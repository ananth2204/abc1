{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012142000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1175720, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 12, "INMDSNAM": "CBT.V500.FILE483.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1175720, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1175720, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE483.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x14\\x04'", "DS1TRBAL": "b'\\xbf\\x84'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\x82\\x00\\x0c\\x03\\x84\\x00\\x02\\x00\\x15'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x00N\\x00N\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 78, "newlines": 78, "modlines": 0, "user": "TRAMSEI"}, "text": "***********************************************************************\nMEMBER   DATE      WHO WHAT\n-------- --------- --- ------------------------------------------------\n$$$$$DOC N/A       RAM THIS MEMBER\n-------- --------- --- ------------------------------------------------\n$QSMS    07.SEP.00 RAM SHORT DESCRIPTION OF QSMS\nQSMS     07.SEP.00 RAM REXX-FUNCTION THAT OBTAINS THE SMS-STATUS OF ALL\n                       DEFINED VOLUMES. RUNS AS TSO-COMMAND OR REXX\nPRINTREG 07.SEP.00 RAM ASM-MACRO USED IN QSMS\nIGDBCD   ??.???.?? GSF SMS-CONFIG MAPPING MACRO BY GILBERT SAINT-FLOUR\n                       USED IN QSMS\nQSMSREXX 07.SEP.00 RAM SAMPLE REXX THAT INVOKES QSMS.\n-------- --------- --- ------------------------------------------------\n$QVTOC   07.SEP.00 RAM SHORT DESCRIPTION OF QVTOC\nQVTOC    07.SEP.00 RAM A CMD-PROCESSOR THAT SCANS ALL ONLINE DASDS AND\n                       BUILDS A LIST OF ALL LOADMODULES.\n                       $$NOTE$$: NEEDS READ ACCESS TO ALL LOADLIBS|\nADDMSG   07.SEP.00 RAM ASM-MACRO USED IN QVTOC\nAIACCTAB 07.SEP.00 RAM FILTER-PGM USED WITH QVTOC\n-------- --------- --- ------------------------------------------------\n$QLPAR   07.SEP.00 RAM SHORT DESCRIPTION OF QLPAR\nQLPAR    07.SEP.00 RAM A TSO CP SHOWING LPAR-INFORMATION FOR ALL CUR-\n                       RENTLY DEFINED PARTITIONS.\nADDMSG   07.SEP.00 RAM ASM-MACRO USED IN QLPAR\nPRINTREG 07.SEP.00 RAM ASM-MACRO USED IN QLPAR\n-------- --------- --- ------------------------------------------------\n$QCMD    07.SEP.00 RAM SHORT DESCRIPTION OF QCMD\nQCMD     07.SEP.00 RAM A TSO COMMANDPROCESSOR THAT ISSUES MVS-COMMANDS\n                       AND TRAPS THE RESPONSE. THE OUTPUT CAN BE WRITTEN\n                       INTO A STEM OF REXX-VARIABLES.\nQCMC     07.SEP.00 RAM SAMPLE REXX THAT USES THE QCMD-FUNCTION\nQCMSCRL  07.SEP.00 RAM SCROLL-ROUTINE FOR THE QCMC-FUNCTION\nQCMP010  07.SEP.00 RAM PANEL FOR THE QCMC-FUNCTION\nQCMDREPL 07.SEP.00 RAM SAMPLE JOB TO RUN QCMD IN BATCH\n-------- --------- --- ------------------------------------------------\nQTOD     07.SEP.00 RAM A TSO COMMANDPROCESSOR SHOWING DATE/TIME IN A\n                       MORE CONVENIENT WAY THAN THE \"TIME\" COMMAND.\nTODPRINT 07.SEP.00 RAM A ASM-MACRO THAT \"PRINTS\" A TOD-STAMP.\n-------- --------- --- ------------------------------------------------\nQ522     07.SEP.00 RAM A TSO COMMANDPROCESSOR PREVENTING YOU FROM BE-\n                       ING LOGGED OFF AFTER JWT EXCEEDED. AUTHORIZED\n-------- --------- --- ------------------------------------------------\nOMTREE   07.SEP.00 RAM REXX DISPLAYING ALL CURRENTLY MOUNTED HFSES AND\n                       THEIR HIERARCHICAL RELATIONSHIP\nOMTREE1  07.SEP.00 RAM PANEL DISPLAYED IN OMTREE\nOMTREEH  07.SEP.00 RAM HELP PANEL FOR THE OMTREE-FUNCTION\n-------- --------- --- ------------------------------------------------\n$INSLINE 07.SEP.00 RAM SHORT DESCRIPTION OF INSLINE\nINSLINE  07.SEP.00 RAM EDIT-MACRO THAT INSERTS LINES INTO DATASETS\n-------- --------- --- ------------------------------------------------\nCATCVTM  07.SEP.00 RAM EDIT-MACRO FOR POSTPROCESSING MCNVTCAT-OUTPUT\n-------- --------- --- ------------------------------------------------\nWORM     07.SEP.00 RAM REXX GAME\nWORMP    07.SEP.00 RAM PLAYGROUND FOR WORM\nWORMH    07.SEP.00 RAM HELP PANEL FOR THE WORM-GAME\n-------- --------- --- ------------------------------------------------\nMM       07.SEP.00 RAM MASTERMIND GAME, WRITTEN IN REXX\nMMP      07.SEP.00 RAM PLAYGROUND FOR MASTERMIND\nMMPH     07.SEP.00 RAM HELP PANEL FOR THE MASTERMIND GAME\n-------- --------- --- ------------------------------------------------\nQUICKIE  07.SEP.00 RAM XMITTED LOADLIB WITH THE ASM-PGMS.\n-------- --------- --- ------------------------------------------------\n$$NOTE$$ THE MM, WORM AND OMTREE-FUNCTIONS SHOULD BE USED WITH A\n         GRAPHIC-TERMINAL OR AN EMULATOR SUPPORTING BOTH APL AND GRAPH.\n-------- --------- --- ------------------------------------------------\n***********************************************************************\n* For further information, please contact me under following address: *\n*                                                                     *\n*                           Thomas Ramseier                           *\n*        FOITT - Swiss Federal Office of Information Technology,      *\n*                    Systems and Telecommunication                    *\n*                          Monbijoustrasse 74                         *\n*                            CH-3003 Berne                            *\n*                            -switzerland-                            *\n* phone: ++41 (0)31 323'01'00         facsimile: ++41 (0)31 325'93'75 *\n*          e-mail (preferred): thomas.ramseier@bit.admin.ch           *\n*                                                             cheers. *\n***********************************************************************\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$#DATE": {"ttr": 519, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04a\\x00G\\x01\\x19\\x00\\x8f\\x01\\x19\\x00\\x8f\\x10U\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf7@@@'", "ispf": {"version": "04.97", "flags": 0, "createdate": "2019-01-08T00:00:00", "modifydate": "2019-01-08T10:55:47", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-497"}, "text": "REGULAR CBT TAPE - VERSION 497    FILE:  483\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT497.FILE483\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 38 MEMBERS COUNTED; CUMULATIVE SIZE IS 10,611 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   01/08/19    10:55:47    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$INSLINE": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x00\\x12\\x00\\x12\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "TRAMSEI"}, "text": "INSLINE\n=======\nInsline is an editmacro that lets you add lines (empty or with data)\nselectively into a dataset or member.\naccepted parameters are:\n<FROM>   first line to be inserted. can be a number,label or .z-var\n         default: 1\n<TO>     last line to be inserted. can be a number, label or .zvar\n         default: .zlast\n<BY>     gap between the lines to be inserted. must be a number.\n         default: 1 (insert 1 line, jump over 1 dataline, insert next)\n<MODE>   either 'X' (for excluded lines) or 'NX' (not excluded)\n         default: none\n\nafter entering the command, you are prompted to enter the data you'd\nlike to have inserted, and, if caps are OFF, whether you'd like it in\nuppercase.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$QCMD": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x00;\\x00;\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 59, "newlines": 59, "modlines": 0, "user": "TRAMSEI"}, "text": "QCMD\n====\nQCMD lets you execute MVS-commands and trap the responses. The commands\ncan be entered either online in TSO or in batchmode. There is a Rexx-\ninterface provided, too, but not as sophisticated as with SYSCMD/GETMSG.\nAnyway, using qcmd you do not have to define gazillions of OPERCMDS-\nprofiles to issue commands other than display.\n\nQcmd accepts 2 ways of entering commands:\n\n  - TSO QCMD mvs_command_w/o_quotes\n    This is the standard form. The mvscommand is issued and qcmd waits\n    1 second for a response. the ouput is delivered in PUTLINE format.\n      e.g. TSO QCMD D A,L or TSO QCMD CF CHP(xx),ONLINE,NOVARY\n\n  - TSO QCMD CMD=(mvs_command_w/o_quotes),T=n,M=x\n    T=n specifies the # of seconds to wait for a commandresponse\n    M=x specifies the output-delivery: M=P (TSO Putline, default)\n                                       M=V (build Array of Rexx-Vars)\n                                       M=B (Both of the above)\n      e.g. TSO QCMD CMD=(RO *ALL,F LLA,REFRESH),T=12\n    To find the names of the rexx-vars created via IKJCT441, see doc\n    in QCMC-Rexx procedure.\n\nQcmd accepts as \"special\" parameter \"GET_REPLIES\". This lists you all\nopen WTORs in your Sysplex and lets you easily extract the reply-ids.\nFurther description in QCMC, too.\nQCMC is kind of a pseudo-console that interacts with qcmd and shows you\nthe output of a mvscommand in the way it appears on the console, but you\nhave ispf-functionalities like splitscreen and scrolling.\n\nRequirements: QCMD needs APF-authorization and has to be put in the\n              AUTHCMD-field of IKJTSOxx.\n              QCMD should reside in a LNKLST-concatenated library\n\nLimitations:  QCMD does not trap unsolicited messages. Some commands\n              deliver more than one MDB as response (e.g. $DI command),\n              so you sometimes will receive messages not belonging to\n              the command issued.\n\nSecurity:     QCMD has the same CMD-authority as the masterconsole.\n              It is *highly* recommended to protect the use of it by\n              RACF (see sample RDEF below)\n\n              RDEF PROGRAM (QCM*) ADDMEM +\n                   ('xxxx.yyyy.zzzz'/VOLSER/NOPADCHK) +\n                   UACC(NONE) OWNER(wwww)\n\n              The Id of the EMCS-Console is NOT the same as the Userid\n              of the caller, the operator-id is QCMD01. if there is\n              already a QCMD01-session active, the next free number is\n              assigned to the operator. this lets you define the qcmd-\n              operator more easily in your subsystems e.g. CICS, NEtview\n              etc. to issue CEMT-commands using qcmd.\n\nQCMDREPL is a sample batchjob that takes a bunch of DASD offline, re-\n         initializes them using ICKDSF, answers the outstanding replies\n         and varies them online afterwards. Nice if you get in some\n         hundreds of new 3390s.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$QLPAR": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "TRAMSEI"}, "text": "QLPAR\n=====\nQLPAR issues a DIAGNOSE x'204' to receive information of all currently\ndefined partitions. It returns # of processors, # of partitions, weigh-\ntening factors and whether the resources are capped. The results are\nreturned via PUTLINE, so they can be trapped by Rexx.\n\nRequirements: QLPAR needs APF-authorization and has to be put in the\n              AUTHCMD-field of IKJTSOxx.\n              QLPAR should reside in a LNKLST-concatenated library\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$QSMS": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x00\\x13\\x00\\x13\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "TRAMSEI"}, "text": "QSMS\n====\nQSMS maps the current sms-configuration and extracts the storagegroup\nof every SMS-defined DASD. QSMS runs as a TSO-Command or can be called\nas a Rexx-Function.  When called as a TSO-Command, QSMS returns the\nVolumename, Storagegroup, Unitaddress, SMS-status and MVS-status. The\noutput is passed via putline, so it can \"Outtraped\". If called as a\nRexx-Function, an three-dimensional array of Rexx-variables is returned.\nSpecify the desired stemname as a parm. QSMSREXX shows you a sample call\nRestriction: the passed stemname may not exceed 32 characters in length.\nReturned variables per arrayelement: (xxxx = stemname, i=element)\n\n     xxxx.vol_ser.i  = Volser\n     xxxx.stor_grp.i = Storagegroup of Volser\n     xxxx.dev_nr.i   = Unitaddress of Volser\n     xxxx.sms_stat.i = SMS-status of Volser\n     xxxx.mvs_stat.i = MVS-status of Volser\n     xxxx.0          = # of elements returned\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$QVTOC": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x002\\x002\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "TRAMSEI"}, "text": "QVTOC\n=====\nQVTOC reads the VTOC of every online dasd and builds a list of all\nloadlibs (DSORG=PO, RECFM=U LRECL=0). Afterwards, the directoryblocks\nof these loadlibs are read and a list of all loadmodules, aliases,\nlibraries and volsers is built. This list is then sorted by modulename.\n\nRestrictions: Neither PDSEs nor HFSes are processed (yet).\n-------------\nQVTOC needs \"READ\" access to all libraries that are to be scanned. In\nour shop, we run the QVTOC-job with the DMS-BACKUP userid as the OWNER\ninstead of granting access to all potential users of QVTOC.\n\nAIACCTAB is a filterprogram, initially written for accounting purposes,\nthat can be called by QVTOC to reduce the amount of dasd and/or libs to\nbe scanned. AIACCTAB checks an entity against a filtervalue (best match-\ning logic) and returns the value associated to the filtervalue.\nWith QVTOC, the value to be returned is either \"DROP\" (bypass) or\n\"PROCESS\". The DDNAME of the filterdataset is passed as parameter of\nthe first call to AIACCTAB.\n\nFollowing rules apply for the filters:\n**     <= general wildcard, (0-n qualifiers with dsns, \"default\" setting\n*      <= wildcard for 1 qualifier or parts of 1 qualifier.\n%      <= wildcard for 1 character (alphanumeric, may not be blank)\n?      <= wildcard for 1 character (numeric, may not be blank)\n\nSample for the volumefilter:\n//VOLFILT   DD  *        DDNAME is passed at 1st call\n;  AIACCTB - TABLE       commentline\nKEYLEN=006,ARGLEN=007    length of key/length of argument returned\n                         this line MUST be the first dataline.\n;  START OF DATA-PORTION  commentline\n**    ,PROCESS           \"Default\": Scan all volumes\nDMS*  ,DROP              bypass all volumenames starting with \"DMS\"\n%%%VIO,DROP              bypass all volumenames ending with \"vio\"\n*9?   ,DROP              bypass all volumes ending with 90-99\n;---+----1----+----2----+----3----+----4----+---  (commentline)         --+----8\n\nSample for the loadlibfilter:\nKEYLEN=044,ARGLEN=007\n;---+----1----+----2----+----3----+----4----+---  (commentline)         --+----8\n**                                          ,PROCESS   default\nSYS%.LINK*                                  ,DROP\nSYS?.LINK*                                  ,PROCESS   incl. sys1.link\n**.LOAD*                                    ,PROCESS   0-n quals, +load*\n\nThe \"default\"-entry is not mandatory, if there is no match, the entity\nis processed. Activate the //ACTTRACE DD to see whether there was a\nmatch, and if yes, which filterentry matched.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE483": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04a\\x003\\x01\\x19\\x00\\x8f\\x01\\x19\\x00\\x8f\\x10U\\x00f\\x00f\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf7@@@'", "ispf": {"version": "04.97", "flags": 0, "createdate": "2019-01-08T00:00:00", "modifydate": "2019-01-08T10:55:33", "lines": 102, "newlines": 102, "modlines": 0, "user": "CBT-497"}, "text": "//***FILE 483 is from Thomas Ramseier and contains a nice           *   FILE 483\n//*           collection of system utilities.  A description of     *   FILE 483\n//*           the programs follows below.                           *   FILE 483\n//*                                                                 *   FILE 483\n//*      $$$$$DOC  THIS MEMBER                                      *   FILE 483\n//*                                                                 *   FILE 483\n//*      $QSMS     SHORT DESCRIPTION OF QSMS                        *   FILE 483\n//*      QSMS      REXX FUNCTION THAT OBTAINS THE SMS STATUS        *   FILE 483\n//*                OF ALL DEFINED VOLUMES. RUNS AS TSO COMMAND      *   FILE 483\n//*                OR REXX                                          *   FILE 483\n//*                (FIXED NOT TO GO INTO AN INFINITE LOOP)          *   FILE 483\n//*                (SG-12/18)                                       *   FILE 483\n//*      PRINTREG  ASM MACRO USED IN QSMS                           *   FILE 483\n//*      IGDBCD    SMS CONFIG MAPPING MACRO BY GILBERT SAINT        *   FILE 483\n//*                FLOUR USED IN QSMS                               *   FILE 483\n//*                                                                 *   FILE 483\n//*      QSMSREXX  SAMPLE REXX THAT INVOKES QSMS.                   *   FILE 483\n//*                                                                 *   FILE 483\n//*      $QVTOC    SHORT DESCRIPTION OF QVTOC                       *   FILE 483\n//*      QVTOC     A CMD PROCESSOR THAT SCANS ALL ONLINE DASDS      *   FILE 483\n//*                AND BUILDS A LIST OF ALL LOAD MODULES.           *   FILE 483\n//*                $$NOTE$$: NEEDS READ ACCESS TO ALL LOADLIBS      *   FILE 483\n//*                                                                 *   FILE 483\n//*      ADDMSG    ASM MACRO USED IN QVTOC                          *   FILE 483\n//*      AIACCTAB  FILTER PGM USED WITH QVTOC                       *   FILE 483\n//*                                                                 *   FILE 483\n//*      $QLPAR    SHORT DESCRIPTION OF QLPAR                       *   FILE 483\n//*      QLPAR     A TSO CP SHOWING LPAR INFORMATION FOR ALL        *   FILE 483\n//*                CURRENTLY DEFINED PARTITIONS.                    *   FILE 483\n//*                                                                 *   FILE 483\n//*      ADDMSG    ASM MACRO USED IN QLPAR                          *   FILE 483\n//*      PRINTREG  ASM MACRO USED IN QLPAR                          *   FILE 483\n//*                                                                 *   FILE 483\n//*      $QCMD     SHORT DESCRIPTION OF QCMD                        *   FILE 483\n//*      QCMD      A TSO COMMANDPROCESSOR THAT ISSUES MVS           *   FILE 483\n//*                COMMANDS AND TRAPS THE RESPONSE. THE             *   FILE 483\n//*                OUTPUT CAN BE WRITTEN INTO A STEM OF             *   FILE 483\n//*                REXX VARIABLES.                                  *   FILE 483\n//*                                                                 *   FILE 483\n//*      QCMC      SAMPLE REXX THAT USES THE QCMD FUNCTION          *   FILE 483\n//*      QCMSCRL   SCROLL ROUTINE FOR THE QCMC FUNCTION             *   FILE 483\n//*      QCMP010   PANEL FOR THE QCMC FUNCTION                      *   FILE 483\n//*      QCMDREPL  SAMPLE JOB TO RUN QCMD IN BATCH                  *   FILE 483\n//*                                                                 *   FILE 483\n//*      QTOD      A TSO COMMAND PROCESSOR SHOWING DATE/TIME        *   FILE 483\n//*                IN A MORE CONVENIENT WAY THAN THE \"TIME\"         *   FILE 483\n//*                COMMAND.                                         *   FILE 483\n//*                                                                 *   FILE 483\n//*      DTOD      AN ADAPTATION OF QTOD WHICH ALLOWS YOU TO        *   FILE 483\n//*                INTERPRET A TIME ENTERED IN DISPLAY STCK         *   FILE 483\n//*                FORMAT:   DTOD D565353F6689C002                  *   FILE 483\n//*                                                                 *   FILE 483\n//*      TODPRINT  A ASM MACRO THAT \"PRINTS\" A TOD STAMP.           *   FILE 483\n//*                                                                 *   FILE 483\n//*      Q522      A TSO COMMANDPROCESSOR PREVENTING YOU            *   FILE 483\n//*                FROM BEING LOGGED OFF AFTER JWT                  *   FILE 483\n//*                EXCEEDED.  AUTHORIZED.                           *   FILE 483\n//*                                                                 *   FILE 483\n//*      OMTREE    REXX DISPLAYING ALL CURRENTLY MOUNTED            *   FILE 483\n//*                HFSES AND THEIR HIERARCHICAL RELATIONSHIP        *   FILE 483\n//*      OMTREE1   PANEL DISPLAYED IN OMTREE                        *   FILE 483\n//*      OMTREEH   HELP PANEL FOR THE OMTREE FUNCTION               *   FILE 483\n//*                                                                 *   FILE 483\n//*      $INSLINE  SHORT DESCRIPTION OF INSLINE                     *   FILE 483\n//*      INSLINE   EDIT MACRO THAT INSERTS LINES INTO               *   FILE 483\n//*                DATASETS                                         *   FILE 483\n//*                (fixed by Peter Glanzmann)                       *   FILE 483\n//*                                                                 *   FILE 483\n//*      CATCVTM   EDIT MACRO FOR POSTPROCESSING MCNVTCAT           *   FILE 483\n//*                OUTPUT                                           *   FILE 483\n//*                                                                 *   FILE 483\n//*      WORM      REXX GAME                                        *   FILE 483\n//*      WORMP     PLAYGROUND FOR WORM                              *   FILE 483\n//*      WORMH     HELP PANEL FOR THE WORM GAME                     *   FILE 483\n//*                                                                 *   FILE 483\n//*      MM        MASTERMIND GAME, WRITTEN IN REXX                 *   FILE 483\n//*      MMP       PLAYGROUND FOR MASTERMIND                        *   FILE 483\n//*      MMPH      HELP PANEL FOR THE MASTERMIND GAME               *   FILE 483\n//*                                                                 *   FILE 483\n//*      QUICKIE   XMITTED LOADLIB WITH THE ASM PGMS.               *   FILE 483\n//*                                                                 *   FILE 483\n//*      $$NOTE$$  THE MM, WORM AND OMTREE FUNCTIONS SHOULD         *   FILE 483\n//*                BE USED WITH A GRAPHIC TERMINAL OR AN            *   FILE 483\n//*                EMULATOR SUPPORTING BOTH APL AND GRAPH.          *   FILE 483\n//*                                                                 *   FILE 483\n//*        For further information, please contact me under         *   FILE 483\n//*        following address:                                       *   FILE 483\n//*                                                                 *   FILE 483\n//*                         Thomas Ramseier                         *   FILE 483\n//*      FOITT   Swiss Federal Office of Information Technology,    *   FILE 483\n//*                  Systems and Telecommunication                  *   FILE 483\n//*                        Monbijoustrasse 74                       *   FILE 483\n//*                          CH 3003 Berne                          *   FILE 483\n//*                           Switzerland                           *   FILE 483\n//*                                                                 *   FILE 483\n//*        phone:     ++41 (0)31 323-01-00                          *   FILE 483\n//*        facsimile: ++41 (0)31 325-93-75                          *   FILE 483\n//*                                                                 *   FILE 483\n//*        e-mail (preferred): thomas.ramseier@bit.admin.ch         *   FILE 483\n//*                                                                 *   FILE 483\n//*                       cheers.                                   *   FILE 483\n//*                                                                 *   FILE 483\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADDMSG": {"ttr": 534, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x00K\\x00K\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 75, "newlines": 75, "modlines": 0, "user": "TRAMSEI"}, "text": "*/********************************************************************/\n*/*                                                                  */\n*/*  ADDMSG MACRO:                                                   */\n*/*  APPENDS A MESSAGE INTO AN USER-GETMAINED AREA.                  */\n*/*                                                                  */\n*/*  PARAMETERS:                                                     */\n*/*  -----------                                                     */\n*/*  3, ALL  POSITIONAL : FIRST FULLWORD OR REG. CONTAINS THE LENGTH */\n*/*                       OF THE MESSAGE TO BE STORED.               */\n*/*                       2ND FULLWORD OR REG. POINTS AT THE START   */\n*/*                       OF THE MESSAGE TO BE STORED.               */\n*/*                       3RD FULLWORD OR REG. POINTS AT THE START   */\n*/*                       OF THE AREA WHERE THE MESSAGE SHOULD BE    */\n*/*                       STORED                                     */\n*/*                                                                  */\n*/*  $$NOTE$$ THESE INPUT-CONVENTIONS MATCH THE OUTPUT OF \"PRINTREG\" */\n*/*                                                                  */\n*/*  FUNCTIONALITY:       THE MACRO PICKS THE LENGTH, SUBTRACTS 1    */\n*/*                       AND THE EXECUTES THE MESSAGE. THE MESSAGE  */\n*/*                       IS THEN STORED INTO A GETMAINED AREA PRE-  */\n*/*                       CEEDED BY A HALFWORD CONTAINING THE LENGTH */\n*/*                       OF THE MESSAGE.                            */\n*/*                                                                  */\n*/*  REGISTER-CONTENTS AT RETURN:   REG. 15 CONTAINS 0, REGISTER 0   */\n*/*                       THE LENGTH OF THE MESSAGE EXCLUDING THE    */\n*/*                       PRECEEDING HALFWORD,  R1 POINTS AT THE     */\n*/*                       END OF THE JUST STORED MESSAGE.            */\n*/*                                                                  */\n*/*  THE MACRO ADDMSG   IS REENTRANT.                                */\n*/*                                                                  */\n*/********************************************************************/\n         MACRO\n&NAME    ADDMSG &MSGLEN,&MSGADDR,&OUTADDR\n.*********************************************************************\n.* SET LOCAL VARIABLES\n.*********************************************************************\n&A       SETA  &SYSNDX             LABEL/FIELD NAME INDEX\n.*\n.******************************************************************\n.* IF THE &PRINTV PARAMETER IS A REGISTER BRANCH TO ISAREG  TO\n.* PROCESS IT.\n.******************************************************************\n.*\n         AIF   (('&MSGLEN' NE '') AND ('&MSGADDR' NE '' ) AND          X\n               ('&OUTADDR' NE '')).CHKMLN\n         MNOTE 8,'ONE OR MORE REQUIRED PARAMETER(S) MISSING'\n         MEXIT\n.*\n.CHKMLN  AIF   ('&MSGLEN'(1,1) NE '(').MLNOREG     NOT REGISTERFORM\n         LR    0,&MSGLEN\n         AGO   .CHKMAD\n.MLNOREG L     0,&MSGLEN\n.*\n.CHKMAD  AIF   ('&MSGADDR'(1,1) NE '(').MANOREG    NOT REGISTERFORM\n         LR    1,&MSGADDR\n         AGO   .CHKOAD\n.MANOREG L     1,&MSGADDR\n.*\n.CHKOAD  AIF   ('&OUTADDR'(1,1) NE '(').OANOREG    NOT REGISTERFORM\n         LR    15,&OUTADDR\n         AGO   .GOTVALS\n.OANOREG L     15,&OUTADDR\n.*\n.GOTVALS ANOP\n         STH   0,0(15)                   STORE PASSED LENGTH OF MSG\n         BCTR  0,0                       SUBTRACT 1 AND ...\n         LR    14,0                      USE R14 FOR EXECUTE (R0 FAILS)\n         EX    14,$ADDMSG_&A._L0010      DO THE EXECUTE\n$ADDMSG_&A._L0010 MVC   2(0,15),0(1)     MOVE BEHIND LENGTH INTO WA\n         LA    14,3(0,14)                ADD 3 (EX. + HALFWORD LENGTH)\n         LR    0,14                      RELOAD R0\n         LR    1,15                      POINT AT BEGIN OF MESSAGE\n         AR    1,0                       AND ADD LENGTH TO POINT AT END\n         XR    15,15                     CLEAR WORKREG\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AIACCTAB": {"ttr": 537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x04$\\x04$\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 1060, "newlines": 1060, "modlines": 0, "user": "TRAMSEI"}, "text": "//T750KQ   JOB (317,04,E150AQ),'RAMSEIER',\n//             MSGLEVEL=(1,1),\n//             CLASS=X,\n//             MSGCLASS=T,\n//             NOTIFY=&SYSUID,\n//             TIME=NOLIMIT\n//*MAIN SYSTEM=SYT\n//*\n//ASM      EXEC PGM=ASMA90,REGION=2048K,\n//          PARM='NODECK,OBJECT,USING(NOWARN)'\n//SYSIN     DD *\n***********************************************************************\n*                                                                     *\n*     AIACCTAB - RETURN A VALUE BASED ON A FILTERED INPUTSTRING       *\n*                                                                     *\n*  PARAMETER-HANDLING:                                                *\n*  -------------------                                                *\n*  AIACCTAB USES THE FOLLOWING LINKAGE-CONVENTIONS:                   *\n*                                                                     *\n*  R1  --> +--------+ --> +---------------+                           *\n*          |PARMADDR|     | PARMFIELD     |                           *\n*          +--------+     +---------------+                           *\n*                                                                     *\n*  PARMADDR: FULLWORD, CONTAINS THE STARTADDRESS OF THE PARMFIELD     *\n*                                                                     *\n*  THE PARMFIELD LOOKS THE FOLLOWING WAY:                             *\n*                                                                     *\n*  FLLDDDDDDDDDDDDDDDDD                                               *\n*  | |        |                                                       *\n*  +-|--------|------------> F: FUNCTIONCODE (LENGTH:1)               *\n*    |        |                                                       *\n*    +--------|------------> L: LENGTH OF THE DATAPORTION             *\n*             |             (W/O FCODE + W/O ITS OWN LENGTH) LEN:2    *\n*             |                                                       *\n*             +------------> D: DATAPORTION, MAXIMUM LENGTH: 97 BYTES *\n*                                                                     *\n*  FUNCTIONCODE;  - I (INIT) FOR THE FIRST CALL, OPENS THE DDNAME RE- *\n*                       FERENCED IN THE DATAPORTION (=FILTER-DS).     *\n*                                                                     *\n*                 - S (SEARCH) CONTAINS THE ARGUMENT TO BE COMPARED   *\n*                       AGAINST THE FILTER-DD                         *\n*                                                                     *\n*                 - T (TERM) LAST CALL, CLOSES+RELEASES THE FILTER-DD.*\n*                                                                     *\n* RETURNED VALUES:                                                    *\n*                                                                     *\n* WITH FUNCTIONCODE I (INIT) NONE, WITH THE OTHER FUNCTIONCODES, THE  *\n* FOLLOWING VALUES ARE RETURNED AT THE ADDRESS OF THE INPUT-PARAMETER:*\n* GEGEBEN:                                                            *\n*                                                                     *\n*  MLLRRRRRRRRRRRRRRRRRR                                              *\n*  | |        |                                                       *\n*  +-|--------|------------> M: MATCHCODE, (LENGTH:1):                *\n*    |        |              M=MATCH, N=NOMATCH                       *\n*    |        |                                                       *\n*    +--------|------------> L: LENGTH OF THE RETURNED VALUE          *\n*             |             (W/O LEN(MATCHCODE + W/O ITS OWN 2 BYTES) *\n*             |                                                       *\n*             +------------> R: RESULT, LENGTH DETERMINED THROUGH THE *\n*                            ARGLEN-KEYWORD IN THE FILTERDATASET.     *\n*                                                                     *\n* FILTERTABLE:                                                        *\n*                                                                     *\n* THE FILTERTABLE HAS TO LOOK THE FOLLOWING WAY:                      *\n* - COMMENTLINES:              ';' ON POS. 1                          *\n* - 1ST DATALINE (MANDATORY):  KEYLEN=NNN,ARGLEN=NNN                  *\n*      KEYLEN AND ARGLEN HAVE BOTH TO BE 3 BYTES IN LENGTH, RIGHTJUS- *\n*      TIFIED AND PADDED TO THE LEFT WITH ZEROES.                     *\n*                                                                     *\n* - DATALINES:   POS. 1-KEYLEN: FILTERSTRING                          *\n*                POS. KEYLEN+1, LENGTH(ARGLEN): VALUE TO BE RETURNED  *\n*                                                                     *\n* - THE FILTERING ALGORITHMS ARE DESCRIBED AT THE LABELS MATCH40*.    *\n*                                                                     *\n* DEBUGGING AID:                                                      *\n*                                                                     *\n* - IF THE DDNAME ACTTRACE IS ALLOCATED, THE FUNCTION RUNS IN \"TRACE\"-*\n*   MODE: THE INPUTSTRING, FILTERSTRIN AND THE RETURNED VALUE WILL BE *\n*   LISTED.                                                           *\n*                                                                     *\n*                                                                     *\n* LINKAGE-CONVENTIONS:  AMODE=24, RMODE=24, REUSABLE, NON-REENTRANT.  *\n*                       AIACCTAB SHOULD RUN IN BATCHMODE.             *\n*                                                                     *\n*                                           27.12.96 $$TRA            *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n*     EQUATES                                                         *\n***********************************************************************\nR0       EQU   0                      WORKREG\nR1       EQU   1                      WORKREG\nR2       EQU   2                      WORKREG\nR3       EQU   3                      WORKREG\nR4       EQU   4                      WORKREG\nR5       EQU   5                      WORKREG\nR6       EQU   6                      WORKREG\nR7       EQU   7                      WORKREG\nR8       EQU   8                      GETMAINED AREA #1\nR9       EQU   9                      GETMAINED AREA #2\nR10      EQU   10                     SUBROUTINE-LINKAGE\nR11      EQU   11                     BASEREG. #1\nR12      EQU   12                     BASEREG. #2\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15                     RETURNCODE\n***********************************************************************\n*     START                                                           *\n***********************************************************************\nAIACCTAB CSECT\nAIACCTAB AMODE 24\nAIACCTAB RMODE 24\n         BAKR  14,0                   ESTABLISH LINKAGE-CONVENTIONS\n         LR    R11,R15                LOAD TEMPORARY BASE TO MY BASE\n         USING AIACCTAB,R11,R12       TELL ASSEMBLER\n         LA    R12,2048               LOAD 2NDRY BASE  ..\n         LA    R12,2048(R12,R11)      W. 2ND 4K\n         LR    R3,R1                  SAVE PASSED PARAMETERS\n*\nMAIN0010 BAL   R10,GETPARMS           LOOK FOR PASSED PARAMETERS\n         CLI   FUNCCODE,C'T'          IS THIS THE LAST CALL ?\n         BE    MAIN0090               (BE=YES, FREEMAIN)\n         LTR   R15,R15                ARE THERE ANY PARMS ?\n         BNZ   ERRMSG                 (BNZ = NO PARMS)\nMAIN0020 BAL   R10,GETDDNAM           LOOK WHETHER DDNAME ALLOCATED\n         LTR   R15,R15                IS IT ?\n         BNZ   ERRMSG                 (BNZ = LIBRARY NOT FOUND)\n         CLI   FUNCCODE,C'I'          IS THIS THE FIRST RUN ?\n         BNE   MAIN0080               (BNE=NO, SO LOOK FOR MATCH)\nMAIN0030 BAL   R10,OPENSKEL           LOOK WHETHER OPEN WAS SUCCESSFUL\n         LTR   R15,R15                WAS IT?\n         BNZ   ERRMSG                 (BNZ = OPEN FAILED)\nMAIN0040 BAL   R10,GETFIRST           GET THE FIRST DATARECORD\n         LTR   R15,R15                FOUND ?\n         BNZ   ERRMSG                 (BNZ = NO PARAMETER-RECORD FOUND)\nMAIN0050 BAL   R10,GETWSTOR           OBTAIN WORKSTORAGE\n         LTR   R15,R15                GOT ?\n         BNZ   ERRMSG                 (BNZ = OBTAIN FAILED)\nMAIN0060 BAL   R10,BUILDTAB           BUILD THE INSTORAGE TABLE\n         LTR   R15,R15                DONE ?\n         BNZ   ERRMSG                 (BNZ = BUILD FAILED)\nMAIN0070 BAL   R10,SORTTAB            SORT THE TABLES (NO RC CHECKED)\n         CLI   FUNCCODE,C'I'          IS THIS THE FIRST RUN ?\n         BE    MAIN0100               (BE=YES, SO NO FURTHER PROCESS)\nMAIN0080 BAL   R10,GETMATCH           CHECK FOR MATCH (NO RC CHECKED)\n         B     MAIN0100\nMAIN0090 BAL   R10,RELWSTOR           RELEASE WORKING STORAGE\n         LTR   R15,R15                FREED ?\n         BNZ   ERRMSG                 (BNZ = RELEASE FAILED)\n         DELETE EP=AIACCTAB\nMAIN0100 DS    0H                     END OF PROGRAM\n         LTR   R15,R15                TEST FOR A SUBROUTINE-RC\n         BZ    ALLDONE                (BZ=RC = ZERO)\nERRMSG   DS    0H                     ERRMSG: SET AN ERRORMESSAGE-WTO\n         LR    R2,R15                 SAVE PASSED SUBROUTINE-RETURNCODE\n         MVC   DLWTO(LEFWTO),EFWTO    CLEAR OUT WTO-WORKAREA\n         MVC   DLWTO+4(L'ERRORMSG),ERRORMSG    MOVE ERRORMSG IN THERE\n         WTO   MF=(E,DLWTO)           ISSUE TH WTO\n         LR    R15,R2                 RELOAD PASSED RETURNCOD\nALLDONE  DS    0H                     ALL SUBROUTINES PASSED, BYEBYE\n         L     R3,PARMFLD             LOAD PARMAREA-STARTADDRESS\n         MVC   0(L'RETVALUE,R3),RETVALUE    MOVE RETURNVALUE THERE\n         PR                           END AIACCTAB + CLEANUP\n*\n         LTORG\n***********************************************************************\n*     EXECUTE                                                         *\n***********************************************************************\n         USING IHADCB,R2\nMOVEDDN1 MVC   DCBDDNAM(0),2(R3)\nMOVESRA1 MVC   SRCHARG(0),2(R3)\nMOVEKEY1 MVC   CURRKEY(0),IREC\nMOVEKEY2 MVC   0(0,R2),CURRKEY\nMOVEARG1 MVC   0(0,R2),0(R5)\nCOMPSRT1 CLC   0(0,R2),0(R5)\nMOVESRT2 MVC   0(0,R9),0(R2)\nSAVESRT1 MVC   SAVEREC(0),0(R2)\nSAVESRT2 MVC   0(0,R2),0(R5)\nSAVESRT3 MVC   0(0,R5),SAVEREC\nTRANSRT1 TR    0(0,R2),TRTTAB02\nTRANMAT1 TRT   0(0,R5),TRTTAB03\nMOVEMAT1 MVC   0(0,R4),0(R5)\nMOVEMAT2 MVC   RETVALUE+3(0),0(R2)\nMOVEACT1 MVC   0(0,R5),0(R2)\n***********************************************************************\n*     SUBROUTINES                                                     *\n***********************************************************************\nGETPARMS ST    R10,SAVE10\n         XR    R15,R15                ASSUME WE HAVE PARMS\n         L     R3,0(,R3)              LOAD PARM START ADDRESS INTO R3\n         ST    R3,PARMFLD             STORE PARAMETER START ADDRESS\n         MVC   FUNCCODE(1),0(R3)      FIRST BYTE IS THE FUNCTIONCODE\n         LA    R3,1(,R3)              BUMP BEHIND IT\n         LH    R4,0(R3)               LOAD LENGTH OF PARM INTO R4\n         LTR   R4,R4                  IS THE PARM-LENGTH ZERO ?\n         BNZ   PARMS010               (BNZ = PARMS FOUND)\n         LA    R15,8                  NO, LOAD RC=8\n         MVC   ERRORMSG(80),ERROR010\nPARMS010 L     R10,SAVE10             RELOAD ENTRYPOINT\n         BR    R10                    BRANCH THERE\n*********************************************************************\n* GETDDNAM:  OBTAIN VARIABLE DDNAME. CALLED 1ST TIME, (FUNCCODE=I), *\n* THIS SUBROUTINE OBTAINS THE DDNAME PASSED BY  CALLER. CALLED ANY  *\n* OTHER TIME, LABEL GETSRCHA IS JUMPED AT AND THE SEARCH-ARGUMENT   *\n* IS WRITTEN INTO A WORKAREA.                                       *\n* THE TIOT IS WALKED THROUGH TO EVALUATE PARAMETER DDNAME. IF NO    *\n* APPROPRIATE DDNAME IS ATTACHED, GETDDNAM TERMINATES W. RC=8.      *\n*********************************************************************\n*\nGETDDNAM ST    R10,SAVE10\n         XR    R15,R15\n         CLI   FUNCCODE,C'I'          IS THIS THE FIRST RUN ?\n         BNE   GETSRCHA               (BNE = NO, GET SEARCHARGUMENT)\n         LOAD  EP=AIACCTAB            LOAD MYSELF TO SAVE WORKFIELDS\n         LA    R2,DCBSKEL             POINT TO SKELETON-DCB\n         USING IHADCB,R2              TELL ASSEMBLER\n         BCTR  R4,0                   R4: PARMLENGTH -1 FOR EXECUTE\n         EX    R4,MOVEDDN1            MOVE THE PASSED DDNAME IN THERE\nTIOTSCAN DS    0H                     CHECK FOR VALID DDNAME\n         MVI   TRACFLAG,C'N'          ASSUME NO TRACE DESIRED\n         MVI   DDNFLAG,C'N'           ASSUME DDNAME NOT FOUND\n         L     R6,PSATOLD-PSA(0)      GET CURRENT TCB\n         L     R6,TCBTIO-TCB(R6)      POINT AT TIOT\n         USING TIOT1,R6               TELL ASSEMBLER\n         LA    R7,TIOENTRY            POINT AT FIRST DDNAME\n         USING TIOENTRY,R7            TELL ASSEMBLER\nTIOT0010 DS    0H\n         XR    R1,R1                  CLEAR WORKREG\n         ICM   R1,1,TIOELNGH          GET LENGTH OF TIOT-ENTRY\n         BZ    TIOT0020               (BZ = LIBRARY NOT FOUND)\n         CLC   TIOEDDNM(8),=CL8'ACTTRACE' IS THE TRACE-DD ALLOCATED ?\n         BNE   TIOT0015               (BNE = NO, TRY NEXT)\n         MVI   TRACFLAG,C'Y'\nTIOT0015 CLC   TIOEDDNM,DCBDDNAM      SEARCH LIBRARY ENTRY\n         BNE   TIOT0016               (BNE = LIBRARY NOT FOUND)\n         MVI   DDNFLAG,C'Y'           INDICATE DDNAME WAS FOUND\nTIOT0016 AR    R7,R1                  STEP TO NEXT ENTRY\n         B     TIOT0010\nTIOT0020 DS    0H\n         CLI   TRACFLAG,C'Y'          IS THE TRACE-DATASET ALLOCATED?\n         BNE   TIOT0025               (BNE = NO, SO DON'T OPEN)\n         OPEN  (ACTTRACE,(OUTPUT))\nTIOT0025 CLI   DDNFLAG,C'Y'           WAS DDNAME FOUND ?\n         BE    ENDPARMS               (BE = YES, CONTINUE)\n         LA    R15,8                  INDICATE LIBRARY NOT FOUND\n         MVC   ERROR020+7(8),DCBDDNAM\n         MVC   ERRORMSG(80),ERROR020\n         B     ENDPARMS\nGETSRCHA DS    0H                    GET THE SEARCH-ARGUMENT\n         XC    SRCHARG(L'SRCHARG),SRCHARG  CLEAR WORKAREA\n         BCTR  R4,0                  SUBTRACT 1 FOR EXECUTE\n         ST    R4,LSRCHARG           STORE EX'ED LENGTH\n         EX    R4,MOVESRA1           DO THE EXECUTE\nENDPARMS DS    0H                    RETURN\n         L     R10,SAVE10\n         BR    R10\n*\n*********************************************************************\n* OPENSKEL:    OPENS THE DDNAME VERIFIED BY ROUTINE GETPARMS        *\n*              IF THE OPEN FAILS, AN ERRORMSG IS GENERATED, RC=8    *\n*********************************************************************\n*\nOPENSKEL ST    R10,SAVE10\n         XR    R15,R15                ASSUME OPEN WILL WORK\n         OPEN  DCBSKEL                OPEN PASSED DDNAME\n         LTR   R15,R15                OPEN SUCCESSFULL ?\n         BZ    OPEN010                (BZ = OPEN SUCCESSFULL)\n         MVC   ERROR030+12(8),DCBDDNAM\n         MVC   ERRORMSG(80),ERROR030  NO,SET AN ERRORMSG\nOPEN010  L     R10,SAVE10             RETURN TO MAIN-PGM\n         BR    R10\n*\n*********************************************************************\n* GETFIRST: GET THE FIRST DATARECORD. THIS ROUTINE STRIPS THE 1ST   *\n* DATARECORD OF THE DDNAME EVALUATED BY GETPARMS. 1ST DATARECORD    *\n* MUST START WITH KEYWORDS 'KEYLEN=XXX,ARGLEN=XXX'. DO NOT CHANGE   *\n* THE LENGTH OF THIS DATAFIELDS, RESULTS MAY BE INPREDICTABLE.      *\n* THE LENGTHS OF THE FILTERSTRING (KEYLEN) AND RETURNVALUE (ARGLEN) *\n* IF RECORD DOES NOT START WITH KEYLEN=, ERROR + RC=8 IS SET.       *\n*********************************************************************\n*                                                                   *\nGETFIRST ST    R10,SAVE10\nGET0010  GET   DCBSKEL,IREC           GET FIRST RECORD\n         CLI   IREC,C';'              IS IT A COMMENT ?\n         BE    GET0010                (BE = YES, IT'S COMMENT)\n         CLC   IREC(7),=CL7'KEYLEN='  DOES DATARECORD START W. KEYLEN=?\n         BNE   GET0030                (BNE = NO, ERROR FOUND)\n         MVC   KEYLEN(L'KEYLEN),IREC+7      KEYLEN=...\n         MVC   ARGLEN(L'ARGLEN),IREC+18     ARGLEN=...\n         PACK  PACKPARM(2),KEYLEN(3)  MAKE DEC. INPUT PACKED\n         ZAP   KEYDW,PACKPARM         ... AND ADD IT TO A FULLWORD\n         CVB   R2,KEYDW               MAKE IT COMPUTABLE\n         ST    R2,WKEYLEN             STORE FOR LATER USE\n         PACK  PACKPARM(2),ARGLEN(3)  MAKE DEC. INPUT PACKED\n         ZAP   ARGDW,PACKPARM         ... AND ADD IT TO A FULLWORD\n         CVB   R2,ARGDW               MAKE IT COMPUTABLE\n         ST    R2,WARGLEN             STORE FOR LATER USE\n         XR    R15,R15\n         B     GET0040\nGET0030  MVC   ERRORMSG(80),ERROR040\n         CLOSE DCBSKEL\n         LA    R15,8\nGET0040  L     R10,SAVE10\n         BR    R10\n         LTORG\n*********************************************************************\n* CLOSFILE: UNUSED AT THE MOMENT                                    *\n*********************************************************************\n*                                                                   *\nCLOSFILE ST    R10,SAVE10\n         XR    R2,R2\n         LR    R2,R15               SAVE PASSED RETURN.-CODE\n         CLOSE DCBSKEL\n         LTR   R2,R2                IS THIS A REGULAR CLOSE ?\n         BE    CLOS010              (BE = YES, R15 WAS ZERO)\nCLOS010  LR    R15,R2               NO, SAVE GENUINE RC\n         L     R10,SAVE10\n         BR    R10\n*\n*********************************************************************\n* GETWSTOR: OBTAIN WORKING STORAGE FOR FILTER-TABLE.                *\n* THIS ROUTINE OBTAINS 100 PAGES (400K) OF PRIVATE AREA STORAGE.    *\n* ROUTINE BUILDTAB WILL USE THESE 100 PAGES.                        *\n*********************************************************************\n*                                                                   *\nGETWSTOR ST    R10,SAVE10\n         XR    R15,R15\n         STORAGE OBTAIN,LENGTH=HUNPAGES,ADDR=(8),LOC=BELOW,            X\n               BNDRY=PAGE           OBTAIN 100 PAGES OF WORKING-STOR.\n         ST    R8,SAVE8\n         LTR   R15,R15              ALL OK ?\n         BZ    GWST010              (BZ = STORAGE OBTAINED)\n         LA    R15,8\n         MVC   ERRORMSG(80),ERROR050  SET ERROR-MSG\nGWST010  L     R10,SAVE10\n         BR    R10\n*\n*********************************************************************\n* BUILDTAB - BUILD AN INSTORAGE TABLE OF ALL FILTERRECORDS.         *\n*            FREE THE INPUT-DDNAME AFTER SUCCESSFULL BUILD.         *\n* EVERY DATARECORD IS READ IN AND TESTET AGAINST SPECIAL-CHARACTERS *\n* '*' (GENERIC) '%' (WILDCARD) OR '?' (NUMERIC). TO MAKE THE TABLE  *\n* SORTEABLE, THE SPECIALS ARE TRANSLATED: '*' -> X'FF'              *\n*                                         '%' -> X'FE'              *\n*                                         '?' -> X'FD'              *\n*                                         ' ' -> X'FC'              *\n* THE TRANSLATED ENTRIES ARE THEN WRITTEN INTO GETMAINED AREA AND   *\n* THE INPUT-DDNAME IS FREED THEREAFTER.                             *\n*                                                                   *\n*********************************************************************\n*                                                                   *\nBUILDTAB ST    R10,SAVE10\n         L     R3,WKEYLEN             LOAD LENGTH OF KEY\n         L     R4,WARGLEN             LOAD LENGTH OF RETURNVALUE\n         BCTR  R4,0                   SUBTR. 1 FOR EXECUTE\n         BCTR  R3,0                   SUBTRACT 1 FOR EXECUTE\n         LR    R2,R8                  POINT TO TOP OF GETM'D AREA\n         XR    R6,R6                  ENTRIES-COUNTER\nTAB0010  XC    IREC,IREC              GET RECORD\n         GET   DCBSKEL,IREC           GET RECORD\n         CLI   IREC,C';'              IS IT COMMENT ?\n         BE    TAB0010                (BE = YES, COMMENTLINE)\n         LA    R6,1(,R6)              ADD 1 TO REC-COUNTER\n         ST    R2,SAVE2               SAVE R2 BEC. OF TRT ||\n         EX    R3,MOVEKEY1            MOVE IN DATA-PORTION\n         TRT   CURRKEY,TRTTAB00       ARE THERE ANY SPECIAL-CHARACTERS?\n         BZ    TAB0020                (BZ = NO SPECIAL CHARS)\n         TR    CURRKEY,TRTTAB01       TRANSLATE THE SPECIAL-CHARS\nTAB0020  L     R2,SAVE2               RESTORE R2 AFTER TRT||\n         EX    R3,MOVEKEY2            WRITE TRANSLATED KEY INTO WSTOR\n         A     R2,WKEYLEN             BUMP BEHIND IT\n         LA    R5,IREC                POINT TO INPUT RECORD\n         A     R5,WKEYLEN             BUMP BEHIND KEY\n         LA    R5,1(R5)               ADD 1 (BUMP OVER ',')\n         EX    R4,MOVEARG1            WRITE INTO GETMAINED AREA\n         A     R2,WARGLEN             BUMP BEHIND IT\n         B     TAB0010                GET NEXT RECORD\nEOF      CLOSE DCBSKEL                CLOSE LIBRARY\n         XR    R15,R15                ASSUME EVERYTHING WENT OK\n         CR    R8,R2                  NO DATARECORDS ?\n         BNE   TAB0030                (BNE = YES, WE HAVE RECORDS)\n         MVC   ERRORMSG(80),ERROR060  SET ERROR-MSG\n         STORAGE RELEASE,LENGTH=HUNPAGES,ADDR=(8)\n         LA    R15,8\nTAB0030  L     R10,SAVE10\n         BR    R10\n*\n*********************************************************************\n* SORTTAB - THIS SUBROUTINE SORTS THE INPUTFILE:                    *\n* LOGIC: R2 POINTS TO THE 1ST RECORD                                *\n*        R5 POINTS TO THE 2ND RECORD                                *\n*        IS THE 1ST RECORD \"SMALLER\" THAN THE 2ND?                  *\n*        YES: GET NEXT RECORD INTO R5                               *\n*        NO: EXCHANGE R2 RECORD W. R5 RECORD                        *\n*        R6:INNER-LOOPCOUNTER (NR.OF RECORDS-NR. OF RECORDS SORTED) *\n*        IF R6 IS ZERO, R2 POINTS TO THE \"LOWEST\" RECORD. THIS ONE  *\n*        IS WRITTEN INTO THE 2ND TABLE (POINTED TO BY R9) .         *\n*        R6 IS THEN DECREASED BY ONE, R2 POINTS TO 2ND ENTRY,       *\n*        R5 POINTS TO THE THIRD. THE WHOLE THING CONTINUES WHILE    *\n*        R7 IS STILL > 0.                                           *\n*        R7: OUTER-LOOPCOUNTER (NR. OF TIMES TO WALK THROUGH TABLE) *\n*        R7: IS R6-1 AT FISRST WALKTHROUGH                          *\n*********************************************************************\n*\nSORTTAB  ST    R10,SAVE10\n         ST    R6,SAVE6               # OF RECORDS\n         SR    R2,R8                  R2-R8 = EFF. LENGTH OF W-STOR\n         L     R4,WKEYLEN             R4 ...\n         A     R4,WARGLEN                ... IS THE CURRENT LINELENGTH\n         ST    R4,LINELEN             STORE IT FOR LATER USE\n         STORAGE OBTAIN,LENGTH=(2),ADDR=(9),LOC=BELOW,BNDRY=PAGE\n         ST    R9,SAVE9               STORE ENTRYPOINT AND ....\n         ST    R2,SAVE2               .... STORAGESIZE\nSORT010  DS    0H                     MOVE 1ST KEY INTO G'MND AREA\n         L     R3,WKEYLEN             LOAD LENGTH OF KEY\n         BCTR  R3,0                   SUBTRACT 1 FOR EXECUTE\n         LR    R2,R8                  POINT TO 1ST GETMAINED AREA WREG1\n         LR    R5,R8                  POINT TO 1ST GETMAINED AREA WREG2\n         L     R6,SAVE6               LOAD NUMBER OF ENTRIES IN TABLE\n         LR    R7,R6                  SAME FOR OUTER-LOOP\n         BCTR  R7,0                   SUBTR. 1 FOR OUTER LOOP\n         LTR   R7,R7                  DO WE HAVE JUST ONE ENTRY ?\n         BZ    SORT040                (BZ = YES, QUITE EASY TO SORT)\n*LOOP                                 START OF OUTER LOOP\nSORT015  DS    0H\n         BCTR  R6,0                   DECREASE INNER LOOP-COUNT AND ..\n         ST    R6,CURRCNT             SAVE THE NEW VALUE\n*--LOOP\nSORT020  DS    0H                     START OF INNER LOOP\n         AR    R5,R4                  POINT TO NEXT BUT ONE-ENTRY\n         EX    R3,COMPSRT1            COMP. WHETHER CURRENT IS LOW\n         BL    SORT030                (BL=R2-> IS LOW, GET NEXT)\n         BCTR  R4,0                   NO, NEXT RECORD IS LOW, SO\n         EX    R4,SAVESRT1            SAVE CURRENT LOWEST RECORD,\n         EX    R4,SAVESRT2            MOVE NEW LOWEST RECORD,\n         EX    R4,SAVESRT3            RELOAD NEXT REC. W. GENUINE LOW-\n         LA    R4,1(,R4)              EST RECORD. RE-INCREASE LENGTH\nSORT030  DS    0H                     GET NEXT INPUTLINE\n         BCT   R6,SORT020             RETRY W. NEXT RECORD.\n*--ENDLOOP                            END OF INNER LOOP\n         EX    R3,TRANSRT1            TRANSLATE THE INPUT BACK\n         BCTR  R4,0                   DECREASE FOR EXECUTE AND ...\n         EX    R4,MOVESRT2            ... WRITE THE LOWEST VALUE INTO\n         LA    R4,1(,R4)              ... GETMAINED AREA. RE-INCREASE\n         AR    R9,R4                  PREPARE FOR NEXT LOWEST ENTRY\n         AR    R2,R4                  BUMP OVER WRITTEN LOWEST ENTRY\n         LR    R5,R2                  SAME W. POINTER 1\n         L     R6,CURRCNT             LOAD NEW DECREASED INNERLOOP-CNT\n         BCT   R7,SORT015             AND RESTART\n*ENDLOOP                              END OF OUTER LOOP.\nSORT040  DS    0H                     WRITE LAST RECORD\n         EX    R3,TRANSRT1            TRANSLATE THE INPUT BACK\n         BCTR  R4,0                   WRITE THE LAST LINE ...\n         EX    R4,MOVESRT2            ... INTO GETMAINED TABLE #2\n         LA    R4,1(,R4)              SAVE OR. LENGTH FOR FURTHER USE\n         L     R10,SAVE10\n         BR    R10\n*********************************************************************\n* GETMATCH: THE MAIN SUBROUTINE OF THIS PROGRAM. GETMATCH PERFORMS  *\n* THE FOLLOWING FUNCTIONS: THE INPUTPARM IS SEPARATED INTO A MAX. OF*\n* 16 QUALIFIERS OF 20 BYTES (16 DATA + 4 LENGTH-BYTES). SEPARATION- *\n* CHARACTER IS '.'. THIS IS DONE FOR THE FILTERSTRING, TOO.         *\n* THEN, THE QUALIFIERS ARE TESTED AGAINST EACH OTHERS. IF THERE     *\n* IS A GENERIC-CHAR (* IN QUALIFIER, ** IN WHOLE ENTRY), THE REMAIN-*\n* ING PART OF THE QUALIFIER OR ENTRY IS REVERSED TO FULLFILL ISPF-  *\n* MATCH CRITERIA.(ATITRA.**.CNTL MATCHES ATITRA.SYS9.CNTL.CNTL ONLY,*\n* IF ALL QUALIFIERS ARE REVERSED).                                  *\n* THE LOGIC OF THE QUALIFIER-MATCHES IS DESCRIBED BELOW (MATCH040)  *\n* IF THE PARAMETERSTRING MATCHES THE FILTERSTRING, A RETURNVALUE IS *\n* PLACED INTO FIELD RETVALUE, PRECEEDED BY A 1-BYTE MATCH-FIELD,    *\n* (M = MATCH OCCURRED, N=NOMATCH), THEN BY A 2-BYTE LENGTH-FIELD.   *\n* IF NO MATCH OCCURS, X'00' IS RETURNED.                            *\n*********************************************************************\n*                                                                   *\nGETMATCH ST    R10,SAVE10\n         L     R3,LSRCHARG            LOAD LENGTH OF SEARCHARGUMENT\n         LA    R5,SRCHARG             POINT TO PASSED SEARCH-ARGUMENT\n         LA    R4,QUALIVAL            POINT TO TOP OF QUALIFIERTABLE\n         LR    R1,R3                  LOAD LENGTH OF ARGUMENT INTO R1\n         LA    R6,1                   R6 = NUMBER OF QUALIFIERS\n*                                     IF 1 THEN INPUT=FILTERSTRING\nMATCH010 EX    R1,TRANMAT1            SEARCH FOR THE NEXT '.'\n         BZ    MATCH015               (BZ = NO (MORE) '.')\n         XC    0(LTABDATA-4,R4),0(R4) BLANK OUT ENTRY\n         SR    R1,R5                  R5=EP, R1= 1ST '.' R5-R1=LENGTH\n         BCTR  R1,0                   SUBTRACT 1 FOR EXECUTE\n         EX    R1,MOVEMAT1            MOVE QUALIFIER INTO TABLE\n         STCM  R1,15,LTABDATA-4(R4)   STORE THE LENGTH OF ENTRY\n         LA    R1,2(,R1)              RE-INCR. + BUMP BEHIND '.'\n         AR    R5,R1                  ADD NEW ENTRY TO OLD ENTRY\n         LA    R6,1(,R6)              # OF QUALIFIERS\n         SR    R3,R1                  SUBTRACT EX'ED LN. FROM TOTAL\n         LR    R1,R3                  RELOAD RESULT (NEW LENGTH F.TRT)\n         LA    R4,LTABDATA(,R4)       POINT TO NEXT-ENTRY\n         B     MATCH010               RE-TRANSLATE-AND TEST\nMATCH015 DS    0H                     END OF TRT-LOOP\n         LR    R2,R5                  POINT TO START OF PASSED PARMS\n         AR    R2,R3                  ADD REMAINING BYTES\nMATCH15A CLI   0(R2),C' '             IS THERE A BLANK AT THE END ?\n         BNE   MATCH016               (BNE = NOT BLANK, ALL DATA NOW\n         BCTR  R2,0                   YES, DECREASE\n         BCT   R3,MATCH15A            RETRY\nMATCH016 DS    0H                     SUBTR. 1 TO EXECUTE LAST QUALI.\n         XC    0(LTABDATA-4,R4),0(R4)\n         EX    R3,MOVEMAT1            MOVE QUALIFIER INTO TABLE\n         STCM  R3,15,LTABDATA-4(R4)   STORE LENGTH OF LAST QUALIFIER\n         ST    R6,PARMQUAL            # OF QUALIFIERS INPUT-PARMM\n*\nMATCH017 DS    0H                     NOW START WORK FOR FILTERLIST\n         L     R5,SAVE9               POINT TO PASSED SEARCH-ARGUMENT\n         L     R7,SAVE6               POINT TO PASSED SEARCH-ARGUMENT\nMATCH020 L     R3,WKEYLEN             LOAD KEY-LENGTH IN TABLE\n         BCTR  R3,0                   SUBTRACT 1 (POINT TO LAST POS)\n         AR    R3,R5                  ADD CURRENT TABLE-ENTRY\nMATCH018 CLI   0(R3),C' '             BLANK AT THE END ?\n         BNE   MATCH019               (BNE=NO, ALL DATA FROM HEREON)\n         BCT   R3,MATCH018            YES, ITS BLANK. DECREASE + RETRY\n         L     R3,WKEYLEN             ALL BLANKS, LOAD ENTRY-LENGTH\nMATCH019 SR    R3,R5                  SUBTRACT ENTRYPOINT(R3=EFF. L')\n         LA    R4,FILTRVAL            POINT TO TOP OF QUALIFIERTABLE\n         LA    R6,1                   R6 = NUMBER OF QUALIFIERS\n         MVI   GENRFLAG,C'N'          ASSUME NOT GENERIC\n         ST    R5,CURRFILT            SEARCH FOR THE NEXT '.'\n         LR    R1,R3                  LOAD LENGTH OF ARGUMENT INTO R1\nMATCH021 EX    R1,TRANMAT1            SEARCH FOR THE NEXT '.'\n         BZ    MATCH025               (BZ = NO (MORE) '.')\n         XC    0(LTABDATA,R4),0(R4)   BLANK OUT ENTRY TO WRITE IN\n         SR    R1,R5                  R5=EP, R1= 1ST '.' R1-R5=LENGTH\n         BCTR  R1,0                   SUBTRACT 1 FOR EXECUTE\n         EX    R1,MOVEMAT1            MOVE QUALIFIER INTO TABLE\n         STCM  R1,15,LTABDATA-4(R4)   STORE LENGTH AT END OF TABLE-ENT.\nMATCH022 LA    R1,2(,R1)              RE-INCR. + BUMP BEHIND '.'\n         AR    R5,R1                  ADD NEW ENTRY TO OLD ENTRY\n         LA    R6,1(,R6)              # OF QUALIFIERS\n         SR    R3,R1                  SUBTRACT EX'ED LN. FROM TOTAL\n         LR    R1,R3                  RELOAD RESULT (NEW LENGTH F.TRT)\n         LA    R4,LTABDATA(,R4)       POINT TO NEXT ENTRY\n         B     MATCH021               RE-TRANSLATE\nMATCH025 DS    0H                     NOW WRITE IN THE LAST QUALIFIER\n         XC    0(LTABDATA,R4),0(R4)   BLANK OUT THE ENTRY\n         EX    R3,MOVEMAT1            MOVE QUALIFIER INTO TABLE\n         STCM  R3,15,LTABDATA-4(R4)   STORE THE LENGTH AT TABLEEND\n         ST    R6,FILTQUAL            # OF QUALIFIERS INPUT-PARMM\n         STM   R2,R7,SAVE2TO7         STORE SUBROUTINES REGISTERS\n         B     MATCH040               BRANCH TO CHECK FOR A MATCH\nMATCH035 DS    0H                     NO MATCH FOUND, TRY NEXT\n         LM    R2,R7,SAVE2TO7         RESTORE \"DAMAGED\" REGISTERS\n         L     R5,CURRFILT            LOAD CURRENT FILTER-DATASET\n         A     R5,LINELEN             ADD ONE LINE\n         BCT   R7,MATCH020            # OF ATTEMPTS TO MADE\n         XC    RETVALUE,RETVALUE      NO MATCH OCCURRED, RETURN X'00'\n         MVI   RETVALUE,C'N'          INDICATE NOMATCH\n         B     MATCH037               NO FILTERVALUE FOUND\nMATCH036 DS    0H                     MATCH036: FILTER MATCHED\n         L     R2,CURRFILT            POINT TO CURRENT FILTERENTRY\n         A     R2,WKEYLEN             ADD LENGTH OF KEY\n         LR    R3,R2                  SAVE IT INTO R3\n         L     R4,WARGLEN             LOAD LENGTH OF RETURNVALUE\n         BCTR  R4,0                   SUBTRACT ONE (-> LAST DATAFIELD)\n         AR    R3,R4                  ADD IT TO R3 (R3=END OF LINE)\nMATCH36A CLI   0(R3),C' '             IS THERE A BLANK AT THE END ?\n         BNE   MATCH36B               (BNE=NO, DATA IS FOUND)\n         BCTR  R3,0                   STILL BLANK, TRY NEXT\n         BCT   R4,MATCH36A            RETRY\nMATCH36B XC    RETVALUE,RETVALUE      CLEAR-OUT RETURNVALUE\n         MVI   RETVALUE,C'M'          INDICATE MATCH\n         LTR   R4,R4                  IS THERE ANY DATA ?\n         BZ    MATCH037               (BZ=NO MATCH, BUT ONLY BLANKS)\n         LA    R4,1(,R4)              ADD 1 TO STORE EFFECTIVE LENGTH\n         STCM  R4,3,RETVALUE+1        AT THE TOP OF RETVALUE\n         BCTR  R4,0                   SUBTRACT 1 FOR EXECUTE\n         EX    R4,MOVEMAT2            MOVE DATAPORTION THERE\nMATCH037 DS    0H                     END OF SUBROUTINE\n         CLI   TRACFLAG,C'Y'          DO WE HAVE TO TRACE ?\n         BNE   MATCH038               (BNE = NO, JUST RETURN)\n         XC    OREC,OREC\n         MVC   OREC(1),RETVALUE\n         LA    R5,OREC+2\n         LA    R2,RETVALUE+3          POINT TO RETURN-VALUE\n         L     R3,WARGLEN\n         EX    R3,MOVEACT1            DO THE EXECUTE\n         AR    R5,R3                  BUMP BEHIND INPUT-PARM\n         MVI   0(R5),C' '\n         LA    R5,1(,R5)              SPARE-ENTRY\n         L     R2,PARMFLD             LOAD PARAMETER ADDRESS\n         LA    R2,3(,R2)              BUMP BEHIND HEADER\n         L     R3,LSRCHARG            LOAD EX'ED LENGTH\n         EX    R3,MOVEACT1            DO THE EXECUTE\n         AR    R5,R3                  BUMP BEHIND IT\n         LA    R5,1(,R5)              EXECUTED LENGTH+1\n         MVI   0(R5),C' '\n         LA    R5,1(,R5)              SPARE-ENTRY\n         CLI   RETVALUE,C'N'          IS IT A NOMATCH ?\n         BE    MATCH37P               (BE = YES, WRITE NO FILTER)\n         L     R2,CURRFILT            LOAD CURRENT FILTER ADDRESS\n         L     R3,WKEYLEN             LOAD LENGTH OF FILTER-ENTRY\n         BCTR  R3,0\n         EX    R3,MOVEACT1            DO THE EXECUTE\nMATCH37P PUT   ACTTRACE,OREC\nMATCH038 L     R9,SAVE9               LOAD GETMAINED-AREA POINTER\n         L     R10,SAVE10             RETURN TO CALLER\n         XR    R15,R15\n         BR    R10\n**********************************************************************\n* MATCH040: A SUBROUTINE THAT CHECKS FOR A MATCH AGAINST FILTERLIST  *\n* THE LOGIC OF THIS SUBROUTINE IS AS FOLLOWS:                        *\n* '**' IS AN OVERALL-WILDCARD, INDICATING THAT 0-NN QUALIFIERS MAY   *\n*      BE JUMPED OVER. SO IF '**' IS THE LAST QUALIFIER, WE HAVE A   *\n*      MATCH. IF NOT, THE NEXT BUT ONE QUALIFIER OF THE FILTERPARM   *\n*      IS LOADED AND TESTING RE-EXECUTES WITH NEW QUALIFIER.         *\n*                                                                    *\n* '*'  IS A GENERIC-CHARACTER, INDICATING THAT 0-NN CHARACTERS IN A  *\n*      QUALIFIER MAY BE JUMPED OVER. IF * IS THE LAST CHARACTER      *\n*      WHITHIN THE QUALIFIER, THERE'S A QUALIFIER-MATCH. OTHERWISE   *\n*      THE NEXT BUT ONE CHARACTER IS LOADED AND FURTHER TESTING      *\n*      OCCURS.                                                       *\n*                                                                    *\n* '%'  IS A WILDCARD, INDICATING THAT THE NEXT CHARACTER MAY BE JUM- *\n*      PED. THERE  M U S T  BE A VALID SIGN (\u00ac= X'00') TO FULLFILL   *\n*      THE REQUIREMENT. BLANK (X'40') IS A VALID CHARACTER, TOO.     *\n*                                                                    *\n* '?'  IS A NUMERIC WILDCARD (NUMBERS 0-9).                          *\n*                                                                    *\n* SAMPLE:   PARM: SLAESIN.ISS.CNTL72                                 *\n*           FILTER: **.ISS.CNT*      -->  MATCH                      *\n*           FILTER: **.IS%.CNTL      -->  NOMATCH                    *\n*           FILTER: SLAE*.IS%.CNTL?* -->  MATCH                      *\n*           FILTER: %*AE*.ISS.CNTL?? -->  MATCH                      *\n*           FILTER: %*AE*.ISS.CNTL??? --> NOMATCH                    *\n*                                                                    *\n**********************************************************************\n*                                                                    *\nMATCH040 DS    0H                     CHECK FOR A MATCH\n         L     R6,PARMQUAL            R6: # OF INPUTPARM-QUALIFIERS\n         L     R7,FILTQUAL            R7: # OF FILTERVALUE-QUALIFIERS\n         LA    R4,QUALIVAL            R4: POINTS TO 1ST INPUT-QUALI\n         LA    R5,FILTRVAL            R5: POINTS TO 1ST FILTER-QUALI\n         MVI   GENRFLAG,C'N'          '**' - INDICATOR\n         MVI   REVAFLAG,C'N'          REVERSEMODE-INDICATOR\nMATCHQ40 DS    0H\n         STM   R4,R5,SAVE4TO5        STORE GENUINE PARAMETER-POINTERS\n         ICM   R3,15,LTABDATA-4(R4)  LENGTH OF ARGUMENT QUALIFIER\n         LA    R3,1(,R3)             INC. 1, VALUE IS EXECUTED LENGTH\n         ICM   R2,15,LTABDATA-4(R5)  LENGTH OF FILTER QUALIFIER\n         LA    R2,1(,R2)             INC. 1, VALUE IS EXECUTED LENGTH\n         MVI   GENQFLAG,C'N'         ASSUME NOT IN GENERIC QUALI-MODE\n         MVI   SAVEFLAG,C'N'         ASSUME NOT IN GENERIC QUALI-MODE\n         MVI   REVDONE,C'N'          ASSUME NOT IN GENERIC QUALI-MODE\n         CLC   0(2,R5),=CL2'**'      IS THIS AN OVERALL-WILDCARD ?\n         BE    MATCH40X\nMATCH40A DS    0H\n         CLC   0(1,R5),0(R4)         DO THE ACTUAL CHARACTERS MATCH?\n         BE    MATCH40W              (BE = YES, TRY NEXT CHAR)\n         CLI   0(R5),C'%'            DO WE HAVE A WILDCARD ?\n         BE    MATCH40W              (BE = YES, TRY NEXT CHAR)\n         CLI   0(R5),C'?'            DO WE HAVE A NUMERIC ?\n         BNE   MATCH40B              (BE = YES, TRY NEXT CHAR)\n         CLI   0(R4),C'0'            IS INPUT-CHAR >= F0 ?\n         BL    MATCH40B              (BL = NO, LOOK FOR GENERIC-FLAG)\n         CLI   0(R4),C'9'            IS INPUT-CHAR <= F9 ?\n         BNH   MATCH40W              YES, IT IS| TRY NEXT CHAR\nMATCH40B CLI   GENQFLAG,C'Y'         ARE WE IN GENERIC-'MODE'\n         BE    MATCH40V              (BE=YES, TRY NEXT INPUT-CHAR)\n         CLI   0(R5),C'*'            IS THIS A GENERIC ?\n         BNE   MATCH4XA              (BNE=NO, SO IT IS A MISHIT)\n         MVI   GENQFLAG,C'Y'         YES, INDICATE GENERIC-'MODE'\n         BCTR  R2,0                  DECREASE FILTER-LENGTH BY 1\n         LTR   R2,R2                 IS THIS THE LAST FILTERCHAR ?\n         BZ    MATCH40Y              (BZ = YES, WE HAVE A MATCH)\n         LA    R5,1(,R5)             POINT TO NEXT FILTER-CHAR\n         MVI   SAVEFLAG,C'Y'\n         B     MATCH40A              RETRY IN GENERIC-MODE\n*\nMATCH40V LA    R4,1(,R4)             POINT TO NEXT CHAR OF PARAMETER\n         BCT   R3,MATCH40A           RETRY NEXT CHARACTER\n         B     MATCH4XA              NO MORE MATCH FOUND, MISHIT\n*\nMATCH40W CLI   SAVEFLAG,C'Y'         IS THE REVERSEMODE NEEDED ?\n         BNE   MATCH4WA              (BNE=NO, JUMP TO NEXT CHAR)\n         CLI   REVDONE,C'Y'          IS THE REVERSE-STUFF DONE ALREADY?\n         BE    MATCH4WA              (BE = YES, JUMP TO NEXT CHAR)\n         STM   R2,R5,SAVEQUAL        STORE THE USED REGISTERS\n         BCTR  R3,0                  COUNTER HAS NOT YET BEEN DECR.\n         XC    REVQUAL,REVQUAL       CLEAR OUT WORKAREA\n         LA    R2,REVQUAL            POINT THERE\n         AR    R4,R3                 POINT AT END OF QUALIFIER\n         LA    R3,1(,R3)             RE-INCREASE COUNTER\nMATCHRE1 MVC   0(1,R2),0(R4)         MOVE LAST CHARACTER INTO 1ST POS.\n         BCTR  R4,0                  DECREASE QUALIFIERPOINTER\n         LA    R2,1(,R2)             INCREASE WORKAREAPOINTER\n         BCT   R3,MATCHRE1           REDO THE REVERSE-LOOP\n         LM    R2,R5,SAVEQUAL        SAME ...\n         XC    REVFILT,REVFILT       ... PROCEDURE ...\n         LA    R3,REVFILT            ... WITH THE ...\n         BCTR  R2,0                  ... CURRENT ...\n         AR    R5,R2                 ... FILTER ...\n         LA    R2,1(,R2)             ... QUALIFIER .\nMATCHRE2 MVC   0(1,R3),0(R5)         START OF REVERSE ...\n         BCTR  R5,0                  FILTERQUALIFIER-LOOP.\n         LA    R3,1(,R3)             THE FILTERQUALIFIER IS NOW\n         BCT   R2,MATCHRE2           REVERSED, TOO.\n         LM    R2,R5,SAVEQUAL        RESTORE USED REGISTERS.\n         LA    R4,REVQUAL            POINT TO THE REVERSED FIELDS\n         LA    R5,REVFILT            AND SAVE THE NEW POINTERS\n         STM   R2,R5,SAVEQUAL        IN THE WORKAREA\n         MVI   REVDONE,C'Y'          IND. REVERSEMODE IS DONE ALREADY\n         MVI   SAVEFLAG,C'N'         IND. SAVE IS DONE\n         MVI   GENQFLAG,C'N'         INDICATE NO LONGER GENERIC-MODE\n         B     MATCH40A              BRANCH TO COMPARE-LABEL AGAIN\n*                                    USING THE REVERSED STRINGS\nMATCH4WA MVI   SAVEFLAG,C'N'         IND. SAVE IS DONE\n         MVI   GENQFLAG,C'N'         INDICATE NO LONGER GENERIC-MODE\n         LA    R5,1(,R5)             POINT TO NEXT CHAR OF FILTER\n         LA    R4,1(,R4)             POINT TO NEXT CHAR OF PARAMETER\n         BCTR  R2,0                  DEC. FILTER-COUNTER\n         BCT   R3,MATCH40A           RETRY NEXT CHARACTER\n         LTR   R2,R2                 IS FILTER-LENGTH ZERO, TOO\n         BZ    MATCH40Y              (BZ = MATCH, NO MORE FILTERCHARS)\n         BCTR  R2,0                  LAST CHANCE: IS THERE A '*' AT\n         LTR   R2,R2                 THE END OF QUALIFIER ?\n         BNZ   MATCH4XA              (BNZ=STILL > THAN 1 CHAR, MISHIT)\n         CLI   0(R5),C'*'            IS IT A '*' ?\n         BE    MATCH40Y              (BE = YES, SO WE HAVE A MATCH)\nMATCH4XA DS    0H                    MATCH4XA: QUALIFIER MISHIT\n         LM    R4,R5,SAVE4TO5        LOAD START OF TABLE-ENTRIES\n         CLI   GENRFLAG,C'Y'         ARE WE IN A **-LOOP, LAST CHANCE?\n         BNE   MATCH035              (BNE=NO, DEFINITE MISHIT)\n         L     R4,SAVE4TO5           YES, WE ARE, TRY THE LAST CHANCE\n         LA    R4,LTABDATA(,R4)      POINT TO NEXT PARAMETER-QUALIFIER\n         ST    R4,SAVE4TO5           STORE THE NEW POINTER\n         BCT   R6,MATCHQ40           TRY NEXT QUALIFIER\n         B     MATCH035              (NO MORE QUALIES, DEFINITE MISHIT)\nMATCH40X DS    0H                    '**'-ENTRY, BUMP BEHIND AND RETRY\n         MVI   GENRFLAG,C'Y'         INDICATE WE'RE IN GENERIC-MODE\n         STM   R2,R7,SAVEREGS        SAVE ALL BLOODY REGS I NEED |\n         BCTR  R7,0                  SUBTRACT 1\n         LTR   R7,R7                 IS THIS THE LAST QUALIFIER ?\n         BZ    MATCH40Z              HOORRAY, WE HAVE A MATCH |\n         L     R5,SAVE4TO5+4         NO, LOAD GENUINE POINTER\n         LA    R5,LTABDATA(,R5)      LOAD NEXT FILTER-QUALIFIER\n         ST    R5,SAVE4TO5+4         SAVE NEW FILTERPOINTER\n         CLI   REVAFLAG,C'Y'         REVERSE ALREADY DONE ?\n         BE    MATCH4XG              (BE = YES, SO NOP)\n*                                    SPECIAL CASE, REVERSE THE QUALS.\n         MVI   REVAFLAG,C'Y'\n         LM    R2,R7,SAVEREGS        LOAD ALL BLOODY REGS I NEED |\n         LA    R4,WORKREVQ           POINT TO FILTER-QUALIFIER-EXCHANGE\n         XR    R2,R2                 WORK-AREA (UFF|).\n         XR    R3,R3                 CLEAR MULTIPLY-REGS\n         LA    R3,LTABDATA           LOAD MULTIPLICAND (QUALILENGTH)\n         MR    R2,R7                 MULTIPLY W. # OF QUALIES\n         LA    R2,LTABDATA           LOAD ENTRYLENGTH\n         SR    R3,R2                 SUBTRACT FROM RESULT OF MULTIPL.\n         BZ    MATCH4XD              BZ=JUST 1 QUALIFIER LEFT, PROCEED\n         AR    R5,R3                 ADD RESULT TO FILTERPOINTER\n**********************************************************************\n*SPECIAL CASE: LOGIC PROBLEM IN REVERSING QUALIFIERS: IF THE LAST\n*FILTERQUALIFIER IS A SINGLE '*', IT MAY NOT BE REVERSED ||\n*   '**' DOES NOT MATTER BECAUSE IT MAY BE 0 QUALIFIERS, BUT '*' MAY\n*JUST BE A 0-QUALIFIER AT THE END.\n**********************************************************************\n         MVI   LASTSTAR,C'N'         ASSUME NOT A '*' AT THE END\n         CLI   0(R5),C'*'            IS THERE A '*' AT THE LAST QUALI?\n         BNE   MATCH4XB              (BNE=NO, PROCEED)\n         ICM   R1,15,LTABDATA-4(R5)  INSERT LENGTH OF LAST FILTERQUAL\n         LTR   R1,R1                 IS LENGTH(EXECUTED) = 0 ?\n         BNZ   MATCH4XB              (BNZ=NO, MORE THAN JUST A '*')\n         MVI   LASTSTAR,C'Y'         YES, INDICATE NOT TO REVERSE\n         ST    R5,SAVE5              STORE POINTER TO LAST FILTERQUAL\n         BCTR  R7,0                  SUBTRACT 1 FOR LOOP BELOW\n         SR    R5,R2                 (THE LAST '*' WILL BE RE-WRITTEN\n*LOOP                                AT THE END, WHERE IT BELOWS)\n*********************************************************************\n* START OF ORDINARY LOOP\n*********************************************************************\nMATCH4XB XC    0(LTABDATA,R4),0(R4)  CLEAR OUT WORKAREA-FIELD\n         MVC   0(LTABDATA,R4),0(R5)  MOVE THERE THE CURRENT ENTRY\n         AR    R4,R2                 ADD ENTRYLENGTH TO WORKAREA\n         SR    R5,R2                 SUBTR. QUALILENGTH FROM FILTER\n         BCT   R7,MATCH4XB           RE-DO W. NEXT QUALIFIER\n*ENDLOOP\n*********************************************************************\n* SPECIAL CASE OF A '*' AT THE END\n*********************************************************************\n         CLI   LASTSTAR,C'Y'         IS THE LAST FILTERQUALI A '*' ?\n         BNE   MATCHXB1              (BNE=NO, ALL IS REVERSED,PROCEED)\n         L     R5,SAVE5              LOAD POINTER TO '*'\n         LA    R7,1                  SET LOOPCOUNTER TO 1\n         MVI   LASTSTAR,C'N'         RESET REVERSE-FLAG\n         B     MATCH4XB              RE-CALL PREVIOUS LOOP\n*********************************************************************\n* END OF SPECIAL CASE\n*********************************************************************\nMATCHXB1 LA    R4,WORKREVQ           TABLE. LOAD WA-POINTER INTO Q-PTR.\n         L     R5,SAVEREGS+12        POINT TO 1ST QUALIFIER OF FILTER\n         L     R7,SAVEREGS+20        RELOAD # OF QUALIFIERS\nMATCH4XC XC    0(LTABDATA,R5),0(R5)  CLEAR OUT WORKAREA-FIELD\n         MVC   0(LTABDATA,R5),0(R4)  MOVE THERE THE CURRENT ENTRY\n         AR    R4,R2                 ADD ENTRYLENGTH TO WORKAREA\n         AR    R5,R2                 SUBTR. QUALILENGTH FROM FILTER\n         BCT   R7,MATCH4XC           RE-WRITE FILTERQUALIFIERTABLE\n*ENDLOOP\nMATCH4XD DS    0H                    REVERSE DONE (OR NOT NEEDED)\n         LM    R2,R7,SAVEREGS        LOAD THE GENUINE REG-VALUES\n         LA    R5,WORKREVQ           POINT TO TOP OF WORKING-TABLE\n         XR    R2,R2                 CLEAR OUT R2 AND PREPARE IT FOR\n         LA    R3,LTABDATA           THE COMING MULTIPLICATION\n         MR    R2,R6                 MULTIPLY THE ENTRY LENGTH W.\n         LA    R2,LTABDATA           # OF ENTRIES. (R3 = RESULT)\n         SR    R4,R2                 POINT TO START OF CURRENT PARM\n         AR    R4,R3                 ADD RESULT TO PARM-POINTER\nMATCH4XE XC    0(LTABDATA,R5),0(R5)  CLEAR OUT WORKAREA-FIELD\n         MVC   0(LTABDATA,R5),0(R4)  MOVE THERE THE CURRENT ENTRY\n         SR    R4,R2                 (R4=END OF QUALTAB, POINT TO NEXT\n         AR    R5,R2                 PREVIOUS ENTRY)\n         BCT   R6,MATCH4XE           WRITE NEXT ENTRIES\n         L     R5,SAVEREGS+8         POINT TO CURRENT PARAMETERENTRY\n         LA    R4,WORKREVQ           POINT TO TOP OF REVERSE-WORKAREA\n         L     R6,SAVEREGS+16        LOAD # OF QUALIFIERS\nMATCH4XF XC    0(LTABDATA,R5),0(R5)  CLEAR OUT PARAMETER-QUALIFIER\n         MVC   0(LTABDATA,R5),0(R4)  MOVE THE REVERSED ENTRY THERE\n         AR    R4,R2                 INCREASE PARAMETER-QUALIFIER\n         AR    R5,R2                 INCREASE WORKAREA-POINTER\n         BCT   R6,MATCH4XF           REDO WITH NEXT ENTRY\n         LM    R2,R7,SAVEREGS        RELOAD DAMAGED REGISTERS\nMATCH4XG DS    0H                    END OF REVERSE-ACTION\n         B     MATCHQ40              RETRY |\n*\nMATCH40Y DS    0H                    MATCH40Y: QUALIFIER MATCHES |\n         LM    R4,R5,SAVE4TO5        LOAD START OF TABLE-ENTRIES\n         LA    R4,LTABDATA(,R4)      LOAD NEXT PARAMETER-QUALIFIER\n         LA    R5,LTABDATA(,R5)      LOAD NEXT FILTER-QUALIFIER\n         STM   R4,R5,SAVE4TO5        STORE NEW ENTRY-POINTS\n         MVI   GENRFLAG,C'N'         GENERIC REQUEST IS SATISFIED NOW\n         BCTR  R7,0                  SUBTRACT 1\n         BCT   R6,MATCHQ40           R6=0: ALL QUALIFIERS MATCH |\n         LTR   R7,R7                 IS THIS THE LAST FILTERQUAL?\n         BZ    MATCH40Z              NO, IT IS A MISHIT\n         BCTR  R7,0                  LOOK WHETHER LAST QUAL IS * OR **\n         LTR   R7,R7                 IS THIS NOW THE LAST FILTERQUAL?\n         BNZ   MATCH035              (BNZ=NO,DEFINITE MISHIT)\n         L     R5,SAVE4TO5+4         POINT TO LAST ENTRY\n         ICM   R4,15,LTABDATA-4(R5)  LOAD EXECUTED LENGTH OF LAST QUAL\n         LA    R4,1(,R4)             ADD 1 FOR LOOPCOUNTER\nMATCH4Y1 CLI   0(R5),C'*'            IS THERE A WILDCARD SET ?\n         BNE   MATCH035              (BNE = NO, DEFINITE MISHIT)\n         LA    R5,1(,R5)             YES, TRY NEXT CHARACTER\n         BCT   R4,MATCH4Y1           REDO LOOP\nMATCH40Z DS    0H\n         B     MATCH036\n         LTORG\n*                                                                    *\n**********************************************************************\n* RELWSTOR: RELEASE OBTAINED WORKAREAS                               *\n**********************************************************************\n*                                                                    *\nRELWSTOR ST    R10,SAVE10\n         XR    R15,R15\n         L     R8,SAVE8\n         STORAGE RELEASE,LENGTH=HUNPAGES,ADDR=(8)\n         LTR   R15,R15              ALL OK ?\n         BZ    RWST010              (BZ = STORAGE RELEASED)\n         LA    R15,8\n         MVC   ERRORMSG(80),ERROR070  SET ERROR-MSG\nRWST010  L     R9,SAVE9               RELOAD ORIGINAL POINTER THERE\n         L     R2,SAVE2               RELOAD LENGTH OF 2ND TABLE\n         STORAGE RELEASE,LENGTH=(2),ADDR=(9)\n         CLI   TRACFLAG,C'Y'\n         BNE   RWST015\n         CLOSE ACTTRACE\nRWST015  L     R10,SAVE10\n         BR    R10\n         LTORG\n*                                                                    *\n**********************************************************************\n*     CONSTANTS                                                      *\n**********************************************************************\n*                                                                    *\nTRTTAB00 DC    XL256'00'\n         ORG   TRTTAB00+C'*'\n         DC    X'FF'\n         ORG   TRTTAB00+C'%'\n         DC    X'FE'\n         ORG   TRTTAB00+C'?'\n         DC    X'FD'\n         ORG   TRTTAB00+C' '\n         DC    X'FC'\n         ORG\n*\nTRTTAB01 DC    XL256'00'\n         ORG   TRTTAB01\n         DC    X'000102030405060708090A0B0C0D0E0F'\n         DC    X'101112131415161718191A1B1C1D1E1F'\n         DC    X'202122232425262728292A2B2C2D2E2F'\n         DC    X'303132333435363738393A3B3C3D3E3F'\n         DC    X'404142434445464748494A4B4C4D4E4F'\n         DC    X'505152535455565758595A5B5C5D5E5F'\n         DC    X'606162636465666768696A6B6C6D6E6F'\n         DC    X'707172737475767778797A7B7C7D7E7F'\n         DC    X'808182838485868788898A8B8C8D8E8F'\n         DC    X'909192939495969798999A9B9C9D9E9F'\n         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n         ORG   TRTTAB01+C'*'\n         DC    X'FF'\n         ORG   TRTTAB01+C'%'\n         DC    X'FE'\n         ORG   TRTTAB01+C'?'\n         DC    X'FD'\n         ORG   TRTTAB01+C' '\n         DC    X'FC'\n         ORG\n*\nTRTTAB02 DC    XL256'00'\n         ORG   TRTTAB02\n         DC    X'000102030405060708090A0B0C0D0E0F'\n         DC    X'101112131415161718191A1B1C1D1E1F'\n         DC    X'202122232425262728292A2B2C2D2E2F'\n         DC    X'303132333435363738393A3B3C3D3E3F'\n         DC    X'404142434445464748494A4B4C4D4E4F'\n         DC    X'505152535455565758595A5B5C5D5E5F'\n         DC    X'606162636465666768696A6B6C6D6E6F'\n         DC    X'707172737475767778797A7B7C7D7E7F'\n         DC    X'808182838485868788898A8B8C8D8E8F'\n         DC    X'909192939495969798999A9B9C9D9E9F'\n         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n         ORG   TRTTAB02+X'FF'\n         DC    C'*'\n         ORG   TRTTAB02+X'FE'\n         DC    C'%'\n         ORG   TRTTAB02+X'FD'\n         DC    C'?'\n         ORG   TRTTAB02+X'FC'\n         DC    C' '\n         ORG\n*\nTRTTAB03 DC    XL256'00'\n         ORG   TRTTAB03+C'.'\n         DC    C'.'\n         ORG\n*\nHUNPAGES EQU   100*4096\n*\nERROR010 DC    CL80'NO PARAMETER PASSED. PROGRAM TERMINATES'\nERROR015 DC    CL80'FIRST CALL NEEDS DDNAME + SEARCHARG. PLEASE RETRY'\nERROR020 DC    CL80'DDNAME XXXXXXXX NOT ALLOCATED. PROGRAM TERMINATES'\nERROR030 DC    CL80'OPEN DDNAME XXXXXXXX FAILED. PROGRAM TERMINATES'\nERROR040 DC    CL80'FIRST DATARECORD DOES NOT START W. KEYLEN=. PROGRAMX\n                TERMINATES.'\nERROR050 DC    CL80'STORAGE OBTAIN FAILED. PROGRAM TERMINATES.'\nERROR060 DC    CL80'NO VALID TABLE RECORDS FOUND. PROGRAM TERMINATES.'\nERROR070 DC    CL80'STORAGE RELEASE FAILED. PROGRAM TERMINATES.'\n***********************************************************************\n*     LIST-FORMS                                                      *\n***********************************************************************\nEFWTO    WTO   '                                                       C\n                                ',MF=L\nLEFWTO   EQU   *-EFWTO\n***********************************************************************\n*     DCB'S                                                           *\n***********************************************************************\nDCBSKEL  DCB   DDNAME=XXXXXX,MACRF=GM,EODAD=EOF,DSORG=PS,LRECL=80\nACTTRACE DCB   DDNAME=ACTTRACE,MACRF=PM,DSORG=PS,LRECL=133\n***********************************************************************\n*     WORKING SECTION                                                 *\n***********************************************************************\n*\nGENRFLAG DS    CL1              INDICATES '**' - MODE\nGENQFLAG DS    CL1              INDICATES '*' - FLAG\nSAVEFLAG DS    CL1              INDICATES REG.-SAVE FOR REVERSE-MODE\nREVDONE  DS    CL1              INDICATES REVERSE IS DONE OR NOT\nREVAFLAG DS    CL1              INDICATES ALL QUALIFIERS ARE REVERSED\nLASTSTAR DS    CL1              INDICATES LAST QUALIFIER IS A '*'\nTRACFLAG DS    CL1              INDICATES TRACE-DD ALLOCATED\nDDNFLAG  DS    CL1              INDICATES DDNAME FOUND\n*\nFUNCCODE DS    CL1              PASSED FUNCTION-CODE\nIREC     DS    CL80             INPUT-RECORD\nSRCHARG  DS    CL80             PASSED SEARCH-ARGUMENT\nLSRCHARG DS    F                LENGTH OF SEARCH-ARGUMENT\nCURRKEY  DS    CL80             KEY-VALUE WORKFIELD\nCURRARG  DS    CL80             ARGUMENT-VALUE WORKFIELD\nKEYLEN   DS    CL3              KEYLENGTH DECIMAL\nARGLEN   DS    CL3              ARGUMENTLENGTH DECIMAL\nKEYDW    DS    D                KEYLENGTH PACK-WORKFIELD\nARGDW    DS    D                ARGUMENTLENGTH PACK-WORKFIELD\nPACKPARM DS    PL2'0'           WORKFIELD\nWKEYLEN  DS    F                KEY-LENGTH AS A FULLWORD\nWARGLEN  DS    F                ARGUMENT-LENGTH AS A FULLWORD\n*\nOREC     DS    CL133            TRACE-RECORD\n*\nSAVE2    DS    F                REGISTER SAVEAREA\nSAVE5    DS    F                REGISTER SAVEAREA\nSAVE6    DS    F                REGISTER SAVEAREA\nSAVE8    DS    F                REGISTER SAVEAREA\nSAVE9    DS    F                REGISTER SAVEAREA\nSAVE10   DS    F                REGISTER SAVEAREA\nSAVE4TO5 DS    2F               REGISTER SAVEAREA\nSAVE2TO7 DS    6F               REGISTER SAVEAREA\nSAVEQUAL DS    4F               REGISTER SAVEAREA\nSAVEREGS DS    6F               REGISTER SAVEAREA\nCURRCNT  DS    F                REGISTER SAVEAREA\nCURRFILT DS    F                REGISTER SAVEAREA\nCURENTRY DS    F                REGISTER SAVEAREA\nPARMQUAL DS    F                REGISTER SAVEAREA\nFILTQUAL DS    F                REGISTER SAVEAREA\nLINELEN  DS    F                REGISTER SAVEAREA\nEFFKLEN  DS    F                REGISTER SAVEAREA\nPARMFLD  DS    F                RETURN-ADDRESS\n*\nRETVALUE DS    CL80             RETURN-VALUE\nSAVEREC  DS    CL80             SORT-ENTRY WORKFIELD\nERRORMSG DS    CL80             ERROR-MSG\nDLWTO    DS    CL(LEFWTO)       WTO-WORKAREA\n*\nLTABDATA EQU   20               LENGTH OF EACH QUALIFIER-ENTRY\n*\nREVQUAL  DS    CL(LTABDATA)     REVERSED PARAMETER QUALIFIER\nREVFILT  DS    CL(LTABDATA)     REVERSED FILTER QUALIFIER\nQUALIVAL DS    16CL(LTABDATA)   PARAMETER QUALIFIER-TABLE\nFILTRVAL DS    16CL(LTABDATA)   FILTER-QUALIFIER-TABLE\nWORKREVQ DS    16CL(LTABDATA)   WORK-TABLE FOR REVERSE OF WHOLE ENTRY\n         PRINT NOGEN\n         DCBD  DSORG=PS\n         IHAPSA\n         IKJTCB DSECT=YES\n         IEFTIOT1\n         END   AIACCTAB\n/*\n//SYSLIB    DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSLIN    DD DSN=&&OBJ,UNIT=SYSDA,DISP=(NEW,PASS),\n//          SPACE=(3200,(200,50)),DCB=(RECFM=FB,BLKSIZE=3200,LRECL=80)\n//SYSPRINT  DD SYSOUT=*,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=3990)\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//*\n//* =====================================================\n//* ===== L I N K A G E   E D I T O R ===================\n//* =====================================================\n//LKED      EXEC PGM=HEWL,REGION=1024K,COND=(0,NE),\n//          PARM='XREF,LIST,REUS'\n//SYSLMOD   DD DISP=SHR,DSN=SA1T.T750K.CBTFILE.LOAD\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(10,3))\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD DSN=&&OBJ,DISP=(OLD,DELETE)\n//          DD *\n  NAME    AIACCTAB(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CATCVTM": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x001\\x001\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "TRAMSEI"}, "text": "/* Rexx */\n/* CATCVTM uses a member of the pds created by MCNVTCAT (Mastercata- */\n/* log conversion Utility) as input and rebuilds IDCAMS-commandblocks*/\n/* after an X aLL;F ALL xxxx command.                                */\n/* e.g: You enter in the SYS1-member \"X ALL;F ALL '******' to find   */\n/*      all entries on the SYSRES. Then, just type CATCVTM and the   */\n/*      macro will reshow you the whole IDCAMS-Command of the entries*/\n/*      so that you can easily build new members and/or DEL ALL X aso*/\nAddress 'ISREDIT'\n'MACRO'\nTrace Off\n'(toline) = LINENUM .zlast'\nIf toline <= 1 Then\n  Exit 12\nDo i = 1 to toline\n  '(excstat) = XSTATUS 'i\n  If excstat = 'NX' Then\n    Do\n      curri = i\n      topdone = 'NO'\n      Do While topdone = 'NO' & curri > 0\n        '(currlin) = LINE 'curri\n        If Pos('- ',currlin) > 0 Then\n          Do\n            'RESET EXCLUDED 'curri curri\n            curri = curri - 1\n          End\n        Else\n          topdone = 'YES'\n      End\n      curri = i\n      botdone = 'NO'\n      Do While botdone = 'NO' & curri <= toline\n        '(currlin) = LINE 'curri\n        If Pos('- ',currlin) > 0 Then\n          Do\n            'RESET EXCLUDED 'curri curri\n            curri = curri + 1\n          End\n        Else\n          Do\n            'RESET EXCLUDED 'curri curri\n            botdone = 'YES'\n          End\n      End\n      i = curri\n    End\nEnd\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DTOD": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x009\\x01\\x00%\\x1f\\x01\\x185?\\x08C\\x01g\\x00\\xd4\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2018-12-19T08:43:39", "lines": 359, "newlines": 212, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//ASM      EXEC PGM=ASMA90,REGION=2048K,\n//          PARM='NODECK,OBJECT,RENT'\n//SYSIN     DD *\nDTOD     TITLE '*** \"DTOD\" *** TSO COMMAND PROCESSOR &SYSDATE'\n***********************************************************************\n* DTOD                                                                *\n* =====                                                               *\n*        THIS PROGRAM ALLOWS YOU TO ENTER A TIME IN STCK FORMAT       *\n*        AND IT INTERPRETS IT AS AN EXACT TIME.                       *\n*                                                                     *\n*        EXAMPLE:   DTOD D565353F6689C002      (16 BYTES)             *\n*                                                                     *\n*        RESULT :   (All stretched out on one line)                   *\n*        Date: Tuesday, 18th of December 2018 (12/18/18 2018.352)     *\n*              Time: 02:56:28.1                                       *\n*                                                                     *\n*        ADAPTED FROM PROGRAM  QTOD  BY  THOMAS RAMSEIER.             *\n*                                                                     *\n*        All I did, was to create the routine GETPARM to convert      *\n*        the parm to STCK format.  Ramseier's code did the rest.      *\n*                                                                     *\n*        Date adapted:  Dec 18, 2018                                  *\n*                                                                     *\n*        Adapter     :  Sam Golob                                     *\n*                                                                     *\n*        Note:  The HEX macro was only included so I could test       *\n*               the converted parm, to see if it matched the 16-byte  *\n*               original parm.  The HEX macro display reverses the    *\n*               GETPARM routine, as follows:                          *\n*                                                                     *\n*        HEX   TESTDDW,8,OURDDW    DISPLAY 8 BYTES OF HEX NUMBERS     *\n*        TPUT  TESTDDW,16          SHOW THE RESULT ON THE SCREEN      *\n*                                                                     *\n*        Assembly requires TODPRINT macro from CBT File 483.          *\n*                                                                     *\n***********************************************************************\n*  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAV4HEX\n         STM   R15,R1,HEXSAVE\n         LA    R1,&FROM\n         LA    R0,&LEN\n         LA    R15,&TO\n         BAL   R4,HEX\n         L     R4,SAV4HEX\n         LM    R15,R1,HEXSAVE\n         MEND\n***********************************************************************\n*     EQUATES                                                         *\n***********************************************************************\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8                      UNUSED\nR9       EQU   9\nR10      EQU   10                     BAL\nR11      EQU   11                     STORAGE OBTAINED AREA\nR12      EQU   12                     BASE #1\nR13      EQU   13                     HIGHER SAVE-AREA\nR14      EQU   14                     BAKR\nR15      EQU   15                     RC\n         EJECT\n***********************************************************************\n*     START                                                           *\n***********************************************************************\nDTOD     CSECT\nDTOD     AMODE 31\nDTOD     RMODE ANY\n         SPACE 2\n         BAKR  14,0                  ESTABLISH LINKAGE-CONVENTIONS\n         LR    R12,R15               LOAD TEMPORARY BASE TO MY BASE\n         USING DTOD,R12              TELL ASSEMBLER\n         LR    R3,R1                 ESTABLISH CPPL'S  ADDRESSABILITY\nGETSTOR  DS    0H\n         STORAGE OBTAIN,LENGTH=LDWORK,LOC=BELOW ET WORKING STORAGE\n         LR    R11,R1                ESTABLISH DSECT'S ADDRESSABILITY\n         USING DWORK,R11             TELL ASSEMBLER\n         BAL   R10,LOADCPPL          SAVE CPPL\n         BAL   R10,GETPARM\n         BAL   R10,CALLMAC           CONVERT TODSTAMP\n         BAL   R10,PUTLBSNS          PRINT IT OUT\n*\nENDIT    DS    0H\n         STORAGE RELEASE,LENGTH=LDWORK,ADDR=(R11)  FREE OBTAINED STOR.\n         XR    R15,R15               SET RC=0\n         PR                          END DTOD + CLEANUP\n*\n***********************************************************************\n*     SUBROUTINES                                                     *\n***********************************************************************\n*\nLOADCPPL ST    R10,SAVE10\n         USING CPPL,R3               GET THE ADDRESSES IN CPPL\n         MVC   CPLCBUF,CPPLCBUF      MOVE COMM.-BUFFER ADDR TO MY AREA\n         MVC   CPLUPT,CPPLUPT        MOVE USERPROFTAB ADDR TO MY AREA\n         MVC   CPLPSCB,CPPLPSCB      MOVE PROT.STEP-CB ADDR TO MY AREA\n         MVC   CPLECT,CPPLECT        MOVE ECT-ADDRESS TO MY AREA\n         L     R10,SAVE10\n         BR    R10\n*\n*\nGETPARM  DS    0H                  CONVERT 16-BYTE DISPLAY FORMAT\n         ST    R10,SAVE10            TO 8-BYTE STCK HEX FORMAT.\n         STM   R1,R3,SAVE123       SAVE WORK REGISTERS\n         LR    R1,R3               REPOINT R1 TO CPPL OR PARM\n         LTR   R1,R1               ANY CPPL OR PARM POINTER?\n         BZ    ENDPARM             B IF NOT.\n         L     R2,0(,R1)           POINT TO BUFFER\n         LTR   R2,R2               ANY?\n         BZ    ENDPARM             B IF NOT.\n         LH    R3,0(R2)            LOAD LENGTH.\n         LTR   R3,R3               ANY?\n         BZ    ENDPARM             B IF NOT.\n         CLI   2(R2),X'00'         COMMAND PROCESSOR INVOCATION?\n         BE    DOTCP\n         LA    R2,2(,R2)           POINT TO PARM.\n         B     PARM\nDOTCP    CH    R3,=H'4'            ANY PARM?\n         BE    ENDPARM             B IF NOT.\n         AH    R2,2(,R2)           POINT TO ...\n         LA    R2,4(,R2)           ... PARM.\n         DROP  R3                    FREE CPPL\nPARM     DS    0H                  CONVERT DISPLAY STCK INTO HEX\n*                                  FROM 16 BYTES INTO 8 BYTES.\n         ST    R1,SAVER1           SAVE\n         ST    R4,SAVER4              WORK REGISTERS\n         MVC   OURDDW2(16),0(R2)     COPY 16-BYTE TIME TO WORK AREA\n         OC    OURDDW2(16),=CL16' '  UPPERCASE.\n         LA    R1,OURDDW           SET UP LOOP TO COPY\n         LA    R3,OURDDWA            ALTERNATE LETTERS TO 2 AREAS.\n         LA    R4,8                SET UP BCT REGISTER\nSPLTLOOP DS    0H                  COPY ALTERNATE LETTERS\n         MVC   0(1,R1),0(R2)         TO TWO\n         MVC   0(1,R3),1(R2)           AREAS.\n         LA    R1,1(,R1)           INCREMENT\n         LA    R3,1(,R3)             POINTERS\n         LA    R2,2(,R2)               AND\n         BCT   R4,SPLTLOOP               LOOP 8 TIMES.\nMERGE    DS    0H                  ISOLATE NIBBLES\n         TR    OURDDW(8),TRTBL1      AND MERGE\n         TR    OURDDWA(8),TRTBL2       THE TWO HALVES\n         OC    OURDDW(8),OURDDWA         TOGETHER.\n* ------------------------------------------------------------------ *\n*                 TEST TO MAKE SURE OUR ROUTINE IS WORKING.          *\n*                    (UNCOMMENT THE NEXT TWO LINES)                  *\n*        HEX   TESTDDW,8,OURDDW    DISPLAY 8 BYTES OF HEX NUMBERS\n*        TPUT  TESTDDW,16          SHOW THE RESULT ON THE SCREEN\n* ------------------------------------------------------------------ *\nENDPARM  LM    R1,R3,SAVE123       RESTORE WORK REGISTERS\n         L     R10,SAVE10\n         BR    R10\n*\n*********************************************************************\n* OBTAIN A TODSTAMP AND CALL THE TODPRINT-MACRO\n*********************************************************************\n*\nCALLMAC  ST    R10,SAVE10          SAVE BACKPOINTER\n         LA    R4,@MLWAREA         A(256-BYTE WORKAREA)\n*        STCK  TODDW               GET TOD-STAMP\n*        TPUT  OURDDW2,16\n         LA    R1,OURDDW           STCK OBTAINED FROM GETPARM\n         TODPRINT (R1),WORKAREA=(R4),                                  X\n               OUTFORM='Date: WHOLEDAY, ANDAY of MONTH YEAR (MT/DD/YY YX\n               EAR.JUL) Time: HH:MM:SS.STAMP(1)',                      X\n               SHIFT=YES,                                              X\n               CAPS=OFF            LET OUTPUT IN MIXED CASE\n         LH    R2,0(R4)            LOAD LENGTH OF DATE/TIMESTAMP\n         STH   R2,ALLMSGS\n         BCTR  R2,0                SUBTRACT 1 FOR EXECUTE\n         EX    R2,*+4              WRITE INTO ALLMSGS\n         MVC   ALLMSGS+2(0),2(R4)\n         L     R10,SAVE10\n         BR    R10\n*        LTORG\n*\n***********************************************************************\n*     PUTLBSNS: DO THE PUTLINE-BUSINESS                               *\n***********************************************************************\nPUTLBSNS ST    R10,SAVE10\n         STFSMODE ON,INITIAL=YES     CLEAR ....\n         STFSMODE OFF                      .... SCREEN\n         LA    R1,IOPLADS            LOAD DYNAMIC IOPL\n         USING IOPL,R1               FILL IT\n         L     R0,CPLUPT             LOAD DYN. USER'S PROFILE TABLE\n         ST    R0,IOPLUPT            STORE IT IN THE IOPL\n         L     R0,CPLECT             LOAD ADDRESS OF DYN. ECT\n         ST    R0,IOPLECT            STORE IT IN THE IOPL\n         LA    R0,ECBADS             LOAD ADDR OF MY ECB TO R3\n         ST    R0,IOPLECB            STORE ADDRESS OF ECBADS IN IOPL\n         MVC   @MLWAREA(L@PUTLIN),@PUTLIN\n         MVC   DTEXTADS(LTEXTADS),TEXTADS   MOVE CONSTANT TO MY AREA\n         LA    R2,ALLMSGS            POINT TO VARIABLE MSG-AREA\n         XC    DTEXTADS(4),DTEXTADS  CLEAR LENGTH-COUNTER\nPUTL010  DS    0H\n         LH    R1,0(R2)              LENGTH OF CURRENT ENTRY INTO R5\n         LTR   R1,R1                 IS IT ZERO ?\n         BZ    PUTL020               (BE = YES, ALL WRITTEN)\nPUTL015  LA    R1,4(,R1)             ADD 4 FOR PUTLINE-HEADER\n         STH   R1,DTEXTADS           STORE INTO WORKAREA\n         BCTR  R1,0                  SUBTRACT 1 FOR EXECUTE\n         EX    R1,PUTLMVC1           DO THE EXECUTE\n         PUTLINE PARM=@MLWAREA,      DO THE PUTLINE                    X\n               OUTPUT=(DTEXTADS,TERM,SINGLE,DATA),MF=(E,IOPLADS)\n         LH    R1,0(R2)              LOAD LENGTH OF MESSAGE\n         LA    R1,2(,R1)             ADD LENGTH OF MSG-LENGTH\n         AR    R2,R1                 ADD CORRECT LENGTH OF MSG-TEXT\n         B     PUTL010               TRY NEXT MESSAGE\nPUTL020  XR    R15,R15\n         L     R10,SAVE10\n         BR    R10\n*        LTORG\n*\nPUTLMVC1 MVC   DTEXTADS+4(0),2(R2)\n***********************************************************************\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *     05098\nHEX      DS    0H                                                       05099\n         ST    R4,SAVER4\n         MVC   1(1,R15),0(R1)        Move byte                          05100\n         UNPK  0(3,R15),1(2,R15)     Unpack                             05101\n         TR    0(2,R15),HEXTAB-240                                      05102\n         LA    R15,2(,R15)           Increment output pointer           05103\n         LA    R1,1(,R1)             Increment input pointer            05104\n         BCT   R0,HEX                Decrement length, then loop        05105\n         MVI   0(R15),C' '           Blank the trailing byte            05106\n         L     R4,SAVER4\n         BR    R4                    Return to caller                   05107\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table                    05108\n         SPACE                                                          05109\n***********************************************************************\n*     CONSTANTS                                                       *\n***********************************************************************\n*\nTEXTADS  DC    H'132'\n         DC    H'0'\n         DC    CL132' '\nLTEXTADS EQU   *-TEXTADS\n*\nTRTBL1   DS    0D\n         DC    XL16'00000000000000000000000000000000'   0\n         DC    XL16'00000000000000000000000000000000'   1\n         DC    XL16'00000000000000000000000000000000'   2\n         DC    XL16'00000000000000000000000000000000'   3\n         DC    XL16'00000000000000000000000000000000'   4\n         DC    XL16'00000000000000000000000000000000'   5\n         DC    XL16'00000000000000000000000000000000'   6\n         DC    XL16'00000000000000000000000000000000'   7\n         DC    XL16'00A0B0C0D0E0F0000000000000000000'   8\n         DC    XL16'00000000000000000000000000000000'   9\n         DC    XL16'00000000000000000000000000000000'   A\n         DC    XL16'00000000000000000000000000000000'   B\n         DC    XL16'00A0B0C0D0E0F0000000000000000000'   C\n         DC    XL16'00000000000000000000000000000000'   D\n         DC    XL16'00000000000000000000000000000000'   E\n         DC    XL16'00102030405060708090000000000000'   F\nTRTBL2   DS    0D\n         DC    XL16'00000000000000000000000000000000'   0\n         DC    XL16'00000000000000000000000000000000'   1\n         DC    XL16'00000000000000000000000000000000'   2\n         DC    XL16'00000000000000000000000000000000'   3\n         DC    XL16'00000000000000000000000000000000'   4\n         DC    XL16'00000000000000000000000000000000'   5\n         DC    XL16'00000000000000000000000000000000'   6\n         DC    XL16'00000000000000000000000000000000'   7\n         DC    XL16'000A0B0C0D0E0F000000000000000000'   8\n         DC    XL16'00000000000000000000000000000000'   9\n         DC    XL16'00000000000000000000000000000000'   A\n         DC    XL16'00000000000000000000000000000000'   B\n         DC    XL16'000A0B0C0D0E0F000000000000000000'   C\n         DC    XL16'00000000000000000000000000000000'   D\n         DC    XL16'00000000000000000000000000000000'   E\n         DC    XL16'00010203040506070809000000000000'   F\n*\n*\n***********************************************************************\n*     MACRO LIST-FORM                                                 *\n***********************************************************************\n@PUTLIN  PUTLINE MF=L\nL@PUTLIN EQU    *-@PUTLIN\n*\n***********************************************************************\n*     COPY    SECTION                                                 *\n***********************************************************************\n***********************************************************************\n*     WORKING SECTION                                                 *\n***********************************************************************\n*\nDWORK    DSECT\n@MLWAREA DS    XL256                  MF=L WORKAREA\n@MACWORK DS    CL256\nMWADDR   DS    A\n*\nSAVE10   DS    F\nSAVER1   DS    F\nSAVE123  DS    3F\nSAVER4   DS    F\nSAV4HEX  DC    F'0'                  Save BAL register for HEX macro\nHEXSAVE  DS    3F                    Register save for HEX macro\n* @SRTESTM DS    F                      A(START SORT STATEMENT)\n*\nCPLCBUF  DS    F                      CPPL-WORKFIELDS\nCPLUPT   DS    F\nCPLPSCB  DS    F\nCPLECT   DS    F\n*\nECBADS   DS    F                      PUTLINE WORKFIELDS\nIOPLADS  DS    4F\nTODDW    DS    D\nOURDDW2  DS    XL16\nOURDDW   DS    XL8\nOURDDWA  DS    XL8\nTESTDDW  DS    XL16\n*\nDTEXTADS DS    CL(LTEXTADS)           MSG-WORKFIELD\nWORKMSG  DS    CL80\n*\n*\nALLMSGS  DS    4CL32000\nLALLMSGS EQU   *-ALLMSGS\n*\nLDWORK   EQU   *-DWORK\n*\n         EJECT\n*\n         IKJCPPL\n         IKJIOPL\n         END   DTOD\n/*\n//SYSLIB    DD DISP=SHR,DSN=CBT.CBT496.FILE483.PDS\n//          DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSLIN    DD DSN=&&OBJ,UNIT=SYSDA,DISP=(NEW,PASS),\n//          SPACE=(3200,(200,50)),DCB=(RECFM=FB,BLKSIZE=3200,LRECL=80)\n//SYSPRINT  DD SYSOUT=*,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=3990)\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//*\n//* =====================================================\n//* ===== L I N K A G E   E D I T O R ===================\n//* =====================================================\n//LKED      EXEC PGM=HEWL,REGION=1024K,COND=(0,NE),\n//             PARM='XREF,LIST,LET,REUS,RENT'\n//SYSLMOD   DD DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(10,3))\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD DSN=&&OBJ,DISP=(OLD,DELETE)\n//          DD *\n  NAME    DTOD(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IGDBCD": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x007\\x007\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "TRAMSEI"}, "text": "         MACRO\n         IGDBCD\nIGDBCD   DSECT                         BASE CONFIG DEFINITION\nBCDP     DS   0CL24                    BASE CONFIGURATION DEF PREFIX\nBCDPID   DS    CL8                     ID = 'IGDBCD'\n         DS    CL2                     UNUSED\nBCDPVER  DS    H                       VERSION OF MACRO\nBCDCNT   DS    F                       COUNT  MUST BE 1\nBCDPTYP  DS    H                       TYPE OF ITEM FOLLOWING HEADER\n         DS    CL2                     RESERVED\nBCDPLEN  DS    F                       LENGTH OF BCDEF\nBCDEF    DS   0CL384                   BASE CONFIGURATION DEF   HDZ11B0\n         DS    CL32                    RESERVED\nBCDFUSER DS    CL8                     USERID OF LAST UPDATER\nBCDFDATE DS    CL10                    DATE OF LAST UPDATE\n         DS    CL6                     RESERVED\nBCDFTIME DS    CL8                     TIME OF LAST UPDATE\nBCDFDESC DS    CL120                   DESCRIPTION\nBCDSUBDF DS   0CL192                   SUB DEFINITION\nBCDFLAGS DS    CL4                     RESERVED FOR FLAGS, ETC\nBCDDEFMC DS   0CL32                    DEFAULT MANAGEMENT CLASS\nBCDMCLEN DS    H                       DEFAULT MC LENGTH OF NAME\nBCDMCNAM DS    CL30                    DEFAULT MANAGEMENT CLASS NAME\nBCDDGEOM DS   0CL8                     DEFAULT DEVICE GEOMETRY\nBCDTRKSZ DS    F                       TRACK SIZE IN BYTES\nBCDCYLCP DS    F                       CYL CAPACITY (TRK/CYL)\nBCDDUNIT DS    CL8                     DEFAULT UNIT\nBCDSRST  DS    CL8                     SMS RESOURCE STATUS TOKEN\nBCDSTAT  DS    AL1                     DATA SET STATUS SEE CONSTS\n         DS    CL3                     RESERVED\nBCDFSYSN DS   8CL8      DIMENSION=(8)  SYSTEM NAMES\nBCDSCDSN DS    CL44                    FOR ACDS ONLY  NAME OF SCDS     X\n                                       FROM WHICH IT WAS ACTIVATED\nBCDSFEAT DS   8CL2      DIMENSION=(8)  SUPPORTED SYSTEM FEATURES\n         DS    X'00010100'        018C ?                        HDZ11B0\n         DS    XL8                0190 ?                        HDZ11B0\n         DS    XL4                0198 ?                        HDZ11C0\nBCDSYSOF DS    A(BCDEND-BCDEF)    019C OFFSET TO SYSTEM DATA    HDZ11C0\nBCDSYSLN DS    A(BCDEND2-BCDSYSDT) 1A0 LENGTH OF SYSTEM DATA    HDZ11C0\n         DS    A(BCDEND-BCDEF)     1A4 ?                        HDZ11C0\n         DS    XL16               01A8 Reserved                 HDZ11C0\nBCDEND   DS    0D                 01B8 ROUND TO DWORD BOUNDARY  HDZ11C0\nBCDSYSDT DSECT                         SYSTEM RELATED DATA      HDZ11C0\nBCDSSTAT DS    256CL16                 ONE ENTRY PER SYSTEM     HDZ11C0\nBCDEND2  DS    0D                      ROUND TO DWORD BOUNDARY  HDZ11C0\nBCD_TOTAL_LENGTH EQU (BCDEND-IGDBCD)+(BCDEND2-BCDSYSDT)         HDZ11C0\nBCDVALID EQU   1                       DATA SET IS VALID\nBCDINVAL EQU   2                       DATA SET IS INVALID\nBCDUNKWN EQU   3                       DATA SET STATUS IS UNKNOWN\nBCDTYP   EQU   10                      CONSTANT TYPE OF LIST\nBCDVER0  EQU   0                       IGDBCD VERSION           HDP3310\nBCDVER1  EQU   1                       IGDBCD VERSION           HDZ11B0\nBCDVER2  EQU   2                       IGDBCD VERSION           HDZ11C0\nBCDVER   EQU   2                       IGDBCD VERSION (current)\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INSLINE": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x00%\\x1f\\x01\\x19\\x00\\x8f\\x12\\x00\\x01\\x95\\x01\\x8f\\x00\\x01\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2019-01-08T12:00:00", "lines": 405, "newlines": 399, "modlines": 1, "user": "UPDATED"}, "text": "/* Rexx */\n/* This Macro allows the user to insert lines wherever he likes to    */\n/*                                                                    */\n/* Parameters are:                                                    */\n/*                                                                    */\n/* FROM: Specifies the starting line                                  */\n/*    - Values accpted: Whole number from 0 to .zlast - 1             */\n/*    - Special variables .ZCSR .ZFIRST                               */\n/*    - Any valid LABEL set in the current edit - session             */\n/*                                                                    */\n/* TO  : Specifies the ending line                                    */\n/*    - Values accpted: Whole number from 1 to .zlast                 */\n/*    - Special variables .ZCSR .ZLAST                                */\n/*    - Any valid LABEL set in the current edit - session             */\n/*                                                                    */\n/* BY  : Specifies the interval by which lines will be inserted.      */\n/*    - Values accpted: Whole number smaller than 'TO' - Value        */\n/*                                                                    */\n/* MODE: Specifies the Mode; either 'X' or 'NX' to limit the affected */\n/*      Lines                                                         */\n/*                                                                    */\n/* The Parameters can be entered in any order or left blank           */\n/*                                                                    */\n/* Defaults are:                                                      */\n/*    - FROM: 1                                                       */\n/*    - TO  : .ZLAST                                                  */\n/*    - BY  : 1                                                       */\n/*    - MODE: ''                                                      */\n/* If the entered parms pass through the plausibility checks,         */\n/* The User is prompted to enter the Data of the line(s) to be        */\n/* inserted.                                                          */\n/* The CAPSMODE setting will be checked.                              */\n/* If 'OFF', the user is prompted whether he wants the entered data   */\n/* in uppercase.                                                      */\n/*                                                                    */\n/* Example:                                                           */\n/* --------                                                           */\n/* Your currently edited data looks as follows:                       */\n/*                                                                    */\n/* 000001 //U00110Y  JOB (7700,0508),'RAMSEIER',CLASS=F,              */\n/* 000002 //         MSGCLASS=X,NOTIFY=U00110,TIME=(1,1)              */\n/* 000003 //PRTTEST OUTPUT JESDS=ALL,                                 */\n/* 000004 //        TITLE='MANUALLIST PER 27.11.91',                  */\n/* 000005 //        ADDRESS=('RESO RECHENZENTRUM',                    */\n/* 000006 //        'ROEMERSTRASSE 20',                               */\n/* 000007 //        '4502 SOLOTHURN',                                 */\n/* 000008 //        '     ========='),                                */\n/* 000009 //        BUILDING='MUTTENTRASSE 1',                        */\n/* 000010 //        DEPT='RESSORT TECHNIK'                            */\n/* 000011 //SCHTEPP1 EXEC PGM=IEFBR14,REGION=4M                       */\n/* 000012 //SYSPRINT DD  SYSOUT=*,OUTPUT=*.PRTTEST                    */\n/*                                                                    */\n/* now you want to add a commentline after every line of the address: */\n/*                                                                    */\n/* type: INSLINE FROM 5 TO 7                                          */\n/*                                                                    */\n/* Answer to the prompt screen:                                       */\n/*                                                                    */\n/* //* This is comment                                     */         */\n/*                                                                    */\n/* Afterwards, your Job looks as follows.                             */\n/*                                                                    */\n/* 000001 //U00110Y  JOB (7700,0508),'RAMSEIER',CLASS=F,              */\n/* 000002 //         MSGCLASS=X,NOTIFY=U00110,TIME=(1,1)              */\n/* 000003 //PRTTEST OUTPUT JESDS=ALL,                                 */\n/* 000004 //        TITLE='MANUALLIST PER 27.11.91',                  */\n/* 000005 //        ADDRESS=('RESO RECHENZENTRUM',                    */\n/* 000006 //* This is comment                                     */  */\n/* 000007 //        'ROEMERSTRASSE 20',                               */\n/* 000008 //* This is comment                                     */  */\n/* 000009 //        '4502 SOLOTHURN',                                 */\n/* 000010 //* This is comment                                     */  */\n/* 000011 //        '     ========='),                                */\n/* 000012 //        BUILDING='MUTTENTRASSE 1',                        */\n/* 000013 //        DEPT='RESSORT TECHNIK'                            */\n/* 000014 //SCHTEPP1 EXEC PGM=IEFBR14                                 */\n/* 000015 //SYSPRINT DD  SYSOUT=*,OUTPUT=*.PRTTEST                    */\n/*                                                                    */\n/* Macro written at Reso                            04/29/94          */\n/*                                                      tra           */\n/*                                                                    */\n/* Changes:                                                           */\n/* --------                                                           */\n/* Correction in processing of BY value             2019/01/08        */\n/*                                                  Peter Glanzmann   */\n/*                                                                    */\n/**********************************************************************/\nAddress 'ISREDIT'\n'MACRO (PARSTR)'\nTrace Off\nUpper parstr\npar = parstr                      /* Reload input                   */\ndo_check = 0                      /* Boolean, indicates plaus-check */\nDo i = 1 to 4\n  wrn.i = 'OK'                    /* Initializes warning-messages   */\nEnd\nparse var par . 'FROM 'fline .    /* Parse the FROM - Value         */\nIf fline = '' Then                /* Empty, deafult will be entered */\n  Do\n    fline = 1\n    wrn.1 = ' not specified; default of 'fline' substituted'\n  End\nElse\n  Do                              /*                                */\n    do_check = 1                  /* Value entered; must check      */\n    parstr = Delstr(parstr,Pos('FROM',parstr),Length('FROM' fline))\n  End                             /* Strip value entered            */\nparse var par . 'TO 'toline .\nIf toline = '' Then               /* Parse and check th TO - Value  */\n  Do\n    '(toline) = LINENUM .ZLAST'   /* Enter Default if empty         */\n    wrn.2 = ' not specified; default of 'toline' substituted'\n  End\nElse\n  Do                              /*                                */\n    do_check = 1                  /* Value entered; must check      */\n    parstr = Delstr(parstr,Pos('TO',parstr),Length('TO' toline))\n  End                             /* Strip value entered            */\nparse var par . 'BY 'byline .      /* do. with BY                   */\nIf byline = '' Then\n  Do\n    byline = 1\n    wrn.3 = ' not specified; default of 'byline' substituted'\n  End\nElse\n  Do                              /*                                */\n    do_check = 1                  /* Value entered; must check      */\n    parstr = Delstr(parstr,Pos('BY',parstr),Length('BY' byline))\n  End                             /* Strip value entered            */\nparse var par . 'MODE 'xmode .     /* do. with mode                */\nIf xmode \u00ac= '' Then\n  Do                              /*                                */\n    do_check = 1                  /* Value entered; must check      */\n    parstr = Delstr(parstr,Pos('MODE',parstr),Length('MODE' xmode))\n  End                             /* Strip value entered            */\nIf parstr \u00ac= ' ' Then             /* Is there any garbage left ?    */\n  Do\n    zedsmsg = parstr 'invalid'\n    msg = 'Valid parms are '''FROM''','''TO''','''BY'''or'\n    zedlmsg = msg ''''MODE'''; Please respecify'\n    Address 'ISPEXEC'\n    'ISPEXEC SETMSG MSG(ISRZ001)'\n    Exit 12\n  End\nmust_go = 0                       /* Error-indicator; if >0, macro */\nIf do_check = 1 Then              /* will not execute              */\n  Do\n    Call Chckparm                 /* Check the parms if needed     */\n    Do i = 1 to 4\n      If err.i \u00ac= 'OK' Then       /* Look for error-msgs.          */\n        must_go = 1               /* Yes, we got;macro will cancel */\n      If wrn.i \u00ac= 'OK' Then       /* Look for warning-msgs         */\n        must_warn = 1\n    End\n    If must_go = 1 Then           /* Explanin the error(s) and exit*/\n      Do\n        Say 'Result of Parameter-Check'\n        Say '========================='\n        Say ''\n        Say 'Errors - macro will terminate:'\n        Say '------------------------------'\n        Say 'FROM' fline': 'err.1\n        Say 'TO' toline': 'err.2\n        Say 'BY' byline': 'err.3\n        Say 'MODE' xmode': 'err.4\n        Exit 1\n      End\n    If must_warn = 1 Then         /* Show warnings and process     */\n      Do\n        Say ''\n        Say 'Warnings - processing will continue:'\n        Say '------------------------------------'\n        Say 'FROM: 'wrn.1\n        Say 'TO: 'wrn.2\n        Say 'BY: 'wrn.3\n        Say 'MODE: 'wrn.4\n        Say ''\n      End\n  End\nElse                              /* Defaults used; tell to user    */\n  Do\n    Say ''\n    Say 'Defaults entered; processing continues'\n    Say '--------------------------------------'\n    Say 'FROM: 'wrn.1\n    Say 'TO: 'wrn.2\n    Say 'BY: 'wrn.3\n    Say 'MODE: 'wrn.4\n    Say ''\n  End\ncolline = '----+----1----+----2----+----3----+----4----+----'\ncolline = (colline)||('5----+----6----+----7----+----')\nerror = 0\nSay 'Enter data to be inserted.'\nSay 'Please do N O T put string in quotes('') :'\nSay colline\nParse Pull insrline\nIf Length(insrline) = 0 Then\n  error = 1                      /* prompt + pull new data        */\nElse\n  Do                             /* Is CAPS OFF ?                 */\n    '(CAPMODE) = CAPS'\n    If capmode = 'OFF' Then\n      Do\n        Say 'Should data be inserted in uppercase (Yes/No)'\n        Pull answer\n        If Length(answer) > 0 Then\n          Do\n            answer = Substr(answer,1,1)\n            Select\n              When answer = 'Y' Then\n                upper insrline\n              When answer = 'N' Then\n                nop\n              Otherwise\n                error = 1\n            End\n          End\n        Else\n          error = 1\n      End\n    Else\n      upper insrline\n  End\nIf error = 0 Then                /* No error found; Process         */\n  Do\n    finish = 0                   /* Init. num. of lines inserted    */\n    i = fline                    /* go to start of insertions       */\n    j = 0                        /* Counter of excl. lines (if any) */\n    Trace off\n    If xmode = '' Then           /* Do we have to look for X/NX     */\n      Do While i <= toline       /* No, process                     */\n        'LINE_AFTER' i '= (INSRLINE)' /* write to file              */\n        i = i + byline + 1       /* adjust i                        */\n        toline = toline + 1      /* Add the insterted line to total */\n        finish = finish + 1      /* increase num of lines inserted  */\n      End\n    Else                         /* Yes, we must concern on X / NX  */\n      Do While i <= toline\n        '(excstat) = XSTATUS 'i  /* Do we have a status match ?     */\n        If excstat = xmode Then  /* Yes, increase hit-count         */\n          Do\n            j = j + 1\n            If j = byline Then   /* May we put a line ?             */\n              Do                 /* Yes, insert it and bump behind  */\n                'LINE_AFTER' i '= (INSRLINE)'   /* write to file    */\n                i = i + 1        /* increase i                      */\n                toline = toline + 1  /* increase total-lines        */\n                finish = finish + 1  /* increase total lines insert */\n                j = 0            /* start new count of x/nx lines   */\n              End\n            Else                 /* not yet enough lines; nothing   */\n              Nop                /* to do                           */\n          End\n        Else                     /* No x/nx match; reset counter    */\n          j = 0                  /* of matched x/nx lines           */\n        i = i + 1                /* increase i in every case        */\n      End\n    Say finish 'lines inserted' /* Say number of inserted lines     */\n  End\nElse\n  Say 'No or invalid data entered; macro cancelled' /* no data      */\nExit 1                          /* Cursor to commandline + exit     */\n/***************/\n/* Subroutines */\n/***************/\nChckparm:\n'(beglin) = LINENUM .zfirst'    /* Set the special variables allowed*/\n'(endlin) = LINENUM .zlast'\n'(curlin) = LINENUM .zcsr'\nfr_parm = Datatype(fline)       /* get Datatype of the FROM         */\nIf fr_parm = 'CHAR' Then\n  Do\n    Select\n      When fline = '.ZCSR' Then /* evaluate allowed names and refill*/\n        Do                      /* to numeric or put error-msg      */\n          fline = curlin\n          err.1 = 'OK'\n          wrn.1 = '.ZCSR substituted with 'curlin\n        End\n      When fline = '.ZFIRST' Then\n        Do\n          fline = beglin\n          err.1 = 'OK'\n          wrn.1 = '.ZFIRST substituted with 'beglin\n        End\n      When fline = '.ZLAST' Then\n        err.1 = 'From 'fline' makes no sense'\n      Otherwise\n        Do                      /* Could it be a label ?            */\n          If Pos('.',fline) = 1 Then\n            Do\n              '(ln) = LINENUM 'fline\n               If Rc > 4 Then   /* No, wrong input                  */\n                 err.1 = 'Invalid label entered'\n               Else\n                 Do\n                   wrn.1 = fline 'substituted with 'ln\n                   fline = ln   /* Yes, tell user about substitution*/\n                   err.1 = 'OK'\n                 End\n            End\n          Else                  /* No label                         */\n            err.1 = 'Invalid literal entered'\n        End\n    End\n  End\nElse If fr_parm = 'NUM' Then\n  Do\n    If Datatype(fline,'W') = 0 Then    /* Is it a whole number ?    */\n      err.1 = fline' not a whole number'\n    Else If fline > endlin | fline < 0 Then\n      err.1 = fline' larger than last line or negatif'\n    Else\n      err.1 = 'OK'\n  End\nElse\n  err.1 = fr_parm' is an invalid datatype'\n/* Test 'TO' */\nto_parm = Datatype(toline)      /* Do similar test to DO            */\nIf to_parm = 'CHAR' Then\n  Do\n    Select\n      When toline = '.ZCSR' Then\n        Do\n          toline = curlin\n          err.2 = 'OK'\n          wrn.2 = '.ZCSR substituted with 'curlin\n        End\n      When toline = '.ZFIRST' Then\n        Do\n          toline = beglin\n          err.2 = 'To 'toline' makes no sense'\n        End\n      When toline = '.ZLAST' Then\n        Do\n          toline = endlin\n          err.2 = 'OK'\n          wrn.2 = '.ZLAST substituted with 'endlin\n        End\n      Otherwise\n        Do\n          If Pos('.',toline) = 1 Then\n            Do\n              '(ln) = LINENUM 'toline\n              If Rc > 4 Then\n                err.2 = 'Invalid label entered'\n              Else\n               Do\n                 wrn.2 = toline 'substituted with 'ln\n                 toline = ln\n                 err.2 = 'OK'\n               End\n            End\n          Else\n            err.2 = 'Invalid literal entered'\n        End\n    End\n  End\nElse If to_parm = 'NUM' Then\n  Do\n    If Datatype(toline,'W') = 0 Then\n      err.2 = toline' not a whole number'\n    Else If toline > endlin Then\n      Do\n        wrn.2 = toline' too big; last line 'endlin' substituted'\n        err.2 = 'OK'\n      End\n    Else If toline < 0 Then\n      err.2 = toline' too big or negatif'\n    Else\n      err.2 = 'OK'\n  End\nElse\n  err.2 = to_parm' is an invalid datatype'\nIf err.2 = 'OK' Then\n  Do\n    If toline <= fline Then\n      err.2 = 'TO smaller than or equal to FROM'\n  End\n/* Test 'BY' */\nby_parm = Datatype(byline)\nIf byline <= 0 | Datatype(byline,'W') \u00ac= 1 Then\n  err.3 = 'BY must specify a positive whole number'\nElse If byline >= toline Then\n  Do\n    If err.2 = 'OK' Then\n      err.3 = 'BY must be smaller than TO'\n    Else\n      err.3 = 'OK'\n  End\nElse\n  err.3 = 'OK'\n/* Test 'MODE' */\nIf xmode \u00ac= 'X' & xmode \u00ac= 'NX' & xmode \u00ac= '' Then\n  err.4 = 'Valid modes are X or NX'\nElse if xmode ='' Then\n  Do\n    wrn.4 = ' not specified; all lines will be processed'\n    err.4 = 'OK'\n  End\nElse\n  err.4 = 'OK'\nTrace Off\nReturn\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MM": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x00\\xb6\\x00\\xb6\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 182, "newlines": 182, "modlines": 0, "user": "TRAMSEI"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "MMP": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x005\\x005\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "TRAMSEI"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "MMPH": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x00\"\\x00\"\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "TRAMSEI"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "OMTREE": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x02G\\x02G\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 583, "newlines": 583, "modlines": 0, "user": "TRAMSEI"}, "text": "/* Rexx */\n/* */\n/* This Rexx builds the hierarchy-tree of all currently mounted HFS */\n/* and  shows them in a pseudo-graphic way using either graphic es- */\n/* cape, the 3278T-characterset or common characters.               */\n/* */\nAddress TSO                    /* set environment                  */\nParse Upper Arg mode           /* dispmode set by user?            */\nIf Wordpos(mode,'GRAPHIC DEFAULT CHAR') > 0 Then\n  disp_mode = mode             /* yes, store for later use         */\nElse\n  disp_mode = ''               /* no, will be evaluated later      */\nCall Syscalls 'ON'             /* enable openedition-calls         */\nAddress SYSCALL                /* address it                       */\n'Getmntent files.'             /* get mounted files into array     */\nAddress TSO                    /* set environment                  */\nhighest = 0                    /* total amount of hiearchy-levels  */\n/* The following loop initializes several arrays that will be used */\n/* to compute the # of children each hfs has and to save a back-   */\n/* pointer to the original element-number of the \"files.\"-array    */\nDo i = 1 to files.0            /* # of mounted HFS's               */\n  files.mnte_fsname.i = Strip(files.mnte_fsname.i,'B',' ')\n  children.i = ''              /* string w. devices of \"children\"  */\n  drawn.i = 'NO'               /* boolean: hfs already \"drawn\"     */\n  dev =  files.mnte_dev.i      /* logical device-# of current hfs  */\n  dev_el.dev = i               /* backpointer to the original ar-  */\nEnd                            /* ray element. End loop (# of hfs) */\n/* */\n/* The following loop determines the hierarchy-level of each hfs   */\n/* and saves it in the level. - array-element.                     */\n/* The level is computed using the pardev-element, which is the    */\n/* parent-device of the hfs and then evaluating this ones mother   */\n/* by making the parent the current and increasing the level by 1. */\n/* This is repeated until the parent-device is '0', which is the   */\n/* root-hfs.                                                       */\n/* */\nDo i = 1 to files.0            /* # of mounted HFS's               */\nlevel = 0                      /* hiearchy-level of each hfs       */\n  mom_found.i = 'NO'           /* boolean for \"grand-children\"     */\n  parent = files.mnte_pardev.i     /* load the parent-device-nr    */\n  Do While parent \u00ac= 0         /* not yet the root-hfs             */\n    level = level + 1          /* increase # of levels checked     */\n    If level > highest Then    /* is this a new hierarchy-level ?  */\n      highest = level          /* yes, save new highest level      */\n    parnti = dev_el.parent     /* array-element of parent          */\n    parent = files.mnte_pardev.parnti    /* try with new parent    */\n    If mom_found.i \u00ac= 'YES' Then   /* \"mother\" already found ?     */\n      children.parnti = children.parnti' 'i   /* no, fill string   */\n    mom_found.i = 'YES'        /* set boolean to avoid a child can */\n  End                          /* have more than 1 parent          */\n  level.i = level + 1          /* inc. 1 for root-level found      */\nEnd                            /* end loop                         */\nhighest = highest + 1          /* synchronize highest after root   */\n/* */\n/* The following loop calls a subroutine that \"draws\" a box around */\n/* the current hfs. see comment at Draw_boxes for further infos.   */\n/* */\nDo i = 1 to files.0            /* # of mounted HFS's               */\n  Call Draw_boxes i level.i    /* draw the box                     */\nEnd                            /* end loop                         */\nDo i = 1 to highest            /* initialize hfs-per-level array   */\n  pos_on_level.i = ''          /* set array - element to ''        */\nEnd                            /* end loop                         */\nscrl = 0             /* # of log. screen-lines w/o connectionlines */\n/* */\n/* The following subroutine groups, from the left to the right,    */\n/* the \"family\" whithin the whole openedition.                     */\n/* see comment at Build_family for further information.            */\nCall Build_family              /* call the subroutine              */\n/* The following loop \"draws\" the boxes of those hfs which were    */\n/* identified as \"parents\" in the Build_family subroutine, at the  */\n/* logical \"left edge\" of the current level. the root-hfs has a    */\n/* parent-device of 0, so the loop-counter starts at 2.            */\n/* */\nDo j = 2 to highest            /* start at lvl 2, root is top      */\n  Do k = 1 to box.0            /* # of lines per hfs-box           */\n    pnlline.k = ''             /* Initialize logical panel-line    */\n  End                          /* end of init-loop                 */\n  a = j - 1                    /* point to the next higher level   */\n  Do i = 1 to Words(realparnt.j)   /* chk every mother of this lvl.*/\n    motherdev = Word(realparnt.j,i)   /* pick mothers device-#     */\n    mother = dev_el.motherdev  /* get the real files.-element-#    */\n    pos_on_level.a = pos_on_level.a' 'mother  /*into positionstring*/\n    drawn.mother = 'YES'       /* indicate that this el. is drawn  */\n    If motherdev > 0 Then      /* valid element of files.-array ?  */\n      Do k = 1 to box.0        /* #of lines for a box              */\n        pnlline.k = pnlline.k' 'box.mother.k  /* fill log. pnlline */\n      End                      /* box drawn into logical panelline */\n  End                          /* all parents of this level drawn  */\n  Do k = 1 to box.0            /* fill all log. panellines of this */\n    scrl = scrl + 1            /* level into overall log. pnllines */\n    scrline.scrl = pnlline.k   /* and increase the counter of all  */\n  End                          /* lines to be displayed on the pnl.*/\nEnd                            /* End of drawing the parents-loop  */\nsavescrl = scrl                /* save # of lines already filled   */\nscrl = 0                       /* reset counter for following loop */\n/* */\n/* The following loop adds the children right to the parents       */\n/* whithin the same level. the last level, the one without parents */\n/* in it, is added completely, at the \"end\" of the scrline-array   */\n/* */\nDo j = 1 to highest            /* Loop-counter: once per level     */\n  Do k = 1 to box.0            /* # of lines per hfs-box           */\n    pnlline.k = ''             /* Initialize logical panel-line    */\n  End                          /* end of init-loop                 */\n       /* start of inner loop: all \"sisters\", hfs's at the same    */\n       /* level, are concatenated into the same log. panel-record  */\n  Do i = 1 to Words(sisterstr.j)   /* inner loop: once per \"sister\"*/\n    elem = Word(sisterstr.j,i)     /* extract files.i of \"sister\"  */\n    If drawn.elem = 'NO' Then      /* has it already been drawn ?  */\n      Do                           /* no, occupy slot in level-rec.*/\n        pos_on_level.j = pos_on_level.j' 'elem    /* add rightmost */\n        Do k = 1 to box.0          /* Loop: # of lines per box     */\n          pnlline.k = pnlline.k' 'box.elem.k      /* add rightmost */\n        End                    /* end of innermost loop: 1/boxline */\n      End                      /* end of logically drawing element */\n  End                          /* end of loop, all sisters drawn   */\n  Do k = 1 to box.0            /* once per level: add the logical  */\n    scrl = scrl + 1            /* panellines to the overall-array  */\n    If scrl > savescrl Then    /* is this a level w/o parents ?    */\n      scrline.scrl = pnlline.k     /* yes, just write the line     */\n    Else                       /* no, line already exists, add     */\n      scrline.scrl = scrline.scrl''pnlline.k  /* sisters beneath   */\n    scrline.scrl = Strip(scrline.scrl,'B',' ')  /* Strip blanks    */\n  End                          /* end of panellines per level      */\nEnd                            /* end of overall panellines        */\nscrline.0 = scrl               /* fill overall-array w. counter    */\ndyndisp = ''\n'ISPEXEC PQUERY PANEL(OMTREE1) AREANAME(dyndisp),\n         AREATYPE('atypname'),\n         WIDTH('dynwidth') DEPTH('dyndepth') ROW('arowname'),\n         COLUMN('acolname')'   /* Query panel-characteristics      */\ndynwidth = dynwidth - 1        /* subtract 1,the attrchar at pos1  */\n/* */\n/* The following subroutine connects the parents of every level    */\n/* with their children and insterts lines for drawing if necessary.*/\n/* See Draw_lines for further info.                                */\n/* */\nCall Draw_lines                /* call the subroutine              */\n/* */\n/* The following lines determine the kind of display to be used.   */\n/* disp_mode is the only parameter accepted and can be either      */\n/* GRAPHIC, DEFAULT, or CHAR                                       */\nIf disp_mode = '' Then        /* no parm passed, find \"best\" method*/\n  Do\n    'ISPEXEC VGET (ZGE ZENVIR)'    /* evaluate callers environment */\n    If zge = 'NO' Then             /* No graphics, use char-mode   */\n      disp_mode = 'CHAR'\n    Else If zenvir < 'ISPF 4.1' Then   /* old fashioned ISPF,      */\n      Do                          /* no CUA-panels, set pseudo-   */\n        disp_mode = 'DEFAULT'      /* graphic characters           */\n        'ISPEXEC VGET ZTERM'       /* get actual terminalsetting   */\n        term_set = zterm           /* save it                      */\n        new_set = '3278T'          /* set \"my\" desired value       */\n        'ISPEXEC SELECT PGM(ISPTTDEF) PARM(ISP'new_set')'  /*tell ISPF*/\n      End\n    Else\n      disp_mode = 'GRAPHIC'        /* graphics on and supported    */\n  End\nElse                               /* disp_mode entered by user    */\n  Do                               /* no further action except if  */\n    If disp_mode = 'DEFAULT' Then  /* DEFAULT-mode                 */\n      Do\n        'ISPEXEC VGET ZTERM'       /* get actual terminalsetting   */\n        term_set = zterm           /* save it                      */\n        new_set = '3278T'          /* set \"my\" desired value       */\n        'ISPEXEC SELECT PGM(ISPTTDEF) PARM(ISP'new_set')'  /*tell ISPF*/\n      End\n  End\n/* The following statements represent the display loop; panel      */\n/* OMTREE1 is displayed unless the user presses 'END'              */\n/* */\ndisp_Rc = 0                    /* boolean: 0=display panel, 8=exit */\nCall Build_page 'INIT'         /* compose logical page to be shown */\nDo While disp_Rc = 0           /* panel display loop               */\n  old_dyndisp = dyndisp        /* save dyndisp before display      */\n  'ISPEXEC DISPLAY PANEL(OMTREE1)'     /* display the panel        */\n  disp_Rc = Rc                 /* save return-code from display    */\n  If disp_Rc = 0 Then          /* was it zero ?                    */\n    Do                         /* yes, proceed                     */\n      selected = Compare(old_dyndisp,dyndisp)  /* compare dyndisps */\n      If selected > 0 Then     /* was a selection made ?           */\n        Do                     /* yes, find selected hfs           */\n          eff_l = selected % (dynwidth+1)   /* effective line-# is */\n          eff_l = flin + eff_l   /* first line/page + line in curr.*/\n          eff_c = selected // (dynwidth+1)  /* effective col-# is  */\n          eff_c = fcol + eff_c - 2  /* 1st col of screen + current */\n                               /* pos.-2 (1 f. x'03', 1 f. start=1 */\n          Do i = 1 to files.0  /* search array for matching grids  */\n            If gridval.i = eff_c' 'eff_l Then  /* found ?          */\n              Call Zoom_hfs\n          End                  /* end of inner loop                */\n        End                    /* end of selection made            */\n      Call Build_page 'SHOW'   /* check for scrolling              */\n    End                        /* end of current display           */\nEnd                            /* end of display-loop              */\nIf disp_mode = 'DEFAULT' Then\n  'ISPEXEC SELECT PGM(ISPTTDEF) PARM(ISP'term_set')'      /* reset */\nExit                           /* end of program                   */\n/* */\n/* Subroutines */\n/* */\n/* Draw_boxes gets passed the current element of files. -array and   */\n/* its hierarchy level. A box is drawn around the hfs-name + mount-  */\n/* point. the size of the box depends on which string is the longest:*/\n/* HFS-name, mountpoint, or the # of children which will be connected*/\n/* to this box (2 byte per child).                                   */\nDraw_boxes:                    /* Draw_boxes: draw a box around hfs  */\narg curr lv                    /* get element-# and hierarchylevel   */\nl1 = Length(files.mnte_fsname.curr)     /* length of HFS-name        */\nl2 = Length(files.mnte_path.curr)       /* length of mountpoint      */\nl3 = Length(Copies('40BB'x,(Words(children.curr)))) /* #of children  */\nli4 = ('014002'x) || 'Ishell' || ('03'x)  /* Commandline             */\nl4 = Length(li4)\nCall Hfs_permissions curr      /* get permission scheme              */\nli5 = Strip(accstr,'B',' ')\nl5 = Length(li5)\ndsnl = Max(l1,l2,l3,l4,l5)     /* find the longest line in the box   */\nbox.curr.1 = ('AC'x) || Substr('BF'x,1,dsnl,'BF'x) || ('BC'x)  /* l1 */\nIf lv > 1 Then                 /* if not root, draw anchor f. parent */\n  box.curr.1 = ('AC'x) || Centre('CB'x,dsnl,'BF'x) || ('BC'x)  /*ancr*/\nbox.curr.2 = ('FA'x) || Centre(files.mnte_fsname.curr,dsnl) || ('FA'x)\nbox.curr.3 = ('FA'x) || Centre(files.mnte_path.curr,dsnl) || ('FA'x)\nbox.curr.4 = ('FA'x) || Centre(li4,dsnl) || ('FA'x)\ncmdline = 4                    /* line-# of command-field in the box */\nbox.curr.5 = ('FA'x) || Centre(li5,dsnl) || ('FA'x)\nbox.curr.6 = Copies('40CC'x,(Words(children.curr)))\nbox.curr.6 = ('AB'x) || Centre(box.curr.6,dsnl) || ('BB'x)\nbox.curr.6 = Translate(box.curr.6,'BF'x,' ')\nbox.0 = 6                      /* box-size in lines                  */\nReturn                         /* end of subroutine                  */\n/* Build_family: This subroutine builds several arrays that will     */\n/* help computing the lines to be drawn later in the program.        */\n/* Each array has as much elements as there are hierarchy-levels.    */\n/* parentstr.x : a string with the device-# of every hfs which is    */\n/*               a parent at the current level.                      */\n/* realparnt.x : parentstr w/o duplicates. (a parent can have more   */\n/*               than on child).                                     */\n/* sisterstr.x : a string containing the real files.-element-# of    */\n/*               the currently processed hfs.                        */\nBuild_family:                  /* start the subroutine               */\nDo j = highest to 1 by -1      /* process bottom-up                  */\n  parentstr.j = ''             /* string w. all parents              */\n  realparnt.j = ''             /* parents w/o duplicates             */\n  sisterstr.j = ''             /* sisters                            */\n  Do i = 1 to files.0          /* inner loop: once per hfs-file      */\n    If level.i = j Then        /* is this one of the current level ? */\n      Do                       /* yes, fill the strings              */\n        sisterpos = Wordpos(files.mnte_pardev.i,parentstr.j)\n        If sisterpos > 0 Then  /* is this a child  ?                 */\n          Do                   /* yes, compute position              */\n            /* This statements optimize the position whithin a family*/\n            /* children are grouped directly under the parent, as    */\n            /* far as possible.                                      */\n            sp = Wordindex(parentstr.j,sisterpos) - 1  /* pos. in pa-*/\n            filler = files.mnte_pardev.i' ' /* -rent-str.ng,make word*/\n            parentstr.j = Insert(filler,parentstr.j,sp) /* new p-str.*/\n            ip = Wordindex(sisterstr.j,sisterpos) - 1  /* same in i- */\n            filler = i' '      /* -string to know which files. it is */\n            sisterstr.j = Insert(filler,sisterstr.j,ip) /* new s-str */\n          End                  /* end of child-position-calculation  */\n        Else                   /* This is not a child, place at the  */\n          Do                   /* right end of parentstr.            */\n            parentstr.j = parentstr.j' 'files.mnte_pardev.i\n            realparnt.j = realparnt.j' 'files.mnte_pardev.i\n            sisterstr.j = sisterstr.j' 'i   /* build new strings     */\n          End                  /* end of not-a-child action          */\n      End                      /* end of correct-level hfs-actions   */\n  End                          /* end of inner loop: once per hfs    */\nEnd                            /* end of outer loop: once per level  */\nReturn                         /* end of subroutine                  */\nDraw_lines:\n/* */\n/* Draw_lines inserts one line in the effective output-array 'line.' */\n/* per connection to draw. connections are made from the rightmost   */\n/* parent of the highest level (root) to the leftmost child at the   */\n/* lowest level in descending sequence. The correct relationship be- */\n/* tween child and parent is computed by using the # of anchorpoints */\n/* the current parent has. this amount is connected to the currently */\n/* rightmost entry in endposstr. after having established the con-   */\n/* nection, length between start and end is computed. If length is   */\n/* < 0, the direction is changed to leftside. After having drawn the */\n/* line, the anchorpoints are deleted in startposstr.x and in        */\n/* endposstr.x . The deleted endposstr-entry is added to endline.x . */\n/* At the end of each entry, the endline.x -positions are filled w.  */\n/* vertical bars to complete the line. The same thing is done with   */\n/* those startpos-entries being not the current.                     */\na = 0                          /* counter of total-lines             */\ngrid = 0                       /* counter of total-lines             */\nj = 0                          /* level-counter                      */\nlongest_line = 0               /* find longest line                  */\nDo i = 1 to scrline.0          /* outmost loop: once per scrline     */\n  If i = 1 Then                /* At the right top of the screen     */\n    Call Add_info_box          /* the info-box is added              */\n  If i <= box.0 Then           /* justify the infobox at the right   */\n    Do                         /* edge of the screen                 */\n      numblks = dynwidth - (Length(scrline.i) + Length(infoline.i))\n      If numblks >= 0 Then     /* fill blanks between root + infobox */\n        scrline.i = (scrline.i) || Substr(' ',1,numblks,' ') ||,\n                    (infoline.i)\n      Else                     /* if overlaps occur, infobox on top  */\n        Do\n          scrline.i = Substr(scrline.i,1,dynwidth,' ')\n          ostrt = dynwidth - Length(infoline.i) + 1\n          scrline.i = Overlay(infoline.i,scrline.i,ostrt)\n        End\n    End\n  If Length(scrline.i) > longest_line Then  /* is this the longest ? */\n    longest_line = Length(scrline.i)   /* yes, save value for panel  */\n  a = a + 1                    /* total-lines up 1                   */\n  line.a = scrline.i           /* fill array - element               */\n  If i // box.0 = cmdline Then      /* is this a \"command\" - line    */\n    Do                         /* yes, compute location of inputfield*/\n      grid = grid + 1          /* level of this command line         */\n      currpos = 0              /* current position (next cmd-field)  */\n      Do k = 1 to Words(pos_on_level.grid)   /* # of sisters in level*/\n        currpos = Pos('014002'x,scrline.i,currpos+1) /* get cmd-pos  */\n        x = Word(pos_on_level.grid,k)  /* get real element of files. */\n        gridval.x = currpos+1' 'a   /* save coordinates in gridval   */\n      End                      /* end of gridval - array             */\n    End                        /* end of command-line                */\n  If i // box.0 = 0 Then       /* is this an anchor-line of parent?  */\n    Do                         /* yes                                */\n      j = j + 1                /* inc. level-counter                 */\n      startposstr.j = ''       /* initialize startposstr.            */\n      startpos = 0             /* 1st anchor-point                   */\n      endposstr.j = ''         /* pos. of childrens anchor           */\n      endpos = 0               /* 1st anchorpoint of child           */\n      endline.j = ''           /* those already connected            */\n      c = j + 1                /* pointer to next level              */\n      Do Words(pos_on_level.c)    /* total amount of children        */\n        startpos = Pos('CC'x,scrline.i,startpos+1)   /* get startpos */\n        startposstr.j = startposstr.j' 'startpos     /* save it      */\n        q = i + 1                 /* anchor of child                 */\n        endpos = Pos('CB'x,scrline.q,endpos+1)    /* pos. of anchor  */\n        endposstr.j = endposstr.j' 'endpos           /* save it      */\n      End                      /* end of inner loop                  */\n      Do Words(pos_on_level.c)    /* next loop: once per #of children*/\n        a = a + 1              /* next line of overall-array         */\n        q = i + 1              /* next line of scrline.x             */\n        line.a = Substr(' ',1,Length(scrline.q),' ') /* init new line*/\n        Do q = 1 to Words(startposstr.j)-1   /* write vertical bars  */\n          line.a = Overlay('FA'x,line.a,(Word(startposstr.j,q)))\n        End                    /* end of vertical bars before line   */\n        q = Words(startposstr.j)       /* get # of remaining anchors */\n        l1 = Word(startposstr.j,q)     /* eff. startpos. in the line */\n        l2 = Word(endposstr.j,q)       /* eff. endpos. in the line   */\n        linel1 = Max(l1,l2)    /* line1 is the bigger one            */\n        linel2 = Min(l1,l2)    /* line2 is the smaller one           */\n        linelen = linel1 - linel2      /* compute length of connectio*/\n        If linelen > 0 Then            /* is it > 0 ?                */\n          Do                           /* yes, draw the line         */\n            line.a = Overlay('BF'x,line.a,linel2,linelen,'BF'x)\n            If l1 < l2 Then    /* is it direction right ?            */\n              Do               /* Yes, draw the line-ancles          */\n                line.a = Overlay('AB'x,line.a,linel2)\n                line.a = Overlay('BC'x,line.a,linel1)\n              End\n            Else               /* is it direction left ?             */\n              Do               /* Yes, draw the line-ancles          */\n                line.a = Overlay('AC'x,line.a,linel2)\n                line.a = Overlay('BB'x,line.a,linel1)\n              End\n          End                  /* end of drawing the line            */\n        Else If j < highest Then       /* length = 0 ?               */\n          line.a = Overlay('FA'x,line.a,linel1)  /* Yes, just a bar  */\n        Else                   /* end of Else - If                   */\n          Nop                  /* end of drawing the line            */\n        Do b = 1 to Words(endline.j)   /* draw remaining verticalbars*/\n          line.a = Overlay('FA'x,line.a,(Word(endline.j,b)))\n        End                    /* current panelline is drawn         */\n        endline.j = endline.j' 'Word(endposstr.j,q)  /* save endpos  */\n        startposstr.j = Delword(startposstr.j,q,1)   /* del rightmost*/\n        endposstr.j = Delword(endposstr.j,q,1)       /* del rightmost*/\n      End                      /* end child in this level            */\n    End                        /* end of all levels                  */\nEnd                            /* end of all lines, array ok.        */\n/* */\n/* corrective action: If there is more than 1 hierarchy level, the   */\n/* last line is just a x'03'. */\nline.0 = a - 1                 /* complete the array, YIIPIIEE ||||| */\n/* a-1 because of the last level having no children, last line empty */\nReturn                         /* end of subroutine                  */\n/* */\nBuild_page:\n/* */\n/* Build_page composes the content (dyndisp) of Panel OMTREE1.       */\n/* One parameter is passed: 'INIT' = first call, set defaults.       */\n/* 'SHOW' = subsequent call. If a scroll-key was pressed, the new    */\n/* dyndisp- contents and the new line + column values are computed.  */\nArg build_type                 /* pick passed parm                   */\nIf build_type = 'INIT' Then    /* is this the initial call ?         */\n  Do                           /* Yes, set defaults                  */\n    flin = 1                   /* first line of dyndisp              */\n    tlin = line.0              /* total number of lines              */\n    llin = Min(dyndepth,tlin)         /* last line of logical page   */\n    'ISPEXEC CONTROL NONDISPL END'    /* do a panel-call w/o display */\n    'ISPEXEC DISPLAY PANEL(OMTREE1)'  /* to obtain last visible line */\n    vlin = Min(dyndepth,vdepth,tlin)  /* last visible line in displ. */\n    fcol = 1                   /* first column at first display      */\n    lcol = Min(dynwidth,longest_line)      /* last col. of dyndisp   */\n    tcol = longest_line        /* total number of columns            */\n  End                          /* end of initial call                */\nElse                           /* not the first call, scroll         */\n  Do\n    'ISPEXEC VGET (ZSCROLLN ZVERB ZSCROLLA)'  /* get scroll-vars     */\n    Select                     /* select appropriate action          */\n      When zverb = 'UP' Then   /* \"UP\" specified ?                   */\n        Do                     /* yes, compute # of lines to scroll  */\n          If zscrolla = 'MAX' Then      /* was \"MAX\" specified ?     */\n            Do                 /* yes                                */\n              flin = 1         /* point at top of line.-array        */\n              llin = Min(dyndepth,tlin)   /* last line of 1st page   */\n              vlin = Min(llin,vdepth)     /* last line of page#1     */\n            End                /* new value calculated               */\n          Else                 /* \"max\" not specified                */\n            Do\n              xl = flin - zscrolln    /* subtract #of lines specified*/\n              flin = Max(1,xl)        /* find new top line (or 1)    */\n              xl = llin - zscrolln    /* subtract #of lines specified*/\n              If xl <= 0 Then         /* Is this now < 0 ?           */\n                llin = Min(dyndepth,tlin)      /* yes, show 1st page */\n              Else\n                Do\n                  xl = flin + dyndepth-1\n                  llin = Min(xl,tlin)\n                End\n              vlin = Min(llin,tlin,(flin+vdepth))    /* last visible */\n            End                /* new value calculated               */\n        End                    /* end of \"UP\" scroll                 */\n      When zverb = 'DOWN' Then    /* \"DOWN\" specified ?              */\n        Do                     /* yes, compute # of lines to scroll  */\n          If zscrolla = 'MAX' Then      /* was \"MAX\" specified ?     */\n            Do                 /* yes                                */\n              flin = tlin - Min(vdepth,dyndepth) + 1 /* 1st of lastp.*/\n              llin = tlin      /* last line = total number of lines  */\n              vlin = tlin      /* last line = total number of lines  */\n            End                /* new value calculated               */\n          Else                 /* \"max\" not specified                */\n            Do\n              xl = flin + zscrolln     /* add # of rows specified    */\n              flin = Min(xl,tlin)      /* do not point \"behind\" last */\n              xl = llin + zscrolln     /* add # of rows specified    */\n              llin = Min(xl,tlin)      /* do not point \"behind\" last */\n              vlin = Min(llin,tlin,(flin+vdepth))    /* last visible */\n            End                /* new value calculated               */\n        End                    /* end of \"DOWN\" scroll               */\n      When zverb = 'LEFT' Then    /* \"LEFT\" specified ?              */\n        Do                     /* yes, compute # of cols. to scroll  */\n          If zscrolla = 'MAX' Then      /* was \"MAX\" specified ?     */\n            Do                 /* yes                                */\n              fcol = 1         /* point at column 1                  */\n              lcol = Min(dynwidth,tcol)   /* last col. of page 1     */\n            End                /* new value calculated               */\n          Else                 /* \"max\" not specified                */\n            Do\n              xl = fcol - zscrolln + 1   /* 1st col of left. page    */\n              If Datatype(zscrolla) = 'NUM' Then  /* if abs. numbers */\n                xl = xl - 1    /* used, decrease 1 from xl (base=1)  */\n              fcol = Max(1,xl)           /* set new value            */\n              lcol = fcol + dynwidth - 1    /* last col of left page */\n            End                /* new value calculated               */\n        End                    /* end of \"LEFT\" scroll               */\n      When zverb = 'RIGHT' Then   /* \"RIGHT\" specified ?             */\n        Do                     /* yes, compute # of cols. to scroll  */\n          If zscrolla = 'MAX' Then      /* was \"MAX\" specified ?     */\n            Do                 /* yes                                */\n              fcol = tcol - dynwidth + 1  /* 1st col. rightmost page */\n              lcol = tcol      /* total numbers of cols.             */\n            End                /* new value calculated               */\n          Else                 /* \"max\" not specified                */\n            Do\n              xl = fcol + zscrolln - 1   /* 1st col. right page      */\n              If Datatype(zscrolla) = 'NUM' Then  /* if abs. numbers */\n                xl = xl + 1    /* used, increase 1 from xl (base=1)  */\n              fcol = Min(xl,tcol)        /* must be < total-columns  */\n              xl = lcol + zscrolln - 1   /* last col. right page     */\n              If Datatype(zscrolla) = 'NUM' Then  /* if abs. numbers */\n                xl = xl + 1    /* used, increase 1 from xl (base=1)  */\n              lcol = Min(xl,tcol)        /* must be < total-columns  */\n            End                /* new value calculated               */\n        End                    /* end of \"RIGHT\" scroll              */\n      Otherwise                /* no scrolling action to be performed*/\n        Nop                    /* nop                                */\n    End                        /* end of select                      */\n  End                          /* end of \"SHOW\"-call                 */\ndyndisp = ''                   /* \"CLEARSCREEN\"                      */\nshadow = ''                    /* No attribute override              */\nDo i = flin to llin            /* fill new \"page\" to be shown        */\n  dyndisp = (dyndisp) || ('03'x) || (Substr(line.i,fcol,dynwidth))\nEnd                            /* dyndisp filled, show it            */\nIf disp_mode = 'CHAR' Then\n  dyndisp = Translate(dyndisp,'++++|-oo','ABACBBBCFABFCCCB'x)\nElse If disp_mode = 'GRAPHIC' Then\n  Do\n    shadow = Translate(dyndisp,'$$$$$$$$','ABACBBBCFABFCCCB'x)\n    dyndisp = Translate(dyndisp,'DEMNesPG','ABACBBBCFABFCCCB'x)\n  End\nElse\n  Nop\nReturn\n/* */\nZoom_hfs:\n/* */\n/* Zoom_hfs: If the ISHELL-Command was selected, the current path  */\n/* is taken as the new working directory and the ISPF-shell is     */\n/* called.                                                         */\nrd = files.mnte_path.i         /* pathname to be used as workdir   */\ncommand = Substr(dyndisp,selected,1)   /* validate the entered CMD */\nUpper command                  /* make it uppercase                */\nSelect\n  When command = '/' | command = 'S' Then\n    Do\n      Call Syscalls 'ON'       /* enable openedition-calls         */\n      Address SYSCALL          /* address it                       */\n      'chdir (rd)'             /* set new working directory        */\n      Address TSO\n      'ISHELL'                 /* call ISHELL                      */\n      Address SYSCALL          /* address it                       */\n      'chdir (cwd)'            /* reset original workingdirectory  */\n    End\n  Otherwise                    /* Room for enhancements (8-))      */\n    Nop\nEnd\nReturn\n/* */\nHfs_permissions:\n/* */\n/* Check callers permissions */\nArg curr                       /* HFS-number                        */\nrd = files.mnte_path.curr      /* Name of HFS to be checked         */\nsec.0 = '(---)'\nsec.1 = '(--x)'\nsec.2 = '(-w-)'\nsec.3 = '(-wx)'\nsec.4 = '(r--)'\nsec.5 = '(r-x)'\nsec.6 = '(rw-)'\nsec.7 = '(rwx)'\nCall Syscalls 'ON'             /* enable openedition-calls         */\nAddress SYSCALL                /* address it                       */\n'stat (rd) prmbits.'           /* obtain permission bits           */\nprmbits.ST_MODE = Right(prmbits.ST_MODE,4,'0')\naccstr = ''\nDo a = 2 to 4\n  el = Substr(prmbits.ST_MODE,a,1)    /* get next number (octal)   */\n  accstr = accstr' 'sec.el     /* add visible form                 */\nEnd\nAddress TSO\nReturn\n/* */\nAdd_info_box:\n/* Add_info_box puts a small information box right on top of the   */\n/* first screen being displayed.                                   */\nCall Syscalls 'ON'             /* enable openedition-calls         */\nAddress SYSCALL                /* address it                       */\n'geteuid'                      /* obtain callers userid            */\neuid = Retval\n'getpwuid (euid) pwuid.'       /* obtain user-info                 */\nAddress TSO\ninfoline.2 = ('04'x) || 'OMVS-Userid:' ||,        /* box contents  */\n             ('05'x) || Word(pwuid.PW_UID,1) || ('03'x)\nl2 = Length(infoline.2)\ninfoline.3 = ('04'x) || 'Group:' ||,\n             ('05'x) || Word(pwuid.PW_GID,1) || ('03'x)\nl3 = Length(infoline.3)\ninfoline.4 = ('04'x) || 'Work-Dir:' ||,\n             ('05'x) || Word(pwuid.PW_DIR,1) || ('03'x)\nl4 = Length(infoline.4)\ninfoline.5 = ('04'x) || 'TSO/E Userid:' ||,\n             ('05'x) || Word(pwuid.PW_NAME,1) || ('03'x)\nl5 = Length(infoline.5)\ninfo_len = Max(l2,l3,l4,l5)    /* determine longest line           */\nDo info_i = 2 to 5             /* arrange data within the box      */\n  lastblk = Lastpos('05'x,infoline.info_i)\n  len = Length(infoline.info_i)\n  fillen = info_len - len\n  infoline.info_i = Insert(' ',infoline.info_i,lastblk,fillen,' ')\n  infoline.info_i = ('FA'x) || (infoline.info_i) || ('FA'x)\nEnd\ninfoline.1 = ('AC'x) || Substr('BF'x,1,info_len,'BF'x) || ('BC'x)\ninfoline.6 = ('AB'x) || Substr('BF'x,1,info_len,'BF'x) || ('BB'x)\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OMTREEH": {"ttr": 1801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "TRAMSEI"}, "text": ")ATTR\n  01 TYPE(TEXT) CAPS(OFF) INTENS(HIGH) COLOR(WHITE)\n  02 TYPE(TEXT) CAPS(OFF) INTENS(HIGH) COLOR(BLUE)\n  }  TYPE(TEXT) CAPS(OFF) INTENS(HIGH) COLOR(RED)\n  04 TYPE(TEXT) CAPS(OFF) INTENS(HIGH) COLOR(GREEN)\n  05 TYPE(TEXT) CAPS(OFF) INTENS(HIGH) COLOR(PINK)\n  {  TYPE(TEXT) CAPS(OFF) INTENS(HIGH) COLOR(TURQ)\n  !  TYPE(TEXT) CAPS(OFF) INTENS(HIGH) COLOR(YELLOW)\n)BODY WINDOW(72,18) WIDTH(72) EXPAND(@@)\n%\n%@ @}OMTREE%- Display all currently mounted HFS @ @+\n%\n{ OMTREE shows you the names, mountpoints and permission schemes of all+\n{ HFS's currently mounted on the system. Their relationship is shown in+\n{ a pseudo-graphic way to let you easily identify sisters, children, and\n{ the mother of a given HFS.\n{ The only parm that OMTREE accepts is the displaymode. you may specify+\n{ either!\"GRAPHIC\"{(needs ISPF 4.1 or better and a graphic terminal or +\n{ an emulator that supports graphics and APL),!\"CHAR\"{that uses conven-+\n{ tioal charactes or!\"DEFAULT\"{that uses the capabilities of the 3278-T+\n{ characterset. If no parm is specified, OMTREE tries to elabotrate the+\n{ \"best fitting\" one.\n{ As an additional feature, you may branch into the ISPF-shell by typing\n{ either an!S{or a!/{in front of the ISHELL-field. The mountpoint of the\n{ selected HFS will become your working directory. +\n{\n%@ @ Have fun.+\n)INIT\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OMTREE1": {"ttr": 1803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "TRAMSEI"}, "text": ")ATTR DEFAULT(%+_)\n ! TYPE(OUTPUT) INTENS(HIGH) COLOR(TURQ) JUST(RIGHT)\n } TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n  * AREA(DYNAMIC) SCROLL(ON) EXTEND(ON)\n $ TYPE(CHAR) INTENS(HIGH) COLOR(YELLOW) GE(ON)\n 01 TYPE(DATAIN) INTENS(HIGH) COLOR(TURQ) PAD('_')\n 02 TYPE(DATAOUT) INTENS(HIGH) COLOR(RED)\n 03 TYPE(DATAOUT) INTENS(HIGH) COLOR(YELLOW)\n 04 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 05 TYPE(DATAOUT) INTENS(HIGH) COLOR(TURQ)\n)BODY EXPAND(//)\n}/-/HFS-Tree Structure/-/+\n%OPTION ====>_ZCMD                                            %SCROLL ===>_Z   +\n%Row!flin%to!vlin%of!tlin+ / /   / / %Col!fcol%to!lcol%of!tcol+\n*dyndisp,shadow                                                                *\n*                                                                              *\n+\n)INIT\n  .HELP = OMTREEH\n  .ZVARS = 'ZSCML'\n  &VDEPTH = LVLINE(dyndisp)\n)REINIT\n  &VDEPTH = LVLINE(dyndisp)\n)PROC\n  &VDEPTH = LVLINE(dyndisp)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRINTREG": {"ttr": 1805, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x00\\x90\\x00\\x90\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 144, "newlines": 144, "modlines": 0, "user": "TRAMSEI"}, "text": "*/********************************************************************/\n*/*                                                                  */\n*/*  PRINTREG MACRO:                                                 */\n*/*  MAKE A FULLWORD OR REGISTER CONTENT PRINTABLE                   */\n*/*  PARAMETERS:                                                     */\n*/*  -----------                                                     */\n*/*  FIRST IS POSITIONAL: FULLWORD OR REGISTER TO BE PRINTED.        */\n*/*  DEFAULT:             NONE                                       */\n*/*                                                                  */\n*/*  PADCHAR=           : PADDING CHARACTER TO BE USED INSTEAD OF    */\n*/*                       LEADING ZEROES. CAN BE ANY PRINTABLE       */\n*/*                       CHARACTER. SPECIAL CASES: 'BLANK' USES     */\n*/*                       X'40', 'NULLSTRING' RETURNS RESULT IN      */\n*/*                       \"EXECUTED\" FORM, WITHOUT LEADING PADS.     */\n*/*  DEFAULT            : X'F0'                                      */\n*/*                                                                  */\n*/*  RESULT=            : SPECIFIES WHICH NUMBER MODE TO USE AS      */\n*/*                       OUTPUT: MUST BE EITHER 'DECIMAL' OR        */\n*/*                       'HEX', WHICH IS THE DEFAULT                */\n*/*                                                                  */\n*/*  REGISTER-CONTENTS AT RETURN:   REG. 15 CONTAINS 0, REGISTER 0   */\n*/*                       THE LENGTH OF THE RESULT (INCLUDING PAD-   */\n*/*                       DING CHARACTERS), AND R1 POINTS TO THE     */\n*/*                       ANSWER AREA.                               */\n*/*                       IF RESULT IS DECIMAL, THERE ARE 16 BYTES   */\n*/*                       RETURNED.                                  */\n*/*                                                                  */\n*/*  THE MACRO PRINTREG IS REENTRANT.                                */\n*/*                                                                  */\n*/********************************************************************/\n         MACRO\n&NAME    PRINTREG &PRINTV,&PADCHAR=,&RESULT=\n.*********************************************************************\n.* SET LOCAL VARIABLES\n.*********************************************************************\n&A       SETA  &SYSNDX             LABEL/FIELD NAME INDEX\n         LCLB  &EXFLAG,&BLKFLAG,&DEFPAD,&TRFLAG,&EDFLAG\n         LCLC  &PCHAR\n.*********************************************************************\n.* BUMP OVER PSEUDO-DSECT WHICH DETERMINES THE AMOUNT OF STORAGE\n.* NEEDED WHITIN THE MACRO\n.*********************************************************************\n         B     CHK&A\n.*\n         DS    0F                  ALIGN STORAGE\nWORKDW&A DS    D                   USED FOR CVD\nWKMASK&A DS    CL16                USED FOR EDIT\n         DS    CL1                 WORKBYTE FOR UNPACK\nLWRKDS&A EQU   *-WORKDW&A\n.*************\n.* CONSTANTS\n.*************\nEDMASK&A DC    XL16'F0202020202020202020202020202020'   EDIT-MASK\nTRTAB&A  DC    XL240'00'\n         DC    C'0123456789ABCDEF'     TRANSLATION-TABLE\n.*\nCHK&A    DS    0H\n.*\n.*********************************************************************\n.* START REGULAR ASSEMBLER PROCESSING HEREAFTER\n.*********************************************************************\n.*\n         STORAGE OBTAIN,LENGTH=LWRKDS&A,LOC=ANY  STAY REENTRANT\n.*\n&PCHAR   SETC  '0'                 THE PADDING CHARACTER\n&EXFLAG  SETB  ('&PADCHAR' EQ 'NULLSTRING')  SET EXECUTE-FORM FLAG\n&BLKFLAG SETB  ('&PADCHAR' EQ 'BLANK')       PADCHAR IS BLANK\n&DEFPAD  SETB  (('&PADCHAR' EQ '') OR ('&PADCHAR' EQ '0') OR           X\n               (&EXFLAG))          IS IT THE DEFAULT-PADDING ?\n         AIF   ((&EXFLAG) OR (&BLKFLAG) OR (&DEFPAD)).PADOK\n         AIF   (K'&PADCHAR EQ 1).MOVEIT      IF PADCHAR GIVEN, REFILL\n         MNOTE 8,'PADDING CHARACTER '&PADCHAR' IS INVALID'\n         MEXIT\n.MOVEIT  ANOP\n&PCHAR   SETC  '&PADCHAR'\n.PADOK   ANOP\n.*\n.*********************************************************************\n.* IF THE RESULT SHOULD BE HEXADECIMAL, USE TRANSLATE\n.*********************************************************************\n.*\n&TRFLAG  SETB  (('&RESULT' EQ '') OR ('&RESULT' EQ 'HEX'))\n&EDFLAG  SETB  ('&RESULT' EQ 'DECIMAL')    RESULT WILL BE DECIMAL\n         AIF   ((&TRFLAG) OR (&EDFLAG)).RESLTOK   IS RESULT= VALID?\n         MNOTE 8,'RESULT MUST EITHER BE \"HEX\" OR \"DECIMAL\"'\n         MEXIT\n.RESLTOK ANOP\n.*\n.******************************************************************\n.* IF THE &PRINTV PARAMETER IS A REGISTER BRANCH TO ISAREG  TO\n.* PROCESS IT.\n.******************************************************************\n.*\n         AIF   ('&PRINTV'(1,1) NE '(').ISNOREG     NOT REGISTERFORM\n         LR    15,&PRINTV               LOAD REGISTER TO BE PRINTED\n         AGO   .GOTVAL\n.ISNOREG L     15,&PRINTV               FULLWORD PASSED, USE LOAD\n.GOTVAL  ANOP\n.********************************************************************\n.*  DECIDE WHETHER TO EDIT OR TO UNPACK/TRANSLATE THE INPUT\n.********************************************************************\n         AIF   (&TRFLAG).DOTRANS        DO I HAVE TO TRANSLATE ?\n         CVD   15,0(1)                  CONVERT TO DECIMAL\n         MVC   8(16,1),EDMASK&A         MOVE THE EDITMASK THEREAFTER\n.*********************************************************************\n.* IF NO PADCHAR HAS BEEN PASSED, THEN JUMP AT END OF PADCHAR CHECKS\n.*********************************************************************\n.*\n         AIF   (&DEFPAD).DOEDIT         DEFAULT PADDING REQ'ED ?\n         AIF   (&BLKFLAG).MOVEBL        BLANK REQUIRED ?\n         MVI   8(1),C'&PCHAR'           MOVE THE PADCHAR INTO EDITMASK\n         AGO   .DOEDIT\n.MOVEBL  MVI   8(1),C' '                MOVE IN A BLANK AT POSTION 1\n&PCHAR   SETC  ' '\n.DOEDIT  ED    8(16,1),0(1)             EDIT THE DW\n         AGO   .STORREL                 BUMP OVER TRANSLATE-PROCESSING\n.DOTRANS ST    15,0(1)                  STORE R15 INTO GETMAINED AREA\n         UNPK  8(9,1),0(5,1)            UNPACK IT INTO RESULT-AREA\n         TR    8(8,1),TRTAB&A           TRANSLATE THE STUFF\n         MVI   16(1),C' '               CLEAR WORKBYTE AT THE END\n         AIF   ((&EXFLAG) OR (&DEFPAD)).STORREL    DEF. PAD, CONTINUE\n         LR    15,1                     POINT AT BEGIN OF RESULT\n         LA    0,7                      MAX. 7 PADS, ELSE ZERO\nTRLUP&A  CLI   8(15),C'0'               IS IT A '0' ?\n         BNE   ENDPAD&A                 (BNE=NO, NO FURTHER PADDING)\n         MVI   8(15),C'&PCHAR'          MOVE THE PADCHAR IN THERE\n         LA    15,1(,15)                POINT AT NEXT CHARACTER\n         BCT   0,TRLUP&A                RETRY\nENDPAD&A DS    0H                       END OF PADDING ACTIONS\n.STORREL STORAGE RELEASE,LENGTH=LWRKDS&A,ADDR=(1) STAY REENTRANT\n         LA    1,8(0,1)                 POINT THE EDITED/TRLTED AREA\n         LA    0,8                      ASSUME TRANSLATE, SO L=8\n         AIF   (&TRFLAG).GOTLEN         IS IT REALLY TRLATED ?\n         LA    0,16                     NO, LENGTH IS 16\n.GOTLEN  AIF   (&EXFLAG EQ 0).BYEBYE    NO EXECUTE TO MAKE, GO AHEAD\nCMP&A    CLI   0(1),C'0'                IS IT NO DATA ?\n         BNE   ENDLUP&A                 (BNE=NO, START OF DATA, EXIT)\n         LA    1,1(,1)                  POINT TO NEXT BYTE\n         BCT   0,CMP&A                  RE-DO TEST\n         BCTR  1,0                      IF ALL ZEROES, JUST GO 1 BACK\n         LA    0,1                      LOAD LENGTH OF 1\nENDLUP&A DS    0H                       END OF \"EXECUTING\"\n.BYEBYE  XR    15,15                    CLEAR WORKREG\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QCMC": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x00\\xea\\x00\\xea\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 234, "newlines": 234, "modlines": 0, "user": "TRAMSEI"}, "text": "/* Rexx */\n/* QCMD Console-Interface                                           */\n/* This procedure establishes the Console-interaction between QCMD  */\n/* and the user.                                                    */\n/* The Command-Syntax is the same as invoking QCMD directly.        */\n/* Exceptions: Messagedelivery MUST be 'V'                          */\n/*             QCMD must not be specified in front of the Command.  */\n/* Please remember that the assigned Console-Authority is MASTER.   */\n/* CLASS OPERCMDS does not affect QCMD.                             */\n/*                                                                  */\n/* The QCMD-Syntax is as follows:                                   */\n/*                                                                  */\n/* 1. with a native MVS-Command:  TSO QCMD command                  */\n/*    command may be any valid MVS-Command:                         */\n/*                                                                  */\n/*    TSO QCMD CF CHP(xx),ONLINE or TSO QCMD D GRS,C                */\n/*                                                                  */\n/* 2. With additional Parameters, other than Command                */\n/*                                                                  */\n/*    TSO QCMD CMD=(command),T=x,M=y                                */\n/*                                                                  */\n/*      - command: see above                                        */\n/*      - T=x:     the time in seconds to wait for the message.     */\n/*                 (1-999)                                          */\n/*      - M=P:     Message-delivery: P=PUTLINE (default)            */\n/*          V:                       V=into Rexx-Variables          */\n/*          B:                       B=Both                         */\n/*                                                                  */\n/*    Assume that 'TSO QCMD F LLA,REFRESH' returns no message.      */\n/*    So specifiy 'TSO QCMD CMD=(F LLA,REFRESH),T=10 and you may    */\n/*    get it into 10 seconds.                                       */\n/*    With the Console-Interface, M=V is recommended.               */\n/*                                                                  */\n/* The following Rexx-variables are created by QCMD M=V or BOTH:    */\n/*                                                                  */\n/* \"Normal\"-MVS-Command             Variable contents:              */\n/* --------------------             ----------------------------    */\n/* QCMD.MSG_COLOR.0                 Number of Color-elements        */\n/* QCMD.MSG_COLOR.1-n               Color-attribute of Message      */\n/* QCMD.MSG_HILITE.0                Number of hilite-Attributes     */\n/* QCMD.MSG_HILITE.1-n              Hilite-attribute of Message     */\n/* QCMD.MSG_TEXT.0                  Number of Messages returned     */\n/* QCMD.MSG_TEXT.0-n                Message Text 1-n                */\n/* QCMD_RC                          Function Return-Code            */\n/*                                  0 - Execution Successfull       */\n/*                                  8 - No Message Returned         */\n/*                                                                  */\n/* Specialcase GET_REPLIES          Variable contents:              */\n/* -----------------------          ----------------------------    */\n/* QCMD.REPLY_ID.0                  Number of Outstanding WTORs     */\n/* QCMD.REPLY_ID.1-n                Reply-Ids 1-n                   */\n/* QCMD.REPLY_ID.0                  Number of Outstanding WTORs     */\n/* QCMD.REPLY_ID.1-n                Reply-Ids 1-n                   */\n/* QCMD.ISSUER.0                    Number of Owners of WTORs       */\n/* QCMD.ISSUER.1-n                  Owners list                     */\n/* QCMD.JOB_ID.0                    Number of Jobname-Elements      */\n/* QCMD.JOB_ID.1-n                  Tasknames of WTORS              */\n/* QCMD.JOB_NAME.0                  Number of taskname-Elements     */\n/* QCMD.JOB_NAME.1-n                tasknames of Wtors              */\n/* QCMD.REPLY_TEXT.0                Number of Outstanding WTORs     */\n/* QCMD.REPLY_TEXT.1-n              Text-Ids                        */\n/* QCMD_RC                          Function Return-Code            */\n/*                                  0 - Execution Successfull       */\n/*                                  4 - No Replies outstanding      */\n/*                                  8 - No Message Returned         */\n/*                                                                  */\n/* QCMD Runs as a TSO-Command in Foreground- or in Batchmode.       */\n/*                                                                  */\n/*                                  6.1.97 $$TRA                    */\n/*                                                                  */\n/********************************************************************/\nAddress TSO\nArg mvscmd\nflin = 0\ntlin = 0\nllin = 0\nIf mvscmd = '' Then                /* No Command passed, show panel */\n  Do While mvscmd = ''\n    'ISPEXEC DISPLAY PANEL(QCMP010) CURSOR(MVSCMD)'\n    If Rc > 0 Then\n      Exit\n  End\nspos = Pos('CMD=(',mvscmd)\nIf spos > 0 Then                   /* Parameters other than command?*/\n  Do\n    cut_pos = Substr(mvscmd,Lastpos(')',mvscmd))\n    Parse Var cut_pos . 'M='dlv .\n    If dlv = '' Then\n      mvscmd = mvscmd',M=V'\n    Else If Pos('V',dlv) \u00ac= 1 Then\n      Do\n        Say 'Invalid messagedelivery specified. Must be V w. Console.'\n        Exit\n      End\n    Else\n      Nop\n  'QCMD 'mvscmd                    /* Yes, Issue ASIS               */\n  End\nElse\n  'QCMD CMD=('mvscmd'),M=V'        /* No, Set delivery to rexx-vars */\ndyndisp = ''\ndatastr = ''\nnewfirst = 1\ndisp_Rc = 0\n'ISPEXEC PQUERY PANEL(QCMP010) AREANAME(DYNDISP) WIDTH(DYNWIDTH),\n         DEPTH(DYNDEPTH)'\npagelen = dynwidth * dyndepth      /* visible page */\nj = 0\nIf Qcmd_Rc = 0 Then                /* something returned ? */\n  Do\n    Upper mvscmd\n    If Pos('GET_REPLIES',mvscmd) > 0 Then\n      Do\n        qcmdc1 = 'RED'\n        qcmdh1 = 'USCORE'\n        qcmdc2 = 'BLUE'\n        qcmdc3 = 'YELLOW'\n        qcmdc4 = 'TURQ'\n        line = ('04'x) || (' Replies Outstanding: ') || ('04'x) ||,\n                 (qcmd.reply_id.0) || ('02'x)\n        datastr = datastr''Substr(line,1,dynwidth)\n        Do i = 1 to qcmd.reply_id.0\n          datastr = datastr''Substr(' ',1,dynwidth,' ')\n          line = ('02'x) || (' Reply-Id:     ') || ('01'x) ||,\n                 (qcmd.reply_id.i) || ('02'x)\n          datastr = datastr''Substr(line,1,dynwidth)\n          line = ('02'x) || (' Reply-Issuer: ') || ('03'x) ||,\n                 (qcmd.issuer.i) || ('02'x)\n          datastr = datastr''Substr(line,1,dynwidth)\n          line = ('02'x) || (' Taskname:     ') || ('03'x) ||,\n                 (qcmd.job_id.i) || ('02'x)\n          datastr = datastr''Substr(line,1,dynwidth)\n          line = ('02'x) || (' Tasknumber:   ') || ('03'x) ||,\n                 (qcmd.job_number.i) || ('02'x)\n          datastr = datastr''Substr(line,1,dynwidth)\n          line = ('02'x) || (' Reply-Text:   ') || ('03'x) ||,\n                 (qcmd.reply_text.i) || ('02'x)\n          If Length(line) > dynwidth Then\n            Do\n              lastwrd = Lastpos(' ',line)\n              contpos = Pos(qcmd.reply_text.i,line)\n              line1 = Substr(line,1,lastwrd)\n              line1 = Substr(line1,1,dynwidth,' ')\n              line2 = Substr(line,lastwrd+1)\n              line2 = Copies(' ',contpos-1)''Substr(line,lastwrd+1)\n              line2 = Substr(line2,1,dynwidth,' ')\n              line = line1''line2\n              datastr = datastr''line\n            End\n          Else\n            datastr = datastr''Substr(line,1,dynwidth)\n        End\n      End\n    Else Do i = 1 to qcmd.msg_color.0\n      j = j + 1\n      attr_char = D2c(j)\n      Interpret 'qcmdc'j' = 'qcmd.msg_color.i\n      If qcmd.msg_hilite.i \u00ac= 'DEFAULT' Then\n        Interpret 'qcmdh'j' = 'qcmd.msg_hilite.i\n      line = Substr(attr_char''qcmd.msg_text.i,1,dynwidth)\n      datastr = datastr''line\n      If j / dyndepth = 1 Then\n        j = 0\n    End\n    curfld = 'ZCMD'\n    mvscmd = ''\n  End\nElse                          /* Nothing returned, show errormsg */\n  Do\n    qcmdc1 = 'TURQ'\n    qcmdh1 = 'REVERSE'\n    pad = Substr(' ',1,4*dynwidth,' ')\n    pad1 = ('01'x) || (Substr(' ',1,dynwidth-2,' ')) || ('02'x)\n    li.1 = ' '\n    If qcmd_Rc = 8 Then\n      Do\n        li.2 = 'Error: Command 'mvscmd' Returns no message.'\n        li.3 = 'Enter YES to re-execute the Command with a wait',\n                'time of 10 seconds.'\n      End\n    If qcmd_Rc = 4 Then\n      Do\n        li.2 = '***** No outstanding replies found. *****'\n        li.3 = 'Request GET_REPLIES ended with an RC=4.'\n        mvscmd = ''\n      End\n    li.4 = ' '\n    li.0 = 4\n    Do i = 1 to li.0\n      li.i = ('01'x) || (' ') || ('02'x) || (Centre(li.i,dynwidth-6))\n      li.i = (li.i) || ('01'x) || (' ') || ('02'x)\n      datastr = (datastr) || (li.i)\n    End\n    curfld = 'MVSCMD'\n    savecmd = mvscmd\n    datastr = (pad) || (pad1) || (datastr) || (pad1)\n  End\nDo While disp_Rc \u00ac= 8\n  dyndisp = Substr(datastr,newfirst,pagelen,' ')\n  If qcmd_Rc = 8 Then\n    mvscmd = 'YES'\n  Else If qcmd_rc = 4 Then\n    Nop\n  Else                                   /* line-counters */\n    Do\n      flin = newfirst % dynwidth + 1\n      tlin = length(datastr) % dynwidth\n      llin = flin + dyndepth - 1\n      If llin > tlin Then\n        llin = tlin\n    End\n  'ISPEXEC DISPLAY PANEL(QCMP010) CURSOR('CURFLD')'\n  disp_Rc = Rc\n  If disp_Rc = 8 Then\n    Exit\n  If mvscmd \u00ac= '' Then\n    Do\n      If qcmd_Rc = 8 Then\n        Do\n          If mvscmd = 'YES' Then\n            mvscmd = 'CMD=('savecmd'),M=V,T=10'\n        End\n      Call QCMC mvscmd\n      Exit\n    End\n  'ISPEXEC VGET (ZVERB ZSCROLLA ZSCROLLN)'\n  If Wordpos(zverb,'UP DOWN') > 0 Then\n    Do                            /* Yes, so do it.                 */\n      Call QCMSCRL 'P=QCMP010 A=DYNDISP F='zverb' V='dyndepth ,\n                 'S='zscrolla' L='Length(datastr)' T='newfirst\n      newfirst = Result\n    End\nEnd\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QCMD": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x05j\\x05j\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 1386, "newlines": 1386, "modlines": 0, "user": "TRAMSEI"}, "text": "//T750KQ   JOB (317,04,E150AQ),'RAMSEIER',\n//             MSGLEVEL=(1,1),\n//             CLASS=A,\n//             MSGCLASS=T,\n//             NOTIFY=&SYSUID,\n//             TIME=NOLIMIT\n//*MAIN SYSTEM=SYT\n//*\n//ASM      EXEC PGM=ASMA90,REGION=2048K,\n//          PARM='NODECK,OBJECT,RENT'\n//SYSIN     DD *\nQCMD     TITLE '*** \"QCMD\" *** TSO COMMAND PROCESSOR &SYSDATE'\n***********************************************************************\n*                                                                     *\n*     QCMD    - SET UP AN EXTENDED MULTIPLE CONSOLE SUPPORT (MCS)     *\n*               ENVIRONMENT                                           *\n*                                                                     *\n*     CALL: 1.: TSO QCMD ....   (DESIRED COMMAND, NOT QUOTED)         *\n*                                                                     *\n*           2.: TSO QCMD CMD=(CCCCCCCCCCCC),T=SSS,M=X                 *\n*               CCCCC IS THE COMMAND YOU WANT TO PERFORM              *\n*               SSS   IS THE DECIMAL NUMBER OF SECONDS YOU WANT TO    *\n*                     WAIT FOR A MESSAGE TO ARRIVE                    *\n*               X     IS THE MESSAGE-DELIVERY FORMAT:                 *\n*               P = PUTLINE-DELIVERY (DEFAULT)                        *\n*               R = DELIVERY INTO REXX-VARIABLES (SEE REXX-QCMC)      *\n*               B = BOTH OF THEM                                      *\n*                                                                     *\n*           SO, IF YOU'RE HAPPY WITH THE DEFAULT OF 1 SECOND, JUST    *\n*           USE CALL FORMAT 1, OTHERWISE SET THE DESIRED WAIT-TIME    *\n*           BY USING CALL-FORMAT 2                                    *\n*                                                                     *\n*                                                                     *\n*     THE CP RUNS EITHER AS A TSO-COMMAND (ONLINE OR BATCH)           *\n*            OR CALLED BY A REXX-PROCEDURE (ONLINE OR BATCH)          *\n*                                                                     *\n*     THE CP RETURNS RESULTS VIA THE PUTLINE-COMMAND; SO              *\n*         THE ANSWER CAN BE PROCESSED VIA THE OUTTRAP-FUNCTION        *\n*         IN REXX EXEC'S                                              *\n*                                                                     *\n*     THE CP USES MASTER-CONSOLE AUTHORITY, SO YOU DON'T HAVE TO      *\n*         ACTIVATE THE RACF-OPERCMDS CLASS TO ISSUE COMMANDS OTHER    *\n*         THAN DISPLAY (AS IN SYSCMD - FUNCTION IN REXX)              *\n*                                                                     *\n*     SYSTEM-REQUIREMENTS:                                            *\n*     --------------------                                            *\n*     THE CP MUST BE ASSEMBLED + LINKED RENT,REUS,AC=1                *\n*     IT MUST RUN IN AUTHORIZED STATE BECAUSE OF THE MODESET          *\n*     REQUIREMENTS                                                    *\n*     IT IS REENTRANT + REUSABLE                                      *\n*     IT MUST BE SPECIFIED IN THE AUTHCMD FIELD OF                    *\n*     IKJTSOXX-MEMBER IN SYS1.PARMLIB                                 *\n*     MODULE SHOULD RESIDE IN A LNKLST-CONCATENATED LIBRARY           *\n*                                                                     *\n* SAMPLE: - TSO QCMD D NET,PENDING      -> RETURNS ALL PENDING RES.   *\n*                                                                     *\n*         - TSO QCMD CMD=(F LLA,REFRESH),T=15  -> WAIT 15 SEC. FOR    *\n*                                              MESSAGE 'LLA REFRESHED'*\n*                                                                     *\n* SPECIALS: TSO QCMD GET_REPLIES GETS A LIST OF ALL CURRENTLY OPEN    *\n*           REPLIES.                                                  *\n*                                                                     *\n* LIMITS: - THE CP CAN NOT TRAP UNSOLICITED MESSAGES                  *\n*                                                                     *\n*         - THE MAX. NUMBER OF MESSAGES THAT CAN BE TRAPPED IS DETER- *\n*           MINED BY THE SIZE OF THE ALLMSGS-FIELD.                   *\n*                                                                     *\n*         - SOME COMMANDS RETURN MORE THAN 1 MDB, E.G. THE $DI CMD.   *\n*           AND SO, ESPECIALLY WHEN WAITING Q LONGTIME FOR RESPONSES, *\n*           YOU WILL RECEIVE UNSOLICITED MESSAGES OF OTHER COMMANDS.  *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*     EQUATES                                                         *\n***********************************************************************\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2                      WORK-REGISTER\nR3       EQU   3                      WORK-REGISTER\nR4       EQU   4                      WORK-REGISTER\nR5       EQU   5                      WORK-REGISTER\nR6       EQU   6                      WORK-REGISTER\nR7       EQU   7                      WORK-REGISTER\nR8       EQU   8                      ERROR-MSG-POINTER\nR9       EQU   9                      GETMAINED AREA\nR10      EQU   10                     BAL\nR11      EQU   11                     BASE #1\nR12      EQU   12                     BASE #2\nR13      EQU   13                     HIGHER SAVE-AREA\nR14      EQU   14                     BAKR\nR15      EQU   15                     RC\n         EJECT\n***********************************************************************\n*     START                                                           *\n***********************************************************************\nQCMD     CSECT\nQCMD     AMODE 31\nQCMD     RMODE ANY\n         PRINT NOGEN\n         LR    R3,R1                  SAVE PASSED PARAMETERS\n         SPACE 2\n         BAKR  14,0                  ESTABLISH LINKAGE-CONVENTIONS\n         LR    R11,R15               LOAD TEMPORARY BASE TO MY BASE\n         LA    R12,2048               LOAD 2NDRY BASE  ..\n         LA    R12,2048(R12,R11)     W. 2ND 4K\n         USING QCMD,R11,R12          TELL ASSEMBLER\n         LR    R3,R1                 ESTABLISH CPPL'S  ADDRESSABILITY\nGETSTOR  DS    0H\n         STORAGE OBTAIN,LENGTH=LDWORK,LOC=BELOW     GET WORK STORAGE\n         LR    R9,R1                 ESTABLISH DSECT'S ADDRESSABILITY\n         USING DWORK,R9              TELL ASSEMBLER\n         BAL   R10,LOADCPPL          SAVE CPPL INTO MY IOPL\n         BAL   R10,GETPARMS          GET THE PARAMETER-STRING\n         LTR   R15,R15               WENT IT OK ?\n         BNZ   ENDIT                 (BNZ = NO, ERRORMSG + OUT)\nSETAUTH  MODESET MF=(E,SUPRMOD)      GET ME INTO SUPERVISOR MODE\n         STAX  DEFER=YES             NO ATTENTION EXITS, PLEASE\n         MODESET MF=(E,PROBMOD)      RETURN INTO PROBLEM MODE\n         BAL   R10,CONSACT           ACTIVATE MCS-CONSOLE SESSION\n         LTR   R15,R15               WENT IT OK ?\n         BNZ   ENDIT                 (BNZ = NO, ERRORMSG + OUT)\nMAIN0040 CLI   REPLYFLG,C'Y'         SHALL I TRAP REPLY-IDS ?\n         BE    GETRPLYS              (BE=YES, GET THE REPLY-IDS)\n         BAL   R10,EXECCMD           GO AND EXECUTE THE COMMAND\n         BAL   R10,WAITMSG           WAIT FOR MESSAGE\n         BAL   R10,GETMSG            DO ORDINARY MDB-BUSINESS\n         BAL   R10,CLEANUP           CLEANUP BEFORE RETURNING ERRORMSG\n         LTR   R15,R15               R15 SET BY GETMSG. IS IT ZERO ?\n         BNZ   ENDIT                 (BNZ = NO,RETURN THE ERRORMESSAGE)\n         BAL   R10,PUTLBSNS          DO THE PUTLINE-BUSINESS\n         BAL   R10,RETRESLT          PREPARE THE RESULT\n         BAL   R10,BUILDVAR          BUILD THE REXX-VARIABLES\n         B     ENDIT\nGETRPLYS BAL   R10,CHKRPLYS          CHECK FOR ACTIVE REPLIES\n         LTR   R15,R15               WENT IT OK ?\n         BZ    SETUPXME              (BZ = YES, CONTINUE)\n         BAL   R10,CLEANUP           NO REPLIES, CLEANUP AND ...\n         B     ENDIT                 ... RETURN\nSETUPXME BAL   R10,XMEMINIT          INITIALIZE CROSS-MEMORY SESSION\n         BAL   R10,CLEANUP           CLEANUP\n         BAL   R10,PUTLBSNS\n         BAL   R10,BUILDVAR          BUILD THE REXX-VARIABLES\n*\nENDIT    DS    0H\n         ST    R8,WORKRC\n         LTR   R15,R15               WENT EVERYTHING OK ?\n         BZ    END0015               (BZ = YES, SET RC = 0)\n         CLI   REPLYFLG,C'Y'\n         BNE   END0014\n         MVI   QCMDRC,C'4'           INDICATE RC=4 TO BE SET\n         B     END0017\nEND0014  MVI   QCMDRC,C'8'           INDICATE RC=8 TO BE SET\n         B     END0017\nEND0015  MVI   QCMDRC,C'0'           INDICATE RC=0 TO BE SET\nEND0017  BAL   R10,SETRCODE          SET RC-VARIABLE = 8\n         BAL   R10,BUILDVAR          WRITE IT INTO REXX-VARIABLE\n         CLI   QCMDRC,C'0'\n         BE    RELSTOR\n         CLI   MSGDFLAG,MSGDVREX\n         BE    RELSTOR\n         L     R8,WORKRC\nEND0020  LA    R4,IOPLADS            LOAD DYNAMIC IOPL\n         USING IOPL,R4               FILL IT\n         L     R3,CPLUPT             LOAD DYN. USER'S PROFILE TABLE\n         ST    R3,IOPLUPT            STORE IT IN THE IOPL\n         L     R3,CPLECT             LOAD ADDRESS OF DYN. ECT\n         ST    R3,IOPLECT            STORE IT IN THE IOPL\n         LA    R3,ECBADS             LOAD ADDR OF MY ECB TO R3\n         ST    R3,IOPLECB            STORE ADDRESS OF ECBADS IN IOPL\n         MVC   @MLWAREA(L@PUTLIN),@PUTLIN\n         MVC   DTEXTADS(LTEXTADS),TEXTADS   MOVE CONSTANT TO MY AREA\n         MVC   DTEXTADS+4(LERRMSGS),0(R8)\n         PUTLINE PARM=@MLWAREA,                                        X\n               OUTPUT=(DTEXTADS,TERM,SINGLE,DATA),MF=(E,IOPLADS)\nRELSTOR  DS    0H\n         STORAGE RELEASE,LENGTH=LDWORK,ADDR=(R9)     FREE WORK STORAGE\n         PR                           END QCMD + CLEANUP\n*\n***********************************************************************\n*     EXECUTE                                                         *\n***********************************************************************\nMOVETIM1 MVC   0(0,R5),0(R3)\nMOVEPRM1 MVC   PARMSTR(0),4(R3)\nMOVECMD1 MVC   MGCMD(0),0(R4)\nHEXCMD1  XC    0(0,R4),0(R4)\n         USING MDBT,R3\nMOVEMSG1 MVC   0(0,R6),MDBTMSGT+1\n         USING WQE,R2\nMOVEALE1 MVC   0(0,R6),WQETXT\n*\nMVCBLD1  MVC   RXVNAME(0),0(R7)\nMVCBLD2  MVC   RXVVAL(0),0(R7)\n*\nPUTLMVC1 MVC   DTEXTADS+4(0),2(R3)\n***********************************************************************\n*     SUBROUTINES                                                     *\n***********************************************************************\n*\nLOADCPPL ST    R10,SAVE10\n         USING CPPL,R3                GET THE ADDRESSES IN CPPL\n         MVC   CPLCBUF,CPPLCBUF       MOVE COMM.-BUFFER ADDR TO MY AREA\n         MVC   CPLUPT,CPPLUPT         MOVE USERPROFTAB ADDR TO MY AREA\n         MVC   CPLPSCB,CPPLPSCB       MOVE PROT.STEP-CB ADDR TO MY AREA\n         MVC   CPLECT,CPPLECT         MOVE ECT-ADDRESS TO MY AREA\n         DROP  R3                     FREE CPPL\n         L     R10,SAVE10\n         BR    R10\n*\n*********************************************************************\n* GET PASSED PARAMETERS\n*********************************************************************\n*\nGETPARMS ST    R10,SAVE10\nPARMS001 DS    0H                    CHECK FOR APPROPRIATE ENVIRONMENT\n         MVC   @MLWAREA(L@EXTR),@EXTR    MOVE MF=L-WORKAREA INTO DSECT\n         LA    R2,DWTSO                  LOAD EXTRACT-ANSWER-AREA\n         EXTRACT (R2),MF=(E,@MLWAREA)    EXTRACT THE TSO-BLOCKS\n         LTR   R2,R2                 IS THERE ANY ADDRESS ?\n         BNZ   PARMS003              (BNZ=YES, WE'RE IN TSO)\n         LA    R15,8                 LOAD RC=8\n         LA    R8,ERR0030            POINT TO THE APPROPRIATE ERRMSG\n         B     PARMS090              SET ERROR-MSG + LEAVE\nPARMS003 L     R3,CPLCBUF            LOAD -> TO PARAMETERS\n         LH    R4,0(R3)              LENGTH OF PARMSTRING\n         LH    R5,2(R3)              OFFS. TO 1ST PARM OR L'NAME\n         SH    R4,=H'4'              SUBTR. LENGTH-FIELDS(=1FULLWORD)\n         CR    R5,R4                 IS OFFSET TO 1ST PARM = NAME ?\n         BNE   PARMS005              NO, SO WE GOT PARMS\n         LA    R15,8                 LOAD RC=8\n         LA    R8,ERR0010            POINT TO ERROR-MSG\n         B     PARMS090              SET ERROR-MSG + GO OUT\nPARMS005 DS    0H\n         SR    R4,R5                 TOT.LENGTH-OFFSET=EFFECT. LENGTH\n         AR    R3,R5                 ADD OFFSET TO CMDBUF ->\n         MVC   PARMSTR,BLANK         FILL THE PARAMETERSTRING W. BLANKS\n         MVC   PARMSTR+1(L'PARMSTR-1),PARMSTR ....\n         STH   R4,PARMLEN            STORE THE TOTAL LENGTH OF PARMS\n         STH   R4,MGCMDL             TWICE. ONE INTO CMD-LENGTH FIELD\n         BCTR  R4,0                  SUBTRACT 1 FOR EXECUTE\n         EX    R4,MOVEPRM1           WRITE IN THE PARMS\nPARMS007 DS    0H\n         TR    PARMSTR,ALFATAB       CONVERT TO UPPERCASE\n         LA    R3,PARMSTR            POINT TO START OF PARAMETERS\n         LH    R4,MGCMDL             LOAD LENGTH INTO R4\n**LOOP                               START OF PARM-WALKTHROUGH-LOOP\nPARMS010 DS    0H                    CHECK TYPE OF COMMAND PASSED:\n         CLC   0(5,R3),=CL5'CMD=('   IS IT TYPE 2 (W. T= + CMD=( ?\n         BNE   PARMS020              NO AT THIS POS. TRY NEXT\n         LA    R3,5(,R3)             YES, FOUND, BUMP BEHIND IT\n         ST    R3,STARTCMD           STORE THE STARTING ADDR. OF CMD\n         B     PARMS030              LEAVE THE LOOP\nPARMS020 LA    R3,1(R3)              NO CMD= FOUND, BUMP TO NEXT CHAR\n         BCT   R4,PARMS010           RE-DO THE LOOP\n**ENDLOOP                            END OF PARM-WALKTHROUGH-LOOP\n         LH    R3,MGCMDL             TYPE 1, JUST CMD CHOSEN, SO\n         LA    R4,PARMSTR            LOAD THE LENGTH + SET TIME-FLAG\n         MVI   TIMEFLAG,TIMEDEF      NO TIME SET, USE DEFAULT\n         MVI   MSGDFLAG,MSGDPUTL     INDICATE PUTLINE MESSAGEPROCESSING\n         B     FILLCMD               GO AND FILL IN THE COMMAND\nPARMS030 DS    0H                    THERE IS A CMD=(, SO POINT TO\n         LH    R4,MGCMDL             THE END OF THE COMMAND:\n         LA    R3,PARMSTR              - -> TO START OF CMD AND ...\n         AR    R3,R4                     -> ADD THE LENGTH OF THE CMD\n**LOOP                               START OF THE CMD-LOOP\nPARMS035 CLI   0(R3),C')'            DID WE GET A ')' ?\n         BE    PARMS040              YES, GO AHEAD\n         BCTR  R3,0                  NO, TRY NEXT\n         BCT   R4,PARMS035           RE-DO THE LOOP\n**ENDLOOP\n         LA    R15,8                 MISSING RIGHT PARANTHESIS.\n         LA    R8,ERR0020            SET APPROPRIATE ERROR-MSG + LEAVE\n         B     PARMS090\nPARMS040 DS    0H                    PREPARE SEPARATION  OF CMD-PART\n         L     R4,STARTCMD           LOAD START OF COMMAND-TEXT\n         SR    R3,R4                 SUBTRACT CURRENT POS OF ')'\n         STH   R3,MGCMDL             STORE EFFECTIVE COMMAND-LENGTH\n         BCTR  R3,0                  SUBTRACT 1 FOR EXECUTE\n         MVI   REPLYFLG,C'N'         DEFAULT: NOT A REPLY\nFILLCMD  EX    R3,MOVECMD1           FILL IN CMD-TYPE 1 OR 2\n         EX    R3,HEXCMD1            BLANK OUT, PREVENT T=MISMATCH\n         CLC   MGCMD(11),=CL11'GET_REPLIES'  DOES THE USER WANT RID?\n         BNE   TIMEBSNS              (BNE=NO, NORMAL BUSINESS)\n         MVI   REPLYFLG,C'Y'         SET REPLY-FLAG\n*\n* END OF COMMAND-SEPARATION\n*\nTIMEBSNS DS    0H                    TIME=BUSINESS\n         TM    TIMEFLAG,TIMEDEF      IS IT THE DEFAULT-TIME (1 SEC ?)\n         BO    DEFTIME               YES, NOTHING TO COMPUTE, GO THERE\n         LH    R4,PARMLEN            LOAD LENGTH OF PASSED PARMS\n         LA    R3,PARMSTR            POINT TO THE START\nTIME000  CLC   0(2,R3),=CL2'T='      IS THERE A T= ? (TIME-PARAMETER)\n         BE    TIME010               YES, FOUND. BRANCH THERE\n         LA    R3,1(R3)              POINT TO NEXT POSITION\n         BCT   R4,TIME000            RETRY.\n         B     DEFTIME               NO T= FOUND, USE DEFAULT\nTIME010  LA    R3,2(R3)              BUMP BEHIND T=\n         ST    R3,STARTTIM           STORE IT\n         XR    R4,R4                 INIT REG\nTIME011  CLI   0(R3),C'0'            IS THIS REALLY A NUMBER ?\n         BL    TIME015               NO, CHECK FURTHER\nTIME011A CLI   0(R3),C'9'            IS THIS REALLY A NUMBER ?\n         BH    TIME015               NO, CHECK FURTHER\n         LA    R4,1(,R4)             YES, INCR. POS. + LENGTH COUNTERS\n         LA    R3,1(,R3)\n         B     TIME011               AND LOOK FOR END OF PARM.\nTIME015  LTR   R4,R4                 IS THERE A VALID # AT ALL ?\n         BZ    DEFTIME               NO, USE DEFAULT-TIME\n         L     R3,STARTTIM           POINT TO START OF T= VALUE\n         LA    R5,TIMEVAL            INIT VALUE-FIELD TO GET IT PACKED\n         MVC   0(L'TIMEVAL,R5),=CL3'000'  EASILY.\n         LA    R6,L'TIMEVAL          LOAD MAX. LENGTH OF TIMER (3)\n         SR    R6,R4                 SUBTRACT PARMS LENGTH AND ...\n         AR    R5,R6                 ... POINT THERE.\n         BCTR  R4,0                  SUBTRACT 1 FOR EXECUTE AND ...\n         EX    R4,MOVETIM1           ... DO IT.\n         PACK  PACKPARM(2),TIMEVAL(3)  PACK THE DEC. TIMEVALUE ...\n         ZAP   TIMEDW,PACKPARM       ... AND STORE IT IN A DOUBLEWORD.\n         CVB   R4,TIMEDW             NOW THIS IS THE RIGTH FORM.\n         MH    R4,=H'100'            MAKE TIMER UNITS THEREOUT.\n         ST    R4,TIINTVL            STORE THIS VALUE\n         C     R4,=A(10*60*100)      IS THE WAIT TIME >=10 MINUTES\n         BNH   MSGDLVRY              (BNH=NO, LET IT)\nDEFTIME  MVC   TIINTVL,=A(0100)      SET DEFAULT-TIME OF 1 SECOND.\n*\nMSGDLVRY DS    0H                    CHECK MESSAGE DELIVERY\n         LH    R4,PARMLEN            LOAD LENGTH OF PASSED PARMS\n         LA    R3,PARMSTR            POINT TO THE START\nDLV0000  CLC   0(2,R3),=CL2'M='      IS THERE A M= ? (MSGD-PARAMETER)\n         BE    DLV0010               YES, FOUND. BRANCH THERE\n         LA    R3,1(R3)              POINT TO NEXT POSITION\n         BCT   R4,DLV0000            RETRY.\n         B     DEFDLVRY              NO M= FOUND, USE DEFAULT\nDLV0010  LA    R3,2(,R3)             BUMP BEHIND M=\n         CLI   0(R3),C'P'            PUTLINE-DELIVERY REQUIRED ?\n         BE    DEFDLVRY              (BNE=YES, THIS IS DEFAULT)\n         CLI   0(R3),C'V'            REXX-VARIABLE DELIVERY ?\n         BNE   DLV0015               (BNE=NO, TRY FURTHER)\n         MVI   MSGDFLAG,MSGDVREX     INDICATE REXX-VAR PROCESSING\n         B     PARMS080              BRANCH AT END\nDLV0015  CLI   0(R3),C'B'            IS BOTH REQUESTED?\n         BNE   DEFDLVRY              (BNE=NO, PARM-ERROR, USE DEFAULT)\n         MVI   MSGDFLAG,MSGDBOTH\n         B     PARMS080              BRANCH AT END\nDEFDLVRY DS    0H\n         MVI   MSGDFLAG,MSGDPUTL     INDICATE PUTLINE-PROCESSING\nPARMS080 XR    R15,R15\nPARMS090 DS    0H\n         L     R10,SAVE10\n         BR    R10\n         LTORG\n*********************************************************************\n* CONSACT: ACTIVATE MCS-SESSION\n*********************************************************************\nCONSACT  ST    R10,SAVE10            PREPARE CONSOLE-ACTIVATION\n         L     R2,PSAAOLD-PSA        PSAAOLD POINTS TO SUBMITTERS ASCB\n         L     R2,ASCBASXB-ASCB(,R2) ASCBASXB POINTS TO THE EXT. BLOCK\n         L     R2,ASXBSENV-ASXB(,R2) ASXBSENV POINTS TO THE ACEE\n         USING ACEE,R2               TELL ASSEMBLER\n         MVC   MCTERM(L'ACEEUSRI),ACEEUSRI  FILL MCS LU= WITH USERID\n         DROP  R2\n         MVC   MCNAME(8),=CL8'QCMD01'       FILL MCS CONSID W. QCMD01\nMCSOP010 DS    0H\n         MVC   @MLWAREA(L@MCSOP),@MCSOP\n         MODESET MF=(E,SUPRMOD)      GET ME INTO SUPERVISOR MODE\n         LA    R3,WAOPPARM           BUILD OPERPARM DEFAULTS\n         USING MCSOPPRM,R3           MAP AREA\n         MVI   MCSOAUTH,MCSOMSTR     SET MASTER AUTHORITY\n         MVI   MCSOMFRM,MCSOMFT      DISPLAY WITH A TIME STAMP\n         OI    MCSOMFRM,MCSOMFS      DISPLAY WITH THE SYSTEM NAME\n         OI    MCSOMFRM,MCSOMFJ      DISPLAY WITH JOB ID/NAME\n         MVI   MCSORCFL,MCSORCAL     ALL ROUTE CODES\n         MVI   MCSOLOGC,MCSOLOGN     DO NOT LOG THE ISSUED COMMAND\n         MVI   MCSOMIG,MCSOMIGY      ASSIGN A MIGRATION ID\n         MVC   MCSOKEY,=C'QCMD    '  USED FOR D C,KEY\n         OI    MCSOMISC,MCSOUDY      DISPLAY UD MESSAGES\n         OI    MCSOMISC,MCSOAUTN     DON'T QUEUE AUTOMATABLE MESSAGES\n         OI    MCSOFLAG,MCSOVRDY     OVERRIDE RACF PROFILE OPERPARM\n         MCSOPER REQUEST=ACTIVATE,   ACTIVATE MCS-CONSOLE              X\n               NAME=MCNAME,          CONSOLE-NAME                      X\n               CONSID=MCCONS,        CONSOLE-ID RETURNED BY MCSOPER    X\n               OPERPARM=WAOPPARM,    MAKE ME THE GURU-USER             X\n               TERMNAME=MCTERM,      USE USERID FOR TERMNAME AUDIT     X\n               MCSCSA=MCCSA,         RETURNED CONS. STATUS AREA ADDR.  X\n               MCSCSAA=MCCSAA,       RETURNED CONS. STATUS AREA ALET   X\n               MSGDLVRY=FIFO,        MSGS RETAINED BY FIFO             X\n               MSGECB=MCMSGECB,      ECB TO POST  WHEN MSG IS QUEUED   X\n               ALERTECB=0,           ECB TO POST WHEN ALERT OCCURS     X\n               RTNCODE=MCRC,         RETURN CODE FROM MCSOPER (R15)    X\n               RSNCODE=MCRCC,        REASON CODE FROM MCSOPER (R0)     X\n               MF=(E,@MLWAREA)\n         MODESET MF=(E,PROBMOD)      RETURN INTO PROBLEM MODE\n         ICM   R15,15,MCRC           WAS THE ACTIVATE SUCCESSFUL ?\n         LTR   R15,R15\n         BZ    MCSOP080              YES, GO AND EXECUTE THE CMD\n         CH    R15,=H'4'             IS THE CONSOLE ALREADY ACTIVE?\n         BE    MCSOP020              YES, TRY TO ASSIGN A FREE NUMBER\n         LA    R15,8                 IND. RETURN-CODE\n         LA    R8,ERR0040            NO, BAD ERROR, ISSUE MESSAGE AND\n         B     MCSOP090              TERMINATE THE PROGRAM\nMCSOP020 DS    0H                    QCMDXX IN USE, GET NEXT FREE #.\n         XR    R3,R3                 CLEAR WORKREG.\n         CLI   MCNAME+5,C'9'         IS 2ND DIGIT 9 ?\n         BNE   MCSOP030              NO, IT'S EASY, JUST INC. BY 1\n         CLI   MCNAME+4,C'9'         IS 1ST DIGIT ALSO = 9 ?\n         BNE   MCSOP025              NO, WE STILL HAVE FREE CONSOLES\n         LA    R15,8                 ALL 99 CONSOLES USED, INDICATE\n         LA    R8,ERR0050            ERROR-MSG + LEAVE\n         B     MCSOP090\nMCSOP025 IC    R3,MCNAME+4           INCREASE 1ST DIGIT BY 1\n         LA    R3,1(,R3)             AND SET 2ND TO 0 (EG: 29+1=30)\n         STC   R3,MCNAME+4           STORE 1ST DIGIT.\n         MVI   MCNAME+5,C'0'         SET 2ND TO 0 + STORE IT, TOO\n         B     MCSOP010              RETRY TO GET A CONSOLE\nMCSOP030 IC    R3,MCNAME+5           2ND DIGIT <9, SO JUST ...\n         LA    R3,1(,R3)             ... INCREASE IT BY 1 AND ...\n         STC   R3,MCNAME+5           STORE IT.\n         B     MCSOP010              RETRY TO GET A CONSOLE\nMCSOP080 XR    R15,R15\nMCSOP090 DS    0H\n         L     R10,SAVE10\n         BR    R10\n         LTORG\n**********************************************************************\n* EXECCMD: EXECUTE THE COMMAND\n**********************************************************************\nEXECCMD  ST    R10,SAVE10            PREPARE COMMAND-EXECUTION.\n         CLI   REPLYFLG,C'Y'         DO WE JUST WANNA REPLIES ?\n         BE    CMD0020               (BE=YES, NO COMMAND NECESSARY)\n         MVC   @MLWAREA(L@MGCRE),@MGCRE     MOVE MF=L INTO DSECT\n         STCK  MGCART                SET A DUMMY-CART\n         LH    R3,MGCMDL             LOAD LENGTH OF THE COMMAND AND ..\n         LA    R3,MGCMDL             POINT THERE ...\n         MODESET MF=(E,SUPRMOD)      GET INTO SUPERVISOR STATE\n         MGCRE TEXT=(R3),            COMMAND BUFFER                    X\n               CONSID=MCCONS,        CONSOLE-ID RETURNED BY MCSOPER    X\n               CART=MGCART,          COMMAND AND RESPONSE TOKEN        X\n               MF=(E,@MLWAREA)\n         MODESET MF=(E,PROBMOD)      RETURN INTO PROBLEM MODE\nCMD0020  XR    R15,R15\n         L     R10,SAVE10\n         BR    R10\n         LTORG\n*********************************************************************\n* WAITMSG: WAIT FOR THE MESSAGE\n***********************************************************************\nWAITMSG  ST    R10,SAVE10            WAIT FOR THE MESSAGE WE SHOULD GET\nDOWAIT   STIMER WAIT,BINTVL=TIINTVL  GO INTO A WAIT.\n         XR    R15,R15\n         L     R10,SAVE10\n         BR    R10\n         LTORG\n**********************************************************************\n* GET THE MESSAGE\n**********************************************************************\nGETMSG   ST    R10,SAVE10            NOW, START THE MSG-BUSINESS.\n         LA    R6,ALLMSGS            -> TO TOP OF MSG-TABLE\nGETM0000 DS    0H\n         XC    MCMSGECB,MCMSGECB     CLEAR THE MSG-ARRIVED ECB.\n         MVC   @MLWAREA(L@OPMSG),@OPMSG   MOVE MF=L INTO DSECT-AREA\n         MODESET MF=(E,SUPRMOD)      GET INTO SUPERVISOR STATE\n         SAC   512                   SWITCH TO AR MODE\n         SYSSTATE ASCENV=AR          TELL MACROS THAT AR MODE IS ACTIVE\n         MCSOPMSG REQUEST=GETMSG,    RETRIEVE A MESSAGE                X\n               CONSID=MCCONS,        CONSOLE-ID RETURNED BY MCSOPER    X\n               RTNCODE=MCRC,         RETURN CODE FROM MCSOPMSG (R15)   X\n               RSNCODE=MCRCC,        REASON CODE FROM MCSOPMSG (R0)    X\n               MF=(E,@MLWAREA)\n         LAE   R3,0(0,R1)            SAVE A(MDB)\n         SAC   0                     SWITCH TO PRIMARY MODE\n         SYSSTATE ASCENV=P           TELL MACROS PRIM MODE IS ACTIVE\n         MODESET MF=(E,PROBMOD)      RETURN INTO PROBLEM MODE\n         ICM   R15,15,MCRC\n         LTR   R15,R15               STORE THE RC OF GETMSG.\n         BNZ   MDB9990               NOT ZERO, NO MORE MSGS.\n         MODESET MF=(E,SUPRMOD)      GET INTO SUPERVISOR STATE\n         SAC   512                   SWITCH TO AR MODE\n         SYSSTATE ASCENV=AR          TELL MACROS THAT AR MODE IS ACTIVE\nMDBSTUFF DS    0H\n         USING MDB,R3                MDB IS POINTED TO BY GPR3\n         CLC   MDBMID,=CL4'MDB '     IS IT REALLY A MDB ?\n         BNE   ENDMDB                NO, GET OUT OF HERE\n         LAE   R7,0(0,R3)            COPY GPR3 INTO AR7  --> A(MDB)\n         SH    R7,=AL2(MDBPLNNO)     SUBTRACT LENGTH OF MDB-PREFIX\n         LR    R4,R3                 POINT TO START OF MDB\n         AH    R4,MDBLEN             ADD LENGTH OF MDB\n         LA    R3,MDBHLEN(,R3)       ADD L'HEADER, POINT TO 1ST MDB OBJ\nMDB0000  DS    0H\n         CLC   MDBTYPE,=AL2(MDBGOBJ)   IS IT A GENERAL OBJECT ?\n         BNE   MDB0010               NO, TRY FURTHER\n         USING MDBG,R3               TELL ASSEMBLER\n         B     MDB0030               NO FURTHER CHECKING, GET NEXT\nMDB0010  DS    0H\n         USING MDB,R3                TELL ASSEMBLER\n         CLC   MDBTYPE,=AL2(MDBTOBJ) IS IT A TEXT-OBJECT ?\n         BNE   MDB0020               NO, TRY FURTHER\n*                                    PROCESS TEXT-OBJECT\n         USING MDBT,R3               TELL ASSEMBLER\n         LH    R5,MDBTLEN            LOAD MDBT-LENGTH\n         SH    R5,=AL2(MDBTMBOB)     SUBTRACT NON-MSGTEXT PORTION\n         CLI   MSGDFLAG,MSGDPUTL     JUST PUTLINE REQUIRED ?\n         BE    MDB0012               (BE=YES, NO COLOR+HLITE REQUIRED)\n         LR    R1,R5                 SAVE R5 IN R1\n         AH    R1,=H'02'             ADD LENGTH OF COLOR + HILITE\n         STH   R1,0(R6)              STORE THE LENGTH\n         LA    R6,2(,R6)             BUMP BEHIND LENGTH-VALUE\n         MVC   0(1,R6),MDBTPCOL      MOVE THE CURRENT COLOR THERE\n         MVC   1(1,R6),MDBTPHIL      MOVE THE HIGHLIGHTING THERE\n         LA    R6,2(,R6)             BUMP BEHIND ATTRIBUTE-PREFIX\n         B     MDB0013\nMDB0012  STH   R5,0(R6)              STORE LENGTH OG TEXT-PORTION IN\n         LA    R6,2(,R6)             BUMP BEHIND LENGTH-VALUE\nMDB0013  BCTR  R5,0                  MSG-AREA. THEN SUBTR. 1 F. EXECUTE\n         EX    R5,MOVEMSG1           DO THE EXECUTE\n         AR    R6,R5                 ADD THE LENGTH OF MSG  ....\n         LA    R6,1(,R6)             ... + 1.\n         B     MDB0030               GO FOR NETX MESSAGE\nMDB0020  DS    0H\n         USING MDB,R3\n         CLC   MDBTYPE,=AL2(MDBCOBJ)  IS IT A CONTROL-PROGRAM OBJECT ?\n         BNE   MDB0030               (BNE = NO, PROCEED)\n         USING MDBSCP,R3             TELL ASSEMBLER\n         B     MDB0030               NO FURTHER CHECKING PROCEED\nMDB0030  DS    0H\n         USING MDB,R3\n         AH    R3,MDBLEN             ADD LENGTH OF MESSAGE\n         CR    R3,R4                 COMPARE WITH TOTAL LENGTH\n         BL    MDB0000               (BL = STILL SOME WORK, RE-DO)\n         ICM   R7,B'1111',MDBPNEXT-MDBPRFX(R7)   NO, POINT TO NEXT MDB\n         BZ    ENDMDB                (BZ = NO MOR MESSAGES)\n         LR    R3,R7                 LOAD POINTER OF NEXT MDB\n         B     MDBSTUFF              REDO MESSAGE-BUSINESS\nENDMDB   DS    0H\n         SAC   0                   SWITCH TO PRIMARY MODE\n         SYSSTATE ASCENV=P         TELL MACROS THAT PRIM MODE IS ACTIVE\n         MODESET MF=(E,PROBMOD)      RETURN INTO PROBLEM MODE\n******************************************************************\n* PROBLEM: IF A COMMAND RETURNS SEVERAL MESSAGES WITH A SEPARATE\n*          MDB EACH (E.G $DI RETURNS 1 COMPLETE MDB PER INITIATOR)\n*          THERE MUST BE RE-CALLED THE COMPLETE MDB-BUSINESS.\n*          THIS IS DONE IN BRANCHING BACK TO LABEL GETM0000.\n*          IF THERE IS NOW ISSUED ANOTHER COMMAND WHILE QCMD IS\n*          WAITING FOR AN ANSWER, THE REPLY OF THE OTHER COMMAND IS\n*          TRAPPED TOO, UNFORTUNATELY.\n******************************************************************\n         B     GETM0000              RECALL MDB-BUSINESS\nMDB9990  LA    R1,ALLMSGS            POINT AT TOP OF MESSAGEBUFFER\n         CR    R6,R1                 WERE THERE MESSAGES WRITTEN ?\n         BH    MDB9998               (BH = YES, NO ERRORMSG)\n         LA    R15,8                 LOAD RC=8\n         LA    R8,ERR0110            POINT AT ERROR-MESSAGE\n         B     MDB9999               RETURN\nMDB9998  XR    R15,R15               GOT MESSAGES, CLEAR RC\nMDB9999  DS    0H                    BRANCH BACK\n         L     R10,SAVE10\n         BR    R10\n         LTORG\n**********************************************************************\n* CHKRPLYS: CHECK FOR OUTSTANDING REPLIES\n**********************************************************************\nCHKRPLYS ST    R10,SAVE10\n         L     R2,CVTPTR             CVT-POINTER INTO R2\n         L     R2,CVTCUCB-CVT(,R2)   UCM-POINTER INTO R2\n         LH    R3,UCMRQNR-UCM(,R2)\n         L     R2,UCMRPYQ-UCM(,R2)   REPLY-QUEUE POINTER INTO R2\n         LTR   R2,R2                 IS IT ZERO ?\n         BNZ   RPL00010              (BNZ= NO, REPLIES ARE OUTSTANDING)\n         LA    R15,8\n         LA    R8,ERR0060\n         B     RPL00090\nRPL00010 DS    0H\n         ST    R2,OREFADDR           STORE ADDRESS OF 1ST OREF\n         STH   R3,REPLYNUM           STORE THE NUMBER OF REPLIES\n         XR    R15,R15\nRPL00090 L     R10,SAVE10\n         BR    R10\n         LTORG\n**********************************************************************\n* CONSREM: REMOVE MVS-OPERCONSOLE\n**********************************************************************\nCLEANUP  ST    R10,SAVE10\n         ST    R15,FUNCRC\n         MVC   @MLWAREA(L@MCSOP),@MCSOP\n         MODESET MF=(E,SUPRMOD)      GET INTO SUPERVISOR STATE\n         MCSOPER REQUEST=DEACTIVATE, DEACTIVATE MCS-CONSOLE            X\n               CONSID=MCCONS,      CONSOLE-ID RETURNED BY MCSOPER      X\n               RTNCODE=MCRC,       RETURN CODE FROM MCSOPER (R15)      X\n               RSNCODE=MCRCC,      REASON CODE FROM MCSOPER (R0)       X\n               MF=(E,@MLWAREA)\nCLEAN010 DS    0H\n         STAX  DEFER=NO              READY FOR INTERRUPTS AGAIN\n         MODESET MF=(E,PROBMOD)      RETURN TO PROBLEM MODE\n         L     R15,FUNCRC\n         L     R10,SAVE10\n         BR    R10\n         LTORG\n**********************************************************************\n* XMEMINIT: INITIALIZE CROSS-MEMORY ENVIRONMENT\n**********************************************************************\nXMEMINIT ST    R10,SAVE10\n         L     R3,CVTPTR             LOAD CVT-POINTER INTO R3\n         L     R3,CVTASVT-CVT(,R3)   LOAD ASVT-POINTER\n         L     R3,ASVTMAXU-ASVT(,R3)    ... AND THE MAX-NR. OF ASIDS\n         LA    R4,1                  ASID-NR.\nASLOOP   DS    0H                    ADDRESS-SPACES WALKTHROUGH-TABLE\n*                                    THANKS TO G.SAINT-FLOUR (SHOWMVS)\n         LOCASCB ASID=(R4)           STORES ASIDS ASCB -> INTO R1\n         LTR   R15,R1                VALID ASCB ? - TEST+COPY INTO R15\n         BZ    ASLP0020              NO, NEXT\n         ICM   R1,B'1111',ASCBJBNI-ASCB(R15)    ANY->TO THE JOBNAME?\n         BNZ   ASLP0010              YES, GOTCHA\n         ICM   R1,B'1111',ASCBJBNS-ASCB(R15)  IS IT STC OR TSO?\n         BZ    ASLP0020              NO, TRY THE NEXT ASID\nASLP0010 DS    0H\n         ST    R15,ASCBADDR          STORE THE ASCB-ADDRESS\n         CLC   0(8,R1),=CL8'CONSOLE '   DO WE HAVE A MATCH?\n         BE    ALES0010              YES, GO AHEAD\nASLP0020 DS    0H                    NO HIT, TRY NEXT\n         LA    R4,1(,R4)             INCR. ASID-VALUE\n         BCT   R3,ASLOOP             STILL SOME WORK ?\n         LA    R15,8                 CONSOLE-ASID NOT FOUND, SET\n         LA    R8,ERR0070            ERRORMSG + LEAVE\n         B     XMEM0090              NO, GO OUT\n*\nALES0010 DS    0H\n         L     R2,ASCBADDR           LOAD CONSOLES ASCB-ADDRESS INTO R2\n         L     R2,ASCBASSB-ASCB(,R2) POINT TO ASSB\n         MVC   CONSTOKN,ASSBSTKN-ASSB(R2)     MOVE THE AS-TOKEN\nALES0015 DS    0H                    (--> SYSTEM SERVICES COURSE)\n         MODESET MF=(E,SUPRMOD)      GET INTO SUPERVISOR STATE\n         ALESERV ADD,                ADD SP-TOKEN TO ACCESSLIST        X\n               AL=WORKUNIT,          USE THE DU-AL (TCB-ACCESS LIST)   X\n               STOKEN=CONSTOKN,      CONSOLE  SPACETOKEN               X\n               ALET=CONSALET,        ALESERV RETURNS ALET THERE        X\n               CHKEAX=NO             DON'T CHECK AUTHORISATION INDEX\n         ST    R15,WORKRC            SAVE RETURN-CODE\n         MODESET MF=(E,PROBMOD)      RETURN TO PROBLEM MODE\n         L     R15,WORKRC\n         LTR   R15,R15               WORKED ?\n         BZ    ALES0020              (BZ=YES, GO AHEAD)\n         LA    R15,8                 CONSOLE-ASID NOT FOUND, SET\n         LA    R8,ERR0080            ERRORMSG + LEAVE\n         B     XMEM0090\nALES0020 DS    0H                    ALES0020: GET REPLY-TEXT\n         LA    R6,ALLMSGS            POINT TO START OF MSG-BUFFER\n         STORAGE OBTAIN,LENGTH=HUNPAGES,LOC=ANY,BNDRY=PAGE,ADDR=(R7)\n         ST    R7,VARTAB\n         CLI   MSGDFLAG,MSGDPUTL     PUTLINE-DELIVERY REQUESTED ?\n         BE    ALES0022              (BE=YES, BUMP OVER REXX-STUFF)\n* REXX-VARAIBLE BUILDING PROCESS\n* BUILD THE COUNTER (.0-ELEMENT OF EACH SUB-ARRAY)\n         XR    R5,R5                 CLEAR OUT R5\n         ST    R5,NROFMSGS           STORE THE NUMBER OF MSGS\n         LA    R1,VAR0001            LOAD POINTER TO VAR-STEM INTO R1\n         ST    R1,STEMPARM           STORE ADDRESS INTO PARMFIELD\n         LA    R1,LVAR0001           LOAD LENGTH OF VARIABLE-STEM\n         ST    R1,STEMPARM+4         STORE INTO PARMFIELD+4\n         LH    R1,REPLYNUM           STORE THE NUMBER OF REPLIES\n         ST    R1,STEMPARM+8         INTO PARMFIELD+8\n         BAL   R5,MAKESTEM           MAKE THE .0 VARIABLE\n         LA    R1,VAR0002            LOAD POINTER TO VAR-STEM INTO R1\n         ST    R1,STEMPARM           STORE ADDRESS INTO PARMFIELD\n         LA    R1,LVAR0002           LOAD LENGTH OF VARIABLE-STEM\n         ST    R1,STEMPARM+4         STORE INTO PARMFIELD+4\n         BAL   R5,MAKESTEM           MAKE THE .0 VARIABLE\n         LA    R1,VAR0003            LOAD POINTER TO VAR-STEM INTO R1\n         ST    R1,STEMPARM           STORE ADDRESS INTO PARMFIELD\n         LA    R1,LVAR0003           LOAD LENGTH OF VARIABLE-STEM\n         ST    R1,STEMPARM+4         STORE INTO PARMFIELD+4\n         BAL   R5,MAKESTEM           MAKE THE .0 VARIABLE\n         LA    R1,VAR0004            LOAD POINTER TO VAR-STEM INTO R1\n         ST    R1,STEMPARM           STORE ADDRESS INTO PARMFIELD\n         LA    R1,LVAR0004           LOAD LENGTH OF VARIABLE-STEM\n         ST    R1,STEMPARM+4         STORE INTO PARMFIELD+4\n         BAL   R5,MAKESTEM           MAKE THE .0 VARIABLE\n         LA    R1,VAR0005            LOAD POINTER TO VAR-STEM INTO R1\n         ST    R1,STEMPARM           STORE ADDRESS INTO PARMFIELD\n         LA    R1,LVAR0005           LOAD LENGTH OF VARIABLE-STEM\n         ST    R1,STEMPARM+4         STORE INTO PARMFIELD+4\n         BAL   R5,MAKESTEM           MAKE THE .0 VARIABLE\n* END OF REXX-VARAIBLE BUILDING PROCESS\nALES0022 DS    0H\n         MODESET MF=(E,SUPRMOD)      GET INTO SUPERVISOR STATE\n         SAC   512                   SWITCH INTO ....\n         SYSSTATE ASCENV=AR          ... AR-MODE\n         L     R2,OREFADDR           SYNCRONIZE THE TWO BASES: GPR\n         LAM   R2,R2,CONSALET        .... AND AR\n         XR    R4,R4                 CLEAR OUT WORKREG\nALES0025 DS    0H                    END OF REXX-VARIABLES\n         L     R3,OREFADDR           POINT AT TOP OF OREF\n* REXX-VARAIBLE BUILDING PROCESS\n         CLI   MSGDFLAG,MSGDPUTL     PUTLINE-DELIVERY REQUESTED ?\n         BE    ALES0030              (BE=YES, BUMP OVER REXX-STUFF)\n         LA    R4,1(,R4)             R4=CURRENT ARRAY-ELEMENT-NUMBER\n         ST    R4,ELEMPARM           STORE IT IN PARMLIST\n         LA    R1,LVAR0001           LENGTH OF VARIABLE-STEM\n         ST    R1,ELEMPARM+4         STORE IN PARMLIST+4\n         LA    R1,VAR0001            VARIABLE STEM-NAME\n         ST    R1,ELEMPARM+8         STORE IN PARMLIST+8\n         BAL   R5,MAKEELEM           BUILD THE NEW ARRAY-ELEMENT\n         LA    R1,2                  LOAD LENGTH OF VALUE\n         ST    R1,VALPARM            STORE IT INTO PARMLIST\n         LA    R1,OREID-OREF(,R3)    POINT TO START OF REPLY-ID\n         ST    R1,VALPARM+4          STORE IT INTO PARMLIST\n         BAL   R5,ADDVALUE           ASSIGN THE VALUE TO THE VARIABLE\n         LA    R1,LVAR0002           LENGTH OF VARIABLE-STEM\n         ST    R1,ELEMPARM+4         STORE IN PARMLIST+4\n         LA    R1,VAR0002            VARIABLE STEM-NAME\n         ST    R1,ELEMPARM+8         STORE IN PARMLIST+8\n         BAL   R5,MAKEELEM           BUILD THE NEW ARRAY-ELEMENT\n         LA    R1,8                  LOAD LENGTH OF ISSUER\n         ST    R1,VALPARM            STORE IT INTO PARMLIST\n         LA    R1,OREWTORU-OREF(,R3)    POINT TO START OF ISSUER-ID\n         ST    R1,VALPARM+4          STORE IT INTO PARMLIST\n         BAL   R5,ADDVALUE           ASSIGN THE VALUE TO THE VARIABLE\n* END OF REXX-VARAIBLE BUILDING PROCESS\nALES0030 DS    0H\n*  PUTLINE-BUSINESS\n         CLI   MSGDFLAG,MSGDVREX     REXX-VAR-DELIVERY REQUESTED ?\n         BE    ALES0035              (BE=YES, BUMP OVER PUTLINE   )\n         LA    R1,2                  LOAD LENGTH OF ISSUER\n         STH   R1,0(R6)              STORE IT FOR PUTLINE\n         MVC   2(2,R6),OREID-OREF(R3) MOVE THE REPLY-ID THERE\n         LA    R6,4(,R6)             BUMP BEHIND REPLY + LENGTH\n         LA    R1,8                  LOAD LENGTH OF ISSUER\n         STH   R1,0(R6)              STORE IT FOR PUTLINE\n         MVC   2(8,R6),OREWTORU-OREF(R3) MOVE THE ISSUERS USERID\n         LA    R6,10(,R6)            BUMP BEHIND REPLY + LENGTH\n*  END OF PUTLINE-BUSINESS\nALES0035 DS    0H                    START WQE-BUSINESS HERE\n         L     R2,ORERWQE-OREF(0,R2) POINT TO WQE-ELEMENT\n         USING WQE,R2                TELL ASSEMBLER\n         CLI   MSGDFLAG,MSGDPUTL     PUTLINE-DELIVERY REQUESTED ?\n         BE    ALES0040              (BE=YES, BUMP OVER REXX-STUFF)\n*  REXX-VARAIBLE BUILDING BUSINESS\n         LA    R5,LVAR0003           LENGTH OF VARIABLE-STEM\n         ST    R5,ELEMPARM+4         STORE IN PARMLIST+4\n         LA    R5,VAR0003            VARIABLE STEM-NAME\n         ST    R5,ELEMPARM+8         STORE IN PARMLIST+8\n         BAL   R5,MAKEELEM           BUILD THE NEW ARRAY-ELEMENT\n         LA    R5,8                  LOAD LENGTH OF ISSUER\n         ST    R5,VALPARM            STORE IT INTO PARMLIST\n         LAE   R5,WQEOJBID-WQE(0,R2) POINT TO START OF JOBID (AR-MODE)\n         ST    R5,VALPARM+4          STORE IT INTO PARMLIST\n         BAL   R5,ADDVALUE           ASSIGN THE VALUE TO THE VARIABLE\n         LA    R5,LVAR0004           LENGTH OF VARIABLE-STEM\n         ST    R5,ELEMPARM+4         STORE IN PARMLIST+4\n         LA    R5,VAR0004            VARIABLE STEM-NAME\n         ST    R5,ELEMPARM+8         STORE IN PARMLIST+8\n         BAL   R5,MAKEELEM           BUILD THE NEW ARRAY-ELEMENT\n         LA    R5,8                  LOAD LENGTH OF ISSUER\n         ST    R5,VALPARM            STORE IT INTO PARMLIST\n         LAE   R5,WQEOJBNM-WQE(0,R2) POINT TO START OF JOBNAME(AR-MODE)\n         ST    R5,VALPARM+4          STORE IT INTO PARMLIST\n         BAL   R5,ADDVALUE           ASSIGN THE VALUE TO THE VARIABLE\n         LA    R5,LVAR0005           LENGTH OF VARIABLE-STEM\n         ST    R5,ELEMPARM+4         STORE IN PARMLIST+4\n         LA    R5,VAR0005            VARIABLE STEM-NAME\n         ST    R5,ELEMPARM+8         STORE IN PARMLIST+8\n         BAL   R5,MAKEELEM           BUILD THE NEW ARRAY-ELEMENT\n         LH    R5,WQETXTLN           LOAD LENGTH OF TEXT\n         ST    R5,VALPARM            STORE IT INTO PARMLIST\n         LAE   R5,WQETXT-WQE(0,R2)   POINT TO START OF JOBNAME(AR-MODE)\n         ST    R5,VALPARM+4          STORE IT INTO PARMLIST\n         BAL   R5,ADDVALUE           ASSIGN THE VALUE TO THE VARIABLE\n* END OF REXX-VARAIBLE BUILDING PROCESS\nALES0040 DS    0H\n         CLI   MSGDFLAG,MSGDVREX     REXX-VAR-DELIVERY REQUESTED ?\n         BE    ALES0045              (BE=YES, BUMP OVER PUTLINE   )\n*  PUTLINE-BUSINESS\n         LA    R5,8                  LOAD LENGTH OF ORIGINATING JOBID\n         STH   R5,0(R6)              STORE IT\n         MVC   2(8,R6),WQEOJBID      MOVE JOBNAME THERE\n         LA    R6,10(,R6)            BUMP BEHIND JOBNAME + LENGTH\n         LA    R5,8                  LOAD LENGTH OF ORIGINATING JOBNAME\n         STH   R5,0(R6)              STORE IT\n         MVC   2(8,R6),WQEOJBNM      MOVE JOBNAME THERE\n         LA    R6,10(,R6)            BUMP BEHIND JOBNAME + LENGTH\n         LH    R5,WQETXTLN           LOAD LENGTH OF MESSAGE-TEXT\n         STH   R5,0(R6)              STORE IT\n         LA    R6,2(,R6)             BUMP BEHIND\n         BCTR  R5,0                  SUBTRACT 1 FOR EXECUTE\n         EX    R5,MOVEALE1           WRITE INTO WORKAREA\n         AH    R6,WQETXTLN           BUMP BEHIND\n*  END OF PUTLINE-BUSINESS\nALES0045 DS    0H\n         L     R3,ORELKP-OREF(0,R3)  LOAD ADDRESS OF NEXT OREF\n         LTR   R3,R3                 IS IT ZERO (LAST OREF ?)\n         BZ    ALES0050              (BZ=YES, PROCEED)\n         ST    R3,OREFADDR           STORE NEW OREF-ADDR\n         LR    R2,R3                 LOAD R2\n         B     ALES0025              RE-WORK\nALES0050 DS    0H\n         SAC   0\n         SYSSTATE ASCENV=P\n         ALESERV DELETE,             REMOVE THE ALET-ENVIRONMENT       X\n               ALET=CONSALET,        CONSOLES ALET                     X\n               CHKEAX=NO             DON'T CHECK AUTHORISATION INDEX\n         ST    R15,WORKRC            STORE RETURNCODE\n         MODESET MF=(E,PROBMOD)      RETURN TO PROBLEM MODE\n         L     R15,WORKRC            RELOAD RETURNCODE\n         LTR   R15,R15               WORKED ?\n         BZ    ALES0080              (BZ=YES, GO AHEAD)\n         LA    R15,8                 CONSOLE-ASID NOT FOUND, SET\n         LA    R8,ERR0080            ERRORMSG + LEAVE\n         B     XMEM0090\nALES0080 DS    0H\n         XR    R15,R15\nXMEM0090 DS    0H\n         L     R10,SAVE10\n         BR    R10\n         LTORG\n***********************************************************************\n*     MAKEELEM: RETURN THE DATA-PORTION OF ARRAY-COUNT                *\n***********************************************************************\nMAKEELEM STM   R4,R6,SAVE4TO6        MAKE A NEW ELEMENT OF AN ARRAY\n         LM    R4,R6,ELEMPARM        LOAD PASSED PARAMETERS: R4=EL-NR.\n         CVD   R4,ARRAYCNT           R5=VAR-LENGTH, R6=VARNAME-ADDR\n         MVC   WORKMASK(LARRAYEM),ARRAYEM  MOVE EDIT-TABLE INTO WA\n         ED    WORKMASK,ARRAYCNT+4   EDIT THE ARRAY-COUNTER\n         LA    R6,WORKMASK           POINT TO START OF WORKFIELD\n         LA    R5,LARRAYEM           LENGTH OF WORKFIELD\nSTRIP010 CLI   0(R6),C' '            IS THERE A BLANK ?\n         BNE   STRIP020              (BNE=NO, DATA FROM HEREON)\n         LA    R6,1(,R6)             POINT TO NEXT POSITION\n         BCT   R5,STRIP010           RETRY\nSTRIP020 DS    0H\n         ST    R5,ELLENGTH           STORE LENGTH OF DATAPORTION\n         ST    R6,ELSTART            STORE STARTPOSITION OF DATA\n         L     R4,ELEMPARM+4         LOAD LENGTH OF VARNAME\n         AR    R4,R5                 ADD LENGTH OF ELEMENT-VALUE\n         STH   R4,0(R7)              STORE TOTAL VARIABLE LENGTH\n         LA    R7,2(,R7)             BUMP BEHIND IT\n         L     R4,ELEMPARM+4         LOAD LENGTH OF VARIABLE-NAME\n         BCTR  R4,0                  SUBTRACT 1 FOR EXECUTE\n         L     R6,ELEMPARM+8         LOAD VARNAME-ADDRESS\n         EX    R4,MOVEELM1           MOVE VARNAME-ADDRESS INTO STOR.\n         A     R7,ELEMPARM+4         BUMP BEHIND VARNAME-STEM\n         L     R6,ELSTART            LOAD STARTADDR OF ELEMENT-NR.\n         L     R5,ELLENGTH           LOAD LENGTH OF ELEMENT-NR.\n         BCTR  R5,0                  SUBTRACT 1 FOR EXECUTE\n         EX    R5,MOVEELM1           MOVE ELEMENT-NR. BEHIND VARNAME\n         A     R7,ELLENGTH           BUMP OVER IT\n         L     R5,NROFMSGS           LOAD THE CURRENT NR. OF MSGS\n         LA    R5,1(,R5)             ADD 1 FOR IKJCT441-LOOP\n         ST    R5,NROFMSGS           STORE THE NUMBER OF MSGS\n         LM    R4,R6,SAVE4TO6        RELOAD CLOBBERED REGISTERS\n         BR    R5                    BRANCH BACK TO MOM\n         LTORG\nMOVEELM1 MVC   0(0,R7),0(R6)         MOVE THE DATA-PORTION THERE\n***********************************************************************\n*     BUILDVAR: BUILD A REXX-VARIABLE                                 *\n***********************************************************************\nBUILDVAR ST    R10,SAVE10            STORE SUBROUTINES 'BASE'\n         CLI   MSGDFLAG,MSGDPUTL     IS JUST PUTLINE REQUIRED ?\n         BE    BLD0090               (BE = YES, RETURN)\n         STM   R2,R3,SAVE2TO3        STORE CLUBBERED  REGISTERS\n         XR    R2,R2\n         CLI   MSGDFLAG,MSGDPUTL     JUST PUTLINE NEEDED ?\n         BE    BLD0080               (BE = YES, BRANCH BACK TO MOM)\n         L     R2,CVTPTR             CVTPOINTER INTO R2 ...\n         L     R2,CVTTVT-CVT(,R2)    .... TSVT INTO R2 ...\n         USING TSVT,R2               TELL ASSEMBLER\n         L     R3,TSVTVACC           VARIABLE-ACCESS ROUTINE INTO R3\n         ST    R3,VACADDR            SAVE ENTRY-ADDRESS FOR CALL\n         LA    R3,TSVEUPDT           FUNCTION-CODE (SEE SYS1.MACLIB)\n         ST    R3,IKJECODE           STORE FOR CALL\n         DROP  R2                    DROP TSVT-BASE\n         MVC   @MLWAREA(L@CALL),@CALL   CALL-LISTAREA INTO WORKAREA\n         L     R7,VARTAB             POINT TO TOP OF VARIABLE-TABLE\n         L     R4,NROFMSGS           LOAD THE # OF WALKTHROUGHS\nBLD0010  DS    0H                    LOOP-BASE\n         XR    R3,R3                 CLEAR OUT ....\n         ST    R3,IKJTOKEN           .... TOKEN-WORKAREA\n         LH    R2,0(R7)              LOAD LENGTH OF ARRAY-ELEMENTNAME\n         ST    R2,LRXVNAME           STORE INTO CALL-PARMLIST\n         LA    R7,2(,R7)             BUMP BEHIND\n         BCTR  R2,0                  SUBTRACT ONE FOR EXECUTE\n         EX    R2,MVCBLD1            WRITE THE ELEMENTNAME INTO WAREA\n         A     R7,LRXVNAME           BUMP BEHIND ELEMENT-NAME\n         LH    R2,0(R7)              LOAD LENGTH OF ELEMENT-VALUE\n         ST    R2,LRXVVAL            STORE INTO CALL-PARMLIST\n         LA    R7,2(,R7)             BUMP BEHIND\n         BCTR  R2,0                  SUBTRACT 1 FOR EXECUTE ..\n         EX    R2,MVCBLD2            WRITE VALUE INTO CALL-PARMLIST\n         A     R7,LRXVVAL            BUMP BEHIND\n         LA    R2,RXVNAME            POINT TO VARIABLENAME-STARTADDR\n         ST    R2,@RXVNAME           STORE INTO CALL-PARMLIST\n         LA    R2,RXVVAL             POINT TO VARIABLEVALUE-STARTADDR\n         ST    R2,@RXVVAL            STORE INTO CALL-PARMLIST\n         L     R15,VACADDR           LOAD IKJCT441-ADDRESS\n         CALL  (15),                 CALL IKJCT441                     X\n               (IKJECODE,            FUNCTIONCODE (CREATE OR UPDATE)   X\n               @RXVNAME,             VARIABLENAME STARTADDRESS         X\n               LRXVNAME,             VARIABLENAME LENGTH               X\n               @RXVVAL,              VARIABLEVALUE STARTADDRESS        X\n               LRXVVAL,              VARIABLEVALUE LENGTH              X\n               IKJTOKEN),            ACCESS-ROUTINE TOKEN              X\n               VL,MF=(E,@MLWAREA)    31BIT-MODE, WORKAREAPOINTER\n         LTR   R2,R15                CREATE WENT OK ?\n         BNZ   BLD0070               (BNZ=NO, DON'T PROCEED)\n         BCT   R4,BLD0010            WORKED, TRY NEXT\n         B     BLD0080               ALL DONE, NO ERROR, PROCEED\nBLD0070  LA    R2,40                 LOAD RC X'28'\n         CR    R15,R2                IS THIS THE ONE WE GOT ?\n         BNE   BLD0075               (BNE=NO, OTHER ERROR)\n         LA    R8,ERR0090            YES, NO VALID REXX-ENVIRONMENT.\n         LA    R2,8                  SET ERRORMESSAGE\n         B     BLD0080               RETURN\nBLD0075  DS    0H                    SET GENERAL ERRORMESSAGE\n         LA    R2,8\n         LA    R8,ERR0100\nBLD0080  DS    0H                    CLEANUP REXX-WORKAREA\n         L     R7,VARTAB             POINT TO GETMAINED AREA\n         STORAGE RELEASE,LENGTH=HUNPAGES,ADDR=(7)    FREE IT\n         LR    R15,R2\n         LM    R2,R3,SAVE2TO3        RELOAD CLOBBERED REGISTERS\nBLD0090  L     R10,SAVE10            RELOAD SUBROUTINE BASE\n         BR    R10                   BRANCH BACK TO CALLER\n         LTORG\n***********************************************************************\n*     MAKESTEM                                                        *\n***********************************************************************\nMAKESTEM STM   R3,R5,SAVE3TO5        STORE REGS THAT I USE\n         LM    R3,R5,STEMPARM        LOAD PASSED REGISTERS\n         LA    R4,1(,R4)             LENGTH OF VARNAME+1 (FOR 0-EL)\n         STH   R4,0(R7)              STORE IT IN GETMAINED AREA\n         LA    R7,2(,R7)             BUMP BEHIND IT\n         BCTR  R4,0                  REESTABLISH GENUINE LENGTH\n         BCTR  R4,0                  SUBTRACT 1 FOR EXECUTE\n         EX    R4,STMMOVE1           WRITE VARSTEM INTO G'MNED AREA\n         L     R4,STEMPARM+4         RE-LOAD GENUINE LENGTH\n         AR    R7,R4                 BUMP BEHIND VAR-STEM\n         MVI   0(R7),C'0'            MOVE THERE A '0' (FOR 0-ELEM.)\n         LA    R7,1(,R7)             BUMP BEHIND\n         CVD   R5,ARRAYCNT           CONVERT THE # OF ELEMENTS\n         MVC   WORKMASK(LARRAYEM),ARRAYEM  MOVE EDIT-TABLE INTO WA\n         ED    WORKMASK,ARRAYCNT+4   EDIT THE ARRAY-COUNTER\n         LA    R4,WORKMASK           POINT TO START OF WORKFIELD\n         LA    R3,LARRAYEM           LENGTH OF WORKFIELD\nSTEM0010 CLI   0(R4),C' '            IS THERE A BLANK ?\n         BNE   STEM0020              (BNE=NO, DATA FROM HEREON)\n         LA    R4,1(,R4)             PONT TO NEXT POSITION\n         BCT   R3,STEM0010           RETRY\nSTEM0020 DS    0H\n         STH   R3,0(R7)              STORE LENGTH OF DATAPORTION\n         LA    R7,2(,R7)             BUMP BEHIND IT\n         BCTR  R3,0                  SUBTRACT 1 FOR EXECUTE\n         EX    R3,STMMOVE2           MOVE THE VALUE THERE\n         AR    R7,R3                 BUMP BEHIND IT\n         LA    R7,1(,R7)             BUMP OVER EXECUTE-DECR.\n         L     R5,NROFMSGS           LOAD THE CURRENT NR. OF MSGS\n         LA    R5,1(,R5)             ADD 1 FOR IKJCT441-LOOP\n         ST    R5,NROFMSGS           STORE THE NUMBER OF MSGS\n         LM    R3,R5,SAVE3TO5        RELOAD ORIGINAL CONTENTS\n         BR    R5\n         LTORG\nSTMMOVE1 MVC   0(0,R7),0(R3)\nSTMMOVE2 MVC   0(0,R7),0(R4)\n***********************************************************************\n*     ADDVALUE                                                        *\n***********************************************************************\nADDVALUE STM   R4,R5,SAVE4TO5\n         LM    R4,R5,VALPARM        POINT TO PSEUDO-PARMLIST\n         STH   R4,0(R7)             STORE LENGTH OF VALUE\n         LA    R7,2(,R7)            BUMP BEHIND\n         BCTR  R4,0                 SUBTRACT 1 FOR EXECUTE\n         EX    R4,MOVEADD1          WRITE VALUE INTO GETMAINED AREA\n         A     R7,VALPARM           BUMP BEHIND\n         LM    R4,R5,SAVE4TO5       RELOAD USED REGISTERS\n         BR    R5\n         LTORG\nMOVEADD1 MVC   0(0,R7),0(R5)\n***********************************************************************\n*     RETRESULT                                                       *\n***********************************************************************\nRETRESLT ST    R10,SAVE10\n         CLI   MSGDFLAG,MSGDPUTL     IS JUST PUTLINE REQUIRED ?\n         BE    RESLT040              (BE=YES, GO BACK TO CALLER)\n         STORAGE OBTAIN,LENGTH=HUNPAGES,LOC=ANY,BNDRY=PAGE,ADDR=(R7)\n         ST    R7,VARTAB\n         XR    R4,R4\n         ST    R4,NROFMSGS\n         LA    R6,ALLMSGS\nRESLT010 DS    0H\n         LH    R3,0(R6)\n         LTR   R3,R3\n         BZ    RESLT030\n         LA    R6,2(,R6)\n         LA    R4,1(,R4)             R4=CURRENT ARRAY-ELEMENT-NUMBER\n         ST    R4,ELEMPARM           STORE IT IN PARMLIST\n         LA    R1,LVAR0006           LENGTH OF VARIABLE-STEM\n         ST    R1,ELEMPARM+4         STORE IN PARMLIST+4\n         LA    R1,VAR0006            VARIABLE STEM-NAME\n         ST    R1,ELEMPARM+8         STORE IN PARMLIST+8\n         BAL   R5,MAKEELEM           BUILD THE NEW ARRAY-ELEMENT\n         XR    R2,R2\n         IC    R2,0(R6)\n         SH    R2,=H'240'\n         MH    R2,=H'8'\n         LA    R1,COLORTAB\n         AR    R2,R1\n         LA    R1,8                  LOAD LENGTH OF VALUE\n         STM   R1,R2,VALPARM         STORE IT INTO PARMLIST + POINTER\n         BAL   R5,ADDVALUE           ASSIGN THE VALUE TO THE VARIABLE\n         LA    R1,LVAR0007           LENGTH OF VARIABLE-STEM\n         ST    R1,ELEMPARM+4         STORE IN PARMLIST+4\n         LA    R1,VAR0007            VARIABLE STEM-NAME\n         ST    R1,ELEMPARM+8         STORE IN PARMLIST+8\n         BAL   R5,MAKEELEM           BUILD THE NEW ARRAY-ELEMENT\n         XR    R2,R2\n         CLI   1(R6),X'F0'\n         BNP   RESLT025\n         IC    R2,1(R6)\n         SH    R2,=H'240'\n         MH    R2,=H'8'\nRESLT025 DS    0H\n         LA    R1,HLITETAB\n         AR    R2,R1\n         LA    R1,8                  LOAD LENGTH OF VALUE\n         STM   R1,R2,VALPARM         STORE IT INTO PARMLIST + POINTER\n         BAL   R5,ADDVALUE           ASSIGN THE VALUE TO THE VARIABLE\n*\n         LA    R1,LVAR0008           LENGTH OF VARIABLE-STEM\n         ST    R1,ELEMPARM+4         STORE IN PARMLIST+4\n         LA    R1,VAR0008            VARIABLE STEM-NAME\n         ST    R1,ELEMPARM+8         STORE IN PARMLIST+8\n         BAL   R5,MAKEELEM           BUILD THE NEW ARRAY-ELEMENT\n         LR    R1,R3\n         SH    R1,=H'2'\n         LA    R2,2(,R6)\n         STM   R1,R2,VALPARM         STORE IT INTO PARMLIST + POINTER\n         BAL   R5,ADDVALUE           ASSIGN THE VALUE TO THE VARIABLE\n*\n         AR    R6,R3\n         B     RESLT010\nRESLT030 DS    0H\n         LA    R1,VAR0006            LOAD POINTER TO VAR-STEM INTO R1\n         ST    R1,STEMPARM           STORE ADDRESS INTO PARMFIELD\n         LA    R1,LVAR0006           LOAD LENGTH OF VARIABLE-STEM\n         ST    R1,STEMPARM+4         STORE INTO PARMFIELD+4\n         ST    R4,STEMPARM+8         # OF ELEMENTS INTO PARMFIELD+8\n         BAL   R5,MAKESTEM           MAKE THE .0 VARIABLE\n         LA    R1,VAR0007            LOAD POINTER TO VAR-STEM INTO R1\n         ST    R1,STEMPARM           STORE ADDRESS INTO PARMFIELD\n         LA    R1,LVAR0007           LOAD LENGTH OF VARIABLE-STEM\n         ST    R1,STEMPARM+4         STORE INTO PARMFIELD+4\n         BAL   R5,MAKESTEM           MAKE THE .0 VARIABLE\n         LA    R1,VAR0008            LOAD POINTER TO VAR-STEM INTO R1\n         ST    R1,STEMPARM           STORE ADDRESS INTO PARMFIELD\n         LA    R1,LVAR0008           LOAD LENGTH OF VARIABLE-STEM\n         ST    R1,STEMPARM+4         STORE INTO PARMFIELD+4\n         BAL   R5,MAKESTEM           MAKE THE .0 VARIABLE\nRESLT040 L     R10,SAVE10\n         BR    R10\n         LTORG\n***********************************************************************\n*     RETRESULT                                                       *\n***********************************************************************\nPUTLBSNS ST    R10,SAVE10\n         CLI   MSGDFLAG,MSGDVREX     IS JUST REXX-VARS REQUIRED ?\n         BE    PUTL020               (BE=YES, NO PUTLINE)\n         STFSMODE ON,INITIAL=YES     CLEAR ....\n         STFSMODE OFF                      .... SCREEN\n         LA    R4,IOPLADS            LOAD DYNAMIC IOPL\n         USING IOPL,R4               FILL IT\n         L     R3,CPLUPT             LOAD DYN. USER'S PROFILE TABLE\n         ST    R3,IOPLUPT            STORE IT IN THE IOPL\n         L     R3,CPLECT             LOAD ADDRESS OF DYN. ECT\n         ST    R3,IOPLECT            STORE IT IN THE IOPL\n         LA    R3,ECBADS             LOAD ADDR OF MY ECB TO R3\n         ST    R3,IOPLECB            STORE ADDRESS OF ECBADS IN IOPL\n         MVC   @MLWAREA(L@PUTLIN),@PUTLIN\n         MVC   DTEXTADS(LTEXTADS),TEXTADS   MOVE CONSTANT TO MY AREA\n         LA    R3,ALLMSGS\nPUTL010  DS    0H                    PREPARE FOR THE PUTLINE\n         XC    DTEXTADS(4),DTEXTADS  CLEAR LENGTH-COUNTER\n         XR    R2,R2                 WORKREG IF MSGDBOTH\n         LH    R5,0(R3)              LENGHT OF CURRENT ENTRY INTO R5\n         LTR   R5,R5                 IS IT ZERO ?\n         BZ    PUTL020               (BE = YES, ALL WRITTEN)\n         CLI   REPLYFLG,C'Y'         IS THIS A GET_REPLIES-REQUEST?\n         BE    PUTL015               (BNE=YES, NO ATTRS PASSED)\n         CLI   MSGDFLAG,MSGDBOTH     IS MSGDLVRY=BOTH ?\n         BNE   PUTL015               (BNE=NO, ORDINARY BUSINESS)\n         LA    R2,2                  LOAD LENGHT OF ATTRIBUTE-BYTES\n         SR    R5,R2                 SUBTRACT ATTR-FIELDS LENGTH\nPUTL015  LA    R4,4(,R5)             ADD 4 FOR PUTLINE-HEADER\n         STH   R4,DTEXTADS           STORE INTO WORKAREA\n         BCTR  R5,0                  SUBTRACT 1 FOR EXECUTE\n         AR    R3,R2                 IF ATTR-FIELDS, BUMP OVER THEM\n         EX    R5,PUTLMVC1           DO THE EXECUTE\n         SR    R3,R2                 IF ATTRS, RESTORE ORIG. LENGTH\n         PUTLINE PARM=@MLWAREA,                                        X\n               OUTPUT=(DTEXTADS,TERM,SINGLE,DATA),MF=(E,IOPLADS)\n*                                    DO THE PUTLINE\n         LH    R4,0(R3)              ORIGINAL MSG-LENGTH INTO R4\n         AR    R3,R4                 ADD LENGTH OF MSG-TEXT\n         LA    R3,2(R3)              ADD LENGTH OF MSG-FIELD\n         B     PUTL010               TRY NEXT MESSAGE\nPUTL020  XR    R15,R15\n         L     R10,SAVE10\n         BR    R10\n         LTORG\n***********************************************************************\n*     SETRCODE                                                        *\n***********************************************************************\nSETRCODE ST    R10,SAVE10\n         CLI   MSGDFLAG,MSGDPUTL\n         BE    RCODE020\n         STORAGE OBTAIN,LENGTH=HUNPAGES,LOC=ANY,BNDRY=PAGE,ADDR=(R7)\n         ST    R7,VARTAB\n         LA    R1,1\n         ST    R1,NROFMSGS\n         LA    R1,7\n         STH   R1,0(R7)\n         MVC   2(7,R7),=CL7'QCMD_RC'\n         LA    R1,1\n         STH   R1,9(R7)\n         MVC   11(1,R7),QCMDRC\nRCODE020 L     R10,SAVE10\n         BR    R10\n         LTORG\n***********************************************************************\n*     CONSTANTS                                                       *\n***********************************************************************\nVAR0001  DC    C'QCMD.REPLY_ID.'\nLVAR0001 EQU   *-VAR0001\nVAR0002  DC    C'QCMD.ISSUER.'\nLVAR0002 EQU   *-VAR0002\nVAR0003  DC    C'QCMD.JOB_NUMBER.'\nLVAR0003 EQU   *-VAR0003\nVAR0004  DC    C'QCMD.JOB_ID.'\nLVAR0004 EQU   *-VAR0004\nVAR0005  DC    C'QCMD.REPLY_TEXT.'\nLVAR0005 EQU   *-VAR0005\nVAR0006  DC    C'QCMD.MSG_COLOR.'\nLVAR0006 EQU   *-VAR0006\nVAR0007  DC    C'QCMD.MSG_HILITE.'\nLVAR0007 EQU   *-VAR0007\nVAR0008  DC    C'QCMD.MSG_TEXT.'\nLVAR0008 EQU   *-VAR0008\n*\nCOLORTAB DC    CL8'NEUTRAL'    F0 BLACK ON DISPLAYS, WHITE ON PRINTERS\n         DC    CL8'BLUE   '    F1\n         DC    CL8'RED    '    F2\n         DC    CL8'PINK   '    F3\n         DC    CL8'GREEN  '    F4\n         DC    CL8'TURQ   '    F5\n         DC    CL8'YELLOW '    F6\n         DC    CL8'WHITE  '    F7\n*\nHLITETAB DC    CL8'DEFAULT '\n         DC    CL8'BLINK   '   F1: BLINK\n         DC    CL8'REVERSE '   F2: REVERSE\n         DC    CL8'SPARE#01'\n         DC    CL8'USCORE  '   F4: UNDERSCORE\n*\nHUNPAGES EQU   100*4096\n*\nARRAYEM  DC    X'4020202020202020'\nLARRAYEM EQU   *-ARRAYEM\n*\nTEXTADS  DC    H'132'\n         DC    H'0'\n         DC    CL132' '\nLTEXTADS EQU   *-TEXTADS\n*\nLERRMSGS EQU   79\nERR0010  DC    CL(LERRMSGS)'QCMD0010 NO PARAMETER(S) PASSED. PLEASE ENTX\n               ER A VALID COMMAND AND RETRY.       '\nERR0020  DC    CL(LERRMSGS)'QCMD0020 MISSING RIGHT PARANTHESIS. REENTERX\n                COMMAND WITH BALANCED PARANTHESES. '\nERR0030  DC    CL(LERRMSGS)'QCMD0030 QCMD RUNS IN A TSO-ENVIRONMENT ONLX\n               Y. PROGRAM TERMINATES.              '\nERR0040  DC    CL(LERRMSGS)'QCMD0040 ACTIVATE OF MCS-CONSOLE SESSION FAX\n               ILED. PROGRAM TERMINATES.           '\nERR0050  DC    CL(LERRMSGS)'QCMD0050 NO FREE MCS-CONSOLE ENTRY FOUND. PX\n               LEASE TRY LATER.                    '\nERR0060  DC    CL(LERRMSGS)'NO REPLIES OUTSTANDING. NO REPLY-IDS RETURNX\n               ED                                  '\nERR0070  DC    CL(LERRMSGS)'NO VALID CONSOLE-ADDRESS SPACE LOCATED. PROX\n               GRAM TERMINATES                     '\nERR0080  DC    CL(LERRMSGS)'ALESERV SERVICE FAILED. NO CROSSMEMORY ENVIX\n               RONMENT COULD BE SET UP.            '\nERR0090  DC    CL(LERRMSGS)'NO ACTIVE REXX-ENVIRONMENT FOUND. NO REXX VX\n               RIABLES COULD BE WRITTEN.'\nERR0100  DC    CL(LERRMSGS)'NO REXX-VARIABLES COULD BE WRITTEN. IKJCT44X\n               1 ENDED WITH A RC > 0.              '\nERR0110  DC    CL(LERRMSGS)'NO MESSAGE HAS BEEN RETURNED. COMMAND ISSUEX\n               D BUT RESPONSE COULD NOT BE TRAPPED.'\n*\nBLANK    DC    CL1' '\n*\nALFATAB  DC    256AL1(*-ALFATAB)\n         ORG   ALFATAB+X'81'\n         DC    C'ABCDEFGHI'\n         ORG   ALFATAB+X'91'\n         DC    C'JKLMNOPQR'\n         ORG   ALFATAB+X'A2'\n         DC    C'STUVWXYZ'\n         ORG\n         EJECT\n*\n***********************************************************************\n*     MACRO LIST-FORM                                                 *\n***********************************************************************\n@CALL    CALL  ,(,,,,,,,,,,),MF=L  CALL LIST FORM\nL@CALL   EQU    *-@CALL\n*\n@PUTLIN  PUTLINE MF=L\nL@PUTLIN EQU    *-@PUTLIN\n*\n@EXTR    EXTRACT *,FIELDS=(PSB),MF=L\nL@EXTR   EQU    *-@EXTR\n*\n@MGCRE   MGCRE   MF=L\nL@MGCRE  EQU    *-@MGCRE\n*\n         MCSOPMSG MF=(L,@OPMSG)\nL@OPMSG  EQU    *-@OPMSG\n*\n         MCSOPER MF=(L,@MCSOP)\nL@MCSOP  EQU    *-@MCSOP\n*\nSUPRMOD  MODESET KEY=ZERO,MODE=SUP,MF=L\n*\nPROBMOD  MODESET KEY=NZERO,MF=L\n*\n         EJECT\n*\n***********************************************************************\n*     COPY    SECTION                                                 *\n***********************************************************************\n***********************************************************************\n*     WORKING SECTION                                                 *\n***********************************************************************\n*\nDWORK    DSECT\n@MLWAREA DS    XL256                  MF=L WORKAREA\nWAOPPARM DS    CL(MCSOPLEN)        OPERPARMS AREA\nMCNAME   DS    CL8\nMCTERM   DS    CL8\nMCCONS   DS    F\nMCCSA    DS    A\nMCCSAA   DS    F\nMCMSGECB DS    F\nMCRC     DS    F\nMCRCC    DS    F\n*\nMGCMDL   DS    H                   LENGTH OF COMMAND TEXT\nMGCMD    DS    CL126               COMMAND TEXT\nMGCMDSIZ EQU   *-MGCMDL            SIZE OF CMD LENGTH-FILED+TEXT\nMGCART   DS    D\n*\nASCBADDR DS    F                   CONSOLE-ASID ASCB-ADDR\nCONSTOKN DS    D                   CONSOLE-ASID SPACE-TOKEN\nCONSALET DS    F                   CONSOLE-ASID ACCESSLIST-TOKEN\n*\nREPLYNUM DS    H                   NUMBER OF REPLIES OUTSTANDING\nOREFADDR DS    F                   ADDRESS OF FIRST OREF\nSAVE10   DS    F\nFUNCRC   DS    F\nDWTSO    DS    F\nSTARTCMD DS    F\nTIINTVL  DS    F\nCPLCBUF  DS    F                      CPPL-WORKFIELDS\nCPLUPT   DS    F\nCPLPSCB  DS    F\nCPLECT   DS    F\n*\nVARTAB   DS    F                   START OF GETMAINED AREA\nWORKRC   DS    F\nSTEMPARM DS    3F\nELEMPARM DS    3F\nSAVE3TO5 DS    3F\nSAVE5    DS    F\nSAVE4TO6 DS    3F\nSAVE2TO3 DS    2F\nSAVE4TO5 DS    2F\nVALPARM  DS    2F\nNROFMSGS DS    F                   STORE THE NUMBER OF MSGS\nELLENGTH DS    H                   LENGTH OF ELEMENT-COUNTER\nELSTART  DS    F                   START OF NUMERIC ELEMENT-COUNTER\nARRAYCNT DS    D                   ARRAY-COUNTER\nWORKMASK DS    CL(LARRAYEM)        EDIT-WORKMASK\n*\nRXVNAME  DS    CL32                REXX-VARIABLE NAME\nLRXVNAME DS    F                   REXX-VARIABLE NAME LENGTH\nRXVVAL   DS    CL132               REXX-VARIABLE VALUE\nLRXVVAL  DS    F                   REXX-VARIABLE VALUE LENGTH\n@RXVNAME DS    AL4                 REXX-VARIABLE NAME POINTER\n@RXVVAL  DS    AL4                 REXX-VARIABLE VALUE POINTER\nIKJTOKEN DS    F                   IKJCT441 - TOKEN\nIKJECODE DS    AL4                 ADDRESS OF FUNCTIONCODE-MODULE\nVACADDR  DS    F                   VARIABLE-ACCESS ROUTINE-ADDR\n*\nQCMDRC   DS    CL1                 RETURNCODE FOR REXX-FUNCTION\n*\nREPLYFLG DS    CL1                 INDICATES WHETHER TO TRAP REPLY-IDS\n*\nTIMEFLAG DS    X                   USE TIME FLAG\nTIMEDEF  EQU   X'80'               DEFAULT-TIME SHOULD BE USED\nTIMESET  EQU   X'40'               TIME WAS SET BY A PARM\n*\nMSGDFLAG DS    X                   MESSAGE-DELIVERY INDICATOR\nMSGDBOTH EQU   X'80'               DELIVER BOTH (PUTLINE + REXX-VARS)\nMSGDPUTL EQU   X'40'               DELIVER MESSAGES VIA PUTLINE\nMSGDVREX EQU   X'20'               WRITE MESSAGES INTO REXX-VARS\n*\nCONSFLAG DS    CL1\n*\nTIMEVAL  DS    CL3\nSTARTTIM DS    F\nPACKPARM DS    PL2'0'\nTIMEDW   DS    D\n*\nECBADS   DS    F'0'                   PUTLINE WORKFIELDS\nIOPLADS  DS    4F\n*\nDTEXTADS DS    CL(LTEXTADS)           MSG-WORKFIELD\n*\nPARMLEN  DS    H\nPARMSTR  DS    CL80\n*\nALLMSGS  DS    8CL32000\nLALLMSGS EQU   *-ALLMSGS\nLDWORK   EQU   *-DWORK\n*\n         CVT     DSECT=YES\n         IEECUCM                       UNIT CONTROL MODULE\n*        IEERDCM                       RESIDENT DCM/SCREEN AREA CB\n*        IEETDCM                       PAGEABLE DCM\n         IHAORE                        OPERATOR REPLY ELEMENT\n         IHAWQE                        WTO(R)-QUEUE ELEMENT\n         IHAPSA\n         IHAASCB DSECT=YES\n         IHAASSB\n         IHAASXB DSECT=YES\n         IHAASVT\n         IHAACEE\n         PRINT GEN\n         IEAVM105                      MDB\n         IEAVG132                      MDBPREFIX\n         IEAVG131\n         IEZVG111\n         IKJTSVT\n         IKJCPPL\n         IKJIOPL\n         END   QCMD\n/*\n//SYSLIB    DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSLIN    DD DSN=&&OBJ,UNIT=SYSDA,DISP=(NEW,PASS),\n//          SPACE=(3200,(200,50)),DCB=(RECFM=FB,BLKSIZE=3200,LRECL=80)\n//SYSPRINT  DD SYSOUT=*,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=3990)\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//*\n//* =====================================================\n//* ===== L I N K A G E   E D I T O R ===================\n//* =====================================================\n//LKED      EXEC PGM=HEWL,REGION=1024K,COND=(0,NE),\n//             PARM='XREF,LIST,LET,AC=1,REUS,RENT'\n//SYSLMOD   DD DISP=SHR,DSN=SA1T.T750K.CBTFILE.LOAD\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(10,3))\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD DSN=&&OBJ,DISP=(OLD,DELETE)\n//          DD *\n  NAME    QCMD(R)\n/*\n//TESTRC IF (RC EQ 0) THEN\n//*\n//SCHTEPP3   EXEC PGM=IEBCOPY,REGION=8M\n//SYSPRINT DD  SYSOUT=*\n//IN1  DD  DSN=SA1T.T750K.CBTFILE.LOAD,\n//         DISP=SHR\n//OU1  DD  DSN=SYS2.USER.LINKLIB,\n//         DISP=SHR\n//SYSIN    DD  *\n   COPYMOD INDD=((IN1,R)),OUTDD=OU1\n   SELECT MEMBER=QCMD\n/*\n//ENDTEST ENDIF\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QCMDREPL": {"ttr": 2569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x01\\xf7\\x01\\xf7\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 503, "newlines": 503, "modlines": 0, "user": "TRAMSEI"}, "text": "//T750KY   JOB  (317,04,E1500K),'RAEMSY',\n//             CLASS=X,\n//             MSGCLASS=T,\n//             MSGLEVEL=(1,1),\n//             NOTIFY=&SYSUID,\n//             REGION=8M,\n//             TIME=NOLIMIT\n//*\n//*MAIN SYSTEM=SYT\n//*\n//SCHTEPPX EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSUT1   DD DATA,DLM='@@'\n/* REXX */\nADDRESS TSO\nARG NUMB\n'QCMD CMD=(D T),T=10'        /* WAIT 10 SECS */\nDO NUMB\n  MVSCMD = 'CMD=(GET_REPLIES),T=3,M=V'\n  'QCMD 'MVSCMD\n  DO I = 1 TO QCMD.REPLY_ID.0\n    IF WORD(QCMD.REPLY_TEXT.I,2) = 'ICK003D' THEN\n      DO\n        'QCMD CMD=(R 'QCMD.REPLY_ID.I',U),T=10'\n        SAY 'ISSUED MVS-COMMAND \"R 'QCMD.REPLY_ID.I',U\"'\n      END\n  END\nEND\nEXIT\n@@\n//SYSUT2   DD DSN=SYS2.SATEMP.REXX(REPLY01),\n//            DISP=(,CATLG),UNIT=SYSALLDA,VOL=SER=MVSS21,\n//            DCB=(LRECL=80,RECFM=FB,BLKSIZE=27920),\n//            SPACE=(TRK,(1,1,1),RLSE)\n//*\n//SCHTEPPY EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSUT1   DD DATA,DLM='@@'\n//T750KZZ  JOB  (317,04,E1500K),'RAEMSY',\n//             CLASS=A,\n//             MSGCLASS=T,\n//             MSGLEVEL=(1,1),\n//             NOTIFY=T750K,\n//             REGION=8M,\n//             TIME=NOLIMIT\n//TSOBTCH  EXEC PGM=IKJEFT01\n//SYSPROC  DD DSN=SYS2.SATEMP.REXX,\n//           DISP=(OLD,DELETE,DELETE)\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n  REPLY01 36\n/*\n@@\n//SYSUT2   DD SYSOUT=(*,INTRDR)\n//*\n//WAERIOFF EXEC PGM=IKJEFT01\n//SYSTSPRT DD  SYSOUT=*,DCB=LRECL=130\n//SYSTSIN  DD  *\n QCMD CMD=(RO *ALL,V 1A90-1AB3,OFFLINE),T=5\n/*\n//OFFLINIT EXEC PGM=ICKDSF,COND=(4000,LT)\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n INIT -\n      UNITADDRESS(1A90) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESA90) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1A91) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESA91) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1A92) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESA92) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1A93) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESA93) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1A94) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESA94) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1A95) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESA95) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1A96) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESA96) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1A97) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESA97) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1A98) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESA98) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1A99) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESA99) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1A9A) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESA9A) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1A9B) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESA9B) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1A9C) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESA9C) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1A9D) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESA9D) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1A9E) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESA9E) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1A9F) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESA9F) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AA0) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAA0) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AA1) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAA1) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AA2) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAA2) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AA3) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAA3) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AA4) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAA4) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AA5) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAA5) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AA6) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAA6) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AA7) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAA7) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AA8) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAA8) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AA9) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAA9) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AAA) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAAA) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AAB) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAAB) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AAC) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAAC) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AAD) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAAD) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AAE) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAAE) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AAF) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAAF) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AB0) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAB0) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AB1) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAB1) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AB2) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAB2) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n INIT -\n      UNITADDRESS(1AB3) -\n      DEVICETYPE(3390) -\n      PURGE    -\n      MAP      -\n      NOVERIFY -\n      NOCHECK -\n      NOVALIDATE -\n      NORECLAIM  -\n      VOLID(RESAB3) -\n      INDEX(3,0,30) -\n      VTOC(0,1,44)\n/*\n//WAERION  EXEC PGM=IKJEFT01\n//SYSTSPRT DD  SYSOUT=*,DCB=LRECL=130\n//SYSTSIN  DD  *\n QCMD CMD=(RO *ALL,V 1A90-1AB3,ONLINE),T=5\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QCMP010": {"ttr": 2824, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x00T\\x00T\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 84, "newlines": 84, "modlines": 0, "user": "TRAMSEI"}, "text": ")ATTR DEFAULT(%+_)\n ! TYPE(OUTPUT) INTENS(HIGH) COLOR(YELLOW) JUST(RIGHT)\n } TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n  * AREA(DYNAMIC) SCROLL(ON) EXTEND(ON)\n 01 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 02 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 03 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 04 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 05 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 06 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 07 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 08 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 09 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 0A TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 0B TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 0C TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 0D TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 0E TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 0F TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 10 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 11 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 12 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 13 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 14 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 15 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 16 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 17 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 18 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 19 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 1A TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 1B TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 1C TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 1D TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 1E TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 1F TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n 20 TYPE(DATAOUT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(//)\n%OPTION ====>_ZCMD                                            %SCROLL ===>_Z   +\n%                       }QCMD-CONSOLE               %Lines!flin%to!llin%of!tlin+\n*dyndisp                                                                       *\n%Enter desired MVS-Command. Your Authority is \"MASTER\"                   +     +\n}==>_MVSCMD\n%                 +\n%                 +\n)INIT\n  .ZVARS = 'ZSCML'\n  .ATTRCHAR(01) = 'COLOR(&QCMDC1) HILITE(&QCMDH1)'\n  .ATTRCHAR(02) = 'COLOR(&QCMDC2) HILITE(&QCMDH2)'\n  .ATTRCHAR(03) = 'COLOR(&QCMDC3) HILITE(&QCMDH3)'\n  .ATTRCHAR(04) = 'COLOR(&QCMDC4) HILITE(&QCMDH4)'\n  .ATTRCHAR(05) = 'COLOR(&QCMDC5) HILITE(&QCMDH5)'\n  .ATTRCHAR(06) = 'COLOR(&QCMDC6) HILITE(&QCMDH6)'\n  .ATTRCHAR(07) = 'COLOR(&QCMDC7) HILITE(&QCMDH7)'\n  .ATTRCHAR(08) = 'COLOR(&QCMDC8) HILITE(&QCMDH8)'\n  .ATTRCHAR(09) = 'COLOR(&QCMDC9) HILITE(&QCMDH9)'\n  .ATTRCHAR(0A) = 'COLOR(&QCMDC10) HILITE(&QCMDH10)'\n  .ATTRCHAR(0B) = 'COLOR(&QCMDC11) HILITE(&QCMDH11)'\n  .ATTRCHAR(0C) = 'COLOR(&QCMDC12) HILITE(&QCMDH12)'\n  .ATTRCHAR(0D) = 'COLOR(&QCMDC13) HILITE(&QCMDH13)'\n  .ATTRCHAR(0E) = 'COLOR(&QCMDC14) HILITE(&QCMDH14)'\n  .ATTRCHAR(0F) = 'COLOR(&QCMDC15) HILITE(&QCMDH15)'\n  .ATTRCHAR(10) = 'COLOR(&QCMDC16) HILITE(&QCMDH16)'\n  .ATTRCHAR(11) = 'COLOR(&QCMDC17) HILITE(&QCMDH17)'\n  .ATTRCHAR(12) = 'COLOR(&QCMDC18) HILITE(&QCMDH18)'\n  .ATTRCHAR(13) = 'COLOR(&QCMDC19) HILITE(&QCMDH19)'\n  .ATTRCHAR(14) = 'COLOR(&QCMDC20) HILITE(&QCMDH20)'\n  .ATTRCHAR(15) = 'COLOR(&QCMDC21) HILITE(&QCMDH21)'\n  .ATTRCHAR(16) = 'COLOR(&QCMDC22) HILITE(&QCMDH22)'\n  .ATTRCHAR(17) = 'COLOR(&QCMDC23) HILITE(&QCMDH23)'\n  .ATTRCHAR(18) = 'COLOR(&QCMDC24) HILITE(&QCMDH24)'\n  .ATTRCHAR(19) = 'COLOR(&QCMDC25) HILITE(&QCMDH25)'\n  .ATTRCHAR(1A) = 'COLOR(&QCMDC26) HILITE(&QCMDH26)'\n  .ATTRCHAR(1B) = 'COLOR(&QCMDC27) HILITE(&QCMDH27)'\n  .ATTRCHAR(1C) = 'COLOR(&QCMDC28) HILITE(&QCMDH28)'\n  .ATTRCHAR(1D) = 'COLOR(&QCMDC29) HILITE(&QCMDH29)'\n  .ATTRCHAR(1E) = 'COLOR(&QCMDC30) HILITE(&QCMDH30)'\n  .ATTRCHAR(1F) = 'COLOR(&QCMDC31) HILITE(&QCMDH31)'\n  .ATTRCHAR(20) = 'COLOR(&QCMDC32) HILITE(&QCMDH32)'\n)PROC\n  &VDEPTH = LVLINE(dyndisp)\n  &AIDSC010 = .CURSOR\n  &AIDSC020 = .CSRPOS\n  VPUT (AIDSC010 AIDSC020) SHARED\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QCMSCRL": {"ttr": 2827, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x00\\xac\\x00\\xac\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 172, "newlines": 172, "modlines": 0, "user": "TRAMSEI"}, "text": "/* Rexx */\n/* Aidsc: Universelle SCROLL-Routine f\u00fcr dynamische Areas           */\n/* Unterst\u00fctzte Modi:  UP + DOWN                                    */\n/* Das Scrolling funktioniert analog ISPF Standards.                */\n/* M\u00f6gliche Scroll-Values: PAGE, HALF, CSR, DATA (1. wird letzte)   */\n/* und MAX (='M' + PF7 / PF8)                                       */\n/* AUFRUF: CALL AIDSC 'P=panel A=area F=UP]DOWN S=scroll L=laenge_  */\n/*                     inputstring T=topleftcorner                  */\n/*                                                                  */\n/*                                                                  */\n/* Returnvalue:      Top_left_corner_Value: Wert der neuerrechneten */\n/*                   \"oberen linken Ecke\"                           */\n/*                                                                  */\n/* P=panel            Panelname, welches gescrolled werden soll     */\n/* A=area             Name der dynamischen Area                     */\n/* F=UP]DOWN          scroll UP oder DOWN                           */\n/* S=scrollamount     PAGE, HALF, DATA, MAX oder CSR                */\n/* L=length_inputstr  Laenge des durch die dynamische Area repr\u00e4sen-*/\n/*                    tierten Strings                               */\n/* T=top_left_corner  Obere linke Ecke (bei 1. Aufruf immer 1)      */\n/* V=dsc_vdepth       &LVLINE auf Panel (Last visible Line im SPLIT)*/\n/*                                                                  */\n/* Ist der Benutzer im SPLIT-Screen mode, so wird dies bei den      */\n/* Berechnungen ber\u00fccksichtigt.                                     */\n/*                                                                  */\n/*                                            15.07.96 $$TRA        */\n/*                                                                  */\nArg parmstr\nParse Var parmstr . 'P='dsc_panlname .    /* Panelname from caller  */\nParse Var parmstr . 'A='dsc_areaname .    /* Areaname from caller   */\nParse Var parmstr . 'F='dsc_scrollfc .    /* Scroll-fc from caller  */\nParse Var parmstr . 'S='dsc_scrollam .    /* Scr-Amount from caller */\nParse Var parmstr . 'L='dsc_stringlg .    /* Length of String       */\nParse Var parmstr . 'T='dsc_topleftc .    /* Top left Corner        */\nParse Var parmstr . 'V='dsc_vdepth .      /* Last visible line      */\n/********************************************************************/\n/* Query the Panelcharacteristics + save the values we got          */\n/********************************************************************/\n'ISPEXEC PQUERY  PANEL('dsc_panlname') AREANAME('dsc_areaname'),\n        AREATYPE(DSCATYP) WIDTH(DSCAWID),\n        ROW(DSCAROW) COLUMN(DSCACOL)'\n/********************************************************************/\n/* First, Check if DOWN-Key was pressed                             */\n/********************************************************************/\nIf dsc_scrollfc = 'DOWN' Then              /* Yes, it's Down, get   */\n  Do                                       /* the SCROLL-Amt.       */\n    Select\n      When Datatype(dsc_scrollam) = 'NUM' Then\n        new_topleftc = dsc_topleftc + (dscawid * dsc_scrollam)\n/********************************************************************/\n/* nnnn: numeric Value: add Value * width to top-left-corner        */\n/********************************************************************/\n      When dsc_scrollam = 'PAGE' Then      /* Page, it is simple |  */\n        new_topleftc = dsc_topleftc + (dscawid * dsc_vdepth)\n/********************************************************************/\n/* PAGE: 1 Page = width of dynamic Area (dscawid) *                 */\n/*                Nr. of visible lines (dsc_vdepth)                 */\n/********************************************************************/\n      When dsc_scrollam = 'HALF' Then\n        new_topleftc = dsc_topleftc + (dscawid * (dsc_vdepth % 2))\n/********************************************************************/\n/* HALF: 1 Page Modulo 2                                            */\n/********************************************************************/\n      When dsc_scrollam = 'DATA' Then\n        new_topleftc = dsc_topleftc + (dscawid * (dsc_vdepth - 1))\n/********************************************************************/\n/* DATA: 1 Page - 1 Line                                            */\n/********************************************************************/\n      When dsc_scrollam = 'MAX' Then\n        Do\n          new_topleftc = dsc_stringlg - (dscawid * dsc_vdepth) + 1\n          If new_topleftc < 1 Then\n            new_topleftc = 1\n        End\n/********************************************************************/\n/* MAX: Go to the bottom (dsc_stringlg) and subtract 1 Page,        */\n/*      and then add 1 to point to the 1st pos. of the last Page    */\n/********************************************************************/\n      When dsc_scrollam = 'CSR' Then\n        Do\n/********************************************************************/\n/* Cursor, its getting complicated |                                */\n/* First, get the Areaname (AIDSC010) and the relative CursorPos.   */\n/*        in this Area (AIDSC020) (rel.Pos = #of bytes from the top */\n/*        left corner of the Area)                                  */\n/********************************************************************/\n          'ISPEXEC VGET (AIDSC010 AIDSC020) SHARED'\n          If aidsc010 = dsc_areaname Then   /* Is this really \"our\" */\n            Do                              /* area? - Yes, compute|*/\n              dsc_currow = aidsc020\n/********************************************************************/\n/* dsc_curline is the line, on which the cursor is positionned:     */\n/* rel. cursorposition-1 modulo areawidth = line-1, + 1 = line      */\n/* e.g: curpos=188, width=20                                        */\n/* 188-1 = 187 % 20 = 9 + 1 = 10  => cursor is on line 10           */\n/* or curpos = 1, width = 20                                        */\n/* 1-1=0 % 20 = 0 + 1 = 1    => cursor is on line 1                 */\n/********************************************************************/\n              dsc_curline = (aidsc020 - 1) % dscawid + 1\n/********************************************************************/\n/* new_topleftc is the new top left corner:                         */\n/* oldtopleftcorner + (cursorline-1) * width                        */\n/********************************************************************/\n              new_topleftc = dsc_topleftc + ((dsc_curline-1) * dscawid)\n            End\n          Else\n            new_topleftc = dsc_topleftc + (dscawid * dsc_vdepth)\n/********************************************************************/\n/* cursor is not on the activ area, so scrolling is PAGE            */\n/********************************************************************/\n        End\n      Otherwise\n        Nop\n    End\n/********************************************************************/\n/* If Scrolling exeeds bottom of data, show the last line on top    */\n/********************************************************************/\n    If new_topleftc >= dsc_stringlg Then\n      new_topleftc = dsc_stringlg - dscawid + 1\n  End\nElse If dsc_scrollfc = 'UP' Then\n  Do\n    Select\n      When Datatype(dsc_scrollam) = 'NUM' Then\n        new_topleftc = dsc_topleftc - (dscawid * dsc_scrollam)\n/********************************************************************/\n/* nnnn: numeric Value: add Value * width to top-left-corner        */\n/********************************************************************/\n      When dsc_scrollam = 'PAGE' Then\n        new_topleftc = dsc_topleftc - (dscawid * dsc_vdepth)\n/********************************************************************/\n/* HALF: 1 Page = % 2                                               */\n/********************************************************************/\n      When dsc_scrollam = 'HALF' Then\n        new_topleftc = dsc_topleftc - (dscawid * (dsc_vdepth % 2))\n/********************************************************************/\n/* DATA: 1 Page - 1 Line                                            */\n/********************************************************************/\n      When dsc_scrollam = 'DATA' Then\n        new_topleftc = dsc_topleftc - (dscawid * (dsc_vdepth - 1))\n/********************************************************************/\n/* MAX: always 1                                                    */\n/********************************************************************/\n      When dsc_scrollam = 'MAX' Then\n        new_topleftc = 1\n      When dsc_scrollam = 'CSR' Then\n        Do\n          'ISPEXEC VGET (AIDSC010 AIDSC020) SHARED'\n          If aidsc010 = dsc_areaname Then\n            Do\n              dsc_currow = aidsc020\n/********************************************************************/\n/* dsc_curline is the same as described in the 'DOWN' section.      */\n/* new_topleftc is the new top left corner:                         */\n/* oldtopleftcorner - (cursorline  * width)                         */\n/********************************************************************/\n              dsc_curline = (aidsc020 - 1) % dscawid + 1\n              new_topleftc = dsc_topleftc -,\n                  ((dsc_vdepth * dscawid) - ((dsc_curline) * dscawid))\n            End\n          Else\n            new_topleftc = dsc_topleftc - (dscawid * dsc_vdepth)\n        End\n      Otherwise\n        Nop\n    End\n    If new_topleftc <= 1 Then\n      new_topleftc = 1\n  End\nElse\n  Nop\nReturn new_topleftc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QLPAR": {"ttr": 3075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x01\\xd8\\x01\\xd8\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 472, "newlines": 472, "modlines": 0, "user": "TRAMSEI"}, "text": "//T750KY   JOB  (317,04,E1500K),'RAEMSY',\n//             CLASS=X,\n//             MSGCLASS=T,\n//             MSGLEVEL=(1,1),\n//             NOTIFY=&SYSUID,\n//             REGION=8M,\n//             TIME=NOLIMIT\n//*\n//*MAIN SYSTEM=SYT\n//*\n//ASM      EXEC PGM=ASMA90,REGION=2048K,\n//          PARM='NODECK,OBJECT,RENT'\n//SYSIN     DD *\nQLPAR    TITLE '*** \"QLPAR\" *** TSO COMMAND PROCESSOR &SYSDATE'\n***********************************************************************\n* QLPAR                                                               *\n* =====                                                               *\n* QLPAR IS A TSO COMMAND-PROCESSOR THAT EXTRACTS LPAR-INFORMATIONS,   *\n* SUCH AS NUMBER OF LPARS, LPAR NAMES, PROCESSOR WEIGHTS A.S.O ...    *\n* THANKS TO ALFRED NYKOLYN OF HDS HITACHI DATA SYSTEMS CANADA FOR     *\n* THE VERY USEFUL HINTS ABOUT THE DIAGNOSE 204 INSTRUCTION WHICH      *\n* EXTRACTS THE NECESSARY LPAR-INFORMATIONS AND TO JULIEN B. WILKINSON *\n* OF HDS SWITZERLAND FOR THE INITIAL CODING.                          *\n* ALL INFORMATIONS ARE RETURNED VIA THE PUTLINE-MACRO SO THAT THEY    *\n* CAN BE ACCESSED BY THE REXX-OUTTRAP FUNCTION.                       *\n*                                                                     *\n* LINKEDIT PARMS: AMODE(31),RMODE(ANY), RENT,REUS,AC(1)               *\n*                                                                     *\n* QLPAR MUST BE LINKEDITED IN AN APF-AUTHORIZED + LINKLIST CONCATEN-  *\n*       ATED LOADLIBRARY. ADD ALSO AN ENTRY IN THE AUTHCMD-LIST OF    *\n*       YOUR IKJTSOXX-MEMBER IN SYS1.PARMLIB                          *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*     EQUATES                                                         *\n***********************************************************************\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2                      MESSAGE-AREA POINTER\nR3       EQU   3                      WORK-REGISTER\nR4       EQU   4                      WORK-REGISTER\nR5       EQU   5                      PGFIX-STORAGE POINTER\nR6       EQU   6                      PGFIX-STORAGE LENGTH\nR7       EQU   7                      WORK-REGISTER\nR8       EQU   8                      BASE #2\nR9       EQU   9                      ERROR-MSG-POINTER\nR10      EQU   10                     BAL\nR11      EQU   11                     STORAGE OBTAINED AREA\nR12      EQU   12                     BASE #1\nR13      EQU   13                     HIGHER SAVE-AREA\nR14      EQU   14                     BAKR\nR15      EQU   15                     RC\n         EJECT\n***********************************************************************\n*     START                                                           *\n***********************************************************************\nQLPAR    CSECT\nQLPAR    AMODE 31\nQLPAR    RMODE ANY\n         PRINT GEN\n         SPACE 2\n         BAKR  14,0                  ESTABLISH LINKAGE-CONVENTIONS\n         LR    R12,R15               LOAD TEMPORARY BASE TO MY BASE\n         LA    R8,2048               LOAD 2NDRY BASE  ..\n         LA    R8,2048(R12,R8)       W. 2ND 4K\n         USING QLPAR,R12,R8          TELL ASSEMBLER\n         LR    R3,R1                 ESTABLISH CPPL'S  ADDRESSABILITY\n         XR    R9,R9                 CLEAR RC/ERRORMSG REGISTER\nGETSTOR  DS    0H\n         STORAGE OBTAIN,LENGTH=LDWORK,LOC=ANY  GET WORKING STORAGE\n         LR    R11,R1                ESTABLISH DSECT'S ADDRESSABILITY\n         USING DWORK,R11             TELL ASSEMBLER\n         BAL   R10,LOADCPPL          SAVE CPPL INTO MY IOPL\n         BAL   R10,GETPARMS          GET THE PARAMETER-STRING\n         LTR   R9,R9                 WENT IT OK ?\n         BNZ   ISSUEMSG              (BNZ = NO, ERRORMSG + OUT)\nSETAUTH  MODESET MF=(E,SUPRMOD)      GET ME INTO SUPERVISOR MODE\n         STAX  DEFER=YES             NO ATTENTION EXITS, PLEASE\n         BAL   R10,FIXPAGE           GO AND PAGEFIX SOME STORAGE\n         LTR   R9,R9                 WENT IT OK ?\n         BNZ   ISSUEMSG              (BNZ = NO, ERRORMSG + OUT)\n         BAL   R10,LPARINFO          GET THIS BLOODY LPAR-INFOS\n         BAL   R10,CLEANPAG          CLEANUP PAGEFIXED+GETM'D AREAS\nISSUEMSG DS    0H\n         BAL   R10,PUTLBSNS          ISSUE EITHER INFOS OR ERRORMSG\n*\nENDIT    DS    0H\nREMAUTH  MODESET MF=(E,PROBMOD)      RETURN INTO PROBLEM MODE\n         STORAGE RELEASE,LENGTH=LDWORK,ADDR=(R11)  FREE OBTAINED STOR.\n         XR    R15,R15                SET RC=0\n         PR                           END QLPAR + CLEANUP\n*\n***********************************************************************\n*     EXECUTE                                                         *\n***********************************************************************\n***********************************************************************\n*     SUBROUTINES                                                     *\n***********************************************************************\n*\nLOADCPPL ST    R10,SAVE10\n         USING CPPL,R3                GET THE ADDRESSES IN CPPL\n         MVC   CPLCBUF,CPPLCBUF       MOVE COMM.-BUFFER ADDR TO MY AREA\n         MVC   CPLUPT,CPPLUPT         MOVE USERPROFTAB ADDR TO MY AREA\n         MVC   CPLPSCB,CPPLPSCB       MOVE PROT.STEP-CB ADDR TO MY AREA\n         MVC   CPLECT,CPPLECT         MOVE ECT-ADDRESS TO MY AREA\n         DROP  R3                     FREE CPPL\n         L     R10,SAVE10\n         BR    R10\n*\n*********************************************************************\n* GET PASSED PARAMETERS\n*********************************************************************\n*\nGETPARMS ST    R10,SAVE10\n         XR    R9,R9\n         L     R10,SAVE10\n         BR    R10\n         LTORG\n**********************************************************************\n* FIXPAGE: PAGEFIX STORAGE VIA GETMAIN (NO STORAGE OBTAIN W. PGSER)\n**********************************************************************\nFIXPAGE  ST    R10,SAVE10\n         XR    R9,R9\n         GETMAIN RU,LV=4096,BNDRY=PAGE,LOC=BELOW\n         LR    R5,R1                 SAVE POINTER TO GETMAINED AREA\n         LTR   R15,R15               CHECK STORAGE OK\n         BZ    PAGE0010              (BZ = OKAY, CONTINUE)\n         LA    R9,ERR0020            POINT TO THE APPROPRIATE MESSAGE\n         B     PAGE0090              GO AND ISSUE IT\nPAGE0010 DS    0H\n         LA    R6,2048               LOAD LENGTH  ...\n         AR    R6,R6                 ... OF 1 PAGE REALSTORAGE\n         AR    R6,R5                 POINT AT END OF GETM'D AREA\n         BCTR  R6,0                  SUBTRACT 1 TO POINT TO LAST BYTE\n         STM   R5,R6,PAGEADRS        SAVE THE POINTERS\n         PGSER R,FIX,A=(5),EA=(6),BRANCH=Y,ECB=FIXECB\n         LTR   R15,R15               WAS IT SUCCESSFUL ?\n         BZ    PAGE0090              (BZ=YES, CONTINUE)\n         LA    R9,ERR0030            NO, LOAD ERROR-MESSAGE\nPAGE0090 DS    0H\n         XR    R15,R15\n         L     R10,SAVE10\n         BR    R10\n         LTORG\n*\n*********************************************************************\n* GET LPAR-INFORMATION VIA DIAGNOSE\n* INSTRUCTION FORMAT:\n*  X'83'       OPCODE FOR DIAGNOSE\n*  X'10'       USE REGISTERS 1 (REAL-ADDRESS OF PAGEFIXED STORAGE)\n*              AND 0 (W. A CONSTANT OF 4)\n*  X'0204'     IS THE DIAGNOSE CODE FOR LPAR-INFORMATIONS\n*********************************************************************\n*\nLPARINFO ST    R10,SAVE10\n         XR    R9,R9\n         LM    R5,R6,PAGEADRS        GETM'D AREA: START(R3), END(R4)\n         LRA   R1,0(0,R5)            LOAD REAL START ADDR INTO R1\n         LA    R0,4                  R0 NEEDS A CONSTANT OF '4'\n         DC    X'83100204'           PERFORM A DIAGNOSE 204\n         USING PRSMBUF,R5            TELL ASSEMBLER\n         LA    R2,ALLMSGS            TOP OF MESSAG-AREA\n         XR    R4,R4                 CLEAR WORKREG\n         IC    R4,PRNBPART           INSERT # OF PARTITIONS\n         LR    R6,R4                 SAVE IT FOR OUTER LOOP\n         PRINTREG (R4),RESULT=DECIMAL,PADCHAR=BLANK   MAKE IT PRINTABLE\n         LA    R7,WORKMSG            POINT TO WORKAREA\n         XC    WORKMSG,WORKMSG       CLEAR IT OUT\n         MVC   0(30,R7),=CL30'NUMBER OF PARTITIONS:'    MOVE TEXT THERE\n         MVC   30(8,R7),8(R1)        MOVE DATA THEREAFTER\n         LA    R0,38                 LOAD LENGTH OF ALL TOGETHER\n         ADDMSG (R0),(R7),(R2)       MAKE A \"PUTLBSNS\"-CONFORM STRING\n         LR    R2,R1                 POINT AT NEXT FREE MESSAGE-SLOT\n         XR    R4,R4                 CLEAR WORKREG\n         IC    R4,PRNBPROC           INSERT # OF PROCESSORS\n         PRINTREG (R4),RESULT=DECIMAL,PADCHAR=BLANK   MAKE IT PRINTABLE\n         LA    R7,WORKMSG            POINT TO WORKAREA\n         XC    WORKMSG,WORKMSG       CLEAR IT OUT\n         MVC   0(30,R7),=CL30'NUMBER OF PROCESSORS:'    MOVE TEXT THERE\n         MVC   30(8,R7),8(R1)        MOVE DATA THEREAFTER\n         LA    R0,38                 LOAD LENGTH OF WHOLE STUFF\n         ADDMSG (R0),(R7),(R2)       MAKE IT \"PUTLBSNS\"-COMPATIBLE\n         LR    R2,R1                 POINT AT NEXT FREE MESSAGE-SLOT\n*\n         LR    R4,R5                 POINT AT TOP OF DSECT\n         AH    R4,PROFFCUR           ADD OFFSET TO CURRENT PARTITION\n         LA    R7,WORKMSG            POINT TO WORKAREA\n         XC    WORKMSG,WORKMSG       CLEAR IT OUT\n         MVC   0(30,R7),=CL30'CURRENT PARTITION NAME:'  MOVE TEXT THERE\n         MVC   30(8,R7),8(R4)        MOVE DATA THEREAFTER\n         LA    R0,38                 LOAD LENGTH OF WHOLE STUFF\n         ADDMSG (R0),(R7),(R2)       MAKE IT \"PUTLBSNS\"-COMPATIBLE\nLPARLOOP DS    0H                    OUTER LOOP (NR. OF LPAR)\n*\n         LR    R2,R1                 POINT AT NEXT FREE MESSAGE-SLOT\n         LA    R1,1\n         STH   R1,0(R2)\n         MVI   2(R2),C'*'\n         AH    R2,=H'3'\n         LA    R7,WORKMSG            POINT TO WORKAREA\n         XC    WORKMSG,WORKMSG       CLEAR IT OUT\n         MVC   0(30,R7),=CL30'PARTITION SUMMARY FOR:'  MOVE TEXT THERE\n         MVC   30(8,R7),PRNAME       MOVE DATA THEREAFTER\n         LA    R0,38                 LOAD LENGTH OF WHOLE STUFF\n         ADDMSG (R0),(R7),(R2)       MAKE IT \"PUTLBSNS\"-COMPATIBLE\n         LR    R2,R1                 POINT AT NEXT FREE MESSAGE-SLOT\n*\n         XR    R4,R4                 CLEAR WORKREG\n         IC    R4,PRNOPART           INSERT PARTITION-NUMBER\n         PRINTREG (R4),RESULT=DECIMAL,PADCHAR=BLANK   MAKE IT PRINTABLE\n         LA    R7,WORKMSG            POINT TO WORKAREA\n         XC    WORKMSG,WORKMSG       CLEAR IT OUT\n         MVC   0(30,R7),=CL30'PHYSICAL NUMBER OF PARTITION'  TEXT THERE\n         MVC   30(8,R7),8(R1)        MOVE DATA THEREAFTER\n         LA    R0,38                 LOAD LENGTH OF ALL TOGETHER\n         ADDMSG (R0),(R7),(R2)       MAKE A \"PUTLBSNS\"-CONFORM STRING\n         LR    R2,R1                 POINT AT NEXT FREE MESSAGE-SLOT\n*\n         XR    R4,R4                 CLEAR WORKREG\n         IC    R4,PRNBPRLO           INSERT # OF LOGICAL PROCESSORS\n         LR    R3,R4                 SAVE IT\n         PRINTREG (R4),RESULT=DECIMAL,PADCHAR=BLANK   MAKE IT PRINTABLE\n         LA    R7,WORKMSG            POINT TO WORKAREA\n         XC    WORKMSG,WORKMSG       CLEAR IT OUT\n         MVC   0(30,R7),=CL30'NUMBER OF LOGICAL PROCESSORS:' TEXT THERE\n         MVC   30(8,R7),8(R1)        MOVE DATA THEREAFTER\n         LTR   R4,R4                 ARE THERE NO LOGICAL PROCS?\n         BNZ   PROCFND1              YES, THERE ARE, BUMP\n         MVI   37(R7),C'0'           MOVE A ZERO THERE\nPROCFND1 DS    0H\n         LA    R0,38                 LOAD LENGTH OF ALL TOGETHER\n         ADDMSG (R0),(R7),(R2)       MAKE A \"PUTLBSNS\"-CONFORM STRING\n         LR    R2,R1                 POINT AT NEXT FREE MESSAGE-SLOT\n         LTR   R3,R3                 NO LOGICAL PROCESSORS? $$TEST$$\n         BZ    NOLPROCS              BUMP OVER LPROC-LOOP $$TEST$$\n*\nLPRCLOOP DS    0H                    INNER LOOP, 1 PER PROC PER LPAR.\n         XR    R4,R4\n         IC    R4,PRNBPRLN           INSERT LPROC-NUMBER\n*\n         PRINTREG (R4),RESULT=DECIMAL,PADCHAR=BLANK   MAKE IT PRINTABLE\n         LA    R7,WORKMSG            POINT TO WORKAREA\n         XC    WORKMSG,WORKMSG       CLEAR IT OUT\n         MVC   0(22,R7),=CL22'LOGICAL PROCESSOR NR.:'        TEXT THERE\n         LTR   R4,R4                 IS IT PROCESSOR-NR '0' ?\n         BZ    MOVEZERO              (BZ=YES, MOVE A ZERO THERE)\n         MVC   22(8,R7),8(R1)        MOVE DATA THEREAFTER\n         B     BUMP0020              BUMP OVER NEXT INSTRUCTION\nMOVEZERO MVI   29(R7),C'0'           MOVE A ZERO THERE\nBUMP0020 DS    0H\n         MVC   32(24,R7),=CL24'WEIGHT-FACTOR (DECIMAL):'\n         LH    R4,PRWEIGHT           INSERT WEIGHTNING-FACTOR\n         PRINTREG (R4),RESULT=DECIMAL,PADCHAR=BLANK   MAKE IT PRINTABLE\n         MVC   56(8,R7),8(R1)        MOVE DATA THEREAFTER\n         MVC   66(11,R7),=CL11'CAPPED:  NO'\n         TM    PRPRFLAG,PRPRCAPD     IS IT CAPPED?\n         BNO   NOTCAPPD              NO, BUMP OVER INSER\n         MVC   74(3,R7),=CL3'YES'\nNOTCAPPD DS    0H\n         LA    R0,77                 LOAD LENGTH OF ALL TOGETHER\n         ADDMSG (R0),(R7),(R2)       MAKE A \"PUTLBSNS\"-CONFORM STRING\n         LR    R2,R1                 POINT AT NEXT FREE MESSAGE-SLOT\n*\n         LA    R5,PRPRLENG(,R5)      ADD 1 LOG.PROC-ENTRY (INNER LOOP)\n         BCT   R3,LPRCLOOP           GET NEXT LOGICAL PROCESSOR\nNOLPROCS DS    0H                    $$TEST$$ \u00c9OGICAL PROCS. 0\n         LA    R5,PRPRFLEN(,R5)      ADD 1 LPAR-ENTRY (OUTER LOOP)\n         BCT   R6,LPARLOOP           GET NEXT LPAR\n         L     R10,SAVE10            LOAD SUBROUTINES ENTRY-POINT\n         BR    R10                   BRANCH THERE\n         LTORG\n*\n**********************************************************************\n* CLEANPAG: FREE PAGEFIXED STORAGE AND GETMAINED AREA\n**********************************************************************\nCLEANPAG ST    R10,SAVE10\n         XR    R9,R9\n         LM    R5,R6,PAGEADRS        SAVE THE POINTERS\n         PGSER R,FREE,A=(5),EA=(6),BRANCH=Y,ECB=FIXECB\n         FREEMAIN RU,LV=4096,A=(5)\nCLEAN090 DS    0H\n         L     R10,SAVE10\n         BR    R10\n         LTORG\n*\n***********************************************************************\n*     PUTLBSNS: DO THE PUTLINE-BUSINESS                               *\n***********************************************************************\nPUTLBSNS ST    R10,SAVE10\n         STFSMODE ON,INITIAL=YES     CLEAR ....\n         STFSMODE OFF                      .... SCREEN\n         LA    R4,IOPLADS            LOAD DYNAMIC IOPL\n         USING IOPL,R4               FILL IT\n         L     R3,CPLUPT             LOAD DYN. USER'S PROFILE TABLE\n         ST    R3,IOPLUPT            STORE IT IN THE IOPL\n         L     R3,CPLECT             LOAD ADDRESS OF DYN. ECT\n         ST    R3,IOPLECT            STORE IT IN THE IOPL\n         LA    R3,ECBADS             LOAD ADDR OF MY ECB TO R3\n         ST    R3,IOPLECB            STORE ADDRESS OF ECBADS IN IOPL\n         MVC   @MLWAREA(L@PUTLIN),@PUTLIN\n         MVC   DTEXTADS(LTEXTADS),TEXTADS   MOVE CONSTANT TO MY AREA\n         LA    R3,ALLMSGS            POINT TO VARIABLE MSG-AREA\n         LTR   R9,R9                 IS THERE AN ERRORMESSAGE ?\n         BZ    PUTL010               (BZ=NO, WRITE DATA)\n         LR    R3,R9                 POINT TO CORRECT ERRORMSG\nPUTL010  DS    0H                    PREPARE FOR THE PUTLINE\n         XC    DTEXTADS(4),DTEXTADS  CLEAR LENGTH-COUNTER\n         LH    R5,0(R3)              LENGTH OF CURRENT ENTRY INTO R5\n         LTR   R5,R5                 IS IT ZERO ?\n         BZ    PUTL020               (BE = YES, ALL WRITTEN)\nPUTL015  LA    R4,4(,R5)             ADD 4 FOR PUTLINE-HEADER\n         STH   R4,DTEXTADS           STORE INTO WORKAREA\n         BCTR  R5,0                  SUBTRACT 1 FOR EXECUTE\n         EX    R5,PUTLMVC1           DO THE EXECUTE\n         PUTLINE PARM=@MLWAREA,                                        X\n               OUTPUT=(DTEXTADS,TERM,SINGLE,DATA),MF=(E,IOPLADS)\n*                                    DO THE PUTLINE\n         AR    R3,R5                 ADD LENGTH OF MSG-TEXT\n         LA    R3,3(,R3)             ADD LENGTH OF MSG-FIELD\n         B     PUTL010               TRY NEXT MESSAGE\nPUTL020  XR    R15,R15\n         L     R10,SAVE10\n         BR    R10\n         LTORG\nPUTLMVC1 MVC   DTEXTADS+4(0),2(R3)\n***********************************************************************\n*     CONSTANTS                                                       *\n***********************************************************************\n*\nTEXTADS  DC    H'132'\n         DC    H'0'\n         DC    CL132' '\nLTEXTADS EQU   *-TEXTADS\n*\nERR0020  DC    H'76'\n         DC    CL76'ERROR DURING GETMAIN. FUNCTION QLPAR ENDED.'\n         DC    H'0'\nERR0030  DC    H'76'\n         DC    CL76'PGSER FAILED. QLPAR CAN''T CONTINUE.'\n         DC    H'0'\n*\nEDMASK   DC    X'4020202020202020'\nLEDMASK EQU    *-EDMASK\n***********************************************************************\n*     MACRO LIST-FORM                                                 *\n***********************************************************************\n@PUTLIN  PUTLINE MF=L\nL@PUTLIN EQU    *-@PUTLIN\n*\nSUPRMOD  MODESET KEY=ZERO,MODE=SUP,MF=L\n*\nPROBMOD  MODESET KEY=NZERO,MF=L\n*\n         EJECT\n*\n***********************************************************************\n*     COPY    SECTION                                                 *\n***********************************************************************\n***********************************************************************\n*     WORKING SECTION                                                 *\n***********************************************************************\n*\nDWORK    DSECT\n@MLWAREA DS    XL256                  MF=L WORKAREA\n*\nSAVE2    DS    F\nSAVE10   DS    F\nPAGEADRS DS    2F\n*\nFIXECB   DS    F\n*\nCPLCBUF  DS    F                      CPPL-WORKFIELDS\nCPLUPT   DS    F\nCPLPSCB  DS    F\nCPLECT   DS    F\n*\nECBADS   DS    F                      PUTLINE WORKFIELDS\nIOPLADS  DS    4F\n*\nWORKDW   DS    D\nWORKMASK DS    CL(LEDMASK)            MSG-WORKFIELD\n*\nDTEXTADS DS    CL(LTEXTADS)           MSG-WORKFIELD\n*\nWORKMSG  DS    CL80\n*\nALLMSGS  DS    CL32767\nLALLMSGS EQU   *-ALLMSGS\n*\nLDWORK   EQU   *-DWORK\n*\n         EJECT\n*--------------------------------------------------------------------*\n*        DIAGNOSE 204 BUFFER                                         *\n*--------------------------------------------------------------------*\n         SPACE 3\nPRSMBUF  DSECT\nPRNBPART DS    XL1                 # PARTITIONS\n         DS    XL4\nPRNBPROC DS    XL1                 # PHYSICAL PROCESSORS\nPROFFCUR DS    H                   CURRENT PARTITION ENTRY OFFSET\nPRTOD    DS    D                   TOD CLOCK\nPRPRFLEN EQU   *-PRSMBUF\n         SPACE 3\n*--------------------------------------------------------------------*\n*        PARTITION ENTRY                                             *\n*--------------------------------------------------------------------*\n         SPACE 3\nPRSMPART DS    0F\nPRNOPART DS    XL1                  PARTITION #\nPRNBPRLO DS    XL1                  # LP'S IN THIS PARTITION\n         DS    XL6\nPRNAME   DS    CL6                  PARTITION NAME\nPRPALENG EQU   *-PRSMPART\n         SPACE 3\n*--------------------------------------------------------------------*\n*        LOGICAL PROCESSOR ENTRY FOR PARTITION                       *\n*--------------------------------------------------------------------*\n         SPACE 3\nPRSMPARP DS    0F\n         DS    XL1\nPRNBPRLN DS    XL1                 LP #\n         DS    XL3\nPRPRFLAG DS    XL1                 FLAGS\nPRPRCAPD EQU   X'40'               FLAGS\nPRWEIGHT DS    H                   PARTITION WEIGHT\nPRDISP   DS    D                   DISPATCH TIME\n         DS    XL8\nPRPRLENG EQU   *-PRSMPARP\n*\n         CVT     DSECT=YES\n         IHAPVT\n         IKJCPPL\n         IKJIOPL\n         END   QLPAR\n/*\n//SYSLIB    DD DISP=SHR,DSN=SA1T.T750K.CBTFILE.CNTL    <== THIS PDS\n//          DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSLIN    DD DSN=&&OBJ,UNIT=SYSDA,DISP=(NEW,PASS),\n//          SPACE=(3200,(200,50)),DCB=(RECFM=FB,BLKSIZE=3200,LRECL=80)\n//SYSPRINT  DD SYSOUT=*,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=3990)\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//*\n//* =====================================================\n//* ===== L I N K A G E   E D I T O R ===================\n//* =====================================================\n//LKED      EXEC PGM=HEWL,REGION=1024K,COND=(0,NE),\n//             PARM='XREF,LIST,LET,AC=1,REUS,RENT'\n//SYSLMOD   DD DISP=SHR,DSN=SA1T.T750K.CBTFILE.LOAD\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(10,3))\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD DSN=&&OBJ,DISP=(OLD,DELETE)\n//          DD *\n  NAME    QLPAR(R)\n/*\n//TESTRC IF (RC EQ 0) THEN\n//*\n//SCHTEPP3   EXEC PGM=IEBCOPY,REGION=8M\n//SYSPRINT DD  SYSOUT=*\n//IN1  DD  DSN=SA1T.T750K.CBTFILE.LOAD,\n//         DISP=SHR\n//OU1  DD  DSN=SYS2.USER.LINKLIB,\n//         DISP=SHR\n//SYSIN    DD  *\n   COPYMOD INDD=((IN1,R)),OUTDD=OU1\n   SELECT MEMBER=QLPAR\n/*\n//ENDTEST ENDIF\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QSMS": {"ttr": 3083, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00$\\x01\\x00%\\x1f\\x01\\x185?\\x12\\x16\\x03\"\\x03 \\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2018-12-19T12:16:24", "lines": 802, "newlines": 800, "modlines": 0, "user": "IBMUSER"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//ASM      EXEC PGM=ASMA90,REGION=2048K,\n//          PARM='NODECK,OBJECT,USING(NOWARN),RENT'\n//SYSIN     DD *\nQSMS TITLE '*** \"QSMS \" *** &SYSDATE'\n***********************************************************************\n*                                                                     *\n*     QSMS - READS SMS-CONFIG AND CHECKS MVS-STATUS OF DEFINED VOLS   *\n*                                                                     *\n*     CHANGE LOG:                                                     *\n*     2018/12/19 - S.GOLOB - LIMIT NUMBER OF SYSTEMS SEARCHED FOR     *\n*                  TO PREVENT S0C4.  SEE JUST ABOVE LABEL CNFGLUP1.   *\n*                  ADJUST BCT REGISTER R5 SMALLER OR LARGER IF        *\n*                  NECESSARY.                                         *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*     EQUATES                                                         *\n***********************************************************************\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n***********************************************************************\n*     START                                                           *\n***********************************************************************\nQSMS     CSECT\nQSMS     AMODE 31\nQSMS     RMODE ANY\n         PRINT NOGEN\n         SPACE 2\n         BAKR  14,0                ESTABLISH LINKAGE-CONVENTIONS\n         LR    R12,R15             ADDRESSABILITY\n         USING QSMS,R12            TELL ASSEMBLER\n         LR    R2,R0               A(ENVBLOCK IF CALLED FROM A REXX)\n         LR    R3,R1               ESTABLISH CPPL'S  ADDRESSABILITY\nGETSTOR  DS    0H                  OBTAIN REENTRANT WORKSPACE\n         STORAGE OBTAIN,LENGTH=LDWORK,LOC=ANY\n         LR    R11,R1              ESTABLISH DSECT'S ADDRESSABILITY\n         USING DWORK,R11           TELL ASSEMBLER\n         BAL   R14,CHKENVIR        EVALUATE CALLERS ENVIRONMENT\n         BAL   R14,GETCONFG        CALL SMS VIA SSI TO GET SMS-CONFIG\n         BAL   R14,GETSVOLI        BUILD A LIST OF ALL SMS-VOLUMES\n         BAL   R14,PUTLBSNS        ISSUE PUTLINE (IF TSO-COMMAND)\n         BAL   R14,REXXVARS        BUILD REXX-VARS(IF REXX-FUNCTION)\n*\n         L     R2,RCODE\n         STORAGE RELEASE,LENGTH=LDWORK,ADDR=(R11)  FREE OBTAINED STOR.\n         LR    R15,R2\n         PR                        END QSMS + CLEANUP\n         LTORG\n*\n***********************************************************************\n*     SUBROUTINES                                                     *\n***********************************************************************\n*\n*********************************************************************\n* CHECK CALLERS ENVIRONMENT\n*********************************************************************\n*\nCHKENVIR ST    R14,SAVE14\n         OI    FLAGBYTE,REXXENV      ASSUME RUNNING IN REXX-ENVT.\n         CLC   =C'ENVBLOCK',0(R2)    ENVIRONMENT BLOCK FOUND ?\n         BE    ENV0030               (BE=YES, BUMP OVER CPPL-SECTION)\n         USING CPPL,R3               GET THE ADDRESSES IN CPPL\n         MVC   CPLCBUF,CPPLCBUF      MOVE COMM.-BUFFER ADDR TO MY AREA\n         MVC   CPLUPT,CPPLUPT        MOVE USERPROFTAB ADDR TO MY AREA\n         MVC   CPLPSCB,CPPLPSCB      MOVE PROT.STEP-CB ADDR TO MY AREA\n         MVC   CPLECT,CPPLECT        MOVE ECT-ADDRESS TO MY AREA\n         DROP  R3                    FREE CPPL\n         NI    FLAGBYTE,255-REXXENV  RESET FLAGBYTE\n         B     ENV0090\nENV0030  DS    0H\n*        OI    FLAGBYTE,REXXENV      CALLED AS REXX-FUNCTION, SET FLAG\n         STM   R2,R3,SAVEREXX        SAVE ADDRESSES FOR LATER USE\nENV0090  DS    0H\n         LA    R8,ALLMSGS            A(ANSWER-AREA)\n         SLR   R9,R9                 A(ERROR-MSG)\n         L     R14,SAVE14\n         BR    R14\n         LTORG\n*\n*********************************************************************\n* GETCONFG: PICK ACTUAL SMS-CONFIG VIA THE SUBSYSTEM INTERFACE\n*********************************************************************\n*\nGETCONFG ST    R14,SAVE14          STORE BACKPOINTER\n         LH    R1,=Y(BCD_TOTAL_LENGTH)\n         ST    R1,WBCDSLEN\n         STORAGE OBTAIN,LENGTH=(R1),                                   X\n               LOC=ANY,BNDRY=PAGE,ADDR=(R7)\n         L     R1,CVTPTR                        A(CVT) INTO R1\n         MVC   CURRSYS(8),CVTSNAME-CVT(R1)\n         L     R1,CVTJESCT-CVT(,R1)             A(JESCT) INTO R1\n         L     R1,JESCTEXT-JESCT(,R1)           A(JESPEXT) INTO R1\n         ICM   R1,B'1111',JESSMSIB-JESPEXT(R1)  A(SMS-SSIB) INTO R2\n         BZ    CNFG0080            (BZ=NO SMS-ENV. FOUND, EXIT)\n         XC    WSSOB,WSSOB         CLEAR WORK-SSOB\n         LA    R2,WSSOB            A(WORK SSOB)\n         USING SSOB,R2             TELL ASSEMBLER\n         ST    R1,SSOBSSIB         A(WORK-SSIB) INTO WORK-SSOB\n         MVC   SSOBID,=C'SSOB'     CB-ID INTO WORKAREA\n         MVI   SSOBFUNC+1,SSOBSSMS    FUNCTION-CODE FOR SMS (55)\n         MVI   SSOBLEN+1,SSOBHSIZ  LENGTH OF SSOB INTO WORK-SSOB\n         LA    R3,WSSSA            A(WORK FUNCTION DEPENDENT AREA)\n         ST    R3,SSOBINDV         STORE IN WORK-SSOB\n         USING IEFSSSA,R3          TELL ASSEMBLER\n         MVC   SSSAID,=C'SSSA'     CB-ID INTO WORKAREA\n         LA    R0,SSSALN+SSSA1LN   TOTAL LENGTH OF USED PARTS OF WSSSA\n         STH   R0,SSSALEN          STORE IN WSSSA\n         MVI   SSSAVER+1,SSOBSSVR  MOVE SSOB-VERSION INTO WSSSA\n         MVI   SSSAIFLG,SSSANAUT   SET NON-AUTHORIZED CALLER IN WSSSA\n         MVI   SSSASFN+1,SSSAACTV  INDICATE ACT.CONFIG-SRVC. REQUESTED\n*                                  SSSA1* = SUBFUNCTION OF ACTIVE CONF.\n         MVI   SSSA1TYP,SSSA1CON   GET CONFIG-INFO, MAPPED BY IGDBCD\n         LH    R0,=Y(BCD_TOTAL_LENGTH)  LENGTH OF BASIC CONFIG-CB\n         ST    R0,SSSA1LEN         STORE IN WSSSA1\n         ST    R7,SSSA1PTR         STORE A(WAREA FOR SSSACON)\n         LA    R1,WSSOB            A(WSSOB) INTO R1\n         ST    R1,@WSSOB           STORE IN PARMLIST-ADDRESS\n         OI    @WSSOB,X'80'        SET HIGHORDERBIT\n         LA    R1,@WSSOB           A(PARMLIST-ADDRESS) INTO R1\n         IEFSSREQ                  ISSUE SMS-SSI-CALL\n         LTR   R15,R15             WENT IT OK ?\n         BNZ   CNFG0082            (BNZ=NO, SET APPROPRIATE ERROR-MSG)\n         ICM   R1,15,SSOBRETN      PICK UP SUBFUNCTION RETURNCODE\n         BZ    CNFG0020            (BZ=0, EVERYTHIN WORKED FINE)\n         CLC   SSSARSN,=A(SSSA1ISP)      INSUFFICIENT STORAGE PASSED ?\n         BNE   CNFG0082            (BNE=NO, OTHER ERROR, QUIT)\n         L     R1,WBCDSLEN         LOAD LENGTH OF 1ST GETMAINED AREA\n         STORAGE RELEASE,LENGTH=(R1),      FREE INSUFFICIENT WORKAREA  X\n               ADDR=(R7)\n         MVC   WBCDSLEN,SSSA1ALN   REQUESTED LENGTH OF WORKAREA (RETUR-\n*                                  NED BY 1ST IEFSSREQ-CALL\n         L     R1,WBCDSLEN         LOAD NEW LENGTH\n         STORAGE OBTAIN,LENGTH=(R1),       OBTAIN NEW WORKAREA FOR     X\n               LOC=ANY,BNDRY=PAGE,ADDR=(R7)    2ND SSI-CALL\n         MVC   SSSA1LEN,SSSA1ALN   SET NEW LENGTH IN IEFSSSA\n         ST    R7,SSSA1PTR         STORE A(WAREA FOR SSSACON)\n         LA    R1,@WSSOB           A(PARMLIST-ADDRESS) INTO R1\n         IEFSSREQ                  ISSUE SMS-SSI-CALL\n         ICM   R1,15,SSOBRETN      SUBFUNCTION RC NOW OKAY ?\n         BNZ   CNFG0082            (BNZ=NO, ANOTHER ERROR, EXIT)\nCNFG0020 DS    0H                  IEFSSREQ WORKED, R7 POINTS AT IGDBCD\n         USING IGDBCD,R7           TELL ASSEMBLER\n         LA    R2,BCDEND-IGDBCD(,R7)    BUMP OVER BASE DSECT\n         USING BCDSYSDT,R2         TELL ASSEMBLER (256 SYSTEM ENTRIES)\n         SLR   R1,R1               CLEAR WORKREG\n         LA    R5,300              LIMIT NUMBER SEARCHED FOR     SG\nCNFGLUP1 DS    0H                  LOOP: POSITION OF CURRENT SYSTEM\n         CLC   CURRSYS,BCDSSTAT    IS THIS THE CURRENT SYSTEM ?\n         BE    CNFG0070            (BE=YES, STORE FOR OFFSET VLD)\n         LA    R1,1(,R1)           ADD LENGTH OF 1 SYSTEM ENTRY\n         LA    R2,16(,R2)          A(NEXT SLOT IN SYSTEM ARRAY)\n         BCT   R5,CNFGLUP1         REDO LOOP\nCNFG0070 DS    0H                  CURRENT SYSTEM FOUND\n         STH   R1,SYSOFFST         STORE OFFSET TO CURRENT SYSTEM\n         DROP  R2                  DROP TEMPORARY BASE\n         B     CNFG0090            BUMP OVER ERROR-MESSAGES\nCNFG0080 DS    0H\n         LA    R9,ERR0010          IEFSSREQ FAILED\n         B     CNFG0090\nCNFG0082 DS    0H\n         LA    R9,ERR0020          SUBFUNCTION-CALL FAILED\nCNFG0090 DS    0H\n         L     R1,WBCDSLEN         LENGTH OF OBTAINED WORKAREA\n         STORAGE RELEASE,LENGTH=(R1),      FREE THE AREA               X\n               ADDR=(R7)\n         L     R14,SAVE14          LOAD BACKPOINTER\n         BR    R14                 BRANCH THERE\n         LTORG\n*\n*********************************************************************\n* GETSVOLI: BUILD A LIST OF ALL SMS-MG'ED VOLUMES\n*********************************************************************\n*\nGETSVOLI ST    R14,SAVE14          STORE BACKPOINTER\n         LH    R1,=Y(WVLD1ST)      LENGTH OF 1 VLD-ENTRY\n         ST    R1,WVLDLEN          STORE FOR STORAGE-RELEASE\n         STORAGE OBTAIN,LENGTH=(R1),            OBTAIN A RESULT-AREA   X\n               LOC=ANY,BNDRY=PAGE,ADDR=(R7)     FOR IEFSSREQ\n         L     R1,CVTPTR                        A(CVT) INTO R1\n         L     R1,CVTJESCT-CVT(,R1)             A(JESCT) INTO R1\n         L     R1,JESCTEXT-JESCT(,R1)           A(JESPEXT) INTO R1\n         ICM   R1,B'1111',JESSMSIB-JESPEXT(R1)  A(SMSSSIB) INTO R1\n         BZ    SVOL0080            (BZ=NO SMS-ENV. FOUND, EXIT)\n         XC    WSSOB,WSSOB         CLEAR WORK-SSOB\n         LA    R2,WSSOB            A(WORK SSOB)\n         USING SSOB,R2             TELL ASSEMBLER\n         ST    R1,SSOBSSIB         A(WORK-SSIB) INTO WORK-SSOB\n         MVC   SSOBID,=C'SSOB'     CB-ID INTO WORKAREA\n         MVI   SSOBFUNC+1,SSOBSSMS    FUNCTION-CODE FOR SMS (55)\n         MVI   SSOBLEN+1,SSOBHSIZ  LENGTH OF SSOB INTO WORK-SSOB\n         LA    R3,WSSSA            A(WORK FUNCTION DEPENDENT AREA)\n         ST    R3,SSOBINDV         STORE IN WORK-SSOB\n         USING IEFSSSA,R3          TELL ASSEMBLER\n         MVC   SSSAID,=C'SSSA'     CB-ID INTO WORKAREA\n         LA    R0,SSSALN+SSSA1LN   TOTAL LENGTH OF USED PARTS OF WSSSA\n         STH   R0,SSSALEN          STORE IN WSSSA\n         MVI   SSSAVER+1,SSOBSSVR  MOVE SSOB-VERSION INTO WSSSA\n         MVI   SSSAIFLG,SSSANAUT   SET NON-AUTHORIZED CALLER IN WSSSA\n         MVI   SSSASFN+1,SSSAACTV  INDICATE ACT.CONFIG-SRVC. REQUESTED\n*                                  SSSA1* = SUBFUNCTION OF ACTIVE CONF.\n         MVI   SSSA1TYP,SSSA1AVL   GET ALL VOLUMES, MAPPED BY IGDVLD\n         LH    R0,=Y(WVLD1ST)      LENGTH OF 1 IGDVLD-CB\n         ST    R0,SSSA1LEN         STORE IN WSSSA1\n         ST    R7,SSSA1PTR         STORE A(WAREA FOR SSSACON)\n         LA    R1,WSSOB            A(WSSOB) INTO R1\n         ST    R1,@WSSOB           STORE IN PARMLIST-ADDRESS\n         OI    @WSSOB,X'80'        SET HIGHORDERBIT\n         LA    R1,@WSSOB           A(PARMLIST-ADDRESS) INTO R1\n         IEFSSREQ                  ISSUE SMS-SSI-CALL\n         LTR   R15,R15             WENT IT OK ?\n         BNZ   SVOL0082            (BNZ=NO, SET APPROPRIATE ERROR-MSG)\n         ICM   R1,15,SSOBRETN      PICK UP SUBFUNCTION-RETURNCODE\n         BZ    SVOL0020            (BZ=ALL WORKED ANALYZE RESULT)\n         CLC   SSSARSN,=A(SSSA1ISP)    INSUFFICIENT STORAGE ?\n         BNE   SVOL0082            (BNE=NO, OTHER ERROR, QUIT)\n         L     R1,WVLDLEN          LENGTH OF 1ST STORAGE OBTAIN\n         STORAGE RELEASE,LENGTH=(R1),  RELEASE OBTAINED WORKAREA       X\n               ADDR=(R7)\n         MVC   WVLDLEN,SSSA1ALN    LENGTH NEEDED BY IEFSSREQ\n         L     R1,WVLDLEN          USE IT FOR 2ND STORAGE OBTAIN\n         STORAGE OBTAIN,LENGTH=(R1),       GET BIGGER WORKAREA         X\n               LOC=ANY,BNDRY=PAGE,ADDR=(R7)\n         MVC   SSSA1LEN,SSSA1ALN   SET NEW LENGTH IN IEFSSSA\n         ST    R7,SSSA1PTR         STORE A(WAREA FOR SSSACON)\n         LA    R1,@WSSOB           A(PARMLIST-ADDRESS) INTO R1\n         IEFSSREQ                  ISSUE SMS-SSI-CALL\n         ICM   R1,15,SSOBRETN      2ND CALL WORKED ?\n         BNZ   SVOL0082            (BNZ=NO, STILL ERRORS, QUIT)\nSVOL0020 DS    0H                  AFTER IEFSSREQ, R7=A(ANSWER-AREA)\n         LR    R3,R7               SAVE R7 FOR STORAGE RELEASE\n         USING IGDVLD,R3           TOP OF VOLSER-ARRAY RETURNED\n         L     R2,VLDPCNT          # OF VOLUME-ENTRIES RETURNED\n         L     R4,VLDPLEN          LENGTH OF A SINGLE ENTRY\nSVOLLUP0 DS    0H                  LOOP: WALK THROUGH SMS-VOLUMETABLE\n         TM    FLAGBYTE,REXXENV    CALLED AS A REXX-FUNCTION ?\n         BO    SVOL0022            (BO=YES, EXECUTE INTO ALLMSGS)\n         MVI   WORKREC,C' '        CLEAR OUT WORKREC (CURRENT LINE)\n         MVC   WORKREC+1(L'WORKREC-1),WORKREC       DO.\n         LA    R0,L'WORKREC        LENGTH OF WORKREC\n         STH   R0,0(R8)            STORE IN ALLMSGS\n         MVC   WORKREC(6),VLDVSER  MOVE VOLSER INTO WORKREC\n         B     SVOL0025            BUMP OVER EXECUTE FOR FUNCTIONCALL\nSVOL0022 DS    0H                  EXECUTE VOLSER INTO ALLMSGS\n         LH    R1,VLDVSLEN         LENGTH OF VOLSERNAME (SHOULD BE 6)\n         STH   R1,0(R8)            STORE LENGTH IN ALLMSGS\n         BCTR  R1,0                SUBTRACT 1 FOR EXECUTE\n         EX    R1,SVOLMVC1         WRITE INTO ALLMSGS\n         AR    R8,R1               BUMP BEHIND VOLSER +\n         AH    R8,=H'3'            ADD LENGTH-HW + 1 (EXECUTE)\nSVOL0025 DS    0H\n         LH    R1,VLDSGLEN         LENGTH OF STORAGE-GROUP INTO R1\n         BCTR  R1,0                SUBTRACT 1 FOR EXECUTE\n         TM    FLAGBYTE,REXXENV    CALLED AS A REXX-FUNCTION ?\n         BZ    SVOL0027            (BZ=NO, WRITE INTO WORKMSG)\n         EX    R1,SVOLMVC2         WRITE STORAGE-GROUP INTO ALLMSGS\n         LA    R1,1(,R1)           RE-INCREASE AFTER EXECUTE\n         STH   R1,0(R8)            STORE LENGTH IN ALLMSGS\n         AR    R8,R1               BUMP BEHIND STORAGEGROUP\n         AH    R8,=H'2'            ADD LENGTH OF LENGTH-HW\n         B     SVOL0028            BUMP OVER TSO-ONLY SECTION\nSVOL0027 DS    0H\n         EX    R1,SVOLMVC3         WRITE INTO WORKREC\n         MVC   WORKREC+36(4),=CL4'N/A '     ASSUME OFFLINE DEVICE\n         B     SVOL0029            BUMP OVER SVOL0028 (REXX-ENV.)\nSVOL0028 DS    0H\n         LA    R1,4                LENGTH OF DEVICE-NR\n         STH   R1,0(R8)            STORE IN ALLMSGS\n         MVC   2(4,R8),=CL4'N/A '     ASSUME UCB WILL BE OFFLINE\n         LA    R8,6(,R8)\nSVOL0029 DS    0H\n         ICM   R1,B'1111',VLDNUCBA    IS THIS REALLY TRUE?\n         BZ    SVOL0030            (BZ=YES, NO UCB FOUND, PROCEED)\n         LA    R1,UCBCHAN-UCBOB(R1)   A(UCBCHAN,4-DIGIT DEVICE,BINARY)\n         XC    WPACKED,WPACKED     CLEAR PACKED WORKFIELD\n         MVI   WPACKED+3,X'0C'     MOVE SIGN FOR UNPACK\n         MVO   WPACKED(3),0(2,R1)  MOVE DEVICE-NR. INTO BYTES 2+3\n         UNPK  WUNPACK,WPACKED     UNPACK IT INTO WORKAREA\n         TR    WUNPACK,TRTAB1      MAKE IT PRINTABLE\n         TM    FLAGBYTE,REXXENV    CALLED AS A REXX-FUNCTION ?\n         BO    SVOL0295            (BO=YES, WRITE INTO ALLMSGS)\n         MVC   WORKREC+36(4),WUNPACK+2   MOVE INTO WORKREC, FORGET SIGN\n         B     SVOL0030            BUMP OVER REXX-ENV\nSVOL0295 DS    0H\n         SH    R8,=H'6'            A(START OF DEVICE-ENTRY IN ALLMSGS)\n         MVC   2(4,R8),WUNPACK+2   MOVE INTO ALLMSGS, FORGET SIGN\n         LA    R8,6(,R8)           BUMP BEHIND N/A OR DEVICE-NR\nSVOL0030 DS    0H                  COMPUTE SMS-STATUS FOR CURRENT VOL.\n         LH    R15,SYSOFFST        OFFSET IN SYSTEM-ARRAY (FROM IGDBCD)\n         MH    R15,=H'8'           LENGTH OF ONE ENTRY IN ARRAY\n         LA    R1,VLDEND-VLD(,R3)  A(START OF SYSTEMS-ARRAY)\n         AR    R1,R15              A(CURRENT SYSTEM IN SYSTEMS-ARRAY)\n         USING VLDSYSDT,R1         TELL ASSEMBLER\n         SLR   R15,R15             CLEAR WORKREG\n         SLR   R14,R14             CLEAR WORKREG\n         IC    R15,VLDSTSMS        INSERT SMS-STATUS\n         IC    R14,VLDSTMVS        INSERT MVS-STATUS\n         MH    R15,=Y(TABSMSEL)    COMPUTE OFFSET IN STATUS-TABLE\n         A     R15,=A(TABSMSST)    ADD BASE OF TABLE\n         TM    FLAGBYTE,REXXENV    CALLED AS A REXX-FUNCTION ?\n         BZ    SVOL0035            (BZ=NO, WRITE INTO WORKREC)\n         LH    R1,=Y(TABSMSEL)     LENGTH OF A TABLE ENTRY INTO R1\n         STH   R1,0(R8)            STORE LENGTH IN ALLMSGS\n         MVC   2(TABSMSEL,R8),0(R15)  WRITE STATUS INTO WORKREC\n         LA    R8,TABSMSEL+2(,R8)  BUMP BEHIND TABLELENGTH/ENTRY\n         B     SVOL0040\nSVOL0035 DS    0H                  WRITE SMS-STATUS INTO WORKREC\n         MVC   WORKREC+42(TABSMSEL),0(R15)\nSVOL0040 DS    0H                  COMPUTE MVS-STATUS FOR CURRENT VOL.\n         BCTR  R14,0               (MVSTAB START WITH STATUS 1)\n         MH    R14,=Y(TABMVSEL)    COMPUTE OFFSET IN STATUS-TABLE\n         A     R14,=A(TABMVSST)    ADD BASE OF TABLE\n         TM    FLAGBYTE,REXXENV    CALLED AS A REXX-FUNCTION ?\n         BO    SVOL0045            (BZ=YES, WRITE INTO ALLMSGS)\n         MVC   WORKREC+60(TABMVSEL),0(R14)   WRITE STATUS INTO WORKREC\n         MVC   2(L'WORKREC,R8),WORKREC\n         LA    R8,L'WORKREC+2(,R8)\n         B     SVOL0050\nSVOL0045 DS    0H                  WRITE MVS-STATUS INTO ALLMSGS\n         LH    R1,=Y(TABMVSEL)     LENGTH OF A TABLE ENTRY INTO R1\n         STH   R1,0(R8)            STORE LENGTH IN ALLMSGS\n         MVC   2(TABMVSEL,R8),0(R14)  WRITE STATUS INTO WORKREC\n         LA    R8,TABMVSEL+2(,R8)  BUMP BEHIND TABLELENGTH/ENTRY\nSVOL0050 DS    0H                  LOAD ADDRESS OF NEXT ENTRY\n         AR    R3,R4               A(NEXT IGDVLD IN RETURNED ARRAY)\n         BCT   R2,SVOLLUP0         PERFORM WORK WITH NEXT VOLUME\n         B     SVOL0090            BUMP OVER ERROR-MESSAGES\nSVOL0080 DS    0H\n         LA    R9,ERR0010          NO SMS-ENVIRONMENT\n         B     SVOL0090\nSVOL0082 DS    0H\n         LA    R9,ERR0020          IEFSSREQ FAILED\nSVOL0090 DS    0H\n         L     R1,WVLDLEN          LENGTH OF OBTAINED WORKAREA\n         STORAGE RELEASE,LENGTH=(R1),                                  X\n               ADDR=(R7)\n*\n         L     R14,SAVE14          LOAD BACKPOINTER\n         BR    R14                 BRANCH THERE\n         LTORG\n*\n         USING IGDVLD,R3\nSVOLMVC1 MVC   2(0,R8),VLDVSER\nSVOLMVC2 MVC   2(0,R8),VLDSTGRP\nSVOLMVC3 MVC   WORKREC+10(0),VLDSTGRP\n*\n***********************************************************************\n*     PUTLBSNS: DO THE PUTLINE-BUSINESS                               *\n***********************************************************************\nPUTLBSNS ST    R14,SAVE14\n         TM    FLAGBYTE,REXXENV      CALLED AS A REXX-FUNCTION ?\n         BOR   R14                   (BO=YES, GET OUT OF HERE)\n         LA    R1,IOPLADS            LOAD DYNAMIC IOPL\n         USING IOPL,R1               FILL IT\n         L     R0,CPLUPT             LOAD DYN. USER'S PROFILE TABLE\n         ST    R0,IOPLUPT            STORE IT IN THE IOPL\n         L     R0,CPLECT             LOAD ADDRESS OF DYN. ECT\n         ST    R0,IOPLECT            STORE IT IN THE IOPL\n         LA    R0,ECBADS             LOAD ADDR OF MY ECB TO R3\n         ST    R0,IOPLECB            STORE ADDRESS OF ECBADS IN IOPL\n         MVC   @MLWAREA(L@PUTLIN),@PUTLIN\n         MVC   DTEXTADS(LTEXTADS),TEXTADS   MOVE CONSTANT TO MY AREA\n         LA    R2,ALLMSGS            POINT TO VARIABLE MSG-AREA\n         LTR   R9,R9                 IS THERE AN ERRORMESSAGE ?\n         BZ    PUTL010               (BZ=NO, WRITE DATA)\n         LR    R2,R9                 POINT TO CORRECT ERRORMSG\nPUTL010  DS    0H                    PREPARE FOR THE PUTLINE\n         XC    DTEXTADS(4),DTEXTADS  CLEAR LENGTH-COUNTER\n         LH    R1,0(R2)              LENGTH OF CURRENT ENTRY INTO R1\n         LTR   R1,R1                 IS IT ZERO ?\n         BZ    PUTL020               (BE = YES, ALL WRITTEN)\nPUTL015  LA    R1,4(,R1)             ADD 4 FOR PUTLINE-HEADER\n         STH   R1,DTEXTADS           STORE INTO WORKAREA\n         BCTR  R1,0                  SUBTRACT 1 FOR EXECUTE\n         EX    R1,PUTLMVC1           DO THE EXECUTE\n         PUTLINE PARM=@MLWAREA,      DO THE PUTLINE                    X\n               OUTPUT=(DTEXTADS,TERM,SINGLE,DATA),MF=(E,IOPLADS)\n         LH    R1,0(R2)              LOAD LENGTH OF MESSAGE\n         LA    R1,2(,R1)             ADD LENGTH OF MSG-LENGTH\n         AR    R2,R1                 ADD CORRECT LENGTH OF MSG-TEXT\n         B     PUTL010               TRY NEXT MESSAGE\nPUTL020  SLR   R15,R15\n         L     R14,SAVE14          LOAD BACKPOINTER\n         BR    R14                 BRANCH THERE\n         LTORG\n*\nPUTLMVC1 MVC   DTEXTADS+4(0),2(R2)\n*\n***********************************************************************\n*     REXXVARS: BUILD AN ARRAY OF REXX-VARAIBLES                      *\n***********************************************************************\nREXXVARS ST    R14,SAVE14          SAVE BACKPOINTER\n         TM    FLAGBYTE,REXXENV    CALLED AS A REXX-FUNCTION ?\n         BZR   R14                 (BZR=NO, DO NOT BUILD VARS)\n         LM    R2,R3,SAVEREXX      A(ENVBLOCK INTO R2, A(EFPL) INTO R3\n         USING EFPL,R3             TELL ASSEMBLER\n         L     R1,EFPLARG          A(ARGTABLE) INTO R1\n         CLC   =F'-1',0(R1)        NO ARGUMENT PASSED ?\n         BE    REXXER10            (BE=YES, SET APPROPRIATE ERRORMSG)\n         USING ARGTABLE_ENTRY,R1   TELL ASSEMBLER\n         XC    WSTEMNAM,WSTEMNAM   CLEAR SAVEAREA FOR STEMNAME\n         L     R14,ARGTABLE_ARGSTRING_LENGTH     L'PASSED STEMNAME\n         C     R14,=F'32'          LONGER THAN 32 CHARACTERS ?\n         BH    REXXER20            YES, SET ERROR-MESSAGE AND QUIT\n         STH   R14,WSTEMLEN        STORE LENGTH OF STEMNAME\n         L     R15,ARGTABLE_ARGSTRING_PTR     A(STEMNAME)\n         BCTR  R14,0               SUBTRACT 1 FOR EXECUTE\n         EX    R14,REXMVC00        WRITE STEMNAME INTO WSTEMNAM\n         EX    R14,REXUPR01        MAKE STEMNAME UPPERCASE\n         AR    R15,R14             A(END OF STEMNAME-1)\n         CLI   0(R15),C'.'         VALID STEMNAME PASSED ?\n         BNE   REXXER25            (BNE=NO, SET ERROR-MSG + QUIT)\n         CLC   =F'-1',ARGTABLE_NEXT    IS THIS THE END OF THE PARMLIST?\n         DROP  R1                  DROP ARGTABLE-BASE\n         BNE   REXXER30            (BNE=NO, MORE THAN 1 PARM, ERROR)\nREXX0100 DS    0H                  START BUILDING THE RESULT-ARRAY\n         L     R1,ENVBLOCK_IRXEXTE-ENVBLOCK(,R2)  A(IRXEXTE)\n         L     R1,IRXEXCOM-IRXEXTE(,R1)           A(IRXEXCOM)\n         ST    R1,@WRXCOM          STORE A(IRXEXCOM) IN WORKFIELD\n         LA    R0,IRXCOM           A(8 BYTE CONSTANT \"IRXEXCOM\")\n         ST    R0,@WRXCNST         STORE IN IRXEXCOM-PARMLIST\n         XC    @WRXPRM2,@WRXPRM2   CLEAR PARAMETER #2 AND ...\n         XC    @WRXPRM3,@WRXPRM3   ... PARM #3 IN IRXEXCOM-PARMLIST\n         XC    WRXSHVL,WRXSHVL     CLEAR OUT WORK-SHVBLOCK\n         LA    R4,WRXSHVL          A(WORK-SHVBLOCK)\n         ST    R4,@WRXSHVL         STORE IN IRXEXCOM-PARMLIST\n         OI    @WRXSHVL,X'80'      SET HIGHORDERBIT IN LAST PARM\n         USING SHVBLOCK,R4         FILL WORK-SHVBLOCK\n         MVI   SHVCODE,SHVSTORE    FUNCTION-CODE: DEFINE NEW VARIABLE\n         LA    R8,ALLMSGS          A(ALL VALUES + LENGTHS\n         SLR   R2,R2               CLEAR OUT ELEMENT-COUNTER\n         ST    R2,CURRELEM         STORE IT\nREXXLUP0 DS    0H                  OUTMOST LOOP: 1/PER 3RD ARRAY-DIM.\n         L     R2,CURRELEM         LOAD ELEMENT-NUMBER\n         LA    R2,1(,R2)           INCREASE FOR NEW ARRAY-ELEMENTS\n         ST    R2,CURRELEM         STORE IT AGAIN\n         PRINTREG (R2),RESULT=DECIMAL,PADCHAR=NULLSTRING\n         STH   R0,WELEMLEN         LENGTH OF CURRENT NUMERIC\n         MVI   WELEMENT,C'.'       START WITH A DOT\n         LH    R2,WELEMLEN         LENGTH OF NUMERIC PART INTO R2\n         BCTR  R2,0                SUBTRACT 1 FOR EXECUTE\n         EX    R2,REXMVC01         WRITE ELEMENT NUMBER INTO WORKFIELD\n         LA    R2,2(,R2)           RELOAD ORIG. LENGTH, ADD 1 FOR DOT\n         STH   R2,WELEMLEN         TOTAL LENGTH OF '.' + CURR. NUMERIC\n         LA    R5,5                #OF VARIABLES PER ELEMENT\n         LA    R2,VARTAB           A(2ND VARIABLE-QUALIFIERS)\nREXXLUP1 DS    0H                  INNER LOOP: 1 FOR EVERY VAR/ELEMENT\n         XC    WVARNAME,WVARNAME   CLEAR OUT CURRENT VARIABLE-NAME\n         LH    R15,WSTEMLEN        LENGTH OF STEMNAME INTO R15\n         STH   R15,WVARLEN         STORE IN VARLENGTH-FIELD\n         BCTR  R15,0               SUBTRACT 1 FOR EXECUTE\n         EX    R15,REXMVC02        WRITE STEMNAME INTO CURRENT VAR.\n         LH    R15,WVARLEN         RELOAD ORIGINAL LENGTH\n         LA    R0,WVARNAME         A(START OF VARIABLE-NAME)\n         AR    R15,R0              A(END OF STEMNAME)\n         TM    FLAGBYTE,STEMDONE   JUST ZERO-ELEMENT REMAINING ?\n         BZ    REXX0200            (BZ=NO, PROCEED)\n         MVI   0(R15),C'0'         WRITE ZERO-ELEMENT\n         LA    R1,WVARNAME         A(STEM.0)\n         ST    R1,SHVNAMA          STORE IN WORK-SHVBLOCK\n         LH    R1,WVARLEN          IF LAST CALL, LENGTH IS COUNTER-DOT\n         LA    R1,1(,R1)           ADD LENGTH OF '0'\n         ST    R1,SHVNAML          STORE IN WORK-SHVBLOCK\n         LA    R1,WELEMENT+1       A(COUNTER BEHIND DOT)\n         ST    R1,SHVVALA          STORE IN WORK-SHVBLOCK\n         LH    R1,WELEMLEN         LENGTH OF NUMERIC PART + DOT\n         BCTR  R1,0                SUBTRACT LENGTH OF DOT\n         ST    R1,SHVVALL          STORE IN WORK-SHVBLOCK\n         B     REXX0300            ISSUE LAST IRXEXCOM-CALL\nREXX0200 DS    0H\n         SLR   R1,R1               CLEAR WORKREG\n         IC    R1,0(R2)            LENGTH OF 2ND DIMENSION\n         BCTR  R1,0                SUBTRACT 1 FOR EXECUTE\n         EX    R1,REXMVC03         WRITE 2ND DIMENSION THEREAFTER\n         LA    R1,1(,R1)           RELOAD ORIGINAL LENGTH\n         LH    R0,WVARLEN          LOAD LENGTH UNTIL NOW\n         AR    R0,R1               ADD LENGTH OF 2ND DIMENSION\n         STH   R0,WVARLEN          STORE NEW LENGTH\n         LA    R15,WVARNAME        A(START OF VARIABLE-NAME)\n         AH    R15,WVARLEN         A(END OF VARIABLE-NAME)\n         LH    R1,WELEMLEN         LENGTH OF DOT + NUMERIC APPENDIX\n         BCTR  R1,0                SUBTRACT 1 FOR EXECUTE\n         EX    R1,REXMVC04         WRITE AT END OF CURRENT STEM\n         LA    R1,1(,R1)           RELOAD ORIGINAL LENTGH\n         LH    R0,WVARLEN          LOAD LENGTH W/O NUMERIC APPENDIX\n         AR    R0,R1               ADD LENGTH OF APPENDIX\n         STH   R0,WVARLEN          STORE TOTAL LENGTH OF VARIABLE\n         LA    R0,WVARNAME         A(VARIABLE NAME)\n         ST    R0,SHVNAMA          STORE IN WORK-SHVBLOCK\n         LH    R0,WVARLEN          LENGTH OF VARIABLE\n         ST    R0,SHVNAML          STORE IN WORK-SHVBLOCK\n         LH    R0,0(R8)            LOAD LENTGTH OF VALUE\n         ST    R0,SHVVALL          STORE IN WORK-SHVBLOCK\n         LA    R0,2(,R8)           LOAD ADDRESS OF NEXT VALUE\n         ST    R0,SHVVALA          STORE IN WORK-SHVBLOCK\nREXX0300 DS    0H\n         SLR   R0,R0               CLEAR A(OPTIONAL ENV_BLOCK)\n         LA    R1,WRXCOMPL         A(IRXEXCOM PARAMETER LIST)\n         L     R15,@WRXCOM         A(IRXEXCOM)\n         BALR  R14,R15             FIRE ||||\n         LTR   R15,R15             WAS CALL SUCCESSFULL ?\n         BNZ   REXXER40            BNZ=NO, ISSUE ERROR-MESSAGE\n         TM    FLAGBYTE,STEMDONE   ZERO-ELEMENT ALREADY WRITTEN ?\n         BO    REXXOK10            (BO=YES, ALL DONE LEAVE NOW)\n         SLR   R1,R1               CLEAR WORKREG\n         IC    R1,0(R2)            LENGTH OF 2ND VARIABLE-QUALIFIER\n         LA    R2,1(,R2)           POINT BEHIND LENGTH FIELD\n         AR    R2,R1               A(NEXT 2ND VARAIBLE-QUALIFIER)\n         LH    R0,0(R8)            LENGTH OF RECENTLY RETURNED VALUE\n         LA    R8,2(,R8)           BUMP OVER LENGTH FIELD IN ALLMSGS\n         AR    R8,R0               A(NEXT VALUE IN ALLMSGS)\nREXXOK10 DS    0H\n         L     R1,EFPLEVAL         A(EVALBLOCK-ADDRESS)\n         L     R1,0(,R1)           A(EVALBLOCK)\n         USING EVALBLOCK,R1        TELL ASSEMBLER\n         LA    R0,1                LENGTH OF RC=0\n         ST    R0,EVALBLOCK_EVLEN         STORE IN EVALBLOCK\n         MVI   EVALBLOCK_EVDATA,C'0'      SET RC=0\n         SLR   R0,R0               SET RC=0 TO SHOW ERROR-MSG IN REXX\n         ST    R0,RCODE            STORE IN RCODE\n         DROP  R1                  DROP TEMPORARY BASE\n         TM    FLAGBYTE,STEMDONE   ZERO-ELEMENT ALREADY WRITTEN ?\n         BO    REXX0900            (BO=YES, ALL DONE LEAVE NOW)\n         BCT   R5,REXXLUP1         WRITE NEXT PART OF CURRENT ELEMENT\n         LH    R1,0(R8)            STILL VARIABLES TO BUILD ?\n         LTR   R1,R1               TEST WHETHER LENGTH OF NEXT = 0\n         BNZ   REXXLUP0            (BNZ=NO, STILL ELEMENTS, CONTINTUE)\n         OI    FLAGBYTE,STEMDONE   INDICATE VERY LAST CALL\n         B     REXXLUP1            WRITE ZERO-ELEMENT\nREXXER10 DS    0H                  ERROR-SCENARIO 1: NO PARMS PASSED\n         L     R1,EFPLEVAL         A(EVALBLOCK-ADDRESS)\n         L     R1,0(,R1)           A(EVALBLOCK)\n         USING EVALBLOCK,R1        TELL ASSEMBLER\n         LA    R0,L'RXMSG010       LENGTH OF ERROR-MESSAGE\n         ST    R0,EVALBLOCK_EVLEN         STORE IN EVALBLOCK\n         MVC   EVALBLOCK_EVDATA(L'RXMSG010),RXMSG010    ERROR-MSG\n         SLR   R0,R0               SET RC=0 TO SHOW ERROR-MSG IN REXX\n         ST    R0,RCODE            STORE IN RCODE\n         DROP  R1                  DROP TEMPORARY BASE\n         B     REXX0900            BUMP AT THE END OF SUBROUTINE\nREXXER20 DS    0H                  ERROR-SCENARIO 2: STEM LONGER 32CH.\n         L     R1,EFPLEVAL         A(EVALBLOCK-ADDRESS)\n         L     R1,0(,R1)           A(EVALBLOCK)\n         USING EVALBLOCK,R1        TELL ASSEMBLER\n         LA    R0,L'RXMSG020       LENGTH OF ERROR-MESSAGE\n         ST    R0,EVALBLOCK_EVLEN         STORE IN EVALBLOCK\n         MVC   EVALBLOCK_EVDATA(L'RXMSG020),RXMSG020    ERROR-MSG\n         SLR   R0,R0               SET RC=0 TO SHOW ERROR-MSG IN REXX\n         ST    R0,RCODE            STORE IN RCODE\n         DROP  R1                  DROP TEMPORARY BASE\n         B     REXX0900            BUMP AT THE END OF SUBROUTINE\nREXXER25 DS    0H                  ERROR-SCENARIO 25 STEM LONGER 32CH.\n         L     R1,EFPLEVAL         A(EVALBLOCK-ADDRESS)\n         L     R1,0(,R1)           A(EVALBLOCK)\n         USING EVALBLOCK,R1        TELL ASSEMBLER\n         LA    R0,L'RXMSG025       LENGTH OF ERROR-MESSAGE\n         ST    R0,EVALBLOCK_EVLEN         STORE IN EVALBLOCK\n         MVC   EVALBLOCK_EVDATA(L'RXMSG025),RXMSG025    ERROR-MSG\n         SLR   R0,R0               SET RC=0 TO SHOW ERROR-MSG IN REXX\n         ST    R0,RCODE            STORE IN RCODE\n         DROP  R1                  DROP TEMPORARY BASE\n         B     REXX0900            BUMP AT THE END OF SUBROUTINE\nREXXER30 DS    0H                  ERROR-SCENARIO 3: MORE THAN 1 PARM.\n         L     R1,EFPLEVAL         A(EVALBLOCK-ADDRESS)\n         L     R1,0(,R1)           A(EVALBLOCK)\n         USING EVALBLOCK,R1        TELL ASSEMBLER\n         LA    R0,L'RXMSG030       LENGTH OF ERROR-MESSAGE\n         ST    R0,EVALBLOCK_EVLEN         STORE IN EVALBLOCK\n         MVC   EVALBLOCK_EVDATA(L'RXMSG030),RXMSG030    ERROR-MSG\n         SLR   R0,R0               SET RC=0 TO SHOW ERROR-MSG IN REXX\n         ST    R0,RCODE            STORE IN RCODE\n         DROP  R1                  DROP TEMPORARY BASE\n         B     REXX0900            BUMP AT THE END OF SUBROUTINE\nREXXER40 DS    0H                  ERROR-SCENARIO 3: MORE THAN 1 PARM.\n         L     R1,EFPLEVAL         A(EVALBLOCK-ADDRESS)\n         L     R1,0(,R1)           A(EVALBLOCK)\n         USING EVALBLOCK,R1        TELL ASSEMBLER\n         LA    R0,L'RXMSG040       LENGTH OF ERROR-MESSAGE\n         ST    R0,EVALBLOCK_EVLEN         STORE IN EVALBLOCK\n         MVC   EVALBLOCK_EVDATA(L'RXMSG040),RXMSG040    ERROR-MSG\n         SLR   R0,R0               SET RC=0 TO SHOW ERROR-MSG IN REXX\n         ST    R0,RCODE            STORE IN RCODE\n         DROP  R1                  DROP TEMPORARY BASE\n         B     REXX0900            BUMP AT THE END OF SUBROUTINE\nREXX0900 DS    0H\n         L     R14,SAVE14           LOAD BACKPOINTER\n         BR    R14                 BRANCH THERE\n*\nREXMVC00 MVC   WSTEMNAM(0),0(R15)       SAVE PASSED STEMNAME\nREXUPR01 OC    WSTEMNAM(0),=32C' '      MAKE PASSED PARM UPPERCASE\nREXMVC01 MVC   WELEMENT+1(0),0(R1)      NUMERIC PART OF VARIABLE\nREXMVC02 MVC   WVARNAME(0),WSTEMNAM     BUILD NEW VARIABLE-NAME\nREXMVC03 MVC   0(0,R15),1(R2)           BUILD NEW VARIABLE-NAME\nREXMVC04 MVC   0(0,R15),WELEMENT        DOT + NUMERIC AT END OF VAR\n*\n         LTORG\n***********************************************************************\n*     CONSTANTS                                                       *\n***********************************************************************\n*\nTEXTADS  DC    H'132'\n         DC    CL132' '\n         DC    H'0'\nLTEXTADS EQU   *-TEXTADS\n*\nTABSMSST DC    CL12'N/A'\nTABSMSEL EQU   *-TABSMSST\n         DC    CL12'ENABLED'\n         DC    CL12'QUIESCED/ALL'\n         DC    CL12'QUIESCED/NEW'\n         DC    CL12'DISABLED/ALL'\n         DC    CL12'DISABLED/NEW'\n*\nTABMVSST DC    CL7'ONLINE'\nTABMVSEL EQU   *-TABMVSST\n         DC    CL7'OFFLINE'\n         DC    CL7'OFF-PND'\n         DC    CL7'BOXED'\n         DC    CL7'NOT-RDY'\n*\nVARTAB   DC    X'07',C'VOL_SER'\n         DC    X'08',C'STOR_GRP'\n         DC    X'06',C'DEV_NR'\n         DC    X'08',C'SMS_STAT'\n         DC    X'08',C'MVS_STAT'\n*\nIRXCOM   DC    CL8'IRXEXCOM'\n*\nRXMSG010 DC    C'8 REQUIRED PARAMETER STEMNAME OMITTED.'\nRXMSG020 DC    C'8 STEMNAME MUST NOT EXCEED 32 CHARACTERS IN LENGTH.'\nRXMSG025 DC    C'8 INVALID STEMNAME PASSED. MUST END WITH PERIOD (.)'\nRXMSG030 DC    C'8 QSMS ACCEPTS JUST 1 PARAMETER (STEMNAME).'\nRXMSG040 DC    C'8 IRXEXCOM CALL FAILED.'\n*\nERR0010  DC    H'78'\n         DC    CL78'QSMS010E NO ACTIVE SMS-ENVIRONMENT FOUND. NO  ACTIOX\n               N TAKEN. PROGRAM TERMINATES'\n         DC    H'0'\nERR0020  DC    H'78'\n         DC    CL78'QSMS020E SMS-SUBSYSTEM INTERFACE CALL FAILED. NO  AX\n               CTION TAKEN. PGM TERMINATES'\n         DC    H'0'\n*\nTRTAB1   EQU   *-240\n         DC    C'0123456789ABCDEF'\n         ORG\n*\n***********************************************************************\n*     MACRO LIST-FORM                                                 *\n***********************************************************************\n*\n@PUTLIN  PUTLINE MF=L\nL@PUTLIN EQU    *-@PUTLIN\n*\nLIOCINFO IOCINFO MF=(L,MTOKEN)\nLLIOCINF EQU   *-LIOCINFO\n*\n         UCBSCAN MF=(L,MSCANWRK)\nLLUCBSCA EQU   *-MSCANWRK\n*\n         EJECT\n*\n***********************************************************************\n*     WORKING SECTION                                                 *\n***********************************************************************\n*\nDWORK    DSECT\n@MLWAREA DS    XL256                  MF=L WORKAREA\n@UCBSCAN DS    XL256                  MF=L WORKAREA\n*\nFLAGBYTE DS    X\nREXXENV  EQU   X'80'\nSTEMDONE EQU   X'40'\n*\nSAVEREXX DS    2F\nWSTEMNAM DS    CL32\nWSTEMLEN DS    H\nWVARNAME DS    CL48\nWVARLEN  DS    H\nWELEMENT DS    CL8\nWELEMLEN DS    H\nCURRELEM DS    F\n@WRXCOM  DS    F\n*\n         DS    0D\nWRXCOMPL DS    0XL16\n@WRXCNST DS    F\n@WRXPRM2 DS    F\n@WRXPRM3 DS    F\n@WRXSHVL DS    F\n         DS    0D\nWRXSHVL  DS    XL(SHVBLEN)\n*\nCPLCBUF  DS    F                      CPPL-WORKFIELDS\nCPLUPT   DS    F\nCPLPSCB  DS    F\nCPLECT   DS    F\n*\nECBADS   DS    F                      PUTLINE WORKFIELDS\nIOPLADS  DS    4F\n*\nDTEXTADS DS    CL(LTEXTADS)           MSG-WORKFIELD\n*\nDEVWORD  DS    CL4\nUCBCOPY  DS    CL48\nSCANWRK  DS    CL100\nTOKEN    DS    CL48\nCURVOL   DS    CL6\n*\nWPACKED  DS    PL4\nWUNPACK  DS    CL8\nWBCDSLEN DS    F\nCURRSYS  DS    CL8\nSYSOFFST DS    H\n@VLD     DS    F\nWVLDLEN  DS    F\n*\nWORKREC  DS    CL80\nSAVE14   DS    F\n@ERRMSG  DS    F\nRCODE    DS    F\n*\n@WSSOB   DS    F\n         DS    0D\nWSSOB    DS    XL(SSOBHSIZ)\n         DS    0D\nWSSSA    DS    XL(SSSALN+SSSA1LN)\n         DS    0D\nWVLD1ST  EQU   ((VLDEND-VLD)+(VLDEND2-VLDSYSDT))\nALLMSGS  DS    400CL32000\nLDWORK   EQU   *-DWORK\n*\n         PRINT GEN\n         IGDVLD\n         IGDBCD\n         PRINT NOGEN\n         CVT   DSECT=YES\n         IEFJESCT\n         IEFSSSA\n         IEFJSSIB\n         IEFSSOBH\n         IKJCPPL\n         IKJIOPL\n         IEFUCBOB\n         IRXEFPL\n         IRXEVALB\n         IRXENVB\n         IRXARGTB\n         IRXEXTE\n         IRXSHVB\n         END   QSMS\n/*\n//SYSLIB    DD DISP=SHR,DSN=IBMUSER.CBT497.FILE483    <== THIS PDS\n//          DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSLIN    DD DSN=&&OBJ,UNIT=SYSDA,DISP=(NEW,PASS),\n//          SPACE=(3200,(200,50)),DCB=(RECFM=FB,BLKSIZE=3200,LRECL=80)\n//SYSPRINT  DD SYSOUT=*,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=3990)\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//*\n//* =====================================================\n//* ===== L I N K A G E   E D I T O R ===================\n//* =====================================================\n//LKED      EXEC PGM=HEWL,REGION=1024K,COND=(0,NE),\n//          PARM='XREF,LIST,RENT,REUS'\n//SYSLMOD   DD DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(10,3))\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD DSN=&&OBJ,DISP=(OLD,DELETE)\n//          DD *\n  NAME    QSMS(R)\n/*\n//TESTRC IF (RC EQ 0) THEN\n//SCHTEPP3   EXEC PGM=IKJEFT01,REGION=0M\n//STEPLIB  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSPROC  DD  DISP=SHR,DSN=SYS1.U.CLIST\n//SYSPRINT DD  SYSOUT=*\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  *\n  QSMSREXX\n  QSMS\n//ENDTEST ENDIF\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QSMSREXX": {"ttr": 3588, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x00\\x08\\x00\\x08\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "TRAMSEI"}, "text": "/* Rexx */\nRc = Qsms('smsvol.')\nDo i = 1 to smsvol.0\n  Say smsvol.vol_ser.i smsvol.stor_grp.i smsvol.dev_nr.i ,\n      smsvol.sms_stat.i smsvol.mvs_stat.i\nEnd\nSay smsvol.0 'Dasds mapped. Highest Rc was 'Rc'.'\nExit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QSMS00": {"ttr": 3590, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00&O\\x08)\\x03 \\x03 \\x00\\x00\\xd6\\xd3\\xc4@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-20T08:29:00", "lines": 800, "newlines": 800, "modlines": 0, "user": "OLD"}, "text": "//T750KQ   JOB (317,04,E150AQ),'RAMSEIER',\n//             MSGLEVEL=(1,1),\n//             CLASS=X,\n//             MSGCLASS=T,\n//             NOTIFY=&SYSUID,\n//             TIME=NOLIMIT\n//*MAIN SYSTEM=SYT\n//*\n//ASM      EXEC PGM=ASMA90,REGION=2048K,\n//          PARM='NODECK,OBJECT,USING(NOWARN),RENT'\n//SYSIN     DD *\nQSMS TITLE '*** \"QSMS \" *** &SYSDATE'\n***********************************************************************\n*                                                                     *\n*     QSMS - READS SMS-CONFIG AND CHECKS MVS-STATUS OF DEFINED VOLS   *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*     EQUATES                                                         *\n***********************************************************************\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n***********************************************************************\n*     START                                                           *\n***********************************************************************\nQSMS     CSECT\nQSMS     AMODE 31\nQSMS     RMODE ANY\n         PRINT NOGEN\n         SPACE 2\n         BAKR  14,0                ESTABLISH LINKAGE-CONVENTIONS\n         LR    R12,R15             ADDRESSABILITY\n         USING QSMS,R12            TELL ASSEMBLER\n         LR    R2,R0               A(ENVBLOCK IF CALLED FROM A REXX)\n         LR    R3,R1               ESTABLISH CPPL'S  ADDRESSABILITY\nGETSTOR  DS    0H                  OBTAIN REENTRANT WORKSPACE\n         STORAGE OBTAIN,LENGTH=LDWORK,LOC=ANY\n         LR    R11,R1              ESTABLISH DSECT'S ADDRESSABILITY\n         USING DWORK,R11           TELL ASSEMBLER\n         BAL   R14,CHKENVIR        EVALUATE CALLERS ENVIRONMENT\n         BAL   R14,GETCONFG        CALL SMS VIA SSI TO GET SMS-CONFIG\n         BAL   R14,GETSVOLI        BUILD A LIST OF ALL SMS-VOLUMES\n         BAL   R14,PUTLBSNS        ISSUE PUTLINE (IF TSO-COMMAND)\n         BAL   R14,REXXVARS        BUILD REXX-VARS(IF REXX-FUNCTION)\n*\n         L     R2,RCODE\n         STORAGE RELEASE,LENGTH=LDWORK,ADDR=(R11)  FREE OBTAINED STOR.\n         LR    R15,R2\n         PR                        END QSMS + CLEANUP\n         LTORG\n*\n***********************************************************************\n*     SUBROUTINES                                                     *\n***********************************************************************\n*\n*********************************************************************\n* CHECK CALLERS ENVIRONMENT\n*********************************************************************\n*\nCHKENVIR ST    R14,SAVE14\n         OI    FLAGBYTE,REXXENV      ASSUME RUNNING IN REXX-ENVT.\n         CLC   =C'ENVBLOCK',0(R2)    ENVIRONMENT BLOCK FOUND ?\n         BE    ENV0030               (BE=YES, BUMP OVER CPPL-SECTION)\n         USING CPPL,R3               GET THE ADDRESSES IN CPPL\n         MVC   CPLCBUF,CPPLCBUF      MOVE COMM.-BUFFER ADDR TO MY AREA\n         MVC   CPLUPT,CPPLUPT        MOVE USERPROFTAB ADDR TO MY AREA\n         MVC   CPLPSCB,CPPLPSCB      MOVE PROT.STEP-CB ADDR TO MY AREA\n         MVC   CPLECT,CPPLECT        MOVE ECT-ADDRESS TO MY AREA\n         DROP  R3                    FREE CPPL\n         NI    FLAGBYTE,255-REXXENV  RESET FLAGBYTE\n         B     ENV0090\nENV0030  DS    0H\n*        OI    FLAGBYTE,REXXENV      CALLED AS REXX-FUNCTION, SET FLAG\n         STM   R2,R3,SAVEREXX        SAVE ADDRESSES FOR LATER USE\nENV0090  DS    0H\n         LA    R8,ALLMSGS            A(ANSWER-AREA)\n         SLR   R9,R9                 A(ERROR-MSG)\n         L     R14,SAVE14\n         BR    R14\n         LTORG\n*\n*********************************************************************\n* GETCONFG: PICK ACTUAL SMS-CONFIG VIA THE SUBSYSTEM INTERFACE\n*********************************************************************\n*\nGETCONFG ST    R14,SAVE14          STORE BACKPOINTER\n         LH    R1,=Y(BCD_TOTAL_LENGTH)\n         ST    R1,WBCDSLEN\n         STORAGE OBTAIN,LENGTH=(R1),                                   X\n               LOC=ANY,BNDRY=PAGE,ADDR=(R7)\n         L     R1,CVTPTR                        A(CVT) INTO R1\n         MVC   CURRSYS(8),CVTSNAME-CVT(R1)\n         L     R1,CVTJESCT-CVT(,R1)             A(JESCT) INTO R1\n         L     R1,JESCTEXT-JESCT(,R1)           A(JESPEXT) INTO R1\n         ICM   R1,B'1111',JESSMSIB-JESPEXT(R1)  A(SMS-SSIB) INTO R2\n         BZ    CNFG0080            (BZ=NO SMS-ENV. FOUND, EXIT)\n         XC    WSSOB,WSSOB         CLEAR WORK-SSOB\n         LA    R2,WSSOB            A(WORK SSOB)\n         USING SSOB,R2             TELL ASSEMBLER\n         ST    R1,SSOBSSIB         A(WORK-SSIB) INTO WORK-SSOB\n         MVC   SSOBID,=C'SSOB'     CB-ID INTO WORKAREA\n         MVI   SSOBFUNC+1,SSOBSSMS    FUNCTION-CODE FOR SMS (55)\n         MVI   SSOBLEN+1,SSOBHSIZ  LENGTH OF SSOB INTO WORK-SSOB\n         LA    R3,WSSSA            A(WORK FUNCTION DEPENDENT AREA)\n         ST    R3,SSOBINDV         STORE IN WORK-SSOB\n         USING IEFSSSA,R3          TELL ASSEMBLER\n         MVC   SSSAID,=C'SSSA'     CB-ID INTO WORKAREA\n         LA    R0,SSSALN+SSSA1LN   TOTAL LENGTH OF USED PARTS OF WSSSA\n         STH   R0,SSSALEN          STORE IN WSSSA\n         MVI   SSSAVER+1,SSOBSSVR  MOVE SSOB-VERSION INTO WSSSA\n         MVI   SSSAIFLG,SSSANAUT   SET NON-AUTHORIZED CALLER IN WSSSA\n         MVI   SSSASFN+1,SSSAACTV  INDICATE ACT.CONFIG-SRVC. REQUESTED\n*                                  SSSA1* = SUBFUNCTION OF ACTIVE CONF.\n         MVI   SSSA1TYP,SSSA1CON   GET CONFIG-INFO, MAPPED BY IGDBCD\n         LH    R0,=Y(BCD_TOTAL_LENGTH)  LENGTH OF BASIC CONFIG-CB\n         ST    R0,SSSA1LEN         STORE IN WSSSA1\n         ST    R7,SSSA1PTR         STORE A(WAREA FOR SSSACON)\n         LA    R1,WSSOB            A(WSSOB) INTO R1\n         ST    R1,@WSSOB           STORE IN PARMLIST-ADDRESS\n         OI    @WSSOB,X'80'        SET HIGHORDERBIT\n         LA    R1,@WSSOB           A(PARMLIST-ADDRESS) INTO R1\n         IEFSSREQ                  ISSUE SMS-SSI-CALL\n         LTR   R15,R15             WENT IT OK ?\n         BNZ   CNFG0082            (BNZ=NO, SET APPROPRIATE ERROR-MSG)\n         ICM   R1,15,SSOBRETN      PICK UP SUBFUNCTION RETURNCODE\n         BZ    CNFG0020            (BZ=0, EVERYTHIN WORKED FINE)\n         CLC   SSSARSN,=A(SSSA1ISP)      INSUFFICIENT STORAGE PASSED ?\n         BNE   CNFG0082            (BNE=NO, OTHER ERROR, QUIT)\n         L     R1,WBCDSLEN         LOAD LENGTH OF 1ST GETMAINED AREA\n         STORAGE RELEASE,LENGTH=(R1),      FREE INSUFFICIENT WORKAREA  X\n               ADDR=(R7)\n         MVC   WBCDSLEN,SSSA1ALN   REQUESTED LENGTH OF WORKAREA (RETUR-\n*                                  NED BY 1ST IEFSSREQ-CALL\n         L     R1,WBCDSLEN         LOAD NEW LENGTH\n         STORAGE OBTAIN,LENGTH=(R1),       OBTAIN NEW WORKAREA FOR     X\n               LOC=ANY,BNDRY=PAGE,ADDR=(R7)    2ND SSI-CALL\n         MVC   SSSA1LEN,SSSA1ALN   SET NEW LENGTH IN IEFSSSA\n         ST    R7,SSSA1PTR         STORE A(WAREA FOR SSSACON)\n         LA    R1,@WSSOB           A(PARMLIST-ADDRESS) INTO R1\n         IEFSSREQ                  ISSUE SMS-SSI-CALL\n         ICM   R1,15,SSOBRETN      SUBFUNCTION RC NOW OKAY ?\n         BNZ   CNFG0082            (BNZ=NO, ANOTHER ERROR, EXIT)\nCNFG0020 DS    0H                  IEFSSREQ WORKED, R7 POINTS AT IGDBCD\n         USING IGDBCD,R7           TELL ASSEMBLER\n         LA    R2,BCDEND-IGDBCD(,R7)    BUMP OVER BASE DSECT\n         USING BCDSYSDT,R2         TELL ASSEMBLER (256 SYSTEM ENTRIES)\n         SLR   R1,R1               CLEAR WORKREG\nCNFGLUP1 DS    0H                  LOOP: POSITION OF CURRENT SYSTEM\n         CLC   CURRSYS,BCDSSTAT    IS THIS THE CURRENT SYSTEM ?\n         BE    CNFG0070            (BE=YES, STORE FOR OFFSET VLD)\n         LA    R1,1(,R1)           ADD LENGTH OF 1 SYSTEM ENTRY\n         LA    R2,16(,R2)          A(NEXT SLOT IN SYSTEM ARRAY)\n         B     CNFGLUP1            REDO LOOP\nCNFG0070 DS    0H                  CURRENT SYSTEM FOND\n         STH   R1,SYSOFFST         STORE OFFSET TO CURRENT SYSTEM\n         DROP  R2                  DROP TEMPORARY BASE\n         B     CNFG0090            BUMP OVER ERROR-MESSAGES\nCNFG0080 DS    0H\n         LA    R9,ERR0010          IEFSSREQ FAILED\n         B     CNFG0090\nCNFG0082 DS    0H\n         LA    R9,ERR0020          SUBFUNCTION-CALL FAILED\nCNFG0090 DS    0H\n         L     R1,WBCDSLEN         LENGTH OF OBTAINED WORKAREA\n         STORAGE RELEASE,LENGTH=(R1),      FREE THE AREA               X\n               ADDR=(R7)\n         L     R14,SAVE14          LOAD BACKPOINTER\n         BR    R14                 BRANCH THERE\n         LTORG\n*\n*********************************************************************\n* GETSVOLI: BUILD A LIST OF ALL SMS-MG'ED VOLUMES\n*********************************************************************\n*\nGETSVOLI ST    R14,SAVE14          STORE BACKPOINTER\n         LH    R1,=Y(WVLD1ST)      LENGTH OF 1 VLD-ENTRY\n         ST    R1,WVLDLEN          STORE FOR STORAGE-RELEASE\n         STORAGE OBTAIN,LENGTH=(R1),            OBTAIN A RESULT-AREA   X\n               LOC=ANY,BNDRY=PAGE,ADDR=(R7)     FOR IEFSSREQ\n         L     R1,CVTPTR                        A(CVT) INTO R1\n         L     R1,CVTJESCT-CVT(,R1)             A(JESCT) INTO R1\n         L     R1,JESCTEXT-JESCT(,R1)           A(JESPEXT) INTO R1\n         ICM   R1,B'1111',JESSMSIB-JESPEXT(R1)  A(SMSSSIB) INTO R1\n         BZ    SVOL0080            (BZ=NO SMS-ENV. FOUND, EXIT)\n         XC    WSSOB,WSSOB         CLEAR WORK-SSOB\n         LA    R2,WSSOB            A(WORK SSOB)\n         USING SSOB,R2             TELL ASSEMBLER\n         ST    R1,SSOBSSIB         A(WORK-SSIB) INTO WORK-SSOB\n         MVC   SSOBID,=C'SSOB'     CB-ID INTO WORKAREA\n         MVI   SSOBFUNC+1,SSOBSSMS    FUNCTION-CODE FOR SMS (55)\n         MVI   SSOBLEN+1,SSOBHSIZ  LENGTH OF SSOB INTO WORK-SSOB\n         LA    R3,WSSSA            A(WORK FUNCTION DEPENDENT AREA)\n         ST    R3,SSOBINDV         STORE IN WORK-SSOB\n         USING IEFSSSA,R3          TELL ASSEMBLER\n         MVC   SSSAID,=C'SSSA'     CB-ID INTO WORKAREA\n         LA    R0,SSSALN+SSSA1LN   TOTAL LENGTH OF USED PARTS OF WSSSA\n         STH   R0,SSSALEN          STORE IN WSSSA\n         MVI   SSSAVER+1,SSOBSSVR  MOVE SSOB-VERSION INTO WSSSA\n         MVI   SSSAIFLG,SSSANAUT   SET NON-AUTHORIZED CALLER IN WSSSA\n         MVI   SSSASFN+1,SSSAACTV  INDICATE ACT.CONFIG-SRVC. REQUESTED\n*                                  SSSA1* = SUBFUNCTION OF ACTIVE CONF.\n         MVI   SSSA1TYP,SSSA1AVL   GET ALL VOLUMES, MAPPED BY IGDVLD\n         LH    R0,=Y(WVLD1ST)      LENGTH OF 1 IGDVLD-CB\n         ST    R0,SSSA1LEN         STORE IN WSSSA1\n         ST    R7,SSSA1PTR         STORE A(WAREA FOR SSSACON)\n         LA    R1,WSSOB            A(WSSOB) INTO R1\n         ST    R1,@WSSOB           STORE IN PARMLIST-ADDRESS\n         OI    @WSSOB,X'80'        SET HIGHORDERBIT\n         LA    R1,@WSSOB           A(PARMLIST-ADDRESS) INTO R1\n         IEFSSREQ                  ISSUE SMS-SSI-CALL\n         LTR   R15,R15             WENT IT OK ?\n         BNZ   SVOL0082            (BNZ=NO, SET APPROPRIATE ERROR-MSG)\n         ICM   R1,15,SSOBRETN      PICK UP SUBFUNCTION-RETURNCODE\n         BZ    SVOL0020            (BZ=ALL WORKED ANALYZE RESULT)\n         CLC   SSSARSN,=A(SSSA1ISP)    INSUFFICIENT STORAGE ?\n         BNE   SVOL0082            (BNE=NO, OTHER ERROR, QUIT)\n         L     R1,WVLDLEN          LENGTH OF 1ST STORAGE OBTAIN\n         STORAGE RELEASE,LENGTH=(R1),  RELEASE OBTAINED WORKAREA       X\n               ADDR=(R7)\n         MVC   WVLDLEN,SSSA1ALN    LENGTH NEEDED BY IEFSSREQ\n         L     R1,WVLDLEN          USE IT FOR 2ND STORAGE OBTAIN\n         STORAGE OBTAIN,LENGTH=(R1),       GET BIGGER WORKAREA         X\n               LOC=ANY,BNDRY=PAGE,ADDR=(R7)\n         MVC   SSSA1LEN,SSSA1ALN   SET NEW LENGTH IN IEFSSSA\n         ST    R7,SSSA1PTR         STORE A(WAREA FOR SSSACON)\n         LA    R1,@WSSOB           A(PARMLIST-ADDRESS) INTO R1\n         IEFSSREQ                  ISSUE SMS-SSI-CALL\n         ICM   R1,15,SSOBRETN      2ND CALL WORKED ?\n         BNZ   SVOL0082            (BNZ=NO, STILL ERRORS, QUIT)\nSVOL0020 DS    0H                  AFTER IEFSSREQ, R7=A(ANSWER-AREA)\n         LR    R3,R7               SAVE R7 FOR STORAGE RELEASE\n         USING IGDVLD,R3           TOP OF VOLSER-ARRAY RETURNED\n         L     R2,VLDPCNT          # OF VOLUME-ENTRIES RETURNED\n         L     R4,VLDPLEN          LENGTH OF A SINGLE ENTRY\nSVOLLUP0 DS    0H                  LOOP: WALK THROUGH SMS-VOLUMETABLE\n         TM    FLAGBYTE,REXXENV    CALLED AS A REXX-FUNCTION ?\n         BO    SVOL0022            (BO=YES, EXECUTE INTO ALLMSGS)\n         MVI   WORKREC,C' '        CLEAR OUT WORKREC (CURRENT LINE)\n         MVC   WORKREC+1(L'WORKREC-1),WORKREC       DO.\n         LA    R0,L'WORKREC        LENGTH OF WORKREC\n         STH   R0,0(R8)            STORE IN ALLMSGS\n         MVC   WORKREC(6),VLDVSER  MOVE VOLSER INTO WORKREC\n         B     SVOL0025            BUMP OVER EXECUTE FOR FUNCTIONCALL\nSVOL0022 DS    0H                  EXECUTE VOLSER INTO ALLMSGS\n         LH    R1,VLDVSLEN         LENGTH OF VOLSERNAME (SHOULD BE 6)\n         STH   R1,0(R8)            STORE LENGTH IN ALLMSGS\n         BCTR  R1,0                SUBTRACT 1 FOR EXECUTE\n         EX    R1,SVOLMVC1         WRITE INTO ALLMSGS\n         AR    R8,R1               BUMP BEHIND VOLSER +\n         AH    R8,=H'3'            ADD LENGTH-HW + 1 (EXECUTE)\nSVOL0025 DS    0H\n         LH    R1,VLDSGLEN         LENGTH OF STORAGE-GROUP INTO R1\n         BCTR  R1,0                SUBTRACT 1 FOR EXECUTE\n         TM    FLAGBYTE,REXXENV    CALLED AS A REXX-FUNCTION ?\n         BZ    SVOL0027            (BZ=NO, WRITE INTO WORKMSG)\n         EX    R1,SVOLMVC2         WRITE STORAGE-GROUP INTO ALLMSGS\n         LA    R1,1(,R1)           RE-INCREASE AFTER EXECUTE\n         STH   R1,0(R8)            STORE LENGTH IN ALLMSGS\n         AR    R8,R1               BUMP BEHIND STORAGEGROUP\n         AH    R8,=H'2'            ADD LENGTH OF LENGTH-HW\n         B     SVOL0028            BUMP OVER TSO-ONLY SECTION\nSVOL0027 DS    0H\n         EX    R1,SVOLMVC3         WRITE INTO WORKREC\n         MVC   WORKREC+36(4),=CL4'N/A '     ASSUME OFFLINE DEVICE\n         B     SVOL0029            BUMP OVER SVOL0028 (REXX-ENV.)\nSVOL0028 DS    0H\n         LA    R1,4                LENGTH OF DEVICE-NR\n         STH   R1,0(R8)            STORE IN ALLMSGS\n         MVC   2(4,R8),=CL4'N/A '     ASSUME UCB WILL BE OFFLINE\n         LA    R8,6(,R8)\nSVOL0029 DS    0H\n         ICM   R1,B'1111',VLDNUCBA    IS THIS REALLY TRUE?\n         BZ    SVOL0030            (BZ=YES, NO UCB FOUND, PROCEED)\n         LA    R1,UCBCHAN-UCBOB(R1)   A(UCBCHAN,4-DIGIT DEVICE,BINARY)\n         XC    WPACKED,WPACKED     CLEAR PACKED WORKFIELD\n         MVI   WPACKED+3,X'0C'     MOVE SIGN FOR UNPACK\n         MVO   WPACKED(3),0(2,R1)  MOVE DEVICE-NR. INTO BYTES 2+3\n         UNPK  WUNPACK,WPACKED     UNPACK IT INTO WORKAREA\n         TR    WUNPACK,TRTAB1      MAKE IT PRINTABLE\n         TM    FLAGBYTE,REXXENV    CALLED AS A REXX-FUNCTION ?\n         BO    SVOL0295            (BO=YES, WRITE INTO ALLMSGS)\n         MVC   WORKREC+36(4),WUNPACK+2   MOVE INTO WORKREC, FORGET SIGN\n         B     SVOL0030            BUMP OVER REXX-ENV\nSVOL0295 DS    0H\n         SH    R8,=H'6'            A(START OF DEVICE-ENTRY IN ALLMSGS)\n         MVC   2(4,R8),WUNPACK+2   MOVE INTO ALLMSGS, FORGET SIGN\n         LA    R8,6(,R8)           BUMP BEHIND N/A OR DEVICE-NR\nSVOL0030 DS    0H                  COMPUTE SMS-STATUS FOR CURRENT VOL.\n         LH    R15,SYSOFFST        OFFSET IN SYSTEM-ARRAY (FROM IGDBCD)\n         MH    R15,=H'8'           LENGTH OF ONE ENTRY IN ARRAY\n         LA    R1,VLDEND-VLD(,R3)  A(START OF SYSTEMS-ARRAY)\n         AR    R1,R15              A(CURRENT SYSTEM IN SYSTEMS-ARRAY)\n         USING VLDSYSDT,R1         TELL ASSEMBLER\n         SLR   R15,R15             CLEAR WORKREG\n         SLR   R14,R14             CLEAR WORKREG\n         IC    R15,VLDSTSMS        INSERT SMS-STATUS\n         IC    R14,VLDSTMVS        INSERT MVS-STATUS\n         MH    R15,=Y(TABSMSEL)    COMPUTE OFFSET IN STATUS-TABLE\n         A     R15,=A(TABSMSST)    ADD BASE OF TABLE\n         TM    FLAGBYTE,REXXENV    CALLED AS A REXX-FUNCTION ?\n         BZ    SVOL0035            (BZ=NO, WRITE INTO WORKREC)\n         LH    R1,=Y(TABSMSEL)     LENGTH OF A TABLE ENTRY INTO R1\n         STH   R1,0(R8)            STORE LENGTH IN ALLMSGS\n         MVC   2(TABSMSEL,R8),0(R15)  WRITE STATUS INTO WORKREC\n         LA    R8,TABSMSEL+2(,R8)  BUMP BEHIND TABLELENGTH/ENTRY\n         B     SVOL0040\nSVOL0035 DS    0H                  WRITE SMS-STATUS INTO WORKREC\n         MVC   WORKREC+42(TABSMSEL),0(R15)\nSVOL0040 DS    0H                  COMPUTE MVS-STATUS FOR CURRENT VOL.\n         BCTR  R14,0               (MVSTAB START WITH STATUS 1)\n         MH    R14,=Y(TABMVSEL)    COMPUTE OFFSET IN STATUS-TABLE\n         A     R14,=A(TABMVSST)    ADD BASE OF TABLE\n         TM    FLAGBYTE,REXXENV    CALLED AS A REXX-FUNCTION ?\n         BO    SVOL0045            (BZ=YES, WRITE INTO ALLMSGS)\n         MVC   WORKREC+60(TABMVSEL),0(R14)   WRITE STATUS INTO WORKREC\n         MVC   2(L'WORKREC,R8),WORKREC\n         LA    R8,L'WORKREC+2(,R8)\n         B     SVOL0050\nSVOL0045 DS    0H                  WRITE MVS-STATUS INTO ALLMSGS\n         LH    R1,=Y(TABMVSEL)     LENGTH OF A TABLE ENTRY INTO R1\n         STH   R1,0(R8)            STORE LENGTH IN ALLMSGS\n         MVC   2(TABMVSEL,R8),0(R14)  WRITE STATUS INTO WORKREC\n         LA    R8,TABMVSEL+2(,R8)  BUMP BEHIND TABLELENGTH/ENTRY\nSVOL0050 DS    0H                  LOAD ADDRESS OF NEXT ENTRY\n         AR    R3,R4               A(NEXT IGDVLD IN RETURNED ARRAY)\n         BCT   R2,SVOLLUP0         PERFORM WORK WITH NEXT VOLUME\n         B     SVOL0090            BUMP OVER ERROR-MESSAGES\nSVOL0080 DS    0H\n         LA    R9,ERR0010          NO SMS-ENVIRONMENT\n         B     SVOL0090\nSVOL0082 DS    0H\n         LA    R9,ERR0020          IEFSSREQ FAILED\nSVOL0090 DS    0H\n         L     R1,WVLDLEN          LENGTH OF OBTAINED WORKAREA\n         STORAGE RELEASE,LENGTH=(R1),                                  X\n               ADDR=(R7)\n*\n         L     R14,SAVE14          LOAD BACKPOINTER\n         BR    R14                 BRANCH THERE\n         LTORG\n*\n         USING IGDVLD,R3\nSVOLMVC1 MVC   2(0,R8),VLDVSER\nSVOLMVC2 MVC   2(0,R8),VLDSTGRP\nSVOLMVC3 MVC   WORKREC+10(0),VLDSTGRP\n*\n***********************************************************************\n*     PUTLBSNS: DO THE PUTLINE-BUSINESS                               *\n***********************************************************************\nPUTLBSNS ST    R14,SAVE14\n         TM    FLAGBYTE,REXXENV      CALLED AS A REXX-FUNCTION ?\n         BOR   R14                   (BO=YES, GET OUT OF HERE)\n         LA    R1,IOPLADS            LOAD DYNAMIC IOPL\n         USING IOPL,R1               FILL IT\n         L     R0,CPLUPT             LOAD DYN. USER'S PROFILE TABLE\n         ST    R0,IOPLUPT            STORE IT IN THE IOPL\n         L     R0,CPLECT             LOAD ADDRESS OF DYN. ECT\n         ST    R0,IOPLECT            STORE IT IN THE IOPL\n         LA    R0,ECBADS             LOAD ADDR OF MY ECB TO R3\n         ST    R0,IOPLECB            STORE ADDRESS OF ECBADS IN IOPL\n         MVC   @MLWAREA(L@PUTLIN),@PUTLIN\n         MVC   DTEXTADS(LTEXTADS),TEXTADS   MOVE CONSTANT TO MY AREA\n         LA    R2,ALLMSGS            POINT TO VARIABLE MSG-AREA\n         LTR   R9,R9                 IS THERE AN ERRORMESSAGE ?\n         BZ    PUTL010               (BZ=NO, WRITE DATA)\n         LR    R2,R9                 POINT TO CORRECT ERRORMSG\nPUTL010  DS    0H                    PREPARE FOR THE PUTLINE\n         XC    DTEXTADS(4),DTEXTADS  CLEAR LENGTH-COUNTER\n         LH    R1,0(R2)              LENGTH OF CURRENT ENTRY INTO R1\n         LTR   R1,R1                 IS IT ZERO ?\n         BZ    PUTL020               (BE = YES, ALL WRITTEN)\nPUTL015  LA    R1,4(,R1)             ADD 4 FOR PUTLINE-HEADER\n         STH   R1,DTEXTADS           STORE INTO WORKAREA\n         BCTR  R1,0                  SUBTRACT 1 FOR EXECUTE\n         EX    R1,PUTLMVC1           DO THE EXECUTE\n         PUTLINE PARM=@MLWAREA,      DO THE PUTLINE                    X\n               OUTPUT=(DTEXTADS,TERM,SINGLE,DATA),MF=(E,IOPLADS)\n         LH    R1,0(R2)              LOAD LENGTH OF MESSAGE\n         LA    R1,2(,R1)             ADD LENGTH OF MSG-LENGTH\n         AR    R2,R1                 ADD CORRECT LENGTH OF MSG-TEXT\n         B     PUTL010               TRY NEXT MESSAGE\nPUTL020  SLR   R15,R15\n         L     R14,SAVE14          LOAD BACKPOINTER\n         BR    R14                 BRANCH THERE\n         LTORG\n*\nPUTLMVC1 MVC   DTEXTADS+4(0),2(R2)\n*\n***********************************************************************\n*     REXXVARS: BUILD AN ARRAY OF REXX-VARAIBLES                      *\n***********************************************************************\nREXXVARS ST    R14,SAVE14          SAVE BACKPOINTER\n         TM    FLAGBYTE,REXXENV    CALLED AS A REXX-FUNCTION ?\n         BZR   R14                 (BZR=NO, DO NOT BUILD VARS)\n         LM    R2,R3,SAVEREXX      A(ENVBLOCK INTO R2, A(EFPL) INTO R3\n         USING EFPL,R3             TELL ASSEMBLER\n         L     R1,EFPLARG          A(ARGTABLE) INTO R1\n         CLC   =F'-1',0(R1)        NO ARGUMENT PASSED ?\n         BE    REXXER10            (BE=YES, SET APPROPRIATE ERRORMSG)\n         USING ARGTABLE_ENTRY,R1   TELL ASSEMBLER\n         XC    WSTEMNAM,WSTEMNAM   CLEAR SAVEAREA FOR STEMNAME\n         L     R14,ARGTABLE_ARGSTRING_LENGTH     L'PASSED STEMNAME\n         C     R14,=F'32'          LONGER THAN 32 CHARACTERS ?\n         BH    REXXER20            YES, SET ERROR-MESSAGE AND QUIT\n         STH   R14,WSTEMLEN        STORE LENGTH OF STEMNAME\n         L     R15,ARGTABLE_ARGSTRING_PTR     A(STEMNAME)\n         BCTR  R14,0               SUBTRACT 1 FOR EXECUTE\n         EX    R14,REXMVC00        WRITE STEMNAME INTO WSTEMNAM\n         EX    R14,REXUPR01        MAKE STEMNAME UPPERCASE\n         AR    R15,R14             A(END OF STEMNAME-1)\n         CLI   0(R15),C'.'         VALID STEMNAME PASSED ?\n         BNE   REXXER25            (BNE=NO, SET ERROR-MSG + QUIT)\n         CLC   =F'-1',ARGTABLE_NEXT    IS THIS THE END OF THE PARMLIST?\n         DROP  R1                  DROP ARGTABLE-BASE\n         BNE   REXXER30            (BNE=NO, MORE THAN 1 PARM, ERROR)\nREXX0100 DS    0H                  START BUILDING THE RESULT-ARRAY\n         L     R1,ENVBLOCK_IRXEXTE-ENVBLOCK(,R2)  A(IRXEXTE)\n         L     R1,IRXEXCOM-IRXEXTE(,R1)           A(IRXEXCOM)\n         ST    R1,@WRXCOM          STORE A(IRXEXCOM) IN WORKFIELD\n         LA    R0,IRXCOM           A(8 BYTE CONSTANT \"IRXEXCOM\")\n         ST    R0,@WRXCNST         STORE IN IRXEXCOM-PARMLIST\n         XC    @WRXPRM2,@WRXPRM2   CLEAR PARAMETER #2 AND ...\n         XC    @WRXPRM3,@WRXPRM3   ... PARM #3 IN IRXEXCOM-PARMLIST\n         XC    WRXSHVL,WRXSHVL     CLEAR OUT WORK-SHVBLOCK\n         LA    R4,WRXSHVL          A(WORK-SHVBLOCK)\n         ST    R4,@WRXSHVL         STORE IN IRXEXCOM-PARMLIST\n         OI    @WRXSHVL,X'80'      SET HIGHORDERBIT IN LAST PARM\n         USING SHVBLOCK,R4         FILL WORK-SHVBLOCK\n         MVI   SHVCODE,SHVSTORE    FUNCTION-CODE: DEFINE NEW VARIABLE\n         LA    R8,ALLMSGS          A(ALL VALUES + LENGTHS\n         SLR   R2,R2               CLEAR OUT ELEMENT-COUNTER\n         ST    R2,CURRELEM         STORE IT\nREXXLUP0 DS    0H                  OUTMOST LOOP: 1/PER 3RD ARRAY-DIM.\n         L     R2,CURRELEM         LOAD ELEMENT-NUMBER\n         LA    R2,1(,R2)           INCREASE FOR NEW ARRAY-ELEMENTS\n         ST    R2,CURRELEM         STORE IT AGAIN\n         PRINTREG (R2),RESULT=DECIMAL,PADCHAR=NULLSTRING\n         STH   R0,WELEMLEN         LENGTH OF CURRENT NUMERIC\n         MVI   WELEMENT,C'.'       START WITH A DOT\n         LH    R2,WELEMLEN         LENGTH OF NUMERIC PART INTO R2\n         BCTR  R2,0                SUBTRACT 1 FOR EXECUTE\n         EX    R2,REXMVC01         WRITE ELEMENT NUMBER INTO WORKFIELD\n         LA    R2,2(,R2)           RELOAD ORIG. LENGTH, ADD 1 FOR DOT\n         STH   R2,WELEMLEN         TOTAL LENGTH OF '.' + CURR. NUMERIC\n         LA    R5,5                #OF VARIABLES PER ELEMENT\n         LA    R2,VARTAB           A(2ND VARIABLE-QUALIFIERS)\nREXXLUP1 DS    0H                  INNER LOOP: 1 FOR EVERY VAR/ELEMENT\n         XC    WVARNAME,WVARNAME   CLEAR OUT CURRENT VARIABLE-NAME\n         LH    R15,WSTEMLEN        LENGTH OF STEMNAME INTO R15\n         STH   R15,WVARLEN         STORE IN VARLENGTH-FIELD\n         BCTR  R15,0               SUBTRACT 1 FOR EXECUTE\n         EX    R15,REXMVC02        WRITE STEMNAME INTO CURRENT VAR.\n         LH    R15,WVARLEN         RELOAD ORIGINAL LENGTH\n         LA    R0,WVARNAME         A(START OF VARIABLE-NAME)\n         AR    R15,R0              A(END OF STEMNAME)\n         TM    FLAGBYTE,STEMDONE   JUST ZERO-ELEMENT REMAINING ?\n         BZ    REXX0200            (BZ=NO, PROCEED)\n         MVI   0(R15),C'0'         WRITE ZERO-ELEMENT\n         LA    R1,WVARNAME         A(STEM.0)\n         ST    R1,SHVNAMA          STORE IN WORK-SHVBLOCK\n         LH    R1,WVARLEN          IF LAST CALL, LENGTH IS COUNTER-DOT\n         LA    R1,1(,R1)           ADD LENGTH OF '0'\n         ST    R1,SHVNAML          STORE IN WORK-SHVBLOCK\n         LA    R1,WELEMENT+1       A(COUNTER BEHIND DOT)\n         ST    R1,SHVVALA          STORE IN WORK-SHVBLOCK\n         LH    R1,WELEMLEN         LENGTH OF NUMERIC PART + DOT\n         BCTR  R1,0                SUBTRACT LENGTH OF DOT\n         ST    R1,SHVVALL          STORE IN WORK-SHVBLOCK\n         B     REXX0300            ISSUE LAST IRXEXCOM-CALL\nREXX0200 DS    0H\n         SLR   R1,R1               CLEAR WORKREG\n         IC    R1,0(R2)            LENGTH OF 2ND DIMENSION\n         BCTR  R1,0                SUBTRACT 1 FOR EXECUTE\n         EX    R1,REXMVC03         WRITE 2ND DIMENSION THEREAFTER\n         LA    R1,1(,R1)           RELOAD ORIGINAL LENGTH\n         LH    R0,WVARLEN          LOAD LENGTH UNTIL NOW\n         AR    R0,R1               ADD LENGTH OF 2ND DIMENSION\n         STH   R0,WVARLEN          STORE NEW LENGTH\n         LA    R15,WVARNAME        A(START OF VARIABLE-NAME)\n         AH    R15,WVARLEN         A(END OF VARIABLE-NAME)\n         LH    R1,WELEMLEN         LENGTH OF DOT + NUMERIC APPENDIX\n         BCTR  R1,0                SUBTRACT 1 FOR EXECUTE\n         EX    R1,REXMVC04         WRITE AT END OF CURRENT STEM\n         LA    R1,1(,R1)           RELOAD ORIGINAL LENTGH\n         LH    R0,WVARLEN          LOAD LENGTH W/O NUMERIC APPENDIX\n         AR    R0,R1               ADD LENGTH OF APPENDIX\n         STH   R0,WVARLEN          STORE TOTAL LENGTH OF VARIABLE\n         LA    R0,WVARNAME         A(VARIABLE NAME)\n         ST    R0,SHVNAMA          STORE IN WORK-SHVBLOCK\n         LH    R0,WVARLEN          LENGTH OF VARIABLE\n         ST    R0,SHVNAML          STORE IN WORK-SHVBLOCK\n         LH    R0,0(R8)            LOAD LENTGTH OF VALUE\n         ST    R0,SHVVALL          STORE IN WORK-SHVBLOCK\n         LA    R0,2(,R8)           LOAD ADDRESS OF NEXT VALUE\n         ST    R0,SHVVALA          STORE IN WORK-SHVBLOCK\nREXX0300 DS    0H\n         SLR   R0,R0               CLEAR A(OPTIONAL ENV_BLOCK)\n         LA    R1,WRXCOMPL         A(IRXEXCOM PARAMETER LIST)\n         L     R15,@WRXCOM         A(IRXEXCOM)\n         BALR  R14,R15             FIRE ||||\n         LTR   R15,R15             WAS CALL SUCCESSFULL ?\n         BNZ   REXXER40            BNZ=NO, ISSUE ERROR-MESSAGE\n         TM    FLAGBYTE,STEMDONE   ZERO-ELEMENT ALREADY WRITTEN ?\n         BO    REXXOK10            (BO=YES, ALL DONE LEAVE NOW)\n         SLR   R1,R1               CLEAR WORKREG\n         IC    R1,0(R2)            LENGTH OF 2ND VARIABLE-QUALIFIER\n         LA    R2,1(,R2)           POINT BEHIND LENGTH FIELD\n         AR    R2,R1               A(NEXT 2ND VARAIBLE-QUALIFIER)\n         LH    R0,0(R8)            LENGTH OF RECENTLY RETURNED VALUE\n         LA    R8,2(,R8)           BUMP OVER LENGTH FIELD IN ALLMSGS\n         AR    R8,R0               A(NEXT VALUE IN ALLMSGS)\nREXXOK10 DS    0H\n         L     R1,EFPLEVAL         A(EVALBLOCK-ADDRESS)\n         L     R1,0(,R1)           A(EVALBLOCK)\n         USING EVALBLOCK,R1        TELL ASSEMBLER\n         LA    R0,1                LENGTH OF RC=0\n         ST    R0,EVALBLOCK_EVLEN         STORE IN EVALBLOCK\n         MVI   EVALBLOCK_EVDATA,C'0'      SET RC=0\n         SLR   R0,R0               SET RC=0 TO SHOW ERROR-MSG IN REXX\n         ST    R0,RCODE            STORE IN RCODE\n         DROP  R1                  DROP TEMPORARY BASE\n         TM    FLAGBYTE,STEMDONE   ZERO-ELEMENT ALREADY WRITTEN ?\n         BO    REXX0900            (BO=YES, ALL DONE LEAVE NOW)\n         BCT   R5,REXXLUP1         WRITE NEXT PART OF CURRENT ELEMENT\n         LH    R1,0(R8)            STILL VARIABLES TO BUILD ?\n         LTR   R1,R1               TEST WHETHER LENGTH OF NEXT = 0\n         BNZ   REXXLUP0            (BNZ=NO, STILL ELEMENTS, CONTINTUE)\n         OI    FLAGBYTE,STEMDONE   INDICATE VERY LAST CALL\n         B     REXXLUP1            WRITE ZERO-ELEMENT\nREXXER10 DS    0H                  ERROR-SCENARIO 1: NO PARMS PASSED\n         L     R1,EFPLEVAL         A(EVALBLOCK-ADDRESS)\n         L     R1,0(,R1)           A(EVALBLOCK)\n         USING EVALBLOCK,R1        TELL ASSEMBLER\n         LA    R0,L'RXMSG010       LENGTH OF ERROR-MESSAGE\n         ST    R0,EVALBLOCK_EVLEN         STORE IN EVALBLOCK\n         MVC   EVALBLOCK_EVDATA(L'RXMSG010),RXMSG010    ERROR-MSG\n         SLR   R0,R0               SET RC=0 TO SHOW ERROR-MSG IN REXX\n         ST    R0,RCODE            STORE IN RCODE\n         DROP  R1                  DROP TEMPORARY BASE\n         B     REXX0900            BUMP AT THE END OF SUBROUTINE\nREXXER20 DS    0H                  ERROR-SCENARIO 2: STEM LONGER 32CH.\n         L     R1,EFPLEVAL         A(EVALBLOCK-ADDRESS)\n         L     R1,0(,R1)           A(EVALBLOCK)\n         USING EVALBLOCK,R1        TELL ASSEMBLER\n         LA    R0,L'RXMSG020       LENGTH OF ERROR-MESSAGE\n         ST    R0,EVALBLOCK_EVLEN         STORE IN EVALBLOCK\n         MVC   EVALBLOCK_EVDATA(L'RXMSG020),RXMSG020    ERROR-MSG\n         SLR   R0,R0               SET RC=0 TO SHOW ERROR-MSG IN REXX\n         ST    R0,RCODE            STORE IN RCODE\n         DROP  R1                  DROP TEMPORARY BASE\n         B     REXX0900            BUMP AT THE END OF SUBROUTINE\nREXXER25 DS    0H                  ERROR-SCENARIO 25 STEM LONGER 32CH.\n         L     R1,EFPLEVAL         A(EVALBLOCK-ADDRESS)\n         L     R1,0(,R1)           A(EVALBLOCK)\n         USING EVALBLOCK,R1        TELL ASSEMBLER\n         LA    R0,L'RXMSG025       LENGTH OF ERROR-MESSAGE\n         ST    R0,EVALBLOCK_EVLEN         STORE IN EVALBLOCK\n         MVC   EVALBLOCK_EVDATA(L'RXMSG025),RXMSG025    ERROR-MSG\n         SLR   R0,R0               SET RC=0 TO SHOW ERROR-MSG IN REXX\n         ST    R0,RCODE            STORE IN RCODE\n         DROP  R1                  DROP TEMPORARY BASE\n         B     REXX0900            BUMP AT THE END OF SUBROUTINE\nREXXER30 DS    0H                  ERROR-SCENARIO 3: MORE THAN 1 PARM.\n         L     R1,EFPLEVAL         A(EVALBLOCK-ADDRESS)\n         L     R1,0(,R1)           A(EVALBLOCK)\n         USING EVALBLOCK,R1        TELL ASSEMBLER\n         LA    R0,L'RXMSG030       LENGTH OF ERROR-MESSAGE\n         ST    R0,EVALBLOCK_EVLEN         STORE IN EVALBLOCK\n         MVC   EVALBLOCK_EVDATA(L'RXMSG030),RXMSG030    ERROR-MSG\n         SLR   R0,R0               SET RC=0 TO SHOW ERROR-MSG IN REXX\n         ST    R0,RCODE            STORE IN RCODE\n         DROP  R1                  DROP TEMPORARY BASE\n         B     REXX0900            BUMP AT THE END OF SUBROUTINE\nREXXER40 DS    0H                  ERROR-SCENARIO 3: MORE THAN 1 PARM.\n         L     R1,EFPLEVAL         A(EVALBLOCK-ADDRESS)\n         L     R1,0(,R1)           A(EVALBLOCK)\n         USING EVALBLOCK,R1        TELL ASSEMBLER\n         LA    R0,L'RXMSG040       LENGTH OF ERROR-MESSAGE\n         ST    R0,EVALBLOCK_EVLEN         STORE IN EVALBLOCK\n         MVC   EVALBLOCK_EVDATA(L'RXMSG040),RXMSG040    ERROR-MSG\n         SLR   R0,R0               SET RC=0 TO SHOW ERROR-MSG IN REXX\n         ST    R0,RCODE            STORE IN RCODE\n         DROP  R1                  DROP TEMPORARY BASE\n         B     REXX0900            BUMP AT THE END OF SUBROUTINE\nREXX0900 DS    0H\n         L     R14,SAVE14           LOAD BACKPOINTER\n         BR    R14                 BRANCH THERE\n*\nREXMVC00 MVC   WSTEMNAM(0),0(R15)       SAVE PASSED STEMNAME\nREXUPR01 OC    WSTEMNAM(0),=32C' '      MAKE PASSED PARM UPPERCASE\nREXMVC01 MVC   WELEMENT+1(0),0(R1)      NUMERIC PART OF VARIABLE\nREXMVC02 MVC   WVARNAME(0),WSTEMNAM     BUILD NEW VARIABLE-NAME\nREXMVC03 MVC   0(0,R15),1(R2)           BUILD NEW VARIABLE-NAME\nREXMVC04 MVC   0(0,R15),WELEMENT        DOT + NUMERIC AT END OF VAR\n*\n         LTORG\n***********************************************************************\n*     CONSTANTS                                                       *\n***********************************************************************\n*\nTEXTADS  DC    H'132'\n         DC    CL132' '\n         DC    H'0'\nLTEXTADS EQU   *-TEXTADS\n*\nTABSMSST DC    CL12'N/A'\nTABSMSEL EQU   *-TABSMSST\n         DC    CL12'ENABLED'\n         DC    CL12'QUIESCED/ALL'\n         DC    CL12'QUIESCED/NEW'\n         DC    CL12'DISABLED/ALL'\n         DC    CL12'DISABLED/NEW'\n*\nTABMVSST DC    CL7'ONLINE'\nTABMVSEL EQU   *-TABMVSST\n         DC    CL7'OFFLINE'\n         DC    CL7'OFF-PND'\n         DC    CL7'BOXED'\n         DC    CL7'NOT-RDY'\n*\nVARTAB   DC    X'07',C'VOL_SER'\n         DC    X'08',C'STOR_GRP'\n         DC    X'06',C'DEV_NR'\n         DC    X'08',C'SMS_STAT'\n         DC    X'08',C'MVS_STAT'\n*\nIRXCOM   DC    CL8'IRXEXCOM'\n*\nRXMSG010 DC    C'8 REQUIRED PARAMETER STEMNAME OMITTED.'\nRXMSG020 DC    C'8 STEMNAME MUST NOT EXCEED 32 CHARACTERS IN LENGTH.'\nRXMSG025 DC    C'8 INVALID STEMNAME PASSED. MUST END WITH PERIOD (.)'\nRXMSG030 DC    C'8 QSMS ACCEPTS JUST 1 PARAMETER (STEMNAME).'\nRXMSG040 DC    C'8 IRXEXCOM CALL FAILED.'\n*\nERR0010  DC    H'78'\n         DC    CL78'QSMS010E NO ACTIVE SMS-ENVIRONMENT FOUND. NO  ACTIOX\n               N TAKEN. PROGRAM TERMINATES'\n         DC    H'0'\nERR0020  DC    H'78'\n         DC    CL78'QSMS020E SMS-SUBSYSTEM INTERFACE CALL FAILED. NO  AX\n               CTION TAKEN. PGM TERMINATES'\n         DC    H'0'\n*\nTRTAB1   EQU   *-240\n         DC    C'0123456789ABCDEF'\n         ORG\n*\n***********************************************************************\n*     MACRO LIST-FORM                                                 *\n***********************************************************************\n*\n@PUTLIN  PUTLINE MF=L\nL@PUTLIN EQU    *-@PUTLIN\n*\nLIOCINFO IOCINFO MF=(L,MTOKEN)\nLLIOCINF EQU   *-LIOCINFO\n*\n         UCBSCAN MF=(L,MSCANWRK)\nLLUCBSCA EQU   *-MSCANWRK\n*\n         EJECT\n*\n***********************************************************************\n*     WORKING SECTION                                                 *\n***********************************************************************\n*\nDWORK    DSECT\n@MLWAREA DS    XL256                  MF=L WORKAREA\n@UCBSCAN DS    XL256                  MF=L WORKAREA\n*\nFLAGBYTE DS    X\nREXXENV  EQU   X'80'\nSTEMDONE EQU   X'40'\n*\nSAVEREXX DS    2F\nWSTEMNAM DS    CL32\nWSTEMLEN DS    H\nWVARNAME DS    CL48\nWVARLEN  DS    H\nWELEMENT DS    CL8\nWELEMLEN DS    H\nCURRELEM DS    F\n@WRXCOM  DS    F\n*\n         DS    0D\nWRXCOMPL DS    0XL16\n@WRXCNST DS    F\n@WRXPRM2 DS    F\n@WRXPRM3 DS    F\n@WRXSHVL DS    F\n         DS    0D\nWRXSHVL  DS    XL(SHVBLEN)\n*\nCPLCBUF  DS    F                      CPPL-WORKFIELDS\nCPLUPT   DS    F\nCPLPSCB  DS    F\nCPLECT   DS    F\n*\nECBADS   DS    F                      PUTLINE WORKFIELDS\nIOPLADS  DS    4F\n*\nDTEXTADS DS    CL(LTEXTADS)           MSG-WORKFIELD\n*\nDEVWORD  DS    CL4\nUCBCOPY  DS    CL48\nSCANWRK  DS    CL100\nTOKEN    DS    CL48\nCURVOL   DS    CL6\n*\nWPACKED  DS    PL4\nWUNPACK  DS    CL8\nWBCDSLEN DS    F\nCURRSYS  DS    CL8\nSYSOFFST DS    H\n@VLD     DS    F\nWVLDLEN  DS    F\n*\nWORKREC  DS    CL80\nSAVE14   DS    F\n@ERRMSG  DS    F\nRCODE    DS    F\n*\n@WSSOB   DS    F\n         DS    0D\nWSSOB    DS    XL(SSOBHSIZ)\n         DS    0D\nWSSSA    DS    XL(SSSALN+SSSA1LN)\n         DS    0D\nWVLD1ST  EQU   ((VLDEND-VLD)+(VLDEND2-VLDSYSDT))\nALLMSGS  DS    400CL32000\nLDWORK   EQU   *-DWORK\n*\n         PRINT GEN\n         IGDVLD\n         IGDBCD\n         PRINT NOGEN\n         CVT   DSECT=YES\n         IEFJESCT\n         IEFSSSA\n         IEFJSSIB\n         IEFSSOBH\n         IKJCPPL\n         IKJIOPL\n         IEFUCBOB\n         IRXEFPL\n         IRXEVALB\n         IRXENVB\n         IRXARGTB\n         IRXEXTE\n         IRXSHVB\n         END   QSMS\n/*\n//SYSLIB    DD DISP=SHR,DSN=SA1T.T750K.CBTFILE.CNTL   <== THIS PDS\n//          DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSLIN    DD DSN=&&OBJ,UNIT=SYSDA,DISP=(NEW,PASS),\n//          SPACE=(3200,(200,50)),DCB=(RECFM=FB,BLKSIZE=3200,LRECL=80)\n//SYSPRINT  DD SYSOUT=*,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=3990)\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//*\n//* =====================================================\n//* ===== L I N K A G E   E D I T O R ===================\n//* =====================================================\n//LKED      EXEC PGM=HEWL,REGION=1024K,COND=(0,NE),\n//          PARM='XREF,LIST,RENT,REUS'\n//SYSLMOD   DD DISP=SHR,DSN=SA1T.T750K.CBTFILE.LOAD\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(10,3))\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD DSN=&&OBJ,DISP=(OLD,DELETE)\n//          DD *\n  NAME    QSMS(R)\n/*\n//TESTRC IF (RC EQ 0) THEN\n//SCHTEPP3   EXEC PGM=IKJEFT01,REGION=8M\n//STEPLIB  DD  DISP=SHR,DSN=SA1T.T750K.CBTFILE.LOAD\n//SYSPROC  DD  DISP=SHR,DSN=SA1T.T750K.CBTFILE.CNTL\n//SYSPRINT DD  SYSOUT=*\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  *\n  QSMSREXX\n  QSMS\n//ENDTEST ENDIF\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QTOD": {"ttr": 3847, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x00\\xd4\\x00\\xd4\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 212, "newlines": 212, "modlines": 0, "user": "TRAMSEI"}, "text": "//T750KY   JOB  (317,04,E1500K),'RAEMSY',\n//             CLASS=X,\n//             MSGCLASS=T,\n//             MSGLEVEL=(1,1),\n//             NOTIFY=&SYSUID,\n//             REGION=8M,\n//             TIME=NOLIMIT\n//*\n//*MAIN SYSTEM=SYT\n//*\n//ASM      EXEC PGM=ASMA90,REGION=2048K,\n//          PARM='NODECK,OBJECT,RENT'\n//SYSIN     DD *\nQTOD     TITLE '*** \"QTOD\" *** TSO COMMAND PROCESSOR &SYSDATE'\n***********************************************************************\n* QTOD                                                                *\n* =====                                                               *\n*                                                                     *\n         EJECT\n***********************************************************************\n*     EQUATES                                                         *\n***********************************************************************\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8                      UNUSED\nR9       EQU   9\nR10      EQU   10                     BAL\nR11      EQU   11                     STORAGE OBTAINED AREA\nR12      EQU   12                     BASE #1\nR13      EQU   13                     HIGHER SAVE-AREA\nR14      EQU   14                     BAKR\nR15      EQU   15                     RC\n         EJECT\n***********************************************************************\n*     START                                                           *\n***********************************************************************\nQTOD     CSECT\nQTOD     AMODE 31\nQTOD     RMODE ANY\n         SPACE 2\n         BAKR  14,0                  ESTABLISH LINKAGE-CONVENTIONS\n         LR    R12,R15               LOAD TEMPORARY BASE TO MY BASE\n         USING QTOD,R12              TELL ASSEMBLER\n         LR    R3,R1                 ESTABLISH CPPL'S  ADDRESSABILITY\nGETSTOR  DS    0H\n         STORAGE OBTAIN,LENGTH=LDWORK,LOC=BELOW ET WORKING STORAGE\n         LR    R11,R1                ESTABLISH DSECT'S ADDRESSABILITY\n         USING DWORK,R11             TELL ASSEMBLER\n         BAL   R10,LOADCPPL          SAVE CPPL\n         BAL   R10,CALLMAC           CONVERT TODSTAMP\n         BAL   R10,PUTLBSNS          PRINT IT OUT\n*\nENDIT    DS    0H\n         STORAGE RELEASE,LENGTH=LDWORK,ADDR=(R11)  FREE OBTAINED STOR.\n         XR    R15,R15               SET RC=0\n         PR                          END QTOD + CLEANUP\n*\n***********************************************************************\n*     SUBROUTINES                                                     *\n***********************************************************************\n*\nLOADCPPL ST    R10,SAVE10\n         USING CPPL,R3               GET THE ADDRESSES IN CPPL\n         MVC   CPLCBUF,CPPLCBUF      MOVE COMM.-BUFFER ADDR TO MY AREA\n         MVC   CPLUPT,CPPLUPT        MOVE USERPROFTAB ADDR TO MY AREA\n         MVC   CPLPSCB,CPPLPSCB      MOVE PROT.STEP-CB ADDR TO MY AREA\n         MVC   CPLECT,CPPLECT        MOVE ECT-ADDRESS TO MY AREA\n         DROP  R3                    FREE CPPL\n         L     R10,SAVE10\n         BR    R10\n*\n*********************************************************************\n* OBTAIN A TODSTAMP AND CALL THE TODPRINT-MACRO\n*********************************************************************\n*\nCALLMAC  ST    R10,SAVE10          SAVE BACKPOINTER\n         LA    R4,@MLWAREA         A(256-BYTE WORKAREA)\n         STCK  TODDW               GET TOD-STAMP\n         LA    R1,TODDW            A(TOD-STAMP)\n         TODPRINT (R1),WORKAREA=(R4),                                  X\n               OUTFORM='Date: WHOLEDAY, ANDAY of MONTH YEAR (MT/DD/YY YX\n               EAR.JUL) Time: HH:MM:SS.STAMP(1)',                      X\n               SHIFT=YES,                                              X\n               CAPS=OFF            LET OUTPUT IN MIXED CASE\n         LH    R2,0(R4)            LOAD LENGTH OF DATE/TIMESTAMP\n         STH   R2,ALLMSGS\n         BCTR  R2,0                SUBTRACT 1 FOR EXECUTE\n         EX    R2,*+4              WRITE INTO ALLMSGS\n         MVC   ALLMSGS+2(0),2(R4)\n         L     R10,SAVE10\n         BR    R10\n*        LTORG\n*\n***********************************************************************\n*     PUTLBSNS: DO THE PUTLINE-BUSINESS                               *\n***********************************************************************\nPUTLBSNS ST    R10,SAVE10\n         STFSMODE ON,INITIAL=YES     CLEAR ....\n         STFSMODE OFF                      .... SCREEN\n         LA    R1,IOPLADS            LOAD DYNAMIC IOPL\n         USING IOPL,R1               FILL IT\n         L     R0,CPLUPT             LOAD DYN. USER'S PROFILE TABLE\n         ST    R0,IOPLUPT            STORE IT IN THE IOPL\n         L     R0,CPLECT             LOAD ADDRESS OF DYN. ECT\n         ST    R0,IOPLECT            STORE IT IN THE IOPL\n         LA    R0,ECBADS             LOAD ADDR OF MY ECB TO R3\n         ST    R0,IOPLECB            STORE ADDRESS OF ECBADS IN IOPL\n         MVC   @MLWAREA(L@PUTLIN),@PUTLIN\n         MVC   DTEXTADS(LTEXTADS),TEXTADS   MOVE CONSTANT TO MY AREA\n         LA    R2,ALLMSGS            POINT TO VARIABLE MSG-AREA\n         XC    DTEXTADS(4),DTEXTADS  CLEAR LENGTH-COUNTER\nPUTL010  DS    0H\n         LH    R1,0(R2)              LENGTH OF CURRENT ENTRY INTO R5\n         LTR   R1,R1                 IS IT ZERO ?\n         BZ    PUTL020               (BE = YES, ALL WRITTEN)\nPUTL015  LA    R1,4(,R1)             ADD 4 FOR PUTLINE-HEADER\n         STH   R1,DTEXTADS           STORE INTO WORKAREA\n         BCTR  R1,0                  SUBTRACT 1 FOR EXECUTE\n         EX    R1,PUTLMVC1           DO THE EXECUTE\n         PUTLINE PARM=@MLWAREA,      DO THE PUTLINE                    X\n               OUTPUT=(DTEXTADS,TERM,SINGLE,DATA),MF=(E,IOPLADS)\n         LH    R1,0(R2)              LOAD LENGTH OF MESSAGE\n         LA    R1,2(,R1)             ADD LENGTH OF MSG-LENGTH\n         AR    R2,R1                 ADD CORRECT LENGTH OF MSG-TEXT\n         B     PUTL010               TRY NEXT MESSAGE\nPUTL020  XR    R15,R15\n         L     R10,SAVE10\n         BR    R10\n*        LTORG\n*\nPUTLMVC1 MVC   DTEXTADS+4(0),2(R2)\n***********************************************************************\n*     CONSTANTS                                                       *\n***********************************************************************\n*\nTEXTADS  DC    H'132'\n         DC    H'0'\n         DC    CL132' '\nLTEXTADS EQU   *-TEXTADS\n*\n***********************************************************************\n*     MACRO LIST-FORM                                                 *\n***********************************************************************\n@PUTLIN  PUTLINE MF=L\nL@PUTLIN EQU    *-@PUTLIN\n*\n***********************************************************************\n*     COPY    SECTION                                                 *\n***********************************************************************\n***********************************************************************\n*     WORKING SECTION                                                 *\n***********************************************************************\n*\nDWORK    DSECT\n@MLWAREA DS    XL256                  MF=L WORKAREA\n@MACWORK DS    CL256\nMWADDR   DS    A\n*\nSAVE10   DS    F\n* @SRTESTM DS    F                      A(START SORT STATEMENT)\n*\nCPLCBUF  DS    F                      CPPL-WORKFIELDS\nCPLUPT   DS    F\nCPLPSCB  DS    F\nCPLECT   DS    F\n*\nECBADS   DS    F                      PUTLINE WORKFIELDS\nIOPLADS  DS    4F\nTODDW    DS    D\n*\nDTEXTADS DS    CL(LTEXTADS)           MSG-WORKFIELD\nWORKMSG  DS    CL80\n*\nALLMSGS  DS    4CL32000\nLALLMSGS EQU   *-ALLMSGS\n*\nLDWORK   EQU   *-DWORK\n*\n         EJECT\n*\n         IKJCPPL\n         IKJIOPL\n         END   QTOD\n/*\n//SYSLIB    DD DISP=SHR,DSN=SA1T.T750K.CBTFILE.CNTL\n//          DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSLIN    DD DSN=&&OBJ,UNIT=SYSDA,DISP=(NEW,PASS),\n//          SPACE=(3200,(200,50)),DCB=(RECFM=FB,BLKSIZE=3200,LRECL=80)\n//SYSPRINT  DD SYSOUT=*,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=3990)\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//*\n//* =====================================================\n//* ===== L I N K A G E   E D I T O R ===================\n//* =====================================================\n//LKED      EXEC PGM=HEWL,REGION=1024K,COND=(0,NE),\n//             PARM='XREF,LIST,LET,REUS,RENT'\n//SYSLMOD   DD DISP=SHR,DSN=SA1T.T750K.CBTFILE.LOAD\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(10,3))\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD DSN=&&OBJ,DISP=(OLD,DELETE)\n//          DD *\n  NAME    QTOD(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QUICKIE": {"ttr": 3852, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x185?\\x01\\x185?\\x08H\\x01w\\x01w\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-19T00:00:00", "modifydate": "2018-12-19T08:48:29", "lines": 375, "newlines": 375, "modlines": 0, "user": "LOADLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "QVTOC": {"ttr": 4103, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x04\\x1e\\x04\\x1e\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 1054, "newlines": 1054, "modlines": 0, "user": "TRAMSEI"}, "text": "//T750KQ   JOB (317,04,E150AQ),'RAMSEIER',\n//             MSGLEVEL=(1,1),\n//             CLASS=X,\n//             MSGCLASS=T,\n//             NOTIFY=&SYSUID,\n//             TIME=NOLIMIT\n//*MAIN SYSTEM=SYT\n//*\n//ASM      EXEC PGM=ASMA90,REGION=2048K,\n//          PARM='NODECK,OBJECT,USING(NOWARN),RENT'\n//SYSIN     DD *\nQVTOC    TITLE '*** \"QVTOC \" *** TSO COMMAND PROCESSOR &SYSDATE'\n***********************************************************************\n*                                                                     *\n*     QVTOC - A TSO-COMMAND-PROCESSOR THAT SCANS ALL CURRENTLY ONLINE *\n*             DASDS AND BUILDS A LIST WITH ALL LOADMODULES            *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*     EQUATES                                                         *\n***********************************************************************\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7                      DYNDISP-WORKAREA\nR8       EQU   8                      ALLMSGS-PTR.\nR9       EQU   9                      DSECT-ADDRESSABILITY\nR10      EQU   10                     BAL\nR11      EQU   11                     STORAGE OBTAINED AREA\nR12      EQU   12                     BASE #1\nR13      EQU   13                     HIGHER SAVE-AREA\nR14      EQU   14                     BAKR\nR15      EQU   15                     RC\n         EJECT\n***********************************************************************\n*     START                                                           *\n***********************************************************************\nQVTOC    CSECT\nQVTOC    AMODE 24\nQVTOC    RMODE 24\n         PRINT NOGEN\n         SPACE 2\n         BAKR  14,0                  ESTABLISH LINKAGE-CONVENTIONS\n         LR    R11,R15               LOAD TEMPORARY BASE TO MY BASE\n         LA    R12,2048              LOAD 2NDRY BASE  ..\n         LA    R12,2048(R12,R11)     W. 2ND 4K\n         USING QVTOC,R11,R12         TELL ASSEMBLER\n         LR    R3,R1                 ESTABLISH CPPL'S  ADDRESSABILITY\nGETSTOR  DS    0H\n         STORAGE OBTAIN,LENGTH=LDWORK,LOC=BELOW   GET WORKING STORAGE\n         LR    R9,R1                 ESTABLISH DSECT'S ADDRESSABILITY\n         USING DWORK,R9              TELL ASSEMBLER\n         BAL   R10,LOADCPPL          SAVE CPPL INTO MY IOPL\n         BAL   R10,GETPARMS          GET THE PARAMETER-STRING\n         BAL   R10,GETIOC            GET THE IOC-TOKEN\n         ICM   R1,B'1111',@ERRMSG    IS THERE AN ERROR-MSG ?\n         BNZ   NOSUCCES              (BNZ = YES, ERRORMSG + OUT)\n         XC    SCANWRK,SCANWRK       CLEAR UCB-WORK FIELD\n         BAL   R10,INITPNL           PREPARE PRIMARY PANEL FOR DISPLAY\n         BAL   R10,DYNDISP           WORKSTORAGE FOR LOG. SCREEN\n         LA    R8,ALLMSGS\nVOLLOOP  DS    0H\n         BAL   R10,NEXTVOL           CHECK THE NEXT (OR FIRST) VOLSER\n         LTR   R15,R15               WENT IT OK ?\n         BNZ   READLIBS              (BNZ = NO MORE VOLUMES FOUND)\n         OI    FLAGBYTE,VTOCREAD     INDICATE VTOC TO BE READ\n         BAL   R10,ALLOCVOL          ALLOCATE CURRENT VOLSER\n         ICM   R1,B'1111',@ERRMSG    IS THERE AN ERROR-MSG ?\n         BNZ   NOSUCCES              (BNZ = YES, STOP PROCESSING)\n         BAL   R10,OPENVTOC          CHECK VOLSERS VTOC\n         ICM   R1,B'1111',@ERRMSG    IS THERE AN ERROR-MSG ?\n         BNZ   NOSUCCES              (BNZ = YES, ERRORMSG + OUT)\n         BAL   R10,READVTOC          READ THE VTOC OF CURRENT VOLSER\n         BAL   R10,FREEVOL           FREE DYNALLOC'ED VOLSER\n         ICM   R1,B'1111',@ERRMSG    IS THERE AN ERROR-MSG ?\n         BNZ   NOSUCCES              (BNZ = YES, ERRORMSG + OUT)\n         B     VOLLOOP               GET NEXT VOLSER\nREADLIBS DS    0H                    READ ALL LOADLIBS\n         XR    R1,R1                 CLEAR R1\n         STH   R1,0(R8)              BE SURE TO CLEAR BEHIND LAST MSG\n         ICM   R1,B'1111',@ERRMSG    IS THERE AN ERROR-MSG ?\n         BNZ   NOSUCCES              (BNZ = YES, ERRORMSG + OUT)\n         BAL   R10,LDSNFILT          LOAD DSN-FILTER (IF ANY)\n         LA    R8,ALLMSGS            TOP OF VOLUME/DSN TABLE\n         NI    FLAGBYTE,X'7F'        INDICATE NO VTOC TO BE READ\n         OI    FLAGBYTE,READPDS      INDICATE PDS TO BE READ\n         BAL   R10,OPENOUTF          OPEN OUTPUT-FILE\nLIBSLOOP DS    0H\n         BAL   R10,ALLOCVOL          RE-ALLOC UNDER DD-STMT LSTPDS\n         ICM   R1,B'1111',@ERRMSG    IS THERE AN ERROR-MSG ?\n         BNZ   NOSUCCES              (BNZ = YES, ERRORMSG + OUT)\n         BAL   R10,SCANLIBS          BUILD MEMBERLISTS PER VOLUME\n         BAL   R10,FREEVOL           RE-ALLOC UNDER DD-STMT LSTPDS\n         ICM   R1,B'1111',@ERRMSG    IS THERE AN ERROR-MSG ?\n         BNZ   NOSUCCES              (BNZ = YES, ERRORMSG + OUT)\n         LH    R1,0(R8)              LENGTH OF NEXT LIBRARY\n         LTR   R1,R1                 IS IT ZERO ?\n         BNZ   LIBSLOOP              (BNZ=NO, BUILD MEMBERLIST)\n         BAL   R10,CLOSOUTF          NO MORE LIBS, CLOSE OUTPUTFILE\n         BAL   R10,CDSNFILT          CLOSE DSN-FILTER (IF ANY)\n         BAL   R10,CALLSORT          CALL DFSORT\n         B     ENDIT                 (ALL WENT GREAT, NO ERROS-MSG)\nNOSUCCES DS    0H\n         BAL   R10,PUTLBSNS          ISSUE EITHER INFOS OR ERRORMSG\n*\nENDIT    DS    0H\n         BAL   R10,ISPFCLN           CLEANUP ISPF-ENV.\n         STORAGE RELEASE,LENGTH=LDWORK,ADDR=(R9)   FREE OBTAINED STOR.\n         XR    R15,R15               SET RC=0\n         PR                          END QVTOC + CLEANUP\n         LTORG\n*\n***********************************************************************\n*     EXECUTE                                                         *\n***********************************************************************\n***********************************************************************\n*     SUBROUTINES                                                     *\n***********************************************************************\n*\nLOADCPPL ST    R10,SAVE10\n         USING CPPL,R3               GET THE ADDRESSES IN CPPL\n         MVC   CPLCBUF,CPPLCBUF      MOVE COMM.-BUFFER ADDR TO MY AREA\n         MVC   CPLUPT,CPPLUPT        MOVE USERPROFTAB ADDR TO MY AREA\n         MVC   CPLPSCB,CPPLPSCB      MOVE PROT.STEP-CB ADDR TO MY AREA\n         MVC   CPLECT,CPPLECT        MOVE ECT-ADDRESS TO MY AREA\n         DROP  R3                    FREE CPPL\n         L     R10,SAVE10\n         BR    R10\n*\n*********************************************************************\n* GET PASSED PARAMETERS\n*********************************************************************\n*\nGETPARMS ST    R10,SAVE10             SAVE BACKPOINTER\n         L     R2,PSATOLD-PSA(0)      GET CURRENT TCB\n         L     R2,TCBTIO-TCB(R2)      POINT AT TIOT\n         USING TIOT1,R2               TELL ASSEMBLER\n         LA    R3,TIOENTRY            POINT AT FIRST DDNAME\n         USING TIOENTRY,R3            TELL ASSEMBLER\nTIOT0010 DS    0H\n         XR    R1,R1                  CLEAR WORKREG\n         ICM   R1,1,TIOELNGH          GET LENGTH OF TIOT-ENTRY\n         BZ    TIOT0020               (BZ = LIBRARY NOT FOUND)\n         CLC   TIOEDDNM(8),=CL8'VOLFILT'  IS THERE A VOLUME-FILTER ?\n         BNE   TIOT0015               (BNE = NO, TRY NEXT)\n         OI    FLAGBYTE,FILTVOL       INDICATE VOLUME-FILTER FOUND\nTIOT0015 CLC   TIOEDDNM(8),=CL8'DSNFILT'  IS THERE A VOLUME-FILTER ?\n         BNE   TIOT0016               (BNE = LIBRARY NOT FOUND)\n         OI    FLAGBYTE,FILTDSN       INDICATE VOLUME-FILTER FOUND\nTIOT0016 AR    R3,R1                  STEP TO NEXT ENTRY\n         B     TIOT0010\nTIOT0020 DS    0H\n         XR    R15,R15\n         L     R10,SAVE10\n         BR    R10\n         LTORG\n*********************************************************************\n* GET CURRENT IODF-TOKEN\n*********************************************************************\n*\nGETIOC   ST    R10,SAVE10             GET CURRENT IOCTOKEN\n         XC    @MLWAREA,@MLWAREA      CLEAR WORKAREA\n         MVC   @MLWAREA(LLIOCINF),LIOCINFO     MOVE MF=L INTO WORKAREA\n         IOCINFO IOCTOKEN=TOKEN,MF=(E,@MLWAREA) DO THE EXECUTE-FORM\n         XR    R15,R15                SET RC=0\n         L     R10,SAVE10\n         BR    R10\n         LTORG\n**********************************************************************\n* INITPNL: SHOW ENTRY-PANEL\n**********************************************************************\nINITPNL  ST    R10,SAVE10             SAVE BACKPOINTER\n         XR    R15,R15\n         L     R10,SAVE10\n         BR    R10\n         LTORG\n*\n**********************************************************************\n* DYNDISP: OBTAIN WORKINGSTORAGE FOR CURRENT SCREEN (=DYNAMIC AREA)\n**********************************************************************\nDYNDISP  ST    R10,SAVE10             SAVE BACKPOINTER\n         XR    R15,R15                ASSUME RC=0\nDYND0090 DS    0H\n         L     R10,SAVE10\n         BR    R10\n         LTORG\n*\n**********************************************************************\n* NEXTVOL: SCAN ALL DASD-VOLUMES FOR VOLSERS\n**********************************************************************\nNEXTVOL  ST    R10,SAVE10             SAVE BACKPOINTER\n         XR    R15,R15                ASSUME RC=0\n         XC    @MLWAREA,@MLWAREA      CLEAR WORKAREA\n         TM    FLAGBYTE,FILTVOL       VOLUME-FILTER SPECIFIED ?\n         BNO   SCANSTRT               (BNZ=NO FILTER, PROCESS ALL)\nVOL0010  DS    0H                     DO INITIAL AIACCTAB-CALL\n         TM    FLAGBYTE,FILTVUP       IS FILTER ALREADY LOADED ?\n         BO    SCANSTRT               (BO=YES, DON'T RELOAD FILTER)\n         LOAD  EP=AIACCTAB            LOAD FILTER-PROGRAM\n         ST    R0,TABADDR             STORE ENTRY-POINT ADDRESS\n         OI    FLAGBYTE,FILTVUP       SET FILTUP-BYTE\n         MVI   PARMREC,C'I'           INDICATE 1ST RUN\n         LA    R1,7                   LENGTH OF DD-STMT\n         STCM  R1,3,PARMREC+1         STORE LENGTH IN PARMREC\n         MVC   PARMREC+3(7),=CL7'VOLFILT'    MOVE DD-NAME THEREAFTER\n         LA    R1,PARMREC             POINT AT PARMREC\n         ST    R1,PARMADDR            STORE IN PARAMETER-ADDRESS FIELD\n         LA    R1,PARMADDR            A(PARMADDR)\n         L     R15,TABADDR            RELOAD ENTRY-POINT\n         BASSM R14,R15                BRANCH THERE\nSCANSTRT DS    0H                     START OF VOLUMES LOOP\n         MVC   @MLWAREA(LLUCBSCA),MSCANWRK     UCBSCAN MF=L INTO WAREA\n         UCBSCAN COPY,                                                 X\n               UCBAREA=UCBCOPY,       ANSWER-AREA OF UCBSCAN           X\n               WORKAREA=SCANWRK,      WORKAREA                         X\n               DYNAMIC=YES,           INCLUDE DYNAMIC DEVICES          X\n               DEVNCHAR=DEVWORD,      DEVICE-NR. IN EBCDIC             X\n               IOCTOKEN=TOKEN,        CURRENT IODF-TOKEN               X\n               RANGE=ALL,             PROCESS ALL ENTRIES              X\n               DEVCLASS=DASD,         OF THIS DEVICE-CLASS             X\n               MF=(E,@MLWAREA)\n         LTR   R2,R15                 WAS UCBSCAN SUCCESSFUL ?\n         BNZ   VOL0030                (BNZ=NO, RETURN)\n         LA    R1,UCBCOPY             START OF RESULT-AREA\n         USING UCBOB,R1               SET UP ADDRESSABILITY\n         TM    UCBSTAT,UCBONLI        IS THE DEVICE ONLINE ?\n         MVC   CURRVOL,UCBVOLI        SAVE CURRENT VOLSER\n         BZ    SCANSTRT               (BZ=NOT ONLINE, TRY NEXT VOLUME)\nVOL0020  DS    0H                     CHECK FOR VOLFILT\n         TM    FLAGBYTE,FILTVOL       IS A FILTER THERE ?\n         BNO   ENDSCAN                (BNO=NO, OUT OF HERE)\n         XC    PARMREC,PARMREC\n         MVI   PARMREC,C'S'           INDICATE SEARCH-FUNCTIONS\n         LA    R1,6                   LENGTH OF UCBVOLI\n         STCM  R1,3,PARMREC+1         STORE LENGTH IN PARMREC\n         MVC   PARMREC+3(6),CURRVOL          MOVE DD-NAME THEREAFTER\n         LA    R1,PARMADDR            A(PARMADDR)\n         L     R15,TABADDR            RELOAD ENTRY-POINT\n         BASSM R14,R15                BRANCH THERE\n         XR    R15,R15                CLEAR R15\n         CLI   0(R1),C'M'             WAS THERE A MATCH ?\n         BNE   ENDSCAN                (BNE=NO, VOLUME TO BE PROCESSED)\n         CLC   2(4,R1),=CL4'DROP'     IS THE VOLUME TO BE DROPPED ?\n         BNE   ENDSCAN                (NO, PROCEED)\n         B     SCANSTRT               (YES, GET NEXT VOLUME)\nVOL0030  DS    0H\n         TM    FLAGBYTE,FILTVOL       VOLUME-FILTER SPECIFIED ?\n         BNO   ENDSCAN                (BNZ=NO FILTER, PROCESS ALL)\n         XC    PARMREC,PARMREC        NO ARG WITH LASTCALL\n         MVI   PARMREC,C'T'           INDICATE LAST CALL\n         LA    R1,PARMADDR            A(PARMREC)\n         L     R15,TABADDR            RELOAD ENTRY-POINT\n         BASSM R14,R15                BRANCH THERE\n         DELETE EP=AIACCTAB           DELETE PROGRAM AFTER LAST CALL\nENDSCAN  L     R10,SAVE10             LOAD BACKPOINTER\n         LR    R15,R2\n         BR    R10                    BRANCH THERE\n         LTORG\n*\n*********************************************************************\n* OPENOUTF: OPEN OUTPUT-FILE\n*********************************************************************\n*\nOPENOUTF ST    R10,SAVE10             SAVE BACKPOINTER\n         MVC   DLMODLST(LMODLST),MODLST   MOVE MODLST DCB INTO WORKAREA\n         MVC   DLOPEN(LLOPEN),LOPEN   OPEN MF=L INTO WORKAREA\n         OPEN  (DLMODLST,(OUTPUT)),MF=(E,DLOPEN)   OPEN SORTIN-DD\nOUTF0090 L     R10,SAVE10             LOAD BACKPOINTER\n         BR    R10                    BRANCH THERE\n         LTORG\n*\n*********************************************************************\n* LDSNFILT: FIRST CALL TO AIACCTAB FOR DSN-FILTER\n*********************************************************************\n*\nLDSNFILT ST    R10,SAVE10             SAVE BACKPOINTER\n         TM    FLAGBYTE,FILTDSN      VOLUME-FILTER SPECIFIED ?\n         BNO   LDSN0090              (BNZ=NO FILTER, PROCESS ALL)\n         LOAD  EP=AIACCTAB            LOAD FILTER-PROGRAM\n         ST    R0,TABADDR             STORE ENTRY-POINT ADDRESS\n         MVI   PARMREC,C'I'           INDICATE 1ST RUN\n         LA    R1,7                   LENGTH OF DD-STMT\n         STCM  R1,3,PARMREC+1         STORE LENGTH IN PARMREC\n         MVC   PARMREC+3(7),=CL7'DSNFILT'    MOVE DD-NAME THEREAFTER\n         LA    R1,PARMREC             POINT AT PARMREC\n         ST    R1,PARMADDR            STORE IN PARAMETER-ADDRESS FIELD\n         LA    R1,PARMADDR            A(PARMADDR)\n         L     R15,TABADDR            RELOAD ENTRY-POINT\n         BASSM R14,R15                BRANCH THERE\nLDSN0090 DS    0H\n         L     R10,SAVE10             LOAD BACKPOINTER\n         BR    R10                    BRANCH THERE\n         LTORG\n*\n*********************************************************************\n* ALLOCATE THE VOLUME VIA SVC 99\n*********************************************************************\n*\nALLOCVOL ST    R10,SAVE10             SAVE BACKPOINTER\n         MVC   DLTUD(LTUD),TUDSTART   MOVE TU-CONSTANTS INTO WORKAREA\n         TM    FLAGBYTE,VTOCREAD      IS THE VTOC TO BE READ ?\n         BO    ALLOC010               (BO=YES, BUMP OVER PDS-ENTRY)\n         MVC   CURRVOL(6),2(R8)       MOVE VOLSER FROM WORKMSG\n         MVC   DLTUD(LTUDDNA2),TUDDNA2   MOVE PDS-DDNAME\nALLOC010 DS    0H                     PREPARE FOR SVC 99 (VTOC)\n         MVC   DLTUD+TUVOLSTR(6),CURRVOL    CURRENT VOLSER IN WAREA\n         LA    R1,DLTUD               POINT AT DDNAME IN WORKAREA\n         ST    R1,TUPTR001            STORE IN TEXT-PTR\n         LA    R1,DLTUD+@TUDSSA1      POINT AT START OF DISP IN WA\n         ST    R1,TUPTR001+4          STORE IN TEXT-PTR\n         LA    R1,DLTUD+@TUUNTA1      POINT AT START OF UNIT IN WA\n         ST    R1,TUPTR001+8          STORE IN TEXT-PTR\n         LA    R1,DLTUD+@TUVOLA1      POINT AT START OF VOLSER IN WA\n         ST    R1,TUPTR001+12         STORE IN TEXT-PTR\n         LA    R1,DLTUD+@TUDSNA1      POINT AT START OF DSN  IN WA\n         ST    R1,TUPTR001+16         STORE IN TEXT-PTR\n         OI    TUPTR001+16,X'80'      HIGH-ORDER BIT ON\n         LA    R2,REQBLK              ADDRESSABILITY FOR RB-DSECT\n         USING S99RB,R2               TELL ASSEMBLER\n         XC    REQBLK,REQBLK          CLEAR RB\n         MVI   S99RBLN,REQBLKLN       SET RB LENGTH\n         MVI   S99VERB,S99VRBAL       SET ALLOCATION VERB\n         LA    R1,TUPTR001            POINT AT TOP OF TXT-UNIT PTR.LIST\n         ST    R1,S99TXTPP            STORE IT IN RB\n         LA    R3,RBPTR               ADDRESSABILITY FOR RBP-DSECT\n         USING S99RBP,R3              TELL ASSEMBLER\n         LA    R1,REQBLK              LOAD ADDRESS OF RB\n         ST    R1,S99RBPTR            STORE INTO RB-PTR\n         OI    S99RBPTR,S99RBPND      TURN ON HIGH-ORDER BIT\n         LA    R1,RBPTR               LOAD ADDR OF RB-POINTER INTO R1\n         DYNALLOC                     PERFORM DYNALLOC\n         DROP  R2,R3                  DROP DSECT-ADDRESSABILITY\n         STM   R1,R3,SAVEALOC         SAVE R1-R3 FOR DYNAMIC DEALLOC\n         LTR   R15,R15                TEST DYNALLOC-RC\n         BZ    ALCV0090               (BZ=OK, CONTINUE)\n         MVC   WORKMSG,ERR0010        MOVE MESSAGE-TEXT INTO WORKAREA\n         MVC   WORKMSG+21(6),CURRVOL  FILL IN VOLSER\n         MVC   WORKMSG+41(7),DLTUD+6  FILL IN DDNAME\n         LA    R1,WORKMSG             START OF ERRORMSG\n         ST    R1,@ERRMSG             STORE ADDRESS\nALCV0090 XR    R15,R15                END OF SUBROUTINE\n         L     R10,SAVE10             LOAD BACKPOINTER\n         BR    R10                    BRANCH THERE\n*\n*********************************************************************\n* OPEN THE VTOC\n*********************************************************************\n*\nOPENVTOC ST    R10,SAVE10             SAVE BACKPOINTER\n         MVC   DLRDJFCB(LLRDJFCB),LRDJFCB   RDJFCB MF=L INTO WORKAREA\n         MVC   DVOLREF(LVOLREF),VOLREF      DCB \"MF=L\" INTO WORKAREA\n         LA    R3,DVOLREF             A(REENTRANT DCB)\n         USING IHADCB,R3              TELL ASSEMBLER\n         STCM  R3,B'0111',DLRDJFCB+1  SETUP A(DCB)\n         LA    R2,WAEXLST             RENT-EXLST-FIELD\n         ST    R2,DCBEXLST            STORE IN DVOLREF-DCBEXLST\n         LA    R1,WAJFCB              RENT-JFCB-FIELD\n         ICM   R1,B'1000',=X'87'      AND SET HIGH-ORDER BYTE\n         ST    R1,0(,R2)              STORE IN WAEXLST\n         LA    R1,WAIOB               RENT-IOB-FIELD\n         ST    R1,DCBIOBAD            STORE IN DVOLREF-DCBIOBAD\n         RDJFCB MF=(E,DLRDJFCB)       READ THE JFCB\n         LTR   R15,R15                EVERYTHING OK ?\n         BZ    VTOC0020               (BZ=YES, OPEN THE VTOC)\n         MVC   WORKMSG,ERR0060        MOVE MSG-CONSTANT INTO WA\n         MVC   WORKMSG+47(6),CURRVOL  FILL VARIABLE PART\n         LA    R1,WORKMSG             A(ERRORMESSAGE)\n         ST    R1,@ERRMSG             STORE ERRMSG-POINTER\n         B     VTOC0090               GET THE HELL OUT OF HERE\nVTOC0020 DS    0H\n         LA    R2,WAJFCB              RENT-JFCB-FIELD\n         USING INFMJFCB,R2            TELL ASSEMBLER\n         MVI   JFCBDSNM,X'04'         OVERWRITE FORMAT4.DSCB\n         MVC   JFCBDSNM+1(43),JFCBDSNM      WITH 44*X'04'\n         OPEN  (DVOLREF,(INPUT)),TYPE=J,MF=(E,DLRDJFCB)\n         LTR   R15,R15                EVERYTHING OK ?\n         BZ    VTOC0090               (BZ=YES, CONTINUE READING)\n         MVC   WORKMSG,ERR0070        MOVE MSG-CONSTANT INTO WA\n         MVC   WORKMSG+32(6),CURRVOL  MOVE FAILING VOLSER THERE\n         LA    R1,WORKMSG\n         ST    R1,@ERRMSG             STORE ADDRESS\nVTOC0090 DS    0H                     END OF OPEN-VTOC SUBROUTINE\n         L     R10,SAVE10             RETURN TO CALLER\n         BR    R10\n*\n*********************************************************************\n* READ THE VTOC\n*********************************************************************\n*\nREADVTOC ST    R10,SAVE10\n         MVC   @MLWAREA(L@TRCALC),@TRCALC   MOVE LISTFORM INTO WORKAREA\n         TRKCALC FUNCTN=TRKCAP,       # OF RECORDS PER TRACK           X\n               DEVTAB=DCBDVTBL,       DEVICETYPE OF VOLSER             X\n               R=1,                   NO BALANCING, CALC WHOLE TRACK   X\n               K=44,                  KEYLEN (=DATASETNAME)            X\n               DD=96,                 DATA-PORTION (FX-DSCB)           X\n               REGSAVE=YES,           SAVE REGS (1,9-11, 14)           X\n               MF=(E,@MLWAREA)\n         LTR   R15,R15                WAS TRKCALC SUCCESSFULL ?\n         BZ    READ0010               (BZ=YES, CONTINUE)\n         MVC   WORKMSG,ERR0080        MOVE MSG-CONSTANT INTO WA\n         MVC   WORKMSG+38(6),CURRVOL  FILL VARIABLE PART\n         LA    R1,WORKMSG\n         ST    R1,@ERRMSG             STORE ERRMSG-POINTER\n         B     READ0060\nREAD0010 DS    0H\n* THE DATAPORTION THAT WILL BE READ IS COMPUTED AS FOLLOWS:\n* # OF RECORDS / TRACK (= R0 AFTER TRKCALC) * TRANSFERCOUNT PER I/O\n* THE TRANSFERCOUNT W. \"READ MULTIPLE CK + D\" (X'5E') IS  K+DD+8 = 148\n         MH    R0,=H'148'             # OF REC/TRK * TRANSFERCNT\n         ST    R0,WACCW4+4            STORE BUFFERLENGTH IN CCW\n         STORAGE OBTAIN,LENGTH=(0),LOC=BELOW\n         ST    R1,WACCW4              STORE WORKAREA PTR. IN CCW\n         MVI   WACCW4,X'5E'           CCW-CODE: READ MULTIPLE TRACK\nREADLUP1 DS    0H\n         L     R0,DCBRELAD            DCBRELAD = TTR0 OF CURRENT TRACK\n         L     R1,DCBDEBAD            DCBDEBAD = ADDRESS OF DE-BLOCK\n         LA    R2,MBBCCHHR            MBBCCHHR = ADDRESS RESULT-AREA\n* THE CONVERSION ROUTINE WILL DESTROY R9-R13, SO SAVE THEM OUTSIDE PGM\n         STM   R8,R13,20(R13)         STORE R8-R13\n         LR    R8,R13                 SAVE POINTER TO SAVEAREA\n         L     R15,CVTPTR             CVT-POINTER\n         L     R15,CVTPCNVT-CVT(,R15) CONVERSION-ROUTINE ADDRESS\n         BALR  R14,R15                CONVERT TTR0 INTO MBBCCHHR\n         LM    R8,R13,20(R8)          RELOAD REGISTERS 8 - 13\n         LTR   R15,R15                WAS CONVERSION SUCCESSFUL ?\n         BNZ   CLOSEDCB               (BNZ=NO, END OF WORK)\nREAD0020 DS    0H                     BUILD AN IOB FOR EXCP\n         LA    R1,WAIOB               ADDRESS OF RENT-IOB\n         XC    WAIOB,WAIOB            CLEAR OUT WORK-AREA IOB\n         USING IOBSTDRD,R1            TELL ASSEMBLER\n         OI    IOBFLAG1,IOBCMDCH      TURN ON COMMAND-CHAIN FLAG\n         OI    IOBFLAG1,IOBUNREL      TURN ON IOB-UNRELATED FLAG\n         LA    R2,WAECB               A(RENT-ECB)\n         ST    R2,IOBECBPT            STORE IN IOB\n         LA    R2,WACCW2              A(FIRST RENT-CCW)\n         ST    R2,IOBSTART            STORE IN IOB\n         LA    R2,DVOLREF             A(OPENED DCB)\n         ST    R2,IOBDCBPT            STORE IN IOB\n         MVC   IOBSEEK,MBBCCHHR       DISK-ADDRESS OF TRACK TO BE READ\nREAD0030 DS    0H                     PREPARE REMAINING CCW'S\n         LA    R2,IOBSEEK+3           LOAD ADDRESS OF 1ST CYL\n         ST    R2,WACCW2              STORE IN 1ST CCW\n         MVI   WACCW2,X'31'           SEARCH ID EQUAL (X'31')\n         MVI   WACCW2+4,X'40'         CHAIN-COMMAND FLAG (PR. OF OP)\n         MVI   WACCW2+7,X'05'         XFER-COUNT OF SEARCH (REF.SUMRY)\n         LA    R2,WACCW2              A (1ST CCW OF CHAIN)\n         ST    R2,WACCW3              STORE IN TIC (CCW3)\n         MVI   WACCW3,X'08'           TRANSFER IN CHANNEL (TIC) CCW\n         MVI   WAECB,X'00'            CLEAR OUT WAIT-ECB\n         EXCP  WAIOB                  UFF |\n         WAIT  ECB=WAECB              WAIT FOR END OF IO\n         CLI   WAECB,X'7F'            WAS EXCP SUCCESSFUL ?\n         BNE   CLOSEDCB               (BNE=NO, ISSUE ERROR-MESSAGE)\n         XR    R2,R2\n         ICM   R2,B'0111',WACCW4+1    A(READ TRACK) IN OBTAINED AREA\nREADLUP2 DS    0H                     DETERMINE DSCB-TYPE\n         USING DSCB1,R2               ASSUME ITS A F1-DSCB\n         CLI   DS1FMTID,X'F4'         IS IT A F4-DSCB ?\n         BNE   READ0037               (BNE=NO, CHECK FURTHER)\n         USING DSCB4,R2               TELL ASSEMBLER\n         MVC   DSCBPTRK,DS4DEVDT      SAVE DS4DEVT\n         USING DSCB1,R2               RE-ADDRESS FOR NEXT FX-DSCB\n         B     READ0050               GET NEXT DSCB\nREAD0037 DS    0H\n         CLI   DS1FMTID,X'F1'         IS IT A F1-DSCB ?\n         BNE   READ0050               (BNE=NO, READ NEXT DSCB)\n         TM    DS1DSORG,DS1DSGPO      IS IT A PO-DATASET ?\n         BZ    READ0050               (BZ=NO LOADLIB, GET NEXT DSCB)\n         TM    DS1RECFM,DS1RECFU      IS IT RECFM=U ?\n         BNO   READ0050               (BNO=NO LOADLIB, GET NEXT DSCB)\n         TM    DS1SMSFG,DS1PDSE+DS1PDSEX    IS IT A HFS-DATASET ?\n         BO    READ0050               (BO=YES, SO ITS NOT A LOADLIB)\n         LH    R1,DS1LRECL            LOAD LRECL OF CURRENT DATASET\n         LTR   R1,R1                  IS IT ZERO ?\n         BNZ   READ0050               (BNZ=NO LOADLIB, GET NEXT DSCB)\nREAD0040 DS    0H                     COMPOSE INPUT FOR LIBSCAN:\n         XC    WORKMSG,WORKMSG        VOLSER(6),DSN(1-44)\n         MVC   WORKMSG,CURRVOL        MOVE VOLSER AT BEGIN OF MESSAGE\n         MVC   WORKMSG+6(44),DS1DSNAM MOVE DSN THEREAFTER\n         LA    R4,WORKMSG+49          A(END OF 44-DSN+6CURRVOL)\nREADLUP3 CLI   0(R4),C' '             IS THERE A BLANK ?\n         BNE   READ0042               (BNE=NO, END OF LENGTH-LOOP)\n         BCT   R4,READLUP3            RETRY WITH NEXT CHARACTER\nREAD0042 DS    0H                     END OF LOOP\n         LA    R1,WORKMSG             A(START OF CURRVOL+DSNAME)\n         SR    R4,R1                  COMPUTE LENGTH + SAVE IN R4\n         LA    R4,1(,R4)              +1 (WE STARTED AT 49)\n         ADDMSG (R4),(R1),(R8)        ADD NEXT DSN-VOLSER\n         LR    R8,R1                  RE-LOAD MSG-POINTER\nREAD0050 DS    0H\n         CLC   F1DPR,DSCBPTRK         IS IT THE LAST DSCB OF THE TRACK?\n         LA    R2,DS1END              A(NEXT DSCB OF THIS TRACK)\n         BL    READLUP2               (BL=NO, GET NEXT DSCB OF TRACK)\n         LA    R0,1                   LAST DSCB OF TRACK READ.\n         AH    R0,DCBRELAD            ADD 1 TO THE RELAD OF RENT-DCB\n         STH   R0,DCBRELAD            STORE NEW VALUE IN WORKAREA\n         B     READLUP1               GET NEXT TRACK\nCLOSEDCB DS    0H                     END OF VTOC\n         MVI   WACCW4,X'00'           CLEAR HIGHORDER-BYTE FOR FREEMAIN\n         LM    R1,R2,WACCW4           LOAD BUFFER-ADDRESS + LENGTH\n         STORAGE RELEASE,LENGTH=(2),ADDR=(1)    FREE WORKING-STORAGE\nREAD0060 DS    0H                     IF ERROR IN TRKCALC OCCURS\n         LA    R2,DVOLREF             A(DCB-WORKAREA)\n         MVC   @MLWAREA(LLCLOS),LCLOS    MOVE CLOSE-MF=L INTO WAREA\n         CLOSE ((R2)),MF=(E,@MLWAREA)    CLOSE VOLREF-DCB\nREAD0090 DS    0H\n         L     R10,SAVE10             LOAD BACKPOINTER\n         BR    R10                    BRANCH THERE\n*\n*********************************************************************\n* DEALLOC  THE VOLUME VIA SVC 99\n*********************************************************************\n*\nFREEVOL  ST    R10,SAVE10             SAVE BACKPOINTER\n         LM    R1,R3,SAVEALOC         RELOAD ALLOCATE-DSECTS\n         USING S99RB,R2               TELL ASSEMBLER\n         USING S99RBP,R3              TELL ASSEMBLER\n         XC    DLTUD,DLTUD            CLEAR WORKAREA\n         MVC   DLTUD(@TUDSSA1),TUDSTART    MOVE DDNAME SCANVOL THERE\n         TM    FLAGBYTE,VTOCREAD      WAS THE VTOC READ ?\n         BO    FREE0010               (BO=YES, BUMP OVER LSTPDS-DCB)\n         MVC   DLTUD(LTUDDNA2),TUDDNA2     MOVE LSTPDS -DCB THERE\nFREE0010 DS    0H\n         LA    R4,DLTUD               POINT AT DDNAME IN WORKAREA\n         ST    R4,TUPTR001            STORE IN TEXT-PTR\n         OI    TUPTR001,X'80'         INDICATE END OF PARMLIST\n         MVI   S99VERB,S99VRBUN       SET DEALLOCATION VERB\n         LA    R4,TUPTR001            POINT AT TOP OF TXT-UNIT PTR.LIST\n         ST    R4,S99TXTPP            STORE IT IN RB\n         LA    R1,RBPTR               LOAD ADDR OF RB-POINTER INTO R1\n         DYNALLOC                     PERFORM DEALLOC\n         LTR   R15,R15                WAS IT SUCCESSFULL ?\n         BZ    FREEV090               (BZ=YES, CONTINUE)\n         MVC   WORKMSG,ERR0020        MOVE MESSAGE-TEXT INTO WORKAREA\n         MVC   WORKMSG+25(6),CURRVOL  FILL IN VOLSER\n         MVC   WORKMSG+51(7),DLTUD+6  FILL IN DDNAME\n         LA    R1,WORKMSG             START OF ERRORMSG\n         ST    R1,@ERRMSG             STORE ADDRESS\nFREEV090 XR    R15,R15\n         L     R10,SAVE10\n         BR    R10\n*\n***********************************************************************\n*     SCANLIBS: READ THE LOADLIBS-DIRECTORIES                         *\n***********************************************************************\nSCANLIBS ST    R10,SAVE10\n         MVC   DLRDJFCB(LLRDJFCB),LRDJPDS   RDJFCB MF=L INTO WORKAREA\n         MVC   DLSTPDS(LLSTPDS),LSTPDS      DCB \"MF=L\" INTO WORKAREA\n         LA    R3,DLSTPDS            A(REENTRANT DCB)\n         USING IHADCB,R3             TELL ASSEMBLER\n         STCM  R3,B'0111',DLRDJFCB+1 SETUP A(DCB)\n         LA    R2,WAEXLST            RENT-EXLST-FIELD\n         ST    R2,DCBEXLST           STORE IN DVOLREF-DCBEXLST\n         LA    R1,WAJFCB             RENT-JFCB-FIELD\n         ICM   R1,B'1000',=X'87'     AND SET HIGH-ORDER BYTE\n         ST    R1,0(,R2)             STORE IN WAEXLST\n         RDJFCB MF=(E,DLRDJFCB)      READ THE JFCB\n         LTR   R15,R15               EVERYTHING OK ?\n         BZ    SCANLUP0              (BZ=YES, GO AND BUILD MEMBERLIST)\n         MVC   WORKMSG,ERR0030       MOVE ERRORMESSAGE INTO WORKAREA\n         LA    R1,WORKMSG            STORE A(WORKMSG)\n         ST    R1,@ERRMSG            IN @ERRMSG FOR PUTLINE\n         B     SCAN0090              DO NOT SCAN LOADLIB\nSCANLUP0 DS    0H                    OUTMOST LOOP: ONCE PER LIBRARY\n         LA    R2,WAJFCB             RENT-JFCB-FIELD\n         USING INFMJFCB,R2           TELL ASSEMBLER\n         MVI   JFCBDSNM,C' '         OVERWRITE FORMAT4.DSCB\n         MVC   JFCBDSNM+1(43),JFCBDSNM      WITH 44*BLANK\n         LH    R1,0(R8)              LOAD LENGTH OF VOLSER+DSN\n         SH    R1,=H'7'              SUBTRACT 1 FOR EXECUTE + L'VOLSER\n         EX    R1,SCNDSN01           WRITE DATASETNAME IN JFCBDSNM\n         MVI   WORKDSN,C' '          CLEAR OUT WORKDSN\n         MVC   WORKDSN+1(L'WORKDSN-1),WORKDSN\n         EX    R1,SCNDSN02           WRITE DATASETNAME IN WORKMSGDSN\n         TM    FLAGBYTE,FILTDSN      DATASET-FILTER SPECIFIED ?\n         BNO   SCAN0010              (BNZ=NO FILTER, PROCESS ALL)\n         MVI   PARMREC,C'S'          INDICATE SEARCH-FUNCTION AIACCTAB\n         LA    R1,44                 LENGTH OF DATASETNAME\n         STCM  R1,3,PARMREC+1        STORE BEHIND FUNCTION\n         MVC   PARMREC+3(44),WORKDSN    MOVE DSNAME INTO PARMLIST\n         LA    R1,PARMADDR           A(PARMREC)\n         L     R15,TABADDR           RELOAD ENTRY-POINT\n         BASSM R14,R15               BRANCH THERE\n         CLI   0(R1),C'M'            WAS THERE A MATCH ?\n         BNE   SCAN0010              (BNE=NOMATCH, PROCESS ENTRY)\n         CLC   2(4,R1),=CL4'DROP'    IS THE DATASET TO BE DROPPED ?\n         BE    SCAN0080              (BE=YES, NEXT LIBRARY, NO OPEN)\nSCAN0010 DS    0H\n         OPEN  (DLSTPDS,(INPUT)),TYPE=J,MF=(E,DLRDJFCB)   OPEN THE PDS\n         LTR   R15,R15               EVERYTHING OK ?\n         BNZ   SCAN0090              (BNZ=NO, GET OUT OF HERE)\n         MVC   @MLWAREA(L@READ),@READ    READ MF=L INTO WORKAREA\nSCANLUP1 DS    0H                    2ND LOOP: CALLED ONCE PER DIRBLOCK\n         READ  @MLWAREA,SF,(R3),WDIRBLK,MF=E   READ NEXT DIRBLOCK\n         CHECK @MLWAREA              WAIT FOR I/O-COMPLETION\n         LH    R2,WDIRDATA           LOAD LENGTH OF DIRECTORY BLOCK\n         LA    R1,WDIRDATA+2         POINT AT 1ST MEMBER\n         LA    R5,2                  START AFTER LENGTH-HALFWORD\nSCANLUP2 DS    0H                    INNERMOST LOOP: ONCE PER MEMBER\n         CLC   0(8,R1),BINONES       END OF DIRECTORY REACHED ?\n         BE    CLOSEPDS              (BE=YES, CLOSE PDS)\n         ST    R1,SAVE1              SAVE REG.1 AROUND PUT\n         MVC   WDIRUDL(1),11(R1)     LENGTH OF UDATA IN HALFWORDS\n         MVI   WORKMSG,C' '          BLANK OUT WORKMSG\n         MVC   WORKMSG+1(L'WORKMSG-1),WORKMSG\n         MVC   WORKMSG(8),0(R1)      MOVE MEMBERNAME THERE\n         TM    WDIRUDL,X'80'         IS IT AN ALIAS ?\n         BNO   SCAN0020              (BNO=NO, BUMP OVER ALIAS-SECTION)\n         MVC   WORKMSG+9(2),=CL2'AO'          MOVE ALIAS-ENTRY INTO\n         MVC   WORKMSG+12(8),36(R1)   WORKMESSAGE\nSCAN0020 DS    0H\n         MVC   WORKMSG+21(44),WORKDSN     MOVE DSN THEREAFTER\n         MVC   WORKMSG+66(6),CURRVOL  MOVE VOLSER AT THE END OF MESSAGE\n         PUT   DLMODLST,WORKMSG      WRITE SORTIN-RECORD\n         L     R1,SAVE1              RELOAD REG. 1\n         NI    WDIRUDL,X'1F'         CLEAR FLAG-BITS 1-3\n         XR    R4,R4                 CLEAR OUT WORKREG\n         IC    R4,WDIRUDL            USERDATALENGTH IN HALFWORDS\n         MH    R4,=H'2'              MAKE BYTES\n         LA    R4,12(,R4)            WHOLE ENTRY-LENGTH\n         AR    R5,R4                 ADD TO TOTAL-ENTRIES\n         CR    R5,R2                 ALL ENTRIES PROCESSED ?\n         BNL   SCANLUP1              (BNL=YES, READ NEXT BLOCK)\n         LA    R1,0(R4,R1)           BUMP TO NEXT ENTRY\n         B     SCANLUP2              RE-READ\nCLOSEPDS DS    0H                    LAST DIRECTORY-BLOCK READ\n         LA    R2,DLSTPDS            DCB-WORKAREA\n         MVC   @MLWAREA(LLCLOS),LCLOS       MOVE LISTFORM INTO WAREA\n         CLOSE ((R2)),MF=(E,@MLWAREA)       CLOSE LOADLIB\nSCAN0080 DS    0H                    FILTER-DROPPED ENTRY\n         LH    R1,0(R8)              LENGTH OF PROCESSED DSN+L'VOLSER\n         LA    R1,2(,R1)             LENGTH OF LENGTH-FIELD\n         AR    R8,R1                 POINT AT NEXT LOADLIB\n         CLC   2(6,R8),CURRVOL       IS IT ON THE SAME VOLUME ?\n         BE    SCANLUP0              (BE=YES, PROCESS IT)\nSCAN0090 DS    0H                    END OF VOLUME\n         L     R10,SAVE10            LOAD BACKPOINTER\n         BR    R10                   BRANCH THERE\n         LTORG\nSCNDSN01 MVC   JFCBDSNM(0),8(R8)     CURRENT LOADLIB INTO JFCB\nSCNDSN02 MVC   WORKDSN(0),8(R8)      CURRENT LOADLIB INTO WORKMESSAGE\nCLRDYN01 XC    0(0,R7),0(R7)         BLANK OUT CURRENT LINE IN DYNAREA\n*\n*********************************************************************\n* CLOSOUTF: CLOSE OUTPUT-FILE\n*********************************************************************\n*\nCLOSOUTF ST    R10,SAVE10\n         MVC   DLCLOS(LLCLOS),LCLOS         LISTFROM INTO WORKAREA\n         CLOSE (DLMODLST),MF=(E,DLCLOS)     CLOSE SORTIN-FILE\nOUTFCL90 L     R10,SAVE10            LOAD BACKPOINTER\n         BR    R10                   BRANCH THERE\n         LTORG\n*\n*\n*********************************************************************\n* CDSNFILT: LAST CALL TO AIACCTAB FOR DSN-FILTER\n*********************************************************************\n*\nCDSNFILT ST    R10,SAVE10             SAVE BACKPOINTER\n         TM    FLAGBYTE,FILTDSN       VOLUME-FILTER SPECIFIED ?\n         BNO   CDSN0090               (BNZ=NO FILTER, DO NOT CLOSE)\n         XC    PARMREC,PARMREC\n         MVI   PARMREC,C'T'           INDICATE LAST RUN\n         LA    R1,PARMADDR            A(PARMADDR)\n         L     R15,TABADDR            RELOAD ENTRY-POINT\n         BASSM R14,R15                BRANCH THERE\n         DELETE EP=AIACCTAB           DELETE PROGRAM AFTER LAST CALL\nCDSN0090 XR    R15,R15\n         L     R10,SAVE10             LOAD BACKPOINTER\n         BR    R10                    BRANCH THERE\n         LTORG\n*\n**********************************************************************\n* CALLSORT: CALL DFSORT\n**********************************************************************\nCALLSORT ST    R10,SAVE10             SAVE BACKPOINTER\n         LA    R1,SORTDA              START OF SORT-24BIT-PARAMETERLIST\n         ST    R1,@SORTDA             STORE IN ADDRESS-FIELD\n         LA    R1,@SORTDA             POINT AT A(SORTDA)\n         MVI   0(R1),X'80'            SET HIGH-ORDERBYTE\n         LINK  EP=SORT                CALL SORT\nCSRT0090 XR    R15,R15\n         L     R10,SAVE10             LOAD BACKPOINTER\n         BR    R10                    BRANCH THERE\n         LTORG\n*\n**********************************************************************\n* ISPFCLN: CLEANUP ISPF-ENVIRONMENT\n**********************************************************************\nISPFCLN  ST    R10,SAVE10             SAVE BACKPOINTER\n         XR    R15,R15                ASSUME RC=0\n         L     R10,SAVE10\n         BR    R10\n         LTORG\n*\n*\n***********************************************************************\n*     PUTLBSNS: DO THE PUTLINE-BUSINESS                               *\n***********************************************************************\nPUTLBSNS ST    R10,SAVE10\n         STFSMODE ON,INITIAL=YES     CLEAR ....\n         STFSMODE OFF                      .... SCREEN\n         LA    R1,IOPLADS            LOAD DYNAMIC IOPL\n         USING IOPL,R1               FILL IT\n         L     R0,CPLUPT             LOAD DYN. USER'S PROFILE TABLE\n         ST    R0,IOPLUPT            STORE IT IN THE IOPL\n         L     R0,CPLECT             LOAD ADDRESS OF DYN. ECT\n         ST    R0,IOPLECT            STORE IT IN THE IOPL\n         LA    R0,ECBADS             LOAD ADDR OF MY ECB TO R3\n         ST    R0,IOPLECB            STORE ADDRESS OF ECBADS IN IOPL\n         MVC   @MLWAREA(L@PUTLIN),@PUTLIN\n         MVC   DTEXTADS(LTEXTADS),TEXTADS   MOVE CONSTANT TO MY AREA\n         LA    R2,ALLMSGS            POINT TO VARIABLE MSG-AREA\n         ICM   R1,B'1111',@ERRMSG    IS THERE AN ERRORMESSAGE ?\n         BZ    PUTL010               (BZ=NO, WRITE DATA)\n         LR    R2,R1                 POINT TO CORRECT ERRORMSG\nPUTL010  DS    0H                    PREPARE FOR THE PUTLINE\n         XC    DTEXTADS(4),DTEXTADS  CLEAR LENGTH-COUNTER\n         LH    R1,0(R2)              LENGTH OF CURRENT ENTRY INTO R5\n         LTR   R1,R1                 IS IT ZERO ?\n         BZ    PUTL020               (BE = YES, ALL WRITTEN)\nPUTL015  LA    R1,4(,R1)             ADD 4 FOR PUTLINE-HEADER\n         STH   R1,DTEXTADS           STORE INTO WORKAREA\n         BCTR  R1,0                  SUBTRACT 1 FOR EXECUTE\n         EX    R1,PUTLMVC1           DO THE EXECUTE\n         PUTLINE PARM=@MLWAREA,      DO THE PUTLINE                    X\n               OUTPUT=(DTEXTADS,TERM,SINGLE,DATA),MF=(E,IOPLADS)\n         LH    R1,0(R2)              LOAD LENGTH OF MESSAGE\n         LA    R1,2(,R1)             ADD LENGTH OF MSG-LENGTH\n         AR    R2,R1                 ADD CORRECT LENGTH OF MSG-TEXT\n         B     PUTL010               TRY NEXT MESSAGE\nPUTL020  XR    R15,R15\n         L     R10,SAVE10\n         BR    R10\n         LTORG\n*\nPUTLMVC1 MVC   DTEXTADS+4(0),2(R2)\n***********************************************************************\n*     CONSTANTS                                                       *\n***********************************************************************\n*\nTEXTADS  DC    H'132'\n         DC    H'0'\n         DC    CL132' '\nLTEXTADS EQU   *-TEXTADS\n*\nERR0010  DC    H'76'\n         DC    CL76'DYNALLOC OF VOLSER        UNDER DDNAME          FAIX\n               LED. QVTOC TERMINATES.'\n         DC    H'0'\n*\nERR0020  DC    H'76'\n         DC    CL76'DEALLOCATION OF VOLSER        UNSUCCESSFULL. DDN   X\n                      STILL ALLOCATED.'\n         DC    H'0'\n*\nERR0030  DC    H'76'\n         DC    CL76'DDNAME SCANPDS NOT ALLOCATED. LOADLIBS CAN NOT BE OX\n               PENED. QVTOC IN ERROR.'\n         DC    H'0'\n*\nERR0060  DC    H'76'\n         DC    CL76'DDNAME SCANVOL NOT ALLOCATED. VTOC OF VOLSER       X\n                CANNOT BE OBTAINED.'\n         DC    H'0'\n*\nERR0070  DC    H'76'\n         DC    CL76'UNABLE TO OPEN VTOC OF VOLSER        .QVTOC TERMINAX\n               ED.'\n         DC    H'0'\n*\nERR0080  DC    H'76'\n         DC    CL76'ERROR IN TRKCALC-ROUTINE FOR VOLSER       . QVTOC TX\n               ERMINATES.'\n         DC    H'0'\n* SVC-99 TEXT-UNITS\nTUDSTART DS    0F\nTUDDNA1  DC    AL2(DALDDNAM),AL2(1),AL2(7),C'SCANVOL'\n@TUDSSA1 EQU   *-TUDSTART\nTUDSSA1  DC    AL2(DALSTATS),AL2(1),AL2(1),X'08'       <= DISP=SHR\n@TUUNTA1 EQU   *-TUDSTART\nTUUNTA1  DC    AL2(DALUNIT),AL2(1),AL2(8),C'SYSALLDA'\n@TUVOLA1 EQU   *-TUDSTART\nTUVOLA1  DC    AL2(DALVLSER),AL2(1),AL2(6)\nTUVOLSTR EQU   *-TUDDNA1\n         DC    CL6'      '\n@TUDSNA1 EQU   *-TUDSTART\nTUDSNA1  DC    AL2(DALDSNAM),AL2(1),AL2(44)\nF4DSCB   DC    CL44'FORMAT4.DSCB'\nLTUD     EQU   *-TUDDNA1\n*\nTUDDNA2  DC    AL2(DALDDNAM),AL2(1),AL2(7),C'SCANPDS'\nLTUDDNA2 EQU   *-TUDDNA2\n*\nBINONES  DC    8XL1'FF'\nNEWSET   DC    C'PGM(ISPTTDEF) PARM(ISPXXXXX)'\nLNEWSET  EQU   *-NEWSET\n*\nEDMASK   DC     XL8'F020202020202020'\n*\nSORTDA   DS    0F                     SORT PARAMETERS DATAAREA\nSORTPLEN DC    Y(SORTPEND)\n@SRTSSTM DC    XL1'00',AL3(SORTSSTM)  A(START SORT STATEMENT)\n@SRTESTM DC    XL1'00',AL3(SORTESTM)  A(START SORT STATEMENT)\n@SRTSREC DC    XL1'00',AL3(SORTSREC)  A(START RECORD STATEMENT)\n@SRTEREC DC    XL1'00',AL3(SORTEREC)  A(END RECORD STATEMENT)\n@SRTE15  DC    4XL1'00'               A(E15 SORT ROUTINE)\n@SRTE35  DC    4XL1'00'               A(E35 SORT ROUTINE)\n@SRTMSGS DC    XL1'03',AL3(SORTMSGS)  A(MSGS-DD-STATEMENT)\nSORTPEND EQU   *-@SRTSSTM\n*\nSORTSSTM DC    C' SORT FIELDS=(1,8,CH,A)'\nSORTESTM DC    C' '\nSORTSREC DC    C' RECORD TYPE=F'\nSORTEREC DC    C' '\nSORTMSGS DC    CL8'SYSOUT  '\n\n         EJECT\n***********************************************************************\n*     MACRO LIST-FORM                                                 *\n***********************************************************************\n@CAMLST  CAMLST SEARCH,*,*,*\nL@CAMLST EQU    *-@CAMLST\n*\n@CALL    CALL  ,(,,,,,,,,,,),MF=L  CALL LIST FORM\nL@CALL   EQU    *-@CALL\n*\n@PUTLIN  PUTLINE MF=L\nL@PUTLIN EQU    *-@PUTLIN\n*\n@READ    READ   PDSDECB,SF,LSTPDS,*,'S',MF=L\nL@READ   EQU    *-@READ\n*\n@TRCALC  TRKCALC MF=L\nL@TRCALC EQU    *-@TRCALC\n*\nLIOCINFO IOCINFO MF=(L,MTOKEN)\nLLIOCINF EQU   *-LIOCINFO\n*\n         UCBSCAN MF=(L,MSCANWRK)\nLLUCBSCA EQU   *-MSCANWRK\n*\nLOPEN    OPEN  (*),MF=L\nLLOPEN   EQU   *-LOPEN\n*\nLCLOS    CLOSE (*),MF=L\nLLCLOS   EQU   *-LCLOS\n*\nLRDJFCB  RDJFCB (VOLREF),MF=L\nLLRDJFCB EQU   *-LRDJFCB\n*\nLRDJPDS  RDJFCB (LSTPDS),MF=L\n*\n         EJECT\n*\n***********************************************************************\n*     DCBS    SECTION                                                 *\n***********************************************************************\nVOLREF   DCB   DSORG=PS,MACRF=E,DDNAME=SCANVOL,EXLST=*,                X\n               IOBAD=*,EODAD=CLOSEDCB\nLVOLREF  EQU   *-VOLREF\n*\nLSTPDS   DCB   DSORG=PS,MACRF=R,DDNAME=SCANPDS,EXLST=*,KEYLEN=8,       X\n               LRECL=256,BLKSIZE=256,RECFM=F,EODAD=CLOSEPDS\nLLSTPDS  EQU   *-LSTPDS\n*\nMODLST   DCB   DSORG=PS,MACRF=PM,DDNAME=SORTIN\nLMODLST  EQU   *-MODLST\n*\n***********************************************************************\n*     WORKING SECTION                                                 *\n***********************************************************************\n*\nDWORK    DSECT\n@MLWAREA DS    XL256                  MF=L WORKAREA\n*\nSAVEALOC DS    3F\nSAVE10   DS    F\nSAVE1    DS    F\n@ERRMSG  DS    F\n@SORTDA  DS    F\nTABADDR  DS    F\n*                                     FOR ISPF-INTERFACE\nPARMADDR DS    F                      PARM FOR AIACCTAB\nPARMREC  DS    CL80                   PARM FOR AIACCTAB\nCURRVOL  DS    CL6                    CURRENT VOLSER\n*\nCPLCBUF  DS    F                      CPPL-WORKFIELDS\nCPLUPT   DS    F\nCPLPSCB  DS    F\nCPLECT   DS    F\n*\nECBADS   DS    F                      PUTLINE WORKFIELDS\nIOPLADS  DS    4F\n*\nDTEXTADS DS    CL(LTEXTADS)           MSG-WORKFIELD\n*\nDNEWSET  DS    CL(LNEWSET)\nDLOPEN   DS    CL(LLOPEN)\nDLCLOS   DS    CL(LLCLOS)\nDLCALL   DS    CL(L@CALL)\n*\nDLRDJFCB DS    CL(LLRDJFCB)\nDVOLREF  DS    CL(LVOLREF)\nDLSTPDS  DS    CL(LLSTPDS)\nDLMODLST DS    CL(LMODLST)\n         DS    0D\nWAIOB    DS    CL(IOBR-IOBSTDRD)      LENGTH OF DASD-IOB (40 BYTES)\n         DS    0D\nWACCW2   DS    D                      FORMAT 0 CCW#1 (POINTED BY IOB)\nWACCW3   DS    D                      FORMAT 0 CCW#2 MUST BE WACCW2 + 8\nWACCW4   DS    D                      FORMAT 0 CCW#3 MUST BE WACCW2 +16\nWAECB    DS    F\nWAEXLST  DS    F\nMBBCCHHR DS    XL8\nDSCBPTRK DS    HL1                    # OF DSCBS PER TRACK\nWAJFCB   DS    XL176\nDLTUD    DS    CL(LTUD)\nTUPTR001 DS    5F\nRBPTR    DS    F\nREQBLK   DS    CL(S99RBEND-S99RB)\nREQBLKLN EQU   L'REQBLK\nDEVWORD  DS    CL4\nUCBCOPY  DS    CL48\nTOKEN    DS    CL48\nSCANWRK  DS    CL100\n*\nFLAGBYTE DS    X\nVTOCREAD EQU   X'80'\nREADPDS  EQU   X'40'\nFILTVOL  EQU   X'20'\nFILTDSN  EQU   X'10'\nFILTVUP  EQU   X'08'\n*\nWCAMLST  DS    0F,190X\nWDSCBDSN DS    CL44\nWDSCBVOL DS    CL6\nWDSCBWA  DS    CL140\n*\nWORKMSG  DS    CL80\nWORKDSN  DS    CL56                 44DSN+(MEMBER)+2*'\n*\nWDIRBLK  DS    0CL264\nWDIRKEY  DS    CL8\nWDIRDATA DS    CL256\nWDIRUDL  DS    XL1\n*\nALLMSGS  DS    44CL32000\nLALLMSGS EQU   *-ALLMSGS\n*\nLDWORK   EQU   *-DWORK\n*\n         EJECT\n*\n         IEFZB4D0\n         IEFZB4D2\n*\nDSCB1    DSECT                        FORMAT1-DSCB PREFIX: CCHHRKDD\n         DS    0D                     ALIGN ON DOUBLEWORD-BNDRY\nF1DPCC   DS    H                      CC OF CURRENTLY READ VTOC-TRK\nF1DPHH   DS    H                      HH OF CURRENTLY READ VTOC-TRK\nF1DPR    DS    HL1                    R  OF CURRENTLY READ VTOC-TRK\nF1DPK    DS    HL1                    KEYLENGTH OF CURRENT DSCB\nF1DPDD   DS    H                      DATALENGTH OF CURRENT DSCB\n         IECSDSL1 (1)                 FORMAT-1 DSCB\nLDSCB1   EQU   *-DSCB1\n*\nDSCB4    DSECT                        FORMAT4-DSCB PREFIX: CCHHRKDD\n         DS    0D                     ALIGN ON DOUBLEWORD-BNDRY\nF4DPCC   DS    H                      CC OF CURRENTLY READ VTOC-TRK\nF4DPHH   DS    H                      HH OF CURRENTLY READ VTOC-TRK\nF4DPR    DS    XL1                    R  OF CURRENTLY READ VTOC-TRK\nF4DPK    DS    XL1                    KEYLENGTH OF CURRENT DSCB\nF4DPDD   DS    H                      DATALENGTH OF CURRENT DSCB\nF4DVTOC  DS    XL44                   'DSN' OF VTOC, NOT MAPPED BY F4\n         IECSDSL1 (4)\nLDSCB4   EQU   *-DSCB4\n         IHAPSA\n         IKJTCB DSECT=YES\n         IEFTIOT1\n         PRINT GEN\n         IEZIOB\n         PRINT NOGEN\n         IEFUCBOB\n         IKJCPPL\n         IKJIOPL\n         DSECT\n         IEFJFCBN                      SYS1.MODGEN\n         DCBD  DSORG=XE,DEVD=DA        SYS1.MACLIB\n         CVT   DSECT=YES\n         END   QVTOC\n/*\n//SYSLIB    DD DISP=SHR,DSN=SA1T.T750K.CBTFILE.CNTL\n//          DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSLIN    DD DSN=&&OBJ,UNIT=SYSDA,DISP=(NEW,PASS),\n//          SPACE=(3200,(200,50)),DCB=(RECFM=FB,BLKSIZE=3200,LRECL=80)\n//SYSPRINT  DD SYSOUT=*,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=3990)\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//*\n//* =====================================================\n//* ===== L I N K A G E   E D I T O R ===================\n//* =====================================================\n//LKED      EXEC PGM=HEWL,REGION=1024K,COND=(0,NE),\n//          PARM='XREF,LIST,RENT,REUS'\n//SYSLMOD   DD DISP=SHR,DSN=SA1T.T750K.CBTFILE.LOAD\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(10,3))\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD DSN=&&OBJ,DISP=(OLD,DELETE)\n//          DD *\n  NAME    QVTOC(R)\n/*\n//TESTRC IF (RC EQ 87) THEN\n//*                             CHANGE RC TO \"0\" TO LET QVTOC RUN\n//SCHTEPP3   EXEC PGM=IKJEFT01,REGION=8M,PARM='QVTOC'\n//STEPLIB  DD  DISP=SHR,DSN=SA1T.T750K.CBTFILE.LOAD\n//SYSPRINT DD  SYSOUT=*\n//SYSTSPRT DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//SORTIN DD   DSN=&&MEMBERS,DISP=(,PASS),UNIT=VIO,\n//            SPACE=(CYL,(1,3),RLSE),\n//            DCB=(LRECL=80,RECFM=FB,BLKSIZE=27920)\n//SORTOUT  DD SYSOUT=*,LRECL=80\n//SYSTSIN  DD  DUMMY\n//ACTTRACE DD  SYSOUT=*\n//DSNFILT   DD  *\n;  AIACCTB - TABLE\nKEYLEN=044,ARGLEN=007\n;  START OF DATA-PORTION\n**                                          ,PROCESS\nSYS%.LINK*                                  ,DROP\n**.LOAD*                                    ,PROCESS\n;---+----1----+----2----+----3----+----4----+----5----+----6----+----7- --+----8\n/*\n//VOLFILT   DD  *\n;  AIACCTB - TABLE\nKEYLEN=006,ARGLEN=007\n;  START OF DATA-PORTION\n**    ,PROCESS\nDMS*  ,DROP\nWORK%%,DROP\n;---+----1----+----2----+----3----+----4----+----5----+----6----+----7- --+----8\n/*\n//*\n//ENDTEST ENDIF\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q522": {"ttr": 4613, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x00]\\x00]\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 93, "newlines": 93, "modlines": 0, "user": "TRAMSEI"}, "text": "//T750KY   JOB  (317,04,E1500K),'RAEMSY',\n//             CLASS=X,\n//             MSGCLASS=T,\n//             MSGLEVEL=(1,1),\n//             NOTIFY=&SYSUID,\n//             REGION=8M,\n//             TIME=NOLIMIT\n//*\n//*MAIN SYSTEM=SYT\n//*\n//*\n//ASM      EXEC PGM=ASMA90,REGION=2048K,\n//          PARM='NODECK,OBJECT,RENT'\n//SYSIN     DD *\n***********************************************************************\n* Q522                                                                *\n* =====                                                               *\n***********************************************************************\nQ522     TITLE '*** \"Q522\" *** TSO COMMAND PROCESSOR &SYSDATE'\n***********************************************************************\n*     START                                                           *\n***********************************************************************\nQ522     CSECT\nQ522     AMODE 31\nQ522     RMODE ANY\n         USING Q522,15\n         B     START-*(15)\n         DC    CL8'Q522'\n         DC    CL16' &SYSDATE &SYSTIME '\n         DC    CL8'RAEMSY'\nSTART    EQU   *\n         BAKR  14,0                  ESTABLISH LINKAGE-CONVENTIONS\n         LR    12,15                 LOAD TEMPORARY BASE TO MY BASE\n         DROP  15\n         USING Q522,12               TELL ASSEMBLER\n         L     2,PSAAOLD-PSA(0)      .A(ASCB)\n         USING ASCB,2                TELL ASSEMBLER\n         TM    ASCBRCTF,ASCBTOFF     .STORAGE REFERNCE BIT ALREADY OFF\n         BO    NOP0090               .(BO=YES, WE'RE DONE)\n         MODESET KEY=ZERO,MODE=SUP   .BEAM ME UP, SCOTTY\n         OI    ASCBRCTF,ASCBTOFF     .TURN STORAGE REFERENCE BIT OFF\n         MODESET KEY=NZERO,MODE=PROB      .BACK INTO PROBLEM MODE\n         DROP  2\nNOP0090  DS    0H\n         SLR   15,15                 SET RC=0\n         PR                          END Q522 + CLEANUP\n*\n         IHAPSA DSECT=YES\n         IHAASCB\n         END   Q522\n/*\n//SYSLIB    DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSLIN    DD DSN=&&OBJ,UNIT=SYSDA,DISP=(NEW,PASS),\n//          SPACE=(3200,(200,50)),DCB=(RECFM=FB,BLKSIZE=3200,LRECL=80)\n//SYSPRINT  DD SYSOUT=*,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=3990)\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(5,3))\n//*\n//* =====================================================\n//* ===== L I N K A G E   E D I T O R ===================\n//* =====================================================\n//LKED      EXEC PGM=HEWL,REGION=1024K,COND=(0,NE),\n//             PARM='XREF,LIST,LET,REUS,RENT'\n//SYSLMOD   DD DISP=SHR,DSN=SA1T.T750K.CBTFILE.LOAD\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(10,3))\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD DSN=&&OBJ,DISP=(OLD,DELETE)\n//          DD *\n  SETCODE AC(1)\n  NAME    Q522(R)\n/*\n//TESCHTRC IF (RC EQ 0) THEN\n//SCHTEPP3   EXEC PGM=IEBCOPY,REGION=8M\n//SYSPRINT DD  SYSOUT=*\n//DDI      DD  DISP=SHR,DSN=SA1T.T750K.CBTFILE.LOAD\n//DDO      DD  DISP=SHR,DSN=SYS2.USER.LINKLIB\n//SYSIN    DD  *\n  COPY INDD=((DDI,R)),OUTDD=DDO\n  S M=Q522\n/*\n//SCHTEPP4   EXEC PGM=IKJEFT01,REGION=8M\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  *\n  QCMD CMD=(F LLA,REFRESH),T=7\n/*\n//SCHTEPP3   EXEC PGM=IKJEFT01,REGION=8M\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  *\n  Q522\n/*\n//ENDTEST ENDIF\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TODPRINT": {"ttr": 4616, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x01\\xda\\x01\\xda\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 474, "newlines": 474, "modlines": 0, "user": "TRAMSEI"}, "text": "         MACRO\n         TODPRINT &TODADDR,                                            X\n               &WORKAREA=,                                             X\n               &OUTFORM='DD/MT/YYYY HH:MM:SS',                         X\n               &SHIFT=YES,                                             X\n               &CAPS=OFF,                                              X\n               &PRF=$TOD\n         AGO   .X0000\n*/********************************************************************/\n*/*                                                                  */\n*/*  TODPRINT MACRO:                                                 */\n*/*  MAKE ANY VALID DATE, PASSED IN TOD-FORMAT, PRINTABLE.           */\n*/*                                                                  */\n*/*  PARAMETERS:                                                     */\n*/*  -----------                                                     */\n*/*  FIRST IS POSITIONAL: A FULLWORD OR REGISTER CONTAINING THE      */\n*/*                       ADDRESS OF A DOUBLEWORD CONTAINING TOD     */\n*/*  DEFAULT:             NONE                                       */\n*/*                                                                  */\n*/*  WORKAREA=          : A FULLWORD OR REGISTER CONTAINING THE      */\n*/*                     : ADDRESS OF A 256-BYTE WORKAREA. THIS PARA- */\n*/*                       METER IS MANDATORY.           .            */\n*/*  DEFAULT:             NONE                                       */\n*/*                                                                  */\n*/*  SHIFT=             : OPTIONAL PARAMETER, INDICATES WHETHER THE  */\n*/*                       CALCULATED VALUES FOR WHOLEDAY AND MONTH   */\n*/*                       ARE SHIFTED (YES) OR NOT (NO)              */\n*/*  DEFAULT:             SHIFT=YES                                  */\n*/*                                                                  */\n*/*  CAPS=              : OPTIONAL PARAMETER, INDICATES WHETHER THE  */\n*/*                       DAY- MONTH- AND ALPHA-DAYS SHOULD BE RE-   */\n*/*                       TURNED IN MIXED CASE (OFF) OR IN CAPS(ON)  */\n*/*  DEFAULT:             CAPS=OFF                                   */\n*/*                                                                  */\n*/*  PRF=               : OPTIONAL PARAMETER, CONTAINING THE LABEL-  */\n*/*                       PREFIX TO BE GENERATED. TODPRINT-LABELS    */\n*/*                       ARE UNIQUE AT EVERY CALL (VIA &SYSNDX),    */\n*/*                       BUT IF THE DEFAULT SHOULD CONFLICT WITH    */\n*/*                       YOUR CONVENTIONS, SET DESIRED VALUE TO     */\n*/*                       OVERRIDE.                                  */\n*/*  DEFAULT:             PRF=$TOD                                   */\n*/*                                                                  */\n*/*  OUTFORM=           : DESIRED OUTPUTFORMAT. FOLLOWING PARAMETERS */\n*/*                       CAN BE USED IN ANY ORDER                   */\n*/*                       YY OR YEAR: 2 OR 4 DIGIT YEAR              */\n*/*                       MT,MON OR MONTH: 2 DIGIT, 3 OR 9 CHAR MONTH*/\n*/*                       DAY OR WHOLEDAY: 3 OR 9 CHARACTER DAY      */\n*/*                       DD OR ANDAY      2 DIGIT OR ALPHANUM (1ST) */\n*/*                       JUL              3 DIGIT JULIAN DAY        */\n*/*                       HH: 2 DIGIT HOUR                           */\n*/*                       MM: 2 DIGIT MINUTES                        */\n*/*                       SS: 2 DIGIT SECONDS                        */\n*/*                       STAMP(X): DEPTH OF FRACTIONS OF A SECOND,  */\n*/*                       FROM 1 (1/10 OF SECONDS) TO 6 (MICROSEC.)  */\n*/*  DEFAULT:             OUTFORM='DD/MT/YYYY HH:MM:SS'              */\n*/*                                                                  */\n*/*  PADDING CHARACTERS CAN BE ENTERED AFTER EACH PART OF DATE       */\n*/*                                                                  */\n*/*  E.G:  TODPRINT (R2),OUTFORM='WHOLEDAY,DD/MON/YYYY HH:MM:SS',    */\n*/*              WORKAREA=@WAREA,SHIFT=YES                           */\n*/*  MIGHT RETURN:  FRIDAY,19/DEC/1997 12:00:15                      */\n*/*                                                                  */\n*/*  REGISTER-CONTENTS AT RETURN:   REG. 15 CONTAINS 0, THE OTHER    */\n*/*           REGISTERS SAME AS ON ENTRY                             */\n*/*                                                                  */\n*/*  WORKAREA-CONTENTS AT RETURN:                                    */\n*/*           A HALFWORD CONTAINING THE LENGTH OF THE RESULT WITHOUT */\n*/*           ITS OWN LENGTH FOLLOWED BY THE RESULT.                 */\n*/*                                                                  */\n*/*  THE MACRO TODPRINT IS REENTRANT.                                */\n*/*                                                                  */\n*/*  C A U T I O N  ||| THIS MACRO CONTAINS LOWERCASE CHARACTERS ||| */\n*/*  --------------------------------------------------------------- */\n*/*                                                                  */\n*/********************************************************************/\n.X0000   ANOP                      .SET LOCAL VARIABLES\n&A       SETA  &SYSNDX             .LABEL/FIELD NAME INDEX\n&LEN     SETA  K'&OUTFORM          .LENGTH OF OUTFORM-PARAMETER\n         LCLA  &I                  .CURRENT POSITION IN OUTFORM-PARM\n         LCLA  &J                  .COUNTER TO PREVENT DUPLICATE LABELS\n&I       SETA  1                   .INITIALIZE OUTFORM-POINTER\n&J       SETA  0                   .INITIALIZE DUMMY-COUNTER\n&S       SETC  '1'                 .GRANULARITY OF THE STAMP()-PARM\n.X0001   ANOP                      .START PARAMETER CHECKS\n         AIF   ((K'&PRF GE 1) AND (K'&PRF LE 8)).X0003\n         MNOTE 12,'PREFIX ''PRF='' MUST BE BETWEEN 1 AND 8 CHARACTERS IX\n               N LENGTH'\n         MEXIT                     .TERMINATE MACRO\n.X0003   ANOP                      .START PARAMETER CHECKS\n         AIF   (T'&WORKAREA NE 'O').X0005     .GOT ADDRESS, PROCESS\n         MNOTE 12,'PARAMETER ''WORKAREA='' IS MANDATORY'\n         MEXIT                     .TERMINATE MACRO\n.X0005   ANOP                      .CHECK WHETHER REG. OR ADDRESS GOT\n         AIF   ('&WORKAREA'(1,1) NE '(').X0005A       .NOT IN PARS.\n         LR    15,&WORKAREA        .MUST BE REGISTER\n         AGO   .X0010              .BUMP OVER LOAD\n.X0005A  ANOP                      .NOT A REGISTER, MUST BE AN ADDRESS\n         L     15,&WORKAREA        .LOAD A(WORKAREA)\n.X0010   ANOP                      .END OF WORKAREA-PARAMETER CHECKS\n         PUSH  USING               .SAVE USINGS AROUND MACRO\n         USING &PRF._DS10_&A.,15               .ADDRESS PASSED WORKAREA\n         XC    &PRF._DS10_&A.,&PRF._DS10_&A    .CLEAR IT OUT FOR USE\n         STM   1,5,&PRF._RSA_&A                .STORE USED REGISTERS\n         DROP  15                  .DROP DSECT AND ...\n         LR    4,15                .RELOAD WITH NEW BASE\n.*\n         AIF   (T'&TODADDR NE 'O').X0015       .GOT ADDRESS, PROCESS\n         MNOTE 12,'PARAMETER 1 (TOD-ADDRESS) IS MANDATORY'\n         MEXIT                     .TERMINATE MACRO\n.*\n.X0015   ANOP                      .CHECK TYPE OF TODADDR\n         AIF   ('&TODADDR'(1,1) NE '(').X0015A       .NOT IN PARS.\n         LR    5,&TODADDR          .MUST BE REGISTER\n         AGO   .X0020              .BUMP OVER LOAD\n.X0015A  ANOP                      .ADDRESS PASSED, DO NOT USE LR\n         L     5,&TODADDR          .LOAD A(TODCLOCK-DW)\n.X0020   ANOP                      .END OF WORKAREA-PARAMETER CHECKS\n.*\n         AIF   (('&SHIFT' EQ 'YES') OR ('&SHIFT' EQ 'NO')).X0025\n         MNOTE 12,' ''SHIFT='' MUST EITHER BE ''YES'' OR ''NO'' '\n         MEXIT\n.X0025   ANOP                      .END OF \"SHIFT=\" CHECKING\n.*\n         AIF   (('&CAPS' EQ 'ON') OR ('&CAPS' EQ 'OFF')).X0030\n         MNOTE 12,' ''CAPS='' MUST EITHER BE ''OFF'' OR ''ON'' '\n         MEXIT\n.X0030   ANOP                      .END OF PARAMETER-CHECKING\n.*\n         DSECT                     .PLACE DSECT HEREAFTER\n&PRF._DS10_&A DSECT                .VARIABLE NAME FOR MULTIPLE CALLS\n         DS  0F                    .ALIGN STORAGE\n&PRF._LRS_&A DS H                  .LENGTH OF ANSWER\n&PRF._RES_&A DS CL132              .RESULT-AREA\n&PRF._RSA_&A DS 5F                 .REGISTER-SAVEAREA\n&PRF._R14_&A DS F                  .SAVE-AREA FOR R14\n&PRF._R1A_&A DS CL16               .RESULT-AREA OF 1ST STCKCONV-CALL\n&PRF._R2A_&A DS CL16               .RESULT-AREA OF 2ND STCKCONV-CALL\n&PRF._MFL_&A DS CL(&PRF.L_STCK_&A)             .STCKCONV MF=L WORKAREA\n&PRF._PWF_&A DS PL4                .WORKFIELD FOR PACKED DATA\n&PRF._DW_&A DS D                   .DOUBLE-WORD FOR CVB-INSTRUCTIONS\n&PRF._WDIV_&A DS F                 .FOR LEAP YEAR CALCULATION\n&PRF._WEDM_&A DS CL8               .WORFIELD FOR THE EDIT-MASK\n.*\n&PRF.L_DS10_&A EQU 256-(*-&PRF._DS10_&A)       .REMAINING LENGTH OF DS\n&PRF._PHOLD_&A DS CL(&PRF.L_DS10_&A)           .PLACEHOLDER TO 256\n&SYSECT  CSECT                     .START CSECT HERE\n         L     15,=A(&PRF._&A.0010+X'80000000') .SWITCH AMODE TO 31\n         BASSM 14,15               .KEEP CALLERS AMODE IN R14\n&PRF._&A.0000 DS 0H                .CONSTANTS START HEREAFTER\n&PRF._&A.UC    DC XL9'404040404040404040'      .UPPER-CHARACTERS\n&PRF._&A.EDM   DC XL8'F020202020202020'        .EDIT-MASK\n&PRF._&A.DSF   DC CL28'01st02nd03rd21st22nd23rd31st'   .NON-\"TH\"-DAYS\n&PRF._&A.DTAB DS 0H                .DAY-LENGTH + DAYNAME TABLE\n         DC    XL1'06',CL9'Sunday   '\n         DC    XL1'06',CL9'Monday   '\n         DC    XL1'07',CL9'Tuesday  '\n         DC    XL1'09',CL9'Wednesday'\n         DC    XL1'08',CL9'Thursday '\n         DC    XL1'06',CL9'Friday   '\n         DC    XL1'08',CL9'Saturday '\n&PRF._&A.MTAB DS 0H                .MONTH-LENGTH + MONTHNAME TABLE\n         DC    XL1'07',CL9'January  '\n         DC    XL1'08',CL9'February '\n         DC    XL1'05',CL9'March    '\n         DC    XL1'05',CL9'April    '\n         DC    XL1'03',CL9'May      '\n         DC    XL1'04',CL9'June     '\n         DC    XL1'04',CL9'July     '\n         DC    XL1'06',CL9'August   '\n         DC    XL1'09',CL9'September'\n         DC    XL1'07',CL9'October  '\n         DC    XL1'08',CL9'November '\n         DC    XL1'08',CL9'December '\n.*\n&PRF._STCK_&A STCKCONV MF=L        .STCKCONV MF=L\n&PRF.L_STCK_&A EQU *-&PRF._STCK_&A .LENGTH OF STCKCONV\n.*\n&PRF._&A.0010 DS 0H                .NOW AMODE=31 IS ACTIVE\n         USING &PRF._DS10_&A.,4    .ADDRESS DSECT + TELL ASSEMBLER\n         MVC   &PRF._MFL_&A.(&PRF.L_STCK_&A.),&PRF._STCK_&A .MF=L\n         ST    14,&PRF._R14_&A     .SAVE R14 AROUND STCKCONV\n.* STCKCONV 1ST RUN TO GET DATEFORM DDMMYYYY\n         STCKCONV TIMETYPE=DEC,                .TYPE OF TIME-RESULT    X\n               STCKVAL=(5),                    .A(TODCLOCK)            X\n               CONVVAL=&PRF._R1A_&A,           .A(RESULT AREA #1)      X\n               DATETYPE=DDMMYYYY,              .FORM OF DATE IN RESULT X\n               MF=(E,&PRF._MFL_&A)             .USE EXECUTE-FORM\n.*\n         MVC   &PRF._MFL_&A.(&PRF.L_STCK_&A.),&PRF._STCK_&A\n.* STCKCONV 2ND RUN TO GET DATEFORM YYYYDDD\n         STCKCONV TIMETYPE=DEC,                .TYPE OF TIME-RESULT    X\n               STCKVAL=(5),                    .A(TODCLOCK)            X\n               CONVVAL=&PRF._R2A_&A,           .A(RESULT AREA #1)      X\n               DATETYPE=YYYYDDD,               .FORM OF DATE IN RESULT X\n               MF=(E,&PRF._MFL_&A)             .USE EXECUTE-FORM\n.*\n&PRF._&A.0100 DS 0H                .START COMPOSING RESULT-STRING\n         LA    5,&PRF._RES_&A      .A(RESULT-AREA)\n         AIF   ('&OUTFORM'(1,1) NE '''').LUP1  .BUMP IF NOT QUOTED\n&LEN     SETA  &LEN-2              .SUBTRACT 2 FOR QUOTES\n&I       SETA  &I+1                .START BEHIND LEFT QUOTE\n.LUP1    ANOP                      .LOOP THROUGH OUTFORM-STRING\n         AIF   (('&OUTFORM'(&I,5) NE 'MONTH') AND ('&OUTFORM'(&I,3) NE X\n               'MON')).LUP0020     .IS IT MONTH OR MON?\n         XR    2,2                 .YES, CLEAR WORKREG\n         MVI   &PRF._DW_&A+7,X'0C'           .MOVE SIGN AT THE END\n         MVO   &PRF._DW_&A,&PRF._R1A_&A+9(1) .MAKE MONTH PACKED\n         CVB   2,&PRF._DW_&A       .MAKE IT COMPUTABLE\n         BCTR  2,0                 .SUBTRACT 1 (MON 1 IS POS 0 IN TAB)\n         MH    2,=H'10'            .MULTIPLY WITH LENGTH OF TAB-ENTRY\n         LA    3,&PRF._&A.MTAB     .A(START OF MONTH-TABLE)\n         AR    2,3                 .COMPUTE ADDRESS OF MONTH IN TABLE\n         LA    1,3                 .ASSUME 'MON' NOT MONTH IS REQUESTED\n         AIF   ('&OUTFORM'(&I,5) NE 'MONTH').LUP0005  .TRUE BUMP TO EX.\n         LA    1,9                 .ASSUME \"SHIFT=NO\" IS SET\n         AIF   ('&SHIFT' EQ 'NO').LUP0005      .TRUE, BUMP OVER EXECUTE\n         XR    1,1                 .CLEAR WORKREG\n         ICM   1,B'0001',0(2)      .INSERT LENGTH OF MONTHNAME\n.LUP0005 ANOP                      .END OF SHIFT NO/YES SPECIFICS\n         BCTR  1,0                 .SUBTRACT 1 FOR EXECUTE\n         EX    1,&PRF._&A.EX01     .WRITE MONTHNAME INTO RESULT-AREA\n         AIF   ('&CAPS' EQ 'OFF').LUP0008    .NO CAPS BUMP OVER EX'UTE\n         EX    1,&PRF._&A.OC01     .MAKE MONTHNAME UPPERCASE\n.LUP0008 ANOP\n         LA    1,1(,1)             .INCREASE WORKREG AFTER EXECUTE\n         AR    5,1                 .A(NEXT FREE SLOT IN ANSWERAREA)\n         AIF   ('&OUTFORM'(&I,5) NE 'MONTH').LUP0010  .BUMP IF MON\n&I       SETA  &I+5                .BUMP BEHIND \"MONTH\" IN OUTFORM\n         AGO   .LUP0015\n.LUP0010 ANOP                      .IF MON, NOT MONTH SPECIFIED\n&I       SETA  &I+3                .ADD LENGTH OF MON\n.LUP0015 ANOP\n         AIF   (&I LE &LEN).LUP1   .END OF OUTFORM REACHED ?\n         AGO   .ENDLUP1            .YES, LEAVE OUTFORM-LOOP\n.*\n.LUP0020 ANOP                      .CHECK 2-DIGIT MONTH SPECIFIED\n         AIF   ('&OUTFORM'(&I,2) NE 'MT').LUP0030  .IS IT MT ?\n         XC    &PRF._PWF_&A.,&PRF._PWF_&A    .CLEAR OUT PACKED WORKAREA\n         MVI   &PRF._PWF_&A+3,X'0C'          .YES, PREPARE PACKED-WA\n         MVO   &PRF._PWF_&A,&PRF._R1A_&A+9(1) .MAKE MONTH PACKED\n         MVC   &PRF._WEDM_&A.(8),&PRF._&A.EDM .MOVE EDITMASK IN WA\n         ED    &PRF._WEDM_&A.(8),&PRF._PWF_&A .EDIT 2-DIGIT MONTH\n         MVC   0(2,5),&PRF._WEDM_&A+6        .WRITE INTO ANSWER-AREA\n         LA    1,2                 .LENGTH OF 2-DIGIT MONTH\n         AR    5,1                 .A(NEXT FREE SLOT IN ANSWERAREA)\n&I       SETA  &I+2                .ADD LENGTH OF MT IN OUTFORM\n         AIF   (&I LE &LEN).LUP1   .END OF OUTFORM REACHED ?\n         AGO   .ENDLUP1            .YES, LEAVE OUTFORM-LOOP\n.*\n.LUP0030 ANOP                      .CHECK WHETHER YEAR OR YY SPECIFIED\n         AIF   (('&OUTFORM'(&I,4) NE 'YEAR') AND ('&OUTFORM'(&I,2) NE 'X\n               YY')).LUP0050       .IS IT YEAR OR YY ?\n         XC    &PRF._PWF_&A.,&PRF._PWF_&A    .CLEAR OUT PACKED WORKAREA\n         MVI   &PRF._PWF_&A+3,X'0C'          .YES, INIT PACKED WA\n         MVO   &PRF._PWF_&A,&PRF._R1A_&A+10(2) .PACK 4-DIGIT YEAR\n         MVC   &PRF._WEDM_&A.(8),&PRF._&A.EDM .INIT EDIT-MASK\n         ED    &PRF._WEDM_&A.(8),&PRF._PWF_&A .EDIT 4-DIGIT YEAR\n         AIF   ('&OUTFORM'(&I,4) NE 'YEAR').LUP0040   .BUMP IF JUST YY\n         MVC   0(4,5),&PRF._WEDM_&A+4        .MOVE YEAR INTO RESULT\n         LA    1,4                 .LENGTH OF YEAR\n         AR    5,1                 .A(NEXT FREE SLOT IN ANSWERAREA)\n&I       SETA  &I+4                .ADD LENGTH OF YEAR IN OUTFORM\n         AGO   .LUP0045            .BUMP OVER YY-SECTION\n.LUP0040 ANOP                      .YY SPECIFIED\n         MVC   0(2,5),&PRF._WEDM_&A+6        .YEAR+2 IN OUTFORM\n         LA    1,2                 .LENGTH OF YY\n         AR    5,1                 .A(NEXT FREE SLOT IN ANSWERAREA)\n&I       SETA  &I+2                .ADD LENGTH OF YY IN OUTFORM\n.LUP0045 ANOP\n         AIF   (&I LE &LEN).LUP1   .END OF OUTFORM REACHED ?\n         AGO   .ENDLUP1            .YES, LEAVE OUTFORM-LOOP\n.*\n.LUP0050 ANOP\n         AIF   (('&OUTFORM'(&I,2) NE 'DD') AND ('&OUTFORM'(&I,5) NE 'ANX\n               DAY')).LUP0060      .DD OR ANDAY REQUESTED ?\n&J       SETA  &J+1                .INC. DUMMYCOUNTER FOR MULTIPLE CALL\n         XC    &PRF._PWF_&A.,&PRF._PWF_&A .CLEAR OUT PACKED WORKAREA\n         MVI   &PRF._PWF_&A+3,X'0C'       .YES, INIT PACKED WA\n         MVO   &PRF._PWF_&A,&PRF._R1A_&A+8(1)     .MAKE DD PACKED\n         MVC   &PRF._WEDM_&A.(8),&PRF._&A.EDM     .PREPARE FOR EDIT\n         ED    &PRF._WEDM_&A.(8),&PRF._PWF_&A     .EDIT DD\n         MVC   0(2,5),&PRF._WEDM_&A+6             .MOVE INTO RESULTAREA\n         AIF   ('&OUTFORM'(&I,5) NE 'ANDAY').LUP0055  .ANDAY REQ'ED ?\n         LA    1,&PRF._&A.DSF      .YES, COMPUTE APPENDIX\n         LA    2,7                 .NUMBER OF NON-\"TH\"-DAYS\n&PRF._&A.LUP&J DS 0H               .3D-LABEL FOR MULTIPLE CALLS/MACRO\n         CLC   0(2,5),0(1)         .DO WE HAVE A \"SPECIAL-APPENDIX\" ?\n         BE    &PRF._&A.012&J      .YES, WRITE IT THEREAFTER\n         LA    1,4(,1)             .NO ADDRESS NEXT SPECIAL APPENDIX\n         BCT   2,&PRF._&A.LUP&J    .RETRY\n         MVC   2(2,5),=CL2'th'     .NOT A SPECIAL APPENDIX, USE \"th\"\n         B     &PRF._&A.013&J      .BUMP OVER SPECIAL APPENDIX\n&PRF._&A.012&J DS 0H\n         MVC   2(2,5),2(1)         .MOVE \"st\", \"nd\" OR \"rd\" THEREAFTER\n&PRF._&A.013&J DS 0H\n         CLI   0(5),C'0'           .IS ANDAY > 10 ?\n         BNE   &PRF._&A.015&J      .NO, GO AHEAD\n         MVI   0(5),C' '           .YES, REMOVE LEADING ZERO OF ANDAY\n&PRF._&A.015&J DS 0H\n         AIF   ('&CAPS' EQ 'OFF').LUP0053    .NO CAPS BUMP OVER EX'UTE\n         OC    2(2,5),&PRF._&A.UC            .MAKE DAY-APPENDIX UPPER\n.LUP0053 ANOP                      .DD SPECIFIED\n         LA    1,4                 .LENGTH OF ANDAY IN RESULTAREA\n         AR    5,1                 .A(NEXT FREE SLOT IN RESULTAREA)\n&I       SETA  &I+5                .LENGTH OF ANDAY IN OUTFORM\n         AGO   .LUP0058            .BUMP OVER DD-SECTION\n.LUP0055 ANOP                      .DD SPECIFIED\n         LA    1,2                 .LENGTH OF DD IN RESULTAREA\n         AR    5,1                 .A(NEXT FREE SLOT IN RESULTAREA)\n&I       SETA  &I+2                .LENGTH OF DD IN OUTFORM\n.LUP0058 ANOP\n         AIF   (&I LE &LEN).LUP1   .END OF OUTFORM REACHED ?\n         AGO   .ENDLUP1            .YES, LEAVE OUTFORM-LOOP\n.*\n.LUP0060 ANOP\n         AIF   (('&OUTFORM'(&I,8) NE 'WHOLEDAY') AND ('&OUTFORM'(&I,3) X\n               NE 'DAY')).LUP0070  .WHOLEDAY OR DAY SPECIFIED ?\n         XC    &PRF._DW_&A.,&PRF._DW_&A      .CLEAR OUT WORK-DOUBLEWORD\n         MVI   &PRF._DW_&A+7,X'0C'           .PACK IT\n         MVO   &PRF._DW_&A,&PRF._R1A_&A+10(2) .MOVE YEAR THERE\n         XR    1,1                 .CLEAR OUT WORKREG # 1\n         CVB   1,&PRF._DW_&A       .MAKE YEAR HEX + COMPUTABLE\n         BCTR  1,0                 .SUBTRACT 1 FOR CURRENT YEAR\n         XR    2,2                 .CLEAR OUT WORKREG # 2\n         ST    1,&PRF._WDIV_&A     .STORE R1 AROUND DIVISION\n         XR    0,0                 .CLEAR REMAINDER\n         D     0,=F'4'             .DIVIDE BY 4\n         AR    2,1                 .ADD #OF LEAP YEARS W/O SPECIALS\n         L     1,&PRF._WDIV_&A     .RELOAD \"LAST\" YEAR\n         XR    0,0                 .CLEAR REMAINDER\n         D     0,=F'100'           .DIVIDE BY 100 (NO LEAP-YEARS)\n         SR    2,1                 .SUBTRACT /100 YEARS FROM TOTAL\n         XR    0,0                 .CLEAR REMAINDER\n         L     1,&PRF._WDIV_&A     .RELOAD \"LAST\" YEAR\n         D     0,=F'400'           .DIVIDE BY 400 (IF 400, LEAPYEAR)\n         AR    2,1                 .ADD THEM to TOTAL #OF LEAPYEARS\n.* END OF LEAP-YEAR CALCULATION:\n         L     1,&PRF._WDIV_&A     .RELOAD \"LAST\" YEAR\n         MH    1,=H'365'           .365 DAYS * (YEAR-1)\n         AR    1,2                 .ADD # OF LEAP-YEARS\n         XC    &PRF._DW_&A.,&PRF._DW_&A      .CLEAR OUT WORK-DOUBLEWORD\n         MVI   &PRF._DW_&A+7,X'0C'           .MOVE SIGN AT THE END\n         MVO   &PRF._DW_&A,&PRF._R2A_&A+10(2) .MAKE DDD PACKED\n         NI    &PRF._DW_&A+5,X'F0'           .REMOVE LAST DIGIT OF YEAR\n         XR    3,3                 .CLEAR BEFORE CVB\n         ICM   3,15,&PRF._DW_&A+4  .INSERT PACKED DEC. DAYS OF YEAR\n         CVB   3,&PRF._DW_&A       .CONVERT THEM FOR DIVISION\n         AR    1,3                 .ADD DAY OF YEAR TO 31.12.YYYY-1\n         XR    0,0                 .CLEAR R0 FOR DIVISION\n         D     0,=F'7'             .DIVIDE BY # OF DAYS/WEEK\n         LA    2,&PRF._&A.DTAB     .REMAINDER IS OFFSET IN DAY-TABLE\n         MH    0,=H'10'            .LENGTH OF A DAY-ENTRY\n         AR    2,0                 .A(CURRENT ENTRY IN DAYTAB)\n         AIF   ('&OUTFORM'(&I,3) EQ 'DAY').LUP0065  .3-CHAR FORM, BUMP\n         LA    1,9                 .ASSUME SHIFT=NO SPECIFIED\n         AIF   ('&SHIFT' EQ 'NO').LUP0062    .BINGO, WRITE RESULT\n         XR    1,1                 .CLEAR WORKREG\n         ICM   1,B'0001',0(2)      .INSERT LENGTH OF CURRENT DAY\n.LUP0062 ANOP\n         BCTR  1,0                 .SUBTRACT 1 FOR EXECUTE\n         EX    1,&PRF._&A.EX01     .WRITE WHOLEDAY INTO ANSWERAREA\n         AIF   ('&CAPS' EQ 'OFF').LUP0064    .NO CAPS BUMP OVER EX'UTE\n         EX    1,&PRF._&A.OC01     .MAKE DAYNAME UPPERCASE\n.LUP0064 ANOP\n         LA    1,1(,1)             .RELOAD ORIGINAL LENGTH\n         AR    5,1                 .A(NEXT FREE SLOT IN ANSWER-AREA)\n&I       SETA  &I+8                .LENGTH WHOLEDAY IN OUTFORM\n         AGO   .LUP0068            .BUMP OVER DAY-SECTION\n.LUP0065 ANOP                      .JUST DAY SPECIFIED, LENGTH IS 3\n         LA    1,2                 .3-1 FOR EXECUTE\n         EX    1,&PRF._&A.EX01     .WRITE DAY INTO ANSWER-AREA\n         AIF   ('&CAPS' EQ 'OFF').LUP0066    .NO CAPS BUMP OVER EX'UTE\n         EX    1,&PRF._&A.OC01     .MAKE DAYNAME UPPERCASE\n.LUP0066 ANOP\n         LA    1,1(,1)             .RELOAD ORIGINAL LENGTH\n         AR    5,1                 .A(NEXT FREE SLOT IN ANSWER-AREA)\n&I       SETA  &I+3                .LENGTH DAY IN OUTFORM\n.LUP0068 ANOP\n         AIF   (&I LE &LEN).LUP1   .END OF OUTFORM REACHED ?\n         AGO   .ENDLUP1            .YES, LEAVE OUTFORM-LOOP\n.*\n.LUP0070 ANOP\n         AIF   ('&OUTFORM'(&I,3) NE 'JUL').LUP0080   .JULIAN DAY\n         XC    &PRF._PWF_&A.,&PRF._PWF_&A    .CLEAR OUT PACKED WORKAREA\n         MVI   &PRF._PWF_&A+3,X'0C'          .INITIALIZE IT\n         MVO   &PRF._PWF_&A,&PRF._R2A_&A+10(2) .PACK YDDD\n         NI    &PRF._PWF_&A+1,X'F0'          .REMOVE LAST DIGIT OF YEAR\n         MVC   &PRF._WEDM_&A.(8),&PRF._&A.EDM .INIT EDIT-MASK\n         ED    &PRF._WEDM_&A.(8),&PRF._PWF_&A .EDIT JULIAN DAYS\n         MVC   0(3,5),&PRF._WEDM_&A+5        .WRITE DDD IN RESULTAREA\n         LA    1,3                 .LENGTH OF JUL IN RESULTAREA\n         AR    5,1                 .A(NEXT FREE SLOT IN ANSWER-AREA)\n&I       SETA  &I+3                .LENGTH JUL IN OUTFORM\n         AIF   (&I LE &LEN).LUP1   .END OF OUTFORM REACHED ?\n         AGO   .ENDLUP1            .YES, LEAVE OUTFORM-LOOP\n.LUP0080 ANOP\n         AIF   (('&OUTFORM'(&I,2) NE 'HH') AND ('&OUTFORM'(&I,2) NE 'MMX\n               ') AND ('&OUTFORM'(&I,2) NE 'SS')).LUP0110\n         XC    &PRF._PWF_&A.,&PRF._PWF_&A  .CLEAR OUT PACKED WORKAREA\n         MVI   &PRF._PWF_&A+3,X'0C'            .INITIALIZE WORKAREA\n         MVO   &PRF._PWF_&A,&PRF._R1A_&A.(3)   .MAKE HHMMSS PACKED\n         MVC   &PRF._WEDM_&A.(8),&PRF._&A.EDM  .INIT EDIT-MASK\n         ED    &PRF._WEDM_&A.(8),&PRF._PWF_&A  .EDIT HHMMSS\n         AIF   ('&OUTFORM'(&I,2) NE 'HH').LUP0090  .IS IT HH ?\n         MVC   0(2,5),&PRF._WEDM_&A+2          .YES, MOVE HH IN RESULT\n         AGO   .LUP0105                        .BUMP OVER MM OR SS\n.LUP0090 ANOP\n         AIF   ('&OUTFORM'(&I,2) NE 'MM').LUP0100  .IS IT MM ?\n         MVC   0(2,5),&PRF._WEDM_&A+4          .YES, MOVE MM IN RESULT\n         AGO   .LUP0105                        .BUMP OVER SS\n.LUP0100 ANOP\n         MVC   0(2,5),&PRF._WEDM_&A+6          .MUST BE SS, MOVE IT\n.LUP0105 ANOP\n         LA    1,2                 .LENGTH OF RESULT\n         AR    5,1                 .A(NEXT FREE SLOT IN RESULT-AREA\n&I       SETA  &I+2                .LENGTH HH OR MM OR SS IN OUTFORM\n         AIF   (&I LE &LEN).LUP1   .END OF OUTFORM REACHED ?\n         AGO   .ENDLUP1            .YES, LEAVE OUTFORM-LOOP\n.*\n.LUP0110 ANOP\n         AIF   ('&OUTFORM'(&I,6) NE 'STAMP(').LUP0120  .IS IT STAMP ?\n         AIF   ('&OUTFORM'(&I+7,1) NE ')').LUP0115     .VALUE > 10 ?\n&S       SETC  '&OUTFORM'(&I+6,1)            .NO, SAVE PASSED VALUE\n         AIF   (('&S' LT '1') OR ('&S' GT '6')).LUP0115  .BAD VALUE ?\n         XC    &PRF._PWF_&A.,&PRF._PWF_&A    .CLEAR OUT PACKED WORKAREA\n         MVI   &PRF._PWF_&A+3,X'0C'          .INIT PACKED WORKFIELD\n         MVO   &PRF._PWF_&A,&PRF._R1A_&A.+3(3) .PACK TIMESTAMP\n         MVC   &PRF._WEDM_&A.(8),&PRF._&A.EDM .INIT EDIT-AREA\n         ED    &PRF._WEDM_&A.(8),&PRF._PWF_&A .EDIT TIMESTAMP\n         LA    1,&S                .GRANULARITY OF TIMESTAMP\n         BCTR  1,0                 .SUBTRACT 1 FOR EXECUTE\n         EX    1,&PRF._&A.EX02     .WRITE INTO ANSWERAREA\n         LA    1,1(,1)             .RELOAD ORIGINAL GRANULARITY\n         AR    5,1                 .A(NEXT FREE SLOT IN RESULT-AREA\n&I       SETA  &I+8                .LENGTH OF STAMP(X) IN OUTFORM\n         AIF   (&I LE &LEN).LUP1   .END OF OUTFORM REACHED ?\n         AGO   .ENDLUP1            .YES, LEAVE OUTFORM-LOOP\n.LUP0115 ANOP                      .INVALID STAMP-VALUE FOUND\n         MNOTE 12,'STAMP MUST BE A VALUE BETWEEN 1 AND 6'\n         MEXIT                     .ISSUE ERROR-MSG AND LEAVE MACRO\n.LUP0120 ANOP                      .NO DATE OR TIME VALUE, MUST BE PAD\n&S       SETC  '&OUTFORM'(&I,1)    .EXTRACT PADDING CHARACTER\n         MVI   0(5),C'&S'          .WRITE PADDING-CHARACTER INTO RESULT\n         LA    1,1                 .LENGTH OF PADDING-CHAR\n         AR    5,1                 .A(NEXT FREE SLOT IN RESULT-AREA\n&I       SETA  &I+1                .LENGTH OF STAMP(X) IN OUTFORM\n         AIF   (&I LE &LEN).LUP1   .END OF OUTFORM REACHED ?\n         AGO   .ENDLUP1            .YES, LEAVE OUTFORM-LOOP\n.*\n.ENDLUP1 ANOP\n         LA    1,&PRF._RES_&A\n         SR    5,1\n         STH   5,&PRF._LRS_&A\n         LA    1,&PRF._DS10_&A\n         L     14,&PRF._R14_&A\n         LM    1,5,&PRF._RSA_&A\n         B     &PRF._&A.9900\n.*\n&PRF._&A.9000 DS 0H\n         XR    15,15                     .RC: 0; EXIT\n&PRF._&A.9900 DS 0H\n         DROP  4\n         AH    14,=Y(&PRF._&A.9999-&PRF._&A.0000)\n         BSM   0,14                      .RESTORE CALLERS AMODE\n.*\n         USING &PRF._DS10_&A.,4\n&PRF._&A.EX01 MVC 0(0,5),1(2)\n&PRF._&A.OC01 OC 0(0,5),&PRF._&A.UC      .MAKE UPPERCASE\n&PRF._&A.EX02 MVC 0(0,5),&PRF._WEDM_&A+2\n         LTORG\n.*\n&PRF._&A.9999 DS 0H\n         POP   USING               .RESTORE USINGS AFTER MACRO\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WORM": {"ttr": 4868, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x01\\xc5\\x01\\xc5\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 453, "newlines": 453, "modlines": 0, "user": "TRAMSEI"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "WORMP": {"ttr": 5121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x005\\x005\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "TRAMSEI"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "WORMPH": {"ttr": 5123, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x1f\\x01\\x00%\\x1f\\x12\\x05\\x00!\\x00!\\x00\\x00\\xe3\\xd9\\xc1\\xd4\\xe2\\xc5\\xc9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-07T00:00:00", "modifydate": "2000-09-07T12:05:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "TRAMSEI"}, "text": ")ATTR\n  01 TYPE(TEXT) CAPS(OFF) INTENS(HIGH) COLOR(WHITE)\n  02 TYPE(TEXT) CAPS(OFF) INTENS(HIGH) COLOR(BLUE)\n  }  TYPE(TEXT) CAPS(OFF) INTENS(HIGH) COLOR(RED)\n  04 TYPE(TEXT) CAPS(OFF) INTENS(HIGH) COLOR(GREEN)\n  05 TYPE(TEXT) CAPS(OFF) INTENS(HIGH) COLOR(PINK)\n  {  TYPE(TEXT) CAPS(OFF) INTENS(HIGH) COLOR(TURQ)\n  !  TYPE(TEXT) CAPS(OFF) INTENS(HIGH) COLOR(YELLOW)\n)BODY WINDOW(76,22) WIDTH(72) EXPAND(@@)\n% @ @ Battle - Find and \"kill\" the enemy's fleet  @ @ +\n%                                               +\n% To achieve this, just select a valid coordinate (A0-J9). The number +\n% and length of the hidden boats is shown in the top-right statistics. +\n% A hit is indicated by a}#x%, (x=boat-nbr.) a mishit by a}--%.\n% There is always at least one empty field beneath two different\n% boats. There are 4 possible directions how a boat can be placed.\n%                                               +\n% The more MUST-free fields you find out and remember, the less\n% number of attempts you will need.       +\n%                                            !4 possible directions:+\n%    {\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1               ----------------------+\n%    {\u00b3FF\u00b3#3\u00b3#3\u00b3#3\u00b3FF\u00b3??\u00b3??\u00b3??\u00b3 !#x%= Hit           }\u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af%  +\n%    {\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1 !FF%= MUST free     }\u00b3%\\ \u00ab /}\u00b3%  +\n%    {\u00b3FF\u00b3FF\u00b3FF\u00b3FF\u00b3FF\u00b3FF\u00b3??\u00b3??\u00b3 !??%= Unknown       }\u00b3% \\\u00b3/ }\u00b3%  +\n%    {\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1                     }\u00b3%\u00fa-*-\u00ff}\u00b3%  +\n%    {\u00b3??\u00b3??\u00b3??\u00b3FF\u00b3#8\u00b3FF\u00b3FF\u00b3??\u00b3                     }\u00b3% /\u00b3\\ }\u00b3%  +\n%    {\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1                     }\u00b3%/ \u00df \\}\u00b3%  +\n%    {\u00b3??\u00b3??\u00b3??\u00b3FF\u00b3FF\u00b3#8\u00b3FF\u00b3??\u00b3                     }\u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]%  +\n%    {\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\u00d7\u00d7\u00b1\n%                                               +\n% @ @ Have fun. +\n)INIT\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT483/FILE483.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT483", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}