{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012556000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE673.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE673.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\x06'", "DS1TRBAL": "b'f\"'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xbf\\x00\\n\\x04\\xbf\\x00\\r\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04A\\x00\\x00\\x01\\x04\\x10/\\x01\\x04\\x10/\\x16$\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf5@@@'", "ispf": {"version": "04.65", "flags": 0, "createdate": "2004-04-11T00:00:00", "modifydate": "2004-04-11T16:24:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-465"}, "text": "REGULAR CBT TAPE - VERSION 465    FILE:  673\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT465.FILE673\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   8 MEMBERS COUNTED; CUMULATIVE SIZE IS 808 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/11/04    16:24:38    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE1": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x04\\x10/\\x01\\x04\\x10/\\x12\\x13\\x00~\\x00\\x81\\x00\\x00\\xc3\\xc3\\xc6\\xe3\\xd3\\xe2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-04-11T00:00:00", "modifydate": "2004-04-11T12:13:31", "lines": 126, "newlines": 129, "modlines": 0, "user": "CCFTLS"}, "text": "\nhttp://bama.ua.edu/cgi-bin/wa?A2=ind0402&L=ibm-main&P=R82089&I=1\n\nDate:         Thu, 26 Feb 2004 08:45:30 -0500\nReply-To:     IBM Mainframe Discussion List <IBM-MAIN@BAMA.UA.EDU>\nSender:       IBM Mainframe Discussion List <IBM-MAIN@BAMA.UA.EDU>\nFrom:         Tom Sipusic <sipusic@GEORGETOWN.EDU>\nSubject:      Re: Incorrect JCL processing?\nIn-Reply-To:  <3718408C4D654A4D89223E69DC010CC65F3CEF@uicnrhechp3.uicnrh.dom>\nContent-Type: text/plain; charset=windows-1252; format=flowed\n\nHere is the documentation from a program, CCFDELET, which I wrote\nand which may address some of your programmers' objections,\nalthough maybe not the one about using more CPU time.  I just\nnever worried about that.  The original motivation for CCFDELET\nwas to avoid DFHSM recalls just to delete a data set.  I can give\nyou the source if you want.\n\nDo not use IEFBR14 to delete or uncatalog data sets, use the\ninhouse written program CCFDELET.  When you have a job step that\nwill allocate a new data set and you wish to avoid a JCL error\ncaused by an undeleted old version of it, you can use CCFDELET in\na prior step to check for old versions of the data set and delete\nthem if they exist.  Following are two examples of using the\nCCFDELET program to delete data sets.  The first example uses\nsysin control cards and would be placed in the jobstream being\nsubmitted (aka RUNJCL).  The second example would be used when\nsetting up a PROC because it avoids using control cards.\n\nJOBSTREAM Example:\n\n//STEP1 EXEC PGM=CCFDELET\n//SYSPRINT DD SYSOUT=*\n//SYSIN DD *\nCCF.DELETE.DSN1\nCCF.DELETE.DSN2\nCCF.DELETE.DSN3\n/*\n\nPROC Example:\n//STEP1 EXEC PGM=CCFDELET,PARM='CCF.DELETE.DSN1'\n//STEP2 EXEC PGM=CCFDELET,PARM='CCF.DELETE.DSN2'\n//STEP3 EXEC PGM=CCFDELET,PARM='CCF.DELETE.DSN3'\n\nAnother nice feature of CCFDELET is that data sets migrated by\nDFHSM are not recalled before they are deleted.  This is why the\nprogram IEFBR14 should not be used to delete or uncatalog data\nsets.  IEFBR14 would recall a data set that is migrated to tape\nand then delete the data set while CCFDELET tells DFHSM to delete\nthe data set without first recalling it.\n\nRestrictions:\n\nCCFDELET/IDCAMS cannot\ndelete a data set that is not catalogued.  It will assume the\ndata set does not exist and produce a return code of 0.\n\nCondition Codes:\n\nCCFDELET works by invoking the IBM utility\nIDCAMS to delete datasets.  The messages sent to SYSPRINT and the\ncondition code are produced by IDCAMS except that a condition\ncode 8 (which indicates that the data set did not exist) is\nchanged to a condition code of 0.  If the return code from a\nCCFDELET step is 0, this indicates that the data set has been\ndeleted or never existed.  Any other condition code indicates\nthat the data set might still exist and should be investigated.\n\nMcKown, John wrote:\n>>-----Original Message-----\n>>From: terry sambrooks \u00ddmailto:terry.sambrooks@BTCLICK.COM\u00a8\n>>Sent: Wednesday, February 25, 2004 10:55 AM\n>>To: IBM-MAIN@BAMA.UA.EDU\n>>Subject:  Re: Incorrect JCL processing?\n>>\n>>\n>>Hi John,\n>>\n>>Regarding your original post in respect of using\n>>DISP=(MOD,DELETE) to tidy up a data set which might or might\n>>not exist, and what are seen as vagaries of completion in\n>>respect of JCL Error or RACF stomp.\n>>\n>>Would I be out of line suggesting a switch to IDCAMS rather\n>>than IEFBR14 for the tidy up.  I am sure that you are aware\n>>that with IDCAMS a consistent activity can be achieved in\n>>that dynamic delete will not cause a JCL error, but will\n>>generate a RACF violation if authority levels are inappropriate.\n>>\n>>SET MAXCC can always be used to give a Cond Code zero\n>>irrespective so there need be no angst about incorrect return\n>>codes either,\n>>\n>>Just a thought if the aim is to avoid calls.\n>>\n>>Regards - Terry\n>>\n>>\n>\n>Would that the programmers would do\n>that.  They refuse.  I do not have the\n>authority to force them to.  Their,\n>reasonable, reason is that there is no\n>way to use JCL symbols to pass in\n>the DSN(s) to be deleted.  I say that they\n>could use a JCL symbol to select name\n>of a member containing the DSNs to\n>delete.  They respond that they would\n>then need to maintain two members - the\n>JCL and the associate IDCAMS sysin\n>member(s).  I point out a way to do it\n>using IKJEFT01 with a PARM='DEL &HLQ..rest.of.dsn'.\n>They point out that requires one step per DSN\n>and is much more processor intensive than a\n>simple IEFBR14.\n\nAnd so it goes.\n>\n>\n>\n\u00ddsnip\u00a8\n----------------------------------------------------------------------\nFor IBM-MAIN subscribe / signoff / archive access instructions,\nsend email to listserv@bama.ua.edu with the message:\nGET IBM-MAIN INFO Search the archives at\nhttp://bama.ua.edu/archives/ibm-main.html\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$TOC": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x12\\x01\\x04\\t_\\x01\\x04\\t_\\x11)\\x00\\x06\\x00\\x01\\x00\\x00\\xc3\\xc3\\xc6\\xe3\\xd3\\xe2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-04-04T00:00:00", "modifydate": "2004-04-04T11:29:12", "lines": 6, "newlines": 1, "modlines": 0, "user": "CCFTLS"}, "text": "                           Table of Contents\n\n$README  --  Notes and Comments\n$USERDOC --  Sample User Guide\nASMJCL   --  Sample Assemble and Link JCL\nCCFDELET --  The Source Code\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$README": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x03\\x01\\x04\\t_\\x01\\x04\\x10/\\x086\\x00%\\x00\\x01\\x00\\x00\\xc3\\xc3\\xc6\\xe3\\xd3\\xe2@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2004-04-04T00:00:00", "modifydate": "2004-04-11T08:36:03", "lines": 37, "newlines": 1, "modlines": 0, "user": "CCFTLS"}, "text": "                            Notes and Commentary\n\nGeorgetown University uses the homegrown utility CCFDELET for ensuring\nthat a data set is deleted prior to running a step that will reallocate\nit. It has some advantages over the following alternatives:\n1) IEFBR14 with a \"MOD,DELETE\" DD card. Unfortunately, if the data set\n   is in migrated status, DFHSM will first restore it before deleting\n   it. There is no restore with CCFDELET.\n2) IDCAMS. The need to use control cards is the disadvantage here. With\n   CCFDELET, you (can) specify the data set to delete in the PARM field\n   of the EXEC card.\nCCFDELET has the good points of IEFBR14 without the disadvantage of\nrecalling migrated data sets. The data set to delete is visible in the\nJCL. It works with JCL procedures and JCL symbols.\n\nCCFDELET deletes data sets by invoking IDCAMS and supplying control\ncards to it. The appendix \"Invoking Access Method Services from Your\nProgram\" in the Access Method Services manual taught me how to do this.\nThe program has not changed since 1994. What was assembled and linked\nthen has continued to work up through OS/390 2.10, which is the release\nthat Georgetown currently runs.\n\nYou are getting the source Georgetown uses with one exception noted\nbelow.  You should probably review it before you put it into\nproduction.  It works at Georgetown but no guarantee is made that it\nwill work anywhere else. Use it at your own risk.  The one change to\nthe source is a commented out entry of the text unit pointer list that\nstarts at the label TUPTRLST. Comments there indicate why.\n\nYou can reach me at:\nemail: sipusic@georgetown.edu\nphone: 202-687-3934\naddress: Thomas Sipusic\n         Georgetown University Information Services\n         Box 571138\n         St. Mary's Hall 304D\n         Washingtion, DC 20057\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$USERDOC": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00P\\x01\\x04\\t_\\x01\\x04\\t_\\x11\\x12\\x000\\x000\\x00\\x00\\xc3\\xc3\\xc6\\xe3\\xd3\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-04-04T00:00:00", "modifydate": "2004-04-04T11:12:50", "lines": 48, "newlines": 48, "modlines": 0, "user": "CCFTLS"}, "text": "IEFBR14/CCFDELET\n\nDo not use IEFBR14 to delete or uncatalog data sets. Use the inhouse\nwritten program CCFDELET. When you have a job step that will allocate a\nnew data set and you wish to avoid a JCL error caused by an undeleted\nold version of it, you can use CCFDELET in a prior step to check for\nold versions of the data set and delete them if they exist. Following\nare two examples of using the CCFDELET program to delete data sets. The\nfirst example uses sysin control cards and would be placed in the\njobstream being submitted (aka RUNJCL). The second example would be\nused when setting up a PROC because it avoids using control cards.\n\nJOBSTREAM Example:\n\n//STEP1 EXEC PGM=CCFDELET\n//SYSPRINT DD SYSOUT=*\n//SYSIN DD *\nCCF.DELETE.DSN1\nCCF.DELETE.DSN2\nCCF.DELETE.DSN3\n/*\n\nPROC Example:\n\n//STEP1 EXEC PGM=CCFDELET,PARM='CCF.DELETE.DSN1'\n//STEP2 EXEC PGM=CCFDELET,PARM='CCF.DELETE.DSN2'\n//STEP3 EXEC PGM=CCFDELET,PARM='CCF.DELETE.DSN3'\n\nAnother nice feature of CCFDELET is that data sets migrated by DFHSM\nare not recalled before they are deleted. This is why the program\nIEFBR14 should not be used to delete or uncatalog data sets. IEFBR14\nwould recall a data set that is migrated to tape and then delete the\ndata set while CCFDELET tells DFHSM to delete the data set without\nfirst recalling it.\n\nRestrictions:\n\nCCFDELET/IDCAMS cannot delete a data set that is not catalogued. It\nwill assume the data set does not exist and produce a return code of 0.\n\nCondition Codes:\nCCFDELET works by invoking the IBM utility IDCAMS to delete datasets.\nThe messages sent to SYSPRINT and the condition code are produced by\nIDCAMS except that a condition code 8 (which indicates that the data\nset did not exist) is changed to a condition code of 0. If the return\ncode from a CCFDELET step is 0, this indicates that the data set has\nbeen deleted or never existed. Any other condition code indicates that\nthe data set might still exist and should be investigated.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE673": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04A\\x00\\x00\\x01\\x04\\x10/\\x01\\x04\\x10/\\x16$\\x00F\\x00F\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf5@@@'", "ispf": {"version": "04.65", "flags": 0, "createdate": "2004-04-11T00:00:00", "modifydate": "2004-04-11T16:24:00", "lines": 70, "newlines": 70, "modlines": 0, "user": "CBT-465"}, "text": "//***FILE 673 is from Tom Sipusic and contains a program called     *   FILE 673\n//*           CCFDELET which will delete datasets using JCL.  In    *   FILE 673\n//*           addition, CCFDELET will delete HSM archived datasets  *   FILE 673\n//*           without having to recall them.  Detailed description  *   FILE 673\n//*           follows below.                                        *   FILE 673\n//*                                                                 *   FILE 673\n//*           email: sipusic@georgetown.edu                         *   FILE 673\n//*           phone: 202-687-3934                                   *   FILE 673\n//*           address: Thomas Sipusic                               *   FILE 673\n//*                    Georgetown University Information Services   *   FILE 673\n//*                    Box 571138                                   *   FILE 673\n//*                    St. Mary's Hall 304D                         *   FILE 673\n//*                    Washingtion, DC 20057                        *   FILE 673\n//*                                                                 *   FILE 673\n//*                    Notes and Commentary                         *   FILE 673\n//*                                                                 *   FILE 673\n//*     Georgetown University uses the homegrown utility            *   FILE 673\n//*     CCFDELET for ensuring that a data set is deleted prior      *   FILE 673\n//*     to running a step that will reallocate it. It has some      *   FILE 673\n//*     advantages over the following alternatives:                 *   FILE 673\n//*                                                                 *   FILE 673\n//*     1) IEFBR14 with a \"MOD,DELETE\" DD card. Unfortunately,      *   FILE 673\n//*        if the data set is in migrated status, DFHSM will        *   FILE 673\n//*        first restore it before deleting it. There is no         *   FILE 673\n//*        restore with CCFDELET.                                   *   FILE 673\n//*                                                                 *   FILE 673\n//*     2) IDCAMS. The need to use control cards is the             *   FILE 673\n//*        disadvantage here. With CCFDELET, you (can) specify      *   FILE 673\n//*        the data set to delete in the PARM field of the EXEC     *   FILE 673\n//*        card.                                                    *   FILE 673\n//*                                                                 *   FILE 673\n//*     CCFDELET has the good points of IEFBR14 without the         *   FILE 673\n//*     disadvantage of recalling migrated data sets. The data      *   FILE 673\n//*     set to delete is visible in the JCL. It works with JCL      *   FILE 673\n//*     procedures and JCL symbols.                                 *   FILE 673\n//*                                                                 *   FILE 673\n//*     CCFDELET deletes data sets by invoking IDCAMS and           *   FILE 673\n//*     supplying control cards to it. The appendix \"Invoking       *   FILE 673\n//*     Access Method Services from Your Program\" in the Access     *   FILE 673\n//*     Method Services manual taught me how to do this.  The       *   FILE 673\n//*     program has not changed since 1994. What was assembled      *   FILE 673\n//*     and linked then has continued to work up through OS/390     *   FILE 673\n//*     2.10, which is the release that Georgetown currently        *   FILE 673\n//*     runs.                                                       *   FILE 673\n//*                                                                 *   FILE 673\n//*     You are getting the source Georgetown uses with one         *   FILE 673\n//*     exception noted below.  You should probably review it       *   FILE 673\n//*     before you put it into production.  It works at             *   FILE 673\n//*     Georgetown but no guarantee is made that it will work       *   FILE 673\n//*     anywhere else. Use it at your own risk.  The one change     *   FILE 673\n//*     to the source is a commented out entry of the text unit     *   FILE 673\n//*     pointer list that starts at the label TUPTRLST.             *   FILE 673\n//*     Comments there indicate why.                                *   FILE 673\n//*                                                                 *   FILE 673\n//*     JOBSTREAM Example:                                          *   FILE 673\n//*                                                                 *   FILE 673\n//*     //STEP1 EXEC PGM=CCFDELET                                   *   FILE 673\n//*     //SYSPRINT DD SYSOUT=*                                      *   FILE 673\n//*     //SYSIN DD *                                                *   FILE 673\n//*     CCF.DELETE.DSN1                                             *   FILE 673\n//*     CCF.DELETE.DSN2                                             *   FILE 673\n//*     CCF.DELETE.DSN3                                             *   FILE 673\n//*     /*                                                          *   FILE 673\n//*                                                                 *   FILE 673\n//*     PROC Example:                                               *   FILE 673\n//*                                                                 *   FILE 673\n//*     //STEP1 EXEC PGM=CCFDELET,PARM='CCF.DELETE.DSN1'            *   FILE 673\n//*     //STEP2 EXEC PGM=CCFDELET,PARM='CCF.DELETE.DSN2'            *   FILE 673\n//*     //STEP3 EXEC PGM=CCFDELET,PARM='CCF.DELETE.DSN3'            *   FILE 673\n//*                                                                 *   FILE 673\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASMJCL": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\"\\x01\\x04\\tO\\x01\\x04\\t_\\x10 \\x00\\x15\\x01\\xf4\\x00\\x00\\xc3\\xc3\\xc6\\xe3\\xd3\\xe2@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-04-03T00:00:00", "modifydate": "2004-04-04T10:20:22", "lines": 21, "newlines": 500, "modlines": 0, "user": "CCFTLS"}, "text": "//ASCCFDEL JOB  (0414,9999),SIPUSIC,MSGLEVEL=(1,1),CLASS=5, <== Change\n//     NOTIFY=CCFTLS,MSGCLASS=X                             <== Change\n//* This is model JCL to assemble and link-edit CCFDELET into an\n//* APF authorized load lib. I put it into the link list.\n//*\n//* Change the following before submitting:\n//*   Provide a valid JOB card\n//*   Change the source library in C.SYSIN to your source library\n//*   Change the target library in L.MOD to your target library\n//ASMCL    EXEC ASMACL,\n//  PARM.L='MAP,LET,LIST,NCAL,XREF',\n//  COND.L=(7,LT,C)\n//C.SYSIN    DD DISP=SHR,\n//             DSN=CCFTLS.CCFDELET.ASM(CCFDELET)            <== Change\n//L.SYSLMOD  DD DDNAME=LMOD\n//L.LMOD     DD DISP=SHR,\n//             DSN=MVS.SPRUCLIB                             <== Change\n//L.SYSIN    DD *\n   SETCODE AC(1)\n   ENTRY CCFDELET\n   NAME  CCFDELET(R)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CCFDELET": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00C\\x01\\x04\\tO\\x01\\x04\\x10/\\x08\\x16\\x01\\xe8\\x01\\xe5\\x00\\x00\\xc3\\xc3\\xc6\\xe3\\xd4\\xd3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-04-03T00:00:00", "modifydate": "2004-04-11T08:16:43", "lines": 488, "newlines": 485, "modlines": 0, "user": "CCFTML"}, "text": "CCFDELET TITLE '- UTILITY THAT DELETES DATASETS WITHOUT RESTORING THEM'\n***********************************************************************\n* PROGRAM: CCFDELET\n*\n* PURPOSE: DELETE A DATA SET IN A WAY THAT ONLY REQUIRES JCL.\n* NO CONTROL CARDS ARE REQUIRED. FURTHERMORE, IF THE DATA SET IS\n* MIGRATED, IT WILL BE DELETED WITHOUT FIRST BEING RECALLED.\n* NOTE, HOWEVER, THAT WHEN THERE ARE A LARGE NUMBER OF DATASETS TO\n* DELETE, A SYSIN DD CARD SPECIFYING A FILE OF CONTROL CARDS CAN BE\n* SUPPLIED. EACH RECORD IN THIS FILE SHOULD HOLD A (LEFT JUSTIFIED)\n* NAME OF A DATASET TO BE DELETED. THE SYSIN DD STATEMENT IS EXPECTED\n* WHEN THE PARM ON THE EXEC CARD IS NOT SPECIFIED.\n*\n* USAGE: INVOKE CCFDELET WITH THE PARM FIELD ON THE EXEC CARD SET TO\n* THE NAME OF THE DATA SET THAT IS TO BE DELETED. IN ADDITION\n* YOU MAY SUPPLY\n* A SYSPRINT DD CARD. FOR INSTANCE, IF UIS.TST.GARBAGE IS TO BE\n* DELETED:\n*\n*   //    EXEC PGM=CCFDELET,PARM='UIS.TST.GARBAGE'\n*   //SYSPRINT DD SYSOUT=*\n*\n* IF THE SYSPRINT CARD IS OMITTED, CCFDELET WILL DYNAMICALLY ALLOCATE\n* ONE (AS IF //SYSPRINT DD SYSOUT=* WERE PRESENT).\n*\n* LOGIC:\n*   SEARCH TIOT (TASK IO TABLE) FOR SYSPRINT DD NAME.\n*   IF NOT FOUND, DYNAMICALLY ALLOCATE A SYSPRINT SYSOUT DATASET.\n*   FETCH THE PARAMETER, I.E, THE NAME OF THE DATASET TO BE DELETED.\n*   IF THE PARAMETER IS ABSENT, THEN OPEN THE SYSIN DATA SET AND\n*   READ IT A RECORD AT A TIME. FROM EACH RECORD EXTRACT A DATA SET\n*   NAME TO DELETE.\n*   FOR EACH NAME, WHETHER OBTAINED FROM THE PARM FIELD OR THE SYSIN\n*   DATA SET,\n*   PLUG THE NAME INTO AN IDCAMS LISTC CONTROL CARD AND A DELETE\n*   CONTROL CARD. THEN CALL IDCITER.\n*   IDCITER LINKS TO IDCAMS (WHICH WILL PERFORM THE DELETE)\n*   SPECIFYING THAT THAT SYSIN AND SYSPRINT \"IO\" WILL BE PERFORMED BY\n*   IROUTINE AND OROUTINE, RESPECTIVELY SUBROUTINES OF CCFDELETE.\n*   IROUTINE FIRST ISSUES A LISTC COMMAND FOR THE DATASET IN ORDER\n*   MAINLY TO DETERMINE IF THE DATASET IS ON TAPE OR DASD, BUT IF THE\n*   OUTPUT FROM IDCAMS SHOWS THAT THE DATASET DOESN'T EXIST, GO NO\n*   FURTHER. THERE IS NOTHING ELSE TO DO. RETURN WITH A CONDITION CODE\n*   OF 0. IF THE DATASET DOES EXIST, DETERMINE THAT THE DATASET IS ON\n*   TAPE IF BYTE 5 OF THE DEVTYPE FIELD IS \"8\" (AND VOLSER IS NOT\n*   \"MIGRAT\". OTHERWISE, IT IS DASD. IF THE DATASET IS TAPE, ADD\n*   \"NOSCRATCH\" TO THE IDCAMS DELETE COMMAND. NO MATTER WHETHER THE\n*   DATASET IS ON TAPE OR DASD, NEXT PASS THE DELETE COMMAND TO\n*   IDCAMS. IF IDCAMS GENERATES A \"DATASET NOT FOUND\" MESSAGE FOR THE\n*   DATASET SUPPOSED TO BE ON DISK. ISSUE THE DELETE COMMAND AGAIN,\n*   THIS TIME WITH A NOSCRATCH PARAMETER AND RETURN A CONDITION CODE\n*   OF 0. ALL THIS DETERMINATION AND MODIFICATION OF CONTROL CARDS AND\n*   CONDITION CODES IS DONE BY THE OUTPUT ROUTINE, OROUTINE, WHICH\n*   ALSO WRITES EACH OUTPUT LINE TO SYSPRINT.\n*\n*   TOM SIPUSIC           MARCH, 1993\n*\n*   CHANGES:\n*   4/5/94    BUG CORRECTED. TEST FOR \"MIGRAT\", NOT \"MIGRATE\"\n*\n***********************************************************************\n         EJECT\nCCFDELET START\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SAVE  (14,12)            |\n         LR    R12,R15            |\n         USING CCFDELET,R12       |\n         ST    R13,SAVEAREA+4     |- STANDARD LINKAGE\n         LR    R2,R13             |\n         LA    R13,SAVEAREA       |\n         ST    R13,8(R2)          |\n* REGISTER USAGE\n*  R2  POINTER TO FLAGS           (FOR IDCAMS INPUT  (IROUTINE))\n*  R2  POINTER TO FLAGS           (FOR IDCAMS OUTPUT (OROUTINE))\n*  R3    POINTER TO PARM FROM EXEC CARD\n*  R3 POINTER TO USER DATA        (FOR IDCAMS INPUT  (OROUTINE))\n*  R3 POINTER TO RECORD INFO LIST (FOR IDCAMS OUTPUT (OROUTINE))\n*  R4 PTR TO S99RB                (IN DYNALLOC SECTION)\n*  R4    LENGTH OF PARM FROM EXEC CARD\n*  R4 OFFSET W.R.T ICARDAR OF NEXT INPUT             (IROUTINE)\n*  R4 LENGTH OF LINE TO PRINT     (FOR IDCAMS OUTPUT (OROUTINE))\n*  R5 PTR TO LINE TO \"INPUT\"      (FOR IDCAMS INPUT  (IROUTINE))\n*  R5 PTR TO LINE TO PRINT        (FOR IDCAMS OUTPUT (OROUTINE))\n*  R6 POINTER TO WHERE IDCAMS WANTS INPUT (IDCAMS INPUT (IROUTINE))\n*  R6 LENGTH TO PLUG INTO RDW     (FOR IDCAMS OUTPUT (OROUTINE))\n*  R7    RETURN CODE FROM IDCAMS\n*  R7 PTR TO USER AREA            (FOR IDCAMS OUTPUT (OROUTINE))\n*  R8 PTR TO TIOT DD ENTRIES      (IN GETDDNAM SECTION)\n*  R8 PTR TO S99RBP               (IN DYNALLOC SECTION)\n*  R9 WORK REG.                   (IN GETDDNAM SECTION)\n*  R9 PTR TO S99RB                (IN DYNALLOC SECTION)\n*  R12   BASE REGISTER\n         SPACE 2\n         L     R3,0(,R1)          LOAD POINTER TO 2 DIGIT PARM\n         EJECT\n         TITLE     '-  GETDDNAM  -  TEST SYSIN DD CARD PRESENCE'\n***********************************************************************\n*                                                                     *\n*     THIS GETDDNAM SECTION WAS CRIBBED FROM CCFVS1CM.                *\n*                                                                     *\n*          SUBSECTION  --  GETDDNAM                                   *\n*                                                                     *\n*     REGISTER 1 ON ENTRY CONTAINS THE ADDRESS OF AN 8 CHARACTER      *\n*     DDNAME, PADDED ON THE RIGHT WITH BLANKS IF NECESSARY.  ON       *\n*     RETURN, REGISTER 1 CONTAINS '1' IF THE SPECIFIED DD NAME IS     *\n*     PRESENT IN THE TIOT (I.E., A DD CARD IS PRESENT), OR '0' IF     *\n*     THE DD CARD IS ABSENT.                                          *\n*     'DUMMY' DD CARDS ARE TREATED AS ABSENT.                         *\n*                                                                     *\n***********************************************************************\n           SPACE   3\nGETDDNAM   EQU     *\n           SPACE   1\n           EXTRACT TIOTADDR,FIELDS=(TIOT)   GET ADDR(TIOT)\n           SPACE   1\n           L       R8,TIOTADDR         GET ADDR (TIOT)\n           LA      R8,24(,R8)          POINT TO FIRST DD ENTRY\n           SLR     R9,R9               CLEAR WORK REG\n           EJECT\nGETDLOOK   EQU     *\n           SPACE   1\n           ICM     R9,B'0001',0(R8)    GET LENGTH (DD ENTRY)\n           BZ      DYNALLOC              BRANCH IF NO MORE ENTRIES\n           SPACE   1\n           CLC     =C'SYSPRINT',4(R8)  DDNAME FOUND?\n           BE      OPENDSNS              YES, BRANCH (DON'T DYNALLOC)\n           SPACE   1\n           LA      R8,0(R8,R9)         GET NEXT DD ENTRY\n           B       GETDLOOK            KEEP LOOKING\n           SPACE   1\n           SPACE   3\nTIOTADDR   DC      A(0)                HOLDS TIOT ADDRESS\n         EJECT\n         TITLE 'CCFDELET -- DYNAMICALLY ALLOCATE SYSPRINT DATA SET'\n***********************************************************************\n* DYNAMICALLY ALLOCATE FILE TO SYSPRINT OUTPUT FILE SINCE IT WAS NOT  *\n* PRESENT IN THE JCL.                                                 *\n***********************************************************************\nDYNALLOC   DS  0H\n         SPACE\n         MVI   DYNAFLAG,X'01'     FLAG THAT DYNALLOC BEING DONE\n*        LA    R0,50              AMOUNT OF STORAGE NEEDED FOR REQUEST\n         GETMAIN R,LV=56          GET THE STORAGE\n         LR    R8,R1              SAVE THE ADDRESS OF RETURNED STORAGE\n         USING S99RBP,R8          ESTABLISH ADDRESSABILITY\n         SPACE\n         LA    R9,S99RBPTR+4      WILL PUT RB JUST BEYOND S99RBP\n         USING S99RB,R9           ESTABLISH ADDRESSABILITY\n         ST    R9,S99RBPTR        RBPTR POINTS TO RB\n         OI    S99RBPTR,S99RBPND  TURN ON RBPTR'S HIGH ORDER BIT\n         XC    S99RB(RBLEN),S99RB ENTIRELY ZERO OUT RB\n         MVI   S99RBLN,RBLEN      PUT LENGTH OF IN ITS LENGTH FIELD\n         MVI   S99VERB,S99VRBAL   SET VERB CODE FIELD TO \"ALLOCATE\"\n         SPACE\n         MVC   S99TXTPP,=A(TUPTRLST)  STORE ADDRESS OF TUP LIST IN RB\n         SPACE\n         LR    R1,R8              ADDRESS OF REQUEST BLOCK PTR IN R1\n         DYNALLOC                 INVOKE DYNAMIC ALLOCATION\n         B     PSTDYNAL           DYNAMIC ALLOC DONE. GO TO NEXT TASK\nRBLEN    EQU   (S99RBEND-S99RB)\n* REQUEST BLOCK EXTENSION\nRBX      DS    0F\nEID      DC    C'S99RBX'          ID\nEVER     DC    X'01'              VERSION NUMBER\nRBSVR    DC    X'80'              PROCESSING OPTION\nESUBP    DS    XL1                SUBPOOL FOR MESSAGE BLOCKS\nEKEY     DS    XL1                STORAGE KEY FOR MESSAGE BLOCKS\nEMGSV    DS    XL1                SEVERITY FOR MESSAGES\nTUPTRLST DC    A(DDTU)\n* THE FOLLOWING DC COMMENTED OUT BECAUSE IT IS GEORGETOWN, IT POINTS\n* TO A TEXT UNIT THAT IS THE EQUIVALENT OF THE JCL \"DEST=N1R9\",\n* WHICH AT GEORGETOWN SENDS THE OUTPUT TO CA-VIEW.\n*        DC    A(DASUSTU)                                               0001980\n         DC    AL1(S99TUPLN),AL3(SYSOUTTU) S99TUPLN MARKS LAST TUPTR\nLTUPTLST EQU   *-TUPTRLST         LENGTH OF TEXT-UNIT-POINTER LIST\nDDTU     DC    AL2(DALDDNAM)      TU FOR DDNAME OF SYSIN\n         DC    X'0001'\n         DC    X'0008'\n         DC    C'SYSPRINT'\nDASUSTU  DC    AL2(DALSUSER)  NODE WHERE SYSOUT ROUTED    |             0002080\n         DC    X'0001'                                    |\n         DC    X'0004'                                    |\n         DC    CL4'N1R9'                                  |_ SAR\nSYSOUTTU DC    AL2(DALSYSOU)  SYSOUT=*\n         DC    X'0000'\nPSTDYNAL DS    0H                 HERE WHEN DYNAMIC ALLOCATION DONE\n         EJECT\n         TITLE '- DELETE THE DATA SET NAMED IN THE EXEC PARM FIELD'\n***********************************************************************\n*                                                                     *\n*                                                                     *\n***********************************************************************\nOPENDSNS   DS  0H\n         OPEN  (SYSPRINT,(OUTPUT)) OPEN MESSAGE DATASET.\n         EJECT\n***********************************************************************\n* PROCESS PARM, WHICH,IF PRESENT, IS THE NAME OF THE DATASET TO DELETE\n***********************************************************************\n         LH    R4,0(,R3)          LENGTH OF PARAMETER\n         LTR   R4,R4              IF PARM LENGTH NOT POSITIVE,\n         BNH   NOPARM               BRANCH TO OBTAIN DSN(S) ELSEWHERE\n         BCTR  R4,0               SUBTRACT 1 TO USE AS LENGTH IN MVC\n         LA    R3,2(,R3)          POINT TO DATA SET NAME\nEXMVCFL  EX    R4,FILLLIST        MOVE THE DSB TO IDCAMS LISTC STMT.\nEXMVCFD  EX    R4,FILLDELT        MOVE THE DSB TO IDCAMS DELETE STMT.\n         BAL   R14,IDCITER        CALL ROUTINE THAT INVOKES IDCAMS\n         ST    R15,COMPCODE       COMP CODE FOR CCFDELET\n         B     EXCCFDEL           CLEAN UP AND EXIT FROM CCFDELET\n         SPACE\nFILLLIST MVC   LDSNAME(0),0(R3)   USED BY EX AT EXMVCFL\nFILLDELT MVC   DDSNAME(0),0(R3)   USED BY EX AT EXMVCFD\n         EJECT\nNOPARM   DS    0H                 HERE WHEN NO PARM WAS PROVIDED\n***********************************************************************\n* NO PARM FIELD WAS PROVIDED IN THE JCL;                              *\n* SO GET DATA SETS TO DELETE FROM SYSIN DD.                           *\n***********************************************************************\n         SPACE 2\n         OPEN  (SYSIN,(INPUT))   OPEN LIST-OF-DSNS DATASET\nDELLOOP  DS    0H                 EACH ITER. DELETES A DSN FROM SYSIN\n         GET   SYSIN              GET THE NAME OF A DATASET TO DELETE\n         MVC   LDSNAME,0(R1)      PLUG IT INTO THE TWO CONTROL CARDS\n         MVC   DDSNAME,0(R1)        THAT TELL IDCAMS WHAT TO DO.\n         MVC   DNSCR,=C'    '     RESET FIELD INDICATING NOSCRATCH.\n         BAL   R14,IDCITER        CALL ROUTINE THAT INVOKES IDCAMS\n         L     R14,COMPCODE       HIGHEST RETURN CODE PRIOR THIS CALL\n         CR    R15,R14            IF THE NEW RETURN CODE IS NOT HIGHER\n         BNH   DELLOOP              THEN START NEXT ITERATION\n         ST    R15,COMPCODE         ELSE REVISE\n         B     DELLOOP            BRANCH TO BEGIN NEXT ITERATION\nEOF      DS    0H                 HERE WHEN NO MORE RECORDS IN SYSIN\n         CLOSE SYSIN\n         B     EXCCFDEL           CLEAN UP AND EXIT FROM CCFDELET\n         SPACE\nCOMPCODE DC    F'0'               MAX COMP CODE (FROM CALLS TO IDCITER)\n         EJECT\nIDCITER  DS    0H                 THE VALUE OF PARM IS NOW IN R4\n***********************************************************************\n* LINK TO IDCAMS, WHICH WILL DELETE THE DATA SET FOR US.              *\n***********************************************************************\n         SPACE 2\n         SAVE  (14,12)            |\n         ST    R13,ITERSAVE+4     |- STANDARD LINKAGE\n         LR    R2,R13             |\n         LA    R13,ITERSAVE       |\n         ST    R13,8(R2)          |\n         MVC   SWRKAREA,=X'FFFFFFFF' REINITIALIZE RC MODIFIER\n         MVC   IWRKAREA,=F'0'        REINITIALIZE ICARDAR INDEX\n         XR    0,0\n         XR    R1,R1\n         LINK  EP=IDCAMS,                                              X\n               PARAM=(ZEROHALF,   NO SPECIAL EXEC OPTIONS              X\n               ZEROHALF,          NO SPECIAL DDNAMES                   X\n               ZEROHALF,          NO SPECIAL PAGE NUMBERING            X\n               IOLIST),           WE WILL CONTROL \"IO\"                 X\n               VL=1\n         EJECT\n***********************************************************************\n* HERE UPON RETURN FROM IDCAMS. RETURN WITH CONDITION                 *\n* CODE RECEIVED FROM IDCAMS.                                          *\n***********************************************************************\nCLOSEM   EQU   *\n         C     R15,=F'4'          RETURN FROM IDCAMS = 4?\n         BNE   CHECKRC8             NO, BRANCH TO RETURN TO CALLER\n         N     R15,SWRKAREA         YES, 0 RC IF 4 FOR DSN NOT CATLGD\n         B     RETURN\n         SPACE\nCHECKRC8 EQU   *\n         C     R15,=F'8'          RETURN FROM IDCAMS = 8?\n         BNE   RETURN               NO, BRANCH TO RETURN TO CALLER\n         N     R15,SWRKAREA         YES, 0 RC IF 8 FOR DSN NOT ON VOL\n         SPACE\nRETURN   EQU   *\n         L     R13,4(R13)         RESTORE SAVE AREA ADDRESS\n         RETURN (14,12),RC=(15)   RETURN FROM IDCITER\nITERSAVE DS    18F\n         SPACE\n         EJECT\nEXCCFDEL DS    0H\n         CLOSE SYSPRINT\n         CLI   DYNAFLAG,X'01'     WAS SYSPRINT DYNAMICALLY ALLOCATED?\n         BNE   PSTFREE              NO, BRANCH TO BYPASS FREEMAIN\n         FREEMAIN R,LV=56,A=(R8)\nPSTFREE  DS    0H\n         L     R15,COMPCODE       HIGHEST RETURN CODE PRIOR THIS CALL\n         L     R13,4(R13)         RESTORE SAVE AREA ADDRESS\n         RETURN (14,12),RC=(15)   RETURN FROM CCFDELET\n         DROP  R12\n         EJECT\n         DS    0F\nSAVEAREA DS    18F\nZEROHALF DC    H'0'\nIOLIST   DS    0F\n         DC    X'00000002'        WILL CONTROL 2 DATASETS\n         DC    A(SIN)             POINT TO THE WORD 'DDSYSIN'\n         DC    A(IROUTINE)        ROUTINE THAT WILL DO SYSOUT\n         DC    A(SWRKAREA)        WORK AREA\n         DC    A(SOUT)            POINT TO THE WORD 'DDSSYSOUT'\n         DC    A(OROUTINE)        ROUTINE THAT WILL DO SYSOUT\n         DC    A(SWRKAREA)        WORK AREA\nSWRKAREA DC    X'FFFFFFFF'        WORK AREA\nIWRKAREA DC    F'0'               INDEX TO ARRAY OF INPUT CARDS.\nSOUT     DC    C'DDSYSPRINT'      WE'LL CONTROL IO TO THIS FILE.\nSIN      DC    C'DDSYSIN   '      WE'LL CONTROL IO TO THIS FILE.\n         EJECT\n         EJECT\n***********************************************************************\n* IDCAMS CALLS THIS ROUTINE TO OBTAIN INPUT CARDS.                    *\n***********************************************************************\nIROUTINE DS    0H\n         SAVE  (14,12)            |\n         LR    R12,R15            |\n         USING IROUTINE,R12       |\n         ST    R13,SAVEAREI+4     |- STANDARD LINKAGE\n         LR    R2,R13             |\n         LA    R13,SAVEAREI       |\n         ST    R13,8(R2)          |\n         SPACE 2\n* PROCESS PARAMETER LIST PASSED FROM IDCAMS\n         L     R2,4(R1)           POINTER TO FLAGS\n         CLI   0(R2),X'00'        IDCAMS REQUESTING OPEN?\n         BNE   INOTOPEN           NO, BRANCH.  IT'S GET.\n* FAKE THE OPEN. WE CREATE \"INPUT CARDS\" FROM PARM DATA.\n         XR    R15,R15            0 RETURN CODE\n         B     IROUTEND           PREPARE TO RETURN TO IDCAMS\n         SPACE\nINOTOPEN EQU   *                  HERE IF NOT OPEN REQUEST\n         CLI   0(R2),X'04'        IDCAMS REQUESTING CLOSE?\n         BNE   DOAGET             NO, BRANCH.  IT'S A GET.\n* ACT AS IF WE HAVE CLOSED SYSIN.\n         XR    R15,R15            0 RETURN CODE\n         B     IROUTEND           PREPARE TO RETURN TO IDCAMS\n         SPACE\nDOAGET   EQU   *                  HERE IF IDCAMS WANTING NEXT INPUT\n         L     R3,0(R1)           POINTER TO USER DATA (ICARDAR INDEX)\n         L     R4,4(R3)   OFFSET W.R.T. ICARDAR FOR NEXT INP. LINE DATA\n         LA    R5,ICARDAR(R4)     PTR LINE TO \"INPUT\"\n         L     R6,8(R1)           WHERE TO PUT ADDRESS OF INPUT CARD\n         MVC   0(8,R6),0(R5)      MOVE IT (AND LINE LENGTH) THERE\n         L     R15,8(R5)          SET RETURN CODE FROM ICARDAR ENTRY\n         LA    R4,12(R4)          BUMP UP 1 INDEX FOR ICARDAR\n         ST    R4,4(R3)             AND STORE IT IN PARMLIST\n         B     IROUTEND\n         SPACE 1\nICARDAR  DS    0D                 ARRAY OF INFO TO SEND BACK TO IDCAMS\n         DC    A(LSYSINCD)        POINTER TO THE 1ST CARD\n         DC    F'80'                LENGTH OF CARD\n         DC    F'0'                   RETURN CODE\n         DC    A(DSYSINCD)        POINTER TO THE 2ND CARD\n         DC    F'80'                LENGTH OF CARD\n         DC    F'0'                   RETURN CODE\n         DC    F'0'              SIGNAL NOTHING MORE TO PRINT\n         DC    F'0'                 LENGTH OF CARD\n         DC    F'4'                   RETURN CODE (END OF DATA)\n         EJECT\n***********************************************************************\n* HERE UPON COMPLETION OF SYSOUT REQUEST FROM IDCAMS                  *\n***********************************************************************\nIROUTEND EQU   *\n         L     R13,4(R13)         RESTORE SAVE AREA ADDRESS\n         L     R14,12(R13)        LOAD RETURN ADDRESS\n         RETURN (14,12),RC=(15)   RETURN TO CALLER\n         DROP  R12\n         EJECT\nSAVEAREI DS    18F                SAVE AREA FOR CCFDELET ROUTINE\n         LTORG\n         EJECT\n***********************************************************************\n* IDCAMS CALLS THIS ROUTINE TO ALLOW US TO HANDLE SYSPRINT IO.        *\n***********************************************************************\nOROUTINE DS    0H\n         SAVE  (14,12)            |\n         LR    R12,R15            |\n         USING OROUTINE,R12       |\n         ST    R13,SAVEAREO+4     |- STANDARD LINKAGE\n         LR    R2,R13             |\n         LA    R13,SAVEAREO       |\n         ST    R13,8(R2)          |\n         SPACE 2\n* PROCESS PARAMETER LIST PASSED FROM IDCAMS\n         L     R2,4(R1)           POINTER TO FLAGS\n         CLI   0(R2),X'00'        IDCAMS REQUESTING OPEN?\n         BNE   ONOTOPEN           NO, BRANCH.  IT'S PUT OR CLOSE.\n         XR    R15,R15            0 RETURN CODE (SYSPRINT ALREADY OPEN)\n         B     OROUTEND           PREPARE TO RETURN TO IDCAMS\n         SPACE\nONOTOPEN EQU   *                  HERE IF NOT OPEN REQUEST\n         CLI   0(R2),X'04'        IDCAMS REQUESTING CLOSE?\n         BNE   DOAPUT             NO, BRANCH.  IT'S PUT.\n* SYSPRINT WILL BE CLOSED JUST BEFORE CCFDELET ENDS.\n         XR    R15,R15            0 RETURN CODE\n         B     OROUTEND           PREPARE TO RETURN TO IDCAMS\n         SPACE\nDOAPUT   EQU   *                  HERE IF A RECORD PASSED FOR OUTPUT\n         L     R3,8(R1)           POINTER TO RECORD INFO LIST\n         L     R4,4(R3)           LENGTH OF LINE TO PRINT\n         L     R5,0(R3)           PTR LINE TO PRINT\n         CLC   =C'IDC3012I',1(R5) IF MSGID FOR \"DATASET NOT\n         BNE   PASTDSNC             CATALOGUED\",\n         L     R7,0(,R1)              THEN SET MASK SO THAT CCFDELET\n         MVI   3(R7),X'00'              WILL RETURN A CC OF 0\n         MVI   7(R7),24                   AND ICARDAR OFFSET TO EOF\n         B     PASTUNIT           RETURN TO MAINLINE PROCESSING OF LINE\n         SPACE\nPASTDSNC EQU   *                  PAST DATA SET NOT CATALOGUED\n         CLC   =C'IKJ56232I D',1(R5) IF MSGID FOR DATASET NOT\n         BNE   PASTDSNF             FOUND ON VOLUME INDICATED,\n         L     R7,0(,R1)              THEN SET MASK SO THAT CCFDELET\n         MVI   3(R7),X'00'              WILL RETURN A CC OF 0\n         MVI   7(R7),12                   AND ICARDAR INDEX TO DEL STMT\n         MVC   DNSCR,=C'NSCR'               AND PLUG IN NOSCRATCH PARM\n         B     PASTUNIT           RETURN TO MAINLINE PROCESSING OF LINE\n         SPACE\nPASTDSNF EQU   *                  PAST DATA SET NOT FOUND\n         CLC   =C'DEVTYPE',37(R5) IF LINE DESCRIBING VOLSER AND DEVT\n         BNE   PASTUNIT             FOUND,\n         CLI   56(R5),C'8'        AND IF UNIT IS\n         BNE   PASTUNIT             TAPE,\n         CLC   =C'MIGRAT',26(R5)  AND IF VOLSER NOT EQUAL TO\n         BE    PASTUNIT             \"MIGRAT\",\n         MVC   DNSCR,=C'NSCR'         PLUG NOSCRATCH PARM INTO DELETE\n         SPACE\nPASTUNIT EQU   *                  PAST MASK SET TO 0\n         LA    R6,4(,R4)          COMPUTE AND\n         STH   R6,OUTBUF            STORE LENGTH FIELD OF RDW\n         BCTR  R4,0               LENGTH -1 FOR USE IN MVC INSTRUCTION\nEXMOVE   EX    R4,MOVEREC         MOVE DATA INTO OUTPUT RECORD.\n         PUT   SYSPRINT,OUTBUF\n         B     OROUTEND\nMOVEREC  MVC   OUTREC(0),0(R5)    EXECUTED FROM LOCATION EXMOVE.\n         EJECT\n***********************************************************************\n* HERE UPON COMPLETION OF SYSOUT REQUEST FROM IDCAMS                  *\n***********************************************************************\nOROUTEND EQU   *\n         XR    R15,R15            0 RETURN CODE BACK TO IDCAMS\n         L     R13,4(R13)         RESTORE SAVE AREA ADDRESS\n         RETURN (14,12),RC=(15)   RETURN TO CALLER\n         DROP  R12\n         EJECT\nSAVEAREO DS    18F                SAVE AREA FOR CCFDELET ROUTINE\n         SPACE 2\n* FIRST CARD PASSED TO IDCAMS. IT HOLDS COMMAND TO LISTC THE DATA SET.\nLSYSINCD DC    CL80' '\n         ORG   LSYSINCD\n         DC    C' LISTC ENT('\nLDSNAME  DC    CL44' '      THE NAME OF THE DATASET WILL GO HERE.\n         DC    C') VOL    '\n         ORG\n         SPACE 2\n* 2ND CARD PASSED TO IDCAMS. IT HOLDS COMMAND TO DELETE THE DATA SET.\nDSYSINCD DC    CL80' '\n         ORG   DSYSINCD\n         DC    C' DELETE ('\nDDSNAME  DC    CL44' '      THE NAME OF THE DATASET WILL GO HERE.\n         DC    C')        '                                             /*/*\n         ORG   DSYSINCD+68\nDNSCR    DS    CL4                NOSCRATCH PARM PLUGGED IN IF TAPE\n         ORG\nSYSIN    DCB   DDNAME=SYSIN,MACRF=GL,DSORG=PS,EODAD=EOF\nSYSPRINT DCB   DDNAME=SYSPRINT,BLKSIZE=141,RECFM=VBA,LRECL=137,        X\n               DSORG=PS,MACRF=PM\nDYNAFLAG DC    X'00'              SET TO 01 IF SYSPRINT DYNALLOCED\nOUTBUF   DS    0H                 ASSEMBLE-OUTPUT-RECORD AREA\nOUTLNTH  DS    H                  RECORD LENGTH (RDW + DATA)\n         DC    X'0000'            END OF RDW\nOUTREC   DS    CL133              THE DATA PART OF THE RECORD\n         LTORG\n         EJECT\n         IHAPSA\n         IEFZB4D0\n         IEFZB4D2\n         END   CCFDELET\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT673/FILE673.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT673", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}