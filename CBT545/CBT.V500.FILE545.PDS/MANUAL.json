{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20020127030438000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 705432, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 133, "INMBLKSZ": 2660, "INMRECFM": "FB", "INMDIR": 1, "INMDSNAM": "SBGOLOB.PL360.MANUAL", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 705432, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 705432, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"SBGOLOB.PL360.MANUAL": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 2660, "DS1LRECL": 133, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 32, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 1000, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "020026", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00-'", "DS1LSTAR": "b'\\x00\\x0c\\n'", "DS1TRBAL": "b'\\x7f\\x1a'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f2\\x10\\x00\\x04\\x8a\\xfd\\x98'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f2\\x10\\x00\\x04\\x8a\\xfd\\x98'", "b'X\\xf4\\x9a\\x00\\x00\\x00\\x01\\xc8\\x00\\x02\\x01\\xcb\\x00\\x01\\x00-'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"MANUAL": {"ttr": 258, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x02o\\x01\\x02\\x02o!!\\x0f+\\x0f+\\x00\\x00\\xd7\\xd3\\xf3\\xf6\\xf0@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-26T00:00:00", "modifydate": "2002-01-26T21:21:00", "lines": 3883, "newlines": 3883, "modlines": 0, "user": "PL360"}, "text": "\n1                               CONTENTS\n+                               CONTENTS\n+                               CONTENTS\n\n SECTION 1.  INTRODUCTION  . . . . . . . . . . . . . . . . . . . . .  1-1\n\n SECTION 2.  DEFINITION OF THE PL360 ENVIRONMENT\n             2.1  Terminology, Notation, and Basic Definitions . . .  2-1\n                  2.1.1  The Processor . . . . . . . . . . . . . . .  2-1\n                  2.1.2  Relationships . . . . . . . . . . . . . . .  2-2\n                  2.1.3  The Program . . . . . . . . . . . . . . . .  2-2\n                  2.1.4  Syntax  . . . . . . . . . . . . . . . . . .  2-2\n             2.2  Identifiers and Basic Symbols  . . . . . . . . . .  2-3\n                  2.2.1  Identifiers . . . . . . . . . . . . . . . .  2-4\n                  2.2.2  Basic Symbols . . . . . . . . . . . . . . .  2-4\n                  2.2.3  Standard Identifiers  . . . . . . . . . . .  2-5\n\n SECTION 3.  VALUES\n             3.1  Hexadecimal Values . . . . . . . . . . . . . . . .  3-1\n             3.2  Decimal Values . . . . . . . . . . . . . . . . . .  3-1\n             3.3  Numeric Values . . . . . . . . . . . . . . . . . .  3-2\n             3.4  String Values  . . . . . . . . . . . . . . . . . .  3-2\n\n SECTION 4.  PROGRAM FORMAT\n             4.1  Block Structure  . . . . . . . . . . . . . . . . .  4-1\n             4.2  Program Segmentation . . . . . . . . . . . . . . .  4-3\n             4.3  Data Segmentation  . . . . . . . . . . . . . . . .  4-3\n             4.4  Main Program . . . . . . . . . . . . . . . . . . .  4-4\n\n SECTION 5.  DECLARATIONS\n             5.1  Register Synonym Declarations  . . . . . . . . . .  5-1\n             5.2  Segment Base Declarations  . . . . . . . . . . . .  5-1\n             5.3  Cell Declarations  . . . . . . . . . . . . . . . .  5-2\n             5.4  Cell Designators . . . . . . . . . . . . . . . . .  5-3\n             5.5  Cell Synonym Declarations  . . . . . . . . . . . .  5-4\n             5.6  EQUATE Declarations  . . . . . . . . . . . . . . .  5-5\n\n SECTION 6.  STATEMENTS\n             6.1  Register Assignments . . . . . . . . . . . . . . .  6-1\n             6.2  Register Assignment Expressions  . . . . . . . . .  6-2\n             6.3  Cell Assignments . . . . . . . . . . . . . . . . .  6-3\n             6.4  GOTO Statements and Labels . . . . . . . . . . . .  6-4\n             6.5  Conditions and Compound Conditions . . . . . . . .  6-4\n             6.6  IF Statements  . . . . . . . . . . . . . . . . . .  6-6\n             6.7  WHILE Statements . . . . . . . . . . . . . . . . .  6-6\n             6.8  FOR Statements . . . . . . . . . . . . . . . . . .  6-7\n             6.9  CASE Statements  . . . . . . . . . . . . . . . . .  6-7\n\n SECTION 7.  FUNCTIONS\n             7.1  Function Declarations  . . . . . . . . . . . . . .  7-1\n             7.2  Function Statements  . . . . . . . . . . . . . . .  7-1\n\n SECTION 8.  PROCEDURES\n             8.1 Procedure Declarations  . . . . . . . . . . . . . .  8-1\n             8.2 Procedure Statements  . . . . . . . . . . . . . . .  8-2\n\n SECTION 9.  THE RUN-TIME LIBRARY\n             9.1 Standard Procedures . . . . . . . . . . . . . . . .  9-1\n             9.2 Number Conversion Procedures  . . . . . . . . . . .  9-2\n             9.3 Data Manipulation Procedures  . . . . . . . . . . .  9-4\nB                                   i\n1\n SECTION 10. COMPILER CONTROL FACILITIES\n             10.1 Instructions to the Compiler . . . . . . . . . . . 10-1\n                  10.1.1  Listing Control  . . . . . . . . . . . . . 10-1\n                  10.1.2  Listing Options  . . . . . . . . . . . . . 10-1\n                  10.1.3  Operating System Control . . . . . . . . . 10-2\n                  10.1.4  Identification . . . . . . . . . . . . . . 10-2\n                  10.1.5  Program Base Register Control  . . . . . . 10-2\n                  10.1.6  Object Deck Control  . . . . . . . . . . . 10-3\n                  10.1.7  Copy Facility  . . . . . . . . . . . . . . 10-3\n                  10.1.8  Conditional Compile Directives . . . . . . 10-3\n             10.2 Compiler Listing Output  . . . . . . . . . . . . . 10-4\n             10.3 Error Messages of the Compiler . . . . . . . . . . 10-5\n             10.4 Compiler Object Program Output . . . . . . . . . . 10-6\n\n SECTION 11. LINKAGE CONVENTIONS\n             11.1 Calling External Routines from PL360 . . . . . . . 11-1\n             11.2 Requesting Supervisor Services . . . . . . . . . . 11-2\n             11.3 Calling PL360 Procedures from External Routines  . 11-2\n\n SECTION 12. PL360 AS AN ORVYL LANGUAGE PROCESSOR\n             12.1 Using the PL360 Compiler with ORVYL  . . . . . . . 12-1\n             12.2 Input/Output Subroutines for\n                    Interactive PL360 Programs . . . . . . . . . . . 12-3\n\n APPENDIX A.  EXAMPLE PROGRAMS AND LISTINGS\n              Sample Program Demonstrating Extensions to PL360 . . .  A-1\n              Right Triangle Problem . . . . . . . . . . . . . . . .  A-6\n              Global Procedure TRTEST  . . . . . . . . . . . . . . .  A-9\n              ORVYL Program to Set Options . . . . . . . . . . . . . A-11\n\n APPENDIX B.  THE OBJECT CODE  . . . . . . . . . . . . . . . . . . .  B-1\n\n APPENDIX C.  COMPILER CONSTRUCTS  . . . . . . . . . . . . . . . . .  C-1\n\n APPENDIX D.  SYNTACTIC INDEX  . . . . . . . . . . . . . . . . . . .  D-1\n\n APPENDIX E.  SYNTACTIC ENTITIES . . . . . . . . . . . . . . . . . .  E-1\n\n\n\n\n                                 TABLES\n+                                TABLES\n+                                TABLES\n\n Table 6.1  Allowable Cell and Register Type Combinations  . . . . .  6-1\n Table 6.2  Allowable Cell and Value Combinations  . . . . . . . . .  6-3\n Table 6.3  Condition Code States  . . . . . . . . . . . . . . . . .  6-5\n\n Table 7.1  Instruction Format . . . . . . . . . . . . . . . . . . .  7-2\n\n Table B.1  Object Code Operators  . . . . . . . . . . . . . . . . .  B-1\n\n Table C.1  2-Byte Instructions  . . . . . . . . . . . . . . . . . .  C-2\n Table C.2  4-Byte Instructions  . . . . . . . . . . . . . . . . . .  C-3\nB                                  ii\n1\n                               REFERENCES\n+                              REFERENCES\n+                              REFERENCES\n\n\n \u00dd1\u00a8  N.  Wirth:  PL360.  \"A Programming Language for the 360 Computers,\"\n      JACM 15 (1968) 37.\n\n \u00dd2\u00a8  SCIP/Academic Computing  Services  Program  Libraries,  Polya  Hall\n      Stanford University.\n\n \u00dd3\u00a8  J.  Eve:  \"PL360 Language  Extensions,\"  Internal  Note,  Computing\n      Laboratory.  University of Newcastle upon Tyne.\n\n \u00dd4\u00a8  G.  M.  Amdahl, G.  A.  Blaauw, F.  P.  Brooks, Jr.:  \"Architecture\n      of the IBM System/360,\" IBM Journal of Research and  Development  8\n      (1964) 87.\n\n \u00dd5\u00a8  G.  A.  Blaauw et al.  \"The structure of System/360,\"  IBM  Systems\n      Journal 3 (1964) 119.\n\n \u00dd6\u00a8  \"IBM System/360 Principles of Operation,\" IBM A22-6821.\n\n \u00dd7\u00a8  \"IBM System/360 OS Assembler Language,\" IBM C28-6514.\n\n \u00dd8\u00a8  MTS Vol.  I, University of Michigan Computation Center, Ann Arbor.\n\n \u00dd9\u00a8  \"IBM System/360 Linkage Editor and Loader\"  IBM C28-6538.\n\n \u00dd10\u00a8 \"PL360  Programming  Manual,\"  University   Computing   Laboratory,\n      University  of  Newcastle upon Tyne, Caremont Tower, Newcastle upon\n      Tyne, NE1 7RU, England, 1970.\n\n \u00dd11\u00a8 \"IBM System/360 DOS System Control and  System  Service  Programs,\"\n      IBM C24-5036\n\n \u00dd12\u00a8 R.   Fajman  and  J.   Borgelt,  \"ORVYL  User's  Guide,\"   Stanford\n      University Computation Center, 1971.\n\n \u00dd13\u00a8 \"IBM System/360 Disk Operating System Supervisor  and  Input/Output\n      Macros,\" IBM C24-5037.\n\n \u00dd14\u00a8 N.  Wirth:  \"Format of PL360 Programs,\" ALGOL  W  -  Project  Memo,\n      Stanford University, Sept.  9, 1966.\nB                                  iii\n1\n                                FOREWORD\n+                               FOREWORD\n+                               FOREWORD\n\n The intent of this manual is to provide a reference tool for programmers\n using PL360.  Although it is not a textbook, it has  been  organized  in\n such  a  way  that  each  section  introduces  new material dependent on\n information covered in preceding sections.  In that sense, it can  serve\n as a self-teaching aid.\n\n Those readers not familiar with Bacus-Naur  Form  (BNF),  may  find  the\n syntactic  rules  used to describe the language difficult to understand.\n However, the textual descriptions and examples associated with a set  of\n syntactic  rules  should serve to clarify those rules.  Also, the sample\n programs of Appendix A further clarify the language structure.\n\n Knowledge of the 360 architecture \u00dd4, 5 or  6\u00a8  is  a  prerequisite  for\n understanding  the language definition and some familiarity with the 360\n Assembly  Language  \u00dd7\u00a8  and  linkage  editor  \u00dd8\u00a8  is  assumed  in  the\n description of the object code produced by the compiler.\n\n In writing  this  manual,  the  authors  have  drawn  heavily  upon  the\n (anonymous)  PL360  Programming  Manual  published  by the University of\n Newcastle upon Tyne, Computing Laboratory \u00dd10\u00a8.\n\nB                                  iv\n1\n                        SECTION 1.  INTRODUCTION\n+                       SECTION 1.  INTRODUCTION\n+                       SECTION 1.  INTRODUCTION\n\n PL360 is a  programming  language  designed  specifically  for  the  IBM\n System/360 computers.  It provides the facilities for a symbolic machine\n language  but  displays  a structure similar to that of ALGOL.  A formal\n description of an earlier version of the language has been published  by\n Niklaus Wirth \u00dd1\u00a8 who directed the development of the PL360 language and\n its  compiler at the Computer Science Department of Stanford University.\n Although  PL360  was   originally   designed   for   writing   logically\n self-contained programs, subsequent extensions permit communication with\n separately compiled programs.\n\n An efficient one pass \"in core\"  compiler,  written  by  Niklaus  Wirth,\n Joseph  W.  Wells, Jr.  and Edwin Satterthwaite, Jr., which incorporates\n these extensions is available through the Stanford Program Library  \u00dd2\u00a8.\n This  compiler  translates  PL360 source code into object modules in the\n format required by  several  360  operating  systems  (OS  and  MTS  for\n example).   The  documentation issued with the compiler includes several\n amendments to the original language definition.  Further extensions were\n carried out at the University of Newcastle by James Eve.  These  changes\n \u00dd3,10\u00a8  were  aimed  primarily  at  relaxing  the linkage constraints on\n separately compiled programs, enabling for example direct  communication\n with  programs  using  OS/360  type  linkages.   Michael  Malcolm of the\n Stanford Computer Science Department made several modifications  to  the\n version of the compiler produced by James Eve.  These extensions made it\n possible  to  run the compiler and compiled programs under DOS operating\n systems.  Assembly language subroutines were also written  for  both  OS\n and  DOS to facilitate input-output with sequential tape and disk files.\n Dick Guertin of the Stanford Center for Information Processing  extended\n the  syntax of PL360, primarily to increase programming convenience.  He\n has also written assembly language interfaces to allow  interactive  use\n of   both  the  PL360  compiler  and  PL360  programs  under  the  ORVYL\n time-sharing monitor at Stanford.  Andrew Koening of Columbia University\n also contributed improvements to the compiler.\n\n The language  definition  and  compiler  description  incorporating  all\n changes  are  given  in  this  manual.   For  a  full  discussion of the\n background underlying the development of PL360 and a description of  the\n organization   and  development  of  the  compiler  together  with  some\n perceptive comments on the 360 architecture,  reference  must  still  be\n made to \u00dd1\u00a8, where the aims of the language are summarized:\n\n     ... it was decided to develop a tool which would:\n     1.  allow full use  of  the  facilities  provided  by  the  360\n         hardware,\n     2.  provide convenience in writing and correcting programs, and\n     3.  encourage the user to write in a clear  and  comprehensible\n         style.\n\n     As a consequence of 3, it was felt that programs should not  be\n     able  to  modify  themselves.   The  language  should  have the\n     facilities  necessary  to  express  compiler   and   supervisor\n     programs,  and the programmer should be able to determine every\n     detailed machine operation.\nB                                 1-1\n1\n             SECTION 2.  DEFINITION OF THE PL360 ENVIRONMENT\n+            SECTION 2.  DEFINITION OF THE PL360 ENVIRONMENT\n+            SECTION 2.  DEFINITION OF THE PL360 ENVIRONMENT\n\n 2.1 Terminology, Notation, and Basic Definitions\n+2.1 Terminology, Notation, and Basic Definitions\n+2.1 Terminology, Notation, and Basic Definitions\n\n The language is defined in terms of a computer which is comprised  of  a\n number  of  processing units and a finite set of storage elements.  Each\n of the storage elements holds a content,  also  called  value.   At  any\n given  time, certain significant relationships may exist between storage\n elements and values.  These relationships may be recognized and altered,\n and new values may be created by  the  processing  units.   The  actions\n taken  by  the  processors  are  determined  by  a  program.  The set of\n possible programs form the language.  A program is composed of, and  can\n therefore  be  decomposed into elementary constructions according to the\n rules  of  a  syntax,  or  grammar.   To  each  elementary  construction\n corresponds an elementary action specified as a  semantic  rule  of  the\n language.  The action denoted by a program is defined as the sequence of\n elementary  actions  corresponding to the elementary constructions which\n are obtained when the program is decomposed  (parsed)  by  reading  from\n left to right.\n\n\n 2.1.1 The Processor\n+2.1.1 The Processor\n+2.1.1 The Processor\n\n At any time, the state of the processor is described by  a  sequence  of\n bits  called  the  program status word (PSW).  The status word contains,\n among other information,  a  pointer  to  the  next  instruction  to  be\n executed, and a quantity which is called the condition code.\n\n Storage elements are classified into registers and  core  memory  cells,\n simply  called  cells.  Registers are divided into three types according\n to their size and the operations which can be performed on their values.\n The types of registers are:\n\n     a.  integer or logical (a sequence of 32 bits)\n     b.  real (a sequence of 32 bits)\n     c.  long real (a sequence of 64 bits)\n\n Cells are classified into five types according to  their  size  and  the\n type  of  value  which  they  may  contain.  A cell may be structured or\n simple.  The types of simple values and simple cells are:\n\n     a.  byte or character (a sequence of 8 bits = 1 byte)\n     b.  short integer (a sequence of 16 bits = 2 bytes, interpreted\n         as an integer in two's complement binary notation)\n     c.  integer or logical (a  sequence  of  32  bits  =  4  bytes,\n         interpreted  as  an  integer  in  two's  complement  binary\n         notation)\n     d.  real (a sequence of 32 bits = 4  bytes,  interpreted  as  a\n         base-16 floating-point number)\n     e.  long real (a sequence of 64 bits = 8 bytes, interpreted  as\n         a base-16 floating-point number)\n\n The types integer and logical are treated as equivalent in the language,\n and consequently only one of them, namely  integer,  will  be  mentioned\n throughout this manual.  Likewise, byte and character are equivalent and\n only byte is mentioned.\nB                                 2-1\n1\n 2.1.2 Relationships\n+2.1.2 Relationships\n+2.1.2 Relationships\n\n The most fundamental relationship is that which exists  between  a  cell\n and  its value.  It is known as containment; the cell is said to contain\n the value.\n\n Another relationship exists between the cells which are  the  components\n of  a  structured cell, called an array, and the structured cell itself.\n It  is  known  as  subordination.   Structured  cells  are  regarded  as\n containing the ordered set of the values of the component cells.\n\n A set of relationships between values is defined by monadic  and  dyadic\n functions  or  operations,  which  the  processor is able to evaluate or\n perform.  The relationships are defined by mappings between  values  (or\n pairs  of values) known as the operands, and values known as the results\n of the evaluation.  These mappings are not  precisely  defined  in  this\n manual; instead, see \u00dd6\u00a8.\n\n\n 2.1.3 The Program\n+2.1.3 The Program\n+2.1.3 The Program\n\n A program contains declarations and statements.  Declarations  serve  to\n list  the  cells,  registers, procedures, and other quantities which are\n involved in the algorithm described by the  program,  and  to  associate\n names, called identifiers, with them.  Statements specify the operations\n to be performed on these quantities, to which they refer through the use\n of identifiers.\n\n A program is a sequence of tokens, which are basic symbols,  strings  or\n comments.   Every  token  is  itself  a  sequence  of  characters.   The\n following conventions are used:\n\n     a.  Basic  symbols  constitute  the  basic  vocabulary  of  the\n         language (cf.  2.2.2).  They are either single  characters,\n         or uppercase letter sequences.\n     b.  Strings are sequences of characters enclosed in quote marks\n         i.e.  \"string\"  (cf.  3.4).\n     c.  Comments are sequences  of  characters  (not  containing  a\n         semicolon)   preceded  by  the  basic  symbol  COMMENT  and\n         followed by a semicolon (;).  Comments may also be  written\n         as  a  sequence  of  characters  between vertical bars (|).\n         Thus, | this is a comment | It is understood that  comments\n         have no effect on the execution of a program.\n\n In order that a sequence of tokens be an executable program, it must  be\n constructed according to the rules of the syntax.\n\n\n 2.1.4 Syntax\n+2.1.4 Syntax\n+2.1.4 Syntax\n\n A sequence of tokens constitutes an instance of a syntactic  entity  (or\n construct),  if  that  entity can be derived from the sequence by one or\n more  applications  of  syntatic  substitution  rules.   In  each   such\n application,  the  sequence  equal  to  the  right  side  of the rule is\n replaced by the symbol which is its left side.\nB                                 2-2\n1\n Syntactic entities (cf.   Appendix  D, E)  are denoted by english  words\n enclosed  in  brackets  < and >.  These words describe approximately the\n nature of the syntatic entity, and where these words are used  elsewhere\n in  the  text,  they  refer  to  that  syntactic entity.  For reasons of\n notational convenience and brevity, the uppercase letters A,  K,  and  T\n are  also  used  in the denotation of syntactic entities.  They stand as\n abbreviations for any of the following words (or pairs):\n\n             A                K                T\n+            A                K                T\n+            A                K                T\n\n         long real        long real        long real\n         real             real             real\n         integer          integer          integer\n         short integer                     short integer\n                                           byte\n\n Syntactic rules are of the form <E> ::=  &  where  <E>  is  a  syntactic\n entity  (called  the left side) and & is a finite sequence of tokens and\n syntactic entities (called the right side of the rule).  The notation\n\n         <E> ::= &1 | &2 | ... | &n\n\n is used as an abbreviation for the n syntactic rules\n\n            <E> ::= &1, <E> ::= &2, ..., <E> ::= &n\n\n If in the denotations of constituents of the rule the uppercase  letters\n A,  K, or T occur more than once, they must be replaced consistently, or\n possibly according to further rules given in the accompanying text.   As\n an example, the syntactic rule\n\n         <K-register> ::= <K-register identifier>\n\n is an abbreviation for the set of rules\n\n         <long real register> ::= <long real register identifier>\n         <integer register> ::= <integer register identifier>\n         <real register> ::= <real register identifier>\n\n\n 2.2 Identifiers and Basic Symbols\n+2.2 Identifiers and Basic Symbols\n+2.2 Identifiers and Basic Symbols\n\n The implementation imposes  the  restriction  that  only  the  first  10\n characters of identifiers are recognized as significant.\n\n Throughout this section, user defined identifiers are shown in lowercase\n letters to distinguish them from standard identifiers and basic symbols.\n In actual practice,  all  identifiers  are  constructed  from  uppercase\n letters.\nB                                 2-3\n1\n 2.2.1 Identifiers\n+2.2.1 Identifiers\n+2.2.1 Identifiers\n\n     <letter> ::= A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z\n     <digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n     <identifier> ::= <letter> | <identifier><letter> | <identifier><digit>\n     <K-register> ::= <identifier>\n     <T-cell identifier> ::= <identifier>\n     <procedure identifier> ::= <identifier>\n     <function identifier> ::= <identifier>\n     <integer value identifier> ::= <identifier>\n\n An identifier is a K-register, T-cell, procedure, function,  or  integer\n value  identifier,  if  it  has  respectively  been  associated  with  a\n K-register,  T-cell,  procedure,  function,  or  integer value (called a\n quantity) in one of the blocks surrounding  its  occurrence  (cf.  4.1).\n This   association  is  achieved  by  an  appropriate  declaration.  The\n identifier is said to designate the associated  quantity.  If  the  same\n identifier   is  associated  with  more  than  one  quantity,  then  the\n considered occurrence designates the quantity to which it was associated\n in the innermost block embracing the considered occurrence. In  any  one\n block,  an  identifier  must be associated with exactly one quantity. In\n the parse of a program, that association determines which of  the  rules\n given above applies.\n\n Any processing computer  and  operating  system  can  be  considered  to\n provide  an  environment  in which the program is embedded, and in which\n some identifiers are permanently declared.  Some identifiers are assumed\n to be known in every environment; they are called standard  identifiers,\n and are listed in Section 2.2.3.\n\n\n 2.2.2  Basic Symbols\n+2.2.2  Basic Symbols\n+2.2.2  Basic Symbols\n\n Basic symbols which consist of uppercase letter  sequences  shown  below\n are  denoted  by  the same letter sequences without further distinction.\n Such letter sequences are called reserved words and cannot  be  used  as\n identifiers.   Embedded  blanks  are  not  allowed  in  reserved  words,\n identifiers,  and  numbers.   Adjacent  reserved words, identifiers, and\n numbers  must  be  separated  by   at   least   one   blank   or   other\n non-alphanumeric.   Otherwise,  blanks  may  be  used freely.  The basic\n symbols are:\n\n           + - * / ( ) = < > \u00ac\n           , ; . : @ # _ \" ' |\n           DO IF OF OR\n           ABS AND END FOR NEG SYN XOR\n           BASE BYTE CASE DATA ELSE GOTO LONG NULL\n           REAL SHLA SHLL SHRA SHRL STEP THEN\n           ARRAY BEGIN CLOSE DUMMY SHORT UNTIL WHILE\n           COMMON EQUATE GLOBAL\n           COMMENT INTEGER LOGICAL SEGMENT\n           EXTERNAL FUNCTION REGISTER\n           CHARACTER PROCEDURE\nB                                 2-4\n1\n 2.2.3 Standard Identifiers\n+2.2.3 Standard Identifiers\n+2.2.3 Standard Identifiers\n\n The following identifiers are predeclared in the  language  but  may  be\n redeclared  due  to  block  structure.   Their  predefined  meanings are\n specified in Section 5, Section 7.1, or Section 9.1.\n\n     MEM\n     B1 B2 B3 B4 B5 B6 B7 B8 B9 B10 B11 B12 B13 B14 B15\n     R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15\n     F0 F2 F4 F6\n     F01 F23 F45 F67\n     BALR CLC CLI CVB CVD ED EDMK EX IC\n     LA LH LM LTR MVC MVI MVN MVZ NC NI OC OI PACK\n     RESET SET SLDA SLDL SPM SRDA SRDL STC STH STM SVC\n     TEST TM TR TRT TS UNPK XC XI\n     CARRY FALSE MIXED OFF ON OVERFLOW STRING TRUE\n     CANCEL GET KLOSE OPEN PAGE PRINT PUNCH PUT READ WRITE\nB                                 2-5\n1\n                           SECTION 3.  VALUES\n+                          SECTION 3.  VALUES\n+                          SECTION 3.  VALUES\n\n 3.1  Hexadecimal Values\n+3.1  Hexadecimal Values\n+3.1  Hexadecimal Values\n\n Values may be expressed in hexadecimal notation.\n\n     <hexadecimal digit> ::= <digit> | A | B | C | D | E | F\n     <hexadecimal value> ::= # <hexadecimal digit>\n                           | <hexadecimal value> <hexadecimal digit>\n\n A hexadecimal value denotes a sequence of bits.  Each hexadecimal  digit\n stands for a sequence of four bits defined as follows:\n\n       0 = 0000    4 = 0100    8 = 1000    C = 1100\n       1 = 0001    5 = 0101    9 = 1001    D = 1101\n       2 = 0010    6 = 0110    A = 1010    E = 1110\n       3 = 0011    7 = 0111    B = 1011    F = 1111\n\n Note:  If hexadecimal values are used in conjunction with arithmetic  or\n logical operators in a program, they must be considered as a sequence of\n bits  which  constitute  the  computer's representation of the number on\n which the operator is  applied.   Hexadecimal  values  followed  by  the\n letter   R   or  L  may  be  used  to  denote  numbers  in  unnormalized\n floating-point representation \u00dd4,5,6\u00a8.\n\n\n 3.2  Decimal Values\n+3.2  Decimal Values\n+3.2  Decimal Values\n\n     <unsigned integer number> ::= <digit>\n                                 | <unsigned integer number> <digit>\n     <unsigned short integer number> ::= <unsigned integer number> S\n     <fractional number> ::= <unsigned integer number> .\n                           | <fractional number> <digit>\n     <scale factor> ::= <integer number>\n     <floating-point number> ::= <fractional number>\n                               | <fractional number> ' <scale factor>\n                               | <unsigned integer number> ' <scale factor>\n     <unsigned real number> ::= <floating-point number>\n                              | <unsigned integer number> R\n     <unsigned long real number> ::= <floating-point number> L\n                                   | <unsigned integer number> L\n     <A-number> ::= <unsigned A-number>\n                  | _ <unsigned A-number>\n\n Integer,  real,  and  long  real  numbers  are  represented  in  decimal\n notation.  The latter two can be followed by a scale factor denoting  an\n integral power of 10.  Short integers are distinguished from integers by\n the  letter  S  following  the  number.   In  order to denote a negative\n number, an unsigned number is preceded by  the  underscore  symbol  \"_\".\n (Note:  the underscore is used so as not to confuse negative values with\n the subtract operator \"-\", which is never part of a number.)\n\n Note:  A-number is an abbreviation for  long real number,  real  number,\n short integer number and integer number as defined in section 2.1.4 as a\n notational convenience.\nB                                 3-1\n1\n 3.3  Numeric Values\n+3.3  Numeric Values\n+3.3  Numeric Values\n\n     <byte value> ::= <integer number> X\n     <short integer value> ::= <short integer number>\n                             | <hexadecimal value> S\n     <integer value> ::= <integer number>\n                       | <hexadecimal value>\n                       | <integer value identifier>\n     <real value> ::= <real number>\n                    | <hexadecimal value> R\n     <long real value> ::= <long real number>\n                         | <hexadecimal value> L\n\n Examples:\n\n      byte values:             2X     _5X\n      short integer values:   10S     #FF00S\n      integer values:          0      #106C      _1     size\n      real values:            1.0     _3.14      2.7'8  #46000001R\n      long real values:       0L      3.14159265359L    #4E00000000000001L\n\n\n 3.4  String Values\n+3.4  String Values\n+3.4  String Values\n\n There are also string values,  but  these  are  not  generally  used  in\n conjunction with arithmetic or logical operators.\n\n     <string> ::= \" <character sequence> \"\n                | <hexadecimal value> X\n     <character sequence> ::= <character>\n                            | <character sequence> <character>\n     <character> ::= <any EBCDIC character except \"> | \"\"\n\n When a string is a character  sequence  enclosed  in  quote  marks,  the\n string  is limited to a total of 255 characters.  If a quote mark (\") is\n to be a character of the sequence,  it  is  represented  by  a  pair  of\n consecutive quote marks.\n\n When a string is a hexadecimal value ending in X, up to  16  hexadecimal\n digits may be specified.  Each pair of hexadecimal digits represents one\n character.   If  the  number  of  hexadecimal digits specified is odd, a\n hexadecimal 0 is prefixed to the specified value to make the total even.\n\n Examples:  \"ABC\"          denotes the sequence  ABC\n            \"A\"\"Z\"         denotes the sequence  A\"Z\n            #C1C2C3X       denotes the sequence  ABC\nB                                  3-2\n1\n                       SECTION 4.  PROGRAM FORMAT\n+                      SECTION 4.  PROGRAM FORMAT\n+                      SECTION 4.  PROGRAM FORMAT\n\n Compiler  input  records  consist  of  80  characters.   The  first   72\n characters  of  each  record  are  processed as part of a PL360 program;\n characters 73  through  80  are  listed  but  not  otherwise  processed.\n Character  72  of one record is considered to be immediately followed by\n character 1 of the next record.  Character position 1  may  contain  any\n character except '$' or any other character (e.g., /) that would  signal\n a compiler control statement or job control statement.\n\n\n 4.1  Block Structure\n+4.1  Block Structure\n+4.1  Block Structure\n\n     <program> ::= <block> . |\n          GLOBAL <simple procedure heading>;<statement> . |\n          GLOBAL <simple procedure heading> BASE <integer register>;<statement> .\n     <block> ::= <block body> END\n     <block body> ::= <block head> | <block body><statement>; |\n          <block body><label definition>\n     <block head> ::= BEGIN | <block head><declaration>;\n     <declaration> ::= <T-cell declaration> |\n          <function declaration> | <procedure declaration> |\n          <T-cell synonym> | <K-register synonym> |\n          <integer value synonym> |\n          <segment base declaration> | <segment close declaration>\n     <label definition> ::= <identifier> :\n     <statement> ::= <simple statement> | <IF statement> |\n          <WHILE statement> | <FOR statement>\n     <simple statement> ::= <K-register assignment> |\n          <T-cell assignment> | <function designator> |\n          <procedure statement> | <CASE statement> | <GOTO statement> |\n          <block> | NULL\n\n A block has the form\n\n     BEGIN D; D; ...; D; S; S; ...; S; END\n\n where the  D's  stand  for  declarations  and  the  S's  for  statements\n optionally  preceded by label definitions.  END may be labeled.  The two\n main purposes of a block are:\n\n     1.  To enclose a sequence of statements into a structural  unit\n         which  as a whole is classified as a simple statement.  The\n         constituent statements are executed in sequence  from  left\n         to right.\n     2.  To introduce new quantities and associate identifiers  with\n         them.   These  identifiers  may  be  used to refer to these\n         quantities in any of the declarations and statements within\n         the block, but are not known outside the block.\n\n The symbol NULL denotes a simple statement which implies  no  action  at\n all.\nB                                 4-1\n1Example of a block:\n\n     BEGIN INTEGER BUCKET;\n          IF FLAG THEN\n          BEGIN BUCKET := R0; R0 := R1; R1 := R2;\n                R2 := BUCKET;\n          END ELSE\n          BEGIN BUCKET := R2; R2 := R1; R1 := R0;\n               R0 := BUCKET;\n          END\n          RESET(FLAG);\n     END\n\n The addressing mechanism of the 360 computers is such that  instructions\n can  indicate  addresses  only relative to a base address contained in a\n register.  The programmer must insure that\n\n     1.  every address in the program specifies a \"base\" register\n     2.  the specified register is loaded with the appropriate  base\n         address  whenever an instruction whose address refers to it\n         is executed\n     3.  the difference d between the desired absolute  address  and\n         the available base address satisfies 0 <= d < 4096\n\n This scheme  not  only  increases  the  amount  of  'clerical'  work  in\n programming,  but  also constitutes a rich source of pitfalls.  PL360 is\n designed to ease the tedious task of base  address  assignment,  and  to\n provide checking facilities against errors.\n\n The solution adopted here is that of program segmentation.  The  program\n is  subdivided  into  individual parts, called segments.  Every quantity\n defined within the program is known by the  number  of  the  segment  in\n which  it  occurs and by its displacement relative to the origin of that\n segment.  The problem then  consists  of  subdividing  the  program  and\n choosing base registers in such a way that\n\n     a.  the compiler knows which register is used as base for  each\n         compiled address\n     b.  the compiler can assure that each  base  register  contains\n         the desired base address during execution\n     c.  the number  of  times  base  addresses  are  reloaded  into\n         registers is reasonably small\n\n It was decided \u00dd1\u00a8 that the programmer should express  explicitly  which\n parts  of  the program are to constitute segments.  The program may then\n be organized in a way that  minimizes  the  number  of  cross-references\n between segments.\n\n It should be noted that a programmer's knowledge about segment sizes and\n occurrences of cross-reference is quite different for programs than  for\n data.   In the latter case the programmer is aware of the precise amount\n of storage needed for the declared quantities, and knows precisely where\n in the program references to a specific  data  segment  occur.   In  the\n former  case,  knowledge  about  the eventual size of a compiled program\n section is only vague, and the programmer is sometimes  unaware  of  the\n occurrence  of branch instructions implicit in certain constructs of the\n language.  It was therefore decided  \u00dd1\u00a8  to  treat  programs  and  data\n differently;  this  decision  also  conformed  with  the desirability of\n keeping program and data apart as separate entities.\nB                                 4-2\n1\n 4.2  Program Segmentation\n+4.2  Program Segmentation\n+4.2  Program Segmentation\n\n A program segment corresponds to a  CSECT  in  assembly  language.   The\n outermost  block of a program is always compiled as a segment.  Since by\n its very nature control lies in exactly one segment at any instant,  one\n register  is  designated to hold the base address of the program segment\n currently executing.  Register R15 is  usually  used  for  this  purpose\n (however,   cf.   8.1,   10.1.5).    Branching  to  another  segment  is\n accomplished with a procedure statement which causes the program segment\n base register of the destination segment to  be  loaded  with  its  base\n address before branching into that segment (cf. 8.2).\n\n The natural unit for a program segment is the procedure (cf. 8.1).   The\n normal  way to enter a procedure is via a procedure statement (cf. 8.2),\n and the normal way to leave it is at its end, or by a  call  to  another\n procedure  which  does not return.  An explicit GOTO statement cannot be\n used for branching from one segment to  another,  but  may  be  used  to\n branch  out  of  a  local  procedure within a segment.  The fact that no\n implicitly generated instructions can ever lead  control  outside  of  a\n segment mimimizes the number of cross references in a natural way.  Only\n relatively  large  procedures  should constitute program segments, and a\n facility  is  provided  to  designate  such  procedures  explicitly.   A\n procedure to be compiled as a program segment must  contain  the  symbol\n SEGMENT or GLOBAL in its heading.\n\n\n 4.3  Data Segmentation\n+4.3  Data Segmentation\n+4.3  Data Segmentation\n\n For data, the programmer is aware of the  precise  amount  of  allocated\n memory  and  of  the  instances  where  references  are  made  to  these\n quantities.   A  base declaration was therefore introduced which implies\n that all quantities  declared  thereafter  within  the  same  block  and\n preceding  another  base declaration, refer to the specified register as\n their base.  These quantities form a data segment.  At the place of  the\n base  declaration,  an  instruction is compiled which loads the register\n with the appropriate segment address (except for dummy base declarations\n and BASE R0); however, its  previous  contents  are  neither  saved  nor\n restored upon exit from the block.\n\n Data segments declared in parallel (i.e., not nested) blocks, can safely\n refer to the same base register.  Data segments declared within the same\n block usually refer to different base registers.  Data segments declared\n within nested blocks should also refer to different base registers.   If\n they  do  not,  it is the programmer's responsibility to ensure that the\n register is appropriately loaded when a segment is addressed.\n\n There is no limit to the size of data segments.   All  cell  identifiers\n must,  however,  refer  to cells whose addresses differ from the segment\n base address by less than 4096.  If they do not, the  compiler  provides\n an appropriate diagnostic.\nB                                 4-3\n1\n\n 4.4  Main Program\n+4.4  Main Program\n+4.4  Main Program\n\n A PL360 program which is a block is  considered  to  be  embedded  in  a\n global procedure such as the following:  (cf.  8.1)\n\n       GLOBAL PROCEDURE SEGN001 (R14) BASE R15;\n       BEGIN  STM(R14,R12,B13(12));  R14 := R13;\n          BEGIN  GLOBAL DATA SEGN000 BASE R13;\n                    ARRAY 18 INTEGER B13;\n             B13(4) := R14;  B14(8) := R13;\n             B14(16) := B14(16) XOR B14(16);\n\n             BEGIN  COMMENT  Main program block;\n             END;\n\n             R13 := B13(4);  LM(R14,R12,B13(12));\n          END;\n       END.\n\n The 18  integer  area  is  reserved  to  conform  to  procedure  calling\n conventions (cf. 9.1). If the PL360 program is a global procedure, there\n is no implicit base declaration for the data area (cf. 4.3).\n\n\n When a program is defined as a block, the compiler supplies  a  transfer\n address for the linkage editor or loader \u00dd9\u00a8, and provides the necessary\n entry  and  exit  code for linking with a standard operating system (cf.\n 10.1.3).\n\n When a program is defined as a global procedure, no transfer address  is\n supplied, and all linkage code must be written by the programmer.\n\n Both types of program are included in the sample programs of Appendix A.\nB                                 4-4\n1                       SECTION 5.  DECLARATIONS\n+                       SECTION 5.  DECLARATIONS\n+                       SECTION 5.  DECLARATIONS\n\n 5.1  Register Synonym Declarations\n+5.1  Register Synonym Declarations\n+5.1  Register Synonym Declarations\n\n The System/360 processor has 16 registers which contain integer  numbers\n and are said to be of type integer (or logical).  They are designated by\n the standard register identifiers:  R0 through R15  (cf.  2.2.3).\n\n The processor also has four registers which contain real numbers or long\n real numbers.  If those registers are  used  in  conjunction  with  real\n numbers,  they  are  said  to be of type real, and are designated by the\n standard register identifiers:\n\n               F0, F2, F4, F6\n\n If they are used in conjunction with long real numbers, they are said to\n be of type long real,  and  are  designated  by  the  standard  register\n identifiers:\n\n               F01, F23, F45, F67\n\n The above register identifiers are assumed to be predeclared,  and other\n identifiers can  be  associated  with  these  registers.   Reference  to\n specific registers in the text apply to register synonyms also.\n\n     <K-register synonym> ::=\n          <simple K-type> REGISTER <identifier> SYN <K-register> |\n          <K-register synonym> , <identifier> SYN <K-register>\n\n\n 5.2  Seqment Base Declarations\n+5.2  Seqment Base Declarations\n+5.2  Seqment Base Declarations\n\n     <segment base declaration> ::=\n          <segment base heading> BASE <integer register>\n     <segment base heading> ::= SEGMENT | GLOBAL DATA <identifier> |\n          EXTERNAL DATA <identifier> | COMMON DATA <identifier> |\n          COMMON | DUMMY\n     <segment close declaration> ::= CLOSE BASE\n\n A segment base declaration causes the  compiler  to  use  the  specified\n register  as the base address for the cells subsequently declared in the\n block in which the base declaration occurs.  The segment  is  terminated\n either  by  the  END  of  the block or by the subsequent appearance of a\n segment close declaration.  Upon entrance to this block, the appropriate\n base address is assigned to the specified base register except  for  the\n dummy  base  declaration and base declarations that specify BASE R0 (cf.\n 4.3).\n\n If the symbol DATA is preceded by any of the symbols GLOBAL, EXTERNAL or\n COMMON, the corresponding identifier is associated with the data segment\n to enable linking of segments  in  different  PL360  programs  \u00dd8,9,12\u00a8.\n Appearance   of   the   symbol  sequence  COMMON  BASE  causes  a  blank\n identification to be associated with the segment (cf.  10.4).\nB                                 5-1\n1\n Note:  Dummy base declarations permit  the  description  of  data  areas\n which  are  created  during  the  execution  of  the PL360 program.  Any\n integer register may be specified in a dummy base declaration.  When  R0\n (or  a  synonym  to  R0)  is  specified  in  any  base  declaration, the\n subsequent identifiers are understood to have displacements and no  base\n register (or index register).\n\n\n 5.3  Cell Declarations\n+5.3  Cell Declarations\n+5.3  Cell Declarations\n\n     <simple byte type> ::= BYTE | CHARACTER\n     <simple short integer type> ::= SHORT INTEGER\n     <simple integer type> ::=  INTEGER | LOGICAL\n     <simple real type> ::= REAL\n     <simple long real type> ::= LONG REAL\n     <T-type> ::= <simple T-type> | ARRAY <integer value><simple T-type>\n     <T-cell declaration> ::= <T-type><item> | <T-cell declaration>,<item>\n     <item> ::= <identifier> | <identifier> = <fill value>\n     <fill value> ::= <T-value> | <string> |\n          @<procedure identifier> | @@<procedure identifier> |\n          @<T-cell designator> | @@<T-cell identifier> |\n          <repetition list><fill value>)\n     <repetition list> ::= ( | <integer value>( |\n          <repetition list><fill value>,\n\n A cell declaration introduces identifiers and associates them with cells\n of a specified type belonging to the currently active  base  declaration\n segment  (cf.  4.3).  The scope of validity of these cell identifiers is\n the block in whose heading the declaration occurs (cf.  4.1).  Moreover,\n a declaration may specify the assignment of  an  initial  value  to  the\n introduced  cell.  This assignment is understood to have occurred before\n execution of the program.\n\n A cell may be  initialized  to  numeric  values,  strings,  relative  or\n absolute addresses.  The number of bytes appropriate for the type of the\n declared  cell  is  taken for each (numeric) T-value.  Strings are never\n expanded or truncated;  each character of the string occupies  one byte,\n initialization  starting  with  the  leftmost  byte.  A short integer or\n integer type cell can be initialized to the relative address (i.e., base\n register and displacement) corresponding to a T-cell  identifier  or  to\n the   relative  (entry  point)  address  corresponding  to  a  procedure\n identifier by means of the @ operator.  The @ operator also permits  the\n initialization  of an integer type cell with the relative address (i.e.,\n index register, base register and displacement) of a T-cell  designator.\n The  @@  operator  enables  integer  type  cells  to be initialized with\n absolute addresses corresponding to T-cell identifiers or to  the  entry\n point of procedure identifiers.\n\n If a simple type is preceded by the symbol ARRAY and an  integer  value,\n say  n  , then the declared cell is an array (ordered set) of n cells of\n the specified simple type.  An initial value list with m  <=  n  entries\n specifies  the  initial  values of the first m elements of the array.  A\n list may be specified as a list of sublists.  Repetition of  a  sequence\n of  elements  may  be  specified  by making the sequence into a list and\n preceding it by an integer value, say k , specifying the number of times\n the list is to be used.  If no integer value precedes a list, it is used\n once.  Absolute addresses may not occur in lists where k > 1 .   Integer\n values n and k must be positive.\nB                                 5-2\n1\n Note:  Boundary alignment is performed for a cell declaration (according\n to the simple type)  and  not  for  each  initializing  value.   Because\n strings  are never expanded or truncated, care is needed in initializing\n with combinations of strings and other values.\n\n Examples:\n     BYTE flag\n     SHORT INTEGER i,j,k = 10S,m = (5), baddr = @basepoint\n     LONG REAL x,y,z = 27'3L\n     ARRAY 3 INTEGER size = (36,23,37),parmlist = (@@a,@@b,@@erproc)\n     ARRAY 132 BYTE blank = 132(\" \"),buff = 33(\" \",2(\"*\"),\" \")\n     ARRAY fbsize LOGICAL area = fbsize(0)\n\n\n 5.4  Cell Designators\n+5.4  Cell Designators\n+5.4  Cell Designators\n\n     <T-cell designator> ::= <T-cell identifier>\n         | <T-cell identifier> ( <index> / <integer value expression> )\n         | <T-cell identifier> ( <index> )\n     <index> ::= <integer value expression>\n         | <integer register expression>\n         | <integer register expression> + <integer value expression>\n         | <integer register expression> - <integer value expression>\n     <integer register expression> ::= <integer register>\n         | <integer register> + <integer register>\n     <integer value expression> ::= <integer value>\n         | <integer value expression> + <integer value>\n         | <integer value expression> - <integer value>\n\n Note:  The second form of <T-cell designator> may be  specified  at  any\n time, but only has meaning for the first <T-cell designator> of\n\n     <T-cell assignment> ::= <T-cell designator> := <T-cell value>\n and\n     <condition> ::= <T-cell designator> <relation> <T-cell value>\n\n In these two cases, the integer value expression following the slash (/)\n specifies the number of bytes to be moved or compared (cf.  6.3, 6.5).\n\n Cells are denoted by cell designators.  The designator for a  particular\n cell  consists  of  the identifier associated with that cell, optionally\n followed by an index or  index/length.   When  an  index  is  used,  the\n address  of  the designated cell is taken as the address associated with\n the cell identifier plus the value of the index.  If a length is  to  be\n specified  when  no  index  is  required,  an  index  value of 0 must be\n specified before the slash; e.g., cell(0/length).\n\n Note:  Register R0 or synonym (cf 5.1) must not be specified as an index\n constituent.  Depending upon the function with which the cell designator\n is used and the declaration of the cell identifier, the index  may  have\n 0,  1 or 2 integer register constituents.  If the cell identifier has no\n base register associated with it, then the first  integer  register  (if\n any)  in  the  index is understood to be the base register.  If the cell\n identifier has a base register  associated  with  it,  and  the  context\n permits  an  index  register,  then  an integer register in the index is\n taken as an index register.  If the identifier has  no  associated  base\n register  and  the  context permits indexing, then two integer registers\n may appear in the index and they are understood to be the base  register\n and index register, respectively.\nB                                 5-3\n1Examples:\n\n         age               B1(1)\n         size(8)           B14(R2)\n         price(R1)         MEM(R3+R7+8)\n         line(R2+15)       buff(R1+R4-2)\n         val(0/20)         status(R1/len-1)\n\n\n 5.5  Cell Synonym Declarations\n+5.5  Cell Synonym Declarations\n+5.5  Cell Synonym Declarations\n\n     <T-cell synonym> ::=\n           <T-type><identifier><synonymous cell> |\n           <T-cell synonym> , <identifier><synonymous cell>\n     <synonymous cell> ::= SYN <T-cell designator> | SYN <integer value>\n\n Cell synonyms serve to associate synonymous identifiers with  previously\n (i.e., preceding in the text) declared cells.  The types associated with\n the synonymous cell identifiers need not necessarily agree.\n\n If a synonymous cell is specified by an integer value, then that integer\n value represents the displacement (and possibly the  base  register  and\n index register) part of the cell's machine address.\n\n Examples:    INTEGER a16 SYN a(16)\n              ARRAY 32768 SHORT INTEGER memory SYN 0\n              INTEGER timer SYN #50\n\n The following example defines the standard integer identifiers:\n\n     INTEGER MEM SYN 0,          B5 SYN MEM(R5),     B10 SYN MEM(R10),\n             B1 SYN MEM(R1),     B6 SYN MEM(R6),     B11 SYN MEM(R11),\n             B2 SYN MEM(R2),     B7 SYN MEM(R7),     B12 SYN MEM(R12),\n             B3 SYN MEM(R3),     B8 SYN MEM(R8),     B13 SYN MEM(R13),\n             B4 SYN MEM(R4),     B9 SYN MEM(R9),     B14 SYN MEM(R14),\n                                                     B15 SYN MEM(R15),\n\n\n Note:   The  synonym  declaration  can  be  used  to  associate  several\n different types with a single cell.   Each  type  is  connected  with  a\n distinct identifier.\n\n Example:      LONG REAL x = #4E0000000000000L\n               INTEGER xlow SYN x(4)\n\n A conversion operation from  a  number  of  type  integer  contained  in\n register  R0 to a number of type long real contained in register F01 can\n now be denoted by\n\n               xlow := R0;  F01 := F01 - F01 + x;\n\n and a conversion vice-versa by\n\n         F01 := F01 ++ #4E00000000000000L;  x := F01;  R0 := xlow;\n\n No initialization can be achieved by a synonym declaration.\nB                                 5-4\n1\n 5.6  EQUATE Declarations\n+5.6  EQUATE Declarations\n+5.6  EQUATE Declarations\n\n     <integer value synonym> ::=\n          EQUATE <identifier><synonymous integer value> |\n          EQUATE <identifier> SYN <string> |\n          EQUATE <identifier> SYN <register name> |\n          <integer value synonym>,<identifier><synonymous integer value>\n     <synonymous integer value> ::= SYN <integer value> |\n          SYN <syn cell value> | SYN <monadic operator><integer value> |\n          <synonymous integer value><arithmetic operator><integer value> |\n          <synonymous integer value><logical operator><integer value> |\n          <synonymous integer value><shift operator><integer value>\n     <syn cell value> ::= <T-cell designator> - <T-cell designator>\n\n Integer value synonyms  serve  to  associate  identifiers  with  integer\n values.   These  integer values are computed at the time the declaration\n is parsed and the identifiers thus associated can subsequently  be  used\n as  integer  values  (cf.  2.2.1, 3.3).  When the difference of two cell\n designators is specified, the cell identifiers must both have  the  same\n base  register  (cf.   5.2).   The  difference  between  their  relative\n locations  within  the segment is taken as the associated integer value.\n The cell designators  must  not  use  index  registers.   The  scope  of\n validity  of  these  integer  synonyms is the block in whose heading the\n declaration occurs (cf.  4.1).\n\n See sections 6.1 and 6.2 for definitions of monadic, arithmetic, logical\n and shift operators.\n\n Examples:    EQUATE a SYN 200, b SYN a+8, c SYN 4\n              EQUATE d SYN a/c AND _4\n              ARRAY b BYTE x, y\n              EQUATE e SYN y-x, f SYN e-c SHLL 2\n\n Note:  a = 200,  b = 208,  c = 4,  d = 48,  e = 208,  f = 816\nB                                 5-5\n1                        SECTION 6.  STATEMENTS\n+                        SECTION 6.  STATEMENTS\n+                        SECTION 6.  STATEMENTS\n\n 6.1  Register Assignments\n+6.1  Register Assignments\n+6.1  Register Assignments\n\n     <T-primary> ::= <T-value> | <T-cell designator>\n     <K-primary> ::= <K-register>\n\n A primary is either a value or the contents  of  a  designated  cell  or\n register.\n\n     <simple K-register assignment> ::=\n          <K-register> := <A-primary> |\n          <K-register> := <monadic operator><A-primary> |\n          <integer register> := <string> |\n          <integer register> := @ <T-cell designator> |\n          <integer register> := @ <procedure identifier>\n\n A simple register assignment is said to specify the  register  appearing\n to  the  left  of  the  assignment  operator  (:=).  To this register is\n assigned the value designated by the  construct  to  the  right  of  the\n assignment  symbol.   That  designated  value  may  be  obtained through\n execution of a monadic operation specified by a monadic operator.\n\n     <monadic operator> ::= ABS | NEG | NEG ABS\n\n The monadic operations are taking the absolute  value,  sign  inversion,\n and sign inversion after taking the absolute value.\n\n If a string is assigned to a register, that string must consist  of  not\n more   than  four  characters.   If  it  consists  of  fewer  than  four\n characters, null characters (#00X) are  appended  at  the  left  of  the\n string.   The  bit  representation  of  characters  is defined in EBCDIC\n \u00dd4,5,6\u00a8.\n\n The construction with the symbol @ is used to assign  to  the  specified\n register the address of the designated cell or the entry  point  address\n of the procedure.\n\n The legal combinations of types to be substituted respectively  for  the\n letters  K  and  A in preceding and subsequent rules of this section are\n given in Table 6.1.\n\n\n                        K                A\n+                       K                A\n+                       K                A\n                     integer          integer\n                     integer          short integer\n                     real             real\n                     long real        real\n                     long real        long real\n\n        Table 6.1 - Allowable Cell and Register Type Combinations\n+       Table 6.1 - Allowable Cell and Register Type Combinations\n+       Table 6.1 - Allowable Cell and Register Type Combinations\n\n\n Examples of simple register assignments:\n\n               R0  := i                 R2  := \"xyz\"\n               R2  := R10               F45 := NEG F01\n               R6  := age               R13 := ABS height\n               F0  := quant(R1)\nB                                 6-1\n16.2  Register Assignment Expressions\n+6.2  Register Assignment Expressions\n+6.2  Register Assignment Expressions\n\n     <K-register assignment> ::= <simple K-register assignment>\n         | <K-register assignment> <arithmetic operator> <A-primary>\n         | <K-register assignment> =: <K-register>\n         | <K-register assignment> =: <A-cell designator>\n         | <integer register assignment> <logical operator> <integer primary>\n         | <integer register assignment> <shift operator> <integer value>\n         | <integer register assignment> <shift operator> <integer register>\n\n     <arithmetic operator> ::= + | - | * | / | ++ | --\n     <logical operator> ::= AND | OR | XOR\n     <shift operator> ::= SHLL | SHLA | SHRL | SHRA\n\n A register assignment is said to specify  the  same  register  which  is\n specified  by  the simple register assignment or the register assignment\n from which it is derived.   To  this  register  is  assigned  the  value\n obtained  by  applying  a  dyadic  operator to the current value of that\n specified register and the value of the primary following the  operator.\n The   operations  are  the  arithmetic  operations  of  addition  (+)  ,\n subtraction (-) , multiplication (*) , and division (/)  ,  the  logical\n operations  of  conjunction  (AND),  exclusive and inclusive disjunction\n (XOR, OR), and those of shifting to the left and right,  as  implemented\n in   the  System/360.   The  operators  ++  and  --  denote  logical  or\n unnormalized  addition  and  subtraction  when  applied  to  integer  or\n real/long  real  registers  respectively.   When  an  integer  value  is\n specified following a shift operator, it must be  nonnegative  and  less\n than  31.   The  reverse-assignment  operator  (=:)  specifies  that the\n contents of the assigned register are to be stored in  the  register  or\n cell following the operator.\n\n Examples of register assignments:\n\n               R0  := R3\n               R1  := 10 * x =: x\n               R10 := i + age - R3 AND size(8)\n               R9  := R8 AND R7 SHLL 8 OR R6\n               F2  := 3.1416\n               F0  := quant(R1) * price(R1)\n               F45 := F23 + F01\n\n\n Note: 1.  The syntax implies  that  sequences  of  operators,  including\n           assignment, are executed strictly from left to right.  Thus\n               R1  := R2 + R1\n           is not equivalent to\n               R1  := R1 + R2\n           but rather to the two statements\n               R1  := R2; R1 := R1 + R1 .\n           This  single  aspect  of  PL360  provides  many  pitfalls  for\n           beginners.\n\n       2.  Multiplication and division with integer operands can only  be\n           specified with a multiplicand or dividend register Rn, where n\n           is odd.  The register Rm with m = n-1 is then used to hold the\n           extension   to   the   left   of   the  product  and  dividend\n           respectively.  In the case of division, register  Rm  will  be\n           assigned the resulting remainder.\nB                                 6-2\n1\n       Examples:  R3 := x * y +z\n                     R2 is affected by the multiplication.\n                  R5 := B1/15\n                     R4 participates in the division and contains the\n                     remainder.\n\n\n 6.3  Cell Assignments\n+6.3  Cell Assignments\n+6.3  Cell Assignments\n\n     <T-cell assignment> ::= <A-cell designator> := <K-register>\n                   | <T-cell designator> := <T-cell value>\n                   | <T-cell assignment> <logical operator> <T-cell value>\n     <T-cell value> ::= <T-cell designator>\n                      | <T-value>\n                      | <string>\n\n In the first assignment, the value in the K-register is assigned to  the\n designated  A-cell.   The  allowable  combinations  of cell and register\n types are indicated in Table 6.1.  Cells may be indexed.\n\n In the second assignment, the T-cell, T-value or string is  assigned  to\n the   designated  T-cell.   The  third  form  is  a  logical  assignment\n expression in which the assigned cell is  logically  combined  with  the\n specified T-cell, T-value or string.  Cell designations must not include\n an  index register (cf.  5.4).  For cell to cell, the cell types must be\n identical or the assigned cell must include a length specification  (cf.\n 5.4).   For  string  to cell, the entire string is moved to or logically\n combined with the assigned cell regardless of cell type when a length is\n not specified, or the shorter of the string length or  specified  length\n is  used.   For  value  to  cell, the allowable combinations of cell and\n value are indicated in the following table:\n\n Note: Length specifications should not be used for value to cell.\n\n                      T-cell           T-value\n+                     T-cell           T-value\n+                     T-cell           T-value\n                    long real         long real\n                    real              real, integer\n                    integer           integer, real\n                    short integer     integer*, short integer\n                    byte              integer*, short integer*, byte\n\n                 Table 6.2 - Allowable Cell and Value Combinations\n+                Table 6.2 - Allowable Cell and Value Combinations\n+                Table 6.2 - Allowable Cell and Value Combinations\n\n                             * unused portions of the T-value must\n                               be all 0 or all 1 bits (sign).\n\n\n Examples of cell assignments:  i := R0\n                                price(R1) := F0\n                                x := F67\n                                price(R1) := price(R2)\n                                y := 30\n                                j := \"A\"\n                                z(0/5) := z XOR z(5)\nB                                 6-3\n16.4  GOTO Statements and Labels\n+6.4  GOTO Statements and Labels\n+6.4  GOTO Statements and Labels\n\n     <GOTO statement> ::= GOTO <identifier>\n\n The interpretation of a GOTO statement proceeds with the following steps:\n\n     1.  Consider the innermost block containing the GOTO statement.\n     2.  If the identifier designates a  program  point  within  the\n         considered  block,  then  program execution resumes at that\n         point.\n     3.  Otherwise, execution of the block is regarded as terminated\n         and the innermost block surrounding it is considered.\n     4.  If this block  is  in  the  same  program  segment  as  the\n         previous blocks, then step 2 is repeated.\n     5.  Otherwise, the identifier is undefined (cf. 4.2).\n\n Label definitions serve to label points in a block.  The  identifier  of\n the  label  definition is said to designate the point in the block where\n the label definition occurs.  GOTO statements may refer to  such  points\n (cf.   4.1).   The identifier can be chosen freely, with the restriction\n that no two points in the same block  may  be  designated  by  the  same\n identifier.\n\n\n 6.5  Conditions and Compound Conditions\n+6.5  Conditions and Compound Conditions\n+6.5  Conditions and Compound Conditions\n\n     <condition> ::= <T-cell designator> <relation> <T-cell value>\n                   | <byte cell designator>\n                   | \u00ac <byte cell designator>\n                   | <K-register> <relation> <A-primary>\n                   | <integer register> <relation> <string>\n                   | <relation>\n                   | <integer value>\n                   | \u00ac <integer value>\n     <relation> ::=  = | \u00ac= | < | <= | >= | >\n\n A condition is said to be met or not met.  In the first  condition,  the\n T-cell  preceding  the  relation  is compared to the T-cell, T-value, or\n string  specified  after  the  relation.   The  comparison  is   logical\n (unsigned).   The  condition  is  met  if  the  specified relation holds\n between the values of the compared quantities.   The  same  restrictions\n apply  regarding  combinations  allowable as apply to the second form of\n T-cell assignment (cf.  Table 6.2).  A condition  specified  as  a  byte\n cell  (or  a  byte  cell preceded by \u00ac ) is met if the value of the byte\n cell is #FF (or not  #FF).   The  condition  consisting  of  a  relation\n enclosed  by  a  register and a primary is met if the specified relation\n holds between the current values of the register and the primary.   When\n an  integer  register is compared to a string, the comparison is logical\n (unsigned),  and  the  string  must  consist  of  not  more  than   four\n characters.  If it consists of fewer than four characters, the string is\n right  justified  and null characters (#00X) are prefixed at the left to\n form a four character string.  The condition is  met  if  the  specified\n relation  holds  between  the  register  and  the  string.   A condition\n consisting of only a relation is  met  if  the  condition  code  of  the\n processor  (cf.   2.1.1) is in a state specified by the symbols of Table\n 6.3 on the following page.  A condition consisting of an  integer  value\n (or an integer value preceded by \u00ac ) is met if the condition code of the\n processor  is  in  a  state (or not in a state) specified by summing the\n integer components from Table 6.3 to arrive  at  the  specified  integer\nB                                 6-4\n1value.   Table  6.3  also contains predeclared integer value identifiers\n which may be used as specified (or preceded by \u00ac to  obtain  all  states\n except the specified state).\n\n   <compound condition> ::= <combined condition>\n                          | <alternative condition>\n   <combined condition> ::= <stat condition>\n                          | <combined condition> AND <stat condition>\n   <alternative condition> ::= <stat condition>\n                             | <alternative condition> OR <stat condition>\n   <stat condition> ::= <condition>\n                      | <statement> ; <condition>\n\n A compound condition is either of the form c1 AND c2 AND c3 ...  AND  cn\n which  is  said to be met, if and only if all the constituent conditions\n are met, or of the form c1 OR c2 OR c3 ...  OR cn which is  said  to  be\n met,  if  and only if at least one of the constituent conditions is met.\n Note that each condition may be prefaced by a statement and  semi-colon.\n In such a case, the statement is done before the associated condition is\n tested.\n                ________________________________________\n               |   identifier      |        state       |\n+              |   identifier      |        state       |\n+              |   identifier      |        state       |\n+               ________________________________________\n               |                   |                    |\n               |   overflow        |          3         |\n               |                   |                    |\n               |     on            |          3         |\n               |                   |                    |\n               |     off           |          0         |\n               |                   |                    |\n               |    mixed          |          1         |\n               |                   |                    |\n               |    carry          |          1         |\n               |                   |                    |\n+               ________________________________________\n               | integer component |        state       |\n+              | integer component |        state       |\n+              | integer component |        state       |\n+               ________________________________________\n               |                   |                    |\n               |        8          |          0         |\n               |                   |                    |\n               |        4          |          1         |\n               |                   |                    |\n               |        2          |          2         |\n               |                   |                    |\n               |        1          |          3         |\n               |                   |                    |\n+               ________________________________________\n               |    symbol         |        state       |\n+              |    symbol         |        state       |\n+              |    symbol         |        state       |\n+               ________________________________________\n               |                   |                    |\n               |      =            |          0         |\n               |                   |                    |\n               |     \u00ac =           |        1 or 2      |\n               |                   |                    |\n               |      <            |          1         |\n               |                   |                    |\n               |     < =           |        0 or 1      |\n               |                   |                    |\n               |     > =           |        0 or 2      |\n               |                   |                    |\n               |      >            |          2         |\n               |                   |                    |\n+               ________________________________________\n\n                    Table 6.3 - Condition Code States\n+                   Table 6.3 - Condition Code States\n+                   Table 6.3 - Condition Code States\nB                                 6-5\n1\n 6.6  IF Statements\n+6.6  IF Statements\n+6.6  IF Statements\n\n     <IF statement> ::= <if clause> <statement>\n          | <if clause> <true part> <statement>\n     <if clause> ::= IF <compound condition> THEN\n     <true part> ::= <simple statement> ELSE\n\n The IF statement specifies the conditional execution of statements:\n\n         <if clause> <statement>\n\n The statement is executed, if and only if the compound condition of  the\n clause is met.\n\n         <if clause> <true part> <statement>\n\n The simple statement of the true part is executed and the  statement  is\n skipped,  if and only if the compound condition of the if clause is met.\n Otherwise the true part is skipped and the  statement  is  executed.   A\n simple statement is any statement except an IF, WHILE or FOR statement.\n\n Examples:   IF R0 < 10 THEN R1 := 1\n             IF F2 > _3.75 AND F2 < 3.75 THEN F0 := F2 ELSE F0 := 0R\n             IF < THEN SET(flags(1)) ELSE SET(flags(2))\n\n\n Note:  If the condition consists of just a relation  or  integer  value,\n then  the  decision  is  made  on  the  basis  of  the condition code as\n determined by a previous instructions.\n\n Examples:  EX(R1,CLC(0,B2,B3));  IF = THEN ...\n            IF  TM(#80,flags);  ON  THEN ...\n\n\n 6.7  WHILE Statements\n+6.7  WHILE Statements\n+6.7  WHILE Statements\n\n     <WHILE statement> ::= <while clause><statement>\n     <while clause> ::= WHILE <compound condition> DO\n\n The WHILE statement denotes the repeated execution  of  a  statement  as\n long as the compound condition in the while clause is met.\n\n Examples:  WHILE F0 < prize(R1) DO R1 := R1 + 4\n            WHILE R0 < 10 DO\n            BEGIN R0 := R0 + 1;  F01 := F01 * F01;  F23 := F23 * F01;\n            END\nB                                 6-6\n1\n 6.8  FOR Statements\n+6.8  FOR Statements\n+6.8  FOR Statements\n\n     <FOR statement> ::= <for clause><statement>\n     <for clause> ::= FOR <integer register assignment> STEP <increment>\n                      UNTIL <limit> DO\n     <increment> ::= <integer value>\n     <limit> ::= <integer primary> | <short integer primary>\n\n The FOR statement specifies the repeated execution of a statement, while\n the content of the integer register specified by the assignment  in  the\n for  clause  takes  on  the  values  of an arithmetic progression.  That\n register is called  the  control  register.   The  execution  of  a  FOR\n statement occurs in the following steps:\n\n     1.  the register assignment in the for clause is executed;\n     2.  if the increment is not negative (negative),  then  if  the\n         value  of  the  control  register is not greater (not less)\n         than  the  limit,  the  process  continues  with  step   3;\n         otherwise the execution of the FOR statement is terminated;\n     3.  the statement following the for clause is executed;\n     4.  the increment is added to the  control  register,  and  the\n         process resumes with step 2.\n\n\n Examples:  FOR R1 := 0 STEP 1 UNTIL n DO STC(R1,lines(R1))\n            FOR R2 := R1 STEP 4 UNTIL R0 DO\n                   BEGIN F23 := quant(R2) * price(R2);\n                       F01 := F01 + F23;\n                   END\n\n\n 6.9  CASE Statements\n+6.9  CASE Statements\n+6.9  CASE Statements\n\n     <CASE statement> ::= <case sequence> END\n     <case sequence> ::= <case clause> BEGIN |\n           <case sequence><statement> ;\n     <case clause> ::= CASE <integer register> OF\n\n CASE statements permit the selection of one of a sequence of  statements\n according  to  the  current  value  of  the integer register (other than\n register R0) specified in the case clause.  The statement whose  ordinal\n number  (starting with 1) is equal to the register value is selected for\n execution, and the other statements in the sequence  are  ignored.   The\n value of that register is thereby modified.\n\n Example:  CASE R1 OF\n           BEGIN COMMENT interpretation of instruction code R1;\n               F01 := F01 + F23;\n               F01 := F01 - F23;\n               F01 := F01 * F23;\n               F01 := F01 / F23;\n               F01 := NEG F01;\n               F01 := ABS F01;\n           END\nB                                 6-7\n1                         SECTION 7.  FUNCTIONS\n+                         SECTION 7.  FUNCTIONS\n+                         SECTION 7.  FUNCTIONS\n\n 7.1  Function Declarations\n+7.1  Function Declarations\n+7.1  Function Declarations\n\n     <function declaration> ::= FUNCTION <function definition> |\n          <function declaration> , <function definition>\n     <function definition> ::=\n          <identifier> ( <format code> , <instruction code> )\n     <instruction code> ::= <integer value>\n     <format code> ::= <integer value>\n\n Various data manipulation facilities  in  the  360  computer  cannot  be\n expressed  by  an assignment.  To make these facilities available in the\n language, the function statement is  introduced  (cf.   7.2),  using  an\n identifier   to  designate  an  individual  computer  instruction.   The\n function declaration serves to associate this identifier, which  thereby\n becomes  a  function  identifier,  with the desired computer instruction\n code, and to define the instruction fields which correspond from left to\n right to the parameters given in function statements.  The  format  code\n defines  the  format  of  the  instruction according to Table 7.1 on the\n following page.  The last two bytes of the instruction code  define  the\n first  two  bytes of the instruction.  The following example defines the\n standard function identifiers, which apart from  TEST,  SET  and  RESET,\n were  derived  from  the symbolic machine code used in assembly language\n \u00dd7\u00a8.\n\n FUNCTION  BALR(1,#0500),     MVI(4,#9200),      SRDL(9,#8C00),\n           CLC(13,#D500),     MVN(5,#D100),      STC(12,#4200),\n           CLI(4,#9500),      MVZ(5,#D300),      STH(12,#4000),\n           CVB(12,#4F00),     NC(5,#D400),       STM(3,#9000),\n           CVD(12,#4E00),     NI(4,#9400),       SVC(7,#0A00),\n           ED(5,#DE00),       OC(5,#D600),       TEST(8,#95FF),\n           EDMK(5,#DF00),     OI(4,#9600),       TM(4,#9100),\n           EX(2,#4400),       PACK(10,#F200),    TR(5,#DC00),\n           IC(2,#4300),       RESET(8,#9200),    TRT(5,#DD00),\n           LA(2,#4100),       SET(8,#92FF),      TS(8,#9300),\n           LH(12,#4800),      SLDA(9,#8F00),     UNPK(10,#F300),\n           LM(3,#9800),       SLDL(9,#8D00),     XC(5,#D700),\n           LTR(1,#1200),      SPM(6,#0400),      XI(4,#9700),\n           MVC(5,#D200),      SRDA(9,#8E00)\n\n\n 7.2  Function Statements\n+7.2  Function Statements\n+7.2  Function Statements\n\n     <function designator> ::= <function identifier> |\n            <function identifier> ( <parameter list> )\n     <parameter list> ::= <parameter> | <parameter list> , <parameter>\n     <parameter> ::= <T-value> | <string> | <K-register> |\n            <T-cell designator> | <function designator>\n\n If a function designator is used as  a  parameter,  the  first  function\n identifier  must  correspond  to  an  execute instruction.  That is, the\n first byte of the instruction code must have the value #44X.  An example\n is the predeclared identifier EX (cf.  7.1).\nB                                 7-1\n1Examples:\n     SET(flag)                 STM(R0,R15,save)\n     RESET(flag)               SVC(255)\n     LA(R1,\"message\")          IC(R0,flags(R1))\n     UNPK(3,7,B2,worker)       EX(R1,MVC(0,lines,buffer))\n\n\n\n        Format     Number of            Instruction Fields\n+       Format     Number of            Instruction Fields\n+       Format     Number of            Instruction Fields\n         Code      Parameters      0   8  16       32       48\n+        Code      Parameters      0   8  16       32       48\n+        Code      Parameters      0   8  16       32       48\n\n                                   _________\n          0            0           |       |\n                                   _________\n          1            2           |   |R|R|\n                                   __________________\n          2            2           |   |R|     LC   |\n                                   __________________\n          3            3           |   |R|R|   C    |\n                                   __________________\n          4            2           |   |ICS|   C    |\n                                   ___________________________\n          5            3           |   |ICS|   C    |   LC   |\n                                   _________\n          6            1           |   |R| |\n                                   _________\n          7            1           |   |ICS|\n                                   __________________\n          8            1           |       |   C    |\n                                   __________________\n          9            2           |   |R| |   IC   |\n                                   ___________________________\n         10            4           |   |I|I|   C    |   LC   |\n                                   __________________\n         11            2           |   |R|     ICS  |\n                                   __________________\n         12            2           |   |R|     C    |\n                                   ___________________________\n         13            3           |   |ICS|   LC   |   LC   |\n                                   ___________________________\n         14            2           |       |   C    |   LC   |\n                                   __________________\n         15            1           |     |     LC   |\n\n\n     Field Definition Codes:\n          R = K-register\n          C = T-cell identifier (or designator in the 20-bit field) address\n          I = Integer value       (the value is used directly\n          S = String               in the instruction field)\n          L = T-value or string or function designator (the address of the\n              value is used in the instruction field)\n\n\n                     Table 7.1 - Instruction Format\n+                    Table 7.1 - Instruction Format\n+                    Table 7.1 - Instruction Format\nB                                 7-2\n1\n                         SECTION 8.  PROCEDURES\n+                        SECTION 8.  PROCEDURES\n+                        SECTION 8.  PROCEDURES\n\n 8.1  Procedure Declarations\n+8.1  Procedure Declarations\n+8.1  Procedure Declarations\n\n     <procedure declaration> ::= <procedure heading> ; <statement>\n     <procedure heading> ::= <simple procedure heading> |\n           COMMON <simple procedure heading> |\n           <separate procedure heading> |\n           <separate procedure heading> BASE <integer register>\n     <separate procedure heading> ::=\n           SEGMENT <simple procedure heading> |\n           GLOBAL <simple procedure heading> |\n           EXTERNAL <simple procedure heading>\n     <simple procedure heading> ::=\n           PROCEDURE <identifier> ( <integer register> )\n\n A procedure declaration serves to associate an identifier, which thereby\n becomes a procedure identifier, with a statement  (cf.   4.1)  which  is\n called  a  procedure  body.   This  identifier  can  then  be used as an\n abbreviation for the procedure body anywhere within  the  scope  of  the\n declaration.   When  the procedure is invoked, the register specified in\n parentheses in the procedure heading is assigned the return  address  of\n the invoking procedure statement.  This register must not be R0.\n\n If the symbol PROCEDURE is preceded by the symbol  SEGMENT,  GLOBAL,  or\n EXTERNAL,  the procedure body is compiled as a separate program segment.\n If the symbol is GLOBAL or EXTERNAL,  the  corresponding  identifier  is\n associated  with  the procedure segment to enable linking of segments in\n possibly different PL360 programs \u00dd8,9,12\u00a8.  These symbols have no other\n influence  on  the  meaning  of  the  program  with  the  exception   of\n restricting the scope of GOTO statements (cf.  4.2, 6.4 and 10.4).  If a\n base  register is specified in the procedure heading, the procedure body\n is compiled using the specified register for the  program  segment  base\n register  (cf.   4.2);  otherwise,  the current program base register is\n used (usually this is R15, however, cf.  10.1.5).   This  register  must\n not  be  R0.   When the procedure is invoked, the specified (or assumed)\n base register is assigned the entry point address.\n\n The  instructions  associated  with  the  statement  of  both  a  simple\n PROCEDURE  and  COMMON  PROCEDURE  are  local  to  the  program  segment\n containing these procedure declarations.  However,  a  COMMON  PROCEDURE\n also  declares  the procedure identifier as an additional entry point to\n the program segment.  Such entry points are normally  called  upon  from\n separately compiled programs through an EXTERNAL PROCEDURE declaration.\n\n Examples:\n           PROCEDURE NEXTCHAR(R3);\n           BEGIN IF R5 < 71 THEN R5 := R5 + 1 ELSE\n                BEGIN R0 := @CARDS;  READ;  R5 := R5--R5;\n                END;\n                IC(R0,CARD(R5));\n           END\nB                                 8-1\n1\n           PROCEDURE SLOWSORT (R4);\n           FOR R1 := 0 STEP 4 UNTIL N DO\n           BEGIN R0 := A(R1);\n                   FOR R2 := R1 + 4 STEP 4 UNTIL N DO\n                   IF R0 < A(R2) THEN BEGIN R0 := A(R2);  R3 := R2;  END;\n                   R2 := A(R1);  A(R1) := R0;  A(R3) := R2;\n           END\n\n\n           EXTERNAL PROCEDURE SEARCHDISK (R14) BASE R12; NULL;\n\n Note:  The code corresponding to a procedure body  is  terminated  by  a\n branch-on-register  instruction  specifying  the  register designated in\n parenthesis in the procedure heading.  A procedure  statement  places  a\n return  address  in this register when invoking the procedure.  In order\n to return properly, the programmer must either not change  the  contents\n of that register, or explicitly save and restore its contents during the\n execution of the procedure.\n\n\n 8.2  Procedure Statements\n+8.2  Procedure Statements\n+8.2  Procedure Statements\n\n     <procedure statement> ::= <procedure identifier> |\n          <procedure identifier> ( <integer register> )\n\n The procedure statement invokes the  execution  of  the  procedure  body\n designated by the procedure identifier.  A return address is assigned to\n the  register  specified  in  the  heading  of  the designated procedure\n declaration.  If an integer  register  is  specified  in  the  procedure\n statement,  on  return  from  the  procedure the contents of the invoked\n procedure's program base register (usually R15) are transferred  to  the\n specified  integer  register  and  the  condition  code  is  set  by the\n transfer.  This facilitates the convention of passing  return  codes  in\n the  invoked  procedure's  program base register (usually R15, cf.  8.1,\n 10.1.5).\nB                                 8-2\n1                   SECTION 9.  THE RUN-TIME LIBRARY\n+                   SECTION 9.  THE RUN-TIME LIBRARY\n+                   SECTION 9.  THE RUN-TIME LIBRARY\n\n This section describes a set of global procedures written in PL360 which\n perform commonly needed tasks.  These  subroutines  are  predeclared  as\n external  procedures in the PL360 compiler.  In all cases, the procedure\n linkage is done with register R14, and R15 should contain the address of\n the  entry  point  upon  entry.   At  Stanford,   the   linkage   editor\n automatically  adds  the  required  subroutines  if  you  are  using the\n cataloged procedure PL360CG.\n\n\n 9.1  Standard Procedures\n+9.1  Standard Procedures\n+9.1  Standard Procedures\n\n A set of standard procedures is defined for elementary unit record input\n and output operations (the first set below),  for  elementary  disk  and\n tape  input  and  output  operations  using sequential files (the second\n set), and for ease in  communicating  with  the  operating  system  (the\n last).  The implicit procedure declarations are as follow:\n\n     EXTERNAL PROCEDURE READ (R14) BASE R15;  NULL;\n     EXTERNAL PROCEDURE WRITE (R14) BASE R15;  NULL;\n     EXTERNAL PROCEDURE PAGE (R14) BASE R15;  NULL;\n     EXTERNAL PROCEDURE PUNCH (R14) BASE R15;  NULL;\n     EXTERNAL PROCEDURE PRINT (R14) BASE R15;  NULL;\n\n     EXTERNAL PROCEDURE OPEN(R14) BASE R15; NULL;\n     EXTERNAL PROCEDURE GET(R14) BASE R15; NULL;\n     EXTERNAL PROCEDURE PUT(R14) BASE R15; NULL;\n     EXTERNAL PROCEDURE KLOSE(R14) BASE R15; NULL;\n\n     EXTERNAL PROCEDURE CANCEL(R14) BASE R15; NULL;\n\n Suitable externally compiled or assembled routines must be  provided  in\n the link/loading process; the specifications of these routines are:\n\n     READ  Read an 80 character record from the system input data set and\n           assign that record  to  the  memory  area  designated  by  the\n           address  in  register  R0.   Set the condition code to 2 if no\n           record could be returned due to  an  end  of  file  condition;\n           otherwise, to 0.  (ABEND 95 or 96)\n    WRITE  Write a 133 character record to the system listing  data  set.\n           A   132  character  record  is  taken  from  the  memory  area\n           designated by the address in register R0 and  prefixed  by  an\n           appropriate  carriage  control character.  A control character\n           indicating a new page is used after 60 lines have been written\n           on a page, otherwise a control character indicating  the  next\n           line is used.  The first  line  is  written  on  a  new  page.\n           (ABEND 95)\n     PAGE  Give the next output record transmitted  by  a  WRITE  to  the\n           system  listing  data set a control character indicating a new\n           page.\n    PUNCH  Write the 80 character record designated  by  the  address  in\n           register R0 to the system punch data set.  (ABEND 95)\n    PRINT  Write the 133 character record designated by  the  address  in\n           register  R0  to  the  system  listing  data set.  The calling\n           program provides  a  USASI  control  character  as  the  first\n           character.  (ABEND 95)\nB                                 9-1\n1    OPEN  At entry, register R0 must be 0 if the file is to be an output\n           file or 1 if the file is to be an  input  file.   Register  R2\n           must contain the address of an 8-byte area containing a unique\n           file  name.  (This is taken as the ddname in an OS environment\n           and as the symbolic file name in a DOS environment.) In an  OS\n           environment,  register  R1  must  contain  the  address  of  a\n           100-byte  full  word-aligned  area  which, following the open,\n           will contain the data control block.  In  a  DOS  environment,\n           register R1 must contain the address of a separately assembled\n           DTF  table  which  describes the file.  The file is made ready\n           for input/output  operations.   All  registers  are  restored.\n           (ABEND 97)\n      GET  At entry, register R1 must contain  the  address  of  a  table\n           which describes the file.  (In an OS environment this table is\n           called  the  data control block and in a DOS environment it is\n           called the DFT table.) Upon return, register R1  contains  the\n           address  of  the  next logical record in the file.  (The first\n           call of GET returns with the  address  of  the  first  logical\n           record.) When an end-of-file is reached, the condition code is\n           set  to 2; normally it is set to 0.  All registers, except R1,\n           are restored.\n      PUT  At entry, register R1 must contain  the  address  of  a  table\n           which  describes  the file.  Upon return, register R1 contains\n           the address of an area in which the next logical record to  be\n           output is to be built.  All other registers are restored.\n    KLOSE  At entry, register R1 must contain  the  address  of  a  table\n           which  describes  the  file.  The corresponding file is closed\n           and no further input-output operations can be  performed  with\n           it  unless  it  is  opened  again.   In an OS environment, the\n           contents of register R0 denoted  by  (R0)  is  also  an  input\n           parameter  to  this subroutine:  if (R0) = 0 , the DISP option\n           of  the  DD  statement  is  used  to  determine  final  volume\n           positioning; if (R0) <= 0 , the volume is  positioned  at  the\n           end  of  the data set.  If (R0) > 0 , the volume is positioned\n           at the beginning of the data set.  All registers are restored.\n\n    CANCEL The job, including all future job steps, is cancelled.\n\n\n All of these procedures assume that register R13 contains the address of\n an 18 word save area (cf.  4.4) and all registers  are  restored  before\n return.   Each  of the data sets is opened upon initial reference and is\n closed by the operating system at the end of a job step.\n\n\n 9.2  Number Conversion Procedures\n+9.2  Number Conversion Procedures\n+9.2  Number Conversion Procedures\n\n The two subroutines described below  are  used  to  convert  the  EBCDIC\n representation  of  a  number  into  an  internal representation of that\n number,  or   vice-versa.    A   slightly   more   conventional   number\n representation is used by these routines than that of the PL360 language\n (cf.  3).  The numbers must satisfy the following syntax:\nB                                 9-2\n1\n    <long complex number> ::= <long real number> + <imaginary number> L\n    <complex number> ::= <real number> + <imaginary number>\n    <imaginary number> ::= <real number> I | <integer number>  I\n    <long real number> ::= <real number> L | <integer number> L\n    <real number> ::= <unscaled real> | <unscaled real> <scale factor> |\n         <integer number> <scale factor> | <scale factor>\n    <unscaled real> ::= <integer number> . <integer number> |\n         . <integer number> | <integer number> .\n    <scale factor> ::= ' <integer number> | ' <sign> <integer number>\n    <integer number> ::= <digit> | <integer number> <digit>\n    <sign> ::= + | -\n\n Numbers are interpreted according to the conventional decimal  notation.\n A  scale  factor  denotes an integral power of 10 which is multiplied by\n the unscaled real or integer number preceding it.  A number can have  no\n imbedded blanks and must be terminated by a blank.  These procedures are\n predeclared in a manner similar to those described in Section 9.1.\n\n\n The parameter passing conventions for the two conversion subroutines are\n as follows:\n\n VALTOBCD This procedure converts an internally stored value to an EBCDIC\n          representation.  At entry,\n\n          R1 contains the address of an area to receive the EBCDIC\n             representation.\n          R2 indicates the type:\n               1 = integer\n               2 = real\n               3 = long real\n               4 = complex\n               5 = long complex\n          R3 contains the field length (>= 1)\n\n          The value to be converted is in R0, F0, F01, F0 and F2, or  F01\n          and F23, depending on the type (in that order).\n\n          A return code is left in R15:\n             0 -> successful conversion\n             1 -> field size too small\n             2 -> invalid field size\n          When the field size is too small  to  receive  the  value,  the\n          field is filled with stars (*).\n\n          All registers, except R14 and R15, are preserved.\n\n BCDTOVAL This procedure converts an EBCDIC representation of a number to\n          an internal number.  At entry,\n\n          R1 contains the address of the EBCDIC representation (possibly\n             preceded by blanks)\n          R2 indicates type (see VALTOBCD)\n\n          The resulting value is left in R0, F0, F01, F0 and F2,  or  F01\n          and F23, depending upon the type.\nB                                 9-3\n1\n          A return code is left in R15:\n              0 -> successful scan\n              1 -> invalid character in input string\n              2 -> missing \"I\" on imaginary part\n              3 -> nonblank terminator\n              4 -> number scanned is not assignment compatible\n                   (e.g., a decimal point is found when R2 = 1)\n              5 -> integer too large\n\n          Upon  exit,  R1  contains  the  address  of   the   terminator.\n          Registers R2-R13 are restored.\n\n\n 9.3  Data Manipulation Procedures\n+9.3  Data Manipulation Procedures\n+9.3  Data Manipulation Procedures\n\n The first procedure described in this section does an  in-core  indirect\n sort using logical comparisons.  The second companion routine searches a\n sorted list for a specified element.   Neither procedure is predeclared.\n\n SHELSORT This procedure sorts character data.  The Shell Sort  technique\n          is used.  At entry, registers R0-R3 must be set as follow:\n\n          R0 = the number of items to sort\n          R1 = the address of the index array\n          R2 = the number of the first byte of the key in each\n               record on which the sort is to be done (R2 >= 1)\n          R3 = the number of bytes in the key on which the sort\n               is to be done\n\n          The index array is a list of  4-byte  integers  containing  the\n          address  of the items to be sorted.  The actual sort is done on\n          the elements of the index array and not the records themselves.\n          That is, only the order of the elements of the index  array  is\n          modified  by  the  procedure.   All  registers, except R14, are\n          restored.\n\n BISEARCH This procedure locates an element in a sorted list.  At  entry,\n          registers R0-R4 must be set as follow:\n\n          R0 = the number of entries in the sorted table\n          R1 = the address of the index array (see SHELSORT)\n          R2 = the number of the first byte of the key field in\n               the records\n          R3 = the number of bytes in each key field\n          R4 = the address of the key for which you are looking\n\n          At exit, R1 contains the address of an  element  in  the  index\n          array  that  points  to a record that contains the desired key.\n          If no match is found, R1 = 0.\n\n          All registers, except R1 and R14, are preserved.\nB                                 9-4\n1                SECTION 10.  COMPILER CONTROL FACILITY\n+                SECTION 10.  COMPILER CONTROL FACILITY\n+                SECTION 10.  COMPILER CONTROL FACILITY\n\n 10.1  Instructions to the Compiler\n+10.1  Instructions to the Compiler\n+10.1  Instructions to the Compiler\n\n The compiler accepts instructions inserted anywhere in the  sequence  of\n input   records.   These  instructions  affect  subsequent  records.   A\n compiler instruction record is marked by the character '$' in  column  1\n and an instruction in columns 2-72.\n\n\n 10.1.1  Listing Control\n+10.1.1  Listing Control\n+10.1.1  Listing Control\n\n $LIST    List source records (initial option).\n\n $NOLIST  Do not list source records.\n\n $PAGE    Start a new page with the next listing record.\n\n $TITLE   Start a new page with the next  listing  record,  and  use  the\n          contents  of  columns  10  through 62 as the title for that and\n          subsequent pages.\n\n $STITLE  This directive provides a sub-title line.  The  sub-title  will\n          remain  in  effect  until  the  next  $TITLE  or  $STITLE card.\n          $STITLE cards may change the sub-title  without  affecting  the\n          main $TITLE.  $STITLE also causes a page eject.\n\n $SPACE # This directive allows the user to line space  a  listing  by  #\n          lines  where # is a number from 1 to 99.  If # is blank, then a\n          single line space is assumed.  If the number of lines remaining\n          on the page is less than #, then a page eject is  done  instead\n          of line spacing.\n\n $EJECT   This directive is equivalent to $PAGE.\n\n $ON      This directive enables the  printing  of  all  $-control  cards\n          except $TITLE, $STITLE, $EJECT, $PAGE, and $SPACE.\n\n $OFF     This directive disables the printing of  all  $-control  cards.\n          This is the default condition at the start of compilation.\n\n\n 10.1.2  Listing Options\n+10.1.2  Listing Options\n+10.1.2  Listing Options\n\n $XREF    All subsequent  instances  of  identifiers  are  listed  in  an\n          alphabetical  cross-reference  listing  together  with the line\n          numbers at which they are defined or referenced in  the  source\n          program.   The  cross-reference  listing  follows  the  program\n          listing  if  $LIST  is in effect at the end of the program.  If\n          there is  not  enough  free  storage  to  allocate  the  cross-\n          reference  tables,  the  $XREF  instruction  is  ignored.   The\n          cross-reference listing will be single spaced unless $XREF 2 is\n          specified to double space the listing.\n\n $NOXREF  This causes the previous  option  to  be  turned  off  (initial\n          option).   Any  accumulated  cross-references  will  be  listed\n          following the program as described above for $XREF.\nB                                 10-1\n1$0       Print a summary line at the  close  of  each  segment  (initial\n          option).\n\n $1       Print a summary line and list  of  external  symbol  dictionary\n          entries at the close of each segment.\n\n $2       List the declared identifiers and associated value as  each  is\n          declared, as well as the information specified in $1.\n\n $3       List the object text in hexadecimal notation at  the  close  of\n          each segment, as well as the information specified in $2.\n\n\n 10.1.3  Operating System Control\n+10.1.3  Operating System Control\n+10.1.3  Operating System Control\n\n $OS      Subsequent PL360 programs which  are  statements  are  compiled\n          with  entry  and  exit  instruction sequences conforming to the\n          program-calling conventions of an OS environment.   This  is  a\n          default option when the compiler is used with the OS interface.\n\n $DOS     Subsequent PL360 programs which  are  statements  are  compiled\n          with  entry and exit instruction sequences which conform to the\n          program calling conventions of a DOS environment.  This is  the\n          default   option  when  the  compiler  is  used  with  the  DOS\n          interface.\n\n\n 10.1.4  Identification\n+10.1.4  Identification\n+10.1.4  Identification\n\n $XYY#    This directive must precede the first  non-control  card.   All\n          compiler  generated segment names will commence with XYY rather\n          than SEG, and all object deck cards are identified  by  XYY  in\n          columns 73 through 75 followed by the letter N and a four digit\n          number.   X  signifies  any  alphabetic  and Y any alphanumeric\n          characters.  (cf.  10.4).\n\n\n 10.1.5  Program Base Register Control\n+10.1.5  Program Base Register Control\n+10.1.5  Program Base Register Control\n\n $BASE=xx This  directive  must  precede  the  first  non-control   card.\n          Program  segments following this directive are compiled with xx\n          taken  as  the  program  base  register.   This  includes  main\n          programs, global procedures, segment procedures,  and  external\n          procedures  (which  do  not  specify BASE).  Procedure calls to\n          such segments automatically set the specified base register  to\n          the entry point address.  The decimal number xx must be between\n          01 and 15 .  Programs which are statements must not be compiled\n          with base registers 13 or 14.  The initial option is xx=15, and\n          all  predeclared  external  procedure  declarations always have\n          base register  R15.   It  is  recommended  that  this  compiler\n          directive  only  be  used  for  programs  which make use of SVC\n          instructions that do not preserve the contents of register R15.\nB                                 10-2\n110.1.6  Object Deck Control\n+10.1.6  Object Deck Control\n+10.1.6  Object Deck Control\n\n $GEN     If this directive precedes the first error detected  (if  any),\n          then   object  decks  are  still  produced  if  any  have  been\n          requested.   Otherwise  object  decks  are   suppressed   after\n          encountering an error.\n\n $NOGO    Compile, but suppress the GO step.\n\n\n 10.1.7  Copy Facility\n+10.1.7  Copy Facility\n+10.1.7  Copy Facility\n\n $COPY ddname\n $COPY ddname(member)\n          These control cards specify  that  a  sequential  data  set  or\n          member  of  a  partitioned  data  set  is to be copied into the\n          compilation.  The compiler temporarily suspends input from  the\n          standard  input  medium and continues compilation with the data\n          set defined by the $COPY control card.  When end-of-information\n          is encountered on that data set, compilation continues from the\n          standard input with the card image  immediately  following  the\n          $COPY  control  card.   Note:  $COPY is ignored in the data set\n          being copied, i.e., $COPY may not nest.  As many $COPY  control\n          cards  as  desired  may  occur  in  the  standard  input.  When\n          compiling under ORVYL, ddname or member is assumed  to  be  the\n          ORVYL  data set name.  An account number may follow to indicate\n          a data set belonging to a different account.\n\n\n 10.1.8  Conditional Compile Directives\n+10.1.8  Conditional Compile Directives\n+10.1.8  Conditional Compile Directives\n\n At the start of compilation of each program  (cf.   4.1),  an  array  of\n flags  is  reset  by  the  compiler.   The following directives use this\n array.  The array flags are specified by individual  characters  in  the\n directives,  and any characters may be used, including blank.  Upper and\n lowercase characters are considered equivalent.  The directives must  be\n in uppercase in columns 1 through 4 on the control card.\n\n $SET a      where 'a' is any character in column 6.\n             This directive sets the 'a' flag.\n\n $IFT a b    where 'a' is any character in column 6, and 'b' is any char-\n $IFF a b    acter in column 8.\n             These directives examine the 'a' flag.  If the 'a'  flag  is\n             set  for  $IFT,  or  reset for $IFF, this directive takes no\n             action and compilation continues normally.\n\n             If the 'a' flag is reset for $IFT,  or  set  for  $IFF,  the\n             compiler  skip-reads  source cards until a $END directive is\n             encountered  with  its  'b'  character  matching   the   'b'\n             character  of  the $IFT or $IFF.  Compilation then continues\n             from that point.\n\n             Note:  '$IFF a b' is an unconditional skip to  '$END  b'  if\n             '$SET  a' has occurred.  '$IFT a b' is an unconditional skip\n             to '$END b' if '$SET a' has not occurred.\n\n $END b      where 'b' is any character in column 6.\n             This directive terminates $IFT or $IFF directives.\nB                                 10-3\n1$RESET a    where 'a' is any character in column 8.\n             This directive resets the 'a' flag.\n\n Examples of Conditional Compile:\n\n 1.  $SET Z\n        .\n        .\n     $IFT Z\n        COMMENT Compile this if 'Z' is $SET;\n        .\n        .\n     $END\n     $IFF Z\n        COMMENT Compile this if 'Z' is not $SET;\n        .\n        .\n     $END\n\n 2.  $SET 1\n        .\n        .\n     $IFF 0 X\n     $IFF 1 X\n     $IFT 2 Q\n     $END X\n        COMMENT Compile this if '0' or '1' or '2' is $SET;\n        .\n        .\n     $END Q\n\n 3.  $SET -\n     $SET +\n        .\n        .\n     $IFT +\n     $IFT -\n        COMMENT Compile this if both '+' and '-' are $SET;\n        .\n        .\n     $END\n\n\n 10.2  Compiler Listing Output\n+10.2  Compiler Listing Output\n+10.2  Compiler Listing Output\n\n If listing is specified, each non-control record  is  listed  as  it  is\n read.   Source  records  in which errors are detected are always listed.\n Four sets of numbers appear at the left of each  line.   The  first  set\n consists  of  the  current  internal program segment number (in decimal)\n followed by the program object code relative address  (in  hexadecimal);\n the second set, of the current internal data segment number (in decimal)\n and the data relative address (in hexadecimal).  The fifth number is the\n statement  number of the source record.  The final number, the BEGIN/END\n level count, shows the excess of BEGIN symbols over END symbols  at  the\n beginning  of  the next line following an occurrence of BEGIN/END.  This\n count is only printed when the BEGIN/END level  changes.   In  addition,\n each  page  begins  with a heading which includes the page number, date,\n time, and  an  optional  title  (cf.   10.1.1).   Examples  of  compiler\n listings are given in Appendix A.\nB                                 10-4\n110.3  Error Messages of the Compiler\n+10.3  Error Messages of the Compiler\n+10.3  Error Messages of the Compiler\n\n Errors detected by the  compiler  are  indicated  by  a  message  and  a\n vertical  bar below the point where the error was detected.  After about\n 50 errors, a message is provided, and further  diagnostic  messages  are\n counted  but  not  listed.  The following is a list of error diagnostics\n and their meanings:\n\n Error\n+Error\n+Error\n Number   Message        Meaning\n+Number   Message        Meaning\n+Number   Message        Meaning\n\n   00     SYNTAX         The source program violates the PL360 syntax.\n   01     VAR MIX TYPES  The types of operands in a variable  assignment\n                         are incompatible.\n   02     FOR PARAMETER  In a for clause, the register is not an integer\n                         register, or the limit is not a register, cell,\n                         or number of the integer types.\n   03     REG ASS TYPES  The  types  of  the  operands  in  a   register\n                         assignment are incompatible.\n   04     BIN OP TYPES   The types  of  operands  of  an  arithmetic  or\n                         logical operator are incompatible.\n   05     SHIFT OP       A real instead of an integer register or number\n                         is specified in a shift operation.\n   06     COMPARE TYPES  The types  of  operands  in  a  comparison  are\n                         incompatible.\n   07     REG TYPE OR #  Either the type or the number of  the  register\n                         used is incorrect.\n   08     UNDEFINED ID   An undeclared identifier has  been  referenced.\n                         The  identifier  is treated as if it were 'R1'.\n                         This may generate other errors.\n   09     MULT LAB DEF   The same identifier is defined as a label  more\n                         than once in the same block.\n   10     EXC INI VALUE  The number of initializing values  exceeds  the\n                         the number of elements declared in an array, or\n                         a  string  attempts  to  initialize  beyond the\n                         declared limits of a variable or array.\n   11     NOT INDEXABLE  An index register is not allowed for  the  cell\n                         designator in this context.\n   12     DATA OVERFLOW  The address of the  declared  variable  in  the\n                         data segment exceeds 4095.\n   13     NO OF ARGS     An incorrect number of arguments is used for  a\n                         function.\n   14     ILLEGAL CHAR   An illegal character  was  encountered;  it  is\n                         skipped.\n   15     MULTIPLE ID    The same identifier is declared more than  once\n                         in  the  same  block.   This  occurrence of the\n                         identifier is ignored.\n   16     PROGRAM OFLOW  The current program segment is too  large.   It\n                         must be resegmented.\n   17     INITIAL OFLOW  The area of initializing data in  the  compiler\n                         is  full.   This can usually be circumvented by\n                         suitable data segmentation  or  by  re-ordering\n                         initialized data within the segment.\n   18     ADDRESS OFLOW  The number used  as  index  is  such  that  the\n                         resulting  relative  address  is less than 0 or\n                         greater than 4095.\n   l9     NUMBER OFLOW   The integer number is too large in magnitude.\nB                                 10-5\n1  20     MISSING .      An end-of-file  is  encountered  before  a  '.'\n                         terminating  the program.  The problem may be a\n                         missing string quote.\n   21     STRING LENGTH  The length of a string is either 0  or  greater\n                         than 256.\n   22     AND/OR MIX     A compound condition must not contain both ANDs\n                         and ORs.\n   23     FUNC DEF NO.   The format number in a function declaration  is\n                         illegal.\n   24     ILLEGAL PARAM  A parameter is incompatible with  the  specifi-\n                         cations of the function.\n   25     NUMBER         A number has been used that has an illegal type\n                         or value.\n   26     SYN MIX        Synonym  declarations  cannot  mix   cell   and\n                         register  declarations,  or  T-cell designators\n                         have different base registers.\n   27     SEG NO OFLOW   The maximum allowed segment  numbers  has  been\n                         exceeded.  The limit is generally set at 255.\n   28     ILLEGAL CLOSE  A segment close declaration is encountered when\n                         no data segment is open  in  the  corresponding\n                         block head.\n   29     NO DATA SEG    A  variable  is  declared  with  no  open  data\n                         segment.  A dummy data segment is opened.\n   30     ILLEGAL INIT   Initialization is specified in  a  common  data\n                         segment or replicates an absolute address.\n\n At the end of each program segment, all occurrences of undefined  labels\n are listed with an indication of where they occurred.\n\n\n 10.4  Compiler Object Program Output\n+10.4  Compiler Object Program Output\n+10.4  Compiler Object Program Output\n\n The  PL360  compiler  is  designed  to  be  used  in  conjunction   with\n link/loader programs which resolve symbolic cross-references between the\n segments  of one or more programs.  Examples of programs capable of such\n resolution are the MTS loader \u00dd8\u00a8, the IBM OS linkage editor  or  loader\n \u00dd9\u00a8, and the IBM DOS linkage editor \u00dd11\u00a8.  The remainder of this section\n uses the terminology of these programs.\n\n The output of the PL360 compiler is a sequence of object modules.   Each\n object module contains a single control section corresponding to a PL360\n segment.   It consists of 80 character records in the standard format of\n external symbol dictionary  (ESD),  text  (TXT),  relocation  dictionary\n (RLD) and an end (END) (cf.  \u00dd10\u00a8 and Appendix B).\n\n Every PL360 segment (except a dummy data segment) is associated with  an\n object module in the following fashion:\n\n    1.  If the symbol SEGMENT appears  in  the  SEGMENT  declaration,  an\n        object  module  is produced for this segment; the control section\n        name is generated by the compiler as described below.\n    2.  If the symbol GLOBAL  appears  in  the  segment  declaration,  an\n        object  module  is produced for this segment; the control section\n        name is the first 8 bytes of  the  identifier  appearing  in  the\n        declaration.\nB                                 10-6\n1   3.  If the symbol EXTERNAL occurs  in  the  segment  declaration,  no\n        object  module  is  produced;  instead  the  first 8 bytes of the\n        identifier in the declaration is assumed to  be  the  name  of  a\n        control  section  independently generated and is used to indicate\n        this in the object module created for the segment containing  the\n        external declaration.\n    4.  If the symbol COMMON appears in the segment declaration  then  an\n        object module is created in the form of a labeled or blank common\n        control  section  according  to  whether  the  common declaration\n        contains an identifier or not.\n\n In all cases a control section has a single entry point; the entry point\n name and the control section name are identical.  In the case of a PL360\n program which is a statement, a transfer address to the entry  point  is\n provided  in  the END card of the object module for the implicit segment\n corresponding to this statement.  This transfer address  is  used  by  a\n loader to determine where to begin execution.\n\n The task of the  linkage  editor/loader  includes  matching  global  and\n external   declarations,   inserting   absolute  address  constants  and\n completing tables of  segment  base  addresses,  contained  within  each\n control  section  for a program segment, in accordance with the external\n symbol dictionary and relocation dictionary generated  by  the  compiler\n for that control section.\n\n For PL360 programs which are statements, control section names generated\n by the compiler for SEGMENT declarations are of the form  SEGNnnn  where\n nnn  is  the decimal internal segment number.  If the PL360 program is a\n global procedure, the first three characters of the procedure identifier\n (extended on the right by NN if necessary) are  used  in  place  of  the\n characters  'SEG'.   These naming conventions may be overruled by use of\n the compiler directive $XYY# (cf.  10.1.4).\n\n Each END card of the object module output of the compiler has  the  name\n \"PL360\" followed by the date and time of compilation.\nB                                 10-7\n1\n                    SECTION 11.  LINKAGE CONVENTIONS\n+                   SECTION 11.  LINKAGE CONVENTIONS\n+                   SECTION 11.  LINKAGE CONVENTIONS\n\n Although  PL360  was  designed  for  writing  logically   self-contained\n programs,  it  is  possible  to  communicate  with  separately  compiled\n programs  if  appropriate  linkage  and coding conventions are observed.\n These conventions are summarized below.\n\n\n 11.1  Calling External Routines from PL360\n+11.1  Calling External Routines from PL360\n+11.1  Calling External Routines from PL360\n\n Addresses which correspond to external symbolic names and which  are  to\n be  supplied  by  linkage  editing  can  be specified by the external or\n common declarations of PL360.  Entry to  the  block  containing  a  data\n segment declaration causes the specified base register to be loaded with\n the  corresponding  address.   External  names  appearing  in  procedure\n declarations  are  assumed to designate entry points to subroutines.  In\n such declarations, the procedure body is normally  the  statement  NULL.\n The  call  of  the  external  procedure  P2  from  the  procedure  P1 is\n equivalent to the following 360 Assembler coding:\n\n       USING P1,15\n       ...\n       L     l,=V(P2)\n       DROP  15\n       BALR  n,l\n       USING *,l\n       L     15,=A(P1)\n       USING P1,15\n       DROP  n\n\n This linkage implies the following restrictions upon the called routine:\n\n     1.  At entry, the base register specified (or assumed)  in  the\n         external  procedure declaration (l) contains the address of\n         the entry point, unless l = n.\n     2.  At  entry, the register specified in the external procedure\n         declaration (n) contains the return address.\n     3.  Before  return, the return address must be restored to that\n         designated register.\n\n Any additional, non-conflicting conventions may be  established  by  the\n programmer.\n\n If the called procedure (P2) uses  R15  to  return  information  to  the\n calling  routine  (P1),  the procedure statement in P1 is usually of the\n form P2(Rm) , indicating that the return linkage must move the  contents\n of  R15  to  Rm , thus setting the condition code before re-establishing\n the base address of P1 in R15.  The equivalent 360 Assembler coding  for\n this  type of call differs from that already given only in the last four\n lines which become\n\n       LTR   m,15\n       BALR  15,0\n       USING *,15\n       L     15,=A(P1)\n       USING P1,15\nB                                 11-1\n1OS type linkages are facilitated by the fact that if the  calling  PL360\n program  is a statement, the first 18 words of the implicit data segment\n (base register R13) are available for use as a save area (cf.  4.4), and\n by the  @@  operator  which  facilitates  the  construction  of  OS-type\n parameter lists at compile time.\n\n\n 11.2  Requesting Supervisor Services\n+11.2  Requesting Supervisor Services\n+11.2  Requesting Supervisor Services\n\n SVC instructions are available in PL360 programs  through  the  function\n statement.   It should be noted, however, that in many operating systems\n the contents of R15 are destroyed by execution of some SVC instructions.\n In such cases, it is essential that saving and immediately restoring R15\n be explicitly programmed.  This tedious job of preserving  the  contents\n of  the program base register can be avoided by using the $BASE compiler\n instruction (cf.  10.1.5), or by explicitly specifying a  base  register\n in the procedure heading (cf.  8.1).\n\n\n 11.3  Calling PL360 Procedures from External Routines\n+11.3  Calling PL360 Procedures from External Routines\n+11.3  Calling PL360 Procedures from External Routines\n\n Symbolic names and corresponding addresses to be made known to  routines\n external  to  the  PL360  program are specified by the global and common\n declarations of PL360.  Global names specified in procedure declarations\n are associated  with  the  corresponding  procedure  entry  point.   The\n external  invocation  of  PL360  procedures  must  satisfy the following\n restrictions:\n\n 1.  At entry to a PL360 procedure, the procedure base register  (usually\n     R15,  but cf.  8.1, 10.1.5) must contain the procedure entry address\n     and the register specified in the procedure declaration must contain\n     the return address.\n 2.  At exit from a correct PL360 procedure, the  register  specified  in\n     the procedure declaration will contain the return address.\n\n In addition, the following points should be noted:\n\n 1.  If the PL360 program was compiled from a block  and  not  a   global\n     procedure declaration,\n\n     a. the symbolic name  of  the  entry  point  will  normally  be\n        SEGN001,  the  symbolic  name  of  the implicit data segment\n        (with base register  R13)  will  normally  be  SEGN000  (cf.\n        10.1.4);\n     b. the return register will be R14\n     c. at entry, R13 must contain the address of an  18  word  save\n        area, if the $OS option is in effect (cf.  4.4, 10.1.3)\n     d. at exit, all registers are restored from this save area with\n        R15 set equal to zero (R15=0)\n\n 2.  Global and external names violate the rules of scope established  by\n     the  PL360  block  structure (cf.  2.2.1, 4).  By pairing global and\n     external  declarations,  a  name  can  be  given  arbitrary   scope.\n     Recursive  procedures  and  co-routines can be programmed using this\n     feature;  however,  this  ability  should  be  used  carefully   and\n     sparingly.\nB                                 11-2\n1\n Consider the following example:\n\n GLOBAL PROCEDURE p1 (R1) BASE R7;      The procedure p2 can  be  entered\n    BEGIN GLOBAL DATA d1 BASE R10;      with  the  base register for data\n       INTEGER a;                       segment  d1  incorrectly  loaded,\n       COMMON PROCEDURE p2 (R2);        since it is  possible  to  bypass\n       BEGIN  R0 := a;                  the  entry code of the block con-\n       END;                             taining the base declaration.  In\n       COMMON PROCEDURE p3 (R2);        procedure p3, however, the exter-\n       BEGIN EXTERNAL DATA d1 BASE R10; nal declaration  causes  register\n          INTEGER a;                    loading,   but  all  declarations\n          R0 := a;                      must be  repeated.   In  general,\n       END;                             procedures   which   are   to  be\n       R0 := a + 1;                     entered independently  should  be\n    END.                                declared   as  separate  programs\n                                        whenever possible.\n\n It should be noted that the registers specified in corresponding  global\n and   external  procedure  declarations  must  be  identical  while  the\n registers specified in corresponding global, external, and  common  data\n segment declarations may be different.\n\n Also note that when common and external procedures  are  paired,  return\n registers  must  be  identical  and  any  base register specified in the\n external declaration must match the  base  register  of  the  global  or\n segment procedure containing the common procedure declaration.  Thus,\n\n     EXTERNAL PROCEDURE p2 (R2) BASE R7; NULL;\n\n would be the proper declaration for p2 in a separately compiled  segment\n considering the above example.\nB                                 11-3\n1\n            SECTION 12.  PL360 AS AN ORVYL LANGUAGE PROCESSOR\n+           SECTION 12.  PL360 AS AN ORVYL LANGUAGE PROCESSOR\n+           SECTION 12.  PL360 AS AN ORVYL LANGUAGE PROCESSOR\n\n This Section contains a brief narrative description of how one uses  the\n interactive  version  of  PL360  which runs under the ORVYL time-sharing\n monitor  \u00dd12\u00a8.   This  version  is  made  possible  through  a   special\n ORVYL-PL360  interface  module  written  in  Assembly Language using the\n ORVYL macro instructions \u00dd12\u00a8.\n\n\n 12.1  Using the PL360 Compiler with ORVYL\n+12.1  Using the PL360 Compiler with ORVYL\n+12.1  Using the PL360 Compiler with ORVYL\n\n This Section assumes that the ORVYL system is  being  used  at  Stanford\n where the ORVYL-PL360 compiler is saved as an ORVYL unload file.  To use\n it, just type:\n\n           ? PL360\n\n You will then receive the message:\n\n           -WELCOME TO PL360, Joe User\n           DECK?\n\n If your account has been activated for ORVYL files, then  you  can  type\n \"YES\" and PL360 will respond with:\n\n           FILE NAME?\n\n You should then type the name of an ORVYL file  in  which  PL360  should\n place the object modules from the subsequent compilation.  This file can\n be  either  new or old.  Appending \" SCR\" to the file name will cause an\n old file to be scratched for reuse; otherwise, you will be prompted:\n\n           SCRATCH?\n\n A \"NO\" response will cause the file naming process to be repeated.   The\n next thing PL360 asks is:\n\n           LISTING?\n\n If you respond \"YES\", then you will again be asked to  supply  an  ORVYL\n file to receive the PL360 Compiler list output.  PL360 then asks:\n\n           -?\n\n You can now type WYLBUR commands which will be passed to and executed by\n WYLBUR.  You can continue to  pass  commands  to  WYLBUR  (for  example,\n collect  lines,  edit  lines,  use  files,  copy files, etc.) until your\n WYLBUR working data set contains the PL360 program(s).   You  then  type\n \"COMPILE\"  immediately after a -?  prompt and PL360 will begin compiling\n the program(s) contained in your WYLBUR working data set.\n\n Any error messages and the line on which they occur  are  typed  at  the\n terminal  as  the compilation proceeds.  Each time a segment is closed a\n message is typed at the terminal.  When compiling from a WYLBUR  working\n data set, the compiler terminates at the end of the data set and types:\n\n           -LEAVING PL360\nB                                 12-1\n1You can type in a program directly by responding \"COMPILE  X\"  to  a  -?\n prompt, where X represents any non-blank character.  PL360 responds:\n\n           BEGIN TYPING PL360 PROGRAM\n           -?\n\n You can now type in a PL360 program and each line will  be  compiled  as\n you go.  Unfortunately, if you make a mistake, you must start over since\n the  old  lines  are  not saved.  Also, leading blanks are stripped from\n each input line.  For these reasons, it is usually best to compile  from\n a WYLBUR working data set.  When typing the program in directly, you can\n leave  PL360  at  any  time by typing \"/*\" or by simply hitting the ATTN\n button at the terminal.\n\n As you are leaving PL360, ORVYL core memory  is  automatically  cleared.\n The  WYLBUR  working  data  set  is not cleared.  If the program you are\n compiling has numerous errors and you wish to  suppress  the  typing  of\n error  messages  at the terminal, then simply hit the ATTN button at the\n terminal (except in response to a prompt).  PL360 will then ask:\n\n           DO YOU WANT FURTHER ERROR MESSAGES TYPED?\n\n A \"NO\" will cause the compilation to  continue  with  no  further  error\n messages  typed  at  the  terminal.   A  \"YES\" will cause compilation to\n continue as before.  In either case, the listing produced in  the  ORVYL\n file (if any) will be unaffected.\n\n After leaving PL360, you can retrieve the object deck by typing:\n\n           GET <file name> CARD CLEAR\n\n You can retrieve the listing by typing:\n\n           GET <file name> PRINT CLEAR\n\n The listing has 133-byte records, the first byte of which is a  carriage\n control  character.   Thus,  when  the  listing  is printed offline, the\n following WYLBUR command should be used:\n\n           LIST OFF BIN xxx UNN (0)\n\n The (0) part of the LIST command causes the first byte to be treated  as\n a  carriage control character.  The resulting line printer listing looks\n like a batch PL360 compilation listing.  The ORVYL version of PL360  has\n several   advantages:    Waiting  for  the  batch  queue  is  completely\n eliminated.  Errors are printed at the terminal, and thus can usually be\n fixed immediately and another compilation can be made  in  a  minute  or\n two.   Paper  is  saved  since  listings  with  errors are seldom listed\n offline.  Finally, the ORVYL version of the runtime library can be  used\n to  run  and test the program immediately at the terminal.  In this way,\n ORVYL's debugging tools can be used and debugging takes far  less  time.\n Most  short  compilations  can be done in about a second or two of ORVYL\n compute time (less than 50\u00a2).  This is a significant savings over  batch\n compilations.   The  PL360  compiler,  which  is  about 3000 cards long,\n compiles in 37 seconds of ORVYL compute time at a cost of about $6.20.\nB                                 12-2\n1\n 12.2  Input/Output Subroutines for Interactive PL360 Programs\n+12.2  Input/Output Subroutines for Interactive PL360 Programs\n+12.2  Input/Output Subroutines for Interactive PL360 Programs\n\n The standard input-output subroutines using the same linkage conventions\n as the READ and WRITE subroutines described in Section 9.1 are available\n for input-output operations directly at  the  terminal  when  running  a\n PL360  program  under the ORVYL monitor.  A description of the parameter\n passing conventions of these subroutines follows:\n\n    READ  The address of a 132 byte input area should be provided  in  R0\n          prior   to  calling  READ.   Upon  return,  all  registers  are\n          preserved except R15 which contains  the  number  of  non-blank\n          characters  typed  by the user (counting imbedded blanks).  All\n          details such as error messages  for  illegal  use  of  tabs  or\n          waiting  too  long  to  respond  are  taken care of by the READ\n          subroutine.  If the attention key is typed  with  no  preceding\n          characters, the condition code is set to 2, otherwise it is set\n          to 0.\n\n    WRITE This subroutine works exactly like the subroutine described  in\n          Section  9.1;  i.e.,  the  address of a 132 byte output area is\n          passed through register R0 and all registers are preserved upon\n          return.  The output area is typed at the terminal.\n\n The following discussion assumes that the ORVYL system is being used  at\n Stanford  where  the  ORVYL  READ  and WRITE subroutines and the library\n subroutines listed in Section 9 are stored in object module form in  the\n WYLBUR  file  T000.PL360.RUNLIB  on  SYS10.   To  run a PL360 program in\n ORVYL, just follow this simple process.   First,  compile  the  program.\n This  may  be  achieved either in batch or with the ORVYL version of the\n PL360 compiler.  The program must  be  a  statement  with  segment  name\n SEGN001  (cf.   Section 4).  Place the object module output of the PL360\n compiler in the WYLBUR working data set and type:\n\n           COPY ALL TO END FROM &T000.PL360.RUNLIB ON SYS10\n           LOAD TEXT\n\n Your program is now ready to be executed.  You could either  unload  the\n program  as  an ORVYL UNLOAD file and/or type the command ENTER to begin\n execution.\n\n Note that file I/O is not provided for in the ORVYL runtime routines.\nB                                 12-3\n1              APPENDIX A.  EXAMPLE PROGRAMS AND LISTINGS\n+              APPENDIX A.  EXAMPLE PROGRAMS AND LISTINGS\n+              APPENDIX A.  EXAMPLE PROGRAMS AND LISTINGS\n\n See Section 10 for details and descriptions of compiler control.\nB                                 A-1\n1\nB                                 A-2\n1\nB                                 A-3\n1\nB                                 A-4\n1\nB                                 A-5\n1\nB                                 A-6\n1\nB                                 A-7\n1\nB                                 A-8\n1\nB                                 A-9\n1\nB                                 A-10\n1\nB                                 A-11\n1\n1\n PL360 COMPILATION            Sample Program Demonstrating Extensions to PL360               ORVYL 10/28/74    PAGE   1\n+PL360 COMPILATION            Sample Program Demonstrating Extensions to PL360               ORVYL 10/28/74    PAGE   1\n+PL360 COMPILATION            Sample Program Demonstrating Extensions to PL360               ORVYL 10/28/74    PAGE   1\n                                 $STITLE card to provide a sub-title   (Koenig)\n0                                   $ON      Turn on printing of $-cards              (Guertin)                    5.\n                                    $GEN     Generate object decks even on errors.    (Guertin)                    6.\n                                    $BASE=12 Specifies default program base register  (Malcolm)                    7.\n                                    $SET a   Sets condition 'a'                       (Guertin)                    8.\n                                    $IFF b 1   Conditional compile test               (Guertin)                    9.\n                                    $IFT a 2   Continue compiling if condition 'a' was $SET                       10.\n                                    $END 1     End of conditional range 1             (Guertin)                   11.\n 001 0000   000 0000        0001             | Vertical bar comments                  (Guertin) |                 12.\n 001 0000   000 0000        0002             | These comments compiled if 'a' or 'b' was $SET   |                 13.\n                                    $SET b   Sets condition 'b'                                                   14.\n                                    $END 2     End of conditional range 2                                         15.\n                                    $RESET a   Turn off condition 'a'                 (Koenig)                    16.\n                                    $XREF 1  Turn on Cross-Reference capability       (Guertin)                   17.\n 001 0000   000 0000        0003                                                                                  18.\n 001 0000   000 0000        0004      BEGIN  |coding includes establishing proper base register (Malcolm)|        19.\n 001 001A   000 0048        0005 01   |coding includes XC instruction to set saved R15 to 0     (Koenig) |        20.\n                                    $3                                                                            21.\n 001 001A   000 0048        0006      |EQUATE declarations for integer value identifiers        (Guertin)|        22.\n 001 001A   000 0048        0007         EQUATE LEN SYN 3;                                                        23.\n          00000003  LEN\n 001 001A   000 0048        0008         ARRAY LEN BYTE ALPHA;                                                    24.\n              D048  ALPHA\n 001 001A   000 004B        0009         INTEGER BETA, GAMMA;                                                     25.\n              D04C  BETA\n              D050  GAMMA\n 001 001A   000 0054        0010      |EQUATES allows monadic, arithmetic, Boolean and shift ops(Guertin)|        26.\n 001 001A   000 0054        0011         EQUATE LO SYN 9,  LOMASK SYN 1 SHLL LO - 1,                              27.\n          00000009  LO\n 001 001A   000 0054        0012                HI SYN NEG LO + 16,  HIMASK SYN 1 SHLL HI - 1;                    28.\n          000001FF  LOMASK\n          00000007  HI\n          0000007F  HIMASK\n 001 001A   000 0054        0013      |EQUATES allows cell-cell                                 (Guertin)|        29.\n 001 001A   000 0054        0014         EQUATE SIZE SYN GAMMA(4) - ALPHA + 3 AND _4;                             30.\n          0000000C  SIZE\n 001 001A   000 0054        0015                                                                                  31.\n 001 001A   000 0054        0016      |Data Segment Declarations with BASE R0       (Guertin & Koenig)   |        32.\n 001 001A   000 0054        0017         DUMMY BASE R0;                                        |(Guertin)|        33.\n 001 001A   014 0000        0018            INTEGER MEM;                                                          34.\n              0000  MEM\n 001 001A   014 0004        0019         CLOSE BASE;                                                              35.\n 001 001A   000 0054        0020                                                                                  36.\n 001 001A   000 0054        0021         GLOBAL DATA SPACE BASE R0;                            |(Koenig) |        37.\n 001 001A   015 0000        0022            INTEGER SOMECELL;                                                     38.\n              0000  SOMECELL\n 001 001A   015 0004        0023         CLOSE BASE;                                                              39.\n0                           SEGMENT 015  NAME = SPACE      LENGTH = 0004  BASE REG = 00\n0                           EXTERNAL SYMBOL DICTIONARY\n                               SPACE     ENTRY (SD) AT 0000\n1\n PL360 COMPILATION            Sample Program Demonstrating Extensions to PL360               ORVYL 10/28/74    PAGE   2\n+PL360 COMPILATION            Sample Program Demonstrating Extensions to PL360               ORVYL 10/28/74    PAGE   2\n+PL360 COMPILATION            Sample Program Demonstrating Extensions to PL360               ORVYL 10/28/74    PAGE   2\n0001 001A   000 0054        0024      |GLOBAL, EXTERNAL and SEGMENT procedures allow BASE Rn    (Malcolm)|        41.\n 001 001A   000 0054        0025         GLOBAL PROCEDURE SAMPLE (R15) BASE R6;                                   42.\n                    SAMPLE\n 016 0000   000 0054        0026         BEGIN                                                                    43.\n 016 0000   000 0054        0027 02   |COMMON procedures to allow additional entry points.      (Guertin)|        44.\n 016 0000   000 0054        0028            COMMON PROCEDURE ENTRY (R15);                                         45.\n                    ENTRY\n 016 0008   000 0054        0029            BEGIN  |has all the properties of local procedure.|                   46.\n 016 0008   000 0054        0030 03   |New FUNCTION types 14 & 15.  See compiled code.          (Guertin)|        47.\n 016 0008   000 0054        0031               FUNCTION  MOVE4(14,#D203),  BRANCH(15,#47F0);                      48.\n              D203  MOVE4\n              47F0  BRANCH\n 016 0008   000 0054        0032               MOVE4(GAMMA,BETA);  BRANCH(B6(R4+10));                             49.\n 016 0012   000 0054        0033               R6 := R6-R6;  |return condition in BASE|        |(Guertin)|        50.\n 016 0014   000 0054        0034            END;                                                                  51.\n 016 0016   000 0054        0035 02         ENTRY(R3);  |See code for BAL to ENTRY, condition to R3|              52.\n 016 0022   000 0054        0036         END;                                                                     53.\n0                           SEGMENT 016  NAME = SAMPLE     LENGTH = 0028  BASE REG = 06\n0                 0000    47F06016  58606020  D203D050  D04C47F4   600A1B66  07FF45F0  60081236  05605860\n                  0020    600607FF  00000000\n0                           EXTERNAL SYMBOL DICTIONARY\n                               SAMPLE    ENTRY (SD) AT 0000\n                               ENTRY     ENTRY (LD) AT 0004\n0001 001A   000 0054        0037 01                                                                               54.\n 001 001A   000 0054        0038         EXTERNAL PROCEDURE ENTRY (R15) BASE R6;  NULL;        |(Malcolm)|        55.\n                    ENTRY\n 001 001A   000 0054        0039         ENTRY;    |See code for  BALR  to COMMON procedure.    (Guertin)|        56.\n 001 0024   000 0054        0040                                                                                  57.\n 001 0024   000 0054        0041      |Cell references may specify Base, Index, and expression  (Guertin)|        58.\n 001 0024   000 0054        0042         BEGIN  INTEGER REGISTER RB SYN R1,  RX SYN R2;                           59.\n              0001  RB\n              0002  RX\n 001 0024   000 0054        0043 02         SOMECELL(RB+RX+LEN+1) := R3;                                          60.\n 001 0028   000 0054        0044         END;                                                                     61.\n 001 0028   000 0054        0045 01                                                                               62.\n 001 0028   000 0054        0046      |Cell-to-cell assignment and conditions.                  (Guertin)|        63.\n 001 0028   000 0054        0047         B1 := B2;   B3 := 16;   B5 := \"string\";                                  64.\n 001 003A   000 0054        0048         WHILE R2 >= R1 AND B2 = \" \" DO                                           65.\n 001 0048   000 0054        0049         BEGIN  FUNCTION REDUCE(6,#0600);  REDUCE(R2);  END;                      66.\n              0600  REDUCE\n 001 004E   000 0054        0050 01      IF GAMMA \u00ac= BETA THEN GOTO TAG;                                          67.\n 001 0058   000 0054        0051                                                                                  68.\n 001 0058   000 0054        0052      |Cell-to-cell assignment allows Boolean expression        (Guertin)|        69.\n 001 0058   000 0054        0053         BETA := BETA AND GAMMA OR \"    \";                                        70.\n 001 0064   000 0054        0054                                                                                  71.\n 001 0064   000 0054        0055      |Cell-to-cell may specify length expression after /       (Guertin)|        72.\n 001 0064   000 0054        0056         GAMMA(4-LEN/LEN) := GAMMA(4-LEN) AND BETA(4-LEN) OR ALPHA;               73.\n 001 0070   000 0054        0057         ALPHA := \" \";  ALPHA(1/LEN-1) := ALPHA;                                  74.\n1\n PL360 COMPILATION            Sample Program Demonstrating Extensions to PL360               ORVYL 10/28/74    PAGE   3\n+PL360 COMPILATION            Sample Program Demonstrating Extensions to PL360               ORVYL 10/28/74    PAGE   3\n+PL360 COMPILATION            Sample Program Demonstrating Extensions to PL360               ORVYL 10/28/74    PAGE   3\n0001 007A   000 0054        0058      |<statement>; allowed to precede <condition>              (Koenig) |        76.\n 001 007A   000 0054        0059         WHILE R1 := R1+R2; R1 < 16 AND READ; \u00ac= DO R2 := R2-4;                   77.\n 001 009A   000 0054        0060                                                                                  78.\n 001 009A   000 0054        0061      |Pre-declared EQUATES for use with assignments and tests. (Koenig) |        79.\n 001 009A   000 0054        0062         BEGIN  EQUATE OVERFLOW SYN 1,  ON SYN 1,  MIXED SYN 4,  OFF SYN 8,       80.\n          00000001  OVERFLOW\n          00000001  ON\n          00000004  MIXED\n 001 009A   000 0054        0063 02                    CARRY SYN 3,  TRUE SYN _1,  FALSE SYN 0;                   81.\n          00000008  OFF\n          00000003  CARRY\n          FFFFFFFF  TRUE\n          00000000  FALSE\n 001 009A   000 0054        0064                                                                                  82.\n 001 009A   000 0054        0065      |<condition> allowed to be <integer> or \u00ac<integer>        (Koenig) |        83.\n 001 009A   000 0054        0066            IF EX(R4,TM(0,B1)); MIXED THEN GOTO TAG;                              84.\n 001 00A2   000 0054        0067            IF \u00acON THEN GOTO TAG;                                                 85.\n 001 00A6   000 0054        0068            ALPHA := TRUE;  IF ALPHA(1) = FALSE THEN GOTO TAG;                    86.\n 001 00B2   000 0054        0069         END;                                                                     87.\n 001 00B2   000 0054        0070 01                                                                               88.\n 001 00B2   000 0054        0071      |$SPACE control card to space listing                     (Koenig) |        89.\n0\n0\n0001 00B2   000 0054        0072      |Hexadecimal strings for packed-decimal and edit masks    (Guertin)|        91.\n 001 00B2   000 0054        0073         BETA(1) := #4096CX;  GAMMA := #40202120X;                                92.\n 001 00BE   000 0054        0074                                                                                  93.\n 001 00BE   000 0054        0075      |STRING equate which has length of last \"string\"          (Guertin)|        94.\n 001 00BE   000 0054        0076         LA(R1,\"This is a test.\");  R2 := STRING;                                 95.\n 001 00C6   000 0054        0077         IF R3 = 0 THEN B1(STRING-5) := \"mess\";                                   96.\n 001 00D2   000 0054        0078                                                                                  97.\n 001 00D2   000 0054        0079      |CASE statement now uses halfword vector table. (Malcolm & Guertin)|        98.\n 001 00D2   000 0054        0080         CASE R1 OF BEGIN   |See compiled code.|                                  99.\n 001 00D2   000 0054        0081 02         R5 := R5 + R3;                                                       100.\n 001 00DE   000 0054        0082            R5 := R5 - R3;                                                       101.\n 001 00E4   000 0054        0083            R5 := R5 * R3;                                                       102.\n 001 00EA   000 0054        0084            R5 := R5 / R3;                                                       103.\n 001 00F0   000 0054        0085         END;               |See compiled code.|                                 104.\n 001 00FC   000 0054        0086 01                                                                              105.\n                                    $COPY DDNAME          Copy from sequential data set         (Guertin)        106.\n 001 00FC   000 0054        0087      |This is copy code from a WYLBUR Edit format data set.|                    $COPY\n 001 00FC   000 0054        0088      | //DDNAME DD DSN=SYS1.DDNAME,VOL=SER=TEMP01,UNIT=2314,     |              $COPY\n 001 00FC   000 0054        0089      | //  DISP=OLD,DCB=(RECFM=U,BLKSIZE=3156)                   |              $COPY\n 001 00FC   000 0054        0090      |This is the end of the $COPY DDNAME|                                      $COPY\n                                    $COPY DATA(MEMBER)    Copy from partitioned data set        (Koenig)         107.\n 001 00FC   000 0054        0091      |This is code from MEMBER of DATA.|                                        $COPY\n 001 00FC   000 0054        0092      | //DATA DD DSN=SYS1.DATA,VOL=SER=TEMP01,UNIT=2314,DISP=OLD |              $COPY\n 001 00FC   000 0054        0093      |This is the end of the $COPY DATA(MEMBER)|                                $COPY\n1\n PL360 COMPILATION            Sample Program Demonstrating Extensions to PL360               ORVYL 10/28/74    PAGE   4\n+PL360 COMPILATION            Sample Program Demonstrating Extensions to PL360               ORVYL 10/28/74    PAGE   4\n+PL360 COMPILATION            Sample Program Demonstrating Extensions to PL360               ORVYL 10/28/74    PAGE   4\n0                                   $NOXREF     Turn off collection of cross-references         (Guertin)        109.\n 001 00FC   000 0054        0094      TAG: END.                                                                  110.\n0                           SEGMENT 000  NAME = SEGN000    LENGTH = 0058  BASE REG = 13\n0                           EXTERNAL SYMBOL DICTIONARY\n                               SEGN000   ENTRY (SD) AT 0000\n0                           SEGMENT 001  NAME = SEGN001    LENGTH = 0148  BASE REG = 12\n0                 0000    90ECD00C  18CF18ED  58D0C13C  50E0D004   50D0E008  D703E010  E0105860  C14005F6\n                  0020    58C0F118  50321004  D2031000  2000D203   3000C130  D2055000  C1061921  4750C04E\n                  0040    95402000  4770C04E  062047F0  C03AD503   D050D04C  4760C0FC  D403D04C  D050D603\n                  0060    D04CC10C  D402D051  D04DD602  D051D048   9240D048  D201D049  D0481A12  5910C130\n                  0080    47B0C09A  58F0C144  05EF58C0  E0AE4790   C09A5B20  C13447F0  C07A4440  C12A4740\n                  00A0    C0FC47E0  C0FC92FF  D0489500  D0494780   C0FCD202  D04DC110  D203D050  C1134110\n                  00C0    C1174120  000F1233  4770C0D2  D203100A   C1261A11  4811C0F2  47F1C000  1A5347FC\n                  00E0    00FC1B53  47FC00FC  1C4347FC  00FC1D43   47FC00FC  00DC00E2  00E800EE  58D0D004\n                  0100    98ECD00C  07FEA2A3  99899587  40404040   04096C40  202120E3  8889A240  89A24081\n                  0120    40A385A2  A34B9485  A2A29100  10004710   00000010  00000004  00000000  00000000\n                  0140    00000000  00000000\n0                           EXTERNAL SYMBOL DICTIONARY\n                               SEGN001   ENTRY (SD) AT 0000\n                               SEGN000   EXTERNAL REFERENCE\n                               ENTRY     EXTERNAL REFERENCE\n                               READ      EXTERNAL REFERENCE\n1\n PL360 CROSS REFERENCE        Sample Program Demonstrating Extensions to PL360               ORVYL 10/28/74    PAGE   5\n+PL360 CROSS REFERENCE        Sample Program Demonstrating Extensions to PL360               ORVYL 10/28/74    PAGE   5\n+PL360 CROSS REFERENCE        Sample Program Demonstrating Extensions to PL360               ORVYL 10/28/74    PAGE   5\n0              54 SYMBOLS,    128 REFERENCES\n0ALPHA       0008  0014  0056  0057  0057  0057  0068  0068\n BETA        0009  0032  0050  0053  0053  0056  0073\n BRANCH      0031  0032\n B1          0047  0066  0077\n B2          0047  0048\n B3          0047\n B5          0047\n B6          0032\n CARRY       0063\n ENTRY       0028  0035  0038  0039\n EX          0066\n FALSE       0063  0068\n GAMMA       0009  0014  0032  0050  0053  0056  0056  0073\n HI          0012  0012\n HIMASK      0012\n LA          0076\n LEN         0007  0008  0043  0056  0056  0056  0056  0057\n LO          0011  0011  0012\n LOMASK      0011\n MEM         0018\n MIXED       0062  0066\n MOVE4       0031  0032\n OFF         0062\n ON          0062  0067\n OVERFLOW    0062\n RB          0042  0043\n READ        0059\n REDUCE      0049  0049\n RX          0042  0043\n R0          0017  0021\n R1          0042  0048  0059  0059  0059  0076  0080\n R15         0025  0028  0038\n R2          0042  0048  0049  0059  0059  0059  0076\n R3          0035  0043  0077  0081  0082  0083  0084\n R4          0032  0066\n R5          0081  0081  0082  0082  0083  0083  0084  0084\n R6          0025  0033  0033  0033  0038\n SAMPLE      0025\n SIZE        0014\n SOMECELL    0022  0043\n SPACE       0021\n STRING      0076  0077\n TAG         0050  0066  0067  0068\n TM          0066\n TRUE        0063  0068\n0      NO ERRORS DETECTED\n1\n PL360 COMPILATION           RIGHT TRIANGLE PROBLEM                                           ORVYL 04/09/74    PAGE  1\n+PL360 COMPILATION           RIGHT TRIANGLE PROBLEM                                           ORVYL 04/09/74    PAGE  1\n+PL360 COMPILATION           RIGHT TRIANGLE PROBLEM                                           ORVYL 04/09/74    PAGE  1\n0001 0000   000 0000        0001 00   BEGIN COMMENT -- THIS IS A SAMPLE PROGRAM WHICH                             32.\n 001 0018   000 0048        0002 01   *  MAKES USE OF MOST OF THE FEATURES OF PL360.                              33.\n 001 0018   000 0048        0003      *  THE PROGRAM READS THE SIDES OF A RIGHT TRIANGLE,                         34.\n 001 0018   000 0048        0004      *  COMPUTES THE HYPOTENUSE, AND WRITES THE RESULT. --;                      35.\n 001 0018   000 0048        0005                                                                                  36.\n 001 0018   000 0048        0006      COMMENT -- DECLARE EXTERNAL PROCEDURES, FUNCTIONS,                          37.\n 001 0018   000 0048        0007      *  AND VARIABLES FIRST. --;                                                 38.\n 001 0018   000 0048        0008                                                                                  39.\n 001 0018   000 0048        0009         EXTERNAL PROCEDURE VALTOBCD (R14);  NULL;                                40.\n                    VALTOBCD\n 001 0018   000 0048        0010         EXTERNAL PROCEDURE BCDTOVAL (R14);  NULL;                                41.\n                    BCDTOVAL\n 001 0018   000 0048        0011                                                                                  42.\n 001 0018   000 0048        0012         PROCEDURE SQRT (R14);  IF F01 > 0L THEN                                  43.\n                    SQRT\n 001 0022   000 0048        0013         COMMENT THIS PROCEDURE TAKES THE SQUARE ROOT OF THE VALUE IN F01;        44.\n 001 0022   000 0048        0014         BEGIN  LONG REAL FCON;                                                   45.\n              D048  FCON\n 001 0022   000 0050        0015 02         FCON := F01;  R1 := R1-R1;                                            46.\n 001 0028   000 0050        0016            IC(R1,FCON);  R1 := R1 - #40S SHRA 1 + #40S;                          47.\n 001 0038   000 0050        0017            STC(R1,FCON);  F45 := FCON;  F6 := 1R;                                48.\n 001 0044   000 0050        0018            WHILE F67 > 10'_6L DO                                                 49.\n 001 004C   000 0050        0019            BEGIN  F23 := F45;                                                    50.\n 001 004E   000 0050        0020 03            F45 := F01/F23 + F23 / 2L;                                         51.\n 001 0058   000 0050        0021               F67 := F45 - F23;  F67 := ABS F67;                                 52.\n 001 005E   000 0050        0022            END;  F01 := F45;                                                     53.\n 001 0064   000 0050        0023 02      END;                                                                     54.\n 001 0066   000 0050        0024 01                                                                               55.\n 001 0066   000 0050        0025      COMMENT -- READ & WRITE ARE ALREADY KNOWN --;                               56.\n 001 0066   000 0050        0026         FUNCTION REDUCE (6,#0600);  COMMENT -- SUBTRACT 1 FROM REGISTER --;      57.\n              0600  REDUCE\n 001 0066   000 0050        0027                                                                                  58.\n 001 0066   000 0050        0028         ARRAY 134 BYTE OUTPUT = (                                                59.\n              D050  OUTPUT\n 001 0066   000 00D6        0029            \" HYPOTENUSE =         FOR SIDES OF\",100(\" \"));                       60.\n 001 0066   000 00D6        0030         BYTE CARD SYN OUTPUT(35), ANSWER SYN OUTPUT(14);                         61.\n              D073  CARD\n              D05E  ANSWER\n 001 0066   000 00D6        0031                                                                                  62.\n 001 0066   000 00D6        0032      COMMENT -- MAIN CODE --;                                                    63.\n 001 0066   000 00D6        0033      LOOP: R0 := @CARD;  READ;  IF \u00ac= THEN GOTO EXIT;                            64.\n 001 0078   000 00D6        0034         R1 := @CARD;  R2 := 3;  BCDTOVAL;  F67 := F01 * F01;                     65.\n 001 008E   000 00D6        0035         BCDTOVAL;  F01 := F01 * F01 + F67;                                       66.\n 001 009C   000 00D6        0036         SQRT;   COMMENT -- TAKE SQUARE ROOT OF VALUE IN F01 --;                  67.\n 001 00A0   000 00D6        0037         R1 := @ANSWER;  R3 := 7;  VALTOBCD;                                      68.\n 001 00B2   000 00D6        0038         R0 := @OUTPUT;  WRITE;  GOTO LOOP;                                       69.\n 001 00C4   000 00D6        0039      EXIT: END.                                                                  70.\n0                           SEGMENT 000  NAME = SEGN000    LENGTH = 00D8  BASE REG = 13\n0                 0050    40C8E8D7  D6E3C5D5  E4E2C540  7E404040   40404040  4040C6D6  D940E2C9  C4C5E240\n                  0070    D6C64040  40404040  40404040  40404040   40404040  40404040  40404040  40404040\n                  0090 TO 00CC      40404040\n                  00D0    40404040  4040\n0                           EXTERNAL SYMBOL DICTIONARY\n                               SEGN000   ENTRY (SD) AT 0000\n1\n PL360 COMPILATION           RIGHT TRIANGLE PROBLEM                                           ORVYL 04/09/74    PAGE  2\n+PL360 COMPILATION           RIGHT TRIANGLE PROBLEM                                           ORVYL 04/09/74    PAGE  2\n+PL360 COMPILATION           RIGHT TRIANGLE PROBLEM                                           ORVYL 04/09/74    PAGE  2\n0                           SEGMENT 001  NAME = SEGN001    LENGTH = 0100  BASE REG = 15\n0                 0000    90ECD00C  18ED58D0  F0D850E0  D00450D0   E008D703  E010E010  47F0F066  220047D0\n                  0020    F0646000  D0481B11  4310D048  4B10F0CE   8A100001  4A10F0CE  4210D048  6840D048\n                  0040    7860F0D0  6960F0F0  47D0F062  28242840   2D422A42  6D40F0F8  28642B62  206647F0\n                  0060    F0442804  07FE4100  D07358F0  F0DC05EF   58F0E064  4760F0C4  4110D073  41200003\n                  0080    58F0F0E0  05EF58F0  E04E2860  2C6058F0   F0E005EF  58F0E040  2C002A06  45E0F01C\n                  00A0    4110D05E  41300007  58F0F0E4  05EF58F0   E0264100  D05058F0  F0E805EF  58F0E018\n                  00C0    47F0F066  58D0D004  98ECD00C  07FE0040   41100000  00000000  00000000  00000000\n                  00E0    00000000  00000000  00000000  72565520   3CA7C5AC  471B4784  41200000  00000000\n0                           EXTERNAL SYMBOL DICTIONARY\n                               SEGN001   ENTRY (SD) AT 0000\n                               SEGN000   EXTERNAL REFERENCE\n                               READ      EXTERNAL REFERENCE\n                               BCDTOVAL  EXTERNAL REFERENCE\n                               VALTOBCD  EXTERNAL REFERENCE\n                               WRITE     EXTERNAL REFERENCE\n1\n PL360 CROSS REFERENCE       RIGHT TRIANGLE PROBLEM                                           ORVYL 04/09/74    PAGE  3\n+PL360 CROSS REFERENCE       RIGHT TRIANGLE PROBLEM                                           ORVYL 04/09/74    PAGE  3\n+PL360 CROSS REFERENCE       RIGHT TRIANGLE PROBLEM                                           ORVYL 04/09/74    PAGE  3\n0              24 SYMBOLS,     71 REFERENCES\n0ANSWER      0030  0037\n0BCDTOVAL    0010  0034  0035\n0CARD        0030  0033  0034\n0EXIT        0033  0039\n0FCON        0014  0015  0016  0017  0017\n0F01         0012  0015  0020  0022  0034  0034  0035  0035  0035\n0F23         0019  0020  0020  0021\n0F45         0017  0019  0020  0021  0022\n0F6          0017\n0F67         0018  0021  0021  0021  0034  0035\n0IC          0016\n0LOOP        0033  0038\n0OUTPUT      0028  0030  0030  0038\n0READ        0033\n0REDUCE      0026\n0R0          0033  0038\n0R1          0015  0015  0015  0016  0016  0016  0017  0034  0037\n0R14         0009  0010  0012\n0R2          0034\n0R3          0037\n0SQRT        0012  0036\n0STC         0017\n0VALTOBCD    0009  0037\n0WRITE       0038\n0      NO ERRORS DETECTED\n1\n PL360 COMPILATION           TRTEST                                                           ORVYL 04/09/74    PAGE  1\n+PL360 COMPILATION           TRTEST                                                           ORVYL 04/09/74    PAGE  1\n+PL360 COMPILATION           TRTEST                                                           ORVYL 04/09/74    PAGE  1\n0001 0000   000 0000        0001      GLOBAL PROCEDURE TRTEST (R14);  BEGIN                                        4.\n                    TRTEST\n 014 0000   000 0000        0002 01   COMMENT THIS ROUTINE TESTS AN INPUT STRING                                   5.\n 014 0000   000 0000        0003      * AGAINST A TRANSLATE TABLE.                                                 6.\n 014 0000   000 0000        0004      * ENTER WITH R1 = @ OF STRING TO BE TESTED.                                  7.\n 014 0000   000 0000        0005      *            R2 = @ OF TABLE.                                                8.\n 014 0000   000 0000        0006      *            R3 = LENGTH OF STRING TO BE TESTED.                             9.\n 014 0000   000 0000        0007      * EXITS WITH R1 = LENGTH OF TRANSLATED STRING.                              10.\n 014 0000   000 0000        0008      *            R2 = TRANSLATE TABLE CHARACTER WHICH                           11.\n 014 0000   000 0000        0009      *                 STOPPED TRANSLATION.                                      12.\n 014 0000   000 0000        0010      *      ALSO, CONDITION CODE SET BASED ON R2;                                13.\n 014 0000   000 0000        0011         FUNCTION REDUCE(6,#0600);                                                14.\n              0600  REDUCE\n 014 0000   000 0000        0012         STM(R3,R6,B13(12)); COMMENT SAVE REGISTERS;                              15.\n 014 0004   000 0000        0013         R4 := R2; R5 := @B1; R2 := R2-R2; R1 := R2;                              16.\n 014 000E   000 0000        0014         IF R3 > 0 THEN                                                           17.\n 014 0014   000 0000        0015         BEGIN REDUCE(R3); R6 := R2;                                              18.\n 014 0018   000 0000        0016 02         FOR R3 := R3 STEP _256 UNTIL 256 DO                                   19.\n 014 0018   000 0000        0017            BEGIN TRT(255,B5,B4); IF \u00ac= THEN                                      20.\n 014 0026   000 0000        0018 03            BEGIN R1 := @B1(R6)-R5; GOTO EXIT;                                 21.\n 014 0030   000 0000        0019 04            END ELSE                                                           22.\n 014 0030   000 0000        0020 03            BEGIN R6 := @B6(256); R5 := @B5(256);                              23.\n 014 003C   000 0000        0021 04            END;                                                               24.\n 014 003C   000 0000        0022 03         END; EX(R3,TRT(0,B5,B4));                                             25.\n 014 004C   000 0000        0023 02         IF = THEN R1 := @B5(R3+1);                                            26.\n 014 0054   000 0000        0024            R1 := @B1(R6) - R5;                                                   27.\n 014 005A   000 0000        0025         END;                                                                     28.\n 014 005A   000 0000        0026 01   EXIT: LM(R3,R6,B13(12)); LTR(R2,R2);                                        29.\n 014 0060   000 0000        0027      END.                                                                        30.\n0                           SEGMENT 014  NAME = TRTEST     LENGTH = 0070  BASE REG = 15\n0                 0000    9036D00C  18424150  10001B22  18121233   47D0F05A  06301862  47F0F040  DDFF5000\n                  0020    40004790  F0344116  10001B15  47F0F05A   47F0F03C  41606100  41505100  5A30F068\n                  0040    5930F06C  47A0F01C  4430F062  4770F054   41135001  41161000  1B159836  D00C1222\n                  0060    07FEDD00  50004000  FFFFFF00  00000100\n0                           EXTERNAL SYMBOL DICTIONARY\n                               TRTEST    ENTRY (SD) AT 0000\n1\n PL360 CROSS REFERENCE       TRTEST                                                           ORVYL 04/09/74    PAGE  2\n+PL360 CROSS REFERENCE       TRTEST                                                           ORVYL 04/09/74    PAGE  2\n+PL360 CROSS REFERENCE       TRTEST                                                           ORVYL 04/09/74    PAGE  2\n0              20 SYMBOLS,     55 REFERENCES\n0B1          0013  0018  0024\n0B13         0012  0026\n0B4          0017  0022\n0B5          0017  0020  0022  0023\n0B6          0020\n0EX          0022\n0EXIT        0018  0026\n0LM          0026\n0LTR         0026\n0REDUCE      0011  0015\n0R1          0013  0018  0023  0024\n0R14         0001\n0R2          0013  0013  0013  0013  0013  0015  0026  0026\n0R3          0012  0014  0015  0016  0016  0022  0023  0026\n0R4          0013\n0R5          0013  0018  0020  0024\n0R6          0012  0015  0018  0020  0024  0026\n0STM         0012\n0TRT         0017  0022\n0TRTEST      0001\n0      NO ERRORS DETECTED\n1\n PL360 COMPILATION           ORVYL PROGRAM TO SET OPTIONS                                     ORVYL 04/22/74    PAGE  1\n+PL360 COMPILATION           ORVYL PROGRAM TO SET OPTIONS                                     ORVYL 04/22/74    PAGE  1\n+PL360 COMPILATION           ORVYL PROGRAM TO SET OPTIONS                                     ORVYL 04/22/74    PAGE  1\n0001 0000   000 0000        0001      GLOBAL PROCEDURE OPTION (R14) BASE R10;                                      1.\n                    OPTION\n 014 0000   000 0000        0002      BEGIN BALR(R10,R0);  R1 := 2;  R10 := R10-R1;                                2.\n 014 0008   000 0000        0003 01      BEGIN PROCEDURE TPUT (R9);                                                3.\n                    TPUT\n 014 000C   000 0000        0004 02         BEGIN R0 := 1;  SVC(246);  R0 := 1;  SVC(242);                         4.\n 014 0018   000 0000        0005 03         END;  PROCEDURE WYLBUR (R9);                                           5.\n                    WYLBUR\n 014 001A   000 0000        0006 02         BEGIN R1 := NEG R1;  R0 := R0-R0;  SVC(254);  END;                     6.\n 014 0022   000 0000        0007 02         LA(R1,#5F1CX);  R15 := 2;  TPUT;                                       7.\n 014 002E   000 0000        0008            LA(R1,\"SET TERSE\");  R15 := STRING;  WYLBUR;                           8.\n 014 003A   000 0000        0009            LA(R1,\"SET NUM\");  R15 := STRING;  WYLBUR;                             9.\n 014 0046   000 0000        0010            LA(R1,\"SET VOL SYS19\");  R15 := STRING;  WYLBUR;                      10.\n 014 0052   000 0000        0011            LA(R1,\"SET NOTIME\");  R15 := STRING;  WYLBUR;                         11.\n 014 005E   000 0000        0012            LA(R1,\"SET WIDTH 72\");  R15 := STRING;  WYLBUR;                       12.\n 014 006A   000 0000        0013            SVC(253);                                                             13.\n 014 006C   000 0000        0014         END;                                                                     14.\n 014 006C   000 0000        0015 01   END.                                                                        15.\n\n1\n                      APPENDIX B.  THE OBJECT CODE\n+                     APPENDIX B.  THE OBJECT CODE\n+                     APPENDIX B.  THE OBJECT CODE\n\n Three principal postulates were used as guidelines in the design of  the\n language:\n\n     1.  Statements which express operations on data must correspond\n         to machine instructions in an obvious way.  Their structure\n         must be such that they decompose into structural  elements,\n         each corresponding directly to a single instruction.\n     2.  No storage element of the computer should  be  hidden  from\n         the  programmer.   In  particular,  the  usage of registers\n         should be explicitly expressed by each program.\n     3.  The control of sequencing should be expressible  implicitly\n         by  the  structure  of  certain  statements  (e.g., through\n         prefixing them with clauses indicating their conditional or\n         iterative execution).\n\n The following paragraphs show the machine code into  which  the  various\n constructs  of  the  language  are translated.  The mnemonics of the 360\n Assembly language \u00dd7\u00a8 are used to denote  the  individual  instructions.\n It is assumed that R15 is the program base register (cf.  4.2, 10.1).\n\n\n             Operands                                      Operators\n+            Operands                                      Operators\n+            Operands                                      Operators\n ____________________________________________________________________________________________\n\n K register          A primary          1      2      3     4     5      6      7     8   9\n   (type)              (type)           :=     +      -     *     /      ++     --    :=\n ____________________________________________________________________________________________\n\n integer         integer register      LR     AR     SR     MR    DR    ALR    SLR        CR\n\n integer         integer cell          L      A      S      M     D     AL     SL    ST   C\n\n integer         short integer cell    LH     AH     SH     MH                       STH  CH\n\n real            real register         LER    AER    SER    MER   DER   AUR    SUR        CER\n\n real            real cell             LE     AE     SE     ME    DE    AU     SU    STE  CE\n\n long real       real register         LER    AER    SER    MER   DER   AUR    SUR        CER\n\n long real       long real register    LDR    ADR    SDR    MDR   DDR   AWR    SWR        CDR\n\n long real       real cell             LE     AE     SE     ME    DE    AU     SU    STE  CE\n\n long real       long real cell        LD     AD     SD     MD    DD    AW     SW    STD  CD\n _____________________________________________________________________________________________\n\n                            Table B.1 - Object Code Operators\n+                           Table B.1 - Object Code Operators\n+                           Table B.1 - Object Code Operators\n\n\n 1.         <K-register> := <A-primary>\n\n The code consists of a single load instruction depending on the types of\n register and primary (cf.  Table B.1, column 1).\nB                                 B-1\n12.         <K-register assignment><operator><A-primary>\n\n The code consists of a single instruction depending on the operator  and\n the  types of register and primary.  It is determined according to Table\n B.1, columns 2-7.\n\n\n 3.         <A-cell> := <K-register>\n\n The code consists of a single store instruction depending on  the  types\n of cell and register as indicated by Table B.1, column 8.\n\n\n 4.         IF <condition-1> AND ... AND <condition-n-1> AND\n            <condition-n> THEN <simple statement> ELSE <statement>\n\n                         (condition-1)\n                         BC c1,L1\n                           ...\n                         (condition-n-1)\n                         BC cn-1,L1\n                         (condition-n)\n                         BC cn,L1\n                         (simple statement)\n                         B  L2\n                    L1   (statement)\n                    L2\n\n ci is determined by the i-th condition, which itself  either  translates\n into a compare instruction depending on the types of compared quantities\n (cf.   Table  B.1, column 9), or has no corresponding instruction, if it\n merely designates a relation or integer value.\n\n Example:     IF R1 < R2 THEN R0 := R3 ELSE R0 := R4\n\n                    CR 1,2\n                    BC 10, L1\n                    LR 0,3\n                    B  L2\n              L1    LR 0,4\n              L2\n\n\n 5.         IF <condition-1> OR ... OR <condition-n-1> OR\n            <condition-n> THEN <simple statement> ELSE <statement>\n\n                         (condition-1)\n                         BC c1,L1\n                             ...\n                         (condition-n-1)\n                         BC cn-1,L1\n                         (condition-n)\n                         BC cn,L2\n                    L1   (simple statement)\n                         B  L3\n                    L2   (statement)\n                    L3\nB                                 B-2\n1\n 6.         CASE <integer register-m> OF\n            BEGIN <statement-1>;\n                  <statement-2>;\n                     ...\n                  <statement-n>;\n            END\n\n                         AR  m,m\n                         LH  m,SW(m)\n                         B   0(m,p)\n                    L1   EQU  *-ORIGIN\n                         (statement-1)\n                         B    LX(P,0)\n                    L2   EQU  *-ORIGIN\n                         (statement-2)\n                         B    LX(P,0)\n                         .    .\n                         .    .\n                         .    .\n                    Ln   EQU  *-ORIGIN\n                         (statement-n)\n                         B    LX(P,0)\n                    SW   EQU  *-2\n                         DC   Y(L1)\n                         DC   Y(L2)\n                         .    .\n                         .    .\n                         .    .\n                         DC   Y(Ln)\n                    LX   EQU  *-ORIGIN\n\n ORIGIN is the address of  the  beginning  of  the  program  segment  and\n register Rp is assumed to contain this address (cf.  5.1, 8.1).\n\n\n 7.         WHILE <condition> DO <statement>\n\n                    L1   (condition)\n                         BC   cond,L2\n                         (statement)\n                         B    L1\n                    L2\n\n If the condition is compound, then code sequences similar to those given\n under 4 and 5 are used.\n\n\n 8.         FOR <integer register assignment>\n            STEP <increment> UNTIL <limit> DO <statement>\n\n                         (integer register assignment)\n                         B    L2\n                    L1   (statement)\n                         A    m,INC\n                    L2   C    m,LIM\n                         BC   cond,L1\nB                                 B-3\n1\n Rm is the register specified by the assignment, INC the  location  where\n the increment is stored, and LIM the location where the limit is stored.\n The  compare  instruction at L2 may be either a C, CH, or CR instruction\n depending on the type of limit.  Moreover, cond depends on the  sign  of\n the increment.\n\n\n 9.         PROCEDURE <identifier>(<integer register>);<statement>\n\n                    P    (statement)\n                         BR  m\n\n It is assumed that the integer register enclosed in  parentheses  is  Rm\n and P is a label corresponding to the procedure identifier.\n\n\n 10.        <procedure identifier>\n\n                         BAL  m,P\n\n                    or   L    b,newbase\n                         BALR m,b\n                         L    b,oldbase\n\n                    or   L    b,newbase\n                         BAL  m,P\n                         L    b,oldbase\n\n It is here assumed  that  P  designates  the  relative  address  of  the\n procedure  to  be  called  within  the  program  segment  in which it is\n declared, and  m  is  the  return  address  register  specified  in  its\n declaration,  and  b  is the program segment's base register.  The first\n version of code is obtained whenever the segment in which the  procedure\n is  declared  is  also the one in which it is invoked.  If the procedure\n call is of the form\n\n            <procedure identifier>(Rn)\n\n then the instruction sequences become:\n\n                         BAL  m,P\n                         LTR  n,b\n                         BALR b,0\n                         L    b,oldbase\n\n                    or   L    b,newbase\n                         BALR m,b\n                         LTR  n,b\n                         BALR b,0\n                         L    b,oldbase\n\n                    or   L    b,newbase\n                         BAL  m,P\n                         LTR  n,b\n                         BALR b,0\n                         L    b,oldbase\nB                                 B-4\n1                   APPENDIX C.  COMPILER CONSTRUCTS\n+                   APPENDIX C.  COMPILER CONSTRUCTS\n+                   APPENDIX C.  COMPILER CONSTRUCTS\n\n\n Registers\n+Registers\n+Registers\n\n      Reg      R0 thru R15          INTEGER\n      Freg     F0, F2, F4, F6       REAL\n      Lreg     F01, F23, F45, F67   LONG REAL\n\n Subscript -d indicates that register assigned on the left  side  of  the\n assign symbol (:=), thus\n\n      Reg-d := Expression\n\n\n Cells\n+Cells\n+Cells\n\n      Bcell    BYTE                 Value X\n      Scell    SHORT INTEGER        Value S\n      Icell    INTEGER              Value\n      Fcell    REAL                 Value R\n      Lcell    LONG REAL            Value L\n\n Note:  Values may replace cells in an expression.\n\n      Reg-d := Icell    could be:   (Icell)\n               Reg-d := #FACE      0000FACE\n               Reg-d := \"DROP\"     C4D9D6D7\n               Reg-d := _4         FFFFFFFC\n\n\n Conditions\n+Conditions\n+Conditions\n\n Cond represents, = , \u00ac= , >= , <= , > , < , Number , \u00acNumber\nB                                 C-1\n1\n In the following tables, * preceding the CODE indicates the  instruction\n does not change the condition code.\n\n\n      Code     Mnemonic       Compiler Construct\n+     Code     Mnemonic       Compiler Construct\n+     Code     Mnemonic       Compiler Construct\n\n      05       BALR           Procname   (not local procedure call)\n      07       BCR            END of any PROCEDURE\n      10       LPR            Reg-d := ABS Reg\n      11       LNR            Reg-d := NEG ABS Reg\n      12       LTR            Reg Cond 0\n      13       LCR            Reg-d := NEG Reg\n      14       NR             Reg-d AND Reg\n      16       OR             Reg-d OR Reg\n      17       XR             Reg-d XOR Reg\n     *18       LR             Reg-d := Reg   or   Reg-d ... =: Reg\n                   Note: Reg-d := Reg-d generates no code.\n      19       CR             Reg-1 Cond Reg-2\n      1A       AR             Reg-d + Reg\n      1B       SR             Reg-d - Reg\n     *1C       MR             Reg-d * Reg\n                   Note: Reg-d must be odd numbered\n     *1D       DR             Reg-d / Reg\n                   Note: Reg-d must be odd numbered\n      1E       ALR            Reg-d ++ Reg\n      1F       SLR            Reg-d -- Reg\n      20       LPDR           Lreg-d := ABS Lreg\n      21       LNDR           Lreg-d := NEG ABS Lreg\n      22       LTDR           Lreg Cond 0L\n      23       LCDR           Lreg-d := NEG Lreg\n     *28       LDR            Lreg-d := Lreg   or   Lreg-d ... =: Lreg\n                   Note: Lreg-d := Lreg-d generates no code.\n      29       CDR            Lreg-1 Cond Lreg-2\n      2A       ADR            Lreg-d + Lreg\n      2B       SDR            Lreg-d - Lreg\n     *2C       MDR            Lreg-d * Lreg\n     *2D       DDR            Lreg-d / Lreg\n      2E       AWR            Lreg-d ++ Lreg\n      2F       SWR            Lreg-d -- Lreg\n      30       LPER           Freg-d := ABS Freg\n      31       LNER           Freg-d := NEG ABS Freg\n      32       LTER           Freg Cond 0R\n      33       LCER           Freg-d := NEG Freg\n     *38       LER            Freg-d := Freg   or   Freg-d ... =: Freg\n                   Note: Freg-d := Freg-d generates no code.\n      39       CER            Freg-1 Cond Freg-2\n      3A       AER            Freg-d + Freg\n      3B       SER            Freg-d - Freg\n     *3C       MER            Freg-d * Freg\n     *3D       DER            Freg-d / Freg\n      3E       AUR            Freg-d ++ Freg\n      3F       SUR            Freg-d -- Freg\n\n                     Table C.1 - 2-Byte Instructions\n+                    Table C.1 - 2-Byte Instructions\n+                    Table C.1 - 2-Byte Instructions\nB                                 C-2\n1\n      All these instructions allow indexable cells.\n\n      Code     Mnemonic       Compiler Construct\n+     Code     Mnemonic       Compiler Construct\n+     Code     Mnemonic       Compiler Construct\n\n     *40       STH            Scell := Reg   or   Reg-d ... =: Scell\n     *41       LA             Reg-d := @Cell\n      45       BAL            Procname   (local procedure call)\n     *47       BC             GOTO Tag\n                              --- THEN\n                              --- ELSE\n                              --- DO\n     *48       LH             Reg-d := Scell\n      49       CH             Reg Cond Scell\n      4A       AH             Reg-d + Scell\n      4B       SH             Reg-d - Scell\n     *4C       MH             Reg-d * Scell\n     *50       ST             Icell := Reg   or   Reg-d ... =: Icell\n      54       N              Reg-d AND Icell\n      56       O              Reg-d OR Icell\n      57       X              Reg-d XOR Icell\n     *58       L              Reg-d := Icell   or   Reg-d := @Procname\n      59       C              Reg-d Cond Icell\n      5A       A              Reg-d + Icell\n      5B       S              Reg-d - Icell\n     *5C       M              Reg-d * Icell\n                   Note: Reg-d must be odd numbered\n     *5D       D              Reg-d / Icell\n                   Note: Reg-d must be odd numbered\n      5E       AL             Reg-d ++ Icell\n      5F       SL             Reg-d -- Icell\n     *60       STD            Lcell := Lreg   or   Lreg-d ... =: Lcell\n     *68       LD             Lreg-d := Lcell\n      69       CD             Lreg-d Cond Lcell\n      6A       AD             Lreg-d + Lcell\n      6B       SD             Lreg-d - Lcell\n     *6C       MD             Lreg-d * Lcell\n     *6D       DD             Lreg-d / Lcell\n      6E       AW             Lreg-d ++ Lcell\n      6F       SW             Lreg-d -- Lcell\n     *70       STE            Fcell := Freg   or   Freg-d ... =: Fcell\n     *78       LE             Freg-d := Fcell\n      79       CE             Freg-d Cond Fcell\n      7A       AE             Freg-d + Fcell\n      7B       SE             Freg-d - Fcell\n     *7C       ME             Freg-d * Fcell\n     *7D       DE             Freg-d / Fcell\n      7E       AU             Freg-d ++ Fcell\n      7F       SU             Freg-d -- Fcell\n     *88       SRL            Reg-d SHRL Ivalue  or  Reg\n     *89       SLL            Reg-d SHLL Ivalue  or  Reg\n      8A       SRA            Reg-d SHRA Ivalue  or  Reg\n      8B       SLA            Reg-d SHLA Ivalue  or  Reg\n\n                     Table C.2 - 4-Byte Instructions\n+                    Table C.2 - 4-Byte Instructions\n+                    Table C.2 - 4-Byte Instructions\nB                                  C-3\n1\n                      APPENDIX D.  SYNTACTIC INDEX\n+                     APPENDIX D.  SYNTACTIC INDEX\n+                     APPENDIX D.  SYNTACTIC INDEX\n\n\n Syntactic Entity             Section   Syntactic Entity             Section\n+Syntactic Entity             Section   Syntactic Entity             Section\n+Syntactic Entity             Section   Syntactic Entity             Section\n\n <A-number>                     3.2     <label definition>             4.1\n <alternative condition>        6.5     <letter>                       2.2.1\n <arithmetic operator>          6.2     <limit>                        6.8\n <block>                        4.1     <logical operator>             6.2\n <block body>                   4.1     <monadic operator>             6.1\n <block head>                   4.1     <parameter>                    7.2\n <case cause>                   6.9     <parameter list>               7.2\n <case sequence>                6.9     <procedure declaration>        8.1\n <CASE statement>               6.9     <procedure heading>            8.1\n <character>                    3.4     <procedure identifier>         2.2.1\n <character sequence>           3.4     <procedure statement>          8.2\n <combined condition>           6.5     <program>                      4.1\n <compound condition>           6.5     <relation>                     6.5\n <condition>                    6.5     <repetition list>              5.3\n <declaration>                  4.1     <scale factor>                 3.2\n <digit>                        2.2.1   <segment base declaration>     5.2\n <fill value>                   5.3     <segment base heading>         5.2\n <floating-point number>        3.2     <segment close declaration>    5.2\n <for clause>                   6.8     <separate procedure heading>   8.1\n <FOR statement>                6.8     <shift operator>               6.2\n <format code>                  7.1     <simple K-register assignment> 6.1\n <fractional number>            3.2     <simple procedure heading>     8.1\n <function declaration>         7.1     <simple statement>             4.1\n <function definition>          7.1     <simple T-type>                5.3\n <function designator>          7.2     <stat condition>               6.5\n <function identifier>          2.2.1   <statement>                    4.1\n <GOTO statement>               6.4     <string>                       3.4\n <hexadecimal digit>            3.1     <syn cell value>               5.6\n <hexadecimal value>            3.1     <synonymous cell>              5.5\n <identifier>                   2.2.1   <synonymous integer value>     5.6\n <if clause>                    6.6     <T-cell assignment>            6.3\n <IF statement>                 6.6     <T-cell declaration>           5.3\n <increment>                    6.8     <T-cell designator>            5.4\n <index>                        5.4     <T-cell identifier>            2.2.1\n <instruction code>             7.1     <T-cell synonym>               5.5\n <integer register expression>  5.4     <T-cell value>                 6.3\n <integer value expression>     5.4     <T-primary>                    6.1\n <integer value identifier>     2.2.1   <T-type>                       5.3\n <integer value synonym>        5.6     <T-value>                      3.3\n <item>                         5.3     <true part>                    6.6\n <K-primary>                    6.1     <unsigned A-number>            3.2\n <K-register>                   2.2.1   <while clause>                 6.7\n <K-register assignment>        6.2     <WHILE statement>              6.7\n <K-register synonym>           5.1\nB                                 D-1\n1\n                    APPENDIX E.  SYNTACTIC ENTITIES\n+                   APPENDIX E.  SYNTACTIC ENTITIES\n+                   APPENDIX E.  SYNTACTIC ENTITIES\n\n\n  <A-number> ::= <unsigned A-number> |\n        _ <unsigned A-number>\n  <alternative condition> ::= <stat condition> |\n        <alternative condition> OR <stat condition>\n  <arithmetic operator> ::= + | - | * | / | ++ | --\n  <block body> ::= <block head> |\n        <block body> <statement> ; |\n        <block body> <label definition>\n  <block head> ::= BEGIN | <block head> <declaration> ;\n  <block> ::= <block body> END\n  <byte value> ::= <integer number> X\n  <case clause> ::= CASE <integer register> OF\n  <case sequence> ::= <case clause> BEGIN |\n        <case sequence> <statement> ;\n  <CASE statement> ::= <case sequence> END\n  <character> ::= <any EBCDIC character except \"> | \"\"\n  <character sequence> ::= <character> |\n        <character sequence> <character>\n  <combined condition> ::= <stat condition> |\n        <combined condition> AND <stat condition>\n  <compound condition> ::= <combined condition> |\n        <alternative condition>\n  <condition> ::= <T-cell designator> <relation> <T-cell value> |\n        <byte cell designator> |\n        \u00ac <byte cell designator> |\n        <K-register> <relation> <A-primary> |\n        <integer register> <relation> <string> |\n        <relation> |\n        <integer value> |\n        \u00ac <integer value>\n  <declaration> ::= <T-cell declaration> |\n        <procedure declaration> |\n        <function declaration> |\n        <T-cell synonym> |\n        <K-register synonym> |\n        <integer value synonym> |\n        <segment base declaration> |\n        <segment close declaration>\n  <digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n  <fill value> ::= <T-value> |\n        <string> |\n        @<procedure identifier> |\n        @@<procedure identifier> |\n        @<T-cell designator> |\n        @@<T-cell identifier> |\n        <repetition list> <fill value> )\n  <floating-point number> ::= <fractional number> |\n        <fractional number> ' <scale factor> |\n        <unsigned integer number> ' <scale factor>\n  <for clause> ::= FOR <integer register assignment> STEP <increment>\n        UNTIL <limit> DO\n  <FOR statement> ::= <for clause> <statement>\nB                                 E-1\n1\n  <format code> ::= <integer value>\n  <fractional number> ::= <unsigned integer number> . |\n        <fractional number> <digit>\n  <function declaration> ::= FUNCTION <function definition> |\n        <function declaration> , <function definition>\n  <function definition> ::=\n        <identifier> ( <format code> , <instruction code> )\n  <function designator> ::= <function identifier> |\n        <function identifier> ( <parameter list> )\n  <function identifier> ::= <identifier>\n  <GOTO statement> ::= GOTO <identifier>\n  <hexadecimal digit> ::= <digit> | A | B | C | D | E | F\n  <hexadecimal value> ::= # <hexadecimal digit> |\n        <hexadecimal value> <hexadecimal digit>\n  <identifier> ::= <letter> | <identifier> <letter> | <identifier> <digit>\n  <if clause> ::= IF <compound condition> THEN\n  <IF statement> ::= <if clause> <statement> |\n        <if clause> <true part> <statement>\n  <increment> ::= <integer value>\n  <index> ::= <integer value expression> |\n        <integer register expression> |\n        <integer register expression> + <integer value expression> |\n        <integer register expression> - <integer value expression>\n  <instruction code> ::= <integer value>\n  <integer register expression> ::= <integer register> |\n        <integer register> + <integer register>\n  <integer value expression> ::= <integer value> |\n        <integer value expression> + <integer value> |\n        <integer value expression> - <integer value>\n  <integer value identifier> ::= <identifier>\n  <integer value synonym> ::=\n        EQUATE <identifier> <synonymous integer value> |\n        EQUATE <identifier> SYN <string> |\n        EQUATE <identifier> SYN <register name> |\n        <integer value synonym> , <identifier> <synonymous integer value>\n  <integer value> ::= <integer number> |\n        <hexadecimal value> |\n        <integer value identifier>\n  <item> ::= <identifier> | <identifier> = <fill value>\n  <K-primary> ::= <K-register>\n  <K-register assignment> ::= <simple K-register assignment> |\n        <K-register assignment> <arithmetic operator> <A-primary> |\n        <K-register assignment> =: <K-register> |\n        <K-register assignment> =: <A-cell designator> |\n        <integer register assignment> <logical operator> <integer primary> |\n        <integer register assignment> <shift operator> <integer value> |\n        <integer register assignment> <shift operator> <integer register>\n  <K-register synonym> ::=\n        <simple K-type> REGISTER <identifier> SYN <K-register> |\n        <K-register synonym> , <identifier> SYN <K-register>\n  <K-register> ::= <identifier>\n  <label definition> ::= <identifier> :\n  <letter> ::= A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z\n  <limit> ::= <integer primary> | <short integer primary>\nB                                 E-2\n1\n  <logical operator> ::= AND | OR | XOR\n  <long real value> ::= <long real number> |\n        <hexadecimal value> L\n  <monadic operator> ::= ABS | NEG | NEG ABS\n  <parameter list> ::= <parameter> | <parameter list> , <parameter>\n  <parameter> ::= <T-value> |\n        <T-cell designator> |\n        <K-register> |\n        <string> |\n        <function designator>\n  <procedure declaration> ::= <procedure heading> ; <statement>\n  <procedure heading> ::= <simple procedure heading> |\n        COMMON <simple procedure heading> |\n        <separate procedure heading> |\n        <separate procedure heading> BASE <integer register>\n  <procedure identifier> ::= <identifier>\n  <procedure statement> ::= <procedure identifier> |\n        <procedure identifier> ( <integer register> )\n  <program> ::= <block> . |\n        GLOBAL <simple procedure heading> ; <statement> . |\n        GLOBAL <simple procedure heading> BASE <integer register> ; <statement> .\n  <real value> ::= <real number> |\n        <hexadecimal value> R\n  <relation> ::= = | \u00ac= | < | <= | >= | >\n  <repetition list> ::= ( |\n        <integer value> ( |\n        <repetition list> <fill value> ,\n  <scale factor> ::= <integer number>\n  <segment base declaration> ::=\n        <segment base heading> BASE <integer register>\n  <segment base heading> ::= SEGMENT |\n        GLOBAL DATA <identifier> |\n        EXTERNAL DATA <identifier> |\n        COMMON DATA <identifier> |\n        COMMON |\n        DUMMY\n  <segment close declaration> ::= CLOSE BASE\n  <separate procedure heading> ::=\n        SEGMENT <simple procedure heading> |\n        GLOBAL <simple procedure heading> |\n        EXTERNAL <simple procedure heading>\n  <shift operator> ::= SHLL | SHLA | SHRL | SHRA\n  <short integer value> ::= <short integer number> |\n        <hexadecimal value> S\n  <simple byte type> ::= BYTE | CHARACTER\n  <simple integer type> ::= INTEGER | LOGICAL\n  <simple K-register assignment> ::=\n        <K-register> := <A-primary> |\n        <K-register> := <monadic operator> <A-primary> |\n        <integer register> := <string> |\n        <integer register> := @ <T-cell designator> |\n        <integer register> := @ <procedure identifier>\n  <simple long real type> ::= LONG REAL\nB                                 E-3\n1\n  <simple procedure heading> ::=\n        PROCEDURE <identifier> ( <integer register> )\n  <simple real type> ::= REAL\n  <simple short integer type> ::= SHORT INTEGER\n  <simple statement> ::= <block> |\n        <K-register assignment> |\n        <T-cell assignment> |\n        <function designator> |\n        <procedure statement> |\n        <GOTO statement> |\n        <CASE statement> |\n        NULL\n  <stat condition> ::= <condition> |\n        <statement> ; <condition>\n  <statement> ::= <simple statement> |\n        <IF statement> |\n        <WHILE statement> |\n        <FOR statement>\n  <string> ::= \" <character sequence> \" |\n        <hexadecimal value> X\n  <syn cell value> ::= <T-cell designator> - <T-cell designator>\n  <synonymous cell> ::= SYN <T-cell designator> | SYN <integer value>\n  <synonymous integer value> ::= SYN <integer value> |\n        SYN <monadic operator> <integer value> |\n        SYN <syn cell value> |\n        <synonymous integer value> <arithmetic operator> <integer value> |\n        <synonymous integer value> <logical operator> <integer value> |\n        <synonymous integer value> <shift operator> <integer value>\n  <T-cell assignment> ::= <A-cell designator> := <K-register> |\n        <T-cell designator> := <T-cell value> |\n        <T-cell assignment> <logical operator> <T-cell value>\n  <T-cell declaration> ::= <T-type> <item> | <T-cell declaration> , <item>\n  <T-cell designator> ::= <T-cell identifier> |\n        <T-cell identifier> ( <index> / <integer value expression> ) |\n        <T-cell identifier> ( <index> )\n  <T-cell identifier> ::= <identifier>\n  <T-cell synonym> ::=\n        <T-type> <identifier> <synonymous cell> |\n        <T-cell synonym> , <identifier> <synonymous cell>\n  <T-cell value> ::= <T-cell designator> |\n        <T-value> |\n        <string>\n  <T-primary> ::= <T-value> | <T-cell designator>\n  <T-type> ::= <simple T-type> | ARRAY <integer value> <simple T-type>\n  <true part> ::= <simple statement> ELSE\n  <unsigned integer number> ::= <digit> |\n        <unsigned integer number> <digit>\n  <unsigned long real number> ::= <floating-point number> L |\n        <unsigned integer number> L\n  <unsigned real number> ::= <floating-point number> |\n        <unsigned integer number> R\n  <unsigned short integer number> ::= <unsigned integer number> S\n  <while clause> ::= WHILE <compound condition> DO\n  <WHILE statement> ::= <while clause> <statement>\nB                                 E-4\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT545/CBT.V500.FILE545.PDS/MANUAL.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT545/CBT.V500.FILE545.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}