{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011842000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 293930, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE364.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE364.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x06\\x04'", "DS1TRBAL": "b'\\xad\\xda'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\xaa\\x00\\x0e\\x02\\xab\\x00\\x05\\x00\\x07'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x07o\\x01\\x00$?\\x18V\\x002\\x002\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-03-17T00:00:00", "modifydate": "2000-08-30T18:56:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "WSBG"}, "text": "Subject: CONTROL CARD SUBSYSTEM (CCSS)\nDate: Wed, 17 Mar 1999 12:38:15 -0500\nFrom: LeeWarriner <cwarriner@thehartford.com>\nTo: \" - (052)sbgolob(a)attglobal.net\" <sbgolob@attglobal.net>\n\n     Hi again Sam,\n\nWhat follows is from the original question from Bill Lee that\nprompted me to send the CCSS Source to you for the CT tape.\n\nIt would/should probably be added to the Documentation on this.\n\nPersonally I would just code //SYSIN DD DSN=XX.XX(MEM) for the\ncontrol cards and put the control cards in a dataset.\n\n                         Lee\n\nSubject: CONTROL CARD SUBSYSTEM (CCSS)\nDate:         Tue, 16 Mar 1999 16:00:22 -0500\nFrom:         Bill Lee <Bill.Lee@JMFAMILY.COM>\nSubject:      Control Card Subsystem (CCSS)\nTo:           IBM-MAIN@BAMA.UA.EDU\n\nAt one time there was something on one of the SHARE tapes called\nControl Card Subsystem that would allow you to use control cards as\nJCL parameters instead of using a DD *. In other words, instead of\ncoding:\n\n//SYSIN DD *\nCONTROL CARD #1\nCONTROL CARD #2\nCONTROL CARD #3\n/*\n\nyou would code:\n\n//SYSIN DD SUBSYS=(CCSS,\n//      'CONTROL CARD #1',\n//      'CONTROL CARD #2',\n//     'CONTROL CARD #3')\n\nThe advantage is that you could then code your control cards within\na cataloged procedure and avoid using an override. Does anyone know\nwhere I can obtain a copy of CCSS?\n\nThanks in advance for your help,\n\nBill\n\n     -\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$LINK": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x07o\\x00\\x99\\x07o\\x12Y\\x00B\\x00:\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-03-17T00:00:00", "modifydate": "1999-03-17T12:59:00", "lines": 66, "newlines": 58, "modlines": 0, "user": "SBGOLOB"}, "text": "\nThese are linkage editor control cards which correspond to\nactual installed (and working) load modules.  The CCSS load\nmodule goes into LPA.  The others go into the Link List.\nOf course, you can assemble them from the source.  This is\nhow they go together.  (Tested and working on OS/390 1.3 - JES3)\nSee member DOC on IEFSSNxx table entries needed.\n\n\n** MAP      CCSS\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,RENT,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.CCSS.LIB\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.CCSS.LIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(CCSS)\n ORDER   CCSSVT,CCCI0000,CCAG0000,CCDA0000,SSIO0000\n MODE    RMODE(24),AMODE(31)\n ENTRY   CCSSVT\n NAME    CCSS(R)\n\n** MAP      CCSSINIT\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,RENT,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.CCSS.LIB\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.CCSS.LIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(MTSSA00)\n ORDER   TSSACTV\n MODE    RMODE(24),AMODE(31)\n ENTRY   TSSACTV\n ALIAS   CCSSINIT(TSSACTV)\n NAME    MTSSA00(R)\n\n** MAP      MTSS\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,RENT,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.CCSS.LIB\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.CCSS.LIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(MTSS)\n ORDER   MTSSVT,TSSNAMES\n MODE    RMODE(24),AMODE(31)\n ENTRY   MTSSVT\n NAME    MTSS(R)\n\n** MAP      MTSSA00\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,RENT,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.CCSS.LIB\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.CCSS.LIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(MTSSA00)\n ORDER   TSSACTV\n MODE    RMODE(24),AMODE(31)\n ENTRY   TSSACTV\n ALIAS   CCSSINIT(TSSACTV)\n NAME    MTSSA00(R)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CCSS": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x07\\x7f\\x00\\x99\\x07\\x7f#$\\x04\\xe3\\x04\\xe3\\x00\\x00\\xc1`\\xc6\\xc9\\xc5\\xd3\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-03-18T00:00:00", "modifydate": "1999-03-18T23:24:00", "lines": 1251, "newlines": 1251, "modlines": 0, "user": "A-FIELD"}, "text": "     TITLE 'CCSS SSVT '\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        CCSS - CONTROL CARD SUBSYSTEM                                *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        SUBSYTEM SSVT AND FUNCTIONAL ROUTINES                        *\n*                                                                     *\n*                                                                     *\n*        MODULE IS LPA RESIDENT RE-ENTRANT AND REFRESHABLE            *\n*                                                                     *\n*        MODIFICATIONS:                                               *\n*        3/5/84 - FUNCTION DEPENDENT PORTION OF SSOB ADDRESSED        *\n*                 VIA SSOBINDV.  SHOULD AVOID REASSEMBLY FOR XA       *\n*        5/16/88 - CORRECT INITIALIZATION OF SSDTRECL FOR CHKPT    @Q1*\n*        5/17/88 - SET ADDRESSING MODE TO 31 BIT USING BSM.  PUT   @Q2*\n*                 OFF ACCESSING SWA CONTROL BLOCKS (SSWA, JFCB)    @Q2*\n*                 USING SWAREQ UNTIL IT BECOMES A PROBLEM          @Q2*\n*        11/22/88 - VALIDATE THE JFCB RECFM, LRECL, AND BLKSIZE    @Q3*\n*                 AT DATASET ALLOCATION                            @Q3*\n*        10/29/89 - GETMAIN STORAGE WITH PROPER LOC PARAMETER      @Q4*\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*        SUBSYSTEM SSVT                                               *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n*\nCCSSVT   CSECT\nCCSSVT   AMODE 31                                                   @Q2\nCCSSVT   RMODE 24                                                   @Q2\n         DC    H'0'\n         DC    AL2(FUNC)\n         DC    AL1(F001),AL1(F002),AL1(F003),AL1(F004)\n         DC    AL1(F005),AL1(F006),AL1(F007),AL1(F008)\n         DC    AL1(F009),AL1(F010),AL1(F011),AL1(F012)\n         DC    AL1(F013),AL1(F014),AL1(F015),AL1(F016)\n         DC    AL1(F017),AL1(F018),AL1(F019),AL1(F020)\n         DC    AL1(F021),AL1(F022),AL1(F023),AL1(F024)\n         DC    AL1(F025),AL1(F026),AL1(F027),AL1(F028)\n         DC    AL1(F029),AL1(F030),AL1(F031),AL1(F032)\n         DC    AL1(F033),AL1(F034),AL1(F035),AL1(F036)\n         DC    AL1(F037),AL1(F038),AL1(F039),X'00'\n         DC    216X'00'\nCCCI     DC    A(X'80000000'+CCCI0000)\nCCAG     DC    A(X'80000000'+CCAG0000)\nCCDA     DC    A(X'80000000'+CCDA0000)\n         LTORG\n*\n*        'B' INDICATES BROADCAST FUNCTION\n*\nFUNC  EQU   X'0003'\nF001  EQU   X'00'      1 - PROCESS SYSOUT DATASET\nF002  EQU   X'00'      2 - CANCEL A JOB\nF003  EQU   X'00'      3 - FIND THE STATUS OF A JOB\nF004  EQU   X'00'   B  4 - NOTIFY: END OF TASK\nF005  EQU   X'00'      5 - JOB SELECT\nF006  EQU   X'00'      6 - ALLOC SYSIN/SYSOUT/INTRDR\nF007  EQU   X'00'      7 - UNALLOCATE SYSIN/SYSOUT/INTRDR\nF008  EQU   X'00'   B  8 - NOTIFY: END OF ADDR SPACE\nF009  EQU   X'00'   B  9 - NOTIFY: WTO MESSAGE\nF010  EQU   X'00'   B 10 - NOTIFY: OPERATOR COMMAND\nF011  EQU   X'00'     11 - VALIDATE REMOTE DEST USERID\nF012  EQU   X'00'     12 - NOTIFY: JOB TERM\nF013  EQU   X'00'     13 - RE-ENQUEUE JOB\nF014  EQU   X'00'   B 14 - NOTIFY: DELETE OPERATOR\nF015  EQU   X'00'     15 - VERIFY SUBSYSTEM NAME\nF016  EQU   X'03'     16 - OPEN SUBSYSTEM DATASET\nF017  EQU   X'03'     17 - CLOSE SUBSYSTEM DATASET\nF018  EQU   X'03'     18 - CHECKPOINT SUBSTSTEM DATASET\nF019  EQU   X'03'     19 - RESTART A SUBSYSTEM DATASET\nF020  EQU   X'00'     20 - REQUEST JOBID\nF021  EQU   X'00'     21 - RETURN JOBID\nF022  EQU   X'00'     22 - NOTIFY: STEP INITIATION\nF023  EQU   X'00'     23 - DYNAMIC ALLOCATION\nF024  EQU   X'00'     24 - COMMON ALLOCATION\nF025  EQU   X'00'     25 - COMMON UNALLOCATION\nF026  EQU   X'00'     26 - CHANGE DDNAME\nF027  EQU   X'00'     27 - CHANGE ENQ USE ATTRIBUTE\nF028  EQU   X'00'     28 - DDR DEVICE CANDIDATE SELECT\nF029  EQU   X'00'     29 - DDR DEVICE CANDIDATE VERIFY\nF030  EQU   X'00'     30 - DDR UCB SWAP\nF031  EQU   X'00'     31 - DDR SWAP COMPLETION\nF032  EQU   X'00'   B 32 - FAILING START\nF033  EQU   X'00'     33 - NOTIFY: CONSOLE SWITCH\nF034  EQU   X'00'     34 - NOTIFY: WTL MESSAGE\nF035  EQU   X'00'     35 - MSS VOLUME EXIT CONTROL\nF036  EQU   X'00'     36 - MSSC MESSAGE TASK-MOUNT EQUALIZATION\nF037  EQU   X'00'     37 - MSS OPEN/EOV\nF038  EQU   X'01'     38 - CONVERTER SUBSYS KEYWORD\nF039  EQU   X'02'     39 - GROUP ALLOCATION\n         TITLE 'MISCELLANEOUS DSECTS'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECT FOR SUBSYSTEM DATASET I/O BLOCK                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CREATED BY OPEN                                              *\n*                                                                     *\n*        SUBPOOL 230 - KEY 5                                          *\n*                                                                     *\n*        DESCRIBES THE 'INTERNAL' DATASET  IN TERMS OF                *\n*        STARTING ADDRESS, ENDING ADDRESS, HIGH RBA,                  *\n*        NUMBER OF RECORDS, ETC..                                     *\n*        REFERENCED BY I/O ROUTINES.                                  *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nSSDSIOB  DSECT\nSSDID    DS    CL4    'SSDS'\nSSDSPL   DS    F      SUBPOOL AND LENGTH\nSPSSDS   EQU   230\nSSDBGNA  DS    F      A(PHYSICAL START OF DATASET)\nSSDPEOD  DS    F      A(PHYSICAL EOD) (PTR TO LAST BYTE+1)\nSSDTRECP DS    F      TOTAL NUMBER OF PHYSICAL RECORDS\nSSDTRECL DS    F      TOTAL NUMBER OF LOGICAL RECORDS\nSSDLRAD  DS    F      A(LOWEST LOGICAL RECORD)\nSSDHRAD  DS    F      A(HIGHEST LOGICAL RECORD)\nSSDHRRBA DS    F      RBA OF HIGHEST LOGICAL RECORD\nSSDRECFM DS    BL1    RECFM FROM JFCB\nSSDSIOBL EQU   *-SSDSIOB\n         EJECT\n   PRINT NOGEN\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECT FOR SSCT                                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         IEFJSCVT\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECT FOR SSOB                                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         IEFJSSOB (CI,AG,DA),CONTIG=NO\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECT FOR SSIB                                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         IEFJSSIB\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECT FOR SSARB                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         IEFSSARB\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECT FOR SSWA                                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         IEFJSSWA\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECT FOR DEB                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         IEZDEB LIST=YES\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECT FOR JFCB                                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\nJFCB     DSECT\n         IEFJFCBN LIST=YES\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECT FOR ACB                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         IFGACB\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECT FOR RPL                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         IFGRPL\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        RECORD MANAGEMENT RETURN CODES                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         IDARMRCD\n         EJECT\n         PRINT GEN\n*---------------------------------------------------------------------*\n*                                                                     *\n*        MISCELLANEOUS EQUATES                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\nCONTREC  EQU  X'014E'     CONTINUATION RECORD: LENGTH=1, CHAR='+'\nR0       EQU       0\nR1       EQU       1\nR2       EQU       2\nR3       EQU       3\nR4       EQU       4\nR5       EQU       5\nR6       EQU       6\nR7       EQU       7\nR8       EQU       8\nR9       EQU       9\nR10      EQU      10\nR11      EQU      11\nR12      EQU      12\nR13      EQU      13\nR14      EQU      14\nR15      EQU      15\n         TITLE 'NO-OP EXIT'\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        SUBSYSTEM FUNCTIONAL ROUTINES:                               *\n*                                                                     *\n*                                                                     *\n*        UPON ENTRY FROM IEFSSREQ                                     *\n*                                                                     *\n*             R0  =  A(SSCVT)                                         *\n*             R1  =  A(SSOB)                                          *\n*             R15 =  ENTRY POINT                                      *\n*             R2-R12, R13 = CALLER'S (OF IEFSSREQ) REGISTERS          *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         TITLE 'CONVERTER SUBSYS EXIT - CCCI'\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        CONVERTER SUBSYS KEYWORD EXIT - CCCI                         *\n*                                                                     *\n*        SCHEDULER KEY ONE                                            *\n*                                                                     *\n*        VALIDATE THE USE OF SUBSYSTEM CONTINUATION CHARACTER         *\n*        INSURE THAT THERE ARE NO NULL PARAMETERS                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nCCCI0000 CSECT\nCCCI0000 AMODE 31                                                   @Q2\nCCCI0000 RMODE 24                                                   @Q2\n         ENTRY CCCI                    ESTABLISH ENTRY POINT      @R92A\n         USING *,R15                   SET TEMP BASE              @R92A\n         B     CCCI0001                  BRANCH AROUND CSECT ID\n         DC    C'CCCI &SYSDATE'\nCCCI0001 DS    0H\n         STM   R14,R12,12(R13)           SAVE REGISTERS           @R92A\n         DROP  R15                                                @R92A\n         LR    R12,R15                 LOAD BASE                  @R92A\n         USING CCCI0000,R12            DECLARE BASE               @R92A\n         LR    R9,R1                     SAVE PTR TO PARM ADDRESS\n         GETMAIN RU,LV=CCCIWKL,SP=230,LOC=ANY  GET WORKING STORAGE  @Q4\n         XC    0(CCCIWKL,R1),0(R1)       CLEAR WORKING STORAGE\n         ST    R13,4(,R1)                CHAIN THE\n         ST    R1,8(,R13)                   SAVE AREAS\n         LR    R13,R1                    NEW SAVE AREA\n         USING CCCIWK,R13                BASE FOR WORK AREA\n         MVC   CCCIID,=C' CCCIWK '       LABEL WORKAREA\n         ST    R9,CCCIPRMP               SAVE R1 ENTRY PARM\n         SPACE\n         USING SSOB,R9                   SSOB ADDRESSIBILITY\n         XC    SSOBRETN,SSOBRETN         CLEAR RETURN CODE IN SSOB\n         L     R10,SSOBINDV              GET A(SSCI)\n         USING SSCIBGN,R10               SSCI ADDRESSIBILITY\n         EJECT\n*\n*        SET UP VALIDATION LOOPS\n*\n         LH    R5,SSCINPRM               R5 = NUMBER OF PARM PAIRS\n         SLR   R3,R3                     CLEAR INDEX REG 3\n         LA    R4,1                      INCREMENT = 1\n         L     R1,SSCISUBS               LOAD POINTER TO PARM PAIRS\n         USING SSWAIFLD,R1               ADDRESSIBILITY\n         BXH   R3,R4,CCCIEXIT            EXIT IF NO PARMS\n         SLR   R2,R2                     CLEAR FOR PARM LENGTH\n*\n*        IF CONTINUATION CHARACTER - ERROR\n*\nCCCI0010 DS    0H\n         CLC   CONTINU,SSWAIFLD          CONTINUE PARM?\n         BE    CCIE0010                  ...YES, ERROR\n*\n*        LOOK FOR PARM - IF NO MORE THEN EXIT\n*\nCCCI0020 DS    0H\n         ICM   R2,B'0001',SSWAILEN       GET PARM LENGTH\n         BZ    CCIE0020                  ...ERROR IF NULL PARM\n         BXH   R3,R4,CCCIEXIT            EXIT IF NO MORE PARMS\n         LA    R1,SSWAIPRM(R2)           POINT TO NEXT PARM\n         CLC   CONTINU,SSWAIFLD          CONTINUE PARM?\n         BNE   CCCI0020                  ...NO, NEXT PARM\n*\n*        FOUND CONTINUE CHAR - CANNOT BE LAST OR FOLLOWED BY ANOTHER\n*\n         BXH   R3,R4,CCIE0010            ...YES, ERROR IF LAST PARM\n         ICM   R2,B'0001',SSWAILEN       GET PARM LENGTH\n         LA    R1,SSWAIPRM(R2)           POINT TO NEXT PARM\n         B     CCCI0010                  CONTINUE CANNOT BE NEXT\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        EXITS                                                        *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        WITH ERROR                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\nCCIE0010 DS    0H\n         LA    R0,SSCISYNT               RET CODE = FATAL SYNTAX ERROR\n         LA    R14,CIEM0010              GET A(ERROR MESSAGE)\n         LA    R15,CIEL0010              SET MESSAGE LENGTH\n         B     CCIEMSG                   PUT OUT MESSAGE\n         SPACE\nCCIE0020 DS    0H\n         LA    R0,SSCISYNT               RET CODE = FATAL SYNTAX ERROR\n         LA    R14,CIEM0020              GET A(ERROR MESSAGE)\n         LA    R15,CIEL0020              SET MESSAGE LENGTH\n         SPACE\nCCIEMSG  DS    0H\n         ST    R0,SSOBRETN               SET SSOB RETURN CODE\n         LH    R1,SSCIMLEN               R1= MESSAGE AREA TEXT LENGTH\n         L     R2,SSCIMPTR               GET A(MESSAGE AREA)\n         CR    R15,R1                    COMPARE: L'MSG TO L'AREA\n         BNH   *+6                       IF L'MSG HIGHER...\n         LR    R15,R1                    ...USE AREA LENGTH\n         STH   R15,0(,R2)                SET MESSAGE LENGTH\n         BCTR  R15,0                     REDUCE FOR EXECUTE\n         EX    R15,CCIEMVC               MOVE MESSAGE\n         B     CCCIEXIT                  EXIT\n         SPACE\nCCIEMVC  MVC   2(0,R2),0(R14)            EXECUTED: MOVE MSG TEXT\n         SPACE 2\n*---------------------------------------------------------------------*\n*                                                                     *\n*        EXIT - FINAL                                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\nCCCIEXIT DS    0H\n         L     R9,CCCISAVE+4             GET A(CALLER'S SAVE)\n         FREEMAIN RU,LV=CCCIWKL,A=(13),SP=230\n         SLR   R15,R15                   CLEAR AS RETURN CODE\n         LR    R13,R9                    CALLER'S SAVE AREA PTR\n         L     R14,12(0,R13)             RESTORE RETURN ADDR\n         LM    R0,R12,20(R13)            AND THE CALLERS REGS\n         BSM   0,R14                   RETURN IN CORRECT AMODE      @Q2\n         EJECT\n*---------------------------------------------------------------------*\n*        CONVERTER EXIT DATA AREA                                     *\n*---------------------------------------------------------------------*\n         SPACE\nCONTINU  DC    AL2(CONTREC)\n         SPACE\nCIEM0010 DC    C'CCSS3801E - INVALID USE OF SUBSYSTEM '\n         DC    C'CONTINUATION CHARACTER.'\nCIEL0010 EQU   *-CIEM0010\n         SPACE 3\nCIEM0020 DC    C'CCSS3802E - SUBSYSTEM PARAMETER IMPLIED '\n         DC    C'BUT NOT FOUND.'\nCIEL0020 EQU   *-CIEM0020\n         LTORG\n*---------------------------------------------------------------------*\n*        DSECT FOR CONVERTER EXIT WORKING STORAGE                     *\n*---------------------------------------------------------------------*\n         SPACE\nCCCIWK   DSECT\nCCCISAVE DS    18F                       REGISTER SAVE AREA\nCCCIID   DS    CL8                       WORKAREA LABEL\nCCCIPRMP DS    F                         A(CALLER'S PARM)\nCCCIWKL  EQU   *-CCCIWK\n         TITLE 'GROUP ALLOCATION - CCAG'\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        GROUP ALLOCATION EXIT - AG                                   *\n*                                                                     *\n*        SCHEDULER KEY ONE                                            *\n*                                                                     *\n*        PASS A(SSWA) TO OTHER EXITS VIA SSAGSSCM                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nCCAG0000 CSECT\nCCAG0000 AMODE 31                                                   @Q2\nCCAG0000 RMODE 24                                                   @Q2\n         ENTRY CCAG                    ESTABLISH ENTRY POINT      @R92A\n         USING *,R15                   SET TEMP BASE              @R92A\n         B     CCAG0001                  BRANCH AROUND CSECT ID\n         DC    C'CCAG &SYSDATE'\nCCAG0001 DS    0H\n         STM   R14,R12,12(R13)           SAVE REGISTERS           @R92A\n         DROP  R15                                                @R92A\n         LR    R12,R15                 LOAD BASE                  @R92A\n         USING CCAG0000,R12            DECLARE BASE               @R92A\n         LR    R9,R1                     SAVE PTR TO PARM ADDRESS\n         LA    R3,CCAGWKL                R3 = LENGTH WKING STORAGE\n         GETMAIN RU,LV=(3),SP=230,LOC=ANY   GET WORKING STORAGE     @Q3\n         LR    R2,R1                     R2 = A(WORKING STORAGE)\n         SLR   R14,R14                   NO SOURCE\n         SLR   R15,R15                   NO SOURCE LENGTH\n         MVCL  R2,R14                    CLEAR STORAGE TO ZEROS\n         ST    R13,4(,R1)                CHAIN THE\n         ST    R1,8(,R13)                   SAVE AREAS\n         LR    R13,R1                    NEW SAVE AREA\n         USING CCAGWK,R13                BASE FOR WORK AREA\n         MVC   CCAGID,=C' CCAGWK '       LABEL WORKAREA\n         ST    R9,CCAGPRMP               SAVE R1 ENTRY PARM\n         SPACE\n         USING SSOB,R9                   SSOB ADDRESSIBILITY\n         XC    SSOBRETN,SSOBRETN         CLEAR RETURN CODE IN SSOB\n         L     R10,SSOBINDV              A(SSAG)\n         USING SSAGBGN,R10               SSAG ADDRESSIBILITY\n         L     R8,SSAGARBP               A(SSARB)\n         USING SSARB,R8                  SSARB ADDRESSIBILITY\n         EJECT\n*\n*        CLEAR REGISTERS FOR LATER USE\n*\n         SLR   R2,R2                     CLEAR FOR PARM LENGTH\n         SLR   R6,R6                     CLEAR RECORD LENGTH\n         SLR   R7,R7                     CLEAR MAX RECORD LENGTH\n*\n*\n*        IF DYNAMIC ALLOCATION VALIDATE SUBSYSTEM PARAMETERS,\n*           I.E., USE OF CONTINUATION CHARACTER, ABSENCE OF\n*           NULL PARAMETERS.\n*        IF NOT DYNAMIC ALLOCATION THERE IS NO NEED. THE\n*           CONVERTER EXIT HAS ALREADY VALIDATED THEM.\n*\n*\n*\n*        SET UP VALIDATION LOOPS\n*\n         TM    SSAGFLGS,SSAGWAIT         IF OK TO WAIT FLAG ON...\n         BO    CCAG0050                  ...BRANCH, NOT DYNALLOC\n         L     R1,SSAGSSWA               A(SSWA)\n         USING SSWA,R1                   SSWA ADDRESSIBILTY\n         SR    R5,R5                     CLEAR REG 5\n         ICM   R5,B'0011',SSWAPRNO       GET NUM LEN/PARM PAIRS\n         BZ    CCAG0050                  ...NONE - EMPTY DATASET\n         LA    R3,1                      INDEX = 1\n         LA    R4,1                      INCREMENT = 1\n         LA    R1,SSWAPREN               POINT TO PARM PAIRS\n         USING SSWAIFLD,R1               ADDRESSIBILITY\n         SLR   R2,R2                     CLEAR FOR PARM LENGTH\n         SLR   R6,R6                     CLEAR RECORD LENGTH\n         SLR   R7,R7                     CLEAR MAX RECORD LENGTH\n*\n*        IF CONTINUATION CHARACTER - ERROR\n*\nCCAG0010 DS    0H\n         CLC   CONTNU,SSWAIFLD           CONTINUE PARM?\n         BE    CCAE0010                  ...YES, ERROR\n*\n*        LOOK FOR PARM - IF NO MORE THEN EXIT LOOP\n*\nCCAG0020 DS    0H\n         ICM   R2,B'0001',SSWAILEN       GET PARM LENGTH\n         BZ    CCAE0020                  ...ERROR IF NULL PARM\n         ALR   R6,R2                     ACCUMULATE RECORD LENGTH\n         BXH   R3,R4,CCAG0050            EXIT IF NO MORE PARMS\n         LA    R1,SSWAIPRM(R2)           POINT TO NEXT PARM\n         CLC   CONTNU,SSWAIFLD           CONTINUE PARM?\n         BE    CCAG0030                  ...YES, CHECK VALIDITY\n         CLR   R6,R7                     CURRENT LONGER THAN MAX ?\n         BL    CCAG0025                  ...NO, DON'T SWITCH\n         LR    R7,R6                     LOAD NEW MAX LENGTH\nCCAG0025 SLR   R6,R6                     CLEAR ACCUMULATOR\n         B     CCAG0020                  LOOP FOR NEXT\n*\n*        FOUND CONTINUE CHAR - CANNOT BE LAST OR FOLLOWED BY ANOTHER\n*\nCCAG0030 BXH   R3,R4,CCAE0010            ...YES, ERROR IF LAST PARM\n         ICM   R2,B'0001',SSWAILEN       GET PARM LENGTH\n         LA    R1,SSWAIPRM(R2)           POINT TO NEXT PARM\n         B     CCAG0010                  CONTINUE CANNOT BE NEXT\n         EJECT\n*\n*\n*\n*        FOR ALL ALLOCATIONS:\n*\n*        PASS A(SSWA) TO SUBSEQUENT EXITS VIA SUBSYSTEM COMMUNICATIONS\n*        POINTER IN SSARB.\n*\n*        IF RECFM NOT SPECIFIED BY USER MODIFY THE JFCB TO REFLECT\n*        A DEFAULT OF FIXED.\n*\n*        SET DEFAULT RECFM TO FIXED, BLOCKED                        @Q3\n*        SET DEFAULT LRECL, BLOCKSIZE TO 80                         @Q3\n*\n*\n         USING JFCB,R2                   JFCB ADDRESSIBILITY        @Q3\nCCAG0050 DS    0H\n         MVC   SSAGSSCM,SSAGSSWA         PASS A(SSWA) VIA SSCM/DSAB\n         L     R2,SSAGJFCB               GET A(JFCB) FROM SSARB\n         CLI   JFCRECFM,0                RECFM SPECIFIED?           @Q3\n         BNE   CCAG00501                 ...YES, DON'T SET DEFAULT  @Q3\n         MVI   JFCRECFM,JFCFIX+JFCRFB    ...NO, SET DEFAULT         @Q3\nCCAG00501 DS 0H                                                     @Q3\n         SLR   R0,R0                     ZIP FOR COMPARE            @Q3\n         LA    R1,80                     DEFAULT LRECL, BLKSIZE     @Q3\n         CLR   R7,R1                   4 COMPARE DEFAULTS\n         BL    CCAG0050X               4 SKIP\n         LR    R1,R7                   4 LOAD MAX DEFAULT\nCCAG0050X DS   0H\n         TM    JFCRECFM,JFCUND           RECFM = U ?                @Q3\n         BO    CCAG00503                 .. YES, BR                 @Q3\n         TM    JFCRECFM,JFCVAR           RECFM=V ?                  @Q3\n         BO    CCAG00502                 .. YES, BR                 @Q3\n         OI    JFCRECFM,JFCFIX+JFCRFB    SET DFLT TO FIXED BLOCKED  @Q3\n         B     CCAG00503                                            @Q3\n         SPACE\nCCAG00502 DS   0H                                                   @Q3\n         LA    R1,4(,R1)                 VARIABLE, LRECL <- LRECL+4 @Q3\nCCAG00503 DS   0H                                                   @Q3\n         CH    R0,JFCLRECL               LRECL = 0 ?                @Q3\n         BNE   CCAG00504                 .. NO, USE IT              @Q3\n         STH   R1,JFCLRECL               .. ELSE SET DEFAULT        @Q3\n         SPACE\nCCAG00504 DS   0H                                                   @Q3\n         CH    R0,JFCBLKSI               BLKSIZE = 0 ?              @Q3\n         BNE   CCAG0055                  .. NO, DONE                @Q3\n         MVC   JFCBLKSI,JFCLRECL         .. ELSE BLKSI = LRECL      @Q3\n         DROP  R2                        DROP JFCB ADDRESSIBILITY\nCCAG0055 DS    0H\n         ICM   R8,B'1111',SSAGNRBP       ANOTHER SSARB?\n         BNZ   CCAG0050                  ...YES, PROCESS IT\n         B     CCAGEXIT                  ...NO, EXIT\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        ERROR PROCESSING                                             *\n*                                                                     *\n*                                                                     *\n*        THE ONLY ERRORS ARE ASSOCIATED WITH DYNAMICALLY              *\n*        ALLOCATED DATASETS: NULL PARAMETERS OR INVALID               *\n*        USE OF CONTINUATION CHARACTER.                               *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nCCAE0010 DS    0H                        INVALID CONTINUE\n         LA    R0,1                      LOAD INFO CODE\n         LA    R1,AGEM0010               LOAD WTO LIST ADDRESS\n         LA    R2,AGEL0010               LOAD WTO LIST LENGTH\n         LA    R3,AGED0010               LOAD OFFSET TO DDNAME\n         B     CCAEDMSG                  PUT OUT DYNALLOC ERR MESSAGE\n         SPACE\nCCAE0020 DS    0H                        NULL PARM\n         LA    R0,2                      LOAD INFO CODE\n         LA    R1,AGEM0020               LOAD WTO LIST ADDRESS\n         LA    R2,AGEL0020               LOAD WTO LIST LENGTH\n         LA    R3,AGED0020               LOAD OFFSET TO DDNAME\n         SPACE\nCCAEDMSG DS    0H\n         STH   R0,SSAGRBIC               SET DYNALLOC INFO CODE\n         LA    R0,SSAGDDER               INDICATE REQUEST BLOCK ERROR\n         ST    R0,SSOBRETN               IN SSOBRETN\n         LA    R0,12                     INDICATE PARAMETER ERROR\n         STH   R0,SSAGRBEC               SSAG\n         BCTR  R2,0                      REDUCE L'LIST FOR EXECUTE\n         EX    R2,CCAEMSG1               MOVE MSG LIST TO WORKAREA\n         L     R2,SSAGDDNM               GET A(DDNAME)\n         LA    R1,CCAGMSG                GET A(MSG WORKAREA)\n         AR    R1,R3                     ADD DDNAME OFFSET\n         MVC   0(8,R1),0(R2)             MOVE DDNAME TO MSG\n         WTO   MF=(E,CCAGMSG)            PUT OUT MSG\n         B     CCAGEXIT                  EXIT PGM\nCCAEMSG1 MVC   CCAGMSG(00),0(R1)\n         SPACE 3\n*---------------------------------------------------------------------*\n*                                                                     *\n*        EXIT - FINAL                                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\nCCAGEXIT DS    0H\n         L     R9,CCAGSAVE+4             GET A(CALLER'S SAVE)\n         FREEMAIN RU,LV=CCAGWKL,A=(13),SP=230\n         SR    R15,R15                   CLEAR AS RETURN CODE\n         LR    R13,R9                    CALLER'S SAVE AREA PTR\n         L     R14,12(0,R13)             RESTORE RETURN ADDR\n         LM    R0,R12,20(R13)            AND THE REST OF CALLERS REGS\n         BSM   0,R14                   RETURN IN CORRECT AMODE      @Q2\n         EJECT\n*---------------------------------------------------------------------*\n*        CCAG CSECT DATA AREA                                         *\n*---------------------------------------------------------------------*\n         SPACE\nCONTNU   DC    AL2(CONTREC)\n         SPACE\nAGEM0010 WTO   'CCSS3901E - INVALID USE OF SUBSYSTEM CONTINUATION CHARA*\n               CTER, XXXXXXXX ',ROUTCDE=11,MF=L\nAGEL0010 EQU   *-AGEM0010\nAGED0010 EQU   4+61\n         SPACE 3\nAGEM0020 WTO   'CCSS3901E - SUBSYSTEM PARAMETER IMPLIED BUT NOT FOUND, *\n               XXXXXXXX ',ROUTCDE=11,MF=L\nAGEL0020 EQU   *-AGEM0010\nAGED0020 EQU   4+55\n         SPACE\n         LTORG\n*---------------------------------------------------------------------*\n*        DSECT FOR GROUP ALLOCATION WORKING STORAGE                   *\n*---------------------------------------------------------------------*\n         SPACE\nCCAGWK   DSECT\nCCAGSAVE DS    18F                       REGISTER SAVE AREA\nCCAGID   DS    CL8                       WORKAREA LABEL\nCCAGPRMP DS    F                         A(CALLER'S PARM)\nCCAGMSG  DS    XL255                     WTO WKAREA\nCCAGWKL  EQU   *-CCAGWK\n     TITLE 'CCDA - OPN/CLS/CKPT/RSTRT'\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*        CCDA0000   CSECT                                             *\n*                                                                     *\n*        FUNCTIONS:                                                   *\n*                                                                     *\n*        OPEN       - DA16   KEY = 5                                  *\n*        CLOSE      - DA17   KEY = 5                                  *\n*        CHECKPOINT - DA18   KEY = 0                                  *\n*        RESTART    - DA19   KEY = 0                                  *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nCCDA0000 CSECT\nCCDA0000 AMODE 31                                                   @Q2\nCCDA0000 RMODE 24                                                   @Q2\n         ENTRY CCDA                    ESTABLISH ENTRY POINT      @R92A\n         USING *,R15                   SET TEMP BASE              @R92A\n         B     CCDA0001                  BRANCH AROUND CSECT ID\n         DC    C'CCDA &SYSDATE'\nCCDA0001 DS    0H\n         STM   R14,R12,12(R13)           SAVE REGISTERS           @R92A\n         DROP  R15                                                @R92A\n         LR    R12,R15                 LOAD BASE                  @R92A\n         USING CCDA0000,R12            DECLARE BASE               @R92A\n         LR    R9,R1                     SAVE PTR TO PARM ADDRESS\n         GETMAIN RU,LV=WKDAL,SP=230,LOC=ANY  GET WORKING STORAGE    @Q4\n         XC    0(WKDAL,R1),0(R1)         CLEAR WORK/SAVE AREA\n         ST    R13,4(,R1)                CHAIN THE\n         ST    R1,8(,R13)                   SAVE AREAS\n         LR    R13,R1                    NEW SAVE AREA\n         USING WKDA,R13                  BASE FOR WORK AREA\n         MVC   WKDAID,=C'WKDA'           LABEL WORKAREA\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        SET UP REGISTERS AND SELECT FUNCTION                         *\n*                                                                     *\n*        R7 = A(ACB) FROM DEB                                         *\n*        R8 = A(DEB) FROM SSDA                                        *\n*        R9 = A(SSOB) PARM                                            *\n*        R10 = 0, CLEARED FOR A(SSDS)                                 *\n*        R11 = A(SSDA) FROM SSOB                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SLR   R10,R10                   CLEAR FOR A(SSDS)\n         USING SSOB,R9                   SSOB ADDRESSIBILITY\n         XC    SSOBRETN,SSOBRETN         CLEAR RETURN CODE\n         L     R11,SSOBINDV              A(SSDA)\n         USING  SSDABGN,R11              SSDA ADDRESSIBILITY\n         L     R8,SSDADEBP               A(DEB)\n         USING DEBBASIC,R8               DEB ADDRESSIBILITY\n         SLR   R7,R7                     CLEAR FOR INSERT\n         ICM   R7,B'0111',DEBDCBB        A(ACB)\n         USING IFGACB,R7                 ACB ADDRESSIBILITY\n         CLC   SSOBFUNC,=AL2(SSOBCLOS)   CLOSE FUNCTION?\n         BE    DA170000                  ...YES, BRANCH.\n         CLC   SSOBFUNC,=AL2(SSOBCKPT)   CHECKPOINT?\n         BE    DA180000                  ...YES, BRANCH.\n         CLC   SSOBFUNC,=AL2(SSOBREST)   RESTART?\n         BE    DA190000                  ...YES, BRANCH\n    TITLE 'CCDA - DA16 -OPEN'\n*\n*\n*        OPEN FUNCTION: CREATE SSDS\n*                     : BRANCH ENTERED FROM RESTART\n*\n*\nDA160000 DS    0H\n         CLI   ACBID,ACBIDVAL            VALID ACB?\n         BNE   DA6E0010                  ...NO, ERROR.\n         TM    ACBAMETH,ACBSUBS          SUBSYSTEM ACCESS METHOD?\n         BNO   DA6E0010                  ...NO, ERROR.\n         TM    ACBMACR1,ACBIN            INPUT?\n         BNO   DA6E0010                  ...NO, ERROR\n         TM    ACBMACR1,ACBOUT           OUTPUT?\n         BO    DA6E0010                  ...YES, ERROR\n         TM    ACBMACR1,ACBADR           ADDRESSED...\n         BNO   DA6E0010                  ...NO,ERROR\n         TM    ACBMACR1,ACBSEQ           SEQUENTIAL ACCESS?\n         BNO   DA6E0010                  ...NO,ERROR.\n         MODESET EXTKEY=DATAMGT          INSURE KEY 5\n         GETMAIN RU,LV=SSDSIOBL,SP=SPSSDS,LOC=BELOW SSDS STORAGE    @Q4\n         XC    0(SSDSIOBL,R1),0(R1)      CLEAR IT\n         ST    R1,DEBIRBAD               ANCHOR IN DEB\n         LR    R10,R1                    A(SSDS) TO R10\n         USING SSDSIOB,R10               SSDS ADDRESSIBILITY\n         MVC   SSDID,=C'SSDS'            LABEL SSDS\n         MVI   SSDSPL,SPSSDS                 SAVE AREA SUBPOOL #    @Q4\n         MVC   SSDSPL+1(3),=AL3(SSDSIOBL)    SAVE AREA LENGTH       @Q4\n         L     R1,SSDASSCM               GET A(SSWA)\n         USING SSWA,R1                   SSWA ADDRESSIBILTY\n         SR    R5,R5                     CLEAR REG 5\n         ICM   R5,B'0011',SSWAPRNO       GET NUM LEN/PARM PAIRS\n         BZ    DA160050                  ...NONE - EMPTY DATASET\n         ST    R5,SSDTRECP               ...EQUALS TOTAL PHYC'L REC'DS\n         LA    R1,SSWAPREN               GET A(FIRST PAIR)\n         ST    R1,SSDBGNA                ...EQUALS START OF DATASET\n         USING SSWAIFLD,R1               LEN/PARM PAIR ADDRESSIBILITY\n         SR    R0,R0                     CLEAR REG 0 A(LOGC'L RECORD)\n         SR    R2,R2                     CLEAR REG 2 FOR DATA LENGTH\n         LA    R3,1                      INDEX = 1\n         LA    R4,1                      INCREMENT = 1\n*\n*        LOCATE THE FIRST LOGICAL RECORD\n*\nDA160010 DS    0H\n         ICM   R2,B'0001',SSWAILEN       GET DATA LENGTH\n         CLC   CONTINUE,SSWAIFLD         CONTINUATION 'RECORD'?\n         BNE   DA160015                  ...NO, FOUND 1ST RECORD\n         LA    R1,SSWAIPRM(R2)           POINT TO NEXT PHYSICAL REC'D\n         BXH   R3,R4,DA160040            BRANCH IF PHYSICAL EOD\n         B     DA160010                  EXAMINE NEXT PHYSICAL RECORD\nDA160015 DS    0H\n         ST    R1,SSDLRAD                SAVE: A(1ST LOGICAL RECORD)\n         SLR   R6,R6                     CLEAR LOGIC'L REC'D COUNT\n*\n*        FOUND A LOGICAL RECORD:  LOOK FOR NEXT ONE\n*\nDA160020 DS    0H\n         AH    R6,=H'1'                  ADD ONE TO LOGICAL REC'D COUNT\n         LR    R0,R1                     R0 = START OF LOGICAL RECORD\nDA160025 DS    0H\n         LA    R1,SSWAIPRM(R2)           POINT TO NEXT PHYSICAL REC'D\n         BXH   R3,R4,DA160040            EXIT IF PHYSICAL EOD\n         ICM   R2,B'0001',SSWAILEN       GET DATA LENGTH\n         CLC   CONTINUE,SSWAIFLD         CONTINUATION 'RECORD'?\n         BNE   DA160020                  ...NO, FOUND LOGICAL REC'D\n*\n*        FOUND CONTINUATION RECORD: LOOK FOR RECORD SEGMENT\n*\nDA160030 DS    0H\n         LA    R1,SSWAIPRM(R2)           POINT TO NEXT PHYSICAL REC'D\n         BXH   R3,R4,DA160040            EXIT IF PHYSICAL EOD\n         ICM   R2,B'0001',SSWAILEN       GET DATA LENGTH\n         CLC   CONTINUE,SSWAIFLD         CONTINUATION 'RECORD'?\n         BNE   DA160025                  ...FOUND A SEGMENT\n         B     DA160030                  ...YES, SKIP IT.\n*\n*        PHYSICAL END OF DATA\n*\nDA160040 DS    0H\n         ST    R1,SSDPEOD                SAVE: PHYSICAL END OF DATA\n         ST    R6,SSDTRECL             SAVE: TOTAL LOGICAL RECORDS  @Q1\n         ST    R0,SSDHRAD                SAVE: HIGH RECORD ADDRESS\n         S     R0,SSDBGNA                SUBTRACT START OF DATASET\n         BNP   DA160050                  (NOTHING BUT CONTINUE REC'DS)\n         ST    R0,SSDHRRBA               SAVE: HIGH RECORD RBA\n         SPACE\nDA160050 DS    0H\n         L     R1,SSDAJFCB               GET A(JFCB)\n         USING JFCB,R1                   JFCB ADDRESIBILTY\n         MVC   SSDRECFM,JFCRECFM         RECFM TO SSDS\n         DROP  R1\n         CLC   SSOBFUNC,=AL2(SSOBREST)   RESTART?\n         BE    DA190001                  ...YES, RETURN.\n         L     R0,INRTNADR               GET A(I/O ROUTINES)\n         ST    R0,ACBINRTN               ANCHOR\n         XC    ACBJWA,ACBJWA             CLEAR ACB CURNT RECORD POINTER\n         B     DA16RTN0                  EXIT\n         TITLE 'CCDA - DA17 - CLOSE'\n*\n*\n*        CLOSE FUNCTION: FREE SSDS\n*\n*\nDA170000 DS    0H\n         ICM   R10,B'0111',DEBIRBB       GET SSDS ADDRESS FROM DEB\n         CLC   SSDID,=C'SSDS'            VALID SSDS?\n         BNE   DA6E0010                  ...NO, ERROR.\nFREESSDS FREEMAIN RU,A=(10),LV=SSDSIOBL,SP=SPSSDS   FREE SSDS       @Q4\n         XC    DEBIRBB,DEBIRBB           CLEAR A(SSDS) IN DEB\n         MODESET EXTKEY=ZERO             FETCH PROTECTED ACB\n         CLI   ACBID,ACBIDVAL            VALID ACB?\n         BNE   DA7E0010                  ...NO, ERROR.\n         XC    ACBINRTN,ACBINRTN         CLEAR A(I/O ROUTINE) IN ACB\n         XC    ACBJWA,ACBJWA             CLEAR RECORD POINTER\n         MODESET EXTKEY=DATAMGT          RETURN TO KEY 5\n         B     DA17RTN0                  EXIT\n         TITLE 'CCDA - DA18 - CHECKPOINT'\n*\n*\n*        CHECKPOINT: RECORD THE NUMBER OF LAST LOGICAL RECORD\n*                    RETRIEVED\n*\n*\nDA180000 DS    0H\n         ICM   R10,B'0111',DEBIRBB       GET A(SSDS)\n         CLC   SSDID,=C'SSDS'            VALID SSDS?\n         BNE   DA6E0010                  ...NO, ERROR.\n         L     R4,SSDABUFR               A(SSCR DATA AREA) FROM SSOB\n         XC    0(16,R4),0(R4)            CLEAR 16 BYTES\n         OC    ACBJWA,ACBJWA             A(CURRENT RECORD)\n         BZ    DA18RTN0                  IF ZERO...EXIT\n         SLR   R0,R0                     INITIALIZE COUNT\n         SLR   R1,R1                     CLEAR FOR LENGTH\n         ICM   R2,B'1111',SSDLRAD        POINT TO FIRST LOGICAL RECORD\n         BZ    DA6E0010                  ...NONE, ERROR\n         USING SSWAIFLD,R2               SSWA ADDRESSIBILTY\nDA180010 DS    0H\n         AH    R0,=H'1'                  COUNT RECORD\n         CL    R0,SSDTRECL               COMPARE: TOTAL LOGC'L REC'DS\n         BH    DA6E0010                  ...COUNT HIGH, ERROR\n         CL    R2,ACBJWA                 EQUAL CURRENT REC ADDRESS?\n         BE    DA180030                  ...YES, FOUND IT\n         BH    DA6E0010                  ...HIGH, ERROR\nDA180015 DS    0H\n         ICM   R1,B'0001',SSWAILEN       GET RECORD LENGTH\n         LA    R2,SSWAIPRM(R1)           POINT TO NEXT PHYSICAL RECORD\n         CL    R2,SSDHRAD                COMPARE: HIGH RECORD ADDRESS\n         BH    DA6E0010                  ...HIGHER: ERROR\n         CLC   CONTINUE,SSWAIFLD         CONCATENATION 'RECORD'?\n         BNE   DA180010                  ...NO, FOUND NEXT LOGC'L REC'D\n         SPACE\nDA180020 DS    0H                        ...YES, LOOK FOR SEGMENT\n         ICM   R1,B'0001',SSWAILEN       GET RECORD LENGTH\n         LA    R2,SSWAIPRM(R1)           POINT TO NEXT PHYSICAL RECORD\n         CL    R2,SSDHRAD                COMPARE: HIGH RECORD ADDRESS\n         BH    DA6E0010                  ...HIGHER: ERROR\n         CLC   CONTINUE,SSWAIFLD         CONCATENATION 'RECORD'?\n         BNE   DA180015                  ...NO, FOUND SEGMENT.\n         B     DA180020                  ...YES, TRY AGAIN\nDA180030 DS    0H\n         ST    R0,0(0,R4)                CHECKPOINT RECORD NUMBER\n         B     DA18RTN0                  RETURN\n         TITLE 'CCDA - DA19 - RESTART'\n*\n*\n*        RESTART: RE-BUILD SSDS\n*               : RE-ESTABLISH PTR TO LAST RECORD READ\n*\n*\nDA190000 DS    0H\n         B     DA160000                  EXECUTE OPEN ROUTINE\nDA190001 DS    0H                        OPEN RETURNS HERE ON RESTART\n         MODESET EXTKEY=ZERO             BACK TO RESTART KEY\n         L     R0,INRTNADR               GET A(I/O ROUTINES)\n         ST    R0,ACBINRTN               ANCHOR\n         XC    ACBJWA,ACBJWA             CLEAR ACB CURNT RECORD POINTER\n         SLR   R1,R1                     CLEAR REG 1 FOR DATA LENGTH\n         L     R4,SSDABUFR               A(SSCR DATA AREA) FROM SSOB\n         ICM   R2,B'1111',SSDLRAD        A(FIRST LOGICAL RECORD)\n         BNP   DA19RTN0                  IF ZERO...RETURN (NXT=EOD)\n         OC    0(4,R4),0(R4)             TST CHECKPOINTED RECORD NUMBER\n         BZ    DA19RTN0                  IF ZERO...RETURN (NXT=FIRST)\n         SLR   R0,R0                     CLEAR REG. 0\n         USING SSWAIFLD,R2               RECORD ADDRESSIBILITY\nDA190010 DS    0H                        GOT A LOGICAL RECORD\n         AH    R0,=H'1'                  COUNT IT\n         C     R0,0(,R4)                 COMPARE COUNT TO CHECKPOINT\n         BE    DA190030                  ...EQUAL, FOUND RECORD\n         CL    R2,SSDHRAD                COMPARE: HIGH RECORD ADDRESS\n         BE    DA190030                  ...EQUAL, EXIT LOOP (NXT=EOD)\nDA190015 DS    0H\n         ICM   R1,B'0001',SSWAILEN       GET RECORD LENGTH\n         LA    R2,SSWAIPRM(R1)           POINT TO NEXT RECORD\n         CLC   CONTINUE,SSWAIFLD         CONTINUATION RECORD?\n         BNE   DA190010                  ...NO, FOUND LOGICAL RECORD\nDA190020 DS    0H\n         ICM   R1,B'0001',SSWAILEN       GET RECORD LENGTH\n         LA    R2,SSWAIPRM(R1)           POINT TO NEXT RECORD\n         CLC   CONTINUE,SSWAIFLD         CONTINUATION RECORD?\n         BNE   DA190015                  ...NO, FOUND SEGMENT\n         B     DA190020                  ...YES TRY AGAIN\nDA190030 DS    0H\n         ST    R2,ACBJWA                 SAVE A(LAST RECORD READ)\n         B     DA19RTN0                  RETURN\n         DROP R2\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        CCDA EXITS                                                   *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ERRORS                                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\nDA7E0010 DS    0H\n         MODESET EXTKEY=DATAMGT          RETURN TO DATA MANAGEMENT KEY\nDA6E0010 DS    0H\n         LA    R0,SSDMFAIL\n         ST    R0,SSOBRETN               SET ERROR FLAG IN SSOB\n         SPACE 3\n*---------------------------------------------------------------------*\n*                                                                     *\n*        NORMAL                                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\nDA16RTN0 DS    0H\nDA17RTN0 DS    0H\nDA18RTN0 DS    0H\nDA19RTN0 DS    0H\nCCDARTN0 DS    0H\n         L     R9,WKDASAVE+4             GET A(CALLER'S SAVE)\n         FREEMAIN RU,LV=WKDAL,A=(13),SP=230\n         SR    R15,R15                   CLEAR AS RETURN CODE\n         LR    R13,R9                    CALLER'S SAVE AREA PTR\n         L     R14,12(0,R13)             RESTORE RETURN ADDR\n         LM    R0,R12,20(R13)            AND THE REST OF CALLERS REGS\n         BSM   0,R14                   RETURN IN CORRECT AMODE      @Q2\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CCDA CSECT CONSTANTS                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nINRTNADR DC    A(X'80000000'+SSIO0000)\nCONTINUE DC    AL2(CONTREC)\n         LTORG\n         SPACE 5\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECT FOR CCDA WORKAREA                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\nWKDA     DSECT\nWKDASAVE DS    18F                       REGISTER SAVE AREA\nWKDAID   DS    CL4                       WORKAREA LABEL\n         DS    F\nWKDAL    EQU   *-WKDA\n         TITLE 'SSIO - SUBSYSTEM I/O'\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        I/O ROUTINES                                                 *\n*                                                                     *\n*                                                                     *\n*        OPEN POINTS ACB TO THESE ROUTINES                            *\n*                                                                     *\n*                                                                     *\n*        SUPPORTED FUNCTIONS: GET                                     *\n*                                                                     *\n*                                                                     *\n*        NOTE: THE 'CORRECT' SYNTAX OF THE CONTINUATION CHARACTER     *\n*        IS ENFORCED BY EITHER THE CONVERTER OR ALLOCATION ROUTINE.   *\n*        AS FAR AS THIS CSECT IS CONCERNED  THERE ARE NO RULES:       *\n*        A PLUS SIGN MAY OCCUR AS THE FIRST OR LAST PARAMETER,        *\n*        A PLUS SIGN MAY BE FOLLOWED BY ANOTHER.                      *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nSSIO0000 CSECT\nSSIO0000 AMODE 31                                                   @Q2\nSSIO0000 RMODE 24                                                   @Q2\n         ENTRY INRTNADR               ESTABLISH ENTRY POINT       @R92A\n         USING *,R15                  SET TEMP BASE               @R92A\n         B     SSIO0001                 BRANCH AROUND CSECT ID\n         DC    C'SSIO &SYSDATE'\nSSIO0001 DS    0H\n         STM   R14,R12,12(R13)          SAVE REGISTERS            @R92A\n         DROP  R15                                                @R92A\n         LR    R12,R15                LOAD BASE                   @R92A\n         USING SSIO0000,R12           DECLARE BASE                @R92A\n         CLM   R0,B'0001',=AL1(RPLGET)  TEST FUCTION CODE\n         BH    SSIE0100                 UNSUPPORTED FUNCTION\n         LTR   R6,R1                    RPL ADDRESS?\n         BNP   SSIE0010                 NO RPL ADDRESS\n         USING IFGRPL,R6                RPL ADDRESSIBILITY\n         CLI   RPLID,RPLIDD             VALID RPL?\n         BNE   SSIE0010                 INVALID RPL\n         STC   R0,RPLREQ                SAVE FUNCTION IN RPL\n         ICM   R7,B'1111',RPLDACB       GET A (ACB)\n         BZ    SSIE0011                 NO ACB IN RPL\n         USING IFGACB,R7                ACB ADDRESSIBILITY\n         CLI   ACBID,ACBIDVAL           VALID ACB?\n         BNE   SSIE0022                 INVALID ACB\n         SLR   R8,R8                    CLEAR FOR INSERT\n         ICM   R8,B'0111',ACBDEB        GET A(DEB)\n         USING DEBBASIC,R8              DEB ADDRESSIBILITY\n         SLR   R10,R10\n         ICM   R10,B'0111',DEBIRBB      GET A(SSDS)\n         BZ    SSIE0021                 NO SSDSIOB\n         USING SSDSIOB,R10              SSDS ADDRESSIBILTY\n         CLC   SSDID,=C'SSDS'           VALID SSDS?\n         BNE   SSIE0030                 INVALID SSDSIOB\n*\n*        R6 = A(RPL)     R8 = A(DEB)       R12 = BASE\n*        R7 = A(ACB)     R10 = A(SSDSIOB)  R13 = USER'S SAVE AREA\n*\n         LR    R15,R0                   FUNCTION TO REG 15\n         SLL   R15,2                    MULTIPLY BY 4\n         B     SSIO0100(R15)            SELECT CORRECT ROUTINE\nSSIO0100 DS    0H\n         B     SSIOGET                  GET\n         B     SSIOPUT                  PUT\n         B     SSIOCHK                  CHECK\n         B     SSIOPNT                  POINT\n         B     SSIOENDR                 ENDREQ\n         B     SSIOERAS                 ERASE\nSSIOPUT  DS    0H\nSSIOCHK  DS    0H\nSSIOPNT  DS    0H\nSSIOENDR DS    0H\nSSIOERAS DS    0H\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*        GET NEXT RECORD FROM SUBSYSTEM DATASET USING                 *\n*        POINTER TO 'CURRENT' OR LAST RECORD READ STORED              *\n*        IN THE ACB                                                   *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nSSIOGET  DS    0H\n         SR    R1,R1                    CLEAR FOR LENGTH\n         L     R5,ACBJWA                GET ACB A(CURRENT RECORD)\n         CL    R5,SSDHRAD               COMPARE: HIGH RECORD ADDRESS\n         BE    SSIE0400                 ...EQUAL: END OF DATA\n         BH    SSIE0020                 ...HIGHER: ERROR\n*\n*        POINT TO NEXT RECORD\n*\n         LTR   R5,R5                    TEST A(CURRENT RECORD)\n         BNZ   SSGT0010                 IF ZERO...\n         L     R5,SSDLRAD               ...POINT TO 1ST LOGICAL RECORD,\n         B     SSGT0020                    IT IS THE NEXT RECORD\n         SPACE\nSSGT0010 DS    0H                       LOCATE START OF NEXT RECORD\n         CL    R5,SSDLRAD               COMPARE: START OF DATASET\n         BL    SSIE0020                 ...LOWER: ERROR.\n         USING SSWAIFLD,R5              SSWA ADDRESSIBILTY\nSSGT0011 DS    0H\n         ICM   R1,B'0001',SSWAILEN      GET RECORD LENGTH\n         LA    R5,SSWAIPRM(R1)          POINT TO NEXT RECORD\n         CL    R5,SSDHRAD               COMPARE: HIGH RECORD ADDRESS\n         BH    SSIE0020                 ...HIGHER: ERROR\n         CLC   CONCAT,SSWAIFLD          CONCATENATION 'RECORD'?\n         BNE   SSGT0020                 ...NO, FOUND NEXT RECORD\n         SPACE\nSSGT0012 DS    0H                       ...YES, LOOK FOR SEGMENT\n         ICM   R1,B'0001',SSWAILEN      GET RECORD LENGTH\n         LA    R5,SSWAIPRM(R1)          POINT TO NEXT PHYSICAL RECORD\n         CL    R5,SSDHRAD               COMPARE: HIGH RECORD ADDRESS\n         BH    SSIE0020                 ...HIGHER: ERROR\n         CLC   CONCAT,SSWAIFLD          CONCATENATION 'RECORD'?\n         BNE   SSGT0011                 ...NO, FOUND SEGMENT.\n         B     SSGT0012                 ...YES, TRY AGAIN\n*\n*        MOVE NEXT RECORD TO BUFFER SEGMENT BY SEGMENT\n*\nSSGT0020 DS    0H\n         LR    R2,R5                    R2 = A(NEXT RECORD)\n         SL    R2,SSDBGNA               CALCULATE: R2 = RBA\n         ST    R2,RPLDDDD               UPDATE RPL RBA\n         ST    R5,ACBJWA                UPDATE ACB RECORD POINTER\n         SLR   R2,R2                    R2 = ZERO = TOTAL REC'D LEN\nSSGT0021 DS    0H\n         L     R3,RPLAREA               R3 = A(BUFFER)\n         L     R4,RPLBUFL               R4 = BUF LENGTH\n         AR    R3,R2                    POINT BEYOND DATA IN BUFFER\n         SR    R4,R2                    CALC BYTES REMAINING IN BUFFER\n         LA    R0,SSWAIPRM              R0 = DATA START\n         ICM   R1,B'0001',SSWAILEN      R1 = DATA LENGTH\n         LR    R14,R3                   R14 = BUFFER START\n         LR    R15,R4                   R15 = BUFFER LENGTH\n         AR    R2,R1                    CALCULATE TOTAL LRECL\n         LTR   R15,R15                  IF BUFL LT LRECL...\n         BNP   SSGT0023                 ...SKIP DATA MOVEMENT\n         ICM   R1,B'1000',=X'40'        MOVE DATA TO BUFFER, LEFT-\n         MVCL  R14,R0                   JUSTIFIED, PADDED WITH BLANKS.\nSSGT0023 DS    0H\n         SR    R0,R0                    CLEAR FOR RETURN CODE\n         SLR   R1,R1                  CLEAR FOR INSERT              @Q2\n         ICM   R1,B'0001',SSWAILEN      GET RECORD LENGTH\n         LA    R5,SSWAIPRM(R1)          POINT TO NEXT RECORD\n         CL    R5,SSDPEOD               COMPARE: PHYSICAL EOD\n         BE    SSGT0030                 EQUAL...FINISHED\n         BH    SSIE0020                 HIGHER...ERROR\n         CLC   CONCAT,SSWAIFLD          CONCATENATION RECORD?\n         BNE   SSGT0030                 ...NO, FINISHED MOVE\nSSGT0025 DS    0H\n         ICM   R1,B'0001',SSWAILEN      GET RECORD LENGTH\n         LA    R5,SSWAIPRM(R1)          POINT TO NEXT RECORD\n         CL    R5,SSDPEOD               COMPARE: PHYSICAL EOD\n         BE    SSGT0030                 EQUAL...FINISHED\n         BH    SSIE0020                 HIGHER...ERROR\n         CLC   CONCAT,SSWAIFLD          CONCATENATION RECORD?\n         BNE   SSGT0021                 ...NO, MOVE NEXT SEGMENT\n         B     SSGT0025                 ...YES, LOOK FOR SEGMENT\n*\n*        ALL SEGMENTS IN BUFFER\n*\nSSGT0030 DS    0H\n         ST    R2,RPLRLEN               UPDATE RPL RECORD LENGTH\n         C     R2,RPLBUFL               COMPARE: LRECL AND BUFL...\n         BH    SSIE0300                 ...LRECL HIGHER, ERROR\n         TM    SSDRECFM,JFCFIX\n         BNO   SSIOEXIT                 IF FIXED RECFM...\n         TM    SSDRECFM,JFCVAR          ...MAKE RECORD SIZE\n         BNZ   SSIOEXIT                    EQUAL BUFFER LENGTH\n         MVC   RPLRLEN,RPLBUFL          THEN\n         B     SSIOEXIT                 ...RETURN\n         DROP  R5\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*        CONTROL BLOCK ERRORS - ABEND SYSTEM X'1FA'                   *\n*                                                                     *\n*                                                                     *\n*        LEAVE TRACE ADDRESS IN REG 2 TO TESTING/DEBUGGING            *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nSSIE0010 DS    0H                       INVALID RPL\n         LA    R2,SSIE0010\n         B     SSIE@1FA\nSSIE0011 DS    0H                       INVALID RPL POINTER TO ACB\n         LA    R2,SSIE0011\n         B     SSIE@1FA\nSSIE0020 DS    0H\n         LA    R2,SSIE0020              INVALID ACB PTR TO LAST RECORD\n         B     SSIE@1FA\nSSIE0021 DS    0H\n         LA    R2,SSIE0021              INVALID ACB POINTER TO SSDSIOB\n         B     SSIE@1FA\nSSIE0022 DS    0H\n         LA    R2,SSIE0030              ACB VALIDITY CHECK FAILURE\n         B     SSIE@1FA\nSSIE0030 DS    0H\n         LA    R2,SSIE0030              SSDSIOB VALIDITY CHECK FAILURE\n         B     SSIE@1FA\nSSIE@1FA DS    0H\n         ABEND X'1FA',DUMP,,SYSTEM  CONTROL BLOCK ERROR\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*        LOGICAL ERRORS - SET RPL FDBK AND LOGICAL ERR RETURN CODE    *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nSSIE0100 DS    0H                       UNSUPPORTED FUNCTION\n         LA    R0,RPLINACC\n         B     SSIE0LGC\nSSIE0300 DS    0H                       BUFFER TOO SMALL\n         LA    R0,RPLINBUF\n         B     SSIE0LGC\nSSIE0400 DS    0H                       END OF DATA\n         LA    R0,RPLEODER\n         B     SSIE0LGC\nSSIE0LGC DS    0H\n         AL    R0,=A(RPLLOGER*65536)\n         B     SSIOEXIT\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*        EXIT - FINAL                                                 *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nSSIOEXIT DS    0H\n         STCM  R0,7,RPLFDBK             SET FEEDBACK IN RPL\n         MVI   RPLCMPON,C'S'            SET COMPONENT ID\n         SRL   R0,16                    SET RETURN CODE\n         ST    R0,16(,13)               SAVE IN USER'S REG 15\n         LA    R1,RPLECB                A(ECB)- INTERNAL\n         TM    RPLOPT1,RPLECBSW         INTERNAL OR EXTERNAL ECB?\n         BZ    *+8                      SKIP IF INTERNAL\n         L     R1,RPLECB                A(ECB) - EXTERNAL\n         MVI   0(R1),X'40'              QUICK POST\n         LM    R14,R12,12(R13)          RESTORE CALLER'S REGISTERS\n         BSM   0,R14                  RETURN IN CORRECT AMODE       @Q2\n         SPACE 5\n*---------------------------------------------------------------------*\n*                                                                     *\n*        SSIO CSECT CONSTANTS                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\nCONCAT   DC    AL2(CONTREC)\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CCSSLINK": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x07\\x7f\\x00\\x99\\x07\\x7f#$\\x00,\\x00,\\x00\\x00\\xc1`\\xc6\\xc9\\xc5\\xd3\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-03-18T00:00:00", "modifydate": "1999-03-18T23:24:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "A-FIELD"}, "text": "//TCACF0C JOB (880MV0),'ALAN FIELD',CLASS=S,NOTIFY=&SYSUID,MSGCLASS=X\n//* JOB(CCSSINST) - CONTROL CARD SUBSYSTEM INSTALL\n//OUTMSG OUTPUT DEFAULT=Y,DEST=TCACF0.LIST,COMPACT=FIELDXXX,FLASH=VMAP\n//ALANJCL JCLLIB ORDER=(SYS1.PROCLIB,TCACF0.JOB.CNTL)\n//MTSS EXEC HLASMCL,\n// PARM.ASM='OBJECT,NODECK,BATCH,RENT',\n// PARM.LKED='XREF,LET,LIST,RENT,REUS'\n//DDS INCLUDE MEMBER=ASMMACDD\n//ASM.SYSIN    DD DISP=SHR,DSN=TCACF0.PGMS.ASM(MTSS)\n//LKED.SYSLMOD DD DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSLIB  DD DISP=SHR,DSN=TCACF0.TEST.LOAD\n//             DD DISP=SHR,DSN=APPNS.SUBLIB.LOAD\n//LKED.SYSIN   DD *\n SETSSI 00007022\n MODE AMODE(31),RMODE(24)\n NAME MTSS(R)\n/*\n//MTSSA EXEC HLASMCL,\n// PARM.ASM='OBJECT,NODECK,BATCH,RENT',\n// PARM.LKED='XREF,LET,LIST,RENT,REUS'\n//DDS INCLUDE MEMBER=ASMMACDD\n//ASM.SYSIN    DD DISP=SHR,DSN=TCACF0.PGMS.ASM(MTSSA00)\n//LKED.SYSLMOD DD DISP=SHR,DSN=SYS2.LINKLIB\n//LKED.SYSLIB  DD DISP=SHR,DSN=TCACF0.TEST.LOAD\n//             DD DISP=SHR,DSN=APPNS.SUBLIB.LOAD\n//LKED.SYSIN   DD *\n SETSSI 00007022\n MODE AMODE(31),RMODE(24)\n ALIAS CCSSINIT\n NAME MTSSA00(R)\n/*\n//CCSS EXEC HLASMCL,\n// PARM.ASM='OBJECT,NODECK,BATCH,RENT',\n// PARM.LKED='XREF,LET,LIST,RENT,REUS'\n//DDS INCLUDE MEMBER=ASMMACDD\n//ASM.SYSIN    DD DISP=SHR,DSN=TCACF0.PGMS.ASM(CCSS)\n//LKED.SYSLMOD DD DISP=SHR,DSN=SYS2.LPALIB\n//LKED.SYSLIB  DD DISP=SHR,DSN=TCACF0.TEST.LOAD\n//             DD DISP=SHR,DSN=APPNS.SUBLIB.LOAD\n//LKED.SYSIN   DD *\n SETSSI 00007022\n MODE AMODE(31),RMODE(24)\n NAME CCSS(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CCSSTEST": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x07\\x7f\\x00\\x99\\x07\\x7f#$\\x00\\r\\x00\\r\\x00\\x00\\xc1`\\xc6\\xc9\\xc5\\xd3\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-03-18T00:00:00", "modifydate": "1999-03-18T23:24:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "A-FIELD"}, "text": "//TCACF0C JOB (880MV0),'ALAN FIELD',CLASS=S,NOTIFY=&SYSUID,MSGCLASS=X\n//* JOB(CCSSTEST) - TEST CONTROL CARD SUBSYSTEM\n//CCSSTST PROC\n//CCSSTST EXEC PGM=ICEGENER,REGION=1024K\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSUT1   DD SUBSYS=(CCSS,\n//   'THIS IS LINE ONE OF &ID.''S ',\n//   'CCSS TEST JOBSTREAM.        ',\n//   'THERE SHOULD BE THREE LINES.')\n//SYSUT2   DD SYSOUT=*\n// PEND\n//TEST EXEC CCSSTST,ID=ALAN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DOC": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x973\\x0f\\x00\\x99\\x07o\\x11A\\x00\\x1b\\x00\\x15\\x00\\x00|\\xe3\\xe2\\xe2\\xe8\\xf5\\xf9@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1997-11-26T00:00:00", "modifydate": "1999-03-17T11:41:00", "lines": 27, "newlines": 21, "modlines": 0, "user": "@TSSY59"}, "text": "WE GOT THIS AS PART OF AN IN-SOURCE ACCOUNT, SO DOC IS A LITTLE SCANTY\nON THIS. IT IS CURRENTLY RUNNING ON OS390 RELEASE 3 JES3.\n\nTHE ENTRY IN THE SUBSYSTEM IEFSSNXX SHOULD BE\nCCSS,CCSSINIT\n\nTHE LINK ATTRIBUTES FOR ALL MODULES ARE AS FOLLOWS\nRENT, REUS AMODE 31 RMODE 24\n\nCCSS SHOULD BE IN AN LPALST LIBRARY AS CCSS\n\nMTSS SHOULD BE IN AN LNKLST LIBARY AS MTSS (NOT SURE THIS MEMBER\n           IS NEEDED, IT APPEARS TO BE USED FOR TESTING ONLY)\n\nMTSSA00 SHOULD BE IN AN LNKLST LIBARY AS MTSSA00 WITH ALIAS OF CTSSINIT\n\n\n      Lee Warriner\n      Hartford Insurance Group\n      Mail Stop NP3-4\n      Hartford Plaza\n      Hartford, CT  06115\n      860-547-2004\n\n   email:   cwarriner@thehartford.com\n IBMMAIL:   USTV7KFN\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IEFSSNXX": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x07\\x7f\\x00\\x99\\x07\\x7f#$\\x00\\x02\\x00\\x02\\x00\\x00\\xc1`\\xc6\\xc9\\xc5\\xd3\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-03-18T00:00:00", "modifydate": "1999-03-18T23:24:00", "lines": 2, "newlines": 2, "modlines": 0, "user": "A-FIELD"}, "text": "SUBSYS SUBNAME(CCSS)    /* CONTROL CARD SUBSYSTEM */\n  INITRTN(CCSSINIT)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOADMODS": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x07o\\x00\\x99\\x07o\\x13\\x00\\x00Z\\x00Z\\x00\\x00\\xe3\\xe2\\xd6\\xe7\\xd4\\xc9\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-03-17T00:00:00", "modifydate": "1999-03-17T13:00:00", "lines": 90, "newlines": 90, "modlines": 0, "user": "TSOXMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "MTSS": {"ttr": 1040, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\t/\\x00\\x98\\t/\\t!\\x02\\x8a\\x02\\x8a\\x00\\x00|\\xe3\\xe2\\xe2\\xe8\\xf5\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-04-02T00:00:00", "modifydate": "1998-04-02T09:21:00", "lines": 650, "newlines": 650, "modlines": 0, "user": "@TSSY59"}, "text": "         TITLE 'MTSSVT  - SSVT MODIFY  '\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*      MTSS - MODIFY TRANSIENT SUBSYSTEM                              *\n*                                                                     *\n*                                                                     *\n*      THIS PROGRAM WAS DESIGNED AS A TOOL FOR DEVELOPING AND         *\n*      TESTING SUBSYSTEMS.  ITS INTENDED FUNCTION IS TO BE ABLE,      *\n*      WHEN USED IN CONJUNCTION WITH THE MODREP PROGRAM, TO           *\n*      ACTIVATE AND DE-ACTIVATE PRU-DEVELOPED SUBSYSTEMS WITHOUT      *\n*      HAVING TO IPL MVS.                                             *\n*                                                                     *\n*                                                                     *\n*      NORMALLY ANY SUBSYSTEM WHOSE NAME IS DEFINED IN LINKLIB        *\n*      MEMBER IEFJSSNT WILL BE INITIALIZED DURING MASTER SCHED-       *\n*      ULER INITIALIZATION IF THE IEFJSSNT ENTRY CONTAINS THE         *\n*      NAME OF AN INITIALIZATION ROUTINE TO BE EXECUTED.  WHEN        *\n*      PERFORMING A START FUNCTION THIS PROGRAM EMULATES THE          *\n*      MASTER SCHEDULER BY PLACING THE MACHINE IN KEY ZERO SUPER-     *\n*      VISOR STATE, CONTRUCTING THE SAME PARAMETER LIST THAT          *\n*      THE MASTER SCHEDULER CONTRUCTS (THE ADDRESS OF THE SUB-        *\n*      SYSTEM'S SSCT), THEN LOADING AND EXECUTING THE INITIALIZATION  *\n*      ROUTINE.  BY DEFINITION, A SUBSYSTEM IS ACTIVE WHEN THE        *\n*      SSCT CONTRUCTED BY THE MASTER SCHEDULER AT IPL TIME CON-       *\n*      TAINS THE ADDRESS OF THE SUBSYSTEM'S SSVT.  THE MAJOR          *\n*      FUNCTION AND IN FACT THE  ONLY REQUIRED FUNCTION OF A          *\n*      SUBSYSTEM INITIALIZATION ROUTINE IS THAT IT BUILD AN SSVT      *\n*      AND CHAIN IT OFF THE SSCT.  THAT IS ALL MOST PRU-DEVELOPED     *\n*      SUBSYSTEM INIT ROUTINES DO.  TO DE-ACTIVATE A                  *\n*      SUBSYSTEM ALL THAT IS REQUIRED IS THAT THE SSCT POINTER TO     *\n*      THE SUBSYSTEM'S SSVT BE ZEROED OUT.  THAT IS ALL THIS PRO-     *\n*      GRAM DOES WHEN STOPPING A SUBSYSTEM.  THAT IS ALL THAT         *\n*      ANY SUBSYSTEM MODIFIED BY THIS PROGRAM SHOULD REQUIRE.         *\n*                                                                     *\n*                                                                     *\n*      THIS PROGRAM IS RE-ENTRANT, REFRESHABLE, AND AUTHORIZED.       *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PGM INITIALIZATION                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nMTSSVT   AMODE 31\nMTSSVT   RMODE 24\nMTSSVT   CSECT\n         STM   R14,R12,12(R13)           SAVE REGISTERS\n         LR    R12,R15                   LOAD BASE\n         USING MTSSVT,R12                DECLARE BASE\n         B     MTSS0000                  BRANCH AROUND MODULE ID\n         DC    C'MTSSVT &SYSDATE'\nMTSS0000 DS    0H\n         LR    R5,R1                     SAVE PTR TO PARM ADDRESS\n         L     R6,XXXMTSSS               GET WKAREA SUBPOOL AND SIZE\n         GETMAIN R,LV=(6)                GET THE WORKAREA\n         LR    R2,R1                     A(AREA) FOR MVCL\n         LA    R3,MTSWKL                 L'WKAREA\n         SR    R14,R14                   NO SOURCE\n         SR    R15,R15                   NO SOURCE LENGTH\n         MVCL  R2,R14                    ZERO THE AREA\n         ST    R13,4(,R1)                CHAIN THE\n         ST    R1,8(,R13)                   SAVE AREAS\n         LR    R13,R1                    NEW SAVE AREA\n         USING MTSSWK,R13                BASE FOR WORK AREA\n         MVC   MTSID,=C' MTSSWK '        LABEL WORKAREA\n         ST    R5,MTSPRMAD               SAVE R1 ENTRY PARM\n         ST    R6,MTSSS                  SUBPOOL AND SIZE TO WKAREA\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*       CHECK OUT THE PARM                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\nPRM00000 DS    0H\n         LA    R0,START                  DEFAULT OPT = START\n         MVC   MTSSID,BLANKS             SUBSYSTEM NAME = BLANKS\n         MVC   MTSLMOD,BLANKS            ENTRY POINT NAME = BLANKS\n         L     R5,0(R5)                  GET A(PARM)\n         LH    R3,0(R5)                  GET PARM LENGTH\n         LTR   R3,R3                     IS THERE A PARM\n         BZ    PRM02000                  NO, SUBSYS NAME = JOBNAME\n         LA    R2,2(R5)                  POINT TO PARM TEXT\n         SR    R14,R14                   NO COMPARATOR\n         LA    R15,X'40'                 PAD = BLANK AND\n         SLL   R15,24                    NO COMPARATOR LENGTH\nLEN      EQU   R1                        REGISTER FOR FIELD LENGTH\n*\n*        LOOK FOR A KEYWORD IN PARM - EXECUTE VALIDATION ROUTINE\n*\nPRM01000 DS    0H\n         CLCL  R2,R14                    FIND NON-BLANK CHAR\n         BE    ERR01000                  ALL BLANKS THEN ERROR\n         LA    R6,KWDTBL                 A(KEYWORD TABLE)\n         USING KWDENTRY,R6               TABLE ADDRESSIBILITY\nPRM01020 DS    0H\n         SLR   LEN,LEN                   CLEAR FOR LENGTH\n         ICM   LEN,B'0001',KWDLEN        GET KEY LENGTH...\n         BZ    ERR01000                  ...ZERO, BAD PARM\n         CR    R3,LEN                    REMAINING BYTES LT L'ENTRY?\n         BL    PRM01021                  ...YES, TRY ANOTHER ENTRY\n         LR    R7,LEN                    R7 = L'ENTRY\n         BCTR  R7,0                      REDUCE FOR EXECUTE\n         EX    R7,PRM0100I               CAN WE IDENTIFY THE KEYWORD?\n         BE    PRM01010                  YES...PROCESS IT\nPRM01021 DS    0H\n         LA    R6,KWDKEY+3(LEN)          NO...POINT TO NEXT ENTRY...\n         SRL   R6,2                      ENTRIES ARE ALIGNED\n         SLL   R6,2                      ON FULLWORD BOUNDARIES\n         B     PRM01020                  KEYWD = NEXT ENTRY?\nPRM01010 DS    0H\n         IC    R7,KWDFLG                 YES...GET KEYWORD FLAG\n         EX    R7,PRM0101I               FOUND IT BEFORE?\n         BO    ERR01000                  YES...BAD PARM\n         OC    MTSPFLGS,KWDFLG           SET KEYWORD FLAG\n         LA    R4,C'='                   FIND '='\n         BAL   R5,PRM01400               NXT CHAR MUST BE '='\n         TM    MTSPFLGS,FIND             FIND IT?\n         BNO   ERR01000                  NO - ERROR\n         CLCL  R2,R14                    FIND NON-BLANK CHAR\n         BE    ERR01000                  ALL BLANKS IS ERROR\n         ICM   R7,B'1111',KWDRTN         YES...GET A(VALIDATION RTN)\n         BZ    ERR01000                  IF ADDR = ZERO, BAD PARM\n         BALR  R5,R7                     EXECUTE VALIDATION ROUTINE\n         LA    R4,C','                   CHAR = COMMA\n         BAL   R5,PRM01400               NXT CHAR MUST BE COMMA\n         TM    MTSPFLGS,FIND             FIND IT?\n         BNO   PRM01END                  NO, DONE WITH PARM\n         B     PRM01000                  NEXT KEYWORD\n         SPACE\nPRM0100I CLC   00(00,R2),KWDKEY          PARM KEYWD = TBL KEYWD?\nPRM0101I TM    MTSPFLGS,X'00'            KEYWORD BEEN FOUND BEFORE?\n         DROP  R6\n         SPACE\n*\n*        SUBROUTINE: LOCATE SPECIFIC CHARACTER\n*\nPRM01400 DS    0H\n         NI    MTSPFLGS,X'FF'-FIND       TURN OFF FLAGS\n         AR    R2,LEN                    POINT PAST LAST FIELD\n         SR    R3,LEN                    ADJUST REMAINING BYTES\n         BNP   PRM01410                  NO REMAINING BYTES, RETURN\n         CLCL  R2,R14                    FIND NON-BLANK CHAR\n         BE    PRM01410                  ALL BLANKS = RETURN TO CALLER\n         CLM   R4,B'0001',0(R2)          CHAR = CALLER'S CHAR?\n         BNE   PRM01410                  NO, RETURN TO CALLER\n         OI    MTSPFLGS,FIND             YES, SET FLAG\n         LA    R2,1(,R2)                 POINT PAST BYTE\n         BCTR  R3,0                      ADJUST REMAINING BYTES\nPRM01410 DS    0H\n         SR    LEN,LEN                   CLEAR LENGTH REGISTER\n         BR    R5                        RETURN TO CALLER\n         SPACE\n*\n*        SUBROUTINE: LOOK FOR DELIMITER\n*\nPRM01600 DS    0H\n         CLI   0(R2),C','                LOOK FOR DELIMITER:\n         BER   R5                             COMMA\n         CLI   0(R2),X'40'                     OR\n         BER   R5                             BLANK\n         LA    LEN,1(,LEN)               COUNT FIELD LENGTH\n         LA    R2,1(R2)                  POINT TO NEXT BYTE\n         BCTR  R3,0                      REDUCE REMAINING BYTES\n         LTR   R3,R3                     IF NO BYTES REMAINING END\n         BZR   R5                           SEARCH FOR DELIMITER\n         B     PRM01600                     ELSE, CONTINUE\n         SPACE\n*\n*        KEYWORD = OPT\n*\nPRM01200 DS    0H\n         ST    R5,MTSLNK0                SAVE RETURN ADDRESS\n         LA    LEN,5                     FIELD LENGTH = 5\n         CR    R3,LEN                    AT LEAST 5 BYTES REMAINING\n         BL    PRM01210                  NO, TRY ANOTHER\n         CLC   0(5,R2),=C'START'         OPTION = START?\n         BE    PRM01500                  YES, NEXT KEYWD, DEFAULT\nPRM01210 DS    0H\n         LA    LEN,4                     FIELD LENGTH = 4\n         CR    R3,LEN                    AT LEAST 4 BYTES REMAINING\n         BL    ERR01000                  NO, ERROR\n         LA    R0,STOP                   ASSUME STOP\n         CLC   0(4,R2),=C'STOP'          OPTION = STOP?\n         BE    PRM01500                  YES, NEXT KEYWORD?\n         B     ERR01000                  NO, ERROR\n         SPACE\n*\n*        KEYWORD = SYSID\n*\nPRM01300 DS    0H\n         ST    R5,MTSLNK0                SAVE RETURN ADDRESS\n         BAL   R5,PRM01600               LOCATE DELIMITER\n         LTR   LEN,LEN                   IF LENGTH LESS THAN 1\n         BNP   ERR01000                  OR\n         LA    R4,4                      GREATER THAN 4\n         CR    LEN,R4                    THEN\n         BH    ERR01000                  ERROR.\n         SR    R2,LEN                    POINT TO START OF FIELD\n         BCTR  LEN,R0                    REDUCE FOR EXECUTE\n         EX    LEN,MVCSSID               MOVE TO WORKING STORAGE\n         LA    R2,1(LEN,R2)              RESTORE R2 POINTER\n         SR    LEN,LEN                   CLEAR LEN (R2,R3 UPDATED)\n         B     PRM01500                  NEXT KEYWORD?\nMVCSSID  MVC   MTSSID(0),0(R2)           EXECUTED INSTRUCTION\n         SPACE\n*\n*        KEYWORD = EP\n*\nPRM01700 DS    0H\n         ST    R5,MTSLNK0                SAVE RETURN ADDRESS\n         BAL   R5,PRM01600               LOCATE DELIMITER\n         LTR   LEN,LEN                   IF LENGTH LESS THAN 1\n         BNP   ERR01000                  OR\n         LA    R4,8                      GREATER THAN 8\n         CR    LEN,R4                    THEN\n         BH    ERR01000                  ERROR.\n         SR    R2,LEN                    POINT TO START OF NAME\n         BCTR  LEN,R0                    REDUCE FOR EXECUTE\n         EX    LEN,MVCEP                 MOVE TO WORKING STORAGE\n         LA    R2,1(LEN,R2)              RESTORE R2 POINTER\n         SLR   LEN,LEN                   CLEAR LEN (R2,R3 UPDATED)\n         B     PRM01500                  NEXT KEYWORD?\nMVCEP    MVC   MTSLMOD(0),0(R2)          EXECUTED INSTRUCTION\n         SPACE\n*\n*        COMMON KEYWORD VALIDATION ROUTINE EXIT\n*\nPRM01500 DS    0H\n         L     R5,MTSLNK0                GET RETURN ADDRESS\n         BR    R5                        RETURN\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*        IF SSID NOT SPECIFIED GET SSID FROM JOBNAME                  *\n*                                                                     *\n*---------------------------------------------------------------------*\nPRM01END DS    0H\nPRM02000 DS    0H\n         STC   R0,MTSOPT                 SAVE OPTION\n         TM    MTSPFLGS,PSSID            WAS SSID PROVIDED?\n         BO    PRM02END                  YES, NO NEED TO LOOK AT JOBNM\n         L     R1,CVTPTR                 A(CVT)\n         L     R1,CVTTCBP-CVT(R1)        A(TCB POINTERS)\n         L     R1,4(,R1)                 A(CURRENT TCB)\n         L     R1,TCBTIO-TCB(R1)         A(TIOT)\n         USING TIOT,R1                   TIOT ADDRESSIBILITY\n         MVC   MTSSID,TIOCNJOB           SSID = 1ST 4 CHAR OF JOBNAME\n*---------------------------------------------------------------------*\n*                                                                     *\n*        IF EP PARM NOT SPECIFIED THEN                                *\n*        SET ENTRY POINT NAME TO SSID + 'INIT'                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nPRM02END DS    0H\nPRM03000 DS    0H\n         TM    MTSPFLGS,PEP              WAS EP PROVIDED?\n         BO    PRM03END                  YES, NO NEED TO CONSTRUCT ONE\n         LA    R0,3                      INDEX\n         SR    LEN,LEN                   LENGTH FOR EXECUTE\n         LA    R2,MTSSID+1               SSID+1\nPRM03100 DS    0H                        LOCATE END OF SUBSYS NAME\n         CLI   0(R2),X'40'               A BLANK?\n         BE    PRM03200                  YES, EXIT LOOP\n         LA    LEN,1(,LEN)               COUNT\n         LA    R2,1(,R2)                 NEXT BYTE\n         BCT   R0,PRM03100               LOOP OR EXIT\nPRM03200 DS    0H                        CONCATENATE NAME + INIT\n         EX    LEN,MVCSSID2              SSID TO EP NAME\n         LA    R2,MTSLMOD+1              POINT TO LOAD MOD NAME\n         AR    R2,LEN                    POINT PAST SSID\n         MVC   0(4,R2),=C'INIT'          CONCAT 'INIT'\n         B     PRM03END                  LOCATE SSVT\nMVCSSID2 MVC   MTSLMOD(LEN),MTSSID       EXECUTED INSTRUCTION\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*        ARE WE AUTHORIZED TO MODIFY THE SUBSYSTEM?                   *\n*                                                                     *\n*        IF SO, THEN LOCATE THE SUBSYSTEM SSCVT                       *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nPRM03END DS    0H\nSCT00000 DS    0H\n         CLC   MTSSID(3),JESID           IF SUBSYSTEM NAME IS 'MSTR'\n         BE    ERR02200                  OR 'JES' THEN ERROR,\n         CLC   MTSSID,MSTRID             INVALID MODIFY REQUEST\n         BE    ERR02200\n         L     R1,TSSTABLE               GET A( SS NAME TABLE )\n         USING TSSTBL,R1                 TABLE ADDRESSIBILITY\nSCT01000 DS    0H\n         CLC   TSSNAME,ZERO              IF ENTRY ZEROES...\n         BE    SCT01100                  ...TRY NEXT ONE\n         CLC   TSSNAME,BLANKS            IF ENTRY BLANK...\n         BE    SCT01100                  ...TRY NEXT ONE\n         CLC   TSSNAME,HEXFF             IF END OF TABLE...\n         BE    ERR02200                  ...NOT AUTHORIZED\n         CLC   TSSNAME,MTSSID            AUTHORIZED TO MODIFY?\n         BE    SCT02000                  ...YES, LOCATE SSCVT\nSCT01100 DS    0H                        ...NO, NEXT ENTRY\n         LA    R1,TSSTBL+TSSLEN          POINT TO NEXT ENTRY\n         B     SCT01000                  CHECK IT OUT\n         SPACE\nSCT02000 DS    0H\n         L     R1,CVTPTR                 A(CVT)\n         L     R1,CVTJESCT-CVT(R1)       A(JES CONTROL TABLE)\n         L     R1,JESSSCT-JESCT(R1)      A(1ST SSCT)\n         USING SSCT,R1                   SSCT ADDRESSIBILITY\n         L     R1,SSCTSCTA               SKIP PRIMARY JES SSCT\n         L     R1,SSCTSCTA               SKIP MASTER SUBSYSTEM SSCT\nSCT02100 DS    0H\n         CLC   SSCTSNAM,MTSSID           SUBSYSTEM NAMES EQUAL?\n         BE    SCT03000                  YES, EXIT LOOP\n         ICM   R1,B'1111',SSCTSCTA       GET A(NEXT SSCT)\n         BZ    ERR02100                  IF ZERO SUBSYSTEM NOT FOUND\n         B     SCT02100                  NEXT SSCT\n               SPACE\nSCT03000 DS    0H\n         ICM   R1,B'1000',=X'80'         TURN ON HI-ORDER BIT\n         ST    R1,MTSSCTAD               SAVE A(SSCT)\n               EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*        IF STOP REQUEST                                              *\n*            STOP THE SUBSYSTEM                                       *\n*            ELSE                                                     *\n*            START THE SUBSYSTEM                                      *\n*        THEN                                                         *\n*            EXIT                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         TM    MTSOPT,STOP               STOP REQUEST?\n         BO    MTSS0200                  YES, BRANCH\n         SPACE\n*\n*        START - LINK TO INIT ROUTINE EMULATING MASTER SCHEDULER\n*\nMTSS0100 DS    0H\n         ICM   R0,B'1111',SSCTSSVT       IF SUBSYSTEM ACTIVE\n         BNZ   ERR03000                  ...THEN ERROR\n         LA    R0,MTSLMOD                A(ENTRY POINT NAME)\n         LA    R2,LDERRET                A(ERROR ROUTINE)\n         LOAD  EPLOC=(0),ERRET=(2)       LOAD INITIALIZATION MODULE\n         ST    R0,MTSLMODA               SAVE A(ENTRY POINT)\n         MODESET KEY=ZERO,MODE=SUP       SUPERVISOR STATE\n         LA    R1,MTSSCTAD               POINT TO A(SSCT)\n         L     R15,MTSLMODA              INIT ROUTINE ADDRESS\n         BALR  R14,R15                   DO INITIALZATION\n         MODESET KEY=NZERO,MODE=PROB     KILL SUPERVISOR STATE\n         SR    R15,R15                   RETURN CODE = ZERO\n         B     RETURN                    EXIT\n         SPACE 2\n*\n*        STOP - CLEAR SSCT POINTER TO SSVT\n*\nMTSS0200 DS    0H\n         MODESET KEY=ZERO,MODE=SUP       SUPERVISOR STATE\n         L     R1,MTSSCTAD               A(SSCT)\n         OC    SSCTSSVT,SSCTSSVT         IS THERE A PTR TO SSVT?\n         BZ    ERR04000                  ...NO, ERROR.\n         XC    SSCTSSVT,SSCTSSVT         CLEAR PTR TO SSVT\n         MODESET KEY=NZERO,MODE=PROB     KILL SUPERVISOR STATE\n         MVC   MTSMSG(M01L),M01          MSG TO WORKAREA\n         MVC   MTSMSG+M01P1(L'MTSSID),MTSSID\n         WTO   MF=(E,MTSMSG)             PUT OUT MESSAGE\n         SR    R15,R15\n         SPACE\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*        EXIT PROGRAM                                                 *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\nRETURN   DS    0H\n         LR    R5,R15                    SAVE RETURN CODE\n         L     R6,MTSAVE+4               GET A(CALLER'S RSA)\n         L     R0,MTSSS                  GET WKAREA SUBPOOL AND SIZE\n         FREEMAIN R,LV=(0),A=(13)         FREE WKAREA\n         LR    R15,R5                    RESTORE RETURN CODE\n         LR    R13,R6                    R13 = CALLER'S RSA\n         RETURN (14,12),RC=(15)          EXIT\n         EJECT\n*---------------------------------------------------------------------*\n*        ERROR ROUTINES                                               *\n*---------------------------------------------------------------------*\n         SPACE\nERR01000 DS    0H                        BAD PARM\n         MVC   MTSMSG(E01L),E01          MSG TO WORKAREA\n         B     ERREXIT\n         SPACE 2\nERR02100 DS    0H                        SUBSYSTEM NOT DEFINED\n         MVC   MTSMSG(E02L),E02          MSG TO WORKAREA\n         MVC   MTSMSG+E02P1(L'MTSSID),MTSSID   SUBSYS NAME TO MSG\n         B     ERREXIT\n         SPACE 2\nERR02200 DS    0H                        INVALID SUBSTEM FOR MODIFY\n         MVC   MTSMSG(E03L),E03          MSG TO WORKAREA\n         MVC   MTSMSG+E03P1(L'MTSSID),MTSSID   SUBSYS NAME TO MSG\n         B     ERREXIT\n         SPACE 2\nLDERRET  DS    0H                        INIT MODULE NOT FOUND\n         MVC   MTSMSG(E04L),E04          MSG TO WORKAREA\n         MVC   MTSMSG+E04P1(L'MTSSID),MTSSID   SUBSYS NAME TO MSG\n         MVC   MTSMSG+E04P2(L'MTSLMOD),MTSLMOD     EP TO MESSAGE\n         B     ERREXIT\n         SPACE 2\nERR03000 DS    0H\n         MVC   MTSMSG(E05L),E05          MSG TO WORKAREA\n         MVC   MTSMSG+E05P1(L'MTSSID),MTSSID   SUBSYS NAME TO MSG\n         B     ERREXIT\n         SPACE 2\nERR04000 DS    0H\n         MODESET KEY=NZERO,MODE=PROB     OUT OF SUPERVISOR STATE\n         MVC   MTSMSG(E06L),E06          MSG TO WORKAREA\n         MVC   MTSMSG+E06P1(L'MTSSID),MTSSID   SUBSYS NAME TO MSG\n         SPACE 2\nERREXIT  DS    0H\n         WTO   MF=(E,MTSMSG)             PUT OUT MESSAGE\n         LA    R15,4\n         B     RETURN\n         EJECT\n*---------------------------------------------------------------------*\n*        PROGRAM DATA AREAS                                           *\n*---------------------------------------------------------------------*\n         SPACE\n         PRINT NOGEN\n         SPACE\nE01      WTO  'MTSS03E - SUBSYSTEM MODIFY FAILED - INVALID PARM',      X\n               ROUTCDE=(2,11),DESC=4,MF=L\nE01L     EQU  *-E01\n         SPACE 3\nE02      WTO  'MTSS04E - SUBSYSTEM XXXX NOT FOUND',ROUTCDE=(2,11),     X\n               DESC=4,MF=L\nE02L     EQU  *-E02\nE02P1    EQU  4+20\n         SPACE 3\nE03      WTO  'MTSS05E - SUBSYSTEM XXXX - MODIFY NOT VALID ',          X\n               ROUTCDE=(2,11),DESC=4,MF=L\nE03L     EQU  *-E03\nE03P1    EQU  4+20\n         SPACE 3\nE04      WTO  'MTSS06E - XXXX INITIALIZATION MODULE, XXXXXXXX, NOT FOUNX\n               D',ROUTCDE=(2,11),DESC=4,MF=L\nE04L     EQU  *-E04\nE04P1    EQU  4+10\nE04P2    EQU  4+38\n         SPACE 3\nE05      WTO  'MTSS07E - SUBSYSTEM XXXX - NOT STARTED, ALREADY ACTIVE',X\n               ROUTCDE=(2,11),DESC=4,MF=L\nE05L     EQU  *-E05\nE05P1    EQU  4+20\n         SPACE 3\nE06      WTO  'MTSS08E - SUBSYSTEM XXXX - NOT STOPPED, NOT ACTIVE',    X\n               ROUTCDE=(2,11),DESC=4,MF=L\nE06L     EQU  *-E06\nE06P1    EQU  4+20\n         SPACE 3\nM01      WTO  'MTSS02I - SUBSYSTEM XXXX IS NOW INACTIVE',              X\n               ROUTCDE=(2,11),DESC=4,MF=L\nM01L     EQU  *-M01\nM01P1    EQU  4+20\n         SPACE 3\nTSSTABLE DC    V(TSSNAMES)\nXXXMTSSS DS   0F\n         DC    AL1(MTSPOOL)\n         DC    AL3(MTSWKL)\nBLANKS   DC    CL8' '\nZERO     DC    X'00000000'\nHEXFF    DC    X'FFFFFFFF'\nMSTRASID DC    X'0001'\nJESID    DC    C'JES'\nMSTRID   DC    C'MSTR'\n         SPACE\nKWDTBL   DS   0F                    PROGRAM OPTION - OPT\n         DC    A(PRM01200)\n         DC    AL1(POPT)\n         DC    AL1(L'OPT)\nOPT      DC    C'OPT'\n         SPACE\n         DS   0F                    SUBSYSTEM ID - SSID\n         DC    A(PRM01300)\n         DC    AL1(PSSID)\n         DC    AL1(L'SSID)\nSSID     DC    C'SSID'\n         SPACE\n         DS   0F                    ENTRY POINT NAME - EP\n         DC    A(PRM01700)\n         DC    AL1(PEP)\n         DC    AL1(L'EP)\nEP       DC    C'EP'\n         SPACE\n         DS   0F                    END OF TABLE ENTRY\n         DC    A(0)\n         DC    AL1(0)\n         SPACE\n         LTORG\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        SUBSYSTEM VALIDATION TABLE                                   *\n*                                                                     *\n*        NON-EXECUTABLE CSECT                                         *\n*                                                                     *\n*        ONLY THE SUBSYSTEMS WHOSE NAMES APPEAR IN                    *\n*        THIS TABLE MAY BE MODIFIED BY THIS PROGRAM                   *\n*                                                                     *\n*        EACH ENTRY IS FOUR BYTES AND CONTAINS THE NAME               *\n*        OF A SUBSYSTEM.  BLANK AND HEX ZERO ENTRIES ARE              *\n*        IGNORED.  THE LAST ENTRY MUST CONTAIN X'FF'S.                *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nTSSNAMES AMODE 31\nTSSNAMES RMODE 24\nTSSNAMES CSECT\n         DC   C'CCSS'\n         DC   C'    '             AVAILABLE ENTRY\n         DC   C'    '             AVAILABLE ENTRY\n         DC   C'    '             AVAILABLE ENTRY\n         DC   C'    '             AVAILABLE ENTRY\n         DC   C'    '             AVAILABLE ENTRY\n         DC   C'    '             AVAILABLE ENTRY\n         DC   C'    '             AVAILABLE ENTRY\n         DC   C'    '             AVAILABLE ENTRY\n         DC   C'    '             AVAILABLE ENTRY\n         DC   C'    '             AVAILABLE ENTRY\n         DC   C'    '             AVAILABLE ENTRY\n         DC   C'    '             AVAILABLE ENTRY\n         DC   C'    '             AVAILABLE ENTRY\n         DC   C'    '             AVAILABLE ENTRY\n         DC   X'FFFFFFFF'         END OF TABLE\n         SPACE 5\n*---------------------------------------------------------------------*\n*        DSECT FOR VALIDATION TABLE                                   *\n*---------------------------------------------------------------------*\nTSSTBL   DSECT\nTSSNAME  DS   CL4\nTSSLEN   EQU  *-TSSTBL\n         EJECT\n*---------------------------------------------------------------------*\n*        DSECT FOR PROGRAM WORK AREAS                                 *\n*---------------------------------------------------------------------*\n         SPACE\nMTSSWK   DSECT\nMTSAVE   DS  18F                         REGISTER SAVE AREA\nMTSID    DS    CL8                       WORKAREA LABEL\nMTSPRMAD DS    F                         A(CALLER'S PARM)\nMTSSS    DS    F                         WKAREA SUBPOOL AND SIZE\nMTSSID   DS    CL4                       SUBSYSTEM ID\nMTSSCTAD DS    F                         A(SUBSYSTEM SCT)\nMTSLMOD  DS    CL8                       LOAD MODULE EP\nMTSLMODA DS    F                         A(LMOD EP)\nMTSPFLGS DS    BL1                       PARM FLAGS\nFIND     EQU   X'80'                       LOCATE CHAR SUBROUTINE FLAG\nPEP      EQU   X'04'                       EP KEYWORD FOUND\nPSSID    EQU   X'02'                       SSID KEYWORD FOUND\nPOPT     EQU   X'01'                       OPT KEYWORD FOUND\nMTSOPT   DS    BL1                       OPTION FLAGS\nSTART    EQU   X'01'                       START,INITIALIZE SUBSYSTEM\nSTOP     EQU   X'02'                       STOP,REMOVE SUBSYSTEM\nRESET    EQU   X'03'                       STOP THEN START SUBSYSTEM\n         DS   0F\nMTSLNK0  DS    F                         SUBROUTINE LINKAGE SAVEARAEA\nMTSMSG   DS    XL100\nMTSWKL   EQU   *-MTSSWK\nMTSPOOL  EQU   00\n         SPACE\n*---------------------------------------------------------------------*\n*        DSECT FOR KEYWORD TABLE                                      *\n*---------------------------------------------------------------------*\nKWDENTRY DSECT\nKWDRTN   DS   A                          A(VERIFICATION ROUTINE)\nKWDFLG   DS   AL1                        VALUE OF PARM FLAG\nKWDLEN   DS   AL1                        LENGTH OF KEYWORD\nKWDKEY   DS  0C                          KEYWORD  (VARIABLE LENGTH)\n*                                                                     *\n*        ENTRIES ARE ALIGNED ON FULLWORDS                             *\n*                                                                     *\n         EJECT\n*        PRINT NOGEN\n*---------------------------------------------------------------------*\n*        DSECT FOR TIOT                                               *\n*---------------------------------------------------------------------*\n         SPACE\nTIOT     DSECT\n         IEFTIOT1\n         SPACE\n*---------------------------------------------------------------------*\n*        DSECT FOR TCB                                                *\n*---------------------------------------------------------------------*\n         SPACE\n         IKJTCB\n         SPACE\n*---------------------------------------------------------------------*\n*        DSECT FOR CVT\n*---------------------------------------------------------------------*\n         SPACE\n         CVT   DSECT=YES\n         SPACE\n*---------------------------------------------------------------------*\n*        DSECT FOR SSCT                                               *\n*---------------------------------------------------------------------*\n         SPACE\n         IEFJSCVT\n*---------------------------------------------------------------------*\n*        DSECT FOR JESCT                                              *\n*---------------------------------------------------------------------*\n         SPACE\n         IEFJESCT\n         EJECT\n*---------------------------------------------------------------------*\n*        MISCELLANEOUS EQUATES                                        *\n*---------------------------------------------------------------------*\n         SPACE\nR0       EQU       0\nR1       EQU       1\nR2       EQU       2\nR3       EQU       3\nR4       EQU       4\nR5       EQU       5\nR6       EQU       6\nR7       EQU       7\nR8       EQU       8\nR9       EQU       9\nR10      EQU      10\nR11      EQU      11\nR12      EQU      12\nR13      EQU      13\nR14      EQU      14\nR15      EQU      15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MTSSA00": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\t/\\x00\\x98\\t/\\t\"\\x00\\xd3\\x00\\xd3\\x00\\x00|\\xe3\\xe2\\xe2\\xe8\\xf5\\xf9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-04-02T00:00:00", "modifydate": "1998-04-02T09:22:00", "lines": 211, "newlines": 211, "modlines": 0, "user": "@TSSY59"}, "text": "     TITLE 'CSECT: TSSACTV'\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        TSSACTV - ACTIVATE TRANSIENT SUBSYSTEM                       *\n*                                                                     *\n*                                                                     *\n*        HOOK SUBSYSTEM SSVT TO SSCVT                                 *\n*                                                                     *\n*                                                                     *\n*        THIS PROGRAM MAY BE USED AS AN INITIALIZATION FOR            *\n*        FOR ALL SIMPLE SUBSYSTEMS.  BY SIMPLE IS MEANT A             *\n*        SUBSYTEM WHOSE INTIALIZATION ROUTINE REQUIRES NOTHING        *\n*        OTHER THAN THE LINKING OF THE SSVT AND SSCVT.  SUCH          *\n*        A SUBSYSTEM MUST CONTAIN AN LPA RESIDENT MODULE WHOSE        *\n*        NAME IS THE SAME AS THE SUBSYSTEM NAME AND WHOSE ENTRY       *\n*        POINT IS THE SUBSYSTEM'S COMPLETED SSVT.  SUCH A SUB-        *\n*        SYSTEM SHOULD BE TRANSIENT, I.E., NOT EXECUTE IN ITS         *\n*        OWN ADDRESS SPACE.                                           *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        MODULE ENTERED IN MASTER KEY ZERO                            *\n*                                                                     *\n*        UPON ENTRY REG. 1 = A(A(SSCVT))                              *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        POTENTIAL CALLERS:                                           *\n*                                                                     *\n*        1. DIRECTLY BY MASTER SCHEDULER TO INITIALIZE SIMPLE         *\n*           TRANSIENT SUBSYSTEMS DURING IPL.                          *\n*                                                                     *\n*        2. BY MODIFY ROUTINES OR PROGRAMS (MTSS) THAT EMULATE        *\n*           THE MASTER SCHEDULER IN CALLING SUBSYSTEM INITIALI-       *\n*           ZATION ROUTINES.                                          *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*        PROGRAM INITIALIZATION                                       *\n*                                                                     *\n*               R9  = SSCT BASE                                       *\n*               R12 = BASE = MODULE ADDRESSIBILITY                    *\n*               R13 = SAVE AREA AND WORKAREA BASE                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nTSSACTV  AMODE 31\nTSSACTV  RMODE 24\nTSSACTV  CSECT\n         STM   R14,R12,12(R13)           SAVE REGISTERS\n         LR    R12,R15                   LOAD BASE\n         USING TSSACTV,R12               DECLARE BASE\n         B     TSSA0000                  BRANCH AROUND CSECT ID\n         DC    C'TSSACTV &SYSDATE'\nTSSA0000 DS    0H\n         LR    R5,R1                     SAVE PTR TO PARM ADDRESS\n         LA    R3,TSSAL                  SET LENGTH OF WORK AREA\n         GETMAIN R,LV=(3)                GET A WORKAREA\n         LR    R2,R1                     A(AREA) FOR MVCL\n         SR    R14,R14                   NO SOURCE\n         SR    R15,R15                   NO SOURCE LENGTH\n         MVCL  R2,R14                    ZERO THE AREA\n         ST    R13,4(,R1)                CHAIN THE\n         ST    R1,8(,R13)                   SAVE AREAS\n         LR    R13,R1                    NEW SAVE AREA\n         USING TSSA,R13                  BASE FOR WORK AREA\n         MVC   TSAID,=C'TSSA'            LABEL WORKAREA\n         ST    R5,TSAPRMAD               SAVE R1 ENTRY PARM (TRACE)\n         L     R9,0(,R5)                 GET A(SSCT)\n         USING SSCT,R9                   SSCT ADDRESSIBILITY\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*        LOCATE SSVT AND POINT SSCT TO IT                             *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         MVI   TSALMOD,X'40'             CLEAR THE LOAD MODULE NAME\n         MVC   TSALMOD+1(L'TSALMOD-1),TSALMOD   TO BLANKS THEN SET TO\n         MVC   TSALMOD(L'SSCTSNAM),SSCTSNAM     SUBSYSTEM NAME\n         LA    R0,TSALMOD                A(ENTRY POINT NAME)\n         LA    R2,TSSAE010               A(ERROR ROUTINE)\n         LOAD  EPLOC=(0),ERRET=(2)       FIND A(SUBSYSTEM SSVT)...\n         ST    R0,SSCTSSVT               ...PUT INTO SSCT\n         ST    R0,TSAEPAD                ...PUT INTO WKAREA (TRACE)\n         SPACE 5\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*        PUT OUT INITIALIZATION MESSAGE                               *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         MVC   TSAMSG(M01L),M01          MSG TO WORKAREA\n         MVC   TSAMSG+M01P1(L'SSCTSNAM),SSCTSNAM   SUBSYS NAME TO MSG\n         WTO   MF=(E,TSAMSG)             PUT OUT MESSAGE\n         SLR   R15,R15                   RETURN CODE = ZERO\n         B     TSSARTN0                  RETURN TO CALLER\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*        ERROR LOAD MODULE NOT FOUND                                  *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\nTSSAE010 DS    0H\n         MVC   TSAMSG(E01L),E01          MSG TO WORKAREA\n         MVC   TSAMSG+E01P1(L'SSCTSNAM),SSCTSNAM   SUBSYS NAME TO MSG\n         MVC   TSAMSG+E01P2(L'TSALMOD),TSALMOD     EP TO MESSAGE\n         WTO   MF=(E,TSAMSG)             PUT OUT MESSAGE\n         LA    R15,4                     RETURN CODE = 4 = ERROR\n         B     TSSARTN0                  RETURN TO CALLER\n         SPACE 5\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*        RETURN TO CALLER                                             *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         DROP R9                         DROP SSCT ADDRESSIBILITY\n         SPACE\nTSSARTN0 DS    0H\n         L     R9,TSASAVE+4              GET A(CALLER'S SAVE)\n         LR    R10,R15                   SAVE RETURN CODE\n         FREEMAIN RU,LV=TSSAL,A=(13)     FREE WORKING STORAGE\n         LR    R15,R10                   SET RETURN CODE\n         LR    R13,R9                    CALLER'S SAVE AREA PTR\n         RETURN (14,12),RC=(15)\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*        DATA AREAS                                                   *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\nM01      WTO  'MTSS01I - SUBSYSTEM XXXX IS NOW ACTIVE',ROUTCDE=(2,11), X\n               DESC=4,MF=L\nM01L     EQU  *-M01\nM01P1    EQU  4+20\n         SPACE 3\nE01      WTO  'MTSS09E - SUBSYSTEM XXXX NOT INITIALIZED SSVT MODULE, XXX\n               XXXXXX, NOT FOUND',ROUTCDE=(2,11),DESC=4,MF=L\nE01L     EQU  *-E01\nE01P1    EQU  4+20\nE01P2    EQU  4+54\n         SPACE 3\n         LTORG\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*        DSECT FOR PROGRAM WORK AREAS                                 *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\nTSSA     DSECT\nTSASAVE  DS    18F                       REGISTER SAVE AREA\nTSAID    DS    CL8                       WORKAREA LABEL\nTSAPRMAD DS    F                         A(CALLER'S PARM)\nTSALMOD  DS    CL8                       LOAD MODULE EP\nTSAEPAD  DS    F                         EP ADDRESS\nTSAMSG   DS    XL100                     MESSAGE WORKAREA\nTSSAL    EQU   *-TSSA\n         SPACE 5\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECT FOR SSCT                                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 2\n         PRINT NOGEN\n         IEFJSCVT\n         EJECT\n*---------------------------------------------------------------------*\n*        MISCELLANEOUS EQUATES                                        *\n*---------------------------------------------------------------------*\n         SPACE\nR0       EQU       0\nR1       EQU       1\nR2       EQU       2\nR3       EQU       3\nR4       EQU       4\nR5       EQU       5\nR6       EQU       6\nR7       EQU       7\nR8       EQU       8\nR9       EQU       9\nR10      EQU      10\nR11      EQU      11\nR12      EQU      12\nR13      EQU      13\nR14      EQU      14\nR15      EQU      15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT364/FILE364.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT364", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}