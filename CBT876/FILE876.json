{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013156000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 16048578, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE876.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 16048578, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 16048578, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE876.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\xf5\\x05'", "DS1TRBAL": "b'\\x87\\xde'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x07\\x87\\x00\\x08\\x07\\x97\\x00\\r\\x00\\xf6'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04U\\x00\\x07\\x01\\x12$\\x8f\\x01\\x12$\\x8f#8\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf5@@@'", "ispf": {"version": "04.85", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T23:38:07", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-485"}, "text": "REGULAR CBT TAPE - VERSION 485    FILE:  876\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT485.FILE876\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 23 MEMBERS COUNTED; CUMULATIVE SIZE IS 152,522 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   09/04/12    23:38:07    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x02\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x141\\x00^\\x00Z\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T14:31:02", "lines": 94, "newlines": 90, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Algol F Level 2.1 ICR\nFrom:     <thomasjarmst@optusnet.com.au>\nDate:     9/3/2012 9:56 PM\nTo:       opplr@hotmail.com, sbgolob@cbttape.org\n\nDear Phil and Sam,\n\nI am reluctant to establish my own website to host the updated IBM\nAlgol F Compiler and Library as I would prefer not to see various\nHercules oriented MVS 3.8 software updates fragmented across\ndifferent websites.  To that end I have contributed my previous MVS\n3.8 system updates to Greg Price and he has generously hosted them\nfor me.  Greg's excellent site has now become recognized as being\nthe home for many MVS 3.8 modifications.  My next contribution,\nwhen completed, being improvements to GTF SVC tracing, GTRACE data\nand AMDPRDMP trace formatting will be contributed to Greg for\nhosting as Greg has already has made enhancements to GTF/AMDPRDMP\nand my enhancements build on top of his previous work in these\ncomponent areas.\n\nInitially I considered Jay Moseley's website would be an appropriate\nsite to host the updated IBM Algol F Compiler and Library as his\nsite seems to be the recognized site for MVS 3.8 language\nprocessors.  I decided to postpone sending my materials to him.\n\nI would therefore like to contribute the updated Algol Compiler\nand Library to a site for hosting so I would be grateful if you,\nSam, would host the updates on CBTTAPE.\n\nThere are three deliverables as part of the Algol update which I\nhave termed an Independent Component Release for MVS.\n\nFirstly a HET format tape containing the updated Compiler modules,\nLibrary modules, PROCLIB members, IVP SAMPLIB members and an\nexample zap to change relevant Compiler options for the MVS\nenvironment.  A PDF of a General Information Manual is also\nprovided that describes the small programming improvements to the\nCompiler and Library, the installation process, running the IVP\njobs and sample output from the IVP jobs together with\ninstructions on how to change the default Compiler options. The\nICR GIM does not describe the many internal changes made to the\nCompiler and Library as described in my email to Phil as most\nusers would not be interested in the significant internal\nreformatting of the assembler source code.  Except for the missing\nsource code in module IEX50, recovered by disassembly, it is\nreasonable to say that the source code is now in better condition\nfor the MVS environment than when it left the IBM Nordic labs.\n(Tape image was converted to AWS from HET for non-Hercules users. SBG)\nMember in this pds:   ALGOLF21\n\nThe second deliverable is a HET format tape containing the assembler\nsource and macro libraries needed to build and link edit the updated\nAlgol Compiler and Library.\n(Tape image was converted to AWS from HET for non-Hercules users. SBG)\nMember in this pds:   ALG21SRC\n\nThe third deliverable is a modern replacement for the optional IBM\nmicrofiche listings of the source code assemblies of the Algol\nCompiler and Library. The assembly listings match the updated load\nmodules.\n\nPhil raised with me a matter regarding missing modules. The\nCBTTAPE distribution of the original IBM version of the Compiler\nand Library is not missing any modules. However the Jay Moseley\ndistribution is missing the dynamically loaded Algol Library\nerror handling module IHIERR and its alias of IHIERROR. An Algol\nProgram runtime error, using the Jay Moseley distribution, will\nfail with an S806 attempting to LOAD IHIERR instead of an Algol\nruntime error message and dump. As there is only one dynamically\nloaded runtime module for Algol I decided to simplify the\ndistribution and make IHIERR/IHIERROR a resident runtime module\nresolved at LINK EDIT time to avoid any future issues. This\nchange adds an additional 5K to the size of an Algol program load\nmodule which is insignificant in the MVS context.\n\nI have not shipped the updated Algol Compiler and Library to\nanyone other than Phil so I would appreciate it if both of you\ncould install the ICR in your systems and provide me with any\nfeedback that would improve the proposed distributed materials.\nThe current method of packaging was designed to be compatible\nwith Jay Moseley's site and is not compatible with the usual\nCBTTAPE method of packaging. I would welcome any suggestions you\nmake Sam on the best way to package for your site.\n\n(I have repackaged everything.  Please see member @FILE876. SBG)\n\nI have attached a zip of the ICR GIM and load module HET tape to\nthis email and will send the other two deliverables in separate\nemails.\n\nRegards\nTom Armstrong\n<thomasjarmst@optusnet.com.au>\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE02": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\\x13\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x16\\x16\\x00s\\x00.\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T16:16:13", "lines": 115, "newlines": 46, "modlines": 0, "user": "SBGOLOB"}, "text": "Installation notes from Sam Golob.        for ALGOL F 2.1\n------------ ----- ---- --- -----         from Tom Armstrong\n\n    As an introductory note, I wish to thank Tom Armstrong for\n    doing an enormous amount of work, to fix and polish the ALGOL F\n    compiler and library, and to make sure that they could also be\n    assembled and linkedited from source code.  All the materials\n    necessary for this, should be packaged in this file.\n\n    I also wish to thank Phil Roberts, without whose input, I would\n    never have heard of this beautiful piece of work.\n\n    I am bearing in mind, that people who are running z/OS might\n    also want to use these materials, as well as people who are\n    running MVS 3.8J and also OS/360.  If something from this file\n    does not work on any of these platforms, please inform me, and\n    I'll try to set things right for everyone.\n\n    email:  sbgolob@cbttape.org   or  sbgolob@attglobal.net\n\nFull Documentation:\n\n    Documentation for the compiler, library, and general information\n    is provided by means of PDF-format members of this pds, which\n    should be downloaded to a PC in BINARY for reading, using the\n    Adobe Acrobat reader, or equivalent (Foxit, etc.)\n\n    These members are:\n\n        #COMPILR - compiler documentation manual\n        #GENINFO - general information manual\n        #LIBRARY - library documentation manual\n\n    Sample output to compare ALGOL F version 2 from IBM, with\n    ALGOL F 2.1 from Tom Armstrong, are PDF files, which have\n    been put here as members AL20SAMP and AL21SAMP, respectively.\n\n\nInstallation help and instruction:\n\nA.  The two AWS-format file members.\n\n    1.  Member ALGOLF21 in this pds is an AWS-format image of the\n        tape whose volser is ALGOLF, that was submitted to me by\n        Tom Armstrong.  You can download this member in BINARY to\n        a PC that is running Hercules, and you can use it from\n        there.  If you don't have Hercules, you can convert this\n        member (under MVS) to a real tape, using the VTT2TAPE\n        program from File 533 of the CBT Tape.  If you do not want\n        to use this AWS tape image, its files have already been\n        put into this CBT Tape file, as members:\n\n          AL21FCMP - ALGOL F 2.1 compiler\n          AL21FIVP - IVP\n          AL21FJCL - IEBCOPY JCL to load from the ALGOLF tape\n          AL21FLIB - ALGOL F 2.1 execution library\n          AL21FPRC - ALGOL F 2.1 JCL procedures for PROCLIB\n\n    2.  Member ALG21SRC in this pds is an AWS-format image of the\n        tape whose volser is ALGSRC, that was submitted to me by\n        Tom Armstrong.  You can download this member in BINARY to\n        a PC that is running Hercules, and you can use it from\n        there.  If you don't have Hercules, you can convert this\n        member (under MVS) to a real tape, using the VTT2TAPE\n        program from File 533 of the CBT Tape.  If you do not want\n        to use this AWS tape image, its files have already been\n        put into this CBT Tape file, as members:\n\n          AL21LASM - Source code to assemble the LIBRARY modules\n          AL21LMAC - Macros needed to assemble the LIBRARY modules\n          AL21SASM - Source code to assemble the COMPILER modules\n          AL21SCTL - Assembly JCL to build the COMPILER and LIBRARY\n          AL21SMAC - Macros needed to assemble the COMPILER modules\n\n    3.  PDSLOAD format, or IEBUPDTE format:  (create new pds'es)\n\n        With the exception of the AL21FCMP and AL21FLIB members,\n        which are in TSO XMIT format, most of the other members\n        from Tom's 2 tapes, are packaged in IEBUPDTE \"unloaded pds\"\n        format.  But if you want to preserve the ISPF statistics\n        for the members in these pds'es, you should use the PDSLOAD\n        program (CBT File 093) to unload them, rather than IBM's\n        IEBUPDTE program.  I have provided JCL for this purpose,\n        and also some other materials to make it possible for you\n        to conveniently run the PDSLOAD program.\n\n        See member #PDSLOAD, which contains an object deck for\n        PDSLOAD, together with convenient LINKEDIT JCL.  Just\n        create the output load library, and put a job card in\n        front of the member to linkedit the load module.\n\n        See member $PDSLOAD, which contains JCL to create most\n        of the pds'es that are needed.  The only other pds'es\n        needed, are the compiler and library load libraries.\n        These are members AL21FCMP (compiler) and AL21FLIB\n        (library) which are in TSO XMIT format.\n\n        If you have access to the TSO RECEIVE command,\n        then execute:\n\n        TSO RECEIVE INDS (this.pds(AL21FCMP))   to get the compiler\n        TSO RECEIVE INDS (this.pds(AL21FLIB))   to get the library\n\n        Otherwise, run the IEBCOPY parts of the AL21FJCL member\n        to download the compiler and library from AWS-format tape.\n        You can get the tape image for running on HERCULES by\n        downloading member ALGOLF21 from this pds, in BINARY,\n        to a pc file, and running it as an AWS-format tape\n        under Hercules, using the Hercules devinit command to\n        mount it.\n\n  Questions and problems:   Sam Golob    sbgolob@cbttape.org\n                                         sbgolob@attglobal.net\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PDSLOAD": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x07\\x008\\x00\\x98\\x01/\\x01\\x13'O\\x01#\\x00\\x1c\\x00\\x0c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.07", "flags": 0, "createdate": "1998-01-12T00:00:00", "modifydate": "2013-10-01T01:23:38", "lines": 28, "newlines": 12, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBA  JOB (ACCT#),S-GOLOB,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//*\n//PDSLOAD PROC IPRE='SBGOLOB.CBT487.FILE876',        (THIS PDS)\n//             MEMIN=XXX,\n//             MEMOUT=YYY,\n//             OPRE=SBGOLOB,                         (CHANGE)\n//             OVL=WORKE2,                           (CHANGE)\n//             OUNT=SYSDA,                           (CHANGE)\n//             TYPEL='ALGOLF',                       (TAPE OF ORIGIN)\n//             P=30,S=150,D=137,\n//             DSP1=NEW,DSP2=CATLG,DSP3=DELETE\n//LOAD EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=SYS2.PDSLOAD.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD DISP=SHR,DSN=&IPRE(&MEMIN)\n//SYSUT2 DD UNIT=&OUNT,VOL=SER=&OVL,DSN=&OPRE..&TYPEL..&MEMOUT,\n//       DISP=(&DSP1,&DSP2,&DSP3),SPACE=(TRK,(&P,&S,&D),RLSE)\n//  PEND\n//AL21FIVP EXEC PDSLOAD,TYPEL='ALGOLF',MEMIN=AL21FIVP,MEMOUT=IVP\n//AL21FJCL EXEC PDSLOAD,TYPEL='ALGOLF',MEMIN=AL21FJCL,MEMOUT=JCL\n//AL21FPRC EXEC PDSLOAD,TYPEL='ALGOLF',MEMIN=AL21FPRC,MEMOUT=PRC\n//AL21LASM EXEC PDSLOAD,TYPEL='ALGSRC',MEMIN=AL21LASM,MEMOUT=LIBASM\n//AL21LMAC EXEC PDSLOAD,TYPEL='ALGSRC',MEMIN=AL21LMAC,MEMOUT=LIBMACS\n//AL21SASM EXEC PDSLOAD,TYPEL='ALGSRC',MEMIN=AL21SASM,MEMOUT=CMPASM\n//AL21SCTL EXEC PDSLOAD,TYPEL='ALGSRC',MEMIN=AL21SCTL,MEMOUT=CMPCNTL\n//AL21SMAC EXEC PDSLOAD,TYPEL='ALGSRC',MEMIN=AL21SMAC,MEMOUT=CMPMACS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "##PDSLOA": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x15\\x01\\x00\\x9d\\x00\\x9d\\x00\\x00\\xd6\\xc2\\xd1\\xc4\\xc5\\xc3\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T15:01:00", "lines": 157, "newlines": 157, "modlines": 0, "user": "OBJDECK"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "#COMPILR": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x16\\t\\xa1\\xd4\\xa1\\xd4\\x00\\x00\\xd7\\xc4\\xc6@@@@@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T16:09:00", "lines": 41428, "newlines": 41428, "modlines": 0, "user": "PDF"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}, "#GENINFO": {"ttr": 17416, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x16\\t\\x170\\x170\\x00\\x00\\xd7\\xc4\\xc6@@@@@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T16:09:00", "lines": 5936, "newlines": 5936, "modlines": 0, "user": "PDF"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}, "#LIBRARY": {"ttr": 19971, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x16\\teWeW\\x00\\x00\\xd7\\xc4\\xc6@@@@@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T16:09:00", "lines": 25943, "newlines": 25943, "modlines": 0, "user": "PDF"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}, "#PDSLOAD": {"ttr": 30469, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00U\\x01\\x12$\\x8f\\x01\\x13'O\\x01\\x19\\x00\\x9d\\x00\\x9d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2013-10-01T01:19:55", "lines": 157, "newlines": 157, "modlines": 0, "user": "SBGOLOB"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "@FILE876": {"ttr": 30473, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x04U\\x00\\x00\\x01\\x12$\\x8f\\x01\\x12$\\x8f#8\\x00'\\x00'\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf5@@@\"", "ispf": {"version": "04.85", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T23:38:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "CBT-485"}, "text": "//***FILE 876 is from Tom Armstrong, and contains the ALGOL F       *   FILE 876\n//*           Version 2.1 compiler.  This is a complete reworking   *   FILE 876\n//*           of the ALGOL F version 2 compiler from IBM, for       *   FILE 876\n//*           which the materials are contained in CBT Overflow     *   FILE 876\n//*           tape, File 089, and CBT Tape files 309 and 310.       *   FILE 876\n//*           Many thanks are also due to Phil Roberts.             *   FILE 876\n//*                                                                 *   FILE 876\n//*           Included in this file is the ALGOL F 2.1 compiler     *   FILE 876\n//*           and library, in source and executable code.  All of   *   FILE 876\n//*           it can be assembled and linkedited, directly from     *   FILE 876\n//*           the supplied source code.                             *   FILE 876\n//*                                                                 *   FILE 876\n//*           This is a complete and thorough rework of the IBM     *   FILE 876\n//*           ALGOL F Version 2 compiler and library.               *   FILE 876\n//*                                                                 *   FILE 876\n//*           email:  thomasjarmst@optusnet.com.au                  *   FILE 876\n//*                                                                 *   FILE 876\n//*           Care was taken in this file, to include PDF format    *   FILE 876\n//*           documentation, and (hopefully) enough material to     *   FILE 876\n//*           enable installation of this compiler and library      *   FILE 876\n//*           from both z/OS and MVS 3.8J, as well as OS/360.       *   FILE 876\n//*                                                                 *   FILE 876\n//*           Images of the AWS-format tapes from Tom Armstrong     *   FILE 876\n//*           have been included here, as members:                  *   FILE 876\n//*                                                                 *   FILE 876\n//*           ALGOLF21 - ALGOL F 2.1 compiler and library           *   FILE 876\n//*           ALG21SRC - ALGOL compiler and library source code     *   FILE 876\n//*                                                                 *   FILE 876\n//*           Please see member $$NOTE01 for background, and        *   FILE 876\n//*           especially member $$NOTE02 for installation           *   FILE 876\n//*           instructions.                                         *   FILE 876\n//*                                                                 *   FILE 876\n//*           Additionally:                                         *   FILE 876\n//*                                                                 *   FILE 876\n//*           email:   opplr@hotmail.com      (Phil Roberts)        *   FILE 876\n//*                                                                 *   FILE 876\n//*           email:   sbgolob@cbttape.org    (Sam Golob)           *   FILE 876\n//*                    sbgolob@attglobal.net                        *   FILE 876\n//*                                                                 *   FILE 876\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ALGOLF21": {"ttr": 30475, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x14\\x18\\x0c;\\x0c;\\x00\\x00\\xc1\\xe6\\xe2\\xc3\\xd4\\xd7\\xd3@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T14:18:00", "lines": 3131, "newlines": 3131, "modlines": 0, "user": "AWSCMPL"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ALG21SRC": {"ttr": 31752, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x14\\t\\x8b\\x86\\x8b\\x86\\x00\\x00\\xc1\\xe6\\xe2\\xe2\\xd6\\xd9\\xc3@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T14:09:00", "lines": 35718, "newlines": 35718, "modlines": 0, "user": "AWSSORC"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "AL20SAMP": {"ttr": 46342, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x16\\x07\\x02F\\x02F\\x00\\x00\\xd7\\xc4\\xc6@@@@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T16:07:00", "lines": 582, "newlines": 582, "modlines": 0, "user": "PDF"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}, "AL21FCMP": {"ttr": 46598, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x13F\\x04.\\x04.\\x00\\x00\\xc3\\xd6\\xd4\\xd7\\xc9\\xd3\\xd9@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T13:46:00", "lines": 1070, "newlines": 1070, "modlines": 0, "user": "COMPILR"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "AL21FIVP": {"ttr": 47108, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x138\\x04\\x87\\x04\\x87\\x00\\x00\\xc9\\xe5\\xd7\\xd3\\xc9\\xc2@@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T13:38:00", "lines": 1159, "newlines": 1159, "modlines": 0, "user": "IVPLIB"}, "text": "./ ADD NAME=IEXOPTNS 0201-12230-12230-1200-00058-00058-00000-LEVEL\n//T1ACO   JOB  111,'ALGOL F LVL2.1',   <-- CUSTOMIZE FOR SITE STANDARDS\n//             CLASS=S,MSGCLASS=C,     <-- CUSTOMIZE FOR SITE STANDARDS\n//             REGION=1024K,COND=(0,NE),MSGLEVEL=(1,1)\n//*\n//*       IBM Algol F Level 2.1\n//*\n//*       360S-AL-531 Algol F Compiler\n//*\n//*       Set Compiler Default Options\n//*\n//SETOPTS EXEC PGM=AMASPZAP\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS2.LINKLIB,DISP=SHR\n//SYSIN    DD  *\n*\n*          Set Algol F Level 2.1 Compiler Default Options\n*\n*          For a complete explanation of the Options refer to -\n*\n*          GC28-6554-13 OS System Generation Release 21.8\n*                       and\n*          GC33-4000-00 Algol Programmers Guide\n*\n*          Option                    POSITION\n*                                    BYTE 0    BYTE 1\n*          Bit Settings              01234567  01234567\n*\n*          Internal Compiler Use     0\n*          Internal Compiler Use      0\n*          Internal Compiler Use       0\n*          Internal Compiler Use        0\n*          Internal Compiler Use         0\n*          Internal Compiler Use          0\n*          LONG/SHORT PRECISION            0              0 = SHORT\n*          Internal Compiler Use            0\n*\n*          NOSOURCE/SOURCE                     0          0 = SOURCE\n*          NOLOAD/LOAD                          0         0 = LOAD\n*          NODECK/DECK                           1        1 = NODECK\n*          ISO/EBCDIC                             0       0 = EBCDIC\n*          Internal Compiler Use                   0\n*          Internal Compiler Use                    0\n*          Internal Compiler Use                     1\n*          Internal Compiler Use                      0\n*\n*          Verify Default settings of -\n*          PRECISN=SHORT\n*          SORLIST=SOURCE\n*          TYPERUN=LOAD\n*          PUNCH=NODECK\n*          SORCODE=EBCDIC\n*\n           NAME IEX00 IEX00001\n           VER  80    0022        Verify Default Settings\n           REP  80    0022        <- Change options\n           IDRDATA    IEXOPTNS\n/*\n//\n./ ADD NAME=IEXSAMP1 0201-12230-12230-1200-00077-00077-00000-LEVEL\n//T1IV1   JOB  111,'ALGOL F LVL2.1',   <-- CUSTOMIZE FOR SITE STANDARDS\n//             CLASS=S,MSGCLASS=C,     <-- CUSTOMIZE FOR SITE STANDARDS\n//             REGION=1024K,COND=(0,NE),MSGLEVEL=(1,1)\n//*\n//*       IBM Algol F Level 2.1 IVP\n//*\n//*       360S-AL-531 Algol F Compiler\n//*            and\n//*       360S-LM-532 Algol F Library\n//*\n//IVP1   EXEC  ALGOFCLG,PARM.GO='TRACE'\n//ALGOL.SYSIN  DD  *\n     'BEGIN'\n      'COMMENT' TEST PROGRAM Q09\n                MODIFIED FOR IBM ALGOL F LEVEL 2.1 IVP\n\n                GENERATE AND PRINTS THE FIRST TWENTY\n                LINES OF PASCALS TRIANGLE\n\n          THE K TH ELEMENT P(K,J) OF THE J TH LINE SHOULD BE\n          EQUAL TO THE SUM OF P(K-1,J-1) AND P(K,J-1) FOR K \u00ac= 0\n          AND K \u00ac= J. P(0,J)=P(J,J)=1\n          THUS BY ADDING TWO BY TWO ALL ELEMENTS IN ONE LINE\n          PLACING EACH SUM BELOW AND BETWEEN THE TWO ELEMENTS THE\n          NEXT LINE OF PASCALS TRIANGLE COULD BE EXPANDED ;\n\n     'INTEGER' l,k,n,i,m,Powerten;\n     'INTEGER' 'ARRAY' a\u00dd0:19\u00a8;\n     'BOOLEAN' c;\n     SYSACT(1,6,120);\n     SYSACT(1,8,62);\n     SYSACT(1,12,1);\n     SYSACT(1,2,56);\n     OUTSTRING (1,'('Pascals Triangle')');\n     'FOR' l := 0 'STEP' 1 'UNTIL' 19 'DO'\n      'BEGIN'\n       SYSACT(1,14,3);\n       'IF' l < 19 'THEN'\n         SYSACT(1,2,58-3*l);\n       a\u00ddl\u00a8 := 1;\n       'FOR' k := l-1 'STEP' -1 'UNTIL' 1 'DO'\n        a\u00ddk\u00a8 := a\u00ddk-1\u00a8 + a\u00ddk\u00a8;\n        'FOR' K :=0 'STEP' 1 'UNTIL' L 'DO'\n         'BEGIN'\n          c := 'TRUE';\n          m := a\u00ddk\u00a8;\n          'FOR' I := 5 'STEP' -1 'UNTIL' 0 'DO'\n           'BEGIN'\n             Powerten := 10 ** I;\n             n := m '/' Powerten;\n             m := m-n * Powerten;\n             'IF' n 'EQUAL' 0 'THEN'\n              'BEGIN'\n               'IF' c 'THEN' OUTSYMBOL (1,'(' ')',1)\n                 'ELSE' OUTSYMBOL (1,'('0')',1);\n              'END'\n               'ELSE'\n                'BEGIN'\n                 c := 'FALSE';\n                 OUTSYMBOL(1,'('123456789')',N);\n                'END'\n           'END'\n         'END'\n      'END'\n     'END'\n/*\n//AMBLIST  EXEC PGM=AMBLIST\n//*\n//*        DEMONSTRATE LANGUAGE TRANSLATOR ID FOR ALGOL F\n//*        PROGRAMS AND TIME OF COMPILATION\n//*\n//SYSPRINT  DD  SYSOUT=*\n//SYSLIB    DD  DSN=&&GOSET,DISP=(OLD,PASS)\n//SYSIN     DD  *\n        LISTIDR  MEMBER=GO\n/*\n//\n./ ADD NAME=IEXSAMP2 0201-12230-12230-1200-00050-00050-00000-LEVEL\n//T1IV2   JOB  111,'ALGOL F LVL2.1',   <-- CUSTOMIZE FOR SITE STANDARDS\n//             CLASS=S,MSGCLASS=C,     <-- CUSTOMIZE FOR SITE STANDARDS\n//             REGION=1024K,COND=(0,NE),MSGLEVEL=(1,1)\n//*\n//*       IBM ALGOL F LEVEL 2.1 IVP\n//*\n//*       360S-AL-531 ALGOL F COMPILER\n//*            AND\n//*       360S-LM-532 ALGOL F LIBRARY\n//*\n//IVP2   EXEC  ALGOFCLG,PARM.GO='TRACE,DUMP'\n//ALGOL.SYSIN  DD  *\n      'BEGIN'\n      'COMMENT'\n       IBM ALGOL F LEVEL 2.1 IVP\n       SAMPLE PROGRAM TO CREATE DELIBERATE DIVIDE BY ZERO ERROR\n       TO DEMONSTRATE ALGOL RUN TIME DIAGNOSTIC INFORMATION;\n\n      'INTEGER' I;\n      'REAL' A;\n      'BOOLEAN' B;\n      'INTEGER' 'ARRAY' IA\u00dd1:5\u00a8;\n      'ARRAY' AR\u00dd0:3,2:8\u00a8;\n      'BOOLEAN' 'ARRAY' BA\u00dd0:1,1:3,3:7\u00a8;\n      'INTEGER' 'PROCEDURE' IP;\n      IP := I + 5;\n      'REAL' 'PROCEDURE' RP(A);\n      'VALUE' A;\n      'INTEGER' A;\n      RP := A*A;\n      'PROCEDURE' P(A,B,C);\n      'BOOLEAN' A;\n      'REAL' B;\n      'INTEGER' C;\n      A:= B < C ;\n      I := 1;\n      A := 2.6;\n      AR\u00dd1,1\u00a8 := IP;\n      AR\u00dd1,2\u00a8 := RP(AR\u00dd1,1\u00a8);\n      P(BA\u00dd0,1,3\u00a8,A,I);\n      P(B,AR\u00dd1,2\u00a8,IP);\n      SYSACT(1,8,50);\n      OUTREAL(1,AR\u00dd1,1\u00a8);\n      OUTBOOLEAN(1,BA\u00dd0,1,3\u00a8);\n      OUTBOOLEAN(1,B);\n      'COMMENT' DELIBERATE DIVIDE BY ZERO ERROR;\n      A := A/0;\n      'END'\n/*\n//\n./ ADD NAME=IEXSAMP3 0201-12230-12230-1200-00081-00081-00000-LEVEL\n//T1IV3   JOB  111,'ALGOL F LVL2.1',   <-- CUSTOMIZE FOR SITE STANDARDS\n//             CLASS=S,MSGCLASS=C,     <-- CUSTOMIZE FOR SITE STANDARDS\n//             REGION=1024K,COND=(0,NE),MSGLEVEL=(1,1)\n//*\n//*       IBM ALGOL F LEVEL 2.1 IVP\n//*\n//*       360S-AL-531 ALGOL F COMPILER\n//*            AND\n//*       360S-LM-532 ALGOL F LIBRARY\n//*\n//IVP3   EXEC  ALGOFCLG,PARM.GO='TRACE'\n//ALGOL.SYSIN  DD  *\n 'BEGIN'\n 'COMMENT'\n ////////////////////////////////////////////////////////////////////\n // NAME: PETER M. MAURER\n // Program: Sieve of Eratosthenes\n // DUE: NEVER\n // LANGUAGE: ALGOL 60 ALA IBM ALGOL F\n // IBM Algol F IVP Contribution\n // by the kind permission of PETER M. MAURER\n ////////////////////////////////////////////////////////////////////\n ;\n    'COMMENT' Define the Sieve Data Structure ;\n    'INTEGER' 'ARRAY' Candidates \u00dd0:1000\u00a8;\n    'INTEGER' i,j,k;\n    'COMMENT' Set line-length = 120, Set lines-per-page = 62, OPEN;\n    SYSACT(1,6,120);\n    SYSACT(1,8,62);\n    SYSACT(1,12,1);\n    'COMMENT' 1000 to protect against strict evaluation of and ;\n    'FOR' i := 0 'STEP' 1 'UNTIL' 1000 'DO'\n    'BEGIN'\n        'COMMENT' everything is potentially prime\n                        until proven otherwise ;\n        Candidates\u00ddi\u00a8 := 1;\n    'END';\n    'COMMENT' Neither 1 nor 0 is Prime, so flag them off  ;\n    Candidates\u00dd0\u00a8 := 0;\n    Candidates\u00dd1\u00a8 := 0;\n    'COMMENT' Start the Sieve with the Integer 0 ;\n    i := 0;\n    'FOR' i := i 'WHILE' i 'LESS' 1000 'DO'\n    'BEGIN'\n        'COMMENT' Advance to the next un-crossed out. ;\n        'COMMENT' this number must be a prime;\n        'FOR' i := i 'WHILE' i 'LESS' 1000\n                            'AND' Candidates\u00ddi\u00a8 'EQUAL' 0 'DO'\n        'BEGIN'\n            i := i+1;\n        'END';\n        'COMMENT' insure against running off the end;\n        'IF' i 'LESS' 1000 'THEN'\n        'BEGIN'\n            'COMMENT' Cross out all multiples of the Prime.;\n            j := 2;\n            k := j*i;\n            'FOR' k := k 'WHILE' k 'LESS' 1000 'DO'\n            'BEGIN'\n                Candidates\u00ddk\u00a8 := 0;\n                j := j + 1;\n                k := j*i;\n            'END';\n            'COMMENT' Advance to the next candidate ;\n            i := i+1;\n            'END'\n        'END';\n        'COMMENT' All uncrossed out numbers are prime;\n        'COMMENT' Print all Primes ;\n        'FOR' i := 0 'STEP' 1 'UNTIL' 999 'DO'\n        'BEGIN'\n        'IF' Candidates\u00ddi\u00a8 \u00ac= 0  'THEN'\n        'BEGIN'\n            OUTINTEGER(1,i);\n            OUTSTRING(1,'(' Is Prime')');\n            SYSACT(1,14,1)\n        'END'\n    'END'\n 'END'\n/*\n//\n./ ADD NAME=IEXSAMP4 0201-12230-12230-1200-00888-00888-00000-LEVEL\n//T1IV4   JOB  111,'ALGOL F LVL2.1',   <-- CUSTOMIZE FOR SITE STANDARDS\n//             CLASS=S,MSGCLASS=C,     <-- CUSTOMIZE FOR SITE STANDARDS\n//             REGION=1024K,COND=(0,NE),MSGLEVEL=(1,1)\n//*\n//*       IBM Algol F Level 2.1 IVP\n//*\n//*       360S-AL-531 Algol F Compiler\n//*            and\n//*       360S-LM-532 Algol F Library\n//*\n//IVP4    EXEC ALGOFCL\n//ALGOL.SYSIN  DD  *\n    'BEGIN'\n    'COMMENT'  Basic Statement Times for Algol 60\n               B A Wichmann\n               National Physics laboratory\n               Teddington, Middlesex\n               November 1973;\n\n    'COMMENT'  Modified for IBM Algol F Level 2.1 IVP\n               This program will execute for aproximately 4 minutes\n               on an MVS 3.8 system running on a Hercules 3.07\n               system averaging 25 mips.\n\n               Timings are guidelines only due to the PC, Windows\n               and the Hercules timer implementations and will\n               therefore vary for each execution;\n\n    'REAL' x, y, z;\n    'INTEGER' i, j, n, k, l, m, case;\n    'INTEGER' 'ARRAY' e1\u00dd1:1\u00a8, e2\u00dd1:1,1:1\u00a8, e3\u00dd1:1,1:1,1:1\u00a8;\n\n    'PROCEDURE' p0;\n       ;\n\n    'PROCEDURE' p1(x);\n       'VALUE' x;\n       'REAL' x;\n       ;\n\n    'PROCEDURE' p2(x,y);\n       'VALUE' x, y;\n       'REAL' x, y;\n       ;\n\n    'PROCEDURE' p3(x,y,z);\n       'VALUE' x, y, z;\n       'REAL' x, y, z;\n       ;\n\n    'INTEGER' 'ARRAY' #TT\u00dd1:43\u00a8;\n\n    'PROCEDURE' printt;\n         'BEGIN'\n              'INTEGER' i;\n              'REAL' x, mix, loop;\n              'COMMENT' calculate time differences;\n              'FOR' i := 43 'STEP' -1 'UNTIL' 2 'DO'\n                   'BEGIN'\n                        #TT\u00ddi\u00a8 := #TT\u00ddi\u00a8 - #TT\u00ddi-1\u00a8;\n                        'COMMENT' subtract previous accum cpu time\n                                  to derive case timing;\n                   'END';\n              'FOR' i := 2 'STEP'  1 'UNTIL' 42 'DO'\n                   'BEGIN'\n                        #TT\u00ddi\u00a8 := (#TT\u00ddi\u00a8 - #TT\u00dd43\u00a8)/ ((n * 10)/1000);\n                        'COMMENT' subtract loop overhead and\n                                  convert to picroseconds;\n                   'END';\n              'COMMENT' Print results;\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd2\u00a8);\n              OUTSTRING(1,'('x := 1.0 ')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd3\u00a8);\n              OUTSTRING(1,'('x := 1 ')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd4\u00a8);\n              OUTSTRING(1,'('x := y ')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd5\u00a8);\n              OUTSTRING(1,'('x := y + z')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd6\u00a8);\n              OUTSTRING(1,'('x := y * z')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd7\u00a8);\n              OUTSTRING(1,'('x := y / z')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd8\u00a8);\n              OUTSTRING(1,'('k := 1')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd9\u00a8);\n              OUTSTRING(1,'('k := 1.0')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd10\u00a8);\n              OUTSTRING(1,'('k := l + m')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd11\u00a8);\n              OUTSTRING(1,'('k := l * m')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd12\u00a8);\n              OUTSTRING(1,'('k := l / m')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd13\u00a8);\n              OUTSTRING(1,'('k := l')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd14\u00a8);\n              OUTSTRING(1,'('x := l')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd15\u00a8);\n              OUTSTRING(1,'('l := y')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd16\u00a8);\n              OUTSTRING(1,'('x := y ** 2')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd17\u00a8);\n              OUTSTRING(1,'('x := y ** 3')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd18\u00a8);\n              OUTSTRING(1,'('x := y ** z')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd19\u00a8);\n              OUTSTRING(1,'('e1\u00dd1\u00a8 := 1')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd20\u00a8);\n              OUTSTRING(1,'('e2\u00dd1,1\u00a8 := 1')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd21\u00a8);\n              OUTSTRING(1,'('e3\u00dd1,1,1\u00a8 := 1')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd22\u00a8);\n              OUTSTRING(1,'('l := e1\u00dd1\u00a8')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd23\u00a8);\n              OUTSTRING(1,'('begin real a; end')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd24\u00a8);\n              OUTSTRING(1,'('begin real a\u00dd1:1\u00a8; end')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd25\u00a8);\n              OUTSTRING(1,'('begin real a\u00dd1:500\u00a8; end')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd26\u00a8);\n              OUTSTRING(1,'('begin real a\u00dd1:1,1:1\u00a8; end')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd27\u00a8);\n              OUTSTRING(1,'('begin real a\u00dd1:1,1:1,1:1\u00a8; end')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd28\u00a8);\n              OUTSTRING(1,'('begin goto lab; lab: end')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd29\u00a8);\n              OUTSTRING(1,'('begin switch s := q; goto s\u00dd1\u00a8; q: end')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd30\u00a8);\n              OUTSTRING(1,'('x := sin(y)')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd31\u00a8);\n              OUTSTRING(1,'('x := cos(y)')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd32\u00a8);\n              OUTSTRING(1,'('x := abs(y)')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd33\u00a8);\n              OUTSTRING(1,'('x := exp(y)')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd34\u00a8);\n              OUTSTRING(1,'('x := ln(y)')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd35\u00a8);\n              OUTSTRING(1,'('x := sqrt(y)')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd36\u00a8);\n              OUTSTRING(1,'('x := arctan(y)')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd37\u00a8);\n              OUTSTRING(1,'('x := sign(y)')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd38\u00a8);\n              OUTSTRING(1,'('x := entier(y)')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd39\u00a8);\n              OUTSTRING(1,'('p0')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd40\u00a8);\n              OUTSTRING(1,'('p1(x)')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd41\u00a8);\n              OUTSTRING(1,'('p2(x,y)')');\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd42\u00a8);\n              OUTSTRING(1,'('p3(x,y,z)')');\n              'COMMENT' print DO loop overhead;\n              SYSACT(1,14,1);\n              OUTINTEGER(1,#TT\u00dd43\u00a8);\n              OUTSTRING(1,'('DO Loop overhead')');\n         'END';\n\n    'INTEGER' 'PROCEDURE' CPUTIM; 'CODE';\n           'COMMENT' Procedure that returns the current accumulated\n                     job step processor time in microseconds in the\n                     MVS 3.8J environment;\n\n    'COMMENT' Set line-length = 120, Set lines-per-page = 62, OPEN;\n    SYSACT(1,6,120);\n    SYSACT(1,8,62);\n    SYSACT(1,12,1);\n    SYSACT(1,2,10);\n    OUTSTRING (1,'('Algol F Statement Timings')');\n    SYSACT(1,14,1);\n    OUTSTRING(1,'('Picoseconds  Statement')');\n\n    x := y := z := 1.0;\n    l := k := m := 1;\n    e1\u00dd1\u00a8 := 1;\n    case := 1;\n\n         'COMMENT' Case 01;\n    n := 100000;\n         'COMMENT' n should be given a large enough value\n                   for the resolution of the clock not to\n                   be a limiting factor to the accuracy.\n                   If n is made too large then processor time\n                   is wasted;\n    #TT\u00dd1\u00a8 := CPUTIM;\n         'COMMENT' #TT\u00dd1\u00a8 equals program initialization overhead;\n\n         'COMMENT' Case 02;\n    case := case + 1;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              x := 1.0; x := 1.0; x := 1.0; x := 1.0; x := 1.0;\n              x := 1.0; x := 1.0; x := 1.0; x := 1.0; x := 1.0;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 03;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              x := 1; x := 1; x := 1; x := 1; x := 1;\n              x := 1; x := 1; x := 1; x := 1; x := 1;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 04;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              x := y; x := y; x := y; x := y;\n              x := y; x := y; x := y; x := y;\n              x := y; x := y; x := y; x := y;\n              x := y;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 05;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              x := y + z; x := y + z; x := y + z; x := y + z;\n              x := y + z; x := y + z; x := y + z; x := y + z;\n              x := y + z; x := y + z;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 06;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              x := y * z; x := y * z; x := y * z; x := y * z;\n              x := y * z; x := y * z; x := y * z; x := y * z;\n              x := y * z; x := y * z;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 07;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              x := y/z; x := y/z; x := y/z; x := y/z;\n              x := y/z; x := y/z; x := y/z; x := y/z;\n              x := y/z; x := y/z;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 08;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              k := 1; k := 1; k := 1; k := 1;\n              k := 1; k := 1; k := 1; k := 1;\n              k := 1; k := 1;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 09;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              k := 1.0; k := 1.0; k := 1.0; k := 1.0;\n              k := 1.0; k := 1.0; k := 1.0; k := 1.0;\n              k := 1.0; k := 1.0;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 10;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              k := l + m; k := l + m;\n              k := l + m; k := l + m;\n              k := l + m; k := l + m;\n              k := l + m; k := l + m;\n              k := l + m; k := l + m;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 11;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              k := l * m; k := l * m; k := l * m;\n              k := l * m; k := l * m; k := l * m;\n              k := l * m; k := l * m; k := l * m;\n              k := l * m;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 12;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              k := l / m; k := l / m; k := l / m;\n              k := l / m; k := l / m; k := l / m;\n              k := l / m; k := l / m; k := l / m;\n              k := l / m;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 13;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              k := l; k := l; k := l;\n              k := l; k := l; k := l;\n              k := l; k := l; k := l;\n              k := l; k := l; k := l;\n              k := l;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 14;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              x := l; x := l; x := l; x := l;\n              x := l; x := l; x := l; x := l;\n              x := l; x := l;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 15;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              l := y; l := y; l := y;\n              l := y; l := y; l := y;\n              l := y; l := y; l := y;\n              l := y;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 16;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              x := y ** 2; x := y ** 2;\n              x := y ** 2; x := y ** 2;\n              x := y ** 2; x := y ** 2;\n              x := y ** 2; x := y ** 2;\n              x := y ** 2; x := y ** 2;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 17;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              x := y ** 3; x := y ** 3;\n              x := y ** 3; x := y ** 3;\n              x := y ** 3; x := y ** 3;\n              x := y ** 3; x := y ** 3;\n              x := y ** 3; x := y ** 3;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 18;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              x := y ** z;       x := y ** z;\n              x := y ** z;       x := y ** z;\n              x := y ** z;       x := y ** z;\n              x := y ** z;       x := y ** z;\n              x := y ** z;       x := y ** z;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 19;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              e1\u00dd1\u00a8 := 1; e1\u00dd1\u00a8 := 1; e1\u00dd1\u00a8 := 1;\n              e1\u00dd1\u00a8 := 1; e1\u00dd1\u00a8 := 1; e1\u00dd1\u00a8 := 1;\n              e1\u00dd1\u00a8 := 1; e1\u00dd1\u00a8 := 1; e1\u00dd1\u00a8 := 1;\n              e1\u00dd1\u00a8 := 1;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 20;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              e2\u00dd1,1\u00a8:= 1; e2\u00dd1,1\u00a8:= 1; e2\u00dd1,1\u00a8:= 1;\n              e2\u00dd1,1\u00a8:= 1; e2\u00dd1,1\u00a8:= 1; e2\u00dd1,1\u00a8:= 1;\n              e2\u00dd1,1\u00a8:= 1; e2\u00dd1,1\u00a8:= 1; e2\u00dd1,1\u00a8:= 1;\n              e2\u00dd1,1\u00a8:= 1; e2\u00dd1,1\u00a8:= 1;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 21;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              e3\u00dd1,1,1\u00a8:= 1; e3\u00dd1,1,1\u00a8 := 1;\n              e3\u00dd1,1,1\u00a8:= 1; e3\u00dd1,1,1\u00a8 := 1;\n              e3\u00dd1,1,1\u00a8:= 1; e3\u00dd1,1,1\u00a8 := 1;\n              e3\u00dd1,1,1\u00a8:= 1; e3\u00dd1,1,1\u00a8 := 1;\n              e3\u00dd1,1,1\u00a8:= 1; e3\u00dd1,1,1\u00a8 := 1;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 22;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              l := e1\u00dd1\u00a8; l := e1\u00dd1\u00a8; l := e1\u00dd1\u00a8;\n              l := e1\u00dd1\u00a8; l := e1\u00dd1\u00a8; l := e1\u00dd1\u00a8;\n              l := e1\u00dd1\u00a8; l := e1\u00dd1\u00a8; l := e1\u00dd1\u00a8;\n              l := e1\u00dd1\u00a8;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 23;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              'BEGIN'\n                   'REAL' a;\n              'END';\n              'BEGIN'\n                   'REAL' a;\n              'END';\n              'BEGIN'\n                   'REAL' a;\n              'END';\n              'BEGIN'\n                   'REAL' a;\n              'END';\n              'BEGIN'\n                   'REAL' a;\n              'END';\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 24;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              'BEGIN'\n                   'ARRAY' a\u00dd1:1\u00a8;\n              'END';\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 25;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              'BEGIN'\n                   'ARRAY' a\u00dd1:500\u00a8;\n              'END';\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 26;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              'BEGIN'\n                   'ARRAY' a\u00dd1:1,1:1\u00a8;\n              'END';\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 27;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              'BEGIN'\n                   'ARRAY' a\u00dd1:1,1:1,1:1\u00a8;\n              'END';\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 28;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              'GOTO' l0;\n              l0: ;\n              'GOTO' l1;\n              l1: ;\n              'GOTO' l2;\n              l2: ;\n              'GOTO' l3;\n              l3: ;\n              'GOTO' l4;\n              l4: ;\n              'GOTO' l5;\n              l5: ;\n              'GOTO' l6;\n              l6: ;\n              'GOTO' l7;\n              l7: ;\n              'GOTO' l8;\n              l8: ;\n              'GOTO' l9;\n              l9: ;\n              p0;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 29;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              'BEGIN'\n                   'SWITCH' s := q; 'GOTO' s\u00dd1\u00a8;\n                   q:  ;\n              'END';\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 30;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              x := sin(y);\n              x := sin(y);\n              x := sin(y);\n              x := sin(y);\n              x := sin(y);\n              x := sin(y);\n              x := sin(y);\n              x := sin(y);\n              x := sin(y);\n              x := sin(y);\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 31;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              x := cos(y);\n              x := cos(y);\n              x := cos(y);\n              x := cos(y);\n              x := cos(y);\n              x := cos(y);\n              x := cos(y);\n              x := cos(y);\n              x := cos(y);\n              x := cos(y);\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 32;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              x := abs(y); x := abs(y); x := abs(y);\n              x := abs(y); x := abs(y); x := abs(y);\n              x := abs(y); x := abs(y); x := abs(y);\n              x := abs(y);\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 33;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              x := exp(y);\n              x := exp(y);\n              x := exp(y);\n              x := exp(y);\n              x := exp(y);\n              x := exp(y);\n              x := exp(y);\n              x := exp(y);\n              x := exp(y);\n              x := exp(y);\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 34;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              x := ln(y);\n              x := ln(y);\n              x := ln(y);\n              x := ln(y);\n              x := ln(y);\n              x := ln(y);\n              x := ln(y);\n              x := ln(y);\n              x := ln(y);\n              x := ln(y);\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 35;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              x := sqrt(y);\n              x := sqrt(y);\n              x := sqrt(y);\n              x := sqrt(y);\n              x := sqrt(y);\n              x := sqrt(y);\n              x := sqrt(y);\n              x := sqrt(y);\n              x := sqrt(y);\n              x := sqrt(y);\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 36;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              x := arctan(y);\n              x := arctan(y);\n              x := arctan(y);\n              x := arctan(y);\n              x := arctan(y);\n              x := arctan(y);\n              x := arctan(y);\n              x := arctan(y);\n              x := arctan(y);\n              x := arctan(y);\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 37;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              x := sign(y); x := sign(y); x := sign(y);\n              x := sign(y); x := sign(y); x := sign(y);\n              x := sign(y); x := sign(y); x := sign(y);\n              x := sign(y);\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 38;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              x := entier(y); x := entier(y);\n              x := entier(y); x := entier(y);\n              x := entier(y); x := entier(y);\n              x := entier(y); x := entier(y);\n              x := entier(y); x := entier(y);\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 39;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              p0;\n              p0;\n              p0;\n              p0;\n              p0;\n              p0;\n              p0;\n              p0;\n              p0;\n              p0;\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 40;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              p1(x);\n              p1(x);\n              p1(x);\n              p1(x);\n              p1(x);\n              p1(x);\n              p1(x);\n              p1(x);\n              p1(x);\n              p1(x);\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 41;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n              p2(x,y);\n              p2(x,y);\n              p2(x,y);\n              p2(x,y);\n              p2(x,y);\n              p2(x,y);\n              p2(x,y);\n              p2(x,y);\n              p2(x,y);\n              p2(x,y);\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 42;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         'BEGIN'\n             p3(x,y,z);\n             p3(x,y,z);\n             p3(x,y,z);\n             p3(x,y,z);\n             p3(x,y,z);\n             p3(x,y,z);\n             p3(x,y,z);\n             p3(x,y,z);\n             p3(x,y,z);\n             p3(x,y,z);\n         'END';\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    case := case + 1;\n         'COMMENT' Case 43;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         ;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         ;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         ;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         ;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         ;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         ;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         ;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         ;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         ;\n    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'\n         ;\n    #TT\u00ddcase\u00a8 := CPUTIM;\n\n    printt;\n\n    'END';\n/*\n//ASMTIM   EXEC ASMFCL\n//ASM.SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=SYS1.AMODGEN,DISP=SHR\n//ASM.SYSIN  DD *\nCPU         TITLE 'CPUTIM - ALGOL F FUNCTION TO RETURN ACCUMULATED STEPX\n                CPU TIME'\n*\n*        FUNCTION -\n*        RETURN THE ACCUMULATED STEP CPU TIME IN MICROSECONDS WHEN\n*        CALLED AS AN ALGOL F FUNCTION DECLARED AS -\n*        'INTEGER' 'PROCEDURE' CPUTIM; 'CODE';\n*        THIS ALGOL F FUNCTION IS DESIGNED TO OPERATE IN THE\n*        MVS 3.8 ENVIRONMENT\n*\n*        ENVIRONMENT -\n*        SEE OS/360 ALGOL F PROGRAMMERS GUIDE GC33-4000 FOR A\n*        DESCRIPTION OF THE INVOKING ENVIRONMENT\n*\n*        STATUS -\n*        THIS FUNCTION IS SERIALLY REUSEABLE BUT NOT\n*        RECURSIVE OR REENTRANT\n*\nCPUTIM   CSECT\n*\n*        FSA OFFSETS\n*\nCAP1     EQU   X'0D4'\nCAP2     EQU   X'0D8'\nPROLOGFP EQU   X'0DC'\nRETPROG  EQU   X'0E4'\nEPILOGP  EQU   X'0E8'\nCSWE1    EQU   X'0F4'\nVALUCALL EQU   X'118'\n*\n         USING PBTAB,R11\n*\n*        PROGRAM BLOCK TABLE\n*\nPBTAB    DC    A(0)\n         DC    CL4'CPUT'           NAME\n         DC    A(0)\n         DC    H'32'               L'DSA FOR TYPED PROCEDURE (FUNCTION)\n         DC    X'08'               TYPE PROCEDURE INTEGER\n         DC    AL1(0)              NUMBER OF FORMAL PARAMETERS\n*\n*        ENTRY BLOCK\n*\nCPUENT   DC    A(PBTAB)\n         DC    A(0)\n         DC    A(CPUCODE)\n*\n*        ESTABLISH ADDRESSABILITY TO THE PSA, ASCB\n*\n         USING PSA,R0\n         USING ASCB,R4\n*\nCPUCODE  B     CPUCODEA\n*\n         DC    AL1(L'ID)\nID       DC    C'CPUTIM &SYSDATE &SYSTIME'\n*\nCPUCODEA STM   R14,R10,SAVEAREA+12\n         L     R4,PSAAOLD          R4 -> CURRENT ASCB\n         LM    R2,R3,ASCBEJST      ACCUM STEP TCB CPU TIME\n         AL    R3,ASCBSRBT+4       ADD ACCUM SRB CPU TIME\n         BC    12,CPUCODEB         OVERFLOW ? NO, BRANCH\n         LA    R2,1(,R2)           YES, ADD CARRY\nCPUCODEB A     R2,ASCBSRBT         TOTAL CPU TIME (TCB + SRB)\n         SRDL  R2,(63-51)          SHIFT TO CONVERT TO MICROSECONDS\n         ST    R3,24(,R10)         STORE RESULT IN DSA+24\n         LM    R14,R10,SAVEAREA+12\n         B     EPILOGP(,R13)       RETURN VIA EPILOG CODE IN FSA\n*\nSAVEAREA DC    18F'0'\n*\n         PRINT NOGEN\n*\n*        PREFIXED SAVE AREA\n*\n         IHAPSA\n*\n*        ADDRESS SPACE CONTROL BLOCK\n*\n         IHAASCB\n*\n         PRINT GEN\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END CPUENT\n/*\n//LKED.SYSLMOD DD DSN=&&GOSET(CPUTIM),DISP=(OLD,PASS)\n//GOIVP4  EXEC PGM=GO\n//STEPLIB  DD  DSN=&&GOSET,DISP=(OLD,PASS)\n//ALGLDD01 DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  UNIT=VIO,SPACE=(1024,(20,10))\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AL21FJCL": {"ttr": 47619, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x03\\x00\\x18\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x15!\\x00Z\\x00Y\\x00Z\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "02.03", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T15:21:18", "lines": 90, "newlines": 89, "modlines": 90, "user": "SBGOLOB"}, "text": "./ ADD NAME=INSTFJCL 0201-12230-12230-1200-00090-00090-00000-LEVEL\n//T1AI    JOB  111,'ALGOL F LVL2.1',   <-- CUSTOMIZE FOR INSTALLATION\n//             CLASS=S,MSGCLASS=C,     <-- CUSTOMIZE FOR INSTALLATION\n//             REGION=4096K,COND=(0,NE),MSGLEVEL=(1,1)\n//*\n//*            INSTALL\n//*            ALGOL F LEVEL 2.1\n//*            360S-AL-531 ALGOL F COMPILER\n//*                 AND\n//*            360S-LM-532 ALGOL F LIBRARY\n//*            INDEPENDENT COMPONENT RELEASE\n//*\n//*            BEFORE SUBMITTING THIS JOB CUSTOMIZE THE SYMBOLIC\n//*            PARAMETERS TO CONFORM TO LOCAL STANDARDS\n//*\n//*            NOTE -\n//*            THIS JOB WILL ISSUE TWO REQUESTS FOR THE\n//*            MASTER CATALOG PASSWORD TO DELETE AND RE-ALLOCATE\n//*            SYS1.ALGLIB\n//*\n//*            THIS JCL IS THE FIRST FILE ON THE DISTRIBUTION TAPE\n//*\n//*            DSN=ALGOLF.LVL210.JCL,LABEL=(1,SL,EXPDT=98000)\n//*\n//INSTALL PROC OLINK='SYS2.LINKLIB',   <-- TARGET COMPILER LINKLIB\n//             OLIB='SYS1.ALGLIB',     <-- TARGET RESIDENT LIBRARY\n//             OLUNIT='3350',          <-- TARGET RESIDENT LIBRARY\n//             OLVOL='MVSRES',         <-- TARGET RESIDENT LIBRARY\n//             OPROC='SYS2.PROCLIB',   <-- TARGET PROCLIB\n//             OSAMP='SYS1.SAMPLIB',   <-- TARGET IVP SAMPLIB\n//             SOUT='*',               SYSOUT CLASS, DLFT TO MSGCLASS\n//             THLQ='ALGOLF',          ADD ADDTNL PREFIX IF REQUIRED\n//             TUNIT='3400-6',         TAPE UNIT FOR DISTRIBUTION TAPE\n//             TVOL='ALGOLF'           VOLSER OF DISTRIBUTION TAPE\n//*\n//*********************************************************************\n//*\n//*            NAME: INSTALL ALGOL F LEVEL 2.1 ICR\n//*\n//*            DESC: INSTALL NEW VERSION OF ALGOL F AND ASSOC\n//*                  LIBRARIES FROM DISTRIBUTION TAPE\n//*\n//*********************************************************************\n//*\n//*            DELETE SYS1.ALGLIB\n//*\n//DELETE  EXEC PGM=IDCAMS\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//*\n//*            LOAD ALL DATASETS\n//*\n//LOAD    EXEC PGM=IEBCOPY,REGION=1024K\n//SYSPRINT DD  SYSOUT=&SOUT\n//*\n//INLINK   DD  DSN=&THLQ..LVL210.MOD,\n//             UNIT=&TUNIT,VOL=(PRIVATE,RETAIN,SER=&TVOL),\n//             LABEL=(2,SL,EXPDT=98000),DISP=(OLD,PASS)\n//OUTLINK  DD  DSN=&OLINK,DISP=SHR              <--- TARGET LIB\n//*\n//INLIB    DD  DSN=&THLQ..LVL210.LIB,\n//             UNIT=&TUNIT,VOL=(PRIVATE,RETAIN,SER=&TVOL),\n//             LABEL=(3,SL,EXPDT=98000),DISP=(OLD,PASS)\n//OUTLIB   DD  DSN=&OLIB,UNIT=&OLUNIT,          <--- TARGET LIB\n//             VOL=SER=&OLVOL,SPACE=(TRK,(15,5,32)),\n//             DISP=(,CATLG)\n//*\n//INPROC   DD  DSN=&THLQ..LVL210.PRC,\n//             UNIT=&TUNIT,VOL=(PRIVATE,RETAIN,SER=&TVOL),\n//             LABEL=(4,SL,EXPDT=98000),DISP=(OLD,PASS)\n//OUTPROC  DD  DSN=&OPROC,DISP=SHR              <--- TARGET LIB\n//*\n//INSAMP   DD  DSN=&THLQ..LVL210.IVP,\n//             UNIT=&TUNIT,VOL=(PRIVATE,RETAIN,SER=&TVOL),\n//             LABEL=(5,SL,EXPDT=98000),DISP=(OLD,KEEP)\n//OUTSAMP  DD  DSN=&OSAMP,DISP=SHR              <--- TARGET LIB\n//*\n//        PEND\n//        EXEC INSTALL\n//DELETE.SYSIN DD *\n  DELETE SYS1.ALGLIB PURGE\n  SET LASTCC = 0\n/*\n//LOAD.SYSIN   DD *\n    COPY INDD=((INLINK,R)),OUTDD=OUTLINK\n    COPY INDD=((INLIB,R)),OUTDD=OUTLIB\n    COPY INDD=((INPROC,R)),OUTDD=OUTPROC\n    COPY INDD=((INSAMP,R)),OUTDD=OUTSAMP\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AL21FLIB": {"ttr": 47622, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x13F\\x02\\xa2\\x02\\xa2\\x00\\x00\\xd3\\xc9\\xc2\\xd9\\xc1\\xd9\\xe8@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T13:46:00", "lines": 674, "newlines": 674, "modlines": 0, "user": "LIBRARY"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "AL21FPRC": {"ttr": 47878, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x13F\\x00u\\x00u\\x00\\x00\\xd7\\xd9\\xd6\\xc3\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T13:46:00", "lines": 117, "newlines": 117, "modlines": 0, "user": "PROCLIB"}, "text": "./ ADD NAME=ALGOFC   0201-12230-12230-1200-00019-00019-00000-LEVEL\n//*\n//*********************************************************************\n//*\n//*       IBM ALGOL F LEVEL 2.1\n//*\n//*       360S-AL-531 ALGOL F COMPILER\n//*\n//*       COMPILE A PROGRAM\n//*\n//*********************************************************************\n//*\n//ALGOL   EXEC PGM=ALGOL,REGION=1024K\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DUMMY\n//SYSLIN   DD  DSN=&&OBJECT,UNIT=VIO,SPACE=(3200,(20,10)),\n//             DISP=(,PASS)\n//SYSUT1   DD  UNIT=VIO,SPACE=(2048,(50,10))\n//SYSUT2   DD  UNIT=VIO,SPACE=(2048,(50,10))\n//SYSUT3   DD  UNIT=VIO,SPACE=(2048,(40,10))\n./ ADD NAME=ALGOFCG  0201-12230-12230-1200-00028-00028-00000-LEVEL\n//*\n//*********************************************************************\n//*\n//*       IBM ALGOL F LEVEL 2.1\n//*\n//*       360S-AL-531 ALGOL F COMPILER\n//*            AND\n//*       360S-LM-532 ALGOL F LIBRARY\n//*\n//*       COMPILE AND EXECUTE A PROGRAM\n//*\n//*********************************************************************\n//*\n//ALGOL   EXEC PGM=ALGOL,REGION=1024K\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DUMMY\n//SYSLIN   DD  DSN=&&OBJECT,UNIT=VIO,SPACE=(3200,(20,10)),\n//             DISP=(,PASS)\n//SYSUT1   DD  UNIT=VIO,SPACE=(2048,(50,10))\n//SYSUT2   DD  UNIT=VIO,SPACE=(2048,(50,10))\n//SYSUT3   DD  UNIT=VIO,SPACE=(2048,(40,10))\n//GO      EXEC PGM=LOADER,PARM='MAP,LET,PRINT',COND=(5,LT,ALGOL)\n//SYSLIN   DD  DSN=&&OBJECT,DISP=(OLD,DELETE)\n//SYSLIB   DD  DSN=SYS1.ALGLIB,DISP=SHR\n//SYSLOUT  DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//ALGLDD01 DD  SYSOUT=*\n//SYSUT1   DD  UNIT=VIO,SPACE=(1024,(20,10))\n./ ADD NAME=ALGOFCL  0201-12230-12230-1200-00030-00030-00000-LEVEL\n//*\n//*********************************************************************\n//*\n//*       IBM ALGOL F LEVEL 2.1\n//*\n//*       360S-AL-531 ALGOL F COMPILER\n//*            AND\n//*       360S-LM-532 ALGOL F LIBRARY\n//*\n//*       COMPILE AND LINK-EDIT A PROGRAM\n//*\n//*********************************************************************\n//*\n//ALGOL   EXEC PGM=ALGOL,REGION=1024K\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DUMMY\n//SYSLIN   DD  DSN=&&OBJECT,UNIT=VIO,SPACE=(3200,(20,10)),\n//             DISP=(,PASS)\n//SYSUT1   DD  UNIT=VIO,SPACE=(2048,(50,10))\n//SYSUT2   DD  UNIT=VIO,SPACE=(2048,(50,10))\n//SYSUT3   DD  UNIT=VIO,SPACE=(2048,(40,10))\n//LKED    EXEC PGM=IEWL,PARM='XREF,LIST,LET',COND=(5,LT,ALGOL),\n//             REGION=1024K\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.ALGLIB,DISP=SHR\n//SYSLMOD  DD  DSN=&&GOSET(GO),UNIT=VIO,DISP=(,PASS),\n//             SPACE=(2048,(100,20,1))\n//SYSUT1   DD  UNIT=VIO,SPACE=(2048,(100,20))\n//SYSLIN   DD  DSN=&&OBJECT,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n./ ADD NAME=ALGOFCLG 0201-12230-12230-1200-00036-00036-00000-LEVEL\n//*\n//*********************************************************************\n//*\n//*       IBM ALGOL F LEVEL 2.1\n//*\n//*       360S-AL-531 ALGOL F COMPILER\n//*            AND\n//*       360S-LM-532 ALGOL F LIBRARY\n//*\n//*       COMPILE, LINK-EDIT AND EXECUTE A PROGRAM\n//*\n//*********************************************************************\n//*\n//ALGOL   EXEC PGM=ALGOL,REGION=1024K\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DUMMY\n//SYSLIN   DD  DSN=&&OBJECT,UNIT=VIO,SPACE=(3200,(20,10)),\n//             DISP=(,PASS)\n//SYSUT1   DD  UNIT=VIO,SPACE=(2048,(50,10))\n//SYSUT2   DD  UNIT=VIO,SPACE=(2048,(50,10))\n//SYSUT3   DD  UNIT=VIO,SPACE=(2048,(40,10))\n//LKED    EXEC PGM=IEWL,PARM='XREF,LIST,LET',COND=(5,LT,ALGOL),\n//             REGION=1024K\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.ALGLIB,DISP=SHR\n//SYSLMOD  DD  DSN=&&GOSET(GO),UNIT=VIO,DISP=(,PASS),\n//             SPACE=(2048,(100,20,1))\n//SYSUT1   DD  UNIT=VIO,SPACE=(2048,(100,20))\n//SYSLIN   DD  DSN=&&OBJECT,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//GO      EXEC PGM=GO,COND=((5,LT,ALGOL),(5,LT,LKED)),\n//             REGION=1024K\n//STEPLIB  DD  DSN=&&GOSET,DISP=(OLD,PASS)\n//ALGLDD01 DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  UNIT=VIO,SPACE=(1024,(20,10))\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AL21LASM": {"ttr": 47881, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x135(\\xc2(\\xc2\\x00\\x00\\xd3\\xc9\\xc2\\xd9\\xe2\\xd9\\xc3@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T13:35:00", "lines": 10434, "newlines": 10434, "modlines": 0, "user": "LIBRSRC"}, "text": "./ ADD NAME=IHIERM   0201-12230-12230-1200-00283-00283-00000-LEVEL\nMSG      TITLE 'IHIERMSG, RUNTIME ERROR MESSAGES, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION - THIS CONTROL SECTION CONTAINS ALL\n*        THE MESSAGES USED BY THE ERROR ROUTINE\n*\n*        ENTRY POINTS - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        EXITS - N/A\n*\n*        TABLES/WORK AREAS -\n*        THIS CONTROL SECTION IS MADE UP OF TABLES\n*\nIHIERMSG CSECT\n*\n         ENTRY IHIERM01\n*\nFLAGIDS  EQU   X'03'                   INSERT DSNAME INTO MSG\nFLAGIPS  EQU   X'01'                   INSERT PSW INTO MSG\nFLAGMC   EQU   X'04'                   MSG CONTINUATION\n*\n         DC    A(MESS0)                MESSAGE NUMBER 0-43 MUST BE\n         DC    A(MESS1)                KEPT TOGETHER\n         DC    A(MESS2)\n         DC    A(MESS3)\n         DC    A(MESS4)\n         DC    A(MESS5)\n         DC    A(MESS6)\n         DC    A(MESS7)\n         DC    A(MESS8)\n         DC    A(MESS9)\n         DC    A(MESS10)\n         DC    A(MESS11)\n         DC    A(MESS12)\n         DC    A(MESS13)\n         DC    A(MESS14)\n         DC    A(MESS15)\n         DC    A(MESS16)\n         DC    A(MESS17)\n         DC    A(MESS18)\n         DC    A(MESS19)\n         DC    A(MESS20)\n         DC    A(MESS21)\n         DC    A(MESS22)\n         DC    A(MESS23)\n         DC    A(MESS24)\n         DC    A(MESS25)\n         DC    A(MESS26)\n         DC    A(MESS27)\n         DC    A(MESS28)\n         DC    A(MESS29)\n         DC    A(MESS30)\n         DC    A(MESS31)\n         DC    A(MESS32)\n         DC    A(MESS33)\n         DC    A(MESS34)\n         DC    A(MESS35)\n         DC    A(MESS36)\n         DC    A(MESS37)\n         DC    A(MESS38)\n         DC    A(MESS39)\n         DC    A(MESS40)\n         DC    A(MESS41)\n         DC    A(MESS42)\n         DC    A(MESS43)\n*\nIHIERM01 DC    C'IHI0  I  SC=       '\n*\nMESS0    DC    AL1(L'MESS0T)\n         DC    AL1(0)                  FLAGS\nMESS0T   DC    C'DATASET NUMBER OUT OF RANGE'\n*\nMESS1    DC    AL1(L'MESS1T)\n         DC    AL1(FLAGIDS)            FLAGS\nMESS1T   DC    C'DSN=       REAL NUMBER TO BE CONVERTED OUT OF INTEGER X\n               RANGE'\n*\nMESS2    DC    AL1(L'MESS2T)\n         DC    AL1(FLAGIDS)            FLAGS\nMESS2T   DC    C'DSN=       INCOMPATIBLE ACTIONS ON DATASET'\n*\nMESS3    DC    AL1(L'MESS3T)\n         DC    AL1(FLAGIDS)            FLAGS\nMESS3T   DC    C'DSN=       INPUT BEYOND LAST OUTPUT'\n*\nMESS4    DC    AL1(L'MESS3T)\n         DC    AL1(0)                  FLAGS\nMESS4T   DC    C'TOO MANY REPOSITIONINGS IN DATASETS. INTERNAL OVERFLOWX\n               '\n*\nMESS5    DC    AL1(L'MESS5T)\n         DC    AL1(FLAGIDS)            FLAGS\nMESS5T   DC    C'DSN=       INPUT REQUEST BEYOND END OF DATASET'\n*\nMESS6    DC    AL1(L'MESS6T)\n         DC    AL1(FLAGIDS+FLAGMC)     FLAGS\nMESS6T   DC    C'DSN=       EXPONENT PART OF INPUT NUMBER CONSISTS OF MX\n               ORE THAN'\n         DC    AL1(L'MESS6T1)\n         DC    AL1(0)                  FLAGS\nMESS6T1  DC    C'TWO SIGNIFICANT DIGITS'\n*\nMESS7    DC    AL1(L'MESS7T)\n         DC    AL1(FLAGIDS+FLAGMC)     FLAGS\nMESS7T   DC    C'DSN=       **NO CONTROL CHARACTER SPECIFIED IN RECORD C\n               FORMAT OF '\n         DC    AL1(L'MESS7T1)\n         DC    AL1(0)                  FLAGS\nMESS7T1  DC    C'DATASET. SPLITTING INTO SECTIONS IMPOSSIBLE'\n*\nMESS8    DC    AL1(L'MESS8T)\n         DC    AL1(FLAGIDS)            FLAGS\nMESS8T   DC    C'DSN=       SOURCE IN PROCEDURE OUTSYMBOL DOES NOT MATCX\n               H STRING'\n*\nMESS9    DC    AL1(L'MESS9T)\n         DC    AL1(FLAGIDS)            FLAGS\nMESS9T   DC    C'DSN=       UNDEFINED FUNCTION NUMBER IN SYSACT PROCEDUX\n               RE'\n*\nMESS10   DC    AL1(L'MESS10T)\n         DC    AL1(FLAGIDS)            FLAGS\nMESS10T  DC    C'DSN=       DATASET CLOSED'\n*\nMESS11   DC    AL1(L'MESS11T)\n         DC    AL1(FLAGIDS)            FLAGS\nMESS11T  DC    C'DSN=       DATASET OPEN'\n*\nMESS12   DC    AL1(L'MESS12T)\n         DC    AL1(FLAGIDS)            FLAGS\nMESS12T  DC    C'DSN=       QUANTITY IN SYSACT PROCEDURE MUST BE A VARIX\n               ABLE'\n*\nMESS13   DC    AL1(L'MESS13T)\n         DC    AL1(FLAGIDS)            FLAGS\nMESS13T  DC    C'DSN=       QUANTITY IN SYSACT PROCEDURE OUT OF RANGE'\n*\nMESS14   DC    AL1(L'MESS14T)\n         DC    AL1(FLAGIDS)            FLAGS\nMESS14T  DC    C'DSN=       BACKWARD REPOSITIONING NOT DEFINED'\n*\nMESS15   DC    AL1(L'MESS15T)\n         DC    AL1(0)                  FLAGS\nMESS15T  DC    C'UPPER BOUND LESS THAN LOWER BOUND IN ARRAY DECLARATIONX\n               '\n*\nMESS16   DC    AL1(L'MESS16T)\n         DC    AL1(0)                  FLAGS\nMESS16T  DC    C'VALUE OF SUBSCRIPT EXPRESSION NOT WITHIN DECLARED BOUNX\n               DS'\n*\nMESS17   DC    AL1(L'MESS17T)\n         DC    AL1(0)                  FLAGS\nMESS17T  DC    C'ENDLESS LOOP IN FOR STATEMENT'\n*\nMESS18   DC    AL1(L'MESS18T)\n         DC    AL1(0)                  FLAGS\nMESS18T  DC    C'STORAGE REQUEST FOR ARRAY EXCEEDS LIMIT'\n*\nMESS19   DC    AL1(L'MESS19T)\n         DC    AL1(0)                  FLAGS\nMESS19T  DC    C'UNEQUAL NUMBER OF DIMENSIONS FOR ACTUAL AND FORMAL PARC\n               AMETER'\n*\nMESS20   DC    AL1(L'MESS20T)\n         DC    AL1(0)                  FLAGS\nMESS20T  DC    C'ACTUAL AND CORRESPONDING FORMAL PARAMETER OF DIFFERENTX\n                TYPE OR KIND'\n*\nMESS21   DC    AL1(L'MESS21T)\n         DC    AL1(FLAGMC)             FLAGS\nMESS21T  DC    C'UNEQUAL NUMBER OF PARAMETERS IN PROCEDURE DECLARATION X\n               AND PROCEDURE'\n         DC    AL1(L'MESS21T1)\n         DC    AL1(0)                  FLAGS\nMESS21T1 DC    C'STATEMENT/FUNCTION DESIGNATOR'\n*\nMESS22   DC    AL1(L'MESS22T)\n         DC    AL1(0)                  FLAGS\nMESS22T  DC    C'ASSIGNMENT TO FORMAL PARAMETER NOT POSSIBLE'\n*\nMESS23   DC    AL1(L'MESS23T)\n         DC    AL1(0)                  FLAGS\nMESS23T  DC    C'ARGUMENT OF SQRT LESS THAN ZERO'\n*\nMESS24   DC    AL1(L'MESS24T)\n         DC    AL1(0)                  FLAGS\nMESS24T  DC    C'ARGUMENT OF EXP GREATER THAN 174.673'\n*\nMESS25   DC    AL1(L'MESS25T)\n         DC    AL1(0)                  FLAGS\nMESS25T  DC    C'ARGUMENT OF LN NOT GREATER THAN ZERO'\n*\nMESS26   DC    AL1(L'MESS26T)\n         DC    AL1(0)                  FLAGS\nMESS26T  DC    C'ABS VALUE OF ARGUMENT OF SIN OR COS NOT LESS THAN PI*2X\n               **18'\n*\nMESS27   DC    AL1(L'MESS27T)\n         DC    AL1(0)                  FLAGS\nMESS27T  DC    C'ABS VALUE OF ARGUMENT OF SIN OR COS NOT LESS THAN PI*2X\n               **50'\n*\nMESS28   DC    AL1(L'MESS28T)\n         DC    AL1(FLAGIPS)            FLAGS\nMESS28T  DC    C'PSW=                   FIXED POINT OVERFLOW INTERRUPT'\n*\nMESS29   DC    AL1(L'MESS29T)\n         DC    AL1(FLAGIPS)            FLAGS\nMESS29T  DC    C'PSW=                   FLOATING POINT EXPONENT OVERFLOX\n               W INTERRUPT'\n*\nMESS30   DC    AL1(L'MESS30T)\n         DC    AL1(FLAGIPS)            FLAGS\nMESS30T  DC    C'PSW=                   DIVISION BY ZERO, FIXED POINT'\n*\nMESS31   DC    AL1(L'MESS31T)\n         DC    AL1(FLAGIPS)            FLAGS\nMESS31T  DC    C'PSW=                   DIVISION BY ZERO, FLOATING POINX\n               T'\n*\nMESS32   DC    AL1(L'MESS32T)\n         DC    AL1(FLAGIDS)            FLAGS\nMESS32T  DC    C'DSN=       UNRECOVERABLE I/O ERROR'\n*\nMESS33   DC    AL1(L'MESS33T)\n         DC    AL1(FLAGIPS)            FLAGS\nMESS33T  DC    C'PSW=                   PROGRAM INTERRUPT'\n*\nMESS34   DC    AL1(L'MESS34T)\n         DC    AL1(0)                  FLAGS\nMESS34T  DC    C'VALUE OF SWITCH DESIGNATOR NOT DEFINED IN DECLARATION X\n               OF SWITCH'\n*\nMESS35   DC    AL1(L'MESS35T)\n         DC    AL1(0)                  FLAGS\nMESS35T  DC    C'BASE NOT GREATER THAN ZERO'\n*\nMESS36   DC    AL1(L'MESS36T)\n         DC    AL1(FLAGMC)             FLAGS\nMESS36T  DC    C'TOO MANY NESTED BLOCKS AND CALLS OF PROCEDURES, SWITCHC\n               ES'\n         DC    AL1(L'MESS36T1)\n         DC    AL1(0)                  FLAGS\nMESS36T1 DC    C'AND PARAMETERS. INTERNAL OVERFLOW'\n*\nMESS37   DC    AL1(L'MESS37T)\n         DC    AL1(FLAGIDS)            FLAGS\nMESS37T  DC    C'DSN=       **BLOCKSIZE NOT A MULTIPLE OF LOGICAL RECORX\n               D LENGTH'\n*\nMESS38   DC    AL1(L'MESS38T)\n         DC    AL1(FLAGIDS)            FLAGS\nMESS38T  DC    C'DSN=       TOO LONG RECORD'\n*\nMESS39   DC    AL1(L'MESS39T)\n         DC    AL1(0)                  FLAGS\nMESS39T  DC    C'GET/PUT IDENTIFICATION OUT OF RANGE'\n*\nMESS40   DC    AL1(L'MESS40T)\n         DC    AL1(0)                  FLAGS\nMESS40T  DC    C'REAL NUMBER TO BE CONVERTED OUT OF INTEGER RANGE'\n*\nMESS41   DC    AL1(L'MESS41T)\n         DC    AL1(FLAGIDS)            FLAGS\nMESS41T  DC    C'DSN=       DD CARD INCORRECT OR MISSING'\n*\nMESS42   DC    AL1(L'MESS42T)\n         DC    AL1(0)                  FLAGS\nMESS42T  DC    C'INVALID OPTION PARAMETER'\n*\nMESS43   DC    AL1(L'MESS43T)\n         DC    AL1(0)                  FLAGS\nMESS43T  DC    C'ILLEGAL CALL OF GET/PUT OR LIST PROCEDURE'\n*\n         END\n./ ADD NAME=IHIERR   0201-12230-12230-1200-00511-00511-00000-LEVEL\nERR      TITLE 'IHIERROR, RUNTIME ERROR ROUTINE, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        IF AN ERROR OCCURS DURING EXECUTION OF AN ALGOL PROGRAM\n*        THIS ROUTINE IS CALLED BY IHIFSARA\n*        A MESSAGE IS GIVEN SPECIFYING THE ERROR. IF DUMP IS\n*        SPECIFIED THE ROUTINE EDITS AND PRINTS THE DATA STORAGE\n*        AREAS CONTAINING THE VALUES OF THE IDENTIFIERS\n*\n*        ENTRY POINT - IHIERROR\n*\n*        OUTPUT-\n*        ERROR MESSAGES AND ALGOL DUMPS ARE PRINTED ON THE\n*        PRINTER AS 90 CHARACTER RECORDS WITH CONTROL CHARACTER\n*        IN SOME CASES A MESSAGE IS ISSUED TO THE CONSOLE\n*\n*        EXTERNAL ROUTINES -\n*        IHIIORCL - FOR CLOSING DATASET NUMBER 1 (PRINTER)\n*        IHIIOROP - FOR OPENING DATASET NUMBER 1\n*        FRDSA    - ROUTINE IN IHIFSARA WHICH ISSUES FREEMAIN FOR\n*                   THE CURRENT DATA STORAGE AREAS\n*\n*        EXIT - NORMAL - TO TERMINATION ROUTINE IN IHIFSARA\n*\n*        EXIT - ERROR - N/A\n*\n*        TABLES/WORK AREAS -\n*        THE CONTROL SECTION NAMED IHIGERMSG CONTAINS ALL\n*        MESSAGES TO BE PRINTED\n*\nIHIERROR CSECT\n*\n         USING DSTABLE,R5\n*\n***********************************************************************\n*\n*        REGISTER USAGE\n*\n***********************************************************************\n*\nCDSA     EQU   10                      ADDRESS OF CURRENT DSA\nPBT      EQU   11\n*\n*        MESSAGE FORMAT FLAGS\n*\nFLAGIDS  EQU   X'03'                   INSERT DSNAME INTO MSG\nFLAGIPS  EQU   X'01'                   INSERT PSW INTO MSG\nFLAGMC   EQU   X'04'                   MSG CONTINUATION\n*\n         SAVE  (14,12),,'IHIERROR LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LR    R7,R15\n         USING IHIERROR,R7\n         MVC   VFRDSA(20),0(R1)        STORE EXTERNAL ADDR PARAMETERS\n         LR    R12,R13                 R12 -> FSA\n         LA    R13,SAVEAREA            R13 -> SAVEAREA\n*\n***********************************************************************\n*\n*        TEST IF ERROR MESSAGE NUMBER IS 32 OR 41 FOR DATASET 1\n*\n***********************************************************************\n*\n         BCT   R6,B1\n         TM    DSF+1,DS11              DS11 = 0 ?\n         BZ    B1                      YES\n         CLI   FSAERCOD(R12),X'80'     I/O ERROR (32) ?\n         BE    IOERR                   YES, EXECUTE WTO INSTRUCTION\n         CLI   FSAERCOD(R12),X'A4'     DD CARD ? (41)\n         BNE   B1                      YES, EXECUTE WTO INSTRUCTION\n*\n         WTO   'IHI041I SYSPRINT DD STMT INCORRECT OR MISSING',        X\n               ROUTCDE=11,DESC=7\n*\n         B     SETOPTSW\n*\nIOERR    WTO   'IHI032I SYSPRINT UNRECOVERABLE I/O ERROR',             X\n               ROUTCDE=11,DESC=7\n*\nSETOPTSW OI    OPTSW(R12),X'02'        SET SWITCH IN FSA\n         NI    DTSW(R12),X'7F'         REMOVE DUMP SWITCH\n         B     SPDAFREE\n*\n***********************************************************************\n*\n*        EDIT AND PRINT ERROR MESSAGE\n*\n***********************************************************************\n*\nB1       LA    R8,1(,R6)               SAVE DSNR FOR EDITING IF NEEDED\n         L     R5,ADSTAB(R12)          R5 -> ADSTAB IN FSA\n         LA    R5,DSTABLEL+4(,R5)      R5 -> DSTABLE ENTRY FOR DS NO 1\n         LA    R6,1                    SET DSNR TO 1\n         OI    DSF+1,DS15              FLAG CLOSE FROM IHIERR\n         L     R15,VIORCP              CLOSE ALL DATASETS\n         BALR  R14,R15\nSETDS11  OI    DSF+1,DS11              DS11=1 TO INDICATE IHIERR-ROUT\n         OI    DSF,DS2+DS3+DS6         DS2, DS3, DS6 = 1\n         NI    DSF,255-DS0-DS1         DS0, DS1 = 0\n         L     R15,VIOROP              R15 -> IHIIOROP\n         BALR  R14,R15                 OPEN SYSPRINT\n         MVI   BUFFER,C' '             PRINT ONE BLANK LINE TO PREVENT\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER  OVERPRINTING\n         BAL   R3,OUTPUT\n         SR    R2,R2\n         IC    R2,FSAERCOD(R12)        GET ADDR OF ERROR MESSAGE\n         L     R6,VERMSG               R6 -> IHIERMSG MODULE\n         L     R6,0(R2,R6)             R6 -> MSG TEXT BLOCK\n         SRL   R2,2                    CONVERT MESSAGE NUMBER TO\n         CVD   R2,WORKD                DECIMAL FOR PRINTING\n         L     R3,VERM01               R3 -> 'IHI0XXI SC=   ' STRING\n         UNPK  4(2,R3),WORKD           MOVE IN MSG NUMBER\n         OI    5(R3),X'F0'             MAKE PRINTABLE\n         LH    R2,SCRCS(,R12)          CONVERT SEMICOLON COUNTER TO\n         CVD   R2,WORKD                DECIMAL FOR PRINTING\n         MVC   12(L'SCPATTN,R3),SCPATTN  MOVE IN EDIT PATTERN\n         ED    12(L'SCPATTN,R3),WORKD+5  FORMAT SEMICOLON COUNT\n         TM    1(R6),FLAGIDS           DSNAME TO BE INSERTED ?\n         BNO   NOT1617A                NO, BRANCH\n         STC   R8,DSNUMBER             YES, STORE DATASET NUMBER\n         CLI   DSNUMBER,16             DSN = 16 ?\n         BNE   DSN17                   NO, BRANCH\n         MVC   2(6,R6),=C'SYSUT2'      SYSUT2\n         B     PSWDSN\n*\nDSN17    BL    NOT1617\n         MVC   2(6,R6),=C'SYSUT1'      SYSUT1\n         B     PSWDSN\n*\nTAKEDSN  CVD   R8,WORKD                CONVERT DATASET NUMBER TO\n         UNPK  6(2,R6),WORKD           DECIMAL FOR PRINTING\n         OI    7(R6),X'F0'             MAKE PRINTABLE\n         B     PSWDSN\n*\nTAKEPSW  UNPK  7(9,R6),PGOPSW(5,R12)   UNPACK OLD PSW FOR PRINTING\n         TR    7(8,R6),TRTABLE-240\n         MVI   15(R6),C' '\n         UNPK  16(9,R6),PGOPSW+4(5,R12)\n         MVI   24(R6),C' '\n         TR    16(8,R6),TRTABLE-240\n         B     PSWDSN\n*\nNOT1617  TM    1(R6),FLAGIDS           INSERT DATASET NUMBER ?\n         BO    TAKEDSN                 YES, BRANCH\nNOT1617A BM    TAKEPSW\n*\nPSWDSN   MVC   BUFFER(19),0(R3)        MOVE MESSAGE INTO BUFFER\n         SR    R2,R2\nLINE2    IC    R2,0(R6)                GET L'MSG TEXT\n         BCTR  R2,0                    DECR FOR EXE\n         EX    R2,EXMVC                MOVE MSG TEXT\n         TM    1(R6),FLAGMC            MSG HAS CONTINUATION ?\n         BZ    ENDLINE                 NO, BRANCH\n         BAL   R3,OUTPUT\n         LA    R6,3(R2,R6)             R6 -> NEXT LINE OF MESSAGE\n         B     LINE2                   LOOP FOR CONTINUATION LINE\n*\nEXMVC    MVC   BUFFER+19(0),2(R6)      EXE MVC\n*\nENDLINE  OI    FLAG,X'04'\n         BAL   R3,OUTPUT\n         MVI   SPACE,C'0'              SET ASA SKIP CHARACTER\n         MVI   SCOUNT+3,X'01'          INSERT NEW STEP LENGTH FOR S\n*\n***********************************************************************\n*\n*        GO THROUGH THE RETURN ADDR STACK\n*        IF A BLOCK OR PROCEDURE ENTRY IS FOUND THE DATA STORAGE\n*        AREAS ARE EDITED AND FSA IS CALLED FOR ISSUEING\n*        FREEMAIN\n*\n***********************************************************************\n*\nSPDAFREE L     R1,VSPDAP               FREEMAIN FOR SPDA AREAS\n         L     R2,0(,R1)\nMORESPDA LTR   R1,R2\n         BZ    MORERAS\n         L     R2,0(,R1)\n*\n         FREEMAIN R,LV=64,A=(R1)\n*\n         B     MORESPDA                LOOP AROUND\n*\nMORERAS  L     R14,RASPT(R12)          TEST IF MORE ENTRIES IN RAS\nMORERASA C     R14,RASSTART(R12)\n         BNH   ENDOFR\n         CLI   0(R14),X'00'            PROCEDURE OR BLOCK ENTRY ?\n         BE    PRENTRY\n         TM    DTSW(R12),X'80'         DUMP SPECIFIED ?\n         BZ    RELDSA\n         B     EDIT\n*\nPRENTRY  LA    R2,8                    GET PRECEDING ENTRY IN RAS\n         SR    R14,R2\n         ST    R14,RASPT(R12)          NEW ADDR TO RASTP IN FSA\n         B     MORERASA\n*\nRELDSA   LR    R13,R12                 RELEASE CURRENT DATA STORAGE\n         L     CDSA,0(,R14)            AREA\n         L     PBT,16(,CDSA)\n         L     R1,VFRDSA\n         BALR  R15,R1\n         LR    R12,R13\n         LA    R13,SAVEAREA\n         B     MORERAS\n*\nENDOFR   LR    R13,R12\n*\n         RETURN (14,12)                TO TERMINATION ROUTINE IN FSA\n*\n***********************************************************************\n*\n*        PRINT CURRENT DATA STORAGE AREAS IF DUMP IS SPECIFIED\n*\n***********************************************************************\n*\n*        BLOCK NUMBER AND TYPE OF BLOCK MOVED INTO TEXT\n*\n***********************************************************************\n*\nEDIT     L     CDSA,0(,R14)            POINTER TO CURRENT DSA\n         L     PBT,16(,CDSA)           ADDR OF PBTAB\n         MVC   ERM02M(4),4(PBT)        NAME OF LOAD MODULE\n         AH    PBT,8(,CDSA)            TYPE OF BLOCK\n         SR    R2,R2\n         IC    R2,6(,PBT)\n         SLL   R2,2\n         LA    R6,ERM02BK(R2)\n         MVC   ERM02TP,0(R6)           MOVE IN BLOCK TYPE TEXT\n         LH    R2,8(CDSA)              CONVERT BLOCK NUMBER TO DECIMAL\n         SRL   R2,3                    FOR PRINTING\n         CVD   R2,WORKD\n         MVC   ERM02BN,BNPATTN\n         ED    ERM02BN,WORKD+6\n         OI    FLAG,X'04'              SET SKIP FLAG\n         MVC   BUFFER(ERM02L),IHIERM02  MOVE MSG INTO BUFFER\n         BAL   R3,OUTPUT\n*\n***********************************************************************\n*\n*        EDIT THE FORMAL PARAMETERS IF PROCEDURE BLOCK\n*\n***********************************************************************\n*\n         SR    R1,R1\n         LA    R9,24(,CDSA)            FIRST BYTE TO BE EDITED\n         TM    6(PBT),X'FF'            TEST FOR FORMAL PARAMETERS\n         BZ    NOFPARAM\n         MVC   BUFFER+9(L'KFORMAL),KFORMAL  HANDLING FORMAL PARAMETERS\n         SR    R5,R5\n         IC    R5,7(,PBT)              PARAMETERS BY EIGHT\n         SLL   R5,3                    MULTIPLY NUMBER OF FORMAL\n         TM    6(PBT),X'08'\n         BZ    NOTYPE\n         LA    R5,8(,R5)               ADD EIGHT IF TYPE PROCEDURE\nNOTYPE   AR    R5,R9                   END OF FORMAL PARAMETERS IN R5\n         BAL   R4,TRANSDAT             PRINT FORMAL PARAMETERS\nNFPARM   OI    FLAG,X'04'              SET SKIP FLAG\n         BAL   R3,OUTPUT               LAST PARAMETERS\nNOFPARAM LH    R2,4(,PBT)              GET END OF OBJECT TIME STACK\n         LA    R5,0(R2,CDSA)\n         CR    R9,R5\n         BNL   ARRAYS\n*\n***********************************************************************\n*\n*        EDIT OBJECT TIME STACK\n*\n***********************************************************************\n*\n         MVC   BUFFER+9(L'IHIERM05),IHIERM05\n         NI    FLAG,X'7D'              BUFFER AND ARRAY FLAG\n         LTR   R1,R1                   ANY FORMAL PARAMETER PRINTED\n         BNZ   NOTZERO\n         B     MULT32A\n*\nMULT32   SRDL  R0,27\nMULT32A  OI    FLAG,X'80'              BUFFER FLAG\n         LA    R4,NFPARM\n         B     TRANSDAT\n*\nNOTZERO  SLDL  R0,27                   TEST IF END OF LINE\n         LTR   R1,R1\n         BZ    MULT32                  YES, BRANCH TO MULT32\n         SRDL  R0,27\n         CR    R9,R5                   TEST IF ANY DATA TO BE PRINTED\n         BNL   NFPARM\n         BAL   R3,OUTPUT               YES, PRINT HEADING\n         STC   R1,IF16                 TEST IF TIME FOR ONE STEP\n         NI    IF16,X'0F'\n         BNZ   LABAA\n         LA    R8,1(,R8)\nLABAA    BAL   R4,INSETDA\n         B     NFPARM\n*\n***********************************************************************\n*\n*        CONVERSION OF DATA FOR PRINTING AND EDITING OF THE OUTPUT\n*\n***********************************************************************\n*\nTRANSDAT CR    R9,R5                   TEST IF MORE DATA IS TO BE\n         BNLR  R4                      EDITED\n         SLDL  R0,27\n         LTR   R1,R1                   PRINT BUFFER IF END OF LINE\n         BZ    SETDISP\n         SLDL  R0,1\n         LTR   R1,R1                   IF INDEX MULTIPLE OF 16 THEN\n         BNZ   SHIFTB                  MAKE ONE EXTRA SPACE\n         LA    R8,1(,R8)\nSHIFTB   SRDL  R0,28\nTRANS    UNPK  0(9,R8),0(5,R9)         UNPACK HEXADECIMAL DATA FOR\n         MVI   8(R8),C' '              PRINTING\n         TR    0(8,R8),TRTABLE-240\n         LA    R1,4(R1)\n         LA    R8,10(R8)\n         LA    R9,4(R9)\n         B     TRANSDAT\n*\n***********************************************************************\n*\n*        DISPLACEMENT FOR DATA EDITED\n*\n***********************************************************************\n*\nSETDISP  SRDL  R0,27\n         BAL   R3,OUTPUT\n         TM    FLAG,X'02'              CHECK IF EDITING ARRAYS TO GET\n         BO    ADDR                    RIGHT DISPLACEMENT\nINSETDA  LA    R3,24(,R1)\nINSETD   ST    R3,WORKD                UNPACK HEXADECIMAL ADDR FOR\n         UNPK  BUFFER(7),WORKD+1(4)    PRINTING\n         OI    BUFFER+6,C' '\n         TR    BUFFER(6),TRTABLE-240\n         TM    FLAG,X'80'              PRINTING IS TO BE CONTINUED ?\n         BZ    INSETDB                 AND NOT START AT THE\n         LA    R8,BUFFER+9             BEGINNING OF A NEW LINE\nINSETDB  OI    FLAG,X'80'\n         B     TRANS\n*\nADDR     LR    R3,R1                   DISPLACEMENT FOR ARRAY\n         B     INSETD\n*\n***********************************************************************\n*\n*        EDITING OF DECLARED ARRAYS\n*\n***********************************************************************\n*\nARRAYS   ICM   R2,B'1111',12(CDSA)     ANY DECLARED ARRAYS ?\n         BZ    VALUE\nMOREARRY OI    FLAG,X'02'\nVARRSMF  L     R9,8(R2,CDSA)           STARTING ADDR OF ARRAY\n         ST    R2,WORKD                UNPACK HEXADECIMAL DISPLACEMENT\n         UNPK  ERM06SMF,WORKD+1(4)     OF SMF FOR PRINTING\n         MVI   ERM06SMF+6,C' '\n         TR    ERM06SMF(6),TRTABLE-240\n         MVC   BUFFER+9(ERM06L),IHIERM06\n         L     R5,12(R2,CDSA)          END ADDR OF ARRAY\n         SR    R1,R1\n         BAL   R4,TRANSDAT\n         L     R2,0(R2,CDSA)           GET CHAINING ADDR\n         LA    R2,0(,R2)\n         OI    FLAG,X'04'              SET SKIP FLAG\n         BAL   R3,OUTPUT               PRINT LAST LINE\n         LTR   R2,R2\n         BNZ   MOREARRY\n*\n***********************************************************************\n*\n*        EDITING OF VALUE ARRAYS\n*\n***********************************************************************\n*\nVALUE    LH    R2,10(CDSA)             TEST FOR VALUE ARRAYS\n         LTR   R2,R2\n         BZ    ENDVALAR\nVALARRAY OI    FLAG,X'02'\n         ST    R2,WORKD                UNPACK HEX DISPLACEMENT OF\n         UNPK  ERM07SMF,WORKD+1(4)     SMF FOR PRINTING\n         MVI   ERM07SMF+6,C' '\n         TR    ERM07SMF(6),TRTABLE-240\n         MVC   BUFFER+9(ERM07L),IHIERM07   TO BUFFER\n         L     R9,0(R2,CDSA)           ADDR OF SMF\n         L     R5,12(,R9)              END OF ARRAY\n         L     R9,8(,R9)               BEGINNING OF ARRAY\n         SR    R1,R1\n         BAL   R4,TRANSDAT             PRINT DATA\n         OI    FLAG,X'04'\n         BAL   R3,OUTPUT               PRINT LAST LINE\n         L     R9,0(R2,CDSA)           GET CHAINING DISPLACEMENT\n         LH    R2,2(,R9)\n         LTR   R2,R2\n         BZ    ENDVALAR\n         B     VALARRAY\n*\nENDVALAR BAL   R3,OUTPUT               PRINT ONE EXTRA BLANK LINE\n         OI    FLAG,X'04'\n         NI    FLAG,X'FD'              RESET ARRAY FLAG\n         B     RELDSA\n*\n***********************************************************************\n*\n*        PRINT THE MSG BUFFER BY USING THE IHIIORNX ROUTINE\n*\n***********************************************************************\n*\nOUTPUT   STM   R5,R8,40(R12)           SAVE REGS USED\n         LA    R6,1                    SET THE DATASET NUMBER TO 1\n         L     R5,ADSTAB(R12)          ENTRY OF DSN=1 IN DSTAB\n         LA    R5,DSTABLEL+4(,R5)      R5 -> DSTABLE ENTRY FOR DSN 1\n         L     R8,R\n         OI    DSF,DS3                 SET DS3 = 1\n         MVC   0(L'BUFFER,R8),BUFFER   MOVE BUFFER TO OUTPUT\n         LR    R0,R14                  SAVE ADDR OF RETURN STACK PTR\n         L     R15,VIORNX\n         BALR  R14,R15                 CALL NEXT RECORD ROUTINE\n         TM    FLAG,X'04'\n         BZ    NOFLAG\n         LH    R6,S                    INCREASE S-COUNTER IN DSTAB\nSCOUNT   LA    R6,2(,R6)\n         STH   R6,S\n         L     R5,R                    SKIP LINES IF SKIP FLAG IS SET\n         BCTR  R5,0                    AND NOT TIME FOR NEW PAGE\n         CLI   0(R5),C'1'              SKIP TO NEW PAGE ?\n         BE    RESFLAG                 YES, BRANCH\n         MVC   0(1,R5),SPACE\nRESFLAG  NI    FLAG,X'FB'              RESET SKIP FLAG\nNOFLAG   LR    R14,R0                  RESTORE RETURN STACK PTR\n         SR    R0,R0\n         MVI   BUFFER,C' '             BLANK BUFFER AFTER PRINTING\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n         LM    R5,R8,40(R12)\n         BR    R3                      RETURN TO CALLER\n*\nSAVEAREA DC    18F'0'\n*\nWORKD    DC    D'0'\nTRTABLE  DC    C'0123456789ABCDEF'     TRANSLATION TABLE\nFLAG     DC    X'84'\nSPACE    DC    C'-'                    ASA CNTL CHAR\nIF16     DS    0C\nDSNUMBER DC    X'00'\nBUFFER   DC    CL90' '                 MESSAGE BUFFER\nSCPATTN  DC    X'402020202020'         PATTERN FOR SEMICOLON COUNT\nBNPATTN  DC    X'40202020'             PATTERN FOR BLOCK NUMBER\n*\n*        HEADINGS\n*\nIHIERM02 DC    C'MODULE = '\nERM02M   DC    CL8' '\n         DC    C'  PROGRAM BLOCK NUMBER = '\nERM02BN  DC    C'    '\n         DC    C' ('\nERM02TP  DC    CL16' '\nERM02L   EQU   *-IHIERM02              L'IHIERM02\n*\nERM02BK  DC    CL16'BLOCK)          '  *\n         DC    CL16'PROCEDURE)      '  |\n         DC    CL16'TYPE PROCEDURE) '  V\n*\nKFORMAL  DC    C'FORMAL PARAMETERS'\n*\nIHIERM05 DC    C'DECLARED IDENTIFIERS AND OBJECT TIME STACK'\n*\nIHIERM06 DC    C'SMF DISPLACEMENT IN DSA = '\nERM06SMF DC    CL7' '\n         DC    C'DECLARED ARRAY'\nERM06L   EQU   *-IHIERM06              L'IHIERM06\n*\nIHIERM07 DC    C'SMF DISPLACEMENT IN DSA = '\nERM07SMF DC    CL7' '\n         DC    C'ARRAY CALLED BY VALUE'\nERM07L   EQU   *-IHIERM07              L'IHIERM07\n*\n***********************************************************************\n*\n*        EXTERNAL ADDRS\n\n***********************************************************************\n*\n*        PASSED IN PARAMETER LIST FROM CALLER IHIFSA\n*\nVFRDSA   DC    A(0)      V(FRDSA)\nVSPDAP   DC    A(0)      V(SPDAP)\nVIOROP   DC    A(0)      V(IHIIOROP)\nVIORCP   DC    A(0)      V(IHIIORCP)\nVIORNX   DC    A(0)      V(IHIIORNX)\n*\n*        ADDRS IN IHIERMSG MODULE\n*\nVERMSG   DC    V(IHIERMSG)\nVERM01   DC    V(IHIERM01)\n*\nFSARE    DSECT\n*\n         COPY  FSAREA\n*\n*        DATASET TABLE MAPPING DSECT\n*\n         DSTABLE DSECT=YES\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIFDD   0201-12230-12230-1200-00104-00104-00000-LEVEL\nFDD        TITLE 'IHIFDDXP, POWER ROUTINE, REAL**REAL, LONG PRECISION, X\n               ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION - SEE CODE\n*\n*        ENTRY POINT - IHIFDD - POWER FUNCTION, REAL**REAL, LONG\n*                      LA   R1,PARMLIST\n*                      BALR R14,R15\n*                      DATA PASSED BY NAME\n*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES -\n*\n*        IHILLO - LOGARITHM FUNCTION, LONG PRECISION\n*        IHILEX - EXPONENTIAL FUNCTION, LONG PRECISION\n*\n*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0\n*\n*        EXIT - ERROR -\n*        IF BASE IS ZERO AND EXPONENT NOT POSITIVE GOTO ERROR\n*        ROUTINE VIA\n*        B    FSAERR+35*4(R13)\n*\n*        TABLES/WORKAREAS - N/A\n*\nIHIFDDXP CSECT\n*\n*        FLOATING POINT REGISTERS\n*\nFPR0     EQU   0                       BASE NO, PASSING RESULT\nFPR2     EQU   2                       EXPONENT IN COMPUTATION\n*\n*        GENERAL PURPOSE REGISTERS\n*\n*        R1                            PARAMETER LIST REF\n*        R3                            INDEXING PARAMETER ADDR\n*\n         ENTRY IHIFDD\n*\nIHIFDD   SAVE  (14,12),,'IHIFDDXP LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LR    R2,R15\n         USING IHIFDDXP,R2\n         LR    R3,R13                  CHAIN SAVE AREAS\n         LA    R13,SAVEAREA\n         ST    R3,4(,R13)\n         ST    R13,8(,R3)\n         L     R3,0(,R1)               PLIST OF BASE NO IN R3\n         LD    FPR0,0(,R3)             BASE NO INTO FPR0\n         L     R3,4(,R1)               PLIST OF EXPONENT IN R3\n         LD    FPR2,0(,R3)             EXPONENT INTO FPR2\n         LTDR  FPR0,FPR0               BASE NO +, - OR ZERO ?\n         BZ    ERROR                   ZERO, BRANCH TO ERROR\n         BM    ERRORM                  NEGATIVE, UNDEFINED ERROR\n         LTDR  FPR2,FPR2               EXPONENT PLUS, MINUS, OR ZERO ?\n         BZ    LOAD1                   ZERO, BRANCH TO LOAD1\n         STD   FPR2,PARAM              STORE EXPONENT\n         L     R15,VIHILLO             R15 -> IHILLO ROUTINE\n         BALR  R14,R15                 CALL IHILLO ROUTINE\n         LD    FPR2,PARAM              RELOAD FPR2 WITH EXPONENT\n         MDR   FPR0,FPR2               MULT LOG OF BASE NO BY EXPONENT\n         STD   FPR0,PARAM              STORE RESULT AS EXP RTN PARM\n         LA    R1,ADCPAR               R1 -> EXP RTN PARM\n         L     R15,VIHILEX             R15 -> IHILEX ROUTINE\n         BALR  R14,R15                 CALL IHILEX ROUTINE\n         B     EXIT                    EXIT WITH RESULT IN FPR0\n*\nLOAD1    LD    FPR0,KFPDONE            PLUS 1 AS RESULT IN FPR0\nEXIT     L     R13,4(,R13)             R13 -> CALLERS SAVE AREA\n*\n         RETURN (14,12)                RESTORE CALLERS REGS AND RETURN\n*\nERROR    LTDR  FPR2,FPR2               EXPONENT PLUS, MINUS, OR ZERO ?\n         BP    EXIT                    EXPN IS POSITIVE, BRANCH TO EXIT\nERRORM   L     R13,4(R13)              R13 -> CALLERS SAVE AREA\n         B     FSAERR+35*4(R13)        BASENO EQUAL ZERO AND EXPONENT\n*                                      NO GREATER THAN ZERO, UNDERFINED\n*\n*        CONSTANTS AND ADCON AREAS\n*\nSAVEAREA DC    18F'0'                  SAVE AREA\nPARAM    DC    D'0'                    PARAM FOR DATA IN DEXP MATH RTN\nKFPDONE  DC    D'+1'                   CONSTANT ONE IN DOUBLE PREC FP\n*\nADCPAR   DC    A(PARAM)                ADDR OF PARAMETER FOR EXP RTN\n*\nVIHILLO  DC    V(IHILLO)               LOG MATH LIBRARY ROUT\nVIHILEX  DC    V(IHILEX)               EXP MATH LIBRARY ROUT\n*\nFSAERR   EQU   X'1CC'\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIFDI   0201-12230-12230-1200-00099-00099-00000-LEVEL\nFDI      TITLE 'IHIFDIXP, POWER ROUTINE, REAL**INTEGER, LONG PRECISION,X\n                ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION - SEE CODE\n*\n*        ENTRY POINT -\n*        IHIFDI - POWER FUNCTION, REAL**INT, LONG\n*        LA     R1,PARMLIST\n*        BALR   R14,R15\n*        DATA PASSED BY NAME\n*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0\n*\n*        EXIT - ERROR -\n*        IF BASE IS ZERO AND EXPONENT NOT POSITIVE GOTO ERROR\n*        ROUTINE VIA\n*        B    FSAERR+35*4(R13)\n*\n*        TABLES/WORKAREAS - N/A\n*\nIHIFDIXP CSECT\n*\n         ENTRY   IHIFDI\n*\n*        FLOATING POINT REGISTERS\n*\nFPR0     EQU   0                       BASE NO, PASSING RESULT\nFPR2     EQU   2                       FACTOR, COMPUTING RESULT\n*\n*        GENERAL PURPOSE REGISTERS\n*\n*        R0                            TESTING FOR MINUS EXPN\n*        R2                            EXPONENT IN COMPUTATION\n*\nIHIFDI   SAVE  (14,12),,'IHIFDIXP LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHIFDIXP,R15\n         L     R3,0(,R1)               LOAD PLIST OF BASE NO IN R3\n         LD    FPR0,0(,R3)             LOAD BASE NO INTO FPR0\n         L     R3,4(0,R1)              LOAD PLIST OF EXPONENT IN R3\n         L     R2,0(0,R3)              LOAD EXPONENT INTO R2\n         LTDR  FPR0,FPR0               BASE NO +, - OR ZERO ?\n         BZ    ERROR                   ZERO, BRANCH TO ERROR\n         SR    R0,R0                   SET NEGATIVE EXPN SWITCH TO 0\n         LTR   R2,R2                   EXPONENT +, - OR ZERO ?\n         BP    PLUS                    +VE, BRANCH TO PLUS\n         BZ    LOAD1                   ZERO, BRANCH TO LOAD1\n         LCR   R2,R2                   MINUS, CONVERT TO 2S COMPLIMENT\n         LA    R0,1                    SET EXP SW TO ONE FOR MINUS EXPN\nPLUS     LD    FPR2,KFPDONE            LOAD FACTOR OF ONE IN FPR2\nLOOP     SRDL  R2,1                    SHIFT LOW BIT R2 INTO R3\n         LTR   R3,R3                   LOWORDER BIT OF R2 MAKE R3 NEG ?\n         BNM   JUMP                    NO, BRANCH TO JUMP\n         MDR   FPR2,FPR0               YES, MULTIPLY FPR2 BY FPR0\nJUMP     LTR   R2,R2                   EXPONENT +, - OR ZERO ?\n         BZ    NEXT                    EXPONENT ZERO, BRANCH TO NEXT\n         MDR   FPR0,FPR0               MULT FPR0 NO BY DOUBLING ITSELF\n         B     LOOP                    LOOP TO TEST NEXT EXPN BIT\n*\nNEXT     LTR   R0,R0                   R0 +, - OR ZERO ?\n         BZ    SWAP                    EXPN \u00ac MINUS, BRANCH TO SWAP\n         LD    FPR0,KFPDONE            LOAD ONE IN FPR0 AS DIVIDEND\n         DDR   FPR0,FPR2               DIV FPR0  BY FPR2 (RESULT)\n         B     EXIT                    EXIT (RESULT IN FPR0)\n*\nSWAP     LDR   FPR0,FPR2               LOAD FPR2 INTO FPR0\n         B     EXIT                    EXIT (RESULT IN FPR0)\n*\nLOAD1    LD    FPR0,KFPDONE            LOAD PLUS 1 AS RESULT IN FPR0\n*\nEXIT     RETURN (14,12)                RESTORE CALLERS REGS AND RETURN\n*\nERROR    LTR   R2,R2                   EXPONENT +, - OR ZERO ?\n         BP    EXIT                    EXPN IS POSITIVE, BRANCH TO EXIT\n         B     FSAERR+35*4(13)         BASE NO = ZERO AND EXPONENT\n*                                      \u00ac> ZERO, UNDEFINED\n*\n*        ADCONS AND CONSTANTS AREA\n*\nKFPDONE  DC    D'+1'                   CONSTANT ONE IN DOUBLE PREC FP\n*\nFSAERR   EQU   X'1CC'\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIFII   0201-12230-12230-1200-00107-00107-00000-LEVEL\nFII      TITLE 'IHIFIIXP, POWER ROUTINE, INTEGER**INTEGER, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION - SEE CODE\n*\n*        ENTRY POINT -\n*        IHIFII - POWER FUNCTION, INT**INT\n*        LA     R1,PARMLIST\n*        BALR   R14,R15\n*        DATA PASSED BY NAME\n*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        EXIT - NORMAL - RETURN VIA R14, RESULT IN R0\n*\n*        EXIT - ERROR -\n*        IF BASE IS ZERO AND EXPONENT NOT POSITIVE GOTO ERROR\n*        ROUTINE VIA\n*        B    FSAERR+35*4(R13)\n*\n*        TABLES/WORKAREAS - N/A\n*\nIHIFIIXP CSECT\n*\n*        GENERAL PURPOSE REGISTERS\n*\n*        R0                            PASSING ON FINAL RESULT\n*        R1                            PARAMETER LIST REF\n*        R2                            MPY REG FOR FACTOR\n*        R3                            FACTOR AND ANSWER\n*        R4                            MPY REG FOR BASE NO\n*        R5                            BASE NO IN COMPUTATION\n*        R6                            EXPONENT IN COMPUTATION\n*        R7                            INDEXING PARAMETER ADDR\n*\nIHIFII   SAVE  (14,12),,'IHIFIIXP LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHIFIIXP,R15\n         L     R7,0(,R1)               LOAD PLIST OF BASE NO IN R7\n         L     R5,0(,R7)               LOAD BASE NO INTO R5\n         L     R7,4(,R1)               LOAD PLIST OF EXPONENT IN R7\n         L     R6,0(,R7)               LOAD EXPONENT INTO R6\n         LTR   R0,R5                   LOAD BASE NO INTO RESULT REG\n*                                      BASE NO +, - OR ZERO ?\n         BZ    ERROR                   ZERO, BRANCH TO ERROR\n         LTR   R6,R6                   EXPONENT +, - OR ZERO ?\n         BZ    LOAD1                   ZERO, BRANCH TO LOAD1\n         BCTR  R5,0                    DECR VALUE OF BASE NO\n         LTR   R5,R5                   BASE NO + - OR ZERO ?\n         BZ    EXIT                    ZERO, BRANCH TO EXIT\n         LA    R5,2(,R5)               INCR BY TWO VALUE OF BASE NO\n         LTR   R5,R5                   BASE NO +, - OR ZERO ?\n         BZ    TEST                    ZERO, BRANCH TO TEST\n         LTR   R6,R6                   EXPONENT +, - OR ZERO ?\n         BP    PLUS                    POSITIVE, BRANCH TO PLUS\n         SR    R0,R0                   EXPN MINUS, RESULT = ZERO\n         B     EXIT                    EXIT ROUTINE\n*\nPLUS     LR    R5,R0                   RELOAD ORG BASE NO FROM RESULT\n         L     R3,KF1                  LOAD FACTOR OF ONE IN R3\nLOOP     SRDL  R6,1                    SHIFT LOW BIT R6 INTO R7\n         LTR   R7,R7                   LOWORDER BIT OF R6 MAKE R7 NEG ?\n         BNM   JUMP                    NO, BRANCH TO JUMP\n         MR    R2,R5                   MULTIPLY FACTOR REG BY R5\n         SLDA  R2,32                   CHECK OVERFLOW\n         SRDA  R2,32\nJUMP     LTR   R6,R6                   EXPONENT +, - OR ZERO ?\n         BZ    NEXT                    EXPONENT ZERO, BRANCH TO NEXT\n         MR    R4,R5                   MULT BASE NO BY DOUBLING ITSELF\n         SLDA  R4,32\n         SRDA  R4,32\n         B     LOOP                    LOOP TO TEST NEXT EXPN BIT\n*\nNEXT     LR    R0,R3                   LOAD FACTOR INTO RESULT\n         B     EXIT                    EXIT\n*\nTEST     SRDL  R6,1                    SHIFT LOW BIT R6 INTO R7\n         LTR   R7,R7                   LOWORDER BIT OF R6 MAKE R7 NEG ?\n         BM    EXIT                    MINUS (EXPN ODD), GOTO EXIT\nLOAD1    L     R0,KF1                  LOAD R0 WITH VALUE OF PLUS 1\nEXIT     STM   R0,R1,20(R13)           UPDATE SAVEAREA WITH RESULT\n*\n         RETURN (14,12)                RESTORE CALLERS REGS AND RETURN\n*\nERROR    LTR   R6,R6                   EXPONENT +, - OR ZERO ?\n         BP    EXIT                    EXPN IS POSITIVE, BRANCH TO EXIT\n         B     FSAERR+35*4(R13)\n*\n*        ADCONS AND CONSTANTS AREA\n*\nKF1      DC    F'1'                    INTERGER CONSTANT OF ONE\n*\nFSAERR   EQU   X'1CC'\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIFRI   0201-12230-12230-1200-00099-00099-00000-LEVEL\nFRI   TITLE 'IHIFRIPXP, POWER ROUTINE, REAL**INTEGER, SHORT PRECISION, X\n               ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION - SEE CODE\n*\n*        ENTRY POINT -\n*        IHIFRI - POWER FUNCTION, REAL**INT, SHORT\n*                 LA     R1,PARMLIST\n*                 BALR   R14,R15\n*                 DATA PASSED BY NAME\n*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0\n*\n*        EXIT - ERROR -\n*        IF BASE IS ZERO AND EXPONENT NOT POSITIVE GOTO ERROR\n*        ROUTINE VIA\n*        B    FSAERR+35*4(R13)\n*\n*        TABLES/WORKAREAS - N/A\n*\nIHIFRIXP CSECT\n*\n         ENTRY   IHIFRI\n*\n*        FLOATING POINT REGISTERS\n*\nFPR0     EQU   0                       REG FOR BASE NO, PASSING RESULT\nFPR2     EQU   2                       REG FOR FACTOR, COMPUTING RESULT\n*\n*        GENERAL PURPOSE REGISTERS\n*\n*        R0                            REG FOR TESTING FOR MINUS EXPN\n*        R2                            REG FOR EXPONENT IN COMPUTATION\n*\nIHIFRI   SAVE  (14,12),,'IHIFRIXP LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHIFRIXP,R15\n         L     R3,0(,R1)               LOAD PLIST OF BASE NO IN R3\n         LE    FPR0,0(,R3)             LOAD BASE NO INTO FPR0\n         L     R3,4(,R1)               LOAD PLIST OF EXPONENT IN R3\n         L     R2,0(,R3)               LOAD EXPONENT INTO R2\n         LTER  FPR0,FPR0               BASE NO +, - OR ZERO ?\n         BZ    ERROR                   ZERO, BRANCH TO ERROR\n         SR    R0,R0                   SET NEGATIVE EXPN SWITCH TO 0\n         LTR   R2,R2                   EXPONENT +, - OR ZERO ?\n         BP    PLUS                    +VE, BRANCH TO PLUS\n         BZ    LOAD1                   ZERO, BRANCH TO LOAD1\n         LCR   R2,R2                   MINUS, CONVERT TO 2S COMPLIMENT\n         LA    R0,1                    SET EXP SW TO ONE FOR MINUS EXPN\nPLUS     LE    FPR2,KFPONE             LOAD FACTOR OF ONE IN FPR2\nLOOP     SRDL  R2,1                    SHIFT LOW BIT R2 INTO R3\n         LTR   R3,R3                   LOWORDER BIT OF R2 MAKE R3 NEG ?\n         BNM   JUMP                    NO, BRANCH TO JUMP\n         MER   FPR2,FPR0               YES, MULTIPLY FPR2 BY FPR0\nJUMP     LTR   R2,R2                   EXPONENT +, -, OR ZERO ?\n         BZ    NEXT                    EXPONENT ZERO, BRANCH TO NEXT\n         MER   FPR0,FPR0               MULT BASE NO BY DOUBLING ITSELF\n         B     LOOP                    LOOP TO TEST NEXT EXPN BIT\n*\nNEXT     LTR   R0,R0                   R0 +, - OR ZERO ?\n         BZ    SWAP                    EXPN \u00ac MINUS, BRANCH TO SWAP\n         LE    FPR0,KFPONE             LOAD ONE IN FPR0 AS DIVIDEND\n         DER   FPR0,FPR2               DIV BASE REG BY FPR2 (RESULT)\n         B     EXIT                    EXIT (RESULT IN FPR0)\n*\nSWAP     LER   FPR0,FPR2               LOAD FPR2 INTO FPR0\n         B     EXIT                    EXIT (RESULT IN FPR0)\n*\nLOAD1    LE    FPR0,KFPONE             LOAD PLUS 1 AS RESULT IN FPR0\n*\nEXIT     RETURN (14,12)                RESTORE CALLERS REGS AND RETURN\n*\nERROR    LTR   R2,R2                   EXPONENT +, - ZERO ?\n         BP    EXIT                    EXPN IS POSITIVE, BRANCH TO EXIT\n         B     FSAERR+35*4(R13)        BASE NO = ZERO AND EXPONENT\n*                                      \u00ac> ZERO, UNDEFINED\n*\n*        ADCONS AND CONSTANTS AREA\n*\nKFPONE   DC    E'1'                    CONSTANT ONE IN SINGLE PREC FP\n*\nFSAERR   EQU   X'1CC'\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIFRR   0201-12230-12230-1200-00105-00105-00000-LEVEL\nFRR       TITLE 'IHIFRRXP, POWER ROUTINE, REAL**REAL, SHORT PRECISION, X\n               ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION - SEE CODE\n*\n*        ENTRY POINT -\n*        IHIFRR - POWER FUNCTION, REAL**REAL, SHORT\n*                 LA     R1,PARMLIST\n*                 BALR   R14,R15\n*                 DATA PASSED BY NAME\n*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES -\n*        IHISLO - LOGARITHM FUNCTION, SHORT PRECISION\n*        IHISEX - EXPONENTIAL FUNCTION, SHORT PRECISION\n*\n*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0\n*\n*        EXIT - ERROR -\n*        IF BASE IS ZERO AND EXPONENT NOT POSITIVE GOTO ERROR\n*        ROUTINE VIA\n*        B    FSAERR+35*4(R13)\n*\n*        TABLES/WORKAREAS - N/A\n*\nIHIFRRXP CSECT\n*\n         ENTRY   IHIFRR\n*\n*        FLOATING POINT REGISTERS\n*\nFPR0     EQU   0                       BASE NO, PASSING RESULT\nFPR2     EQU   2                       EXPONENT IN COMPUTATION\n*\n*        GENERAL PURPOSE REGISTERS\n*\n*        R1                            PARAMETER LIST REF\n*        R2                            SECOND BASE ADDR\n*        R3                            INDEXING PARAMETER ADDR\n*\nIHIFRR   SAVE  (14,12),,'IHIFRRXP LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LR    R2,R15\n         USING IHIFRRXP,R2\n         LR    R3,R13                  CHAIN SAVE AREAS\n         LA    R13,SAVEAREA\n         ST    R3,4(,R13)\n         ST    R13,8(,R3)\n         L     R3,0(,R1)               LOAD PLIST OF BASE NO IN R3\n         LE    FPR0,0(,R3)             LOAD BASE NO INTO FPR0\n         L     R3,4(,R1)               LOAD PLIST OF EXPONENT IN R3\n         LE    FPR2,0(,R3)             LOAD EXPONENT INTO FPR2\n         LTER  FPR0,FPR0               BASE NO +, - OR ZERO ?\n         BZ    ERROR                   ZERO, BRANCH TO ERROR\n         BM    ERRORM                  NEGATIVE UNDEFINED, ERROR\n         LTER  FPR2,FPR2               EXPONENT +, - OR ZERO ?\n         BZ    LOAD1                   ZERO, BRANCH TO LOAD1\n         STE   FPR2,PARAM              STORE EXPONENT IN PARAM\n         L     R15,VIHISLO             R15 -> IHISLO ROUTINE\n         BALR  R14,R15                 CALL IHISLO ROUTINE\n         LE    FPR2,PARAM              RELOAD FPR2 WITH EXPONENT\n         MER   FPR0,FPR2               MULT LOG OF BASE NO BY EXPONENT\n         STE   FPR0,PARAM              STORE RESULT IN PARAM\n         LA    R1,ADCPAR               R1 -> EXP RTN PARAM\n         L     R15,VIHISEX             R15 -> IHISEX ROUTINE\n         BALR  R14,R15                 CALL IHISEX ROUTINE\n         B     EXIT                    EXIT (RESULT IN FPR0)\n*\nLOAD1    LE    FPR0,KFPONE             LOAD PLUS 1 AS RESULT IN FPR0\nEXIT     L     R13,4(,R13)             R13 -> CALLERS SAVE AREA\n*\n         RETURN (14,12)                RESTORE CALLERS REGS AND RETURN\n*\nERROR    LTER  FPR2,FPR2               EXPONENT +, - OR ZERO\n         BP    EXIT                    EXPN IS POSITIVE, BRANCH TO EXIT\nERRORM   L     R13,4(,R13)             R13 -> CALLERS SAVE AREA\n         B     FSAERR+35*4(R13)        BASE NO = ZERO AND EXPONENT\n*                                      \u00ac> ZERO, UNDEFINED\n*\n*        CONSTANTS AND ADCON AREAS\n*\nSAVEAREA DC    18F'0'                  SAVE AREA\nPARAM    DC    F'0'                    PARAM FOR DATA IN EXP MATH RTN\nKFPONE   DC    E'1'                    CONSTANT ONE IN SINGLE PREC FP\n*\nADCPAR   DC    A(PARAM)                ADDR OF PARAMETER FOR EXP RTN\n*\nVIHISLO  DC    V(IHISLO)               LOG MATH LIBRARY ROUTINE\nVIHISEX  DC    V(IHISEX)               EXP MATH LIBRARY ROUTINE\n*\nFSAERR   EQU   X'1CC'\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIFSA   0201-12230-12230-1200-02271-02271-00000-LEVEL\nFSA      TITLE 'IHIFSA, RUNTIME FIXED STORAGE AREA, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        FUNCTION/OPERATION -\n*        IHIFSA IS A COLLECTION OF ABOUT 20 ROUTINES WHICH ARE\n*        REQUIRED FOR THE EXECUTION OF ALGOL PROGRAMS. THE ENTRY\n*        POINT AND PURPOSE OF EACH ROUTINE IS LISTED UNDER ENTRY\n*        POINTS BELOW DETAILED INFORMATION ON THE FUNCTION,\n*        CALLING SEQUENCE, TRANSMISSION OF PARAMETERS ETC CAN BE\n*        FOUND IN THE COMMENTARY WHICH PRECEDES THE PROGRAM\n*        LISTING FOR EACH ROUTINE\n*\n*        THE MODULE CONSISTS OF TWO CONTROL SECTIONS, IHIFSARA\n*        AND IHIFSARB.\n*        IHIFSARA CONTAINS THE ROUTINES, TABLES AND OTHER\n*        INFORMATION USED DURING THE EXECUTION OF THE ALGOL\n*        OBJECT PROGRAM\n*        IHIFSARB CONTAINS MAINLY THE INITIALIZATION AND\n*        TERMINATION ROUTINES WITH THEIR ASSOCIATED TABLES AND\n*        WORK AREAS\n*\n*        R13 - BASE REGISTER FOR IHIFSARA\n*        R7  - BASE REGISTER FOR IHIFSARB\n*\n*        ENTRY POINTS -\n*        MOST OF THE ENTRY POINTS LISTED HERE ARE COLLECTED IN A\n*        BRANCH LIST LOCATED AT BRLIST. THE ENTRY POINTS\n*        CONTAINED IN THIS BRANCH LIST ARE MARKED WITH AN\n*        ASTERISK AFTER THE NAME IN THE LISTING BELOW\n*\n*        CAP1*     - CALL ACTUAL PARAMETER\n*                    PART 1. ENTER THUNK ROUTINE FROM A PROCEDURE\n*        CAP2*     - CALL ACTUAL PARAMETER\n*                    PART 2. RETURN FROM THE THUNK ROUTINE TO\n*                    THE PROCEDURE\n*        PROLOGP*  - ENTER A PROCEDURE WHEN IT IS CALLED VIA AN\n*                    ACTUAL PARAMETER\n*        PROLOG*   - ENTER A BLOCK OR A PROCEDURE\n*        RETPROG*  - LEAVE A BLOCK OR PROCEDURE VIA A 'GO TO'\n*                    STATEMENT\n*        EPILOGP*  - RETURN FROM A PROCEDURE VIA THE 'END'\n*                    STATEMENT\n*        EPILOGB*  - LEAVE A BLOCK VIA THE 'END' STATEMENT\n*        FRDSA     - FREE STORAGE FOR DSA AND ARRAYS\n*                    SYNONYM FOR EPILOGB WHEN USED AS A SUBROUTINE\n*                    BY THE ERROR ROUTINE IHGERROR\n*        CSWE1*    - CALL SWITCH ELEMENT, PART 1\n*        CSWE2*    - CALL SWITCH ELEMENT, PART 2\n*        LOADPP*   - LOAD A PRECOMPILED PROCEDURE\n*        SPDECL    - STANDARD PROCEDURE DECLARATION ROUTINE\n*                    (ENTERED VIA THE PROLOG ROUTINE)\n*        VALUCALL* - HANDLE FORMAL PARAMETERS CALLED BY VALUE\n*        GETMSTO*  - GET MAIN STORAGE FOR ARRAYS\n*        CNVIRD    - CONVERT INTEGER TO REAL\n*        CNVRDI    - CONVERT REAL TO INTEGER\n*        ENTIER    - EXECUTE ALGOL ENTIER FUNCTION\n*        TRACE*    - STORE THE CURRENT SEMICOLON NUMBER\n*        IHGFSAIN  - INITIALIZE FOR PROGRAM EXECUTION AND GIVE\n*                    CONTROL TO THE OBJECT MODULE\n*        TERMNTE*  - TERMINATE THE EXECUTION\n*        PIEROUT   - PROGRAM INTERRUPT ROUTINE\n*        FSAERR    - STORE ERROR NUMBER AND CALL THE ERROR\n*                    ROUTINE IHIERROR\n*\n*        INPUT -\n*        IF THE TRACE OPTION IS USED, THE TERMINATION ROUTINE MAY\n*        READ A TABLE OF SEMICOLON NUMBERS, WHICH HAS BEEN\n*        WRITTEN ON SYSUT1 BY THE TRACE ROUTINE\n*\n*        OUTPUT -\n*        IF THE TRACE OPTION IS USED, THE TRACE ROUTINE MAY WRITE\n*        A TABLE OF SEMICOLON NUMBERS ON SYSUT1. THIS TABLE IS\n*        READ AND THEN WRITTEN ON SYSPRINT IN EDITED FORMAT BY\n*        THE TERMINATION ROUTINE.\n*        THE MESSAGE 'END OF ALGOL PROGRAM EXECUTION' IS WRITTEN\n*        ON SYSPRINT AS THE FINAL OUTPUT FROM THE EXECUTION.\n*\n*        EXTERNAL ROUTINES -\n*        IHIIOROP - OPEN A DATASET (USED ONLY FOR SYSPRINT)\n*        IHIIORCL - CLOSE A DATASET (USED ONLY FOR SYSPRINT)\n*        IHIIORCP - CLOSE ALL OPEN DATASETS (EXCEPT SYSUT1)\n*        IHIIORNX - HANDLE THE NEXT I/O RECORD\n*        IHIERROR - EDIT AND PRINT AN ERROR MESSAGE AND, IF\n*                   REQUESTED, AN ALGOL STORAGE DUMP.\n*                   (ENTERED BY CALL)\n*\n*        THE FOLLOWING TWO EXTERNAL TABLES ARE IN THE OBJECT\n*        MODULE -\n*        IHIENTIF - INFORMATION NEEDED FOR ENTERING THE OBJECT MODULE\n*             FORMAT -\n*             IHIENTIF DC A(PBTAB)  ADDR OF PROGRAM BLOCK TABLE\n*                      DC A(LATAB)  ADDR OF LABEL ADDR TABLE\n*                      DC X'02' OR X'00' FOR SHORT/LONG PREC\n*                      DC AL3(ENTRYPOINT)  ADDR OF FIRST INSTRUCTION\n*\n*        IHIDSTAB - INFORMATION ABOUT THE STATUS OF EACH DATASET USED\n*             FORMAT AND USE -\n*             SEE THE DSECT DSTABLE AND THE LISTING OF\n*             THE I/O SUBROUTINE MODULE IHIIORTN\n*\n*        EXITS - NORMAL -\n*        THE TERMINATION ROUTINE IS ENTERED BY A BRANCH TO\n*        TERMNTE, AND A FINAL RETURN IS BY A RETURN MACRO WITH\n*        THE RETURN CODE ZERO IN R15\n*\n*        EXITS - ERRORS -\n*        ON RETURN FROM THE ERROR ROUTINE IHIERROR, THE\n*        TERMINATION ROUTINE IS ENTERED BY A BRANCH TO ALGTRMA,\n*        AND A FINAL RETURN IS MADE BY A RETURN MACRO WITH THE\n*        RETURN CODE 16 IN R15\n*\n*        TABLES/WORK AREAS -\n*        THE LOWER PART OF IHIFSARA CONTAINS A BLOCK OF WORK\n*        AREAS AND CONSTANTS WHICH ARE USED IN COMMON BY SEVERAL\n*        ROUTINES.\n*        THE MOST IMPORTANT ARE -\n*        SAVE     - STANDARD SAVEAREA USED BY ALL FIRST LEVEL\n*                   SUBROUTINES EXCEPT THOSE CONTAINED IN THIS MODULE\n*        ASAVE    - SAVE AREA USED BY SOME ROUTINES IN THIS MODULE\n*        FCTVALST - STORAGE FOR THE RESULT OF AN ALGOL FUNCTION\n*        PROLPBN  - PROGRAM BLOCK NUMBER OF A BLOCK OR PROCEDURE\n*                   TO BE ENTERED VIA THE PROLOG ROUTINE\n*        PGOPSW   - THE OLD PSW IN CASE OF A PROGRAM INTERRUPT\n*        SCRCS    - THE CURRENT SEMICOLON NUMBER\n*        OPTSW    - FLAG BITS REPRESENTING EXECUTION TIME OPTIONS\n*                   AND SWITCHES FOR CONTROLLING THE PROGRAM FLOW\n*        FSAERCOD - ERROR NUMBER IDENTIFYING AN EXECUTION ERROR\n*        IHIFSARS - FOUR POINTERS FOR CONTROLLING THE RETURN\n*                   ADDR STACK\n*        BRLIST   - A LIST OF ENTRY POINTS TO MOST OF THE ROUTINES\n*                   MENTIONED UNDER 'ENTRY POINTS'. THE LIST CONSISTS\n*                   MAINLY OF BRANCH INSTRUCTIONS\n*        IHIFSAER - A LIST OF BAL INSTRUCTIONS, EACH\n*                   CORRESPONDING TO ONE TYPE OF ERROR, THE\n*                   NUMBER OF WHICH IS DETERMINED BY ITS POSITION\n*                   IN THE LIST\n*\n*        OTHER WORK AREAS AND CONSTANTS OF GENERAL\n*        INTEREST ARE -\n*        PARMLIST - A LIST OF THE VALID EXECUTION OPTION\n*                   PARAMETERS\n*        TRBUF    - BUFFER POINTERS AND RECORD COUNTER FOR\n*                   CONTROLLING THE OUTPUT OF TRACING\n*                   INFORMATION ON SYSUT1\n*        PIETAB   - A LIST OF 16 ADDR CONSTANTS EACH POINTING\n*                   TO AN ENTRY IN IHIFSAER, WHICH CORRESPONDS\n*                   TO A TYPE OF PROGRAM INTERRUPT\n*        FPINST   - A LIST OF FLOATING POINT INSTRUCTIONS USED BY\n*                   THE VALUCALL AND SPDECL ROUTINES\n*        CNVINSTE - INSTRUCTIONS TO BE INSERTED INTO THE CONVERT\n*                   ROUTINE FOR SHORT PRECISION\n*        CNVINSTD - INSTRUCTIONS TO BE INSERTED INTO THE CONVERT\n*                   ROUTINE FOR LONG PRECISION\n*\n*        ATTRIBUTES - THIS MODULE IS SERIALLY REUSABLE\n*\n*        NOTES -\n*        THIS MODULE IS ONLY INTENDED TO BE USED WHEN LINKAGE\n*        EDITED TOGETHER WITH AN OS/360 ALGOL OBJECT MODULE AND\n*        WITH THE OS/360 ALGOL I/O ROUTINES. FOR REASONS OF\n*        EFFICIENCY CERTAIN LOCAL CONVENTIONS ARE OBEYED IN THE\n*        COMMUNICATION BETWEEN THESE MODULES\n*        REGISTER SAVING AND RESTORING IS ONLY DONE WHEN\n*        REQUIRED AND THEN GENERALLY IN A NON STANDARD FASHION\n*\n*        USE OF GENERAL REGISTERS WHEN COMMUNICATING WITH THE\n*        OBJECT MODULE -\n*        R8 (ADR)    MAY BE USED AS RETURN REGISTER AND\n*                    PARAMETER POINTER\n*        R10 (CDSA)  -> CURRENT ACTIVE DATA STORAGE AREA\n*        R11 (PBT)   -> PROGRAM BLOCK TABLE IN THE OBJECT MODULE\n*        R12 (LAT)   -> LABEL ADDR TABLE IN THE OBJECT MODULE\n*        R13 (FSA)   SERVES BOTH AS THE STANDARD SAVE AREA\n*                    REGISTER AND AS BASE REGISTER FOR THE\n*                    CSECT IHIFSARA\n*        R14         TRANSMIT INTEGER VALUES TO OR\n*                    FROM CONVERT ROUTINES\n*        R15         RETURN REGISTER AND PARAMETER POINTER\n*        FP0         TRANSMIT REAL VALUES TO OR FROM CONVERT ROUTINES\n*\n*        USE OF GENERAL REGISTERS WHEN COMMUNICATING WITH THE\n*        I/O ROUTINES -\n*\n*        R5      (DSN)    -> RELEVANT ENTRY IN THE DATASET TABLE\n*        R6      (DSNR)      DATASET NUMBER\n*        R12     (FSAA)      BASE ADDR OF IHIFSARA\n*\n*        PARAMETER VALUES AND OTHER INFORMATION ARE OFTEN\n*        TRANSMITTED IMPLICITLY VIA THE COMMONLY ACCESSIBLE\n*        WORKING STORAGE IN THE LOWER PART OF IHIFSARA AND (FOR\n*        I/O ROUTINES) VIA THE DATASET TABLE IN THE OBJECT\n*        MODULE\n*\n*        THE MODULE WORKS FOR EITHER SINGLE OR DOUBLE FLOATING\n*        POINT PRECISION. IT SENSES THE PRECISION FOR WHICH THE\n*        OBJECT MODULE WAS COMPILED AND INITIALIZES ITSELF\n*        ACCORDINGLY. THE AREAS AFFECTED ARE THE LIST OF FLOATING\n*        POINT INSTRUCTIONS AT FPINST AND THE BLOCK OF\n*        INSTRUCTIONS STARTING AT CNVINST IN THE CONVERT\n*        ROUTINES\n*\n*        THE OPERATION OF THIS MODULE DEPENDS UPON AN INTERNAL\n*        REPRESENTATION OF THE EXTERNAL CHARACTER SET WHICH IS\n*        EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME\n*\nIHIFSARA CSECT\n*\n*        REGISTERS FOR COMMUNICATION WITH THE OBJECT MODULE\n*\n*        R8                            ADDRESSING REGISTER\nGDSA     EQU   9                       GLOBAL DSA\nCDSA     EQU   10                      CURRENT DSA\nPBT      EQU   11                      PROGRAM BLOCK TABLE\nLAT      EQU   12                      LABEL ADDR TABLE\n*        R13                           IHIFSARA BASE REGISTER\n*\n*        REGISTERS FOR COMMUNICATION WITH I/O SUBROUTINES\n*\n*        R5                            -> DATASET TABLE ENTRY\n*        R6                            DATASET NUMBER\nFSAA     EQU   12                      ALTERNATE FSA BASE REGISTER\n*\n*        REGISTERS USED BY TRACE AND TERMINATION ROUTINES\n*\n*        R4                            BYTE POINTER IN TRACE BUFFER\n*        R5                            SEMICOLON NUMBER\n*        R6                            LOWER TRACE LIMIT\n*        R7                            UPPER TRACE LIMIT\n*        R8                            TRACE BUFFER ADDR\n*        R9                            ALTERNATE TRACE BUFFER ADDR\n*        R10                           LENGTH OF TRACE BUFFER\n*        R11                           NUMBER OF TRACE RECORDS\n*\n*        FLOATING POINT REGISTER\n*\nFPR0     EQU   0\n*\n*        BIT PATTERNS\n*\nBETABM   EQU   X'0C'                   MASK FOR BETA BLOCK FLAG IN PBT\nCODEPRM  EQU   X'10'                   MASK FOR CODE PROCEDURE IN PBT\nPIMASK   EQU   X'04'                   MASK FOR PI PROCEDURE IN PBT\nRASLOADM EQU   X'FE'                   LOAD PROCEDURE ENTRY IN RAS\nRASPARMM EQU   X'00'                   CAP OR CSWE ENTRY IN RAS\nSHORTBIT EQU   X'10'                   FP OPCODE MODIFIER\n*\n*        SWITCHES IN OPTSW\n*\nDPSW     EQU   X'80'                   DUMP  OPTION SWITCH\nTRSW     EQU   X'40'                   TRACE OPTION SWITCH\nSHSW     EQU   X'20'                   SHORT PRECISION OPTION SWITCH\nTERMSW   EQU   X'10'                   TERMINATION ROUTINE ENTERED\nERROR    EQU   X'08'                   ERROR ROUTINE ENTERED\nUT1ERR   EQU   X'04'                   ERROR ON SYSUT1\nPRNTERR  EQU   X'02'                   ERROR ON SYSPRINT\nUCTRSW   EQU   X'41'                   UNCONDITIONAL TRACE OPTION\nPPTRSW   EQU   X'01'                   TRACE PRECOMP PROCEDURES\n*\n*        ESD SYMBOLS\n*\n         ENTRY IHIFSAIN\n*\n         EXTRN IHIDSTAB\n         EXTRN IHIENTIF\n         EXTRN IHIIOROP,IHIIORCL,IHIIORNX,IHIIORCI,IHIIOREV\n         EXTRN IHIIOROQ,IHIIOREN,IHIIORGP,IHIIORCP,IHIIORER\n*\n         COPY  FSAREA\n*\n         COPY  FSACONV\n*\n         ORG   FSAREA+ADSTAB\n         DC    A(IHIDSTAB)\n*\n***********************************************************************\n*\n*        INSTRUCTIONS/DATA INSERTED INTO THE FSA AT BRLIST\n*\n***********************************************************************\n*\n         ORG   BRLIST\n         USING IHIFSARA,R13\n*\n         B     CAP1A                   CAP1\n         B     CAP2A                   CAP2\n         B     PROLP                   PROLOGP\n         B     PROL                    PROLOG\n         B     RETPROGA                RETPROG\n         B     EPILP                   EPILOGP\n         B     EPILB                   EPILOGB\n         B     EPIL3                   EPILPR3\n         B     CSWE1A                  CSWE1\n         B     CSWE2A                  CSWE2\n         B     LOADPPA                 LOADPP\n*\n*        TRACE\n*\n         MVC   SCRCS(2,R13),0(R15)     INSERT SEMICOLON NUMBER\n         B     2(R15)                  MODIFIED TO NOP IF TRACE\n         B     TRACEA\n         B     TERMN                   TERMNTE\n         NOPR  R15                     BCR\n         B     GETMAIN                 GETMSTO\n         B     VALUCAL                 VALUCALL\n*\n*        COMMON I/O ROUTINES IHIIOR @ IORLST\n*\n         DC    A(ADRLST)\n*\n***********************************************************************\n*\n*        EXITS FOR EXECUTION ERRORS\n*\n***********************************************************************\n*\n*\n*        ENTRY POINTS FOR ALL TYPES OF EXECUTION ERRORS\n*\n*        STORE THE ERROR NUMBER AND LINK TO THE ERROR\n*        ROUTINE IHIFSAER\n*        THE NUMBER OF EACH ERROR IS DETERMINED BY ITS POSITION\n*        IN THE BRANCH LIST\n*\n*        CALLING SEQUENCE -\n*        BC    ERRORCONDITION,FSAERR+4*ERRORNUMBER(R13)\n*\n         ORG   FSAERR+FSAREA\n*\nIHIFSAER BAL   R1,FSAERRL               0\n         BAL   R1,FSAERRL               1\n         BAL   R1,FSAERRL               2\n         BAL   R1,FSAERRL               3\n         BAL   R1,FSAERRL               4\n         BAL   R1,FSAERRL               5\n         BAL   R1,FSAERRL               6\n         BAL   R1,FSAERRL               7\n         BAL   R1,FSAERRL               8\n         BAL   R1,FSAERRL               9\n         BAL   R1,FSAERRL              10\n         BAL   R1,FSAERRL              11\n         BAL   R1,FSAERRL              12\n         BAL   R1,FSAERRL              13\n         BAL   R1,FSAERRL              14\n         BAL   R1,FSAERRL              15\n         BAL   R1,FSAERRL              16\n         BAL   R1,FSAERRL              17\nNOMAIN   EQU   *-FSAREA\n         BAL   R1,FSAERRL              18\n         BAL   R1,FSAERRL              19\nERROR20  EQU   *\nOERR20   EQU   *-FSAREA\nPARERR   EQU   *-FSAREA\n         BAL   R1,FSAERRL              20\nERROR21  BAL   R1,FSAERRL              21\n         BAL   R1,FSAERRL              22\n         BAL   R1,FSAERRL              23\n         BAL   R1,FSAERRL              24\n         BAL   R1,FSAERRL              25\n         BAL   R1,FSAERRL              26\nERROR27  BAL   R1,FSAERRL              27\nERROR28  BAL   R1,FSAERRL              28    0C8 FROM SPIE\nERROR29  BAL   R1,FSAERRL              29    0CC FROM SPIE\nERROR30  BAL   R1,FSAERRL              30    0C9 FROM SPIE\nERROR31  BAL   R1,FSAERRL              31\nERROR32  BAL   R1,FSAERRL              32\nERROR33  BAL   R1,FSAERRL              33    0CX FROM SPIE\nERROR34  EQU   *\nSWDMERR  EQU   *-FSAREA\n         BAL   R1,FSAERRL              34\nERROR35  BAL   R1,FSAERRL              35\nERROR36  EQU   *\nRASOVERF EQU   *-FSAREA\n         BAL   R1,FSAERRL              36\n         BAL   R1,FSAERRL              37\n         BAL   R1,FSAERRL              38\n         BAL   R1,FSAERRL              39\n         BAL   R1,FSAERRL              40\nDDERROR  EQU   *-FSAREA\n         BAL   R1,FSAERRL              41\nINVOPT   EQU   *-FSAREA\n         BAL   R1,FSAERRL              42\n         BAL   R1,FSAERRL              43\n*\n*        LINK TO ERROR ROUTINE IHIFSAERR\n*\nFSAERRL  LA    R1,0(,R1)               ZERO HIORDER BYTE\n         S     R1,=A(IHIFSAER+4)       ERRORNUMBER*4 IN R1\n         STC   R1,FSAERCOD(R13)        SAVE ERROR CODE\n         TM    OPTSW(R13),ERROR        TO PREVENT ENTERING\n         BO    TERMAA                  ERROR ROUTINE\n         OI    OPTSW(R13),ERROR        MORE THAN ONCE\n*\n         CALL  IHIERROR,                                               X\n               (FRDSA,SPDAP,IHIIOROP,IHIIORCP,IHIIORNX)\n*\n         USING IHIFSARB,R7\n*\n*        ABNORMAL TERMINATION\n*\nTERMA    L     R7,=A(IHIFSARB)\n         TM    OPTSW(R13),TERMSW\n         BO    ALGTRMAA                IF ERROR IN TERM ROUTINE\n         B     ALGTRMA\n*\n*        VERY ABNORMAL TERMINATION\n*\nTERMAA   L     R7,=A(IHIFSARB)\n         B     ALGTRMAA\n*\n*        NORMAL TERMINATION\n*\nTERMN    L     R7,=A(IHIFSARB)\n         B     ALGTRMN\n*\n         DROP  R7\n         ORG\n*\n***********************************************************************\n*\n*        INSTRUCTIONS FOR SHORT OR LONG FLOATING POINT PRECISION\n*\n***********************************************************************\n*\n*        THE FOLLOWING INSTRUCTIONS ARE MODIFIED BY THE\n*        INITIALIZATION ROUTINE FOR SHORT OR LONG PRECISION AS\n*        REQUIRED\n*\nFPINST   EQU   *\n*                                       USED BY VALUCALL\nVALLD    LE    0,0(R1)\nVALST    STE   0,0(R2)\n*                                       USED BY SPDECL\nLINSTR   LE    0,0(R2)\nSTINSTR  STE   0,FCTVALST(R13)\nLTRINSTR LTER  0,0\n         NOPR  0\nFPINSTE  EQU   *\nLPRINSTR LPER  0,0\n*\nFPINSTAD DC    A(FPINST,4,FPINSTE)\n*\n*        ONE OF THE FOLLOWING SETS OF INSTRUCTIONS IS INSERTED\n*        INTO THE CONVERT ROUTINE BY THE INITIALIZATION ROUTINE\n*        IN ORDER TO SET UP FOR LONG OR SHORT PRECISION AS\n*        REQUIRED\n*\n*        SHORT PRECISION\n*\nCNVINSTE STD   FPR0,CNVBUF2\n         MVC   CNVBUF2+1(3),CNVCNST1+1\n         AD    FPR0,CNVBUF2\n         BR    R8\n*\n         STE   FPR0,CNVBUF3\n         LD    FPR0,CNVBUF3\n         B     ENTIER1\n*\n         STE   FPR0,CNVBUF3\n         LD    FPR0,CNVBUF3\n*\n*        LONG PRECISION\n*\nCNVINSTD BR    R8\n*\n         DC    14X'FF'\n         B     ENTIER1\n*\n         DC    8X'FF'\n         AD    FPR0,CNVCNST2\n         B     ENTIER1\n*\nCNVINSTL EQU   *-CNVINSTD\n*\n***********************************************************************\n*\n*        GETMAIN ROUTINE\n*\n***********************************************************************\n*\n*        ISSUE A CONDITIONAL GETMAIN IN RESPONSE TO A REQUEST BY\n*        THE OBJECT MODULE FOR STORAGE FOR AN ARRAY. IF STORAGE\n*        IS NOT AVAILABLE, AN ERROR EXIT IS TAKEN\n*\n*        CALLING SEQUENCE - (ENTRY VIA BRLIST)\n*\n*        BAL   R8,GETMSTO(R13)         LENGTH OF AREA IN R0\n*        ---                           RETURN WITH ADDR IN R1\n*\nGETMAIN  LR    R2,R0                   LENGTH VALUE\n*\n         GETMAIN EC,LV=(R2),A=STORAGE\n*\n         LTR   R15,R15\n         BNZ   NOMAIN(R13)\n         L     R1,STORAGE\n         BR    R8                      RETURN TO CALLING PROG\n*\nSTORAGE  DC    A(0)                    ADDR OF THE AREA\n*\n***********************************************************************\n*\n*        CALL ACTUAL PARAMETER ROUTINE\n*\n***********************************************************************\n*\n*\n*        THIS ROUTINE IS AN INTERMEDIATE LINK BETWEEN A PROCEDURE\n*        AND THE THUNK FOR AN ACTUAL PARAMETER TO THE PROCEDURE.\n*        IT SEARCHES THE DSA CHAIN FOR THE DSA OF THE PROCEDURE\n*        DECLARATION. THEN IT LOADS THE THUNK ADDR FROM THIS\n*        DSA, LOADS CDSA WITH THE DSA ADDR OF THE ENCLOSING\n*        BLOCK AND BRANCHES TO THE THUNK\n*\n*        CALLING SEQUENCE - (ENTRY VIA BRLIST)\n*\n*        BAL   R15,CAP1(R13)\n*        DC    H'PBN1'                 PBN OF PROCEDURE\n*        DS    H\n*        L     R8,DISPL(CDSA)          LOAD ADDR OF THUNK\n*        ---                           RETURN FROM THUNK VIA CAP2\n*                                      WITH PARAM ADDR IN R8\n*\nCAP1A    EQU   *\nCAPA     L     R14,RASPT(R13)          RAS POINTER FROM TOP\n         ST    R15,12(,R14)            SAVE RETURN ADDR IN RAS\n         LH    R1,0(,R15)              PBN OF PROCEDURE\n         LA    R1,0(R1,PBT)            PROCEDURE ENTRY IN PBT\nCAPI1    LA    R14,8(,R14)             RESERVE ONE ENTRY IN RAS\n         C     R14,RASPB(R13)          CHECK FOR STACK OVERFLOW\n         BNL   RASOVERF(R13)\n         ST    CDSA,0(,R14)            SAVE DSA POINTER IN RAS\n         AH    PBT,8(,CDSA)            ADDR OF CURRENT PBT ENTRY\n         L     R2,0(,CDSA)             LAST GENERATION DSA POINTER\n         ST    R2,0(,PBT)              IS STORED IN PBT ENTRY\n         CR    R1,PBT                  RIGHT PROCEDURE REACHED\n         EX    0,4(,R15)               LOAD ADDR OF THUNK\n         L     CDSA,4(,CDSA)           LOAD DYNAMICALLY ENCLOSING DSA\n         LM    PBT,LAT,16(CDSA)        PBT AND LAT CAN BE DIFFERENT\n         ST    R14,RASPT(R13)          SAVE RAS TOP POINTER\n         BZR   R8                      TO THUNK OF ACTUAL PARAM\n*                                      IF RIGHT BLOCK REACHED\n         SR    R2,R2                   ZERO TO RETURN ENTRY IN\n         ST    R2,12(,R14)             RAS INSTEAD OF R15\n         B     CAPI1\n*\n*        HANDLE THE TRANSFER FROM THE THUNK BACK TO THE PROCEDURE\n*\n*        RELOAD CDSA WITH THE ADDR OF THE DSA THAT WAS ACTIVE\n*        WHEN CAP1 WAS ENTERED\n*\n*        CALLING SEQUENCE - (ENTRY VIA BRLIST)\n*        B     CAP2(R13)\n*\nCAP2A    EQU   *\nCAPB     EQU   *\n         L     R14,RASPT(R13)          RAS POINTER FROM TOP\nCAPI3    L     CDSA,0(,R14)            DSA POINTER FROM RAS\n         LM    PBT,LAT,16(CDSA)        PBT AND LAT CAN BE DIFFERENT\n         L     R15,4(R14)              RETURN ADDR FROM RAS\n         SH    R14,EIGHT(R13)          RELEASE ONE ENTRY IN RAS\n         LH    R1,8(CDSA)              PROGRAM BLOCK NUMBER TO REG\n         ST    CDSA,0(R1,PBT)          CURRENT DSA POINTER TO PBT\n         LTR   R15,R15                 CALLING BLOCK REACHED\n         BZ    CAPI3                   NO CONTINUE\nCAPI4    ST    R14,RASPT(R13)          SAVE RAS TOP POINTER\n         B     8(,R15)                 RETURN TO CALLING SEQUENCE\n*\n***********************************************************************\n*\n*        PROLOGUE PROGRAM\n*\n***********************************************************************\n*\n*        THIS ROUTINE IS EXECUTED WHENEVER A BLOCK OR PROCEDURE\n*        IS TO BE ENTERED\n*\n*        IT CREATES AND INITIALIZES A NEW DSA. FOR A PROCEDURE\n*        WITH PARAMETERS IT MOVES THE PARAMETER LIST TO THE DSA\n*        AND CHECKS IT AGAINST THE FORMAL PARAMETER LIST IN THE\n*        PROCEDURE DECLARATION. THEN IT ENTERS THE BLOCK OR\n*        PROCEDURE\n*        THE ENTRY POINT PROLOGP IS USED ONLY WHEN THE PROCEDURE\n*        IS CALLED VIA AN ACTUAL PARAMETER TO ANOTHER\n*        PROCEDURE\n*\n*        CALLING SEQUENCE (ENTRY VIA BRLIST)\n*        BAL   R15,PROLOG(R13)\n*        MVI   PROLPBN(R13),PBN         PBN OF BLOCK TO BE ENTERED\n*                                       PARAMETER LIST FOR PROCEDURE\n*        DC    A(THUNK1)                ADDR OF THUNK FOR 1ST PARAM\n*        DC    H'CH'                    CHARACTERISTICS OF 1ST PARAM\n*        DC    H'N'                     NUMBER OF PARAMETERS\n*         .\n*         .\n*         .\n*        DC    A(THUNKN)                ADDR OF THUNK FOR LAST PARAM\n*        DC    H'CH'\n*        DC    H'0'\n*\nPROLP    MVI   PROLPBN-1(R13),X'00'\n*\n*        SET OFF SW SET BY GENERATE PROG TO DETECT ERROR\n*        SEE BELOW\n*\n         LM    PBT,LAT,PROLREG(R13)    UPDATE PBT AND LAT\n*\nPROL     LH    R3,PROLPBN-1(R13)       CALLED PROGRAM BLOCK NUMBER\n         SLL   R3,3                    CALCULATE PBT DISPLACEMENT\n         LTR   R2,R3                   STANDARD PROCEDURE CALLED ?\n         BZ    SPDECL(,R13)            YES, BRANCH\n         BM    OERR21(R13)             ERROR, ACTUAL PROCEDURE\n*\n*        PARAMETER IS PARAMETERLESS WHILE FORMAL PROCEDURE IS\n*        CALLED WITH PARAMETERS\n*        PROLPBN-1 WAS SET TO X'FF' BY GENERATED PROG BEFORE CAP1\n*        WAS CALLED\n*\n         AR    R3,PBT                  ADDR OF PBT ENTRY\n         TM    6(R3),BETABM            PROCEDURE CALLED ?\n         BZ    PROLOG1                 NO\n         C     R8,ASTLOC(,R13)         COMP CONT OF ADDR WITH ADDR OF\n*                                      FUNCTION VALUE STORAGE\n         BE    OERR21(,R13)            EQUAL, BRANCH\n         TM    6(R3),CODEPRM           CODE PROCDURE CALLED ?\n         BO    PROLOG2                 YES.\nPROLOG1  LH    R0,4(,R3)               LENGTH OF DSA TO REG 0\n         LR    R4,R15                  SAVE R15 DURING GETMAIN\n*\n         GETMAIN R,LV=(0)              GETMAIN FOR DSA\n*\n         LR    R15,R4\n         L     R0,0(R2,PBT)            LOAD POINTER OF LAST GENERATION\n         ST    R0,0(,R1)               STORE IT IN DSA\n         ST    CDSA,4(,R1)             STORE POINTER OF EMBRACING PB\n         STH   R2,8(,R1)               STORE PBT DISPLACEMENT\n         MVI   10(R1),0                ZEROS TO VALUE ARRAY AND\n         MVC   11(5,R1),10(R1)         ARRAY POINTERS\n         ST    R1,0(R2,PBT)            STORE CURR DSA POINTER IN PBT\n         LR    CDSA,R1                 SET CDSA POINTER\n         STM   PBT,LAT,16(CDSA)\n         L     R14,RASPT(R13)          RAS-POINTER TOP\n         LA    R14,8(R14)              RESERVE ONE ENTRY\n         C     R14,RASPB(R13)          COMPARE WITH RAS-POINTER BOTTOM\n         BNL   RASOVERF(R13)           STACK OVERFLOW\n         ST    CDSA,0(,R14)\n         MVI   0(R14),X'FF'\n         ST    R14,RASPT(R13)          SAVE POINTER\n         TM    6(R3),BETABM            PROCEDURE CALLED ?\n         BZR   R15                     NO, USUAL BLOCK RETURN, EXIT 1\nA4       CLI   7(R3),0                 ANY FORMAL PARAMETERS ?\n         BE    F4                      ZERO, BRANCH\n         CLC   7(1,R3),7(R15)          COMP NO OF FORM AND ACT PARAM\n         BNE   OERR21(,R13)            \u00ac=, BRANCH\n         SR    R2,R2\n         IC    R2,7(,R3)               FETCH NUMBER OF PARAMETERS\n         LR    R4,R2                   SAVE NUMBER IN R4\n         SLL   R2,3                    CALCULATE LENGTH OF PARAMETER\n         BCTR  R2,0                    ENTRY-1\n         LA    R1,24(CDSA)             START OF PARAM IF PROC\n         TM    6(R3),PIMASK            FUNCTION PROCEDURE CALLED\n         BZ    PROLOG3                 YES\n         EX    R2,PIMOVE\n         B     LOOP\n*\nPIMOVE   MVC   24(1,CDSA),0(R15)       MOVE PROCEDURE PARAMETERS\nPHIMOVE  MVC   32(1,CDSA),0(R15)       MOVE FUNCTION PARAMETERS\nPROLOG3  EX    R2,PHIMOVE\n         LA    R1,8(R1)                START OF PARAM. IF TYPE\nLOOP     TM    0(R8),X'01'             FORM PAR 'STRING' ?\n         BO    STRTST                  YES, GOTO STRINGTEST\n         CLI   1(R8),X'D0'             FORM PAR 'PROC' WITHOUT TYP ?\n         BE    PROTST                  YES, GOTO PROCEDURE TEST\n         CLI   1(R8),X'1C'             FORM PAR 'SWITCH' ?\n         BE    SWTTST                  YES, GOTO SWITCH TEST\n         TM    1(R8),X'08'             FORM PAR 'LABEL' ?\n         BO    LBLTST                  YES, GOTO LABEL TEST\n         TM    1(R8),X'04'             FORM PAR 'ARRAY' ?\n         BO    ARRTST                  YES, GOTO ARRAY TEST\n         TM    1(R8),X'C0'             FORM PAR A TYP PROCEDURE ?\n         BO    TPRTST                  YES, GOTO TYP PROCEDURE TEST\n         TM    5(R15),X'04'            ACT PAR 'ARRAY' ?\n         BO    OERR20(,R13)            YES, ERR 20\nTYPTST   TM    1(R8),X'03'             TEST TYP\n         BM    ARITST                  IF ARITHM TYP GOTO ARITH TEST\n         TM    5(R15),X'03'            ACT PAR BOOL ?\n         BO    ASSFLAG                 YES, SPECIAL ASSIGNMENT TEST\n         B     OERR20(,R13)            NO, GOTO ERR 20\n*\nSTRTST   TM    4(R15),X'01'            ACT PAR 'STRING' ?\n         BO    EXIT                    YES, TEST NEXT PAR\n         B     OERR20(,R13)            NO, BRANCH TO OBJEXT TIME ERR 20\n*\nPROTST   TM    5(R15),X'C0'            ACT PAR IS 'PROCEDURE' ?\n         BZ    OERR20(,R13)            NO, ERR 20\n         B     EXIT                    YES, TEST NEXT PAR\n*\nSWTTST   TM    5(R15),X'0C'            ACT PAR 'SWITCH' ?\n         B     STRTST+4                BRANCH TO STRTST+4 TO TEST CC\n*\nLBLTST   TM    5(R15),X'08'            ACT PAR 'LABEL' ?\n         BZ    OERR20(,R13)            NO, ERR 20\n         TM    5(R15),X'04'            ACT PAR 'SWITCH' ?\n         BO    OERR20(,R13)            YES, ERR 20\n         B     EXIT                    TEST NEXT PAR\n*\nARRTST   TM    5(R15),X'04'            ACT PAR 'ARRAY' ?\n         BZ    OERR20(0,R13)           NO, ERR 20\n         B     TYPTST                  YES, GOTO TYP TEST\n*\nTPRTST   TM    5(R15),X'C0'            ACT PAR 'PROCEDURE' ?\n         BZ    OERR20(0,R13)           NO, ERR 20\n         B     TYPTST                  YES, GOTO TYP TEST\n*\nARITST   TM    5(R15),X'03'            ACTUAL PAR ARITHMETIC ?\n         BNM   OERR20(R13)             NO\n         TM    1(R8),X'10'             FORMAL PARAMETER CALLED BY NAME?\n         BZ    PARAMPR                 NO\n         TM    1(R8),X'02'             FORMAL PARAMETER REAL TYPE ?\n         BZ    INTTST                  NO, INTEGER TYPE\n         TM    5(R15),X'02'            ACTUAL PARAMETER REAL ?\n         BZ    OERR20(R13)             NO, ERROR\n         B     ASSFLAG2                SPECIAL ASSIGNMENT TEST\n*\nINTTST   TM    5(R15),X'01'            ACTUAL PARAMETER INTEGER ?\n         BZ    OERR20(R13)             NO, ERROR\n*\n*        SPECIAL TEST IF ACTUAL PARAMETER IS FORMAL BY NAME AND\n*        THEN MOVE THE ASGNMENT FLAG FR ACT PARAMETER ENT IN DSA\n*        TO THE NEW PARAMETER ENT IN DSA OF BLK TO BE ENTERED\n*\n*        NOTE: THIS CODE IS EXTREMELY DEPENDENT ON CODE\n*        GENERATED FOR FORMAL PARAMETERS CALLED BY NAME\n*\nASSFLAG  TM    1(R8),X'10'             FORMAL PARM BY NAME ?\n         BZ    PARAMPR                 NO\nASSFLAG2 TM    5(R15),X'10'            ACT IS TYPE CALLED BY NAME ?\n         BZ    PARAMPR\n         TM    5(R15),X'20'            IF NOT GOTO SPECIAL\n         BO    PARAMPR                 PARAMETERLESS PR TEST\n         L     R2,4(CDSA)              DSA OF CALLING SEQUENSE\n         L     R2,16(,R2)              PBT ADDR OF CALLING SEQ\n         L     R3,0(,R1)               ADDR OF THUNK OF ACT PARM\n*                                      WHICH IS FORMAL\n         MVC   ORI+5(1),11(R3)         MOVE DISPL OF PARAM FOUND\n*                                      IN THUNK CODE TO OR INST\n         IC    R3,4(,R3)               DISPLACEMENT OF\n         N     R3,MASKFF               PROCEDURE IN PBT\n         L     R3,0(R3,R2)             ADDR OF DSA OF PROCEDURE\n         LA    R3,4(,R3)               ADDR CHARACTERISTIC PART\n*                                      OF PARAMETER ENTRY\nORI      OC    4(1,R1),0(R3)           MOVE ASGNMENT BIT FROM\n*                                      CALLING PARAMETER ENT IN\n*                                      DSA TO NEW DSA ENT\n*\n*        TEST IF ACTUAL PARAMETER IS PARAMETERLESS PROCEDURE\n*\nPARAMPR  TM    5(R15),X'C0'            ACTUAL PARAMETER PROCEDURE ?\n         BZ    EXIT                    NO\n         TM    5(R15),X'30'\n         BM    EXIT\n         TM    1(R8),X'D0'             FORMAL PROC CALLED BY NAME ?\n         BO    EXIT                    YES, EXIT\n         TM    4(R15),X'C0'            PROCEDURE CALLED ?\n         BO    OERR20(R13)\nEXIT     LA    R15,8(,R15)             GET NEXT ACT PAR ADDR\n         LA    R8,2(,R8)               GET NEXT FORM PAR ADDR\n         LA    R1,8(,R1)               NEXT PARAMETER IN DSA\n         BCT   R4,LOOP                 IF A NEXT PAR OCCURS GOTO LOOP\nF4       ST    R15,4(,R14)             STORE RETURN ADDR IN RAS\n         BR    R8                      EXIT 2\n*\n*        PRECOMPILED PROCEDURE CALLED\n*\nPROLOG2  L     R1,0(,R3)               ADDR OF PRECOMP PR CONST\n         LM    PBT,LAT,0(R1)           LOAD NEW PBT AND LAT ADDRS\n         CLC   7(1,R3),15(PBT)         PARAMETER DEFINITION IN CODE\n*                                      PROCEDURE SAME AS IN LOADED\n*                                      PRECOMPILED PROCEDURE ?\n         BNE   OERR21(R13)             NO, ERROR 21\n         L     R8,8(,R1)               PROCEDURE DECLAR ENTRY POINT\n         MVI   PROLPBN(R13),1          PBN OF PROCEDURE IS 1\n         B     PROLOG(R13)             CALL PRECOMPILED PROCEDURE\n*\nMASKFF   DC    X'000000FF'             MASK TO CLEAR 3 BYTES OF REG\n*\n***********************************************************************\n*\n*        VALUE CALL ROUTINE\n*\n***********************************************************************\n*\n*        SUBROUTINE FOR HANDLING FORMAL PARAMETERS\n*\n*        CALLED BY VALUE\n*\n*        USED FOR FORMAL PARAMETERS OF TYPE REAL, INTEGER OR\n*        BOOLEAN, INCLUDING ARRAYS\n*\n*        CALLING SEQUENCE - (ENTRY VIA BRLIST)\n*        CALL  ACTUAL PARAMETER\n*        BAL   R15,VALUCALL(R13)\n*        DC    H'DISPL'                FORMAL PARAMETER DISPLACEMENT\n*        DC    XL2'  '                 CHARACTERISTIC OF PARAMETER\n*        ---                           RETURN FROM VALUCALL\n*\n*        DISPL(CDSA) CONTAINS IF PARAMETER IS AN ARRAY ADDR OF\n*        SMF OTHERWISE VALUE OF THE ACTUAL PARAMETER, CONVERTED\n*        IF NECESSARY\n*\nVALUCAL  MVI   CONVFL,0                ZERO TO CONVERSION FLAG\n         ST    R15,BRRSAVE             SAVE R15, R8\n         ST    R8,ADRSAVE\n         LH    R1,0(,R15)\nVALUC10  LA    R14,0(R1,CDSA)\n*\n*        INSERT COMPONENT SIZE OF ORIGINAL\n*\n         MVI   CSIZORIG+1,X'01'        ONE TO COMP SIZE INCASE BOOLEAN\n         TM    5(R14),X'03'            TEST ACTUAL PARAMETER TYPE\n         BO    VALUC12                 BOOLEAN, BRANCH\n         MVI   CSIZORIG+1,X'04'        FOUR TO COMPONENT SIZE\n         TM    5(R14),X'01'            ACTUAL PAR INTEGER ?\n         BO    VALUC00                 INTEGER, BRANCH\n         TM    OPTSW(R13),X'20'        PRECISION ?\n         BO    VALUC00                 SHORT PRECISION, BRANCH\n         MVI   CSIZORIG+1,X'08'        LONG, EIGHT TO COMPONENT SIZE\n*\nVALUC00  TM    5(R14),X'02'            ACTUAL PARAMETER REAL\n         BO    VALUC11                 YES, BRANCH\n*\n*        ACTUAL PARAMETER INTEGER\n*\n         TM    3(R15),X'01'            FORMAL PAR INTEGER ?\n         BO    VALUC12                 YES, BRANCH\n*\n         MVI   CONVFL,X'01'            1 (= INTEGER TO REAL) TO FLAG\n         B     VALUC12\n*\n*        ACTUAL PARAMETER REAL\n*\nVALUC11  TM    3(R15),X'02'            FORMAL PAR REAL ?\n         BO    VALUC12                 YES, BRANCH\n         MVI   CONVFL,X'03'            3 (=REAL TO INTEGER) TO FLG\nVALUC12  MVC   CSIZCOPY+1(1),CSIZORIG+1  COPY COMPONENT SIZE\n         TM    3(R15),X'04'            ARRAY ?\n         BO    VALUC21                 YES, BRANCH\nVALUC13  MVC   0(8,R14),0(R8)          MOVE CONT OF R8 TO CDSA\n         LR    R1,R14                  ADDR OF FORMAL PARAM ENTRY\n         LR    R2,R1                   STORE BACK AFTER CONVERSION\n         LA    R5,4(,R15)              RETURN ADDR\nVALUC14  TM    CONVFL,X'03'            CONVERSION NECESSARY ?\n         BZR   R5                      NO, RETURN\n         BO    VALUC15                 REAL INTEGER\n*\n*        CALL INTEGER REAL CONVERSION ROUTINE\n*\n         L     R14,0(,R1)\n         BAL   R8,CNVIRD(R13)\n         EX    0,VALST\n         BR    R5                      RETURN\n*\n*        CALL REAL-INTEGER CONVERSION ROUTINE\n*\nVALUC15  EX    0,VALLD\n         BAL   R8,CNVRDI(R13)\n         ST    R14,0(,R2)\n         BR    R5                      RETURN\n*\n*        HANDLE VALUE CALL OF ARRAY\n*\nVALUC21  MVC   SIZEARR(4),16(R8)       SIZE OF ORIGINAL ARRAY\n         L     R15,8(,R8)\n         S     R15,4(,R8)              DIFF (ADDRLOWCOMP - ADRZEROCOMP)\n         ST    R15,DIFFLZ\n*\n         MVI   SMFFL,0                 ZERO TO SMF FLAG\n*\n         TM    OPTSW(R13),X'20'        PRECISION ?\n         BO    VALUC31                 SHORT PRECISION, BRANCH\n         TM    CONVFL,X'03'            LONG, TEST CONV FLAG\n         BZ    VALUC31                 NO CONV NEEDED, BRANCH\n         MVC   SMFFL(1),CONVFL         CONV FLAG TO SMF FLAG\n         L     R15,SIZEARR\n         L     R14,DIFFLZ\n         LH    R1,CSIZCOPY\n         BO    VALUC25\n*\n*        INCREMENT 'SIZE OF ARRAY', DIFF AND COMPONENT SIZE\n*\n         SLA   R15,1\n         SLA   R14,1\n         SLA   R1,1\n         B     VALUC26\n*\n*        DECREMENT 'SIZE OF ARRAY', DIFF AND COMPONENT SIZE\n*\nVALUC25  SRA   R15,1\n         SRA   R14,1\n         SRA   R1,1\nVALUC26  ST    R15,SIZEARR\n         ST    R14,DIFFLZ\n         STH   R1,CSIZCOPY\n*\n*        EXECUTE SUBROUTINE WITH GETMAIN\n*\nVALUC31  SR    R15,R15\n         IC    R15,0(R8)               NUMBER OF SUBSCRIPTS\n         LA    R15,5(R15)\n         SLA   R15,2\n         CLI   CSIZCOPY+1,X'08'        REAL ARRAY LONG ?\n         BNE   VALUC32                 NO\n         TM    0(R8),X'01'             SMF LENGTH DOUBLE WORDS\n         BO    VALUC32                 YES\n         LA    R15,4(,R15)             FORCE ARRAY TO DOUBLE WORD\nVALUC32  STC   R15,SIZESMF+1           INSERT SIZE OF SMF\n         LH    0,SIZESMF\n         A     0,SIZEARR               NUMBER OF BYTES REQUESTED\n         BAL   R8,GETMSTO(R13)\n*\n*        COPY SMF\n*\n         L     R8,ADRSAVE\nVALUC33  MVC   0(1,R1),0(R8)\n*\n*        INSERT FIRST FOUR WORDS INTO SMF COPY\n*\n         MVC   2(2,R1),10(CDSA)        CHAIN DISPL FROM DSA\n         L     R15,BRRSAVE\n         LH    R2,0(,R15)              DISPL OF FORMAL PARAM ENTRY\n         STH   R2,10(,CDSA)            CHAIN DISPL\n         ST    R1,0(R2,CDSA)           ADDR OF VALUE ARRAY\n*                                      TO FORMAL PARAMETER ENTRY\n         LR    R15,R1\n         AH    R15,SIZESMF\n         ST    R15,8(,R1)\n         S     R15,DIFFLZ\n         ST    R15,4(,R1)\n         A     R15,DIFFLZ\n         A     R15,SIZEARR\n         ST    R15,12(,R1)\n*\n*        COPY DOUBLE OR HALF P-VALUES INTO NEW SMF\n*\n         LA    R15,16(,R1)\n         LA    R2,16(,R8)\n*\nVALUC35  L     R14,0(R2)\n         TM    SMFFL,X'03'             TEST IF P-VALUES MUST CHANGE\n         BZ    VALUC36\n         SLL   R14,1\n         BM    VALUC36                 BR IF FLAG=1 (INCREM IS OK)\n         SRL   R14,2                   DECREMENT INSTEAD\nVALUC36  ST    R14,0(,R15)\n         LA    R15,4(,R15)\n         LA    R2,4(,R2)\n         C     R15,8(,R1)\n         BL    VALUC35\n*\n*        COPY ARRAY\n*\n*        INITIALIZE COPYING\n*\nVALUC41  L     R3,SIZEARR              SIZE OF ARRAY\n         L     R2,8(,R1)               ADDR OF COPY ARRAY\n         L     R1,8(,R8)               ADDR OF ORIGINAL ARRAY\n         TM    CONVFL,X'03'            CONVERSION NECESSARY ?\n         BZ    VALUC61                 NO, MOVE ARRAY\nVALUC51  BAL   R5,VALUC14              CONVERT ONE ELEMENT, STORE IT\n         AH    R1,CSIZORIG             NEXT ELEMENT FROM ORIGINAL\n         AH    R2,CSIZCOPY             NEXT ELEMENT FROM COPY\n         SH    R3,CSIZCOPY\n         BP    VALUC51                 CONTINUE IF ELEMENTS LEFT\nVALUC52  L     R15,BRRSAVE\n         B     4(,R15)                 RETURN\n*\nVALUC61  LA    R4,255                  MAX IN ONE MOVE\nVALUC61A BCTR  R3,0                    SIZE-1\n         CR    R3,R4\n         BNH   VALUC62                 NOT MORE THAN 256 BYTES\n         EX    R4,VALUC63              MOVE 256 BYTES\n         SR    R3,R4                   REDUCE SIZE\n         LA    R1,256(,R1)\n         LA    R2,256(,R2)\n         B     VALUC61A                CONTINUE\n*\nVALUC62  EX    R3,VALUC63              MOVE LAST PART OF ARRAY\n         B     VALUC52                 RETURN\n*\nVALUC63  MVC   0(0,R2),0(R1)           ORIGINAL ARRAY TO COPY\n*\n*        WORK AREA\n*\nBRRSAVE  DC    F'0'                    STORAGE OF R15\nADRSAVE  DC    F'0'                    STORAGE OF R8\nDIFFLZ   DC    F'0'                    DIFFERENCE BETWEEN LOW\n*                                      AND ZERO COMPONENTS\nSIZEARR  DC    F'0'                    SIZE OF ARRAY\nSIZESMF  DC    H'0'                    SIZE OF SMF\nCSIZORIG DC    H'0'                    COMPONENT SIZE, ORIGINAL\nCSIZCOPY DC    H'0'                    COMPONENT SIZE, COPY\nCONVFL   DC    X'00'                   CONVERSION FLAG\nSMFFL    DC    X'00'                   ARRAY SIZE FLAG\n*\n***********************************************************************\n*\n*        RETURN PROGRAM\n*\n***********************************************************************\n*\n*        THIS ROUTINE IS ENTERED WHEN A BRANCH IS MADE OUT OF A\n*        BLOCK OR PROCEDURE BY MEANS OF A 'GO TO' STATEMENT\n*\n*        IT SEARCHES RAS FOR AN ENTRY POINTING TO THE DSA OF THE\n*        TARGET BLOCK. FOR EACH BLOCK THAT IS BYPASSED, THE\n*        FREEDSA ROUTINE IS INVOKED TO RELEASE STORAGE FOR DSA\n*        AND ARRAYS. CALLING SEQUENCE - (ENTRY VIA BRLIST)\n*\n*        B     RETPROG(R13)\n*\nRETPROGA BALR  R15,0                   SET RETURN REGISTER\n         L     R14,RASPT(R13)          FETCH RAS TOP POINTER\nRETPR1   CLI   0(R14),RASPARMM         RAS PARAMETER ENTRY ?\n         BNE   PBNENTRY                NO\n         SH    R14,EIGHT(,R13)         CLEAR PARAMETER ENTRY\n         B     RETPR1                  TEST NEXT ENTRY\n*\nPBNENTRY IC    R1,0(R14)               SAVE FLAG\n         MVI   0(R14),0                CLEAR FLAG\n         L     CDSA,0(,R14)            UPDATE DSA REG\n         C     GDSA,0(,R14)            COMPARE DSA ADDR\n         STC   R1,0(,R14)              RESTORE FLAG\n         ST    R14,RASPT(R13)          SAVE RAS POINTER\n         BER   R8                      EQUAL, EXIT TO ADDR IN R8\n         B     FREEDSA(R13)            FREE DSA SUBROUTINE IN EPILOG\n*\n***********************************************************************\n*\n*        EPILOGUE PROGRAM\n*\n***********************************************************************\n*\n*        THIS ROUTINE IS EXECUTED WHENEVER AN EXIT IS MADE FROM\n*        A PROCEDURE (ENTRY POINT EPILOGP) OR BLOCK (ENTRY POINT\n*        EPILOGB) VIA THE 'END' STATEMENT\n*\n*        CLEAR THE CORRESPONDING ENTRY FROM RAS AND FREES\n*        THE STORAGE FOR DSA AND ARRAYS. IF THE EXIT WAS FROM A\n*        PRECOMPILED PROCEDURE, THE PROCEDURE IS DELETED\n*\n*        CALLING SEQUENCE - (ENTRY VIA BRLIST)\n*\n*        B     EPILOGP(R13)\n*\nEPILP    MVC   FCTVALST(8,R13),24(CDSA) FUNCTION VALUE TO FSA\n         LA    R8,FCTVALST(R13)         FUNCTION VALUE ADDR TO R8\n         BAL   R15,FREEDSA(R13)         LEAVE BLOCK AND UPDATE REG\n         L     R14,RASPT(R13)\n         L     R15,12(,R14)             RETURN ADDR FROM RAS\n         BR    R15                      RETURN\n*\n*        CALLING SEQUENCE - (ENTRY VIA BRLIST)\n*\n*        B     EPILOGB(R13)\n*\nEPILB    EQU   *\nFREEDSA  EQU   EPILOGB                 LEAVE A BLOCK\nFRDSA    EQU   *                       FREEMAIN UPDATE REG\n         ST    R15,BRRST(R13)          SAVE RETURN ADDR\n         L     R14,RASPT(R13)          FETCH RAS POINTER\n         SH    R14,EIGHT(R13)          REDUCE RETURN ADDR STACK\n         ST    R14,RASPT(R13)          SAVE RAS POINTER\n         CLI   8(R14),RASLOADM         LOAD PROCEDURE ENTRY ?\n         BNE   VTEST                   NO\n         L     R1,RASPB(R13)           FETCH ADDR OF NAME OF\n         LR    R0,R1                   PROCEDURE TO BE DELETED\n         LA    R1,8(,R1)               CLEAR PRECOMPILED PROCEDURE\n         ST    R1,RASPB(R13)           NAME FROM RAS\n*\n         DELETE  EPLOC=(0)\n*\n         B     FRDSA+4                 CONTINUE\n*\n*        VALUE ARRAY HANDLING\n*\nEPIL3    EQU   *\nVTEST    ICM   R0,B'0011',10(CDSA)     TEST VALUE ARRAY FIELD\n         BZ    ATEST                   ZERO, GOTO NEXT TEST\n         LH    R2,10(,CDSA)            LOAD LAST VALUE ARRAY DISPL\n         L     R1,0(R2,CDSA)           LOAD ADDR OF STOR MAP FCT\n         L     R0,16(,R1)              LOAD LENGTH OF ARRAY\n         LH    R2,2(,R1)               LOAD BEFORE LAST VALUE\n*                                      ARRAY DISPLACEMENT\n         STH   R2,10(,CDSA)            STORE BEFORE LAST VALUE\n*                                      ARRAY DISPLACEMENT\n         SR    R2,R2                   CLEAR A WORK REGISTER\n         IC    R2,0(,R1)\n         LA    R2,1(,R2)               CALCULATE LENGTH OF STORAGE\n         SLL   R2,2                    MAPPING FUNCTION\n         LA    R2,16(,R2)\n         AR    R0,R2                   ADD ST MAP FUNCT LENGTH\n*                                      AND ARRAY LENGTH\n*                                      FREEMAIN FOR VAL ARRAY\n         FREEMAIN R,LV=(0),A=(1)       INCL ST MAP FCT\n*\n         B     VTEST                   RETURN TO VALUE ARRAY TEST\n*\n*        ARRAY HANDLING\n*\nATEST    SR    R2,R2                   CLEAR WORK REGISTER\n         ICM   R2,B'0011',14(CDSA)     TEST LAST ARRAY DISPLACEMENT\n         BZ    DSAHDL                  ZERO, GOTO DSAHDL\n         LH    R3,2(R2,CDSA)           LOAD BEFORE LAST ARRAY DISPL\n         STH   R3,14(,CDSA)            STORE BEFORELAST ARRAY DISPL\n         L     R1,8(R2,CDSA)           LOAD ADDR OF LOWEST COMPON\n         L     R0,16(R2,CDSA)          LOAD LENGTH OF ARRAY\n*\n         FREEMAIN R,LV=(0),A=(1)       FREEMAIN FOR ARRAY\n*\n         B     ATEST                   RETURN TO ARRAY TEST\n*\n*        DSA HANDLING\n*\nDSAHDL   LR    R1,CDSA                 LOAD DSA ADDR\n         LH    R2,8(,CDSA)             LOAD PBT DISPL\n         L     R3,0(,CDSA)             UPDATE DSA ADDR\n         ST    R3,0(R2,PBT)            IN PBT\n         LH    R0,4(R2,PBT)            LENGTH OF DSA TO R0\n         L     CDSA,4(,CDSA)           RESET CDSA POINTER\n         LM    PBT,LAT,16(CDSA)        UPDATE PBT AND LAT REGISTERS\n*\n         FREEMAIN R,LV=(0),A=(1)       FREEMAIN FOR DSA\n*\n         L     R15,BRRST(R13)          RESTORE RETURN ADDR\n         BR    R15                     BRANCH\n*\n***********************************************************************\n*\n*        STANDARD PROCEDURE DECLARATION ROUTINE\n*\n***********************************************************************\n*\n*\n*        ENTERED FROM THE PROLOG ROUTINE IF PBN IS ZERO, IE A\n*        STANDARD PROCEDURE IS CALLED VIA AN ACTUAL PARAMETER TO\n*        AN ANOTHER PROCEDURE\n*\n*        ON ENTRY, R15 CONTAINS THE ADDR OF THE PARAMETER\n*        LIST, WHILE R8 CONTAINS THE INTERNAL NAME OF THE\n*        STANDARD PROCEDURE.\n*        THE ROUTINE BUILDS THE PARAMETER LIST AND EXECUTES THE\n*        CALL IN THE SAME WAY AS WOULD NORMALLY BE DONE BY THE\n*        GENERATED OBJECT CODE. SINCE THE ROUTINE MAY BE ENTERED\n*        REPEATEDLY DURING THE EVALUATION OF THE ACTUAL\n*        PARAMETERS, THE PARAMETER LIST AND OTHER INFORMATION IS\n*        STORED IN A DYNAMIC AREA CALLED SPDA.\n*\n         DS    0H\nSPDECL   EQU   *-FSAREA\n*\n*        TEST FOR AUXILIARY ROUTINE INPUT OR OUTPUT\n*\n         LTR   R8,R8\n         BPR   R8                      TO ROUTINE INPUT OR OUTPUT\n*\n*        GET DYNAMIC STORAGE AREA\n*\nSPDECL00 LR    R2,R15                  SAVE R15 DURING GETMAIN\n*\n         GETMAIN R,LV=SPDALG\n*\n         LR    R15,R2\n         MVC   0(4,R1),SPDAP           INSERT CHAIN ADDR\n         ST    R1,SPDAP                STORE CURRENT AREA POINTER\n         LR    R5,R1\n         USING SPDA,R5\n         ST    R8,PRID\n         LR    R4,LAT                  R4 IS NOW LAT POINTER\n         LR    R0,R8\n         LR    R2,R0\n         SRL   R2,12\n         N     R0,=F'3'                NUMBER OF FORMAL PARAMETERS\n         BNZ   *+8                     ZERO MEANS ONE PARAMETER\n         LA    R0,1\n         CH    R0,6(,R15)              COMPARE NUMBER OF ACTUAL PARAM\n         BNE   ERROR21\n*\n*        INITIALIZE FOR CREATING PARAMETER LIST\n*\n         LA    R1,PARLIST\n         LA    R3,PARAMS\n         MVI   0(R1),0\n         MVC   1(11,R1),0(R1)          RESET PARAMETER LIST\nSPDECL02 STC   R2,FPTYPA\n         STC   R2,FPTYP\n         XC    FPTYP,5(R15)            COMPARE WITH ACTUAL PAR CHAR\n         TM    FPTYP,X'07'\n         BZ    SPDECL15                IDENTICAL TYPES\n         BO    PARERR(R13)             NOT COMPATIBLE TYPES\n*\n*        TYPES ARE NOT IDENTICAL BUT MAY BE COMPATIBLE\n*\n         TM    FPTYPA,X'08'            TEST FOR VALUE OR NAME\n         BO    PARERR(R13)             CALL BY NAME AND NOT SAME TYPE\n         TM    FPTYP,X'03'             TEST IF REAL-INTEGER COMPATIBLE\n         BNO   PARERR(R13)\n         TM    5(R15),X'03'            TEST ACTUAL PARAMETER\n         BNM   PARERR(R13)             IF NOT REAL OR INTEGER\n         OI    0(R1),X'80'             SET TYPE CONVERSION FLAG\n*\n*        ACTIVATE THUNK TO GET ADDR OF ACTUAL PARAMETER\n*\nSPDECL15 STM   R15,R4,SPSAVE\n         MVC   SPTHAD(4),0(R15)        THUNK ADDR TO FULLWORD LOCATION\n         L     R3,RASPT(R13)\n         LA    R3,8(,R3)               NEXT ENTRY IN RAS\n         C     R3,RASPB(R13)\n         BNL   RASOVERF(R13)           IF RAS FULL\n         ST    R3,RASPT(R13)\n         ST    CDSA,0(,R3)             DSA POINTER TO RAS\n         LM    PBT,LAT,16(CDSA)\n         LA    R2,SPDECL17-8\n         ST    R2,4(R3)                ADDR USED BY CAP2\n         L     R15,SPTHAD              ADDR OF THUNK\n         BR    R15                     BRANCH TO THUNK\n*\n*        RETURN HERE VIA CAP2\n*        R8 CONTAINS ADDR OF ACTUAL PARAM\n*\nSPDECL17 L     R5,SPDAP                RESTORE SPDA POINTER\n         LM    R15,R4,SPSAVE           RESTORE REGISTERS\n         C     R8,ASTLOC(R13)\n         BNE   SPDECL19\n         MVC   0(8,R3),0(R8)           SAVE PARAM VALUE IN SPDA\n         LR    R8,R3\nSPDECL19 O     R8,0(,R1)               COMBINE FLAGS AND PARAM ADDR\n         ST    R8,0(,R1)               STORE PARAM ADDR IN PARLIST\n         TM    PRID,X'03'              I/O PROCEDURE ?\n         BNZ   SPDECL01                NO, BRANCH\n*\n*        I/O PROCEDURE\n*\n         TM    PRID+2,X'02'            SYSACT ?\n         BZ    SPDECL01                NO, BRANCH\n         CH    R0,=H'1'                TEST IF THIRD PARAM\n         BNE   SPDECL01                BR IF NO\n         TM    4(R15),X'08'            ASSIGNMENT POSSIBLE ?\n         BZ    SPDECL01                YES, BRANCH\n         OI    0(R1),X'40'             SET NO ASSIGNMENT FLAG\n*\nSPDECL01 LA    R1,4(,R1)               STEP PARLIST POINTER\n         LA    R3,8(,R3)               STEP PARAMETER POINTER\n         LA    R15,8(,R15)             STEP ACTUAL PARAMETER POINTER\n         SRL   R2,4\n         BCT   R0,SPDECL02             BRANCH IF MORE PARAMETERS\n*\n*        PARAMETER LIST COMPLETE - ACTIVATE THE PROCEDURE\n*\n         ST    R15,SPSAVE              SAVE RETURN ADDR\n         LA    R1,PARLIST\n         TM    PRID+3,X'80'            ABS/SIGN/LENGTH/ENTIER ?\n         BO    SPDECL03                YES, BRANCH\n         IC    R2,PRID+3\n         N     R2,=X'000000FC'         GET DISPLACEMENT IN LAT\n         L     R15,0(R2,R4)            LOAD ADDR OF PROCEDURE\n         TM    PRID,X'03'              I/O PROCEDURE ?\n         BNZ   SPDECL04                NO, BRANCH\n*\n*        I/O PROCEDURE EXIT\n*\n         BALR  R14,R15\n         B     SPDECL18\n*\nSPDECL03 TM    PRID+3,X'50'\n         BNM   SPDECL04                BR IF ABS OR ENTIER FUNCTION\n         TM    PRID+3,X'20'\n         BZ    SPDECL05                BR IF SIGN FUNCTION\n*\n*        LENGTH FUNCTION\n*\n         L     R1,0(R1)\n         MVC   HW(2,R13),0(R1)\n         LH    R0,HW(R13)              LENGTH OF ENTIRE STRING FIELD\n         BCTR  R0,0                    REDUCE BY TWO TO GET\n         BCTR  R0,0                    ACTUAL STRING LENGTH\n         ST    R0,FCTVALST(R13)\n         B     SPDECL13\n*\n*        SIGN FUNCTION\n*\nSPDECL05 L     R2,0(,R1)               LOAD PARAMETER ADDR\n         SR    R0,R0                   INITIALIZE OUTPUT VALUE\n         TM    0(R1),X'80'             TYPE CONVERSION ?\n         BO    SPDECL06                YES, BRANCH\n         EX    0,LINSTR                VALUE TO FPR0\n         EX    0,LTRINSTR              TEST SIGN\n         B     SPDECL07\n*\nSPDECL06 ICM   R0,B'1111',0(R2)        VALUE TO R0\nSPDECL07 BZ    SPDECL08                TEST SIGN\n         LA    R0,1                    FUNCTION VALUE=1\n         BP    SPDECL08\n         LCR   R0,R0                   FUNCTION VALUE=-1\nSPDECL08 ST    R0,FCTVALST(,R13)\n         B     SPDECL13\n*\n*        MATHEMATICAL FUNCTIONS (INCLUDING ABS, ENTIER)\n*\nSPDECL04 L     R2,0(,R1)\n         TM    0(R1),X'80'             TYPE CONVERSION ?\n         BZ    SPDECL09\n         L     R14,0(,R2)              LOAD PARAMETER VALUE\n         BAL   R8,CNVIRD(R13)\n         EX    0,STINSTR\n         MVC   0(4,R1),ASTLOC(R13)     CHANGE PARAMETER ADDR\n         B     SPDECL10\n*\nSPDECL09 EX    0,LINSTR\nSPDECL10 CLI   PRID+3,X'80'            ABS ?\n         BNE   SPDECL11                NO, BRANCH\n*\n*        ABS FUNCTION\n*\n         EX    0,LPRINSTR              ABS VALUE TO FPR0\n         B     SPDECL14\n*\nSPDECL11 CLI   PRID+3,X'F0'            ENTIER ?\n         BNE   SPDECL12                NO, BRANCH\n*\n*        ENTIER FUNCTION\n*\n         BAL   R8,ENTIER(R13)\n         ST    R14,FCTVALST(R13)\n         B     SPDECL13\n*\n*        ALL OTHER FUNCTIONS\n*\nSPDECL12 BALR  R14,R15                 CALL SUBROUTINE\nSPDECL14 EX    0,STINSTR\nSPDECL13 L     R8,ASTLOC(R13)          ADDR OF FUNCTION VALUE\n*\n*        COMMON EXIT\n*\nSPDECL18 LR    R1,R5\n         MVC   SPDAP(4),0(R1)          RESTORE PREV DA POINTER\n         L     R2,SPSAVE               LOAD RETURN ADDR (PREV R15)\n*\n         FREEMAIN R,A=(1),LV=SPDALG\n*\n         LM    PBT,LAT,16(CDSA)\n         BR    R2                      RETURN TO CALLING PROGRAM\n*\n         DROP  R5\n*\n*        CONSTANTS AND WORK AREAS\n*\nSPTHAD   DC    F'0'                    TEMP STORAGE FOR THUNK ADDR\nSPDAP    DC    F'0'                    POINTER TO CURRENT DYNAMIC AREA\nFPTYP    DC    X'00'                   TYPE OF FORMAL PARAMETER\nFPTYPA   DC    X'00'                   SAVE AREA FOR FPTYP\n*\n*        DYNAMIC STORAGE AREA\n*\nSPDA     DSECT\n         DS    F                       LINK TO LOWER DA\nSPSAVE   DS    6F                      REGS R15, R0, R1, R2, R3, R4\nPRID     DS    F                       PROCEDURE IDENTIFICATION\nPARLIST  DS    3F                      PARAMETER LIST\nPARAMS   DS    3D                      PARAMETER VALUES\nSPDALG   EQU   *-SPDA\n*\nIHIFSARA CSECT\n*\n***********************************************************************\n*\n*        CALL SWITCH ELEMENT SUBROUTINE\n*\n***********************************************************************\n*\n*        THIS ROUTINE IS AN INTERMEDIATE LINK BETWEEN A SWITCH\n*        DESIGNATOR AND A SWITCH LIST\n*\n*        IT SEARCHES THE DSA CHAIN FOR THE DSA OF THE SWITCH LIST\n*        AND BRANCHES TO THE CALLED SWITCH LIST ENTRY\n*        CALLING SEQUENCE - (ENTRY VIA BRLIST)\n*        ADDR OF SWITCH LIST IN R8, ADDR OF DSA FOR\n*        BLOCK IN WHICH SWITCH IS DECLARED IN REG GDSA AND THE\n*        SWITCH ELEMENT NUMBER IN R15\n*\n*\n*        BAL   R14,CSWE1(R13)\n*        ---                           RETURN VIA CSWE2 WITH BRANCH\n*                                      ADDR IN R8 AND ADDR OF\n*                                      DSA IN GDSA\n*\nCSWE1A   LTR   R15,R15                 ELEMENT NUMBER POSITIVE ?\n         BNH   SWDMERR(R13)            NO, DIMENSION ERROR\n         CH    R15,2(,R8)              COMPARE NO WITH SWITCH LIST NO\n         BH    SWDMERR(R13)            DIMENSION ERROR\n         SLL   R15,2\n         L     R3,RASPT(R13)           RAS POINTER FROM TOP\nCSWEI1   LA    R3,8(R3)                RESERVE ONE ENTRY IN RAS\n         C     R3,RASPB(R13)           STACK OVERFLOW ?\n         BNL   RASOVERF(R13)\n         ST    CDSA,0(,R3)             STORE CDSA IN RAS\n         ST    R14,4(,R3)              SAVE RETURN ADDR IN STACK\n         SR    R14,R14                 NOT CALLING BLOCK INDICATION\n         CR    CDSA,GDSA               SWITCH BLOCK REACHED ?\n         BNE   CSWEI2                  NO\n         ST    R3,RASPT(R13)           SAVE RAS TOP POINTER\n         L     R15,0(R15,R8)           ADDR OF SWITCH ELEMENT\n         BR    R15\n*\nCSWEI2   LH    R1,8(,CDSA)             PROGRAM BLOCK DISPL TO REG\n         L     R2,0(,CDSA)             LAST GENERATION DSA POINTER IS\n         ST    R2,0(R1,PBT)            STORED IN PROGRAM BLOCK TABLE\n         L     CDSA,4(,CDSA)           LOAD DYNAMICALLY ENCLOSING DSA\n         LM    PBT,LAT,16(CDSA)        PBT AND LAT CAN BE DIFFERENT\n         B     CSWEI1                  CONTINUE\n*\n*        THIS ROUTINE HANDLES THE TRANSFER FROM THE SWITCH LIST\n*        BACK TO THE SWITCH DESIGNATOR\n*\n*        IT RELOADS CDSA WITH THE ADDR OF THE DSA THAT WAS\n*        ACTIVE WHEN CSWEU WAS ENTERED\n*\n*        CALLING SEQUENCE - (ENTRY VIA BRLIST)\n*        B     CSWE2(R13)\n*\nCSWE2A   L     R3,RASPT(R13)           RAS POINTER FROM TOP\nCSWEI3   L     R14,4(,R3)              RETURN ADDR FROM STACK\n         SH    R3,EIGHT(R13)           RELEASE ONE ENTRY IN RAS\n         ST    R3,RASPT(R13)           SAVE RAS TOP POINTER\n         LTR   R14,R14                 RETURN ADDR FOUND ?\n         BNZR  R14                     YES, RETURN\n         L     CDSA,0(R3)              NEW DSA POINTER FROM RAS\n         LH    R1,8(,CDSA)             PROGRAM BLOCK DISPL TO REG\n         ST    CDSA,0(R1,PBT)          CURRENT DSA POINTER TO PBT\n         LM    PBT,LAT,16(CDSA)        PBT AND LAT CAN BE DIFFERENT\n         B     CSWEI3                  CONTINUE\n*\n***********************************************************************\n*\n*        LOAD PRECOMPILED PROCEDURE\n*\n***********************************************************************\n*\n*        ENTERED FROM THE DECLARATION OF A 'CODE' PROCEDURE\n*\n*        SEARCH THE BOTTOM PART OF RAS FOR THE NAME OF THE\n*        PROCEDURE. IF IT IS NOT FOUND, THE PRECOMPILED PROCEDURE\n*        WITH THE SAME NAME IS LOADED AND ENTRIES ARE MADE IN\n*        RAS FOR THE NAME AND FOR THE ENTRY POINT\n*\n*        THE ENTRY POINT ADDR IS STORED IN THE PROGRAM BLOCK TABLE\n*\n*        CALLING SEQUENCE - (ENTRY VIA BRLIST)\n*\n*        BAL   R8,LOADPP(R13)\n*        DC    CL8(PPNAME)             NAME OF PRECOMPILED PROCEDURE\n*        DC    H'PBN'                  PROG BLOCK NUMBER\n*\nLOADPPA  LM    R3,R4,RASEND(R13)       RASEND AND RASPB TO REG\n         LA    R2,8                    SET TO 8\nLOADPP2  CR    R3,R4\n         BNH   LOADPP1                 BRANCH IF STACK EMPTY\n         CLC   0(8,R4),0(R8)           PROCEDURE ALREADY LOADED ?\n         LA    R4,8(,R4)               STEP TO NEXT PP NAME\n         BNE   LOADPP2                 NO, NAME NOT FOUND\n         L     R3,RASPT(R13)           RAS POINTER FROM TOP\n         S     R4,RASPB(R13)\n         SRL   R4,3                    NAME FOUND IN ENTRY NR R4\nLOADPP3  SR    R3,R2\n         CLI   8(R3),RASLOADM          LOAD PROCEDURE ENTRY ?\n         BNE   LOADPP3                 NO, CONTINUE SEARCH\n         BCT   R4,LOADPP3              LOOP TO FIND RIGHT ENTRY\n         L     R0,12(,R3)              FETCH ADDR OF CONSTANTS\n         B     LOADPP4\n*\n*        PROCEDURE MUST BE LOADED\n*\nLOADPP1  L     R3,RASPT(R13)\n         L     R4,RASPB(R13)\n         AR    R3,R2                   RESERVE ONE ENTRY FROM TOP\n         SR    R4,R2                   RESERVE ONE ENTRY FROM BOTTOM\n         CR    R3,R4                   STACK OVERFLOW ?\n         BNL   RASOVERF(R13)\n         ST    R4,RASPB(R13)           STORE UPDATED STACK POINTER\n         ST    R3,RASPT(R13)\n         MVC   0(8,R4),0(R8)           ENTER NAME IN STACK\n         LR    R0,R4                   R0 -> NAME\n*\n         LOAD  EPLOC=(0)\n*\n         ST    CDSA,0(,R3)             SAVE CDSA IN RAS ENTRY\n         MVI   0(R3),RASLOADM          INSERT LOAD PROCEDURE FLAG\n         ST    R0,4(,R3)               STORE ADDR TO ENTRY CONSTANT\nLOADPP4  LH    R3,8(,R8)               FETCH PBN CODE PROCEDURE\n         ST    R0,0(R3,PBT)            ADDR OF PRECOMPILED PROCEDURE\n*                                      CONSTANT TO CODE PROC.PBT ENTRY\n*                                      CONSTANT A(PBT),A(LAT),A(ENTRY)\n         B     10(,R8)                 RETURN TO DECLARATION END\n*\n***********************************************************************\n*\n*        TRACE ROUTINE\n*\n***********************************************************************\n*\n*        EXECUTED WHENEVER THE END OF AN ALGOL STATEMENT IS REACHED\n*\n*        IF ANY OF THE PARAMETERS TRACE, TRBEG OR TREND WAS\n*        SPECIFIED. IT CHECKS IF THE SEMICOLON NUMBER IS WITHIN A\n*        TRACE AREA AND, IF THIS IS THE CASE, STORES IT IN A\n*        BUFFER FOR OUTPUT ON SYSUT1 WHEN THE BUFFER OVERFLOWS.\n*        WHEN A DISCONTINUITY IS ENCOUNTERED (TRANSFER INTO A\n*        TRACE AREA OR BETWEEN THE MAIN PROGRAM AND A PRECOMPILED\n*        PROCEDURE), THE NAME OF THE ACTIVE MODULE IS ALSO\n*        STORED IN THE BUFFER\n*\n*        THE FORMAT OF THE INFORMATION IN THE BUFFER IS -\n*\n*        DC    H'LENGTH'               POINTER TO NEXT FREE PLACE\n*        DS    H                       NOT USED\n*        DC    H'SC'                   SEMICOLON NUMBER\n*         .\n*         .\n*        DC    H'0'                    FLAG FOR MODULE NAME\n*        DC    CL4'NAME'               MODULE NAME (FIRST 4 CHAR)\n*        DC    H'SC'                   SEMICOLON NUMBER\n*         .\n*         .\n*\n*        THE ROUTINE IS ENTERED VIA INSTRUCTIONS IN THE BRANCH\n*        LIST AT BRLIST. THESE INSTRUCTIONS STORE THE SEMICOLON\n*        NUMBER AND THEN EXECUTE A BRANCH EITHER TO THIS ROUTINE\n*        OR, IF TRACE WAS NOT REQUESTED, DIRECTLY BACK TO THE\n*        ALGOL PROGRAM.\n*\n*        CALLING SEQUENCE -\n*\n*        BAL   R15,TRACE(R13)\n*        DC    H'SC'                   SEMICOLON NUMBER\n*        ---                           (RETURN POINT)\n*\nTRACEA   STM   14,12,ASAVE+12(R13)     SAVE REGS IN SECOND SAVEAREA\n         L     R3,=A(IHIFSARB)\n         USING IHIFSARB,R3\n         LR    R1,PBT\n         LM    R6,R7,TRBEG             LOAD TRACE LIMITS\n         LM    R8,R11,TRBUF            LOAD BUFFER PARAMETERS\n         LH    R4,0(,R8)               LOAD BYTE POINTER\n         LH    R2,TRL1                 LENGTH OF NORMAL TRACE ITEM\n*\n         CLC   4(4,R1),TRMPNAME        MAINP OR PRECOMP PROC ?\n         BE    TRACE10                 MAINP\n         TM    OPTSW(R13),PPTRSW       TRACE IN PRECOMP PROC ?\n         BZ    TRACE6                  NO, PP TRACE\n         TM    TRFLAG,X'03'            PP CALLED FROM TRACE AREA ?\n         BM    TRACE0                  YES, TRACE REQUIRED\n         B     TRACE6                  CONDITIONAL - NO PP TRACE\n*\nTRACE10  LH    R5,SCRCS(R13)           LOAD CURRENT SEMICOLON NUMBER\n         CR    R7,R6                   TEST INTERVAL LIMITS\n         BNH   TRACE13                 SINGLE INTERVAL\n         CR    R5,R6                   CHECK SC AGAINST LIMITS\n         BL    TRACE15                 OUTSIDE INTERVAL\n         CR    R5,R7\n         BH    TRACE15                 OUTSIDE INTERVAL\n         B     TRACE16                 INSIDE INTERVAL\n*\nTRACE13  CR    R5,R7                   DOUBLE INTERVAL\n         BH    TRACE14\nTRACE16  MVI   TRFLAG1,1               INSIDE LOWER INTERVAL\n         B     TRACE18\n*\nTRACE14  CR    R5,R6\n         BL    TRACE15                 OUTSIDE BOTH INTERVALS\n         MVI   TRFLAG1,2               INSIDE HIGHER INTERVAL\nTRACE18  CLC   TRFLAG1,TRFLAG          BORDER BEEN CROSSED ?\n         BE    TRACE0                  NO, SAME INTERVAL AS BEFORE\n         MVC   TRFLAG,TRFLAG1\n         B     TRACE5\n*\nTRACE15  MVI   TRFLAG,0                NO TRACE THIS TIME\n         B     TRACE6\n*\nTRACE0   CLC   4(4,R1),TRPGID+2        PROGID CHANGED ?\n         BE    TRACE1                  NO, BRANCH\nTRACE5   MVC   TRPGID+2(4),4(R1)       STORE NEW PROGID\n         LH    R2,TRL2                 LENGTH OF ITEM WITH PROGID\nTRACE1   LR    R0,R2                   BUFFER FILLED ?\n         AR    R0,R4\n         CR    R0,R10\n         BL    TRACE2                  STILL ROOM, BRANCH\n         LTR   R11,R11                 IF NO RECORDS WRITTEN\n         BZ    TRACE4                  BYPASS CHECK\n*\n         CHECK TRCHECK\n*\nTRACE4   WRITE TRCHECK,SF,,(R8),MF=E\n*\n         LR    R0,R8\n         LR    R8,R9                   SWITCH BUFFERS\n         LR    R9,R0\n         LA    R4,4                    RESET POINTER\n         LA    R11,1(,R11)             INCR RECORD COUNTER\n*\nTRACE2   CH    R2,TRL1                 TEST FOR NEW PROGID\n         BE    TRACE3\n*\n         LR    R1,R8\n         AR    R1,R4\n         MVC   0(6,R1),TRPGID          PROGID TO BUFFER\n         LA    R4,6(,R4)\n*\nTRACE3   LR    R1,R8\n         AR    R1,R4\n         MVC   0(2,R1),SCRCS(R13)      SEMICOLON COUNTER TO BUFFER\n         LA    R4,2(,R4)\n         STH   R4,0(,R8)\n         STM   R8,R11,TRBUF\nTRACE6   LM    R14,R12,ASAVE+12(R13)\n         B     2(,R15)                 RETURN TO ALGOL PROGRAM\n*\n         CNOP  2,4\nTRL1     DC    H'2'                    LENGTH OF SEMICOLON FIELD\nTRL2     DC    H'8'                    LENGTH OF NEW NAME + SEMICOLON\nTRPGID   DC    H'0'                    FLAG FOR PROGID\n         DC    2H'0'                   FIRST FOUR BYTES OF PROG NAME\n         DC    X'FFFF'                 INITIAL VALUE FOR TREND\nTRBEG    DC    F'0'                    BEGINNING OF TRACE AREA\nTREND    DC    F'0'                    END OF TRACE AREA\nTRFLAG   DC    X'00'                   STATUS INDICATOR\n*                                        00 - OUTSIDE BOTH TRACE AREAS\n*                                        01 - INSIDE LOWER AREA\n*                                        02 - INSIDE HIGHER AREA\nTRFLAG1  DC    X'00'                   PREVIOUS VALUE OF TRFLAG\nTRMPNAME DC    CL4' '                  NAME OF MAIN PROGRAM\n*\n         DROP  R3\n*\n***********************************************************************\n*\n*        PROGRAM INTERRUPT ROUTINE\n*\n***********************************************************************\n*\n*        USE INTERRUPT CODE TO LOAD ENTRY FROM PIETAB TO PASS\n*        CONTROL TO FSA ERROR ROUTINE BY UPDATING THE OLD PSW\n*        AND RETURNING FROM SPIE\n*\n         USING PIEROUT,R15\nPIEROUT  L     R13,=A(IHIFSARA)\n         MVC   PGOPSW(8,R13),4(R1)     MOVE BC MODE PSW TO PGOPSW\n         IC    R2,PGOPSW+3(,R13)       LOAD INTERRUPTION CODE\n         N     R2,PGCMASK              REMOVE IMPRECISE CODES (M/91)\n         SLA   R2,2                    CONVERT INTERRUPT CODE\n         LA    R2,PIETAB(R2)           FOR TABLE LOOKUP\nPIEROUT2 MVC   9(3,R1),1(R2)           CHANGE RETURN ADDR IN OLD PSW\n         BR    R14                     RETURN FROM SPIE RTN\n*\n         DROP  R15\n*\n         DC    0F'0'\nPGCMASK  DC    X'0000000F'             MASK FOR INTERRUPT CODE\n*\nPIETAB   DC    A(ERROR33)              MOD/91 ONLY\n         DC    A(ERROR33)              OPERATION        - 0C1\n         DC    A(ERROR33)              PRIVILAGE        - 0C2\n         DC    A(ERROR33)              EXECUTE          - 0C3\n         DC    A(ERROR33)              PROTECTION       - 0C4\n         DC    A(ERROR33)              ADDRESSING       - 0C5\n         DC    A(ERROR33)              SPECIFICATION    - 0C6\n         DC    A(ERROR33)              DATA             - 0C7\n         DC    A(ERROR28)              FIXED PT OVFL    - 0C8\n         DC    A(ERROR30)              FIXED PT DIVIDE  - 0C9\n         DC    A(ERROR33)              DECIMAL OVFL     - 0CA\n         DC    A(ERROR33)              DECIMAL DIVIDE   - 0CB\n         DC    A(ERROR29)              EXPONENT OVFL    - 0CC\n         DC    A(ERROR33)              EXPONENT UNDERFL - 0CD\n         DC    A(ERROR33)              FP SIGNIFICANCE  - 0CE\n         DC    A(ERROR31)              FP DIVIDE        - 0CF\n*\n***********************************************************************\n*\n*        ENTRY POINTS IN IHIIOR USED BY I/O ROUTINES\n*\n***********************************************************************\n*\nADRLST   DC    A(IHIIORCI)\n         DC    A(IHIIORCL)\n         DC    A(IHIIOREV)\n         DC    A(IHIIORNX)\n         DC    A(IHIIOROP)\n         DC    A(IHIIOROQ)\n         DC    A(IHIIOREN)\n         DC    A(IHIIORGP)\n         DC    A(IHIIORER)\n*\n***********************************************************************\n*\n*        INITIAL ENTRY POINT\n*\n***********************************************************************\n*\n         DROP  R13\n         USING IHIFSAIN,R15\n*\nIHIFSAIN SAVE  (14,12),,'IHIFSAIN LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         L     FSAA,=A(IHIFSARA)\n         ST    R13,4(,FSAA)            LINK SAVE AREAS TOGETHER\n         ST    FSAA,8(,R13)\n         LR    R13,FSAA\n         L     R7,=A(IHIFSARB)\n         USING IHIFSARB,R7\n         B     ALGIN                   TO INITIALIZATION ROUTINE\n*\n         DROP  R15\n         DROP  R7\n*\nIHIFSARB CSECT\n*\n***********************************************************************\n*\n*        INITIALIZATION ROUTINE\n*\n***********************************************************************\n*\n*        THIS IS THE FIRST ROUTINE EXECUTED WHEN AN ALGOL\n*        PROGRAM IS EXECUTED OR CALLED VIA A PROGRAM\n*\n*        PERFORM INITIALIZING FUNCTIONS AND TRANSFER CONTROL TO\n*        THE ALGOL OBJECT PROGRAM\n*\n         USING IHIFSARA,R13\n         USING IHIFSARB,R7\n*\nALGIN    SPIE  PIEROUT,((1,9),12,15)   EXIT FOR RELEVANT PROG CHECKS\n*\n         ST    R1,FSAPICA(,R13)\n*\n*        GET STORAGE FOR RETURN ADDR STACK\n*        INITIALIZE RAS POINTERS\n*\n         GETMAIN R,LV=2048\n*\n         SH    R1,EIGHT(,R13)\n         ST    R1,RASPT(,R13)\n         ST    R1,RASSTART(,R13)\n         LA    R1,2056(,R1)\n         ST    R1,RASPB(,R13)\n         ST    R1,RASEND(,R13)\n         SR    CDSA,CDSA\n         L     R5,ADSTAB(R13)          INITIALIZE DS ENTRIES FOR\n         L     R2,0(,R5)               S P K Q\n         LA    R5,4(,R5)\n         LTR   R2,R2                   THERE A PUT/GET CONTROL FILE ?\n         BM    ALGIN01A\n         LA    R1,2048                 YES\n         ST    R1,16(,R2)              INSERT BE LENGTH\n         ST    CDSA,24(,R2)            INITIALIZE S, TYP IN PGCF\nALGIN01A LA    R2,0(,R2)               CLEAR HIGH ORDER BYTE\nALGIN01  CR    R2,R5\n         BE    ALGIN02\n         MVC   20(6,R5),DSINIT\n         LA    R5,36(,R5)\n         B     ALGIN01\n*\nALGIN02  STH   CDSA,TRPGID             INITIALIZE TRACE COUNTERS\n         ST    CDSA,TRPGID+2\n         STC   CDSA,TRFLAG\n         MVI   TRPGID+6,X'FF'\n         MVI   TRPGID+7,X'FF'\n         STH   CDSA,SCRCS(R13)         INITIALIZE SEMICOLON COUNT\n         ST    CDSA,ANOTTAB(R13)       RESET NOTE TABLE ADDR\n         ST    CDSA,SPDAP              RESET SPECIAL DECL POINTER\n*\n*        EXECUTION TIME OPTIONS AND SET SWITCHES\n*\n*        TEST FOR SHORT/LONG PRECISION\n*\n         L     R2,=A(IHIENTIF)         GET S/L SWITCH\n         MVC   OPTSW(1,R13),8(R2)      FROM THE OBJECT MODULE\n         MVC   CNVINST(CNVINSTL),CNVINSTE  ASSUME SHORT\n         LA    R2,SETSHORT\n         TM    OPTSW(R13),SHSW\n         BO    ALGIN4                  IF SHORT\n         MVC   CNVINST(CNVINSTL),CNVINSTD    MODIFY CONVERT ROUTINE\n         LA    R2,4(,R2)\nALGIN4   LM    R3,R5,FPINSTAD          MODIFY FLOATING POINT\nALGIN4A  EX    0,0(R2)                 INSTRUCTIONS\n         BXLE  R3,R4,ALGIN4A\n*\n*        CHECK EXECUTION PARAMETERS DUMP AND TRACE\n*\nALGIN0   OI    TRACE+7(R13),X'F0'      DEACTIVATE BRANCH TO TRACE RT\n         MVC   TRPGID+2(4),TRPGID+1    RESET PROGID FOR TRACE\n         MVC   TRBEG(8),TRPGID         INITIALIZE TRACE LIMITS\n         L     R2,4(,R13)\n         ICM   R2,B'1111',24(R2)       R2 -> PARAMETER LIST\n         BZ    ALGIN1                  BRANCH IF NO PARAMETERS\n         L     R2,0(,R2)               ADDR OF PARAMETER FIELD\n         LA    R2,0(,R2)               RESET HIGH ORDER BYTE\n         LH    R3,0(,R2)\n         LTR   R3,R3                   LENGTH OF PARAMETER FIELD\n         BZ    ALGIN1                  NO PARAMETERS\n         AR    R3,R2                   END OF PARAMETER FIELD\n         LA    R5,LASTPARM             END OF PARAMETER LIST\n         SR    R6,R6\nFNDCOMMA CLI   2(R2),C','\n         BNE   FNDPAR\nSTEP1    LA    R2,1(,R2)\nCOMP1    CR    R2,R3\n         BL    FNDCOMMA\n         B     ALGIN2                  WHOLE PARM FIELD SCANNED\n*\nFNDPAR   LA    R4,PARMLIST\n         USING PARMLIST,R4\nNXTPAR   IC    R6,PARMLG               LENGTH OF PARAMETER\n         EX    R6,COMPINST             COMPARE WITH ENTRY IN LIST\n         BNE   NOTFOUND\n         LA    R1,1(R2,R6)\n         EX    0,PABRANCH\nCHKCOMMA CLI   2(R1),C','              CHECK FOR COMMA AFTER PARAM\n         BE    SETBIT\n         CR    R1,R3                   IF NO COMMA CHECK FOR END OF\n         BL    STEP1                   PARAMETER FIELD\nSETBIT   LR    R2,R1\n         EX    0,PARMSET\n         B     COMP1\n*\nNOTFOUND CR    R4,R5                   CHECK FOR END OF LIST\n         LA    R4,PARLG(,R4)\n         BL    NXTPAR                  NEXT ENTRY IN LIST\n         B     INVOPT(R13)             OPTION NOT FOUND IN LIST\n*\nCOMPINST CLC   2(0,R2),PARM\n         DROP  R4\n*\n*        EVALUATE TRBEG OR TREND PARAMETER\n*\nTRLIM1   LA    R8,TRBEG\n         B     TRLIM2A\n*\nTRLIM2   LA    R8,TREND\nTRLIM2A  CLI   2(R1),C'='\n         BNE   INVOPT(R13)\n         LA    R9,5(,R1)               END OF NUMBER FIELD\n         SR    R10,R10                 RESET NUMBER ACCUMULATOR\nTRLIM4   LA    R1,1(,R1)               STEP TO NEXT DIGIT\n         CR    R1,R3\n         BNL   TRLIM3                  BR IF END OF WHOLE PARAM FIELD\n         CLI   2(R1),C','\n         BE    TRLIM3                  BR IF END OF THIS PARAMETER\n         CR    R1,R9\n         BH    INVOPT(R13)             BR IF TOO MANY DIGITS\n         CLI   2(R1),C'0'              CHECK FOR VALID DIGIT\n         BL    INVOPT(R13)\n         CLI   2(R1),C'9'\n         BH    INVOPT(R13)\n         MVN   TRLDIG+1(1),2(R1)       EXTRACT NEW DIGIT\n         MH    R10,=H'10'\n         AH    R10,TRLDIG              ACCUMULATE SUM\n         B     TRLIM4\n*\nTRLIM3   ST    R10,0(,R8)              STORE AS TRBEG OR TREND\n         B     SETBIT\n*\nTRLDIG   DC    H'0'                    TEMP STORAGE FOR DIGIT\n*\n*        PREPARE FOR PROGRAM TRACING\n*\nALGIN2   EQU   *\n         TM    DTSW(R13),TRSW          TRACE REQUESTED ?\n         BZ    ALGIN1\n*\n         OPEN  (SYSUT1,(OUTIN))        OPEN SYSUT1 FOR USE BY TRACE\n*\n         LA    R3,SYSUT1\n         USING IHADCB,R3\n         TM    DCBOFLGS,DCBOFOPN       SYSUT1 OPENED ?\n         BO    ALGIN3\n         NI    DTSW(R13),255-TRSW      TRACE SWITCH OFF\n         LA    R6,17                   SET DATASET NUMBER TO 17\n         B     DDERROR(R13)\n*\nALGIN3   NI    TRACE+7(R13),X'0F'      ACTIVATE BRANCH TO TRACE ROUT\n         LH    R0,DCBBLKSI             GET BLOCK SIZE FROM DCB\n         DROP  R3\n         ST    R0,TRBUFL               STORE AS BUFFER LENGTH\n         SLA   R0,1\n*\n         GETMAIN R,LV=(0)              GET TWO BUFFERS FOR SYSUT1\n*\n         ST    R1,TRBUF                ADDR OF FIRST BUFFER\n         SR    R0,R0\n         ST    R0,TRCNT                RESET RECORD COUNTER\n         LA    R0,4                    SET BYTE POINTER\n         STH   R0,0(,R1)\n         A     R1,TRBUFL\n         ST    R1,TRBUFA               ALTERNATE BUFFER\n*\n*        INITIALIZE REGISTERS AND ENTER OBJECT MODULE\n*\nALGIN1   SR    CDSA,CDSA\n         L     R15,=A(IHIENTIF)\n         LM    PBT,LAT,0(R15)\n         L     R2,16                   R2 -> CVT ADDR\n         L     R2,0(,R2)\n         L     R2,4(,R2)               R2 -> TCB\n         L     R2,0(,R2)               R2 -> RB ADDR\n         L     R2,12(,R2)              INSERT RB NAME INTO PBTAB\n         MVC   4(4,PBT),8(R2)\n         MVC   TRMPNAME,8(R2)\n         L     R15,8(,R15)\n         BR    R15                     ENTER ALGOL PROGRAM\n*\n*        DCB EXIT ROUTINE FOR SYSUT1\n*\n         USING IHADCB,R1\nSYSUT1X  LH    R2,DCBBLKSI\n         LTR   R2,R2                   BLKSIZE SPECIFIED ?\n         BNZ   DCBEXIT1                YES, BRANCH\nDCBEXIT2 LA    R2,TRBUFST              ELSE USE STANDARD SIZE\n         STH   R2,DCBBLKSI\n*\nDCBEXIT3 RETURN\n*\nDCBEXIT1 CH    R2,TRBUFMIN             CHECK BLKSIZE\n         BL    DCBEXIT2                IF TOO LOW OR TOO HIGH,\n         CH    R2,TRBUFMAX             USE STANDARD SIZE\n         BH    DCBEXIT2\n         B     DCBEXIT3\n*\n         DROP  R1\n*\nTRBUFMIN DC    H'14'                   MINIMUM TRACE BUFFER SIZE\nTRBUFMAX DC    H'32760'                MAXIMUM TRACE BUFFER SIZE\n*\nTRBUFST  EQU   2048                    STANDARD TRACE BUFFER SIZE\n*\nDSINIT   DC    X'000100500200'         INITIALIZE DSTAB\n*\nSETSHORT OI    0(R3),SHORTBIT          MODIFY FP INSTR FOR SHORT\n         NI    0(R3),255-SHORTBIT      OR LONG PR\n*\n*        TABLE FOR DECODING OPTION PARAMETERS\n*\nPARMLIST DC    0H'0'\nPARMLG   DC    AL1(3)                  (LENGTH - 1) OF KEYWORD\nPARM     DC    CL5'DUMP'               OPTION KEYWORD\n*\nPABRANCH B     CHKCOMMA                EXIT TO EVALUATION ROUTINE\n*\nPARMSET  OI    DTSW(R13),DPSW          SET FLAG BIT\nPARLG    EQU   *-PARMLG\n         DC    AL1(4)\n         DC    CL5'TRACE'\n         B     CHKCOMMA\n*\n         OI    DTSW(R13),UCTRSW\n         DC    AL1(4)\n         DC    CL5'TRBEG'\n         B     TRLIM1\n*\n         OI    DTSW(R13),TRSW\nLASTPARM DC    AL1(4)\n         DC    CL5'TREND'\n         B     TRLIM2\n*\n         OI    DTSW(R13),TRSW\n*\n***********************************************************************\n*\n*        TERMINATION ROUTINE\n*\n***********************************************************************\n*\n*        THIS ROUTINE IS ENTERED EITHER FROM THE ALGOL PROGRAM\n*        UPON PASSING THE FINAL 'END' STATEMENT (NORMAL\n*        TERMINATION) OR FROM THE ERROR ROUTINE (ABNORMAL\n*        TERMINATION).\n*\n*        IN EITHER CASE IT EDITS AND PRINTS THE TRACE INFORMATION\n*        IF ANY, CLOSES ALL DATASETS AND RESTORES THE REGISTERS\n*        AS THEY WERE AT THE TIME OF ENTRY TO THE ALGOL PROGRAM\n*\n*        RETURN IS TO OS OR THE CALLING PROGRAM\n*        THE COMPLETION CODE IS SET TO ZERO (NORMAL) OR 16\n*        (ABNORMAL TERMINATION)\n*\nALGTRMA  MVI   COMPCODE+3,16           ENTRY IN CASE OF ERROR\n         B     ALGTRM0\n*\n*        NORMAL ENTRY\n*\nALGTRMN  MVI   COMPCODE+3,0\nALGTRM0  LR    FSAA,R13                PREPARE FOR\n         L     R5,ADSTAB(,R13)         OUTPUT TO SYSPRINT\n         LA    R5,DSTABLEL+4(,R5)      BY MEANS OF I/O ROUTINES\n         LA    R6,1                    SET DSNR TO 1 FOR SYSPRINT\n         USING DSTABLE,R5\n         TM    COMPCODE+3,X'04'\n         BO    ALGTRM00\n         OI    DSF+1,DS15              FLAG CLOSE FROM IHIFSA\n         L     R15,=V(IHIIORCP)        CLOSE ALL DATASETS USED\n         BALR  R14,R15\nALGTRM00 OI    OPTSW(R13),TERMSW       FLAG TERM ROUTINE ENTERED\n         TM    OPTSW(R13),PRNTERR\n         BZ    ALGTRM16                IF SYSPRINT OK\n*\n         WTO   MF=(E,WTOTRM)           WRITE END EXEC MESSAGE\n*\n         B     ALGTRM10\n*\nALGTRM16 OI    DSF+1,DS11              RE-OPEN SYSPRINT FOR\n         OI    DSF,DS2+DS3+DS6         TRACE AND TERM OUTPUT\n         TM    COMPCODE+3,X'04'\n         BO    ALGTRM1A\n         L     R15,=V(IHIIOROP)\n         BALR  R14,R15\n         B     ALGTRM1B\n*\nALGTRM1A MVI   S+1,50\nALGTRM1B BAL   R14,BLANK\n         OI    DSF,DS3\n         L     R15,=V(IHIIORNX)\n         BALR  R14,R15\nALGTRM1  TM    DTSW(R13),TRSW\n         BZ    ALGTRM11                NO TRACE OPTION, BRANCH\n         TM    OPTSW(R13),UT1ERR\n         BO    ALGTRM18                IF SYSUT1 ERROR\n         LM    R8,R11,TRBUF            LOAD BUFFER PARAMETERS\n         LTR   R11,R11\n         BZ    ALGTRM2                 NO RECORDS WRITTEN, BRANCH\n*\n         CHECK TRCHECK                 CHECK LAST RECORD WRITTEN\n*\n         LH    R4,0(,R8)\n         CH    R4,=H'4'\n         BNH   ALGTRM3                 CURRENT BUFFER EMPTY, BRANCH\n*\n         WRITE TRCHECK,SF,,(R8),MF=E   WRITE LAST RECORD\n*\n         CHECK TRCHECK\n*\n         LA    R11,1(,R11)\n*\nALGTRM3  CLOSE (SYSUT1,REREAD),TYPE=T  CLOSE TEMPORARY\n*\n         READ  TRCHECK,SF,,(R8),MF=E   READ FIRST RECORD\n*\n*        PRINT TRACE HEADLINES\n*\nALGTRM2  BAL   R14,TRHEAD\nALGTRM4  LTR   R11,R11\n         BNZ   ALGTRM9                 IF RECORDS ON SYSUT1\n         LR    R9,R8\n         B     ALGTRM5\n*\nALGTRM9  CHECK TRCHECK                 CHECK PREVIOUS READ\n*\n         LM    R8,R9,TRBUF\n         LR    R1,R8                   SWITCH BUFFERS\n         LR    R8,R9\n         LR    R9,R1\n         STM   R8,R9,TRBUF\n         BCT   R11,ALGTRM6             DECR RECORD COUNTER\n         B     ALGTRM5                 NO MORE RECORDS, BRANCH\n*\nALGTRM6  READ  TRCHECK,SF,,(R8),MF=E\n*\nALGTRM5  LH    R4,0(0,R9)              LOAD BYTE COUNT\n         AR    R4,R9                   ADDR OF LAST BYTE PLUS ONE\n         LA    R9,4(0,R9)              R9 IS NOW BYTE POINTER\n         L     R2,R                    SYSPRINT BYTE POINTER\n         B     ALGTRM7\n*\nALGTRM8  CLC   0(2,R9),TRPGID          NEXT ITEM A PROGID ?\n         BNE   ALGTRM12                NO, BRANCH\n         MVC   PROGID(4),2(R9)         STORE PROGID\n         LA    R9,6(0,R9)\n         B     ALGTRM15\n*\nALGTRM12 LA    R3,6(,R2)               ROOM FOR\n         C     R3,RE                   ONE MORE OUTPUT ITEM ?\n         BL    ALGTRM13                YES, BRANCH\nALGTRM15 OI    DSF,DS3\n         L     R15,=V(IHIIORNX)\n         BALR  R14,R15\n         CLC   S(2),=H'1'              NEW PAGE ?\n         BNE   ALGTRM14                NO, BRANCH\n         BAL   R14,TRHEAD              PRINT PAGE HEADINGS\n         B     ALGTRM15\n*\nALGTRM14 L     R2,R\n         BAL   R14,BLANK               INITIALIZE WITH BLANKS\n         MVC   0(10,R2),PIDFIELD       PROGID AT START OF NEW LINE\n         MVC   PROGID(4),PROGID-1      BLANKS TO RPOGID\n         LA    R2,PIDLGTH(,R2)\nALGTRM13 LH    R3,0(,R9)\n         LA    R9,2(,R9)               CONVERT SEMICOLON COUNTER\n         CVD   R3,CONVBUF              PRINT AREA\n         MVC   0(L'SCPATTN,R2),SCPATTN    MOVE IN PATTERN\n         ED    0(L'SCPATTN,R2),CONVBUF+5  FORMAT SC COUNT\n         LA    R2,6(,R2)               STEP OUTPUT BUFFER POINTER\n         ST    R2,R\nALGTRM7  CR    R9,R4\n         BL    ALGTRM8                 NOT END OF SYSUT1 REC, BRANCH\n         LTR   R11,R11\n         BNZ   ALGTRM9                 MORE RECORDS TO READ, BRANCH\n         OI    DSF,DS3                 PRINT LAST LINE\n         L     R15,=V(IHIIORNX)\n         BALR  R14,R15\n*\n*        CLOSE SYSUT1 AND FREE BUFFER AREA\n*\nALGTRM18 CLOSE (SYSUT1)\n*\n         LM    R8,R9,TRBUF             GET LOWER\n         LR    R1,R8                   BUFFER ADDR\n         CR    R8,R9\n         BL    *+6\n         LR    R1,R9\n         L     R0,TRBUFL\n         SLA   R0,1\n*\n         FREEMAIN R,LV=(0),A=(1)       FREE SYSUT1 BUFFER\n*\n*        PRINT EXECUTION END MESSAGE\n*\nALGTRM11 L     R2,R                    BYTE POINTER\n         MVC   0(TML,R2),TRMSG         MOVE TERMINATION MESSAGE\n         LA    R2,TML(,R2)\n         ST    R2,R                    UPDATE BYTE POINTER\n         LA    R2,2                    LOOP COUNTER FOR BLANK LINES\nALGTRM19 BAL   R14,BLANK\n         OI    DSF,DS3\n         L     R15,=V(IHIIORNX)\n         BALR  R14,R15\n         BCT   R2,ALGTRM19             ONE EXTRA BLANK LINE\n         OI    DSF+1,DS15              FLAG CLOSE FROM IHIFSA\n         L     R15,=V(IHIIORCL)        CLOSE SYSPRINT\n         BALR  R14,R15\n*\n*        FINAL CLEAN-UP\n*\nALGTRM10 L     R1,RASSTART(R13)        FREE RETURN ADDR STACK\n         LA    R1,8(,R1)\n*\n         FREEMAIN R,LV=2048,A=(1)\n*\nALGTRM17 L     R2,FSAPICA(,R13)\n*\n         SPIE  MF=(E,(R2))             RESTORE PICA\n*\nALGTRMAA L     R13,4(,R13)\n         L     R15,COMPCODE            RETURN CODE INTO R15\n*\n         RETURN (14,12),RC=(15)        TO OS OR THE CALLING PROGRAM\n*\n*        ROUTINE FOR FILLING A SYSPRINT RECORD WITH BLANKS\n*\nBLANK    STM   R2,R3,BLANKS\n         L     R2,R                    CURRENT BYTE POINTER\n         L     R3,RE                   RECORD END POINTER\nBLANKA   CR    R2,R3\n         BNL   BLANKB                  RECORD END, BRANCH\n         MVI   0(R2),C' '              INSERT ONE BLANK\n         LA    R2,1(,R2)               STEP TO NEXT BYTE\n         B     BLANKA                  LOOP TO PROCESS NEXT CHAR\n*\nBLANKB   ST    R2,R                    UPDATED BYTE POINTER\n         LM    R2,R3,BLANKS\n         BR    R14\n*\nBLANKS   DC    2F'0'\n*\n*        ROUTINE FOR PRINTING TRACE OUTPUT HEADING\n*\nTRHEAD   STM   R14,R12,ASAVE+12(R13)   USE SECOND SAVE AREA\n         LM    R2,R4,TRHADR            COUNTER FOR HEADLINES\nTRHEAD1  L     R1,R\n         BAL   R14,BLANK               INITIALIZE WITH BLANKS\n         EX    0,0(R4)                 MOVE TEXT, OR NOP\n         OI    DSF,DS3\n         L     R15,=V(IHIIORNX)\n         BALR  R14,R15\n         BXLE  R4,R2,TRHEAD1\n         BAL   R14,BLANK               BLANK LINE AFTER HEADING\n         LM    R14,R12,ASAVE+12(R13)\n         BR    R14\n*\nTRHADR   DC    A(6,TRHEND,TRHLIST)\n*\nTRHLIST  NOP   0                       BLANK LINE\n         NOPR  0\n         MVC   0(L'TRHEADA,R1),TRHEADA\n         NOP   0                       BLANK LINE\n         NOPR  0\nTRHEND   MVC   0(L'TRHEADB,R1),TRHEADB\n*\nTRHEADA  DC    C'  ALGOL PROGRAM TRACE'         FIRST HEADLINE\n*\nTRHEADB  DC    C'MODULE     SEMICOLON NUMBERS'  SECOND HEADLINE\n*\nSCPATTN  DC    X'402020202020'         FORMAT SEMICOLON COUNT VALUE\n*\nWTOTRM   WTO   'END OF ALGOL PROGRAM EXECUTION',ROUTCDE=11,DESC=7,MF=L\n*\nTRMSG    EQU    WTOTRM+4\nTML      EQU   *-TRMSG-4\n*\n*        ERROR AND END OF DATA ROUTINE FOR SYSUT1\n*\nENDUT1   OI    OPTSW(R13),UT1ERR       SYSUT1 ERROR SWITCH ON\n         LA    R6,17                   DUMMY DS NUMBER FOR SYSUT1\n         B     ERROR32\n*\n*        PARAMETER LIST USED BY BOTH READ AND WRITE MACROS FOR\n*        SYSUT1\n*\n         WRITE TRCHECK,SF,SYSUT1,MF=L\n*\n*        PARAMETERS FOR TRACE BUFFER\n*\nTRBUF    DC    F'0'                    ADDR OF CURRENT BUFFER\nTRBUFA   DC    F'0'                    ADDR OF ALTERNATE BUFFER\nTRBUFL   DC    F'0'                    LENGTH OF BUFFER\nTRCNT    DC    F'0'                    RECORD COUNTER\n*\n*        THE BYTE POINTER IS CONTAINED IN THE FIRST TWO BYTES OF\n*        THE RECORD AND SERVES AS RECORD LENGTH FIELD\n*\nCOMPCODE DC    F'0'                    COMPLETION CODE (0 OR 16)\n*\n*        WORK STORAGE FOR EDITING THE TRACE LISTING\n*\nPIDFIELD DC    CL2' '\nPROGID   DC    CL4' '                  MODULE NAME\n         DC    CL4' '\nPIDLGTH  EQU   *-PIDFIELD\nCONVBUF  DC    D'0'                    FOR CONVERTING SEMICOLON NUMBER\n*\n*        DCB FOR SYSUT1\n*\nSYSUT1   DCB   DSORG=PS,MACRF=(R,W),DDNAME=SYSUT1,RECFM=F,             X\n               EODAD=ENDUT1,EXLST=EXLUT1,SYNAD=ENDUT1\n*\nEXLUT1   DC    X'85',AL3(SYSUT1X)\n*\n*        LTORG\n*\n*\n*        DATASET TABLE ENTRY\n*\n         DSTABLE DSECT=YES\n*\n         PRINT NOGEN\n*\n         DCBD  DSORG=(BS),DEVD=(DA,TA)\n*\n         PRINT GEN\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIGPR   0201-12230-12230-1200-00906-00906-00000-LEVEL\nGPR      TITLE 'IHIGPRTN, PUT/GET, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*\n*        ACTION OF PUT -\n*        TRANSFER DATA INDICATED BY A LIST PROCEDURE, WHICH IS THE\n*        SECOND PARAMETER IN PUT, TO AN I/O BUFFER IN BINARY FORM\n*        WRITE A RECORD, V-FORM, TO A DASD DATASET WITH A\n*        DDNAME OF SYSUT2. ENTER REPOSITIONING INFORMATION IN\n*        NOTTAB\n*\n*        ACTION OF GET -\n*        RETRIEVE INFORMATION AFTER REPOSITIONING OF DATASET\n*        STORED BY PUT AND ASSIGN DATA TO IDENTIFIER IN LIST\n*        PROCEDURE\n*\n*        ENTRY POINTS -\n*        IHIGPRPT - FROM GENERATED OBJECT MODULE\n*                   DATA PASSED BY NAME\n*                   LA   R1,PARMLIST\n*                   BALR R14,R15\n*\n*        IHIGPROT - FROM IHIFSA\n*                   PROCEDURE IS ACTUAL PARAMETER OF LIST DATA\n*                   PASSED BY NAME R15 POINTS TO A THUNK FIELD\n*\n*        IHIGPRGT - FROM GENERATED OBJECT MODULE\n*                   DATA PASSED BY NAME\n*                   LA   R1,PARMLIST\n*                   BALR R14,R15\n*\n*        IHIGPRIT - FROM IHIFSA\n*                   PROCEDURE IS ACTUAL PARAMETER OF LIST DATA\n*                   PASSED BY NAME R15 POINTS TO A THUNK FIELD\n*\n*        IHIGPRCL - FROM IHIIOR - CLOSE DATASET\n*                   NO DATA PASSED\n*                   BALR R14,R15\n*\n*        INPUT -\n*        GET READS A RECORD STORED PREVIOUSLY BY PUT, DATA IN\n*        BINARY FORM\n*\n*        OUTPUT - STORES DATA IN BINARY FORM\n*\n*        EXTERNAL ROUTINES -\n*        IHIIOR - CONVERT REAL TO INTEGER - ENTRY NOTTAB - SYNAD\n*\n*        EXITS - NORMAL -\n*                FOR ROUTINE PUT AND GET RELOAD REGISTERS AND BR14\n*                FOR PROCEDURE OUTPUT AND INPUT SEE BELOW\n*              - ERROR -\n*                NO.10 DATASET CLOSED\n*                NO.14 BACK WARD REPOSITIONING NOT DEFINED\n*                NO.20 ACTUAL AND FORMAL PARAMETER OF DIFFERENT TYPE\n*                NO.21 NUMBER OF PARAMETERS DOES NOT CORRESPOND\n*                NO.36 TOO MANY NESTED BLOCKS PROCEDURES AND PARAMETERS\n*                NO.38 GET/PUT BUFFER OVERFLOW\n*                NO.39 GET/PUT IDENTIFICATION OUT OF RANGE\n*                NO.41 DDCARD INCORRECT OR MISSING\n*                NO.43 RECURSIVELY TRY OF PUT/GET OR OUTPUT/INPUT\n*        ACTION - BRANCH TO IHIFSA\n*                 LA  R13,IHIFSA\n*                 B   FSAERR+XX*4(R13)  XX ERROR NO\n*\n*        TABLES/WORKAREAS - N/A\n*\n*        ATTRIBUTES - SERIALLY REUSABLE\n*\n*        NOTES -\n*        THE LIST PROCEDURE HAS ONE FORMAL PARAMETER WHICH IS A\n*        PROCEDURE AND WHICH ONLY IS DECLARED AND HAS NO\n*        PROCEDURE BODY IN THE ALGOL PROGRAM, AT ACTUAL POSITION\n*        THIS IS OUTPUT RESP. INPUT ADDR OF PUT/GET FIELD IN\n*        DSTAB LOADED TO R5 R6=16 IS KEPT THROUGH THE\n*        MODULE IN ORDER TO ADDR THIS FIELD\n*\nIHIGPRTN CSECT\n*\n         ENTRY IHIGPRPT\n         ENTRY IHIGPROT\n         ENTRY IHIGPRGT\n         ENTRY IHIGPRIT\n         ENTRY IHIGPROP\n         ENTRY IHIGPRCL\n*\n*        FLOATING POINT REGISTER\n*\nFPR0     EQU   0\n*\n*        DISPLACEMENTS IN ADRLST IN IHIFSA\n*\n*                                      DISPLACEMENT FOR\nCI       EQU   0                       IHIIORCI\nCL       EQU   4                       IHIIORCL\nEV       EQU   8                       IHIIOREV\nNX       EQU   12                      IHIIORNX\nOP       EQU   16                      IHIIOROP\nOQ       EQU   20                      IHIIOROQ\nEN       EQU   24                      IHIIOREN\nGP       EQU   28                      IHIIORGP\nER       EQU   32                      IHIIORER\n*\n*        PUT/GET FLAGS\n*\nPG0      EQU   X'80'\nPG1      EQU   X'40'\n*\n         USING IHIGPRPT,R15\n*\nIHIGPRPT IHIENTRY 'IHIGPRPT LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         ST    R13,SAVEPG+4            SAVE REGISTER INTERNALLY\n         LA    R13,SAVEPG\n*\n         SAVE  (14,12)\n*\n         DROP  R15\n         LR    R7,R15\n         USING IHIGPRPT,R7\n         ST    R13,SAVEPUT+4\n         L     R12,SAVEPG+4            ADDR OF FSA\n         LA    R13,SAVEPUT\n         L     R5,ADSTAB(R12)          FIRST ENTRY IN DSTAB IS APGCF\n         L     R5,0(,R5)               ADDR OF PGCF IN R5\n         LA    R6,16                   SET DSN NUMBER TO 16 FOR SYSUT2\n         USING PGCF,R5\n         TM    RECPG,X'01'             TEST IF RECURSIVELY\n         BO    ERROR43                 YES\n         OI    RECPG,X'01'             SET FLAG BIT\n         TM    PG,PG0                  DATASET OPEN ?\n         BZ    PUT1                    DATASET NOT OPEN\n*                                      DATASET WAS OPEN\n         L     R8,ADCB                 LOAD REGISTER FOR ADDRESSING\n         USING IHADCB,R8               DCB AND DECB\n         TM    PG,PG1                  TEST LAST PROCEDURE\n         BO    PUT2                    LAST PROCEDURE WAS GET\n*\n         CHECK DECB                    CHECK THE PREVIOUS WRITE\n*\n         NOTE  (R8)\n*\n         LA    R5,4(,R5)\n         L     R15,IORLST(R12)\n         L     R15,EN(,R15)            R15 -> IHIIOREN\n         BALR  R14,R15                 CLEAR NOTTAB\n         SH    R5,=H'4'\n         B     PUT3\n*\nPUT2     L     R2,NOTEADR              LAST PROCEDURE WAS GET\n         LA    R2,1(,R2)               INCREASE NOTEADR BY ONE\n         ST    R2,NOTEADR\n         LR    R1,R8\n*\n         POINT (1),NOTEADR             REPOSITION DATASET FOR WRITE\n*\n         NI    PG,X'BF'                PG1=0 INDICATE PUT IS EXECUTED\n         B     PUT3\n*\nPUT1     L     R15,AOPENPG             CALL FOR ROUTINE OPEN DATASET\n         BALR  R14,R15\n         L     R8,ADCB\n*\n*        EVALUATE IDENTIFICATION NUMBER FIRST PARAMETER\n*\nPUT3     L     R1,SAVEPG+24            GET CALLERS R1\n         ICM   R2,B'1111',0(R1)        CONVERSION IS NECESSARY ?\n         BP    PUT4                    NO CONVERSION\n         TM    OPTSW(R12),X'20'        CONVERSION TO INTEGER NECS\n         BO    PUT31                   SHORT PRECISION\n         LD    FPR0,0(,R2)             PARAMETER TO FPR0\n         B     PUT31A\n*\nPUT31    LE    FPR0,0(,R2)\nPUT31A   L     R15,IORLST(R12)\n         L     R15,CI(R15)             R15 -> IHIIORCI\n         BALR  R14,R15                 CALL CONVERSION ROUTINE\n         B     PUT4A\n*\nPUT4     L     R0,0(,R2)               PARAMETER TO R0\nPUT4A    LTR   R0,R0\n         BM    ERROR39\n         C     R0,TWOP16               TWOP16= 2**16\n         BNL   ERROR39\n*                                      GET/PUT IDENTIFICATION WITHIN\n*                                      RANGE\n         STH   R0,S                    STORE IDENTIFICATION IN PGCF\n*\n*        TEST IF S ALREADY USED AS IDENTIFICATION NUMBER\n*\n         L     R9,ANOTTAB(R12)\n         LR    R10,R9\nPUTNOT   LA    R10,8(,R10)\n         C     R10,0(,R9)\n         BE    PUT41                   NO ENTRY WITH S FOUND\n         LR    R2,R6\n         CH    R2,0(,R10)\n         BNE   PUTNOT\n         CLC   S(2),2(R10)\n         BNE   PUTNOT\n         MVI   0(R10),X'80'            AN ENTRY FOR S IN NOTTAB\n*                                      INSERT INVALID FLAG\nPUT41    L     R4,BB\n         LA    R4,12(,R4)              INSERT CORRECT CHAR POINTER\n         ST    R4,R\n         MVI   TYP,0                   CLEAR TYP\n*\n         SAVE  (14,12)                 PUT'S REGISTER SAVED IN SAVEPUT\n*\n         L     R13,SAVEPUT+4           RESTORE PROGRAMS REGISTER\n         LM    R14,R12,12(R13)\n         L     R8,4(,R1)               ADDR TO LIST\n*                                      PROCEDURE IN R8\n         USING IHIGPRPT,R15\n         L     R13,SAVEPG+4\n         DROP  R15\n         CNOP  0,4\n         BAL   R15,PROLOG(R13)\n*\n         DC    A(THUNKOUT)\n         DC    X'8880'                 TYPE INFORMATION FOR STAND PROC\n         DC    H'1'\n*\n         USING *,R15\n         LA    R13,SAVEPUT\n         DROP  R15\n         LM    R14,R12,12(R13)         RELOAD PUT'S REGISTER\n         L     R4,R                    RECORD POINTER TO R4\n         S     R4,BB                   R-BB\n         L     R3,BB                   BUFFER BEGIN\n         STH   R4,0(,R3)               BLOCK LENGTH TO BUFFER\n         SH    R4,=H'4'                R-BB-4\n         LA    R3,4(,R3)\n         STH   R4,0(,R3)               RECORD LENGTH OT RECORD IN BUFF\n         MVC   4(2,R3),S               STORE S IN RECORD\n         MVC   6(1,R3),TYP\n         L     R3,BB                   BUFFER BEGIN\n         MVI   RECPG,0                 CLEAR FLAG BIT\n*\n         WRITE DECB,SF,(R8),(R3),MF=E        WRITE BUFFER\n*\n         L     R13,SAVEPUT+4\n         LM    R14,R12,12(R13)\n         USING IHIGPRPT,R15\n         L     R13,SAVEPG+4\n         BR    R14\n*\nSAVEPUT  DC    18F'0'\n*\n         DROP  R15\n*\n***********************************************************************\n*\n*        IHIGPROT - OUTPUT IS ACTUAL PROCEDURE TO LIST\n*        EVALUATED BY THUNKOUT\n*\n***********************************************************************\n*\n*        REGISTER CONTENTS ON ENTRY POINT IHIGPROT\n*\n*        R13                           -> FSA\n*        R15                           -> A THUNKFIELD\n*        R8                            -> ENTRY POINT\n*\n*        REGISTER CONTENTS ON ENTRY POINT OUTPUTTH OUTPUT BUFFER\n*\n*        R15                           -> OUTPUTTH\n*        R8                            -> VALUE TO BE TRANSFERED TO\n*                                         OTHER GENERAL REG\n         CNOP  0,8\n         USING IHIGPROT,R8\n*\nIHIGPROT IHIENTRY 'IHIGPROT LEVEL 2.1 &SYSDATE &SYSTIME',REG=R8\n*\n         ST    R13,SAVEOI+4\n         LA    R13,SAVEOI\n*\n         SAVE  (14,12)\n*\n         ST    R13,SAVOUTP+4\n         DROP  R8\n         LR    R7,R8                   FIXED STORAGE AREA ON ENTRY\n         USING IHIGPROT,R7\n         ST    R13,SAVOUTP+4\n         L     R12,SAVEOI+4            R12 -> FSA\n         LA    R13,SAVOUTP\n         L     R5,ADSTAB(R12)\n         L     R5,0(,R5)               R5 -> PGCF\n         LA    R6,16                   SET DSNR TO 16 FOR SYSUT2\n         USING PGCF,R5                 FOR DSECT ADDRESSING\n         TM    RECOI,X'01'             TEST IF RECURSIVELY\n         BO    ERROR43                 YES\n         OI    RECOI,X'01'             SET FLAG BIT\n         CLI   7(R15),X'01'            TEST NUMBER OF PARAMETER\n         BNE   ERROR21\n         TM    5(R15),X'03'            TEST TYP INFORMATION ABOUT FIRST\n         BZ    ERROR20                 PARAMETER\n         TM    5(R15),X'04'            TEST IF ARRAY\n         BO    ERROR20                 ARRAY\n         TM    5(R15),X'C0'\n         BZ    OUTPUT01                NO\n         TM    5(R15),X'40'\n         BZ    ERROR20                 STANDARD PROC IDENTIFIER\n         TM    4(R15),X'C0'\n         BM    OUTPUT01\n         BZ    OUTPUT01\n         MVI   PARTST,X'01'            SET BIT FOR LATER TEST\nOUTPUT01 TM    TYP,X'FF'               TEST TYP FIELD IN PGCF\n         BZ    OUTPUT1                 NO TYP INFORMATION IN PGCF\n         MVC   TYPC(1),5(R15)          PGCF CONTAIN TYP INFORMATION\n         NI    TYPC,X'03'\n         CLC   TYP(1),TYPC\n         BNE   ERROR20\n         B     OUTPUT2\n*\nOUTPUT1  MVC   TYP(1),5(R15)\n         NI    TYP,X'03'\n*\nOUTPUT2  MVC   ADRTHUNK(4),0(R15)\n*\n         SAVE  (14,12)                 SAVE OUTPUT'S REGISTER IN\n*                                      SAVEOUTP\n         L     R13,SAVOUTP+4           RESTORE CALLING ROUTINES REGS\n         LM    R14,R12,12(R13)\n*\n***********************************************************************\n*\n*        LINKING TO ROUTINE CALLING ACTUAL PARAMETER\n*\n         USING IHIGPROT,R8\n         L     R13,SAVEOI+4\n         CNOP  2,4\n         MVC   *+12(2),8(R10)          MOVE PROGRAM BLOCK NUMBER\n         BAL   R15,CAP1GP\n         DROP  R8\n         USING *,R15\n*\n         DC    H'0'\n         DC    H'0'\n         NOP   0\n*\nOUTPUTTH LA    R13,SAVOUTP\n         DROP  R15\n         LM    R14,R7,12(R13)          RESTORE OUTPUT'S REGISTER\n         LM    R9,R12,56(R13)          EXCEPT R8\n         B     OUTPUTAA                BRANCH OVER SAVEAREA\n*\nSAVOUTP  DC    18F'0'\n*\n***********************************************************************\n*\nOUTPUTAA TM    PARTST,X'01'\n         BZ    OUTPUT25\n         LA    R2,FCTVALST(R12)\n         CR    R2,R8\n         BNE   ERROR20\n         MVI   PARTST,X'00'\nOUTPUT25 SR    R9,R9\n         TM    TYP,X'03'\n         BM    OUTPUT3\n         LA    R9,1(,R9)               BOOLEAN VALUE\n         B     OUTPUT5\n*\nOUTPUT3  TM    TYP,X'01'\n         BZ    OUTPUT4\nOUTPUT3A LA    R9,4(,R9)               INTEGER VALUE\n         B     OUTPUT5\n*\nOUTPUT4  TM    OPTSW(R12),X'20'        REAL VALUE TEST IF LONG/SHORT\n         BO    OUTPUT3A                SHORT\n         LA    R9,8(,R9)               LONG\n*\nOUTPUT5  L     R4,R                    INSERT VALUE TO RECORD BUFFER\n         LR    R2,R4\n         AR    R2,R9\n         C     R2,BE\n         BH    ERROR38\nOUTPUT51 BCTR  R9,0\n         EX    R9,OUTINMOV\n         LA    R9,1(,R9)\n         AR    R4,R9                   INCREASE CHARACTER POINTER\n         ST    R4,R\n         MVI   RECOI,X'00'             CLEAR FLAG BIT\n         L     R13,SAVOUTP+4           RESTORE CALLING ROUTINES REGS\n         LM    R14,R12,12(R13)\n         USING IHIGPROT,R8\n         L     R13,SAVEOI+4\n         DROP  R8\n         B     8(,R15)\n*\n*        THUNK OUT\n*\n*        LIST PROCEDURE INVOKE CALL ACTUAL PARAMETER IN IHIFSA\n*        AND THIS CALL THUNKOUT, WHICH ASSIGNS OUTPUT AS ACTUAL\n*        PROCEDURE TO LIST\n*\nPBT      EQU   11                      REGISTER\nLAT      EQU   12\nFSB      EQU   13                      ADDRESS OF FIXED STORAGE AREA\n*\n*        DISPLACEMENT IN FSA\n*\n         CNOP  2,4\nTHUNKOUT BALR  R15,0\n         L     R8,8(,R15)\n         B     12(R15)\n*\n         DC    A(IHIGPROT)             INFORMATION CHARACTERISE OUTPUT\n*\n         MVI   PROLPBN(FSB),X'00'\n         STM   PBT,LAT,PROLREG(FSB)\n         B     CAP2(0,FSB)\n*\n***********************************************************************\n*\n*        IHIGPRGT - GET ROUTINE\n*\n***********************************************************************\n*\n*        REGISTER CONTENTS ON ENTRY POINT IHIGPRGT\n*\n*        R15                           -> ENTRY POINT\n*        R14                           -> RETURN\n*        R13                           -> SAVE AREA IN FSA\n*        R1                            -> PARAMETER LIST\n*\n         USING *,R15\n*\nIHIGPRGT IHIENTRY 'IHIGPRGT LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         ST    R13,SAVEPG+4\n         LA    R13,SAVEPG\n*\n         SAVE  (14,12)\n*\n         DROP  R15\n         LR    R7,R15\n         USING IHIGPRGT,R7\n         L     R12,SAVEPG+4            ADDR OF FIXED ST AREA\n         ST    R13,SAVEGET+4\n         LA    R13,SAVEGET\n         L     R5,ADSTAB(R12)          FIRST ENTRY IN DSTAB IS APGCF\n         L     R5,0(,R5)               R5 -> PGCF TO\n         LA    R6,16                   SET DSNR TO 16 FOR SYSUT2\n         USING PGCF,R5\n         TM    RECPG,X'01'             TEST IF RECURSIVELY\n         BO    ERROR43                 YES\n         OI    RECPG,X'01'             SET FLAG BIT\n         TM    PG,PG0                  DATASET OPEN ?\n         BZ    ERROR10                 DATASET NOT OPEN\n         L     R8,ADCB                 LOAD REGISTER FOR ADDRESSING\n         USING IHADCB,R8               DCB AND DECB\n         TM    PG,PG1                  TEST LAST PROCEDURE\n         BO    GET1                    LAST PROCEDURE WAS GET\n*\n         CHECK DECB                    CHECK THE PREVIOUS WRITE\n*\n         NOTE  (R8)\n*\n         ST    R1,NOTEADR              INFORMATION ABOUT THE LAST\n*                                      RECORD WRITTEN TO PGCF TO\n*                                      HAVE FOR A LATER PUT\n*                                      WHERE TO CONTINUE DATASET\n         OI    PG,PG1                  PG1=1 INDICATING GET IS EXECUTED\n         LA    R5,4(,R5)\n         L     R15,IORLST(R12)\n         L     R15,EN(R15)             R15 -> IHIIOREN\n         BALR  R14,R15                 CLEAR NOTTAB\n         SH    R5,=H'4'                RESTORE PGCF ADDR\n*\n*        EVALUATE IDENTIFICATION NUMBER FIRST PARAMETER\n*\nGET1     L     R1,SAVEPG+24            GET CALLERS R1\n         ICM   R2,B'1111',0(R1)        CONVERSION REQUIRED ?\n         BP    GET2                    NO CONVERSION\n         TM    OPTSW(R12),X'20'        CONVERSION TO INTEGER NECESSARY?\n         BO    GET11                   SHORT PROCSISION\n         LD    FPR0,0(,R2)             LONG\n         B     GET11A                  PARAMETER TO FPR0\n*\nGET11    LE    FPR0,0(,R2)\nGET11A   L     R15,IORLST(R12)\n         L     R15,CI(R15)\n         BALR  R14,R15                 CALL CONVERSION ROUTINE\n         B     GET2A\n*\nGET2     L     R0,0(,R2)\nGET2A    LTR   R0,R0                   IDENTIFICATION NUMBERS IN R0\n         BM    ERROR39\n         C     R0,TWOP16\n         BNL   ERROR39\n         STH   R0,S                    GET/PUT IDENT WITHIN RANGE\n         L     R4,BB\n         LA    R4,12(,R4)              INSERT CORRECT CHARACTER POINTER\n         ST    R4,R\n*\n*        EXAMINE NOTTAB TO FIND AN ENTRY FOR S\n*\nGET12    L     R9,ANOTTAB(R12)         R9 -> NOTTAB\n         LR    R10,R9                  COPY TO R10\nGET3     LA    R10,8(,R10)             INCR ADDR BY RIGHT\n         C     R10,0(,R9)              COMPARE WITH NXE\n         BE    ERROR14                 NO ENTRY FOR S FIND IN NOTTAB\n         LR    R2,R6                   DATASET NUMBER TO R2\n         CH    R2,0(,R10)              DATASET NUMBER = 16 ?\n         BNE   GET3                    DATASET NUMBER \u00ac= 16 LOOP\n         CLC   S(2),2(R10)             S IS EQUAL IN NOTTABENTRY ?\n         BNE   GET3                    NO, NEXT ENTRY IN NOTTAB\n*                                      FOUND AN ENTRY IN NOTTAB FOR S\n         LA    R0,4(,R10)              ADDR OF NOTE INFORMATION\n         LR    R1,R8                   DCB ADDR TO R1\n*\n         POINT (1),(0)\n*\n         L     R3,BB\n*\n         READ  DECB,SF,(R8),(R3),MF=E  READ A BLOCK TO BUFFER\n*\n         CHECK DECB                    CHECK THIS READ\n*\n         CLC   8(2,R3),S               TEST IDENTIFICATION NUMBER\n         BNE   ERROR14\n         MVC   TYP(1),10(R3)           TYP INFORMATION TO PGCF\n         AH    R3,0(,R3)               BB+BL\n         ST    R3,RE                   EFFECTIVE END OF RECORD CURRENT\n         L     R1,SAVEPG+24\n         L     R13,SAVEGET+4           RESTORE PROGRAMS REGISTER\n         LM    R14,R12,12(R13)\n         L     R8,4(,R1)               ADDR OF LIST PROCEDURE\n         USING IHIGPRGT,R15\n         L     R13,SAVEPG+4\n         DROP  R15\n         CNOP  0,4\n         BAL   R15,PROLOG(R13)\n*\n         DC    A(THUNKIN)\n         DC    X'8880'                 TYP INFORMATION FOR STANDARD\n*                                      PROCEDURE\n         DC    H'1'\n*\n         USING *,R15\n         LA    R13,SAVEPG\n         LM    R14,R12,12(R13)\n         USING IHIGPRGT,R15\n         L     R13,SAVEPG+4\n         MVI   RECPG,X'00'             CLEAR FLAG BIT\n         BR    R14\n*\nSAVEGET  DC    18F'0'\n         DROP  R15\n*\n***********************************************************************\n*\n*        IHIGPRIT - INPUT IS ACTUAL PROCEDURE TO LIST\n*        EVALUATED BY THUNKIN\n*\n***********************************************************************\n*\n*        REGISTER CONTENTS ON ENTRY POINT IHIGPRIT\n*\n*        R13                           R13 -> FSA\n*        R8                            R8 -> ENTRY POINT IHIGPRIT\n*        R15                           R15 -> A THUNKFIELD\n*\n*        REGISTER CONTENTS ON ENTRY POINT INPUTTH\n*\n*        R15                           -> INPUTTH\n*        R8                            -> PARAMETER WHERE TO\n*                                         STORE VALUE FROM BUFFER\n         USING IHIGPRIT,R8\n*\nIHIGPRIT IHIENTRY 'IHIGPRIT LEVEL 2.1 &SYSDATE &SYSTIME',REG=R8\n*\n         ST    R13,SAVEOI+4\n         LA    R13,SAVEOI\n*\n         SAVE  (14,12)\n*\n         ST    R13,SAVEIN+4\n         LR    R7,R8                   FIXED STORAGE AREA ON ENTRY\n         DROP  R8\n         USING IHIGPRIT,R7\n         L     R12,SAVEOI+4\n         LA    R13,SAVEIN\n         L     R5,ADSTAB(R12)\n         L     R5,0(,R5)               R5 -> PGCF\n         LA    R6,16                   DSNR = 16 FOR SYSUT2\n         USING PGCF,R5                 DSECT ADDRESSABILITY\n         TM    RECOI,X'01'             TEST IF RECURSIVELY\n         BO    ERROR43                 YES\n         OI    RECOI,X'01'             SET FLAG BIT\n         CLI   7(R15),X'01'            TEST NUMBER OF PARAMETERS\n         BNE   ERROR21                 NUMBER DOES NOT CORRESPOND\n*                                      BETWEEN DECLARATION AND CALL\n         TM    4(R15),X'08'            ASSIGNMENT POSSIBLE ?\n         BO    ERROR20\n         MVC   TYPC(1),5(R15)\n         NI    TYPC,X'03'\n         CLC   TYP(1),TYPC\n         BNE   ERROR20                 PGCF\n*\n***********************************************************************\n*\n*        LINKING TO ROUTINE CALLING ACTUAL PARAMETER\n*\n         SAVE  (14,12)                 SAVE REGISTER IN SAVEIN\n*\n         L     R13,SAVEIN+4\n         MVC   ADRTHUNK(4),0(R15)\n         LM    R14,R12,12(R13)         RESTORE PROGRAMS REGISTER\n         USING IHIGPRIT,R8\n         L     R13,SAVEOI+4\n         CNOP  2,4\n         MVC   *+12(2),8(R10)          MOVE PROGRAM BLOCK NUMBER\n         BAL   R15,CAP1GP\n         DROP  R8\n         USING *,R15\n*\n         DC    H'0'\n         DC    H'0'\n         NOP   0\n*\nINPUTTH  LA    R13,SAVEIN\n         DROP  R15\n         LM    R14,R7,12(R13)          RESTORE INPUT'S REGISTER EXCEPT\n         LM    R9,R12,56(R13)          R8\n         B     INPUTTAA                BRANCH OVER SAVEAREA\n*\nSAVEIN   DC    18F'0'\n*\n*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n*\nINPUTTAA L     R3,BB\n         AH    R3,0(,R3)\n         C     R3,R\n         BNH   ERROR38                 BUFFER OVERFLOW\n         SR    R9,R9\n         TM    TYP,X'03'\n         BM    INPUT1\n         LA    R9,1(,R9)               BOOLEAN VALUE\n         B     INPUT3\n*\nINPUT1   TM    TYP,X'01'\n         BZ    INPUT2\nINPUT1AA LA    R9,4(,R9)               INTEGER VALUE\n         B     INPUT3\n*\nINPUT2   TM    OPTSW(R12),X'20'        REAL VALUE TEST IF LONG/SHORT\n         BO    INPUT1AA                SHORT\n         LA    R9,8(,R9)               LONG\n*\nINPUT3   L     R4,R\nINPUT31  BCTR  R9,0\n         EX    R9,INOUTMOV\n         LA    R9,1(,R9)\n         AR    R4,R9                   INCREASE CHARACTER POINTER\n         ST    R4,R\n         MVI   RECOI,0                 CLEAR FLAG BIT\n         L     R13,SAVEIN+4\n         LM    R14,R12,12(R13)\n         USING IHIGPRIT,R8\n         L     R13,SAVEOI+4\n         DROP  R8\n         B     8(,R15)\n*\n*        THUNK IN\n*\n*        LIST PROCEDURE INVOKE CALL ACTUAL PARAMETER IN IHGFSA\n*        AND THIS CALL THUNKIN, WHICH ASSIGN INPUT AS ACTUAL\n*        PROCEDURE TO LIST\n*\n         CNOP  2,4\nTHUNKIN  BALR  R15,0\n         L     R8,8(,R15)\n         B     12(,R15)\n*\n         DC    A(IHIGPRIT)             INFORMATION CHARACTERISE OUTPUT\n*\n         MVI   PROLPBN(FSB),X'00'\n         STM   PBT,LAT,PROLREG(FSB)\n         B     CAP2(,FSB)\n*\n*        OPEN DATASET SYSUT2\n*\n*        RESERVE MAIN FOR ONE DCB AND ONE DECB, ONE I/O BUFFER\n*        AND FOR NOTTAB IF NOT CREATED BEFORE\n*\nIHIGPROP SAVE  (14,12),,'IHIGPROP LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LR    R7,R15\n         USING IHIGPROP,R7\n         USING IHADCB,R8\n         ST    R13,SAVEOP+4\n         LA    R13,SAVEOP\n         LA    R2,IHIGPRCL\n         L     R9,IORLST(R12)\n         L     R9,GP(,R9)\n         ST    R2,0(,R9)\n         ICM   R2,B'1111',ANOTTAB(R12)  NOTTAB ALREADY GETMAINED ?\n         BP    OPGP1                   YES, BRANCH\n         LA    R0,1024\n*\n         GETMAIN R,LV=(0)              GET AREA FOR NOTTAB\n*\n         ST    R1,ANOTTAB(R12)         SAVE GETMAINED AREA ADDR\n         LR    R2,R1                   ANOTTAB TO R2\n         LR    R9,R1                   ANOTTAB TO R9\n         LA    R9,8(,R9)\n         ST    R9,0(,R2)               STORE POINTER NXE IN NOTTAB\n         LA    R9,1016(,R9)\n         ST    R9,4(,R2)               STORE POINTER NXEF IN NOTTAB\n*\nOPGP1    LA    R0,DCBAREAL             GET AREA FOR DCB AND DECB\n*\n         GETMAIN R,LV=(0)\n*\n         ST    R1,ADCB\n         LR    R8,R1\n*\n*        TRANSFER DCBMODEL\n*\n         MVC   0(DCBMODLN,R8),DCBMODEL\n         L     R1,IORLST(,R12)          INSERT SYNAD\n         L     R1,ER(,R1)               ADDR TO\n         ST    R1,DCBSYNAD              IHIIORER\n*\n         OPEN  ((R8),(OUTIN))           OPEN DATASET\n*\n         TM    DCBOFLGS,DCBOFOPN        OPEN SUCCESSFUL ?\n         BO    OPGP2                    YES, BRANCH\n         LR    R13,R12                  OPEN FAILED\n         B     FSAERR+41*4(R12)\n*\nOPGP2    L     R0,BE                    BE=BUFFER LENGTH\n*\n         GETMAIN R,LV=(0)               GET AREA FOR RECORD BUFFER\n*\n         ST    R1,BB\n         A     R1,BE                    BB+BE TO BE\n         ST    R1,BE                    BE DEFINE BUFFER END\n         OI    PG,PG0                   PG0=1 DATASET OPEN\n         L     R13,SAVEOP+4\n*\n         RETURN (14,12)\n*\n*        OPEN EXIT ROUTINE\n*\nIHIGPRDX LH    R2,DCBBLKSI             DCBBLKSI = 0 ?\n         LTR   R2,R2\n         BZ    EXIT1                   BLKSIZE = 0\n         ST    R2,BE                   BLKSIZE NOT ZERO\n         B     EXIT1+8\n*\nEXIT1    L     R2,BE                   BE=2048 TO BLKSIZE\n         STH   R2,DCBBLKSI\n*\n         RETURN\n*\n*        CLOSE DATASET SYSUT2\n*\n*        RELEASE DCB, DECB AND I/O BUFFER\n*        CALLED FROM IHGIOR - CLOSEPE\n*\nIHIGPRCL SAVE  (14,12),,'IHIGPRCL LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LR    R7,R15\n         USING IHIGPRCL,R7\n         ST    R13,SAVEOP+4\n         LA    R13,SAVEOP\n         L     R5,ADSTAB(,R12)\n         L     R5,0(,R5)\n         LA    R6,16\n         L     R8,ADCB\n*\n         CLOSE ((R8))\n*\n         L     R1,BB                   BUFFER BEGIN ADDR TO R1\n         L     R0,BE\n         SR    R0,R1                   BUFFER LENGTH TO R0\n*\n*        FREEMAIN FOR RECORD BUFFER\n*\n         FREEMAIN  R,LV=(0),A=(1)\n*\n*        FREEMAIN FOR DCB AND DECB\n*\n         FREEMAIN  R,LV=DCBAREAL,A=ADCB\n*\n         L     R13,SAVEOP+4\n*\n         RETURN (14,12)\n*\nRECPG    DC    X'00'\nRECOI    DC    X'00'\nTYPC     DC    X'00'\nPARTST   DC    X'00'\nSAVEPG   DC    18F'0'\nSAVEOI   DC    18F'0'\nSAVEOP   DC    18F'0'\n*\nDCBMODEL DCB   DSORG=PS,MACRF=(RP,WP),DDNAME=SYSUT2,RECFM=V,NCP=1,     X\n               EXLST=ADCBEXIT\nDCBMODLN EQU   *-DCBMODEL              L'DCB\n*\n         DC    0F'0'\nADCBEXIT DC    X'85'\n         DC    AL3(IHIGPRDX)\n*\n*        EXTERNAL ADDRESSES\n*\nAOPENPG  DC    A(IHIGPROP)\n*\n*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n*                                                                    *\n*        THIS ROUTINE IS USED INSTEAD OF CAP1 IN FSA                 *\n*                                                                    *\n*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n*\nCAP1GP   BALR  R8,0\n         USING *,R8\n         L     R3,RASPT(FSB)\n         LA    R3,8(R3)\n         C     R3,RASPB(FSB)\n         BNL   ERROR36                 RASOVERFLOW\n         ST    R10,0(,R3)\n         ST    R15,4(,R3)\n         ST    R3,RASPT(FSB)\n         L     R8,ADRTHUNK\n         DROP  R8\n         BR    R8                      TO THUNK ROUTINE\n*\nTWOP16   DC    F'65536'                2**16\nADRTHUNK DC    A(0)\n*\n         LTORG\n*\nOUTINMOV MVC   0(1,R4),0(R8)\nINOUTMOV MVC   0(1,R8),0(R4)\n*                                      DATASET CLOSED\nERROR10  LR    R13,R12                 ADDR OF FSA TO R13\n         B     FSAERR+10*4(R12)\n*\nERROR14  LR    R13,R12                 ADDR OF FSA TO R13\n*                                      NO ENTRY IN NOTTAB IE BACK-\n         B     FSAERR+14*4(R12)        WARD REPOSITIONING NOT DEFINED\n*\nERROR20  LR    R13,R12                 ADDR OF FSA TO R13\n*                                      DIFFERENT TYPE OR KIND OF\n         B     FSAERR+20*4(R12)        PARAMETER AT ACTUAL AND FORMAL\n*\nERROR21  LR    R13,R12                 ADDR OF FSA TO R13\n*                                      NUMBER OF PARAMETERS DOES NOT\n         B     FSAERR+21*4(R12)        CORRESPOND BETWEEN DECLARATION\n*                                      AND CALL\n*                                      TOO MANY NESTED BLOCKS, PROCS\nERROR36  LR    R13,R12                 AND PARAMETER CALLS. INTERNAL\n         B     FSAERR+36*4(R12)        (RETURN ADDRESS STACK) OVERFLOW\n*\nERROR38  LR    R13,R12                 ADDR OF FSA TO R13\n         B     FSAERR+38*4(R12)        GET/PUT BUFFER OVERFLOW\n*\nERROR39  LR    R13,R12                 ADDRESS OF FSA TO R13\n*                                      GET/PUT IDENTIFICATION OUT OF\n         B     FSAERR+39*4(R12)        RANGE\n*\n*\nERROR43  LR    R13,R12                 RECURSIVELY USE OF PUT/GET\n         B     FSAERR+43*4(R12)        OUTPUT/INPUT\n*\nPGCF     DSECT\nADCB     DS    A\nR        DS    A\nRE       DS    A\nBB       DS    A\nBE       DS    A\nNOTEADR  DS    A\nS        DS    H\nTYP      DS    C\nPG       DS    C\n*\n*        MAP DCB\n*\n         PRINT NOGEN\n*\n         DCBD  DSORG=BS,DEVD=(DA)\n*\n         PRINT GEN\n*\n*        MAP DECB\n*\n         READ  DECB,SF,MF=L\n*\nDCBAREAL EQU   *-IHADCB                 L'I/O CONTROL BLOCKS\n*\nFSAAREA  DSECT\n         COPY  FSAREA\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIIAR   0201-12230-12230-1200-00102-00102-00000-LEVEL\nIAR      TITLE 'IHIIARTN, INARRAY AND INTARRAY, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        ASSIGN NUMBERS TO ARRAY INDICATED BY SECOND ACTUAL\n*        PARAMETER BY CALLING INREAL OR ININTEGER REPEATEDLY\n*\n*        ENTRY POINTS -\n*        IHIIARRY - FROM GENERATED OBJECT MODULE\n*                   INARRAY  LA R1,PARMLIST\n*        IHIIARRT - FROM GENERATED OBJECT MODULE\n*                   INTARRAY BALR R14,R15\n*        DATA PASSED BY NAME\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES -\n*        IHIIOR - EVALUATE DATA SET NUMBER\n*        IHIIDE - INREAL OR ININTEGER\n*\n*        EXIT - NORMAL - RELOAD REGISTERS AND RETURN VIA R14\n*\n*        EXIT - ERROR - N/A\n*\n*        TABLES/WORK AREAS - N/A\n*\n*        R1                            -> PARAMETER LIST\n*        R7                            TRANSFER DESTADR\n*        R10                           TRANSFER FLAGBYTE\n*        R12                           -> FSA\n*\nIHIIARTN CSECT\n*\n         ENTRY IHIIARRT\n         ENTRY IHIIARRY\n*\nIHIIARRT SAVE  (14,12),,'IHIIARRT LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHIIARRT,R15\n         LR    R12,R13                 R12 -> FSA\n         LA    R9,IHIIARRY             R9 -> IHGIARRY\n         DROP  R15\n         USING IHIIARRY,R9\n         LA    R13,ASAVE(,R13)         R13 -> SECOND SAVEAREA IN FSA\n         LA    R10,4                   FLAGBYTE INTARRAY\n         B     INAR1\n*\nIHIIARRY SAVE  (14,12),,'IHIIARRY LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LR    R9,R15\n         LR    R12,R13                 R12 -> FSA\n         LA    R13,ASAVE(,R13)         R13 -> SECOND SAVEAREA IN FSA\n         SR    R10,R10                 FLAGBYTE INARRAY\n*\n*        EVALUATE DATASET NUMBER\n*\nINAR1    L     R15,VIOREV\n         BALR  R14,R15\n*\n*        EVALUATE DEST ADDRS\n*\n         L     R1,4(,R1)               R1 -> SECOND PARAMETER\n         L     R8,12(,R1)              R8 -> DESTEND+1\n         L     R7,8(,R1)               R7 -> STARTDEST\n*\n*        CALL ROUTINE INREAL - ININTEGER\n*\nINAR2    L     R15,VIDEAI              R15 -> IHIIDEAI\n         BALR  R14,R15                 CALL IHIIDEAI\n         LTR   R10,R10\n         BP    INAR3\n         TM    OPTSW(R12),X'20'        LONG OR SHORT PREC ?\n         BO    INAR3\n         LA    R7,8(,R7)               INCREASE  DEST ADDR INARRAY\n         B     INAR3A\n*\nINAR3    LA    R7,4(,R7)               INCREASE  DEST ADDR INTARRAY\nINAR3A   CR    R7,R8\n         BL    INAR2\n         LR    R13,R12\n*\n         RETURN (14,12)                RESTORE REGS AND RETURN\n*\n*        EXTERNAL ADDRS\n*\nVIOREV   DC    V(IHIIOREV)\nVIDEAI   DC    V(IHIIDEAI)\n*\nFAS      DSECT\n*\n         COPY  FSAREA\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIIBA   0201-12230-12230-1200-00078-00078-00000-LEVEL\nIBA       TITLE 'IHIIBARR, INBARRAY, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        ASSIGN BOOLEAN VALUE TO ARRAY INDICATED BY SECOND ACTUAL\n*        PARAMETER BY CALLING INBOOLEAN REPEATEDLY\n*\n*        ENTRY POINT -\n*        IHIIBARR - FROM GENERATED OBJECT MODULE\n*                   LA   R1,PARMLIST\n*                   BALR R14,R15\n*                   DATA PASSED BY NAME\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES -\n*        IHIIOR - EVALUATE DATA SET NUMBER\n*        IHIIBO - INBOOLEAN\n*\n*        EXIT - NORMAL - RELOAD REGISTERS AND RETURN VIA R14\n*\n*        EXIT - ERROR - N/A\n*\n*        TABLES/WORK AREAS - N/A\n*\nIHIIBARR CSECT\n*\n*        R1                            -> PARAMETER LIST\n*        R12   12                      -> FSA\n*\n         SAVE  (14,12),,'IHIIBARR LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LR    R7,R15\n         USING IHIIBARR,R7\n         LR    R12,R13                 R12 -> FSA\n         LA    R13,ASAVE(,R13)         R13 -> SECOND SAVEAREA IN FSA\n*\n*        EVALUTE DATASET NUMBER\n*\n         L     R15,VIOREV\n         BALR  R14,R15\n*\n*        EVALUTE DESTINATION ADDR\n*\n         L     R1,4(,R1)\n         L     R3,12(,R1)              R3 -> DESTEND+1\n         L     R2,8(,R1)               R2 -> START DEST\n*\n*        CALL FOR ROUTINE INBOOLEAN\n*\nINBARRY1 L     R15,VIBOAR\n         BALR  R14,R15\n         LA    R2,1(,R2)               INCR ADEST\n         CR    R2,R3\n         BL    INBARRY1                MORE VALUE TO BE READ\n         LR    R13,R12\n*\n         RETURN (14,12)\n*\n*        EXTERNAL ADDRS\n*\nVIOREV   DC    V(IHIIOREV)             EVALUATE DATASET NUMBER\nVIBOAR   DC    V(IHIIBOAR)             INBOOLEAN\n*\nFAS      DSECT\n*\n         COPY  FSAREA\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIIBO   0201-12230-12230-1200-00238-00238-00000-LEVEL\nBOO      TITLE 'IHIIBOOL, INBOOLEAN, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        SCAN INPUT BUFFER UNTIL A BOOLEAN VALUE IS FOUND\n*        TRANSFER IF 'TRUE' 1 IF 'FALSE' 0 TO BOOLEAN IDENTIFIER,\n*        THE SECOND PARAMETER\n*\n*        ENTRY POINTS -\n*        IHIIBOOL - FROM GENERATED OBJECT MODULE\n*                   LA   R1,PARMLIST\n*                   BALR R14,R15\n*                   DATA PASSED BY NAME\n*        IHIIBOAR - FROM ARRAY MODULE IHIIBA\n*                   L    R2,A(DESTINATION)\n*                   BALR R14,R15\n*                   DATA PASSED BY NAME\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES -\n*        IHIIOR - EVALUATE DATASET NUMBER\n*               - OPEN DATA SET\n*               - CHANGE TO NEXT INPUT RECORD\n*\n*        EXITS - NORMAL - RELOAD REGISTERS AND EXIT VIA R14\n*\n*        EXITS - ERROR - INPUT REQUEST BEYOND END OF DATASET\n*                        BRANCH TO IHIFSA\n*                        L      R13,IHIFSA\n*                        B      FSAERR+XX*4(R13) XX ERROR NO 5\n*\n*        TABLES/WORK AREAS - N/A\n*\nIHIIBOOL CSECT\n*\n         ENTRY IHIIBOAR\n         USING DSTABLE,R5\n*\n*        R5                            -> DSTABLE ENTRY\n*        R6                            =  DATASET NUMBER\n*\n*        DISPLACEMENTS IN ADRLST IN IHIFSA\n*\nCI       EQU   0             DISPLACEMENT FOR - IHIIORCI\nCL       EQU   4                                IHIIORCL\nEV       EQU   8                                IHIIOREV\nNX       EQU   12                               IHIIORNX\nOP       EQU   16                               IHIIOROP\nOQ       EQU   20                               IHIIOROQ\n*\n         SAVE  (14,12),,'IHIIBOOL LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHIIBOOL,R15\n         LA    R7,COMMON\n         DROP  R15\n         USING COMMON,R7\n         LR    R12,R13                 R12 -> FSA\n         ST    R13,SAVEAREA+4          CHAIN SAVE AREAS\n         LA    R13,SAVEAREA\n         ST    R13,8(,R12)\n*\n*        EVALUATE DATA SET NUMBER\n*\n         L     R15,IORLST(,R12)\n         L     R15,EV(,R15)\n         BALR  R14,R15\n         B     INBOOL1\n*\n         DROP  R7\n*\nIHIIBOAR SAVE  (14,12),,'IHIIBOAR LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHIIBOAR,R15\n         LA    R7,COMMON\n         DROP  R15\n         USING COMMON,R7\n         LR    R12,R13                 R12 -> FSA\n         ST    R13,SAVEAREA+4          CHAIN SAVE AREAS\n         LA    R13,SAVEAREA\n         ST    R13,8(,R12)\n         ST    R2,ADEST                STORE DESTINATION ADDR\n         B     INBOOLOP\n*\nCOMMON   EQU   *                       COMMON CODE POINT\nINBOOL1  L     R1,4(,R1)\n         ST    R1,ADEST\nINBOOLOP NI    DSF+1,255-DS10          SET DS10 = 0\n         TM    Q,X'FF'                 DATASET SECTIONED ?\n         BNZ   ERROR2                  INCOMPATIBLE ACTION ON DATASET\n         CH    R6,=H'1'                DATASET NUMBER 1?\n         BE    ERROR2                  INCOMPATIBLE ACTION ON DATASET\n         TM    DSF,DS0                 DATASET OPEN ?\n         BO    INBOOL2                 YES, BRANCH\n         NI    DSF,255-DS6             NO, SET DS6 TO 0\n         L     R15,IORLST(,R12)\n         L     R15,OP(,R15)\n         BALR  R14,R15                 CALL OPEN ROUTINE\n         B     INBOOL3\n*\nINBOOL2  TM    DSF,DS2                 LAST I/O OUTPUT ?\n         BO    ERROR3                  INPUT BEYOND LAST OUTPUT\n         TM    DSF,DS6                 DS OPEN FOR OUTPUT ?\n         BZ    INBOOL3                 NO, BRANCH\n         TM    DSF,DS7                 EOD REACHED ?\n         BO    ERROR5                  YES, BRANCH\n         B     ERROR2\n*\nINBOOL3  L     R8,R                    CHARACTER POINTER IN R8\n         BCTR  R8,0                    DECR CHARACTER PTR\n         ST    R8,R\nINBOOL4  MVI   FLAGS,0                 CLEAR FLAG BYTE\nINBOOL5  LA    R10,MB                  MANTISSA BUFFER POINTER\n         SR    R9,R9                   BLANK COUNTER CLEARED\n         TM    DSF,DS7                 INPUT REQ BEYOND END OF DATA ?\n         BO    ERROR5                  YES, BRANCH\nINBOOL6  L     R3,RE\n         BCTR  R3,0\n         L     R8,R\n         CR    R8,R3\n         BNE   INBOOL7\n         L     R15,IORLST(,R12)        RECORD END IS REACHED\n         L     R15,NX(,R15)\n         BALR  R14,R15                 CALL NEXTREC ROUTINE\n         B     INBOOL3                 LOOP BACK\n*\nINBOOL7  LA    R8,1(,R8)               INCR R\n         ST    R8,R                    SAVE R\n         CLI   0(R8),C''''             QUOTE FOUND ?\n         BE    INBOOL9                 YES, BRANCH\n         TM    FLAGS,X'FF'\n         BZ    INBOOL6                 NO QUOTE READ NEXT CHARACTER\n         CLI   0(R8),C' '              QUOTE READ ALREADY ?\n         BNE   INBOOL8                 CHARACTER IS NOT BLANK\n         LA    R9,1(,R9)               CHARACTER IS BLANK INCR COUNTER\n         SR    R4,R4\n         IC    R4,K                    TEST IF BLANK DELIMITERS DENOTE\n         CR    R4,R9                   BY K IS ALREADY FOUND\n         BE    INBOOL4                 NEW SCAN LOOP K DELIMT FOUND\n         BNE   INBOOL6                 K DELIMITERS NOT FOUND\nINBOOL8  SR    R9,R9                   CLEAR BLANK COUNTER\n         LA    R11,MB+5                END OF BUFFER ADDR\n         CR    R10,R11\n         BNL   INBOOL4                 NO VALID BOOLEAN VALUE FOUND\n*                                      NEW SCAN LOOP\n         MVC   0(1,R10),0(R8)          INSERT FOUND CHAR TO BUFFER\n         LA    R10,1(,R10)             INCR R10\n         B     INBOOL6                 EXAMINE NEXT CHARACTER\n*\nINBOOL9  SR    R9,R9\n         TM    FLAGS,X'FF'\n         BNZ   INBOOL10                QUOTE ALREADY FOUND\n         OI    FLAGS,X'01'             FIRST QUOTE, SET FLAGS\n         B     INBOOL6\n*\nINBOOL10 LA    R11,MB+4                FOUR CHARACTERS READ ?\n         CR    R10,R11\n         BL    INBOOL5\n         BH    INBOOL11\n         CLC   MB(L'KTRUE),KTRUE       TRUE ?\n         BNE   INBOOL5                 NO, INVALID BOOLEAN VALUE FOUND\n         L     R2,ADEST                YES, BOOLEAN VALUE TRUE FOUND\n         MVI   0(R2),X'01'             CHARACTER TO DESTINATION\n         B     INBOOL12\n*\nINBOOL11 CLC   MB(L'KFALSE),KFALSE     FALSE ?\n         BNE   INBOOL5                 NO, INVALID BOOLEAN VALUE FOUND\n         L     R2,ADEST                YES, BOOLEAN VALUE FALSE FOUND\n         MVI   0(R2),X'00'             CHARACTER TO DESTINATION\n*\n*        RECOGNITION OF THE LAST DELIMITING CHARACTER\n*\nINBOOL12 SR    R9,R9\n         SR    R1,R1\nINBOOL13 LA    R8,1(,R8)               INCREASE CHARACTER POINTER\n         C     R8,RE\n         BNL   INBOOLNX                NEXT RECORD\n         CLI   0(R8),C' '\n         BNE   INBOOL14                CHARACTER IS NOT BLANK\n         LA    R9,1(,R9)               CHARACTER IS BLANK  INCREASE R9\n         SR    R4,R4                   TEST IF BLANK DELIMITERS DENOTE\n         IC    R4,K                    BY K IS ALREADY FOUND\n         CR    R4,R9\n         BNE   INBOOL13                NOT K BLANK DELIMITERS READ\n         LA    R1,1(,R1)               K BLANK DELIMITERS READ\n         B     INBOOL13\n*\nINBOOL14 LTR   R1,R1                   CHARACTER NOT EQUAL BLANK FOUND\n         BP    INBOOLAA                K OR MORE BLANKS FOUND\n         LA    R8,1(,R8)               < K BLANKS FOUND\nINBOOLAA C     R8,RE\n         BE    INBOOLNX                RECORD END REACHED\n         ST    R8,R                    STORE R TO DSTAB\nINBOOLEX L     R13,SAVEAREA+4\n*\n         RETURN (14,12)                RESTORE CALLERS REGS AND RETURN\n*\nINBOOLNX L     R15,IORLST(,R12)        CALL NEXTREC ROUTINE\n         L     R15,NX(,R15)\n         BALR  R14,R15\n         B     INBOOLEX\n*\nERROR2   LR    R13,R12\n         B     FSAERR+2*4(R13)         INCOMP ACTION ON DATASET\n*\nERROR3   LR    R13,R12\n         B     FSAERR+3*4(R13)         INPUT BEYOND LAST OUTPUT\n*\nERROR5   LR    R13,R12                 INPUT REQUEST BEYOND END OF\n         B     FSAERR+5*4(R13)         DATA SET\n*\nFLAGS    DC    X'00'                   FLAG BYTE FOR APOSTROPHE\nMB       DC    CL6' '                  BUFFER\nADEST    DC    A(0)                    DESTINATION ADDR\n*\nKTRUE    DC    C'TRUE'                 BOOLEAN VALUE TRUE\nKFALSE   DC    C'FALSE'                BOOLEAN VALUE FALSE\n*\nSAVEAREA DC    18F'0'                  SAVE AREA\n*\n         LTORG\n*\n         DSTABLE  DSECT=YES\n*\nFAS      DSECT\n*\n         COPY  FSAREA\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIIDE   0201-12230-12230-1200-00520-00520-00000-LEVEL\nIDE      TITLE 'IHIIDECM, INREAL, ININTEGER, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        SCAN INPUT BUFFER UNTIL A VALID NUMBER IS FOUND TRANSFER\n*        TO BINARY AND STORE INTO SECOND PARAMETER\n*\n*        ENTRY POINTS -\n*        IHIIDEIR - FROM - GENERATED OBJECT MODULE - INREAL\n*        IHIIDEII - FROM - GENERATED OBJECT MODULE - ININTEGER\n*                   LA   R1,PARMLIST\n*                   BALR R14,R15\n*                   DATA PASSED BY NAME\n*        IHIIDEAI - FROM - ARRAY MODULE IHIIAR\n*                   L    R7,A(DESTINATION)\n*                   L    R10,FLAG\n*                   BALR R14,R15\n*                   DATA PASSED BY NAME\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES -\n*        IHIIOR - EVALUATE DATASET NUMBER\n*               - OPEN DATASET\n*               - CHANGE TO NEXT INPUT RECORD\n*               - CONVERT REAL TO INTEGER\n*        IHIFSA - CNVIRD, INTEGER TO REAL\n*        IHIPTT - POWER OF TEN TABLE\n*\n*        TABLE/WORK AREAS -\n*        IPTAB - TO EVALUATE CHARACTER FROM INPUT BUFFER WHEN\n*                SCANNING AND TO BRANCH TO CORRESPONDING SUBPROGRAM\n*        MB    - MANTISSA BUFFER FOR INTERMEDIATE STORING OF VALID\n*                DIGITS\n*\n*        EXITS - NORMAL - RELOAD REGISTERS AND RETURN VIA R14\n*\n*        EXITS - ERROR - INPUT REQUEST BEYOND END OF DATASET NO 5\n*                      - EXP PART OF INPUT NUMBER CONSISTS OF\n*                        MORE THAN 2 DIGITS NO 6\n*                        BRANCH TO FSA\n*                        LA     R13,IHIFSA\n*                        B      FSAERR+XX*4(R13) XX CORRESPONDING\n*                                                   ERROR NUMBER\n*\n*        NOTES - LINKING TO IHIIDEAI DEVIATES FROM STANDARD SEE\n*        ABOVE\n*\nIHIIDECM CSECT\n*\n         ENTRY IHIIDEIR\n         ENTRY IHIIDEII\n         ENTRY IHIIDEAI\n*\n*        REGISTER CONTENTS ON ENTRY POINT IHGIDEAI\n*\n*        R7                            DESTINATION ADDR\n*        R10                           FLAG BYTE\n*\n*        FLOATING POINT REGISTERS\n*\nFPR0     EQU   0\n*\n*        OTHER GENERAL REGISTERS\n*\n*        R5                            -> DSTABLE ENTRY\n*        R6                            DATASET NUMBER\n*        R13                           BASE REGISTER FOR\n*        R7                            -> DESTINATION\n*        R4                            CHARACTER POINTER\n*        R0                            INTEGER NUMBER\n*        R8                            MANTISSA BUFFER POINTER\n*        R9                            EXPONENT BUFFER POINTER\n*        R10                           DECIMAL POINT POINTER\n*        R11                           EXPONENT LESS EIGHT\n*        R15                           -> POWERTEN TABLE LESS EIGHT\n*\n         USING DSTABLE,R5\n*\n*        DISPLACEMENTS IN ADRLST IN IHIFSA\n*\nCI       EQU   0             DISPLACEMENT FOR - IHIIORCI\nCL       EQU   4                                IHIIORCL\nEV       EQU   8                                IHIIOREV\nNX       EQU   12                               IHIIORNX\nOP       EQU   16                               IHIIOROP\nOQ       EQU   20                               IHIIOROQ\n*\nIHIIDEAI SAVE  (14,12),,'IHIIDEAI LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHIIDEAI,R15\n         LR    R3,R13                  CHAIN SAVE AREAS\n         LA    R13,SAVEAREA\n         ST    R3,4(,R13)\n         ST    R13,8(,R3)\n         LA    R3,COMMON\n         DROP  R15\n         USING COMMON,R3\n         STC   R10,FKT                 STORE FLAG BYTE\n         B     LADDRA\n*\n         DROP  R3\n*\nIHIIDEII SAVE  (14,12),,'IHIIDEII LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHIIDEII,R15\n         LR    R12,R13\n         LA    R13,SAVEAREA            CHAIN SAVE AREAS\n         ST    R12,4(,R13)\n         ST    R13,8(,R12)\n         LA    R3,COMMON\n         DROP  R15\n         USING COMMON,R3\n         MVI   FKT,X'04'               FLAG BYTE: ININTEGER\n         B     COMMON\n*\n         DROP  R3\n*\nIHIIDEIR SAVE  (14,12),,'IHIIDEIR LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHIIDEIR,R15\n         LR    R12,R13\n         LA    R13,SAVEAREA            CHAIN SAVE AREAS\n         ST    R12,4(,R13)\n         ST    R13,8(,R12)\n         LA    R3,COMMON\n         DROP  R15\n         USING COMMON,R3\n         MVI   FKT,X'00'               FLAG BYTE: INREAL\n         B     COMMON\n*\n*        EVALUATE DATASET NUMBER (EVDSN)\n*\nCOMMON   L     R15,IORLST(,R12)\n         L     R15,EV(,R15)\n         BALR  R14,R15\n*\nLADDR    L     R7,4(,R1)               R7 -> DESTINATION ADDR\nLADDRA   NI    DSF+1,255-DS10          SET DS10 = 0\n         TM    Q,X'FF'                 DATASET SECTIONED ?\n         BNZ   ERROR2                  YES, INCOMPATIBLE ACTION\n         CH    R6,=H'1'                DATASET NO = 1 ?\n         BE    ERROR2                  YES, INCOMPATIBLE ACTION\n         TM    DSF,DS0                 DATASET OPEN ?\n         BO    DSOPEN                  YES, BRANCH\n         L     R15,IORLST(,R12)        NO, SETUP FOR OPEN REQUEST\n         L     R15,OP(,R15)\n         B     REQOPEN                 DCB IS CLOSED, BRANCH TO OPEN IT\n*\nDSOPEN   TM    DSF,DS2                 LAST I/O OUTPUT ?\n         BZ    DSOPENA                 NO, BRANCH\n         B     ERROR3                  INPUT BEYOND LAST OUTPUT\n*\nDSOPENA  TM    DSF,DS6                 OPEN FOR OUTPUT ?\n         BZ    SCAN                    NO, BRANCH\n         TM    DSF,DS7\n         BO    ERROR5                  END OF DATA REACHED\n         B     ERROR2\nREQOPEN  NI    DSF,255-DS6             SET DS6 = 0\n         BALR  R14,R15                 OPEN DATASET\nSCAN     L     R4,R                    CHARACTER POINTER\n         LA    R8,MB+1                 MANTISSA BUFFER POINTER\n         LA    R9,MB+19                EXPONENT BUFFER POINTER\n         MVC   MB+1(L'MB-1),MB         CLEAR BUFFER\nSCAN1    BCTR  R4,0                    DECREASE CHARACTER POINTER\nSCAN2    MVI   SM,C'+'                 MANTISSA SIGN INITIALLY PLUS\nSCAN2A   MVI   F,0                     CLEAR FLAG BYTE F\n         MVI   SE,C'+'                 EXPONENT SIGN INITIALLY PLUS\nSCAN3    LA    R4,1(,R4)\n         C     R4,RE\n         BNE   SCAN5                   R IS NOT EQUAL RECORD END(RE)\nSCAN4    TM    F,X'82'                 RECORD END IS REACHED (R=RE) ?\n         BNZ   DELIMIT                 A VALID NUMBER HAS BEEN READ\n         L     R15,IORLST(,R12)\n         L     R15,NX(,R15)            REQUEST NEXT RECORD\n         BALR  R14,R15                 RECORD CHANGE IS PERFORMED\n         L     R4,R\n         TM    DSF,DS7                 END OF FILE ?\n         BO    ERROR5                  YES, END OF DATA REACHED\n         B     SCAN1                   NEXT RECORD IS TO BE SCANNED\n*\nSCAN5    SR    R2,R2\n         TRT   0(256,R4),IPTAB         EVALUATE NEXT CHARACTER\n         SR    R15,R15                 CLEAR BLANK COUNTER (CB)\n         B     *(R2)\nBRANCH   B     BLANK                   +04\n         B     OTHERS                  +08\n         B     DIGIT                   +12\n         B     SIGN                    +16\n         B     DECPT                   +20\n         B     APOSTR                  +24\n*\nBLANK    LA    R15,1(,R15)             INCR CB\n         LA    R4,1(,R4)               INCREASE R\n         C     R4,RE\n         BE    SCAN4                   RECORD END IS REACHED\n         CLI   0(R4),C' '\n         BE    BLANK                   NEXT CHARACTER ALSO BLANK\n         SR    R2,R2\n         IC    R2,K\n         CR    R15,R2\n         BL    SCAN5                   < K BLANKS, EVAL NEXT CHARACTER\n         BCTR  R4,0                    K BLANKS READ, DECREASE R\nOTHERS   TM    F,X'82'\n         BZ    SCAN2                   NO VALID NUMBER READ, NEW SCAN\n         B     DELIMIT                 A VALID NUMBER AND K BLANKS READ\n*\nDIGIT    TM    F,X'08'\n         BO    DIGIT1                  EXPONENT DIGIT\n         TM    F,X'40'                 MANTISSA DIGIT\n         BZ    DIGIT2                  FIRST MANTISSA DIGIT\n         CR    R8,R9\n         BL    DIGIT3                  < 19 MANTISSA DIGITS\n         B     DIGIT3A\n*\nDIGIT3   MVC   0(1,R8),0(R4)           DIGIT INTO MANTISSA BUFFER (MB)\nDIGIT3A  LA    R8,1(,R8)               INCREASE MANTISSA POINTER\n         TM    F,X'20'\n         BZ    SCAN3                   NO DEC POINT IS READ, NEXT CHAR\n         OI    F,X'10'                 F3 = 1 DIGIT BEHIND DEC PT READ\n         B     SCAN3\n*\nDIGIT2   CLI   0(R4),C'0'\n         BE    DIGIT2A\n         OI    F,X'C0'                 F0, F1 = 1 MANTISSA DIGIT \u00ac 0\n         B     DIGIT3\n*\nDIGIT2A  OI    F,X'80'                 F0 = 1 LEADING ZERO\n         TM    F,X'20'\n         BZ    SCAN3\n         BCTR  R10,0                   DECR DECIMAL POINT POINTER\n         OI    F,X'10'                 F3 = 1 DIGIT BEHIND DEC P READ\n         B     SCAN3\n*\nDIGIT1   TM    F,X'01'\n         BZ    DIGIT4                  NO EXP DIGIT NOT 0 WAS READ\n         LA    R2,MB+21                END OF EXPONENT BUFFER\n         CR    R9,R2\n         BNL   ERROR6                  MORE THAN 2 EXP DIGITS WERE READ\nDIGIT5   MVC   0(1,R9),0(R4)           DIGIT INTO EXPONENT BUFFER\n         LA    R9,1(,R9)               INCREASE EXPONENT POINTER\n         B     SCAN3                   EVALUATE NEXT CHARACTER\n*\nDIGIT4   OI    F,X'02'                 F6 = 1 ANY EXPONENT DIGIT READ\n         CLI   0(R4),C'0'\n         BE    SCAN3                   EVALUATE NEXT CHARACTER\n         OI    F,X'01'                 F7 = 1 EXPONENT DIGIT \u00ac 0 READ\n         B     DIGIT5\n*\nSIGN     TM    F,X'08'\n         BO    SIGN1                   SIGN FOLLOWED AN APOSTROPHE\n         TM    F,X'80'\n         BO    DELIMIT                 SIGN FOLLOWED A MANTISSA DIGIT\n         B     SIGN2\n*\nSIGN1    TM    F,X'06'\n         BZ    SIGN2A                  EXPONENT SIGN\n         TM    F,X'82'\n         BNZ   DELIMIT                 SIGN FOLLOWED A VALID NUMBER\nSIGN2    MVC   SM,0(R4)                MANTISSA SIGN\n         B     SCAN2A                  NEW SCAN\n*\nSIGN2A   MVC   SE,0(R4)                EXPONENT SIGN\n         OI    F,X'04'                 F5 = 1 EXPONENT SIGN READ\n         B     SCAN3                   EVALUATE NEXT CHARACTER\n*\nDECPT    TM    F,X'28'\n         BZ    DECPT1                  NO DEC POINT OR APOST BEFORE\n         TM    F,X'82'\n         BNZ   DELIMIT                 DEC PT FOLLOWED A VALID NUMBER\n         TM    F,X'08'\n         BO    DECPTA                  DEC POINT FOLLOWED APOSTROPHE\n         MVI   SM,C'+'                 MANTISSA SIGN INITIALLY PLUS\n         B     SCAN3                   NEW SCAN\n*\nDECPTA   MVC   SM,SE                   EXP SIGN IS ASSIGNED TO MANTSIGN\n         MVI   SE,C'+'                 EXPONENT SIGN INITIALLY PLUS\n         MVI   F,0                     CLEAR FLAG BYTE F\nDECPT1   OI    F,X'20'                 F2 = 1 DEC POINT WAS READ\n         LR    R10,R8                  STATE OF MANT POINTER INTO R10\n         ST    R4,DPI                  STATE OF CHAR POINTER INTO DPI\n         B     SCAN3                   NEXT CHARACTER\n*\nAPOSTR   TM    F,X'08'\n         BO    APOSTRA                 AN APOSTROPHE WAS ALREADY READ\n         TM    F,X'30'\n         BNM   APOSTR1                 A VALID NUMBER WAS READ\nAPOSTRA  TM    F,X'82'                 APOSTROPHE FOLLOWED DEC POINT\n         BNZ   DELIMIT                 NUMBER BEFORE DEC POINT IS VALID\n         MVC   SM,SE                   EXP SIGN IS ASSNED TO MANT SIGN\n         MVI   SE,C'+'                 EXPONENT SIGN INITIALLY PLUS\n         MVI   F,0                     CLEAR FLAG BYTE F\nAPOSTR1  OI    F,X'08'                 APOSTROPHE WAS READ F4.=1\n         ST    R4,API                  STATE OF CHAR POINTER INTO API\n         B     SCAN3                   EVALUATE NEXT CHARACTER\n*\nDELIMIT  TM    F,X'30'\n         BNM   DELIMIT1                MANTISSA PART IS VALID\n         L     R4,DPI                  CHAR POINTER OF DEC POINT INTO R\n         NI    F,X'DF'                 F2.=0 NO DEC POINT WAS READ\n         B     DELIMIT2\n*\nDELIMIT1 TM    F,X'0A'\n         BNM   DELIMIT2                EXPONENT PART IS VALID\n         L     R4,API                  CHAR PTR OF APOSTROPHE INTO R\n         NI    F,X'F3'\nDELIMIT2 C     R4,RE\n         BNE   DELIMITB\nDELIMITC L     R15,IORLST(,R12)\n         L     R15,NX(,R15)            REQUEST NEXT RECORD\n         BALR  R14,R15                 RECORD CHANGE IS PERFORMED\n         B     DELIMIT3\n*\nDELIMITB LA    R4,1(,R4)               INCR CHARACTER POINTER\n         C     R4,RE\n         BE    DELIMITC\n         ST    R4,R                    STORE CHAR POINTER TO DSTABLE\nDELIMIT3 TM    F,X'28'                 TEST TYPE OF NUMBER\n         BNZ   TRREAL                  REAL TYPE NUMBER\n         TM    F,X'40'\n         BO    DELIMITD                NUMBER \u00ac= ZERO\n         SR    R0,R0\n         B     TRINT1                  NUMBER = ZERO\n*\nDELIMITD LA    R2,MB+11\n         CR    R8,R2\n         BH    TRREAL                  > 10 DIGITS READ, REAL\n         BL    DELIMITH                < 10 DIGITS READ, INTEGER\n         CLC   MB+1(10),DMINT          10 DIGITS WERE READ\n         BNL   TRREAL                  NUMBER GREATER (2**31)-1, REAL\nDELIMITH LA    R2,MB+2\n         SR    R8,R2                   NUMBER OF DIGITS DECR BY ONE\n         EX    R8,PACK                 PACK NUMBER\n         CLI   SM,C'+'                 TEST SIGN OF THE NUMBER\n         BNE   DELIMITE\n         OI    MB+17,X'0F'\n         B     DELIMITF\n*\nDELIMITE OI    MB+17,X'0D'\n         NI    MB+17,X'FD'\nDELIMITF CVB   R0,MB+10\nTRINT1   LA    R2,4\n         CLI   FKT,X'04'\n         BE    FIN3                    CONVERSION NOT REQ, FKT=INTEGER\n*\n*        CALL CONVERSION ROUTINE (LOADED IN FSA)\n*\n         STM   R14,R13,8(R13)          ALL REGISTERS INTO SAVEAREA\n         LR    R2,R13                  R2 -> SAVE AREA\n         LA    R7,ACNVIRD(,R12)\n         LR    R14,R0                  INTEGER INTO R14\n         LR    R13,R12                 R13 -> FSA\n         BALR  R8,R7\n         LM    R14,R13,8(R2)           RESTORE REGS\n         SR    R2,R2\n         USING FSAAREA,R12\n         TM    OPTSW(R12),X'20'        LONG OR SHORT PRECISION ?\n         BZ    FIN3                    LONG PRECISION STATED\n         LA    R2,8\n         B     FIN3\n*\nTRREAL   SWR   FPR0,FPR0\n         TM    F,X'C0'\n         BO    TRREALA\n         BM    FIN                     MANTISSA IS ZERO\n         SR    R10,R10\n         LD    FPR0,KFPD1              MANTISSA IS 1.0\n         B     TRREAL1\n*\nTRREALA  TM    F,X'20'\n         BO    TRREALB                 A DECIMAL WAS READ\n         LR    R10,R8                  DECPT IS ACCEPTED BEH LAST DIGIT\nTRREALB  LA    R2,MB+10\n         SR    R10,R2                  POS OF DECPT: BEHIND 9. DIGIT\nTRREAL2  PACK  MB+2(8),MB+1(9)         PACK UPPER 9 DIGITS\n         OI    MB+9,X'0F'\n         CVB   R0,MB+2                 CONVERT UPPER 9 DIGITS TO BINARY\n         ST    R0,MASK+4               MASK FLOATING ZERO WITH EXPON 78\n         AD    FPR0,MASK               TRANSFORM NUMBER TO FLOAT TYPE\n         CR    R8,R2\n         BNH   TRREAL1\n         MD    FPR0,TPNINE\n         S     R10,KF9                 SHIFT DECPT 9 POSITIONS TO RIGHT\n         SR    R8,R8\n         PACK  MB+2(8),MB+10(9)        PACK LOWER 9 DIGITS\n         B     TRREAL2+6               REPEAT ACTION FOR LOWER 9 DIGITS\n*\nTRREAL1  CLI   SM,C'+'\n         BE    TRREAL1A                NUMBER IS POSITIVE\n         LCDR  FPR0,FPR0               INSERT MINUS\nTRREAL1A SR    R0,R0\n         TM    F,X'01'\n         BZ    TRREAL3                 SCALE FACTOR\n         NI    MB+19,X'0F'             CLEAR ZONE OF ONE EXPONENT DIGIT\n         IC    R0,MB+19\n         TM    MB+20,X'FF'             2. EXPONENT DIGIT IS TESTED\n         BZ    TRREAL3A                NO 2. EXPONENT\n         MH    R0,KH10                 FIRST EXPONENT DIGIT MULT BY 10\n         LR    R2,R0\n         NI    MB+20,X'0F'             CLEAR ZONE OF 2. EXPONENT DIGIT\n         IC    R0,MB+20\n         AR    R0,R2                   TOTAL PRELIMINARY EXPONENT\nTRREAL3A CLI   SE,C'+'\n         BE    TRREAL3                 EXPONENT IS POSITIVE\n         LCR   R0,R0                   INSERT MINUS\nTRREAL3  AR    R10,R0                  CORR EXP BY DEC POINT POSITION\n         BZ    FIN                     CORRECTED EXPONENT IS ZERO\n         L     R15,VPTTAB              ADDR OF POWERTEN TABLE\n         BP    TRREAL3B\n         LA    R15,128(R15)            ADDR OF 10**(-1) DIMIN BY EIGHT\nTRREAL3B LPR   R10,R10                 ABS (CORRECTED EXPONENT)\n         SR    R11,R11                 CLEAR REGISTER\n         SRDA  R10,3\n         SLA   R10,3\nTRREAL5  BZ    TRREAL4A                CORRECTED EXPONENT LESS 8\n         C     R10,KF72\n         BNH   TRREAL4                 CORRECTED EXPONENT LESS 73\n         MD    FPR0,128(,R15)          MULTIPLY OR DIVIDE BY 10**72\n         S     R10,KF72                DECREASE CORRECTED EXP BY 72\n         B     TRREAL5                 REPEAT MULT OR DIVISION\n*\nTRREAL4  MD    FPR0,56(R10,R15)\nTRREAL4A SRL   R11,26\n         LTR   R11,R11\n         BZ    FIN\n         MD    FPR0,0(R11,R15)       * OR / 10**(EXP-(ENTIER(EXP/8)*8))\nFIN      SR    R2,R2                   CLEAR R2, TYPE = REAL LONG\n         TM    OPTSW(R12),X'20'        LONG OR SHORT PRECISION ?\n         BZ    FIN1                    LONG PRECISION STATED\n         STD   FPR0,BUFF               SHORT PRECISION STATED\n         MVC   ROUND(1),BUFF           EXPONENT TO ROUND\n         AD    FPR0,ROUND              LONG PRECISION ROUNDED TO SHORT\n         LA    R2,8                    TYPE = REALSHORT\nFIN1     CLI   FKT,0\n         BE    FIN3                    CONVERSION NOT NECESSARY\n         LA    R2,4                    TYPE = INTEGER\n         L     R15,IORLST(,R12)\n         L     R15,CI(,R15)\n         BALR  R14,R15                 NUMBER CONVERTED TO INTEGER\nFIN3     EX    0,STORE(R2)\n         L     R13,SAVEAREA+4\n*\n         RETURN (14,12)\n*\nPACK     PACK  MB+10(8),MB+1(0)        EXE INSTRUCTIONS\nSTORE    STD   FPR0,0(,R7)             *\n         ST    R0,0(,R7)               |\n         STE   FPR0,0(,R7)             V\n*\nERROR2   LR    R13,R12\n         B     FSAERR+2*4(R12)         INCOMP ACTION ON DATASET\n*\nERROR3   LR    R13,R12\n         B     FSAERR+3*4(R12)         INPUT BEYOND LAST OUTPUT\n*\nERROR5   LR    R13,R12                 INPUT REQ BEYOND END OF DATASET\n         B     FSAERR+5*4(R12)\n*\nERROR6   LR    R13,R12                 EXP PART CONSIST OF\n         B     FSAERR+6*4(R12)         MORE TH.2DIGITS\n*\n*        EXTERNAL ADDRS\n*\nVPTTAB   DC    V(IHIPTTAB)\n*\nACNVIRD  EQU   X'120'\n*\n*        INTERNAL CONSTANTS AND STORAGE\n*\nKF9      DC    F'9'                    FOR SHIFT OF DECIMAL POINT\nKF72     DC    F'72'                   FOR EXPONENT TREATMENT\nAPI      DC    A(0)                    CHARACTER POINTER OF APOSTROPHE\nDPI      DC    A(0)                    CHARACTER POINTER OF DEC POINT\nBUFF     DC    D'0'                    FOR CONVERSION OF NUMBER\nKFPD1    DC    D'1.0'\nTPNINE   DC    DE9'1'                  10**9\nMASK     DC    FL8S56'78'              FLOAT 0 WITH EXPONENT 78\nROUND    DC    X'0000000080000000'     FOR CONVERSION OF NUMBER\nKH10     DC    H'10'                   FOR EXPONENT TREATMENT\nFKT      DC    X'00'                   FLAG BYTE\nF        DC    X'00'                   FLAG BYTE\nSM       DC    C' '\nSE       DC    C' '\nMB       DC    XL21'00'                MANTISSA BUFFER\nDMINT    DC    C'2147483648'           2**31\n*\nIPTAB    DC    64X'08'                 OTHERS\n         DC    X'04'                   BLANK\n         DC    10X'08'                 OTHERS\n         DC    X'14'                   DECIMAL POINT\n         DC    2X'08'                  OTHERS\n         DC    X'10'                   SIGN +\n         DC    17X'08'                 OTHERS\n         DC    X'10'                   SIGN -\n         DC    28X'08'                 OTHERS\n         DC    X'18'                   APOSTROPHE\n         DC    114X'08'                OTHERS\n         DC    10X'0C'                 DIGITS 0 TO 9\n         DC    6X'08'                  OTHERS\n*\nSAVEAREA DC    18F'0'\n*\n         LTORG\n*\n         DSTABLE  DSECT=YES\n*\nFSAAREA  DSECT\n*\n         COPY  FSAREA\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIIOR   0201-12230-12230-1200-01169-01169-00000-LEVEL\nIOR      TITLE 'IHIIORTN, LIBRARY I/O SERVICE ROUTINES, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        THE CODE HAS BEEN UPDATED -\n*\n*        1. ALL HARDCODED LENGTH CALCULATIONS FOR GETMAINED\n*           AREAS USED FOR DCB, DECB ETC ARE NOW CALCULATED\n*        2. ALL REFERENCES TO VARIOUS DCB FIELDS UTILIZE THE\n*           MAPPING SYMBOLS PROVIDED BY DCBD\n*        3. ALL REFERENCES TO VARIOUS JFCB FIELDS UTILIZE THE\n*           MAPPING SYMBOLS PROVIDED BY IEFJFCBN\n*        4. THE DCBS FOR SYSIN, SYSPRINT AND ALGLIB01 ARE OPENED\n*           WITH OPEN OPTIONS SUITABLE FOR JES2/3 DATASETS\n*           THIS WILL PREVENT 013-BC ABENDS THAT OCCURRED WITH THE\n*           PREVIOUS RELEASE\n*        5. ALL NUMERIC BRANCH CONDITIONS ARE RATIONALIZED TO USE\n*           STANDARD ASSEMBLER MNEMONICS\n*        6. MINOR CODE AND COMMENT CHANGES FOR IMPROVED READABILITY\n*\n*        FUNCTION/OPERATION -\n*        THIS MODULE CONTAINS A SET OF SERVICE ROUTINES USED BY\n*        OTHER I/O MODULES AS SUBROUTINES\n*        THEY PERFORM THE FOLLOWING -\n*        OPEN DATASET\n*        CHANGE TO NEXT RECORD\n*        CLOSE DATASET\n*        CLOSE ALL DATASETS\n*        CLEAR NOTTAB\n*        ENTRY NOTTAB\n*        EVALUATE DATASET NUMBER\n*        END OF DATA HANDLING\n*        SYNCHRONOUS ERROR HANDLING\n*        CONVERT REAL TO INTEGER.\n*        MORE DETAIL BEFORE EACH ROUTINE\n*\n*        ENTRY POINTS -\n*        IHIIOROP\n*        IHIIOROQ\n*        IHIIORNX\n*        IHIIORCL\n*        IHIIORCP\n*        IHIIORCN\n*        IHIIOREN\n*        IHIIOREV\n*        IHIIORCI\n*        IHIIORED\n*        IHIIORER\n*        ALL INVOKED BY BALR R14,R15\n*        DIFFERENCE EXPLAINED BEFORE EACH ROUTINE\n*\n*        INPUT - SEE EACH ROUTINE\n*\n*        OUTPUT - SEE EACH ROUTINE\n*\n*        EXTERNAL ROUTINES - IHIGPR - CLOSE DATASET FOR PUT/GET\n*\n*        EXITS - NORMAL - ALL ROUTINES EXCEPT END OF DATA AND\n*                         SYNAD RELOAD REGISTERS AND BR 14\n*              - ERROR  - NO  EXPLANATION\n*                         0   DATASET NUMBER OUT OF RANGE\n*                         1   REAL NUMBER TO BE CONVERTED OUT OF\n*                             INTEGER RANGE\n*                         2   INCOMPATIBLE ACTIONS ON SAME DATASET\n*                         3   INPUT BEYOND LAST OUTPUT\n*                         4   OVERFLOW OF NOTTAB\n*                         5   INPUT REQUEST BEYOND END OF DATASET\n*                         7   DATA SECTIONED AND NO CTRL CHARACTER\n*                             SPECIFIED\n*                         32  UNRECOVERABLE I/O ERROR\n*                         37  BLOCKSIZE NOT A MULTIPLE OF RECORD\n*                             LENGTH\n*                         41  DDCARD INCORRECT OR MISSING\n*              - ACTION - BRANCH TO IHGFSA\n*                         LA 13,IHGFSA\n*                         B  FSAERR+XX*4(13)  XX ERROR NUMBER\n*\n*        TABLES/WORK AREAS -\n*        NOTTAB, FOR STORING OF RECORD IDENTIFICATION USING WHEN\n*        REPOSITIONING, IS CREATED DYNAMICALLY WHEN OPEN A DATASET\n*        WITH UNBLOCKED RECORD FORMAT SIZE OF 1024 BYTES\n*\n*        ATTRIBUTES - SERIALLY REUSABLE\n*\n*        NOTES -\n*        THE OPERATION OF THIS MODULE DOES NOT DEPEND UPON A\n*        SPECIAL INTERNAL REPRESENTATION OF THE EXTERNAL\n*        CHARACTER SET\n*\n*        REGISTER USAGE\n*\n*        R5  -> RELEVANT ENTRY IN DSTAB\n*        R6     DATASET NUMBER\n*        R7     PROGRAM BASE REGISTER\n*        R8  -> DCB AND DECB'S\n*        R12 -> FSA\n*        R13 -> SAVE AREA\n*        R14 -> RETURN\n*        R15 -> ROUTINE\n*\nIHIIORTN CSECT\n*\n         ENTRY IHIIOROP\n         ENTRY IHIIOROQ\n         ENTRY IHIIORNX\n         ENTRY IHIIORCL\n         ENTRY IHIIORCP\n         ENTRY IHIIORGP\n         ENTRY IHIIORCN\n         ENTRY IHIIOREN\n         ENTRY IHIIOREV\n         ENTRY IHIIORED\n         ENTRY IHIIORCI\n         ENTRY IHIIORER\n*\n*        DISPLACEMENT IN FSA\n*\nADSTAB   EQU   X'AC'\nANOTTAB  EQU   X'B0'\nOPTSW    EQU   X'C2'\nFSAERR   EQU   X'1CC'\n*\n*\n*\n*----------------------------------------------------------------------\n*        OPEN A DATASET\n*----------------------------------------------------------------------\n*\n*        FUNCTION/OPERATION -\n*        RESERVE STORAGE FOR AND COMPLETE A DCB AND TWO I/O BUFFERS\n*\n*        COMPLETE DSTAB FIELDS IN GENERATED OBJECT MODULE\n*\n*        STAB HAS AN ENTRY AND INDICATOR STATUS FOR EVERY DATASET\n*        USED IN THE PROGRAM\n*\n*        INPUT -\n*        IF DATASET SHOULD PERFORM ONLY INPUT OR OUTPUT BLOCKED\n*        RECORD FORMAT IS USED ELSE UNBLOCKED FORMAT - ACCESS\n*        METHOD BSAM.\n*        IN CASE OF INPUT TWO RECORDS OR BLOCKS READ TO I/O\n*        BUFFERS. BLOCKED RECORD FORMAT IS USED ONLY WHEN\n*        BLOCKING FACTOR > 1\n*\n*        OUTPUT - N/A\n*\n*        NOTES -\n*        ADDR OF THE DCB IS LOADED IN R8 AND KEPT THROUGH ALL\n*        I/O MODULES\n*\n*        ROUTINE IHIIOROQ IS ENTERED FROM SYSACT 12\n*\nIHIIOROQ SAVE  (14,12),,'IHIIOROQ LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LR    R4,R15\n         USING IHIIOROQ,R4\n         LA    R7,IHIIOROP\n         USING IHIIOROP,R7\n         ST    R13,SAVAR+4\n         LA    R13,SAVAR\n         USING DSTABLE,R5              DSN RELEVANT ENTRY IN DSTABLE\n         CH    R6,=H'1'                DATASET NUMBER 0 OR 1 ?\n         BNH   OPEN00                  YES, BRANCH TO IHIIOROP\n         NI    DSF,255-DS6\n         TM    DSF+1,DS14              DATASET BEEN OPEN BEFORE ?\n         BO    OPEN00                  YES\n*\n*        OPEN DATASET FOR THE FIRST TIME\n*\n*        GETMAIN AREA FOR DCB, DECB AND JFCB\n*        EXAMINE THE DISP PARAMETER IN JFCB IF NEW OPEN THE\n*        DATASET FOR OUTIN ELSE FOR INOUT\n*\n         GETMAIN R,LV=DCBAREAL\n*\n         ST    R1,ADCB                 SAVE DCB ADDR IN DSTABLE\n         LR    R8,R1\n         USING IHADCB,R8\n         MVC   0(DCBMODLN,R8),DCBMODEL  MOVE DCBMODEL INTO GETMAIN AREA\n*\n*        CONVERT BINARY DATASET NUMBER INTO CHARACTER TO\n*        MOVE INTO THE DDNAME\n*\n         CVD   R6,DWORD\n         UNPK  DWORD(2),DWORD+6(2)     EXTRACT LAST TWO DIGITS\n         OI    DWORD+1,X'F0'\n         MVC   DCBDDNAM+6(2),DWORD     MOVE IN DCB DDNAME NUMBER\n         LA    R3,JFCB\n         STCM  R3,B'0111',ADCBEXIT+5   STORE JFCB AREA ADDR\n*\n         RDJFCB ((R8))\n*\n         TM    JFCBTSDM,JFCSDS         SYSIN/SYSOUT DATASET ?\n         BZ    ROQA                    NO, BRANCH\n*\n*        SUBSYSTEM DATASET\n*\n         TM    JFCBIND2,JFCMOD         NEW OR MOD DATASET ?\n         BO    ROQB                    YES, MUST BE SYSOUT\n         MVC   DCBMACRF,=AL1(DCBMRRD,0)  NO POINT OPTION FOR SUBSYS DS\n         B     ROQD\n*\nROQB     MVC   DCBMACRF,=AL1(0,DCBMRWRT) NO POINT OPTION FOR SUBSYS DS\n         OI    DSF,DS6\n         B     ROQD\n*\nROQA     TM    JFCBIND2,JFCMOD         NEW OR MOD DATASET ?\n         BZ    ROQD                    NO, BRANCH\n         OI    DSF,DS6\nROQD     LA    R1,JFCB\n*\n*        FREE UP THE JFCB AREA ON THE END OF DCBAREA AS ITS NO\n*        LONGER NEEDED\n*\n         FREEMAIN R,LV=JFCB_LEN,A=(1)\n*\n         B     OPEN20\n*\nIHIIOROP SAVE  (14,12),,'IHIIOROP LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LR    R7,R15\n         ST    R13,SAVAR+4\n         LA    R13,SAVAR\nOPEN00   CH    R6,=H'1'\n         BNE   OPEN01\n*\n*        DATASET NUMBER = 1\n*        IF DATASET HAS BEEN OPENED BEFORE (DS14=1)\n*        SET DS0 = 1 AND GO BACK. IF NOT OPEN THE DATASET\n*\n         TM    DSF+1,DS14              PREVIOUSLY OPENED ?\n         BZ    OPEN01                  NO, BRANCH\n         OI    DSF,DS0\n         B     OPEN51\n*\n*        GETMAIN FOR DCB AND DECB, NO JFCB\n*\nOPEN01   GETMAIN R,LV=DCBAREAL-JFCB_LEN\n*\n         ST    R1,ADCB\n         LR    R8,R1\n         MVC   0(DCBMODLN,R8),DCBMODEL  MOVE IN MODEL DCB\n         CH    R6,=H'1'\n         BL    DSIN\n         BE    DSPRINT\n*\n*        CONVERT BINARY DSNUMBER TO CHAR\n*\n         CVD   R6,DWORD                DATASET NUMBER TO DDNAME\n         UNPK  DWORD(2),DWORD+6(2)     EXTRACT LAST TWO DIGITS\n         OI    DWORD+1,X'F0'\n         MVC   DCBDDNAM+6(2),DWORD     MOVE IN DCB DDNAME NUMBER\n         B     OPEN2\n*\nDSIN     MVC   DCBDDNAM,=CL8'SYSIN   '\n         MVC   DCBMACR,=AL1(DCBMRRD,0)  NO POINT OPTION FOR SYSIN\n*\n         OPEN  ((R8),(INPUT))          INPUT ONLY FOR SYSIN\n*\n         B     OPEN300\n*\n*        IF DS11 = 0 OPEN DATASET SYSPRINT\n*        IF DS11 = 1 OPEN DATASET ALGLDD01\n*\nDSPRINT  TM    DSF+1,DS11\n         BO    DSPR2\n         MVC   DCBDDNAM+6(2),=CL2'01'  LAST 2 CHARS OF DDNAME\n         OI    DSF+1,DS14\n         B     DSPR2A\n*\nDSPR2    MVC   DCBDDNAM,=CL8'SYSPRINT'\nDSPR2A   MVC   DCBMACR(2),=AL1(0,DCBMRWRT)  NO POINT OPT FOR SYSPRINT\n*\n         OPEN  ((R8),(OUTPUT))        OUTPUT ONLY FOR SUBSYS SYSOUT\n*\n         B     OPEN300\n*                                     SET MACRF=(RP,WP)\nOPEN2    MVC   DCBMACR,=AL1(DCBMRRD+DCBMRPT1,DCBMRWRT+DCBMRPT2)\nOPEN20   ICM   R2,B'1111',ANOTTAB(R12)\n         BNZ   OPEN3\n*\n         GETMAIN R,LV=1024             GET AREA FOR NOTE TABLE\n*\n         ST    R1,ANOTTAB(R12)\n         LR    R2,R1                   ANOTTAB TO R2\n         LR    R3,R2                   ANOTTAB TO R3\n         LA    R3,8(,R3)\n         ST    R3,0(,R2)               STORE POINTER NXE IN NOTTAB\n         LA    R3,1016(,R3)\n         ST    R3,4(,R2)               STORE POINTER NEXEF IN NOTTAB\nOPEN3    TM    DSF,DS6                 OUTPUT POSSIBLE ?\n         BO    OPEN30                  YES\n*\n         OPEN  ((R8),(INOUT))\n*\nOPEN300  TM    DCBOFLGS,DCBOFOPN       OPEN SUCCESSFUL ?\n         BO    OPEN355                 YES, BRANCH\n         NI    DSF+1,255-DS14          NO, SET DS14 = 0\n         LR    R13,R12                 DDCARD INCORRECT OR MISSING\n         B     FSAERR+41*4(R12)\n*\nOPEN30   OPEN  ((R8),(OUTIN))\n*\n         B     OPEN300                 CONTINUE\n*\nOPEN355  TM    EXERFLAG,X'11'          ERROR IN DCBEXIT ?\n         BZ    OPEN301\n*\n*        CLOSE DATASET AND FREEMAIN FOR DCB AND DECB ONLY\n*\n         CLOSE ((R8),REREAD)\n*\n         FREEMAIN R,LV=DCBAREAL-JFCB_LEN,A=ADCB\n*\n         LR    R13,R12\n         TM    EXERFLAG,X'01'          ERROR 7 IN DCBEXIT ?\n         MVI   EXERFLAG,X'00'          CLEAR FLAG\n         BZ    OPEN350\n         B     FSAERR+7*4(R12)         ERROR 7\n*\nOPEN350  B     FSAERR+37*4(R12)        ERROR 37\n*\nOPEN301  OI    DSF,DS0\n         CH    R6,=H'1'                DATASET NUMBER = 0 OR 1\n         BNH   OPEN301A\n         OI    BL+3,DS14\nOPEN301A LH    R0,BL\n         AR    R0,R0                   DOUBLE BUFFER LENGTH\n*\n         GETMAIN R,LV=(0)              GET AREA FOR TWO BUFFERS\n*\n         ST    R1,BB                   BUFFER BEGIN\n         LR    R2,R1\n         AH    R1,BL\n         ST    R1,NBB                  ALTERNATE BUFFER BEGIN\n         TM    DSF,DS6\n         BO    OPEN4\nOPEN31   OI    DSF+1,DSEOD             SET MARK FOR END OF DATA\n         LA    R4,DECB\n         L     R3,8(,R4)\n         CR    R3,R8\n         BNE   OPEN311\n*\n         CHECK DECB\n*\nOPEN311  READ  DECB,SF,(R8),(R2),MF=E  READ FIRST BLOCK\n*\n         CHECK DECB\n*\n         NI    DSF+1,255-DSEOD         RESET\n         LH    1,DCBBLKSI\n         L     R4,DCBIOBA\n         SH    1,22(R4)\n         STH   1,BL\n*\n         NOTE  (R8)\n*\n         ST    R1,NOTEADR\nOPEN41   L     R3,NBB\n*\n         READ  DECB,SF,(R8),(R3),MF=E  READ SECOND BLOCK\n*\n         B     OPEN5\n*\nOPEN4    TM    DSF+1,DS9\n         BZ    OPEN5\n         MVC   0(1,R2),=C'1'           INSERT FIRST CONTROL CHAR\n         LA    R2,1(,R2)               PROVIDE SPACE FOR CONTROL CHAR\nOPEN5    ST    R2,R\n         AH    R2,P\n         ST    R2,RE\nOPEN51   L     R13,SAVAR+4\n*\n         RETURN (14,12)\n*\n*----------------------------------------------------------------------\n*        DCB OPEN EXIT ROUTINE\n*----------------------------------------------------------------------\n*\nIHIIORDX TM    DSF+1,DS11\n         BZ    EXIT3\n*\n*        EXIT ROUTINE FOR PRINTING ERROR MESSAGE\n*\n         MVC   Q(1),=X'32'             RECORD IS SECTIONED Q=50\n         MVC   P(2),=X'005A'           RECORD LENGTH P=90\n*                                      INSERT RECORD FORMAT=FBA\n         MVI   DCBRECFM,DCBRECF+DCBRECBR+DCBRECCA\n         OI    DSF+1,DS9               INSERT FLAG REC CONT CONTR CHAR\n         LH    R4,P\n         LA    R4,1(,R4)               P+1 TO LRECL\n         STH   R4,DCBLRECL\n*\n*        EXAMINE DCB BLKSIZE\n*\n         LH    R3,DCBBLKSI             LOAD DCBBLKSI INTO R3\n         SR    R2,R2\n         DR    R2,R4\n         LTR   R3,R3\n         BZ    EXITA                   BLKSI < LRECL OR BLKSI = 0\n         BCT   R3,EXITB\nEXITA    STH   R4,DCBBLKSI\n         OI    DSF,DS1\nEXITC    MVC   BL(2),DCBBLKSI\n         B     RETEX\n*\nEXITB    LA    R3,1(R3)\n         MH    R3,DCBLRECL\n         STH   R3,DCBBLKSI\n         NI    DSF,255-DS1\n         B     EXITC\n*\n*        ALGOL USER'S EXIT ROUTINE\n*\nEXIT0    TM    DCBRECFM,X'FF'          RECFM PROVIDED ?\n         BZ    EXIT1                   RECFM = 0\n         TM    DCBRECFM,DCBRECF+DCBRECCA  RECFM = FBA OR FBA ?\n         BO    EXIT4\n         TM    Q,X'FF'                 RECORDS PER SECTION PROVIDED ?\n         BZ    RETEX                   NO, BRANCH\n         OI    EXERFLAG,X'01'          DATASET SPLIT INTO SECTIONS\n         B     RETEX                   AND NO CTL CHARACTER ERROR NO 7\n*\nEXIT1    OI    DCBRECFM,DCBRECF        SET RECFM = F\n         TM    DSF,DS1\n         BO    EXIT12\n         OI    DCBRECFM,DCBRECBR       SET RECFM = BLOCKED\nEXIT12   TM    DSF+1,DS9\n         BZ    RETEX\n         OI    DCBRECFM,DCBRECCA       SET RECFM = ASA CNTL\n         B     RETEX\n*\nEXIT4    OI    DSF+1,DS9\n         B     RETEX\n*\n*        EXAMINE LRECL\n*\nEXIT3    OI    DSF,DS1\n         TM    Q,X'FF'\n         BZ    EXIT3A\n         OI    DSF+1,DS9\nEXIT3A   LH    R4,DCBLRECL\n         LTR   R4,R4\n         BZ    EXIT2\n         TM    DSF+1,DS9\n         BO    EXIT5                   DS9=1 RECORDS CONTAIN CNTL CHAR\n         STH   R4,P                    LRECL  TO  P\n         B     EXIT6\n*\nEXIT5    BCTR  R4,0\n         STH   R4,P                    LRECL-1 TO P\n         LA    R4,1(,R4)\n         B     EXIT6\n*\nEXIT2    TM    DSF+1,DS9\n         BO    EXIT7                   DS9 = 1\n         LH    R4,P\n         STH   R4,DCBLRECL             P TO LRECL\n         B     EXIT6\n*\nEXIT7    LH    R4,P\n         LA    R4,1(,R4)               P+1 TO LRECL\n         STH   R4,DCBLRECL\n*\n*        EXAMINE BLKSIZE\n*\nEXIT6    LH    R2,DCBBLKSI\n         LTR   R2,R2                   BLKSIZE = 0 ?\n         BZ    EXIT8                   YES, BRANCH\n         CH    R4,DCBBLKSI             DCBBLKSI = DCBLRECL ?\n         BE    EXIT61A                 YES, BRANCH\n         LH    R3,DCBBLKSI\n         SR    R2,R2\n         DR    R2,R4\n         LTR   R2,R2\n         BZ    EXIT61\n         OI    EXERFLAG,X'10'          BLOCKSIZE NOT A MULTIPLE OF\n         B     RETEX                   LOGICAL RECORD LENGTH ERR NO.37\n*\nEXIT61   NI    DSF,255-DS1             0 TO DS1 UNBLOCKED FORMAT NESC\nEXIT61A  MVC   BL(2),DCBBLKSI          BLKSI TO BL\n         B     EXIT0\n*\nEXIT8    STH   R4,DCBBLKSI\n         STH   R4,BL\n         B     EXIT0\n*\nRETEX    RETURN\n*\n*----------------------------------------------------------------------\n*        NEXTREC - CHANGE TO NEXT RECORD\n*----------------------------------------------------------------------\n*\n*        INPUT -\n*        IN CASE OF AN IN-MODULE CALLING NEXTREC, LAST I/O\n*        OPERATION IS CHECKED FOR COMPLETION AND ONE BLOCK OR\n*        RECORD IS READ TO THE OTHER I/O BUFFER\n*\n*        OUTPUT -\n*        IN CASE OF AN OUT-MODULE CALLING NEXTREC, LAST I/O\n*        OPERATION IS CHECKED FOR COMPLETION AND ONE BLOCK OR\n*        RECORD IS WRITTEN TO THE DATASET\n*\n*\nIHIIORNX SAVE  (14,12),,'IHIIORNX LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LR    R7,R15\n         USING IHIIORNX,R7\n         ST    R13,SAVAR+4\n         LA    R13,SAVAR\n         L     R8,ADCB\n*\n*        FLOW CHAR PROGRAM BEGIN\n*\n         TM    DSF,DS2+DS6\n         BZ    NXIN1\n         BO    NXUT1\n*\n*        DS6=0 DS2=1 CURRENT BLOCK WAS READ AND SHOULD BE WRITTEN\n*        BACK\n*\n         CHECK DECB\n*\n         MVC   BL(2),DCBBLKSI\n         LR    R1,R8\n*\n         POINT (1),NOTEADR\n*\n         OI    DSF,DS6\n*\n*        DS6=1 DS2=1 WRITE BLOCK IF LAST RECORD\n*\nNXUT1    TM    DSF,DS1\n         BZ    NXUT2\n*\n*        CHANGE BUFFERS\n*\nNXUT3    L     R2,BB\n         L     R4,NBB\n         ST    R4,BB\n         ST    R2,NBB\n         ST    R4,R\n         AH    R4,P\n         ST    R4,RE\n         NI    DSF,255-DS3\nNXUT4    L     R4,DECB+8\n         CR    R4,R8\n         BNE   NXUT41\n*\n         CHECK DECB\n*\nNXUT41   WRITE DECB,SF,(R8),(R2),MF=E\n*\n*        CLEAR NOTTAB IF BACKWARD REPOSITIONING HAS OCCURED\n*\nNXUT5    TM    DSF,DS5\n         BZ    NXUT6\n         L     R15,VIORCN              R15 -> IHIIORCN\n         BALR  R14,R15                 CALL IHIIORCN\n         NI    DSF,255-DS5\n*\n*        INSERT NOTTAB ENTRY IF REQUESTED\n*\nNXUT6    TM    DSF,DS4\n         BZ    NXUT7\n*\n         CHECK DECB\n*\n         NOTE  (R8)\n*\n         ST    R1,NOTEADR\n         L     R15,VIOREN              R15 -> IHIIOREN\n         BALR  R14,R15                 CALL IHIIOREN\n         NI    DSF,255-DS4\n*\n*        INSERT CONTROL CHARACTER IF SECTIONED\n*\nNXUT7    TM    DSF+1,DS9\n         BZ    NXRET\n         L     R4,R\n         CLC   S+1(1),Q\n         BL    NXUT8\n         SR    R2,R2\n         STH   R2,S\n         MVI   0(R4),C'1'\n         B     NXUT9\n*\nNXUT8    MVI   0(R4),C' '\nNXUT9    LA    R4,1(R4)\n         ST    R4,R\n         AH    R4,P\n         ST    R4,RE\n*\n*        INCREASE RECORD POINTER AND RETURN\n*\nNXRET    L     R2,S\n         SRL   R2,16\n         LA    R2,1(R2)\n         STH   R2,S\n         L     R13,SAVAR+4\n*\n         RETURN (14,12)\n*\n*        BLOCKED FORMAT\n*        CHECK IF LAST RECORD IND IF NOTTAB ENTRY REQUIRED\n*\nNXUT2    L     R2,BB\n         AH    R2,BL\n         C     R2,RE\n         BE    NXUT3\n         L     R4,RE\n         ST    R4,R\n         AH    R4,P\n         ST    R4,RE\n         TM    DSF,DS4\n         BZ    NXUT7\n         NI    DSF,255-DS6\n         L     R2,BB\n         B     NXUT4\n*\n*        DS6=0 DS2=0 CHECK IF NOTTAB ENTRY REQUIRED\n*        STORE ADDR OF LAST BLOCK IN NOTEADR AND READ NEXT\n*        BLOCK\n*\nNXIN1    TM    DSF,DS4\n         BZ    NXIN2\n         L     R1,NOTEADR\n         L     R15,VIOREN\n         BALR  R14,R15\n         NI    DSF,255-DS4\nNXIN2    TM    DSF,DS1\n         BZ    NXIN5\n*\nNXIN3    CHECK DECB\n*\n         TM    DSF,DS7\n         BZ    NXIN7\n         OI    DSF,DS6\n         MVC   BL(2),DCBBLKSI\n         B     NXIN6\n*\nNXIN7    LH    1,DCBBLKSI\n         L     R4,DCBIOBA\n         SH    1,22(R4)\n         STH   1,BL\n*\n         NOTE  (R8)\n*\n         ST    R1,NOTEADR\n         L     R2,BB\n*\n         READ  DECB,SF,(R8),(R2),MF=E\n*\n*        CHANGE BUFFERS\n*\nNXIN6    L     R2,BB\n         L     R4,NBB\n         ST    R4,BB\n         ST    R4,R\n         AH    R4,P\n         ST    R4,RE\n         ST    R2,NBB\n         B     NXRET\n*\n*        BLOCKED FORMAT\n*\nNXIN5    L     R2,BB\n         AH    R2,BL\n         C     R2,RE\n         BE    NXIN3\n         L     R4,RE\n         ST    R4,R\n         AH    R4,P\n         ST    R4,RE\n         B     NXRET\n*\n*----------------------------------------------------------------------\n*        CLOSE DATASET\n*----------------------------------------------------------------------\n*\n*        FUNCTION/OPERATION -\n*        CLOSE A DATASET, RELEASE STORAGE FOR I/O BUFFERS AND DCB\n*        CALL FOR ROUTINE CLEAR NOTTAB\n*\n*        OUTPUT -\n*        IN CASE OF OUTPUT WRITE LAST BLOCK TO DATASET\n*\nIHIIORCL SAVE  (14,12),,'IHIIORCL LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LR    R7,R15\n         USING IHIIORCL,R7\n         ST    R13,SAVAR+4             SAVE REGISTER\n         LA    R13,SAVAR\n         L     R8,ADCB\n*\n*        DATASET 1 IS TO BE CLOSED ONLY IF DS15=1\n*\n*        IF DS15 = 0 FILL CURRENT BLOCK WITH BLANKS AND BRANCH\n*        TO ROUTINE IHIIORNX TO WRITE THE BLOCK AND RETURN\n*\n         CH    R6,=H'1'\n         BNE   CLOSE01\n         TM    DSF+1,DS15\n         BO    CLOSE01\n         OI    DSF,DS2+DS6\n         NI    DSF,255-DS0             SET DS0=0\n         LH    R2,BL\n         A     R2,BB\n         L     R3,R\n         ST    R2,R\n         SR    R2,R3\n         BZ    CLOSE02\nCLOSE03  MVI   0(R3),C' '\n         LA    R3,1(R3)\n         BCT   R2,CLOSE03\nCLOSE02  NI    S,X'00'\n         MVC   S+1(1),Q\n         L     R7,VIORNX               R15 -> IHIIORNX\n         B     14(,R7)                 CALL IHIIORNX\n*\nCLOSE01  TM    DSF,DS7\n         BO    CLOSE1                  END OF DATA REACHED\n         TM    DSF+1,DSIOERR           I/O ERROR ?\n         BO    CLOSE1                  YES, GO CLOSE DCB\n         LA    R4,DECB                 TEST IF READ OR WRITE BEFORE\n         L     R2,8(,R4)               PICK UP DCB ADDR\n         CR    R2,R8\n         BNE   CLOSE2\n         OI    DSF+1,DS8               SET DS8=1 FOR END OF DATA\n*\nCLOSE0   CHECK DECB                    LAST I/O FINISHED\n*\nCLOSE2   TM    DSF,DS2                 LAST I/O OUTPUT ?\n         BZ    CLOSE1\n         TM    DSF,DS6                 BLOCK BEEN READ ?\n         BO    WRITE2\n         LR    R1,R8                   OUTPUT OCCUR WRITE BACK RECORD\n*\n         POINT (1),NOTEADR             NO BLANKS\n*\n         B     WRITE1\n*\nWRITE2   TM    DSF,DS3                 OUTPUT IN BLOCK\n         BZ    CLOSE1                  NO CLOSE\n*\n*        OUTPUT HAS OCCURED, FILL BUFFER WITH BLANKS AND WRITE\n*\nWRITE1   LH    R2,BL\n         L     R3,R\n         S     R2,R\n         A     R2,BB\n         BZ    CLOSE21\nCLOSE22  MVI   0(R3),C' '\n         LA    R3,1(,R3)\n         BCT   R2,CLOSE22\n*\n*        WRITE BUFFER\n*\nCLOSE21  L     R2,BB\n*\nCLOSE211 WRITE DECB,SF,(R8),(R2),MF=E\n*\n         CHECK DECB\n*\n*        CLOSE DATASET\n*\nCLOSE1   CLOSE ((R8),REREAD)\n*\n         L     R1,BB\n         C     R1,NBB\n         BL    *+8                     THE LOWEST ADDR TO R1\n         L     R1,NBB\n         LH    R0,BL                   BUFFER LEN TO R0\n         SLA   R0,1\n*\n*        FREEMAIN FOR RECORD BUFFERS\n*\n         FREEMAIN  R,LV=(0),A=(1)\n*\n*        FREEMAIN FOR DCB AND DECB\n*\n         FREEMAIN R,LV=DCBAREAL-JFCB_LEN,A=ADCB\n*\n         SR    R2,R2\n         LA    R2,1(,R2)\n         STH   R2,S\n         LA    R2,1(,R2)\n         MVC   P(2),=H'80'              P=80\n         LTR   R2,R6\n         BZ    CLOSE3\n         BCT   R2,CLOSE4\n         B     CLOSE3\n*\nCLOSE4   L     R15,VIORCN\n         BALR  R14,R15                  CLEAR NOTTAB FOR DATASET\nCLOSE3   MVC   DSF,BL+2                 RESTORE DATASET FLAGS\n         L     R13,SAVAR+4\n*\n         RETURN (14,12)\n*\n*----------------------------------------------------------------------\n*        CLOSE ALL DATASETS\n*----------------------------------------------------------------------\n*\n*        FUNCTION/OPERATION -\n*        CALL ROUTINE CLOSE FOR ALL OPEN DATASETS AND ROUTINE\n*        CLOSEGP IN IHIGPR MODULE\n*\n*        THIS ROUTINE IS CALLED FROM IHIFSA AND IHIERR. IN BOTH\n*        CASES R5 CONTAINS THE ADDR OF THE ENTRY IN DSTABLE\n*        FOR DATASET ONE IE DSTABLE+40\n*\nIHIIORCP SAVE  (14,12),,'IHIIORCP LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LR    R7,R15\n         USING IHIIORCP,R7             SAVE REGISTER\n         ST    R13,SAVCLO+4\n         LA    R13,SAVCLO\n         SR    R6,R6\n         SH    R5,=H'40'               DSN TO DSTABLE START\n         ICM   R2,B'1111',0(R5)        TEST APGCF\n         BP    CLOSEPE4                PUT/GET ENTRY IN DSTABLE\n         LA    R2,0(,R2)\n         LA    R5,4(,R5)               R5 -> FIRST DSTABLE ENTRY\nCLOSEPE2 CR    R2,R5\n         BE    CLOSEPE3                ALL DATASETS ARE CLOSED\n         NI    BL+3,255-DS6\n         CH    R6,=H'1'\n         BE    CLOSEPE5\nCLOSEPE7 TM    DSF,DS0\n         BZ    CLOSEPE1\n*\n*        CALL FOR ROUTINE CLOSE\n*\nCLOSEPE6 L     R8,ADCB\n         L     R15,ACLOSE\n         BALR  R14,R15\nCLOSEPE1 LA    R5,DSTABLEL(,R5)        NEXT ENTRY IN DSTAB\n         LA    R6,1(,R6)               INCREASE DATASET NUMBER\n         B     CLOSEPE2\n*\nCLOSEPE5 TM    DSF+1,DS14              DATASET OPENED ?\n         BZ    CLOSEPE7\n         B     CLOSEPE6\n*\nCLOSEPE4 TM    27(R2),X'80'            PUT/GET DATASET OPEN ?\n         BZ    CLOSEPE2-4              DATASET CLOSED\n         L     R15,IHIIORGP\n         BALR  R14,R15                 CLOSE PUT/GET DATASET\n         B     CLOSEPE2-4\n*\n*        ALL DATASETS ARE CLOSED\n*\nCLOSEPE3 L     R1,ANOTTAB(R12)\n         LTR   R1,R1\n         BZ    RETCLOSP\n*\n         FREEMAIN R,LV=1024,A=(1)      FREE NOTTAB\n*\nRETCLOSP L     R13,SAVCLO+4\n*\n         RETURN (14,12)\n*\nSAVCLO   DC    18F'0'\n*\n*        EXTERNAL ADDR\n*\nACLOSE   DC    A(IHIIORCL)\n*\nIHIIORGP DC    A(0)\n*\n*----------------------------------------------------------------------\n*        CLEAR NOTTAB\n*----------------------------------------------------------------------\n*\n*        FUNCTION/OPERATION -\n*        ALL ENTRIES IN NOTTAB FOR RECORDS EQUAL OR GREATER THAN\n*        ACTUAL RECORD COUNTERS ARE CLEARED BY INSERTING INVALID\n*        FLAG\n*\nIHIIORCN SAVE  (14,12),,'IHIIORCN LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LR    R7,R15                  DEFINE BASE REGISTER\n         USING IHIIORCN,R7\n         L     R9,ANOTTAB(R12)\n         LR    R4,R9\nCLNOTB1  LA    R4,8(,R4)               START ENTRY ADDR TO R4\n         C     R4,0(,R9)\n         BE    RETCLEAR                NOTTAB CLEARED\n         LR    R2,R6                   DATASET NUMBER TO R2\n         CH    R2,0(,R4)\n         BNE   CLNOTB1                 CURRENT DSN NOT EQUAL\n         CLC   S(2),2(R4)\n         BH    CLNOTB1\n         MVI   0(R4),X'80'             INSERT INVALID FLAG IN NOTTAB\n         B     CLNOTB1\n*\nRETCLEAR RETURN (14,12)\n*\n*----------------------------------------------------------------------\n*        CLEAR NOTTAB\n*----------------------------------------------------------------------\n*\n*        FUNCTION/OPERATION -\n*        AN ENTRY FOR RECORD JUST HANDLED IS MADE IN NOTTAB\n*\n*        NOTES - ON ENTRY R1 = NOTEADR FROM DSTABLE\n*\n*\nIHIIOREN SAVE  (14,12),,'IHIIOREN LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LR    R7,R15\n         USING IHIIOREN,R7\n         L     R9,ANOTTAB(R12)\n         LR    R4,R9\nENNOTB1  LA    R4,8(,R4)               START ENTRY ADDR\n         C     R4,0(,R9)\n         BNE   ENNOTB3\n         L     R2,0(,R9)               NXE TO R2\n         LA    R2,8(,R2)               INCREASE NXE BY EIGHT\n         ST    R2,0(,R9)\n         C     R2,4(,R9)\n         BE    ENNERR4                 OVERFLOW NOTTAB\nENNOTB2  LR    R2,R6\n         SLA   R2,16\n         ST    R2,0(,R4)               NEW ENTRY DSN AND S TO NOTTAB\n         MVC   2(2,R4),S\n         ST    R1,4(,R4)               NOTEADR\n*\n         RETURN (14,12)\n*\nENNOTB3  TM    0(R4),X'80'             NOTTAB ENTRY INVALID ?\n         BO    ENNOTB2\n         B     ENNOTB1\n*\nENNERR4  LR    13,R12                  OVERFLOW OF RECORD IDENT AREA\n         B     FSAERR+4*4(R12)\n*\n*----------------------------------------------------------------------\n*        EVALUATE DATASET NUMBER\n*----------------------------------------------------------------------\n*\n*        FUNCTION/OPERATION -\n*        ADDR OF DSTABLE IN GENERATED OBJECT MODULE IS PICKED UP\n*        FROM FSA\n*        L R4,ADSTAB(R12)\n*        ACTUAL DATASET NUMBER LOADED IN BINARY FORM TO R6,\n*        ADDR OF ACTUAL ENTRY IN DSTABLE TO R5, THESE REGISTERS\n*        ARE KEPT THROUGH ALL I/O MODULES IN ORDER TO ADDR\n*        POINTERS AND FLAGS IN DSTAB\n*\n*        ENTRY POINT -\n*        DATA IS PASSED VIA NAME\n*        LA   R1,PARMLIST\n*        BALR R14,R15\n*\n*\n*\nIHIIOREV SAVE  (14,12),,'IHIIOREV LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LR    R7,R15\n         USING IHIIOREV,R7\n         ST    R13,SAVAR+4\n         LA    R13,SAVAR\n*\n*        PARAMETER LIST ADDR IN R1\n*\n         ICM   R5,B'1111',0(R1)\n         BP    DSNINT\n         TM    OPTSW(R12),X'20'        LONG OR SHORT PRECISION ?\n         BO    EVD1                    SHORT\n         LD    FPR0,0(,R5)             LONG\n         B     EVD1+4\n*\nEVD1     LE    FPR0,0(,R5)             SHORT\n         L     R15,VIORCI              R15 -> IHIIORCI\n         BALR  R14,R15                 CALL IHIIORCI\n         B     DSNINTA\n*\nDSNINT   L     R0,0(,R5)               DATASET NUMBER IN R0\nDSNINTA  LR    R5,R0\n         N     R0,RANGEDSN             DATASET NUMBER OUT OF RANGE\n         BM    EVDERR0\n         LR    R6,R5\n         LA    R0,DSTABLEL             L'DSTABLE ENTRY\n         MR    R4,R0\n         L     R4,ADSTAB(R12)\n         LA    R5,4(R5,R4)             ENTRY TO DSTABLE IN R5\n         L     R13,SAVAR+4\n         LM    R14,R4,12(R13)\n         LM    R7,R12,48(R13)          KEEP R5 AND R6\n         BR    R14\n*\nEVDERR0  LR    R13,R12                 DATASET NUMBER OUT OF RANGE\n         B     FSAERR(R12)\n*\nRANGEDSN DC    F'-16'                  SCOPE OUTSIDE RANGE OF DSN\n*\nVIORCI   DC    V(IHIIORCI)             ADDR OF CONVERSION ROUTINE\n*\n*----------------------------------------------------------------------\n*        DCB END OF DATA EXIT\n*----------------------------------------------------------------------\n*\n*        FUNCTION/OPERATION - INVOKED VIA CHECK MACRO\n*\n*        EXITS - NORMAL - CHECK FROM SYSACT4 OR CLOSE RELOAD\n*                         REGISTERS AND RETURN TO CALLING PROGRAM\n*                         VIA BR14\n*              - CHECK FROM NEXTREC - BLOCKED FORMAT SET FLAG DS7 IN\n*                         DSTABLE AND BRANCH TO END OF NEXTREC\n*              - UNBLOCKED FORMAT OUTPUT - RETURN TO NEXTREC TO WRITE\n*                         BACK CURRENT RECORD\n*              - UNBLOCKED FORMAT INPUT - SET FLAG DS7 IN DSTABLE AND\n*                         RETURN TO NEXTREC TO UPDATE PTR IN DSTABLE\n*              - ERROR -  CHECK FROM OPEN\n*                         INPUT REQUEST BEYOND END OF DATASET\n*\n*\nIHIIORED SAVE  (14,12),,'IHIIORED LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         BALR  R7,0\n         USING *,R7\n         ST    R13,SAVEOD+4\n         LA    R13,SAVEOD\n         L     R8,ADCB\n         TM    DSF+1,DSEOD             CHECK FROM OPEN ?\n         BZ    END00\n         NI    DSF,255-(DS2+DS3+DS6)   SET FLAGS FOR A CORRECT CLOSE\n         LR    R13,R12\n         B     FSAERR+5*4(R12)         INPUT REQUEST BEYOND END\n*\nEND00    CLOSE ((R8),LEAVE),TYPE=T\n*\n         TM    DSF+1,DS8               CHECK FROM CLOSE OR SYSACT4 ?\n         BZ    END02\nEND11    L     R13,SAVEOD+4\n         LM    R14,R12,12(R13)\n         BR    R14                     RETURN TO CALLING SYSACT4 OR\n*                                      CLOSE ROUTINE\nEND02    TM    DSF,DS2\n         BZ    END03\n         B     END11\n*\nEND03    OI    DSF,DS7\n         MVI   DECB+8,X'FF'            FLAG DCB ADDR IN DECB\n         L     R13,SAVEOD+4            RETURN TO CALLING NEXTREC\n         LM    R14,R12,12(R13)\n         BR    R14                     RETURN TO CALLING NEXTREC\n*\n*        INTERNAL ADDRESSES\n*\nSAVEOD   DC    18F'0'\n*\n*----------------------------------------------------------------------\n*        CONVERSION TO INTEGER\n*----------------------------------------------------------------------\n*\n*        FUNCTION/OPERATION - CONVERT REAL LONG OR SHORT TO INTEGER\n*\n*        NOTES - CALLED BY BALR 14,15\n*        DATA PASSED BY VALUE IN FPR0\n*        RESULT IN R0\n*\nIHIIORCI TM    OPTSW(R12),X'20'        LONG OR SHORT PRECISION ?\n         USING IHIIORCI,R15\n         BZ    LONG\n         STE   FPR0,BUFF3\n         LD    FPR0,BUFF3\n*\nLONG     AD    FPR0,CONST2\n         STD   FPR0,BUFF4\n         CE    FPR0,CONST3\n         BNL   ERROR1\n         AW    FPR0,CONST1\n         BP    LABEL\n         CLC   BUFF4(8),CONST4\n         BH    ERROR1\nLABEL    STD   FPR0,BUFF2\n         L     R0,BUFF2+4\n         X     R0,CONST1+4\n         SD    FPR0,CONST1\n         CD    FPR0,BUFF4\n         BNHR  R14\n         BCTR  R0,R14\nERROR1   LR    R13,R12\n         B     FSAERR+1*4(R12)\n*\n*        INTERNAL CONSTANTS AND STORAGE\n*\n         DC    0D'0'\nCONST1   DC    X'4E00000080000000'\nCONST2   DC    X'4080000000000000'\nBUFF2    DC    D'0'\nBUFF3    DC    D'0'\nCONST4   DC    X'C880000000000000'\nBUFF4    DC    D'0'\nCONST3   DC    X'48800000'\n*\n*        DCB SYNAD EXIT\n*\n*        EXIT - NORMAL - BRANCH ERROR UNRECOVERABLE I/O ERROR\n*\nIHIIORER LR    R7,R15\n         USING IHIIORER,R7\n         OI    DSF+1,DSIOERR           SET MARK FOR CORRECT CLOSE\n         LR    R13,R12\n         B     FSAERR+32*4(R12)        I/O ERROR\n*\n*\nDCBMODEL DCB   DSORG=PS,MACRF=(RP,WP),DDNAME=ALGLDD,NCP=1,             X\n               EODAD=IHIIORED,                                         X\n               EXLST=ADCBEXIT,                                         X\n               SYNAD=IHIIORER\n*\nDCBMODLN EQU   *-DCBMODEL              LENGTH OF DCBMODEL FOR MVC\n*\n         DC    0F'0'\nADCBEXIT DC    X'05'                   DCB OPEN EXIT REQUESTED\n         DC    AL3(IHIIORDX)           OPEN EXIT ROUTINE ADDR\n         DC    X'87',AL3(0)            JFCB ADDR UPDATED WHEN GETMAINED\n*\nDWORD    DC    D'0'                    WORK AREA FOR DSN\nSAVAR    DC    18F'0'\nEXERFLAG DC    X'00'\n*\n*        INTERNAL ADDRS\n*\nVIORCN   DC    A(IHIIORCN)\nVIOREN   DC    A(IHIIOREN)\nVIORNX   DC    A(IHIIORNX)\n*\n         LTORG\n*\n*        SEE GC28-6615 ALGOL LANGUAGE P82 FOR A DETAILED DESCRIPTION\n*        OF THE DSTABLE FIELDS MAINTAINED FOR EACH DATASET\n*\n         DSTABLE  DSECT=YES\n*\n*        SYMBOLIC NAMES FOR DCB\n*\n         PRINT NOGEN\n*\n         DCBD  DSORG=BS,DEVD=DA\n*\n         PRINT GEN\n*\n*        DECB\n*\n         READ  DECB,SF,MF=L\n*\nJFCB     DS    22D\n         ORG   JFCB\n*\n         IEFJFCBN ,                    MAP THE JFCB\n*\nJFCB_LEN EQU   *-JFCB\n*\n*        CALCULATE TOTAL GETMAINED AREA FOR DCBAREA WITH DECB AND JFCB\n*\nDCBAREAL EQU   *-IHADCB\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\nFPR0     EQU   0\n*\n         END\n./ ADD NAME=IHIISY   0201-12230-12230-1200-00152-00152-00000-LEVEL\nISY      TITLE 'IHIISYMB, INSYMBOL, ALGOL F LIBRARY'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        COMPARE ONE CHARACTER FROM AN INPUT BUFFER WITH AN\n*        INTERNAL STRING AND ASSIGN WHEN CORRESPONDENCE POSITION\n*        NUMBER IN STRING TO THIRD ACTUAL PARAMETER\n*\n*        ENTRY POINT - IHIISYMB - FROM GENERATED OBJECT MODULE\n*                      LA   R1,PARMLIST\n*                      BALR R14,R15\n*                      DATA PASSED BY NAME\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES -\n*        IHIIOR - EVALUATE DATASET NUMBER\n*               - OPEN DATASET\n*               - CHANGE TO NEXT INPUT RECORD\n*\n*        EXITS - NORMAL - RELOAD REGISTERS AND RETURN VIA R14\n*              - ERROR  - INPUT REQUEST BEYOND END OF DATASET NO 5\n*                         BRANCH TO FSA\n*                         LA   R13,IHIFSA\n*                         B    FSAERR+XX*4(R13) XX ERROR NUMBER\n*\n*        TABLES/WORK AREAS - N/A\n*\nIHIISYMB CSECT\n*\n*        GENERAL REGISTER USAGE\n*\n*        R5                            -> DSTABLE ENTRY\n*        R6                            DATASET NUMBER\n*        R3                            -> DESTINATION\n*        R4                            -> STRING SYMBOL\n*        R9                            -> END OF STRING\n*        R10                           CHARACTER POINTER\n*        R8                            INCREMENT FOR LOOP\n*        R12                           -> FSA\n*\n*        DISPLACEMENTS IN ADRLST IN IHIFSA\n*\nCI       EQU   0                       IHIIORCI\nCL       EQU   4                       IHIIORCL\nEV       EQU   8                       IHIIOREV\nNX       EQU   12                      IHIIORNX\nOP       EQU   16                      IHIIOROP\nOQ       EQU   20                      IHIIOROQ\n*\n         SAVE  (14,12),,'IHIISYMB LEVEL 2.1 &SYSDATE &SYSTIME'\n         LR    R7,R15\n         USING IHIISYMB,R7\n         LR    R12,R13                 R12 -> FSA\n         LA    R13,SAVEAREA            CHAIN SAVE AREAS\n         ST    R12,SAVEAREA+4\n         ST    R13,8(,R12)\n*\n*        EVALUATE DATASET NUMBER (EVDSN)\n*\n         L     R15,IORLST(,R12)\n         L     R15,EV(,R15)\n         BALR  R14,R15                 CALL IHIIOREV\n         L     R4,4(,R1)               R4 - STRING\n         L     R3,8(,R1)               R3 -> DESTINATION\n         LA    R8,1                    INCREMENT\n*\n*        TEST IF DATASET IS OPEN\n*\n         USING DSTABLE,R5\n         NI    DSF+1,255-DS10          SET DS10 = 0\n         CLI   Q,0                     DATASET SECTIONED ?\n         BNE   ERROR2                  INCOMPATIBLE ACTION\n         LR    R10,R6                  DATASET NO = 1 ?\n         BCT   R10,SYMBBB              NO, BRANCH\n         B     ERROR2                  INCOMPATIBLE ACTION\n*\nSYMBBB   TM    DSF,DS0                 DATASET OPEN ?\n         BZ    SYMBDD                  NO, BRANCH\n*                                      DATASET IS OPEN\nSYMBCC   TM    DSF,DS2                 LAST I/O OUTPUT ?\n         BZ    SYMBEE\n         B     ERROR3                  INPUT BEYOND LAST OUTPUT\n*\nSYMBEE   TM    DSF,DS6                 OPEN FOR OUTPUT OR EOD ?\n         BZ    EVSYMB\n         TM    DSF,DS7                 END OF DATA BEEN REACHED ?\n         BO    ERROR5                  INPUT RQUEST BEYOND END OF DATA\n         B     ERROR2\n*\nSYMBDD   NI    DSF,255-DS6             SET DS6 = 0\n         L     R15,IORLST(,R12)\n         L     R15,OP(,R15)            R15 -> IHIIOROP\n         BALR  R14,R15                 CALL IHIIOROP TO OPEN DATASET\n*\nEVSYMB   LH    R9,0(,R4)               LENGTH OF STRING\n         BCTR  R9,0\n         AR    R9,R4                   STRING-END LESS 1\n         LA    R4,2(,R4)               -> STRING-SYMBOL\n         L     R10,R                   CHARACTER POINTER\nSYMBLOOP CLC   0(1,R10),0(R4)\n         BE    TERMINBB\n         BXLE  R4,R8,SYMBLOOP\n         SR    R4,R4                   ZERO INSERTED R4\n         B     TERMINAA\n*\nTERMINBB S     R4,4(,R1)\n         BCTR  R4,0\nTERMINAA ST    R4,0(,R3)               NUMBER OF SYMBOL INSERTED\n*                                      DESTINATION\nTERMIN   LA    R10,1(,R10)\n         C     R10,RE\n         BNL   NEXTREC\n         ST    R10,R\nTERMINCC LR    R13,R12\n*\n         RETURN (14,12)                RESTORE CALLERS REGS AND RETURN\n*\nNEXTREC  L     R15,IORLST(,R12)\n         L     R15,NX(,R15)            R15 -> IHIIORNX\n         BALR  R14,R15                 GET NEXT RECORD\n         B     TERMINCC\n*\nERROR2   LR    R13,R12\n         B     FSAERR+2*4(R12)         INCOMPATIBLE ACTION ON DATASET\n*\nERROR3   LR    R13,R12\n         B     FSAERR+3*4(R12)         INPUT BEYOND LAST OUTPUT\n*\nERROR5   LR    R13,R12\n         B     FSAERR+5*4(R12)         INPUT REQUEST BEYOND END OF DATA\n*\nSAVEAREA DC    18F'0'                  SAVE AREA\n*\n         LTORG\n*\n         DSTABLE DSECT=YES\n*\nFAS      DSECT\n*\n         COPY  FSAREA\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHILAT   0201-12230-12230-1200-00124-00124-00000-LEVEL\nTAN      TITLE 'IHILATAN, ATAN LONG PRECISION, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION-\n*        1. REDUCE THE CASE TO THE 1ST OCTANT BY USING\n*           ATAN(-X) = -ATAN(X), ATAN(1/X) = PI/2-ATAN(X)\n*        2. REDUCE FURTHER TO THE CASE /X/ LESS THAN TAN(PI/2) BY\n*           ATAN(X)=PI/6+ATAN((X*SQRT3-1)/(X+SQRT3)\n*        3. FOR THE BASIC RANGE (X LESS THAN TAN(PI/12)),\n*           USE A FRACTIONAL APPROXIMATION\n*\n*        ENTRY POINT -\n*        IHILAT - ATAN FUNCTION, LONG\n*                 LA   R1,PARMLIST\n*                 BALR R14,R15\n*                 DATA PASSED BY NAME\n*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        EXIT - NORMAL -\n*        RETURN VIA R14, RESULT IN FPR0\n*\n*        EXIT - ERROR - N/A\n*\n*        TABLES/WORKAREAS - N/A\n*\nIHILATAN CSECT\n*\n         ENTRY IHILAT\n*\nFPR0     EQU   0                       RESULT REGISTER\nFPR2     EQU   2                       SCRATCH REGISTERS\nFPR4     EQU   4\nFPR6     EQU   6\n*\nIHILAT   SAVE  (14,12),,'IHILATAN LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHILATAN,R15\n         L     R1,0(,R1)\n         LD    FPR0,0(,R1)             OBTAIN ARGUMENT\n         STE   FPR0,SIGN               SAVE ARG FOR SIGN CONTROL\n         LPER  FPR0,FPR0               SET SIGN POSITIVE\n         SR    R1,R1                   R1 FOR DISTINGUISHING CASES\n         CE    FPR0,ONE\n         BL    SKIP1\n         LD    FPR2,ONE                IF X > 1, TAKE INVERSE\n         DDR   FPR2,FPR0\n         LDR   FPR0,FPR2\n         LA    R1,16                   INCR R1 BY 16\nSKIP1    CE    FPR0,TAN15\n         BNH   SKIP2\n         LDR   FPR2,FPR0               IF X >TAN(PI/12),\n         MD    FPR0,RT3M1             REDUCE X TO (X*SQRT3-1)/(X+SQRT3)\n         SD    FPR0,HALF\n         SD    FPR0,HALF               COMPUTE X*SQRT3-1 AS\n         ADR   FPR0,FPR2               X*(SQRT3-1)-0.5-0.5+X\n         AD    FPR2,RT3                TO GAIN ACCURACY\n         DDR   FPR0,FPR2\n         LA    R1,8(,R1)               INCR R1 BY 8\nSKIP2    LDR   FPR6,FPR0               COMPUTE ATAN OF REDUCED\n         MDR   FPR0,FPR0               ARGUMENT BY\n         LDR   FPR2,FPR0               ATAN(X) = X(1+F*XSQ)\n         AD    FPR2,BETA4\n         LD    FPR4,ALPHA4             F = A1/(B1+XSQ+A2/(B2+XSQ+A3\n         DDR   FPR4,FPR2                    /(B3+XSQ+A4/(B4+XSQ))..)\n         ADR   FPR4,FPR0\n         AD    FPR4,BETA3\n         LD    FPR2,ALPHA3\n         DDR   FPR2,FPR4\n         ADR   FPR2,FPR0\n         AD    FPR2,BETA2\n         LD    FPR4,ALPHA2\n         DDR   FPR4,FPR2\n         ADR   FPR4,FPR0\n         AD    FPR4,BETA1\n         LD    FPR2,ALPHA1\n         DDR   FPR2,FPR4\n         MDR   FPR0,FPR2\n         MDR   FPR0,FPR6\n         ADR   FPR0,FPR6\n         C     R1,KF16                 DEPENDING ON THE CASE EITHER ADD\n         BL    SKIP3                   0 OR PI/6 OR SUBTRACT FROM PI/3\n         LCER  FPR0,FPR0               OR PI/2.  DO LATTER IN 2 STEPS\n         AD    FPR0,PO2M1-16(R1)\nSKIP3    AD    FPR0,ZERO(R1)\n         TM    SIGN,X'80'              SIGN NEGATIVE ?\n         BZ    SKIP4                   YES, ANSWER IS NEGATIVE\n         LCER  FPR0,FPR0\nSKIP4    BR    R14                     RETURN\n*\nSIGN     DC    F'0'\n         DC    0D'0'\nRT3M1    DC    X'40BB67AE8584CAA8'      SQRT(3)-1\nRT3      DC    X'411BB67AE8584CAB'      SQRT(3)\nALPHA1   DC    X'C0D5F788DF6CB457'       -0.8358083291502266\nBETA1    DC    X'414D42F041242098'        4.828842405755528\nALPHA2   DC    X'C1DD6E91F2AD24DF'      -13.839494655565710\nBETA2    DC    X'4168C2DCB9C0437F'        6.547573781576119\nALPHA3   DC    X'C1138256FCDD5CB6'       -1.219321239235610\nBETA3    DC    X'41224D09A3EFF7AC'        2.143808021908152\nALPHA4   DC    X'C0145A9C5C07FB43'       -0.07950761076788829\nBETA4    DC    X'4114451896975D03'        1.266869152304765\nPO2M1    DC    X'40921FB54442D184'       90 DEGREES MINUS ONE\n         DC    X'408C152382D73658'       60 DEGREES MINUS HALF\nZERO     DC    D'0'                     0\n         DC    X'40860A91C16B9B2D'      30 DEGREES\nONE      DC    X'4110000000000000'\nHALF     DC    X'4080000000000000'\nTAN15    DC    X'40449851'\nKF16     DC    F'16'\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHILEX   0201-12230-12230-1200-00154-00154-00000-LEVEL\nLEX      TITLE 'IHILEXPT, EXPONENTIAL, LONG PRECISION, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        Y = X*LOG2(E) = 4A-B-C/16-D\n*        WHERE A, B, AND C ARE INTEGERS\n*        B BETWEEN 0 AND 3\n*        C BETWEEN 0 AND 15\n*        D IS A FRACTION BETWEEN 0 AND 1/16\n*         THEN\n*        E**X = 2**Y = (16**A)(2**-B)N2**-C/16)(2**-D)\n*\n*        ENTRY POINT -\n*        IHILEX - EXP FUNCTION, LONG\n*                 LA   R1,PARMLIST\n*                 BALR R14,R15\n*        DATA PASSED BY NAME\n*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        EXIT - NORMAL -\n*        RETURN VIA R14, RESULT IN FPR0\n*\n*        EXIT - ERROR -\n*        IF ARGUMENT GREATER THAN 174673 GOTO ERROR ROUTINE VIA\n*        B FSAERR+24*4(R13)\n*\n*        TABLES/WORKAREAS - N/A\n*\nIHILEXPT CSECT\n*\n         ENTRY IHILEX\n*\nFPR0     EQU   0                       RESULT REGISTER\nFPR2     EQU   2                       SCRATCH REGISTER\n*\nIHILEX   SAVE  (14,12),,'IHILEXPT LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHILEXPT,R15\n         L     R1,0(,R1)               OBTAIN ARGUMENT\n         LD    FPR0,0(,R1)\n         CE    FPR0,MAX                MAX = 63*LOG16 = 174.67309\n         BH    ERROR                   ARG > MAX, ERROR\n         CE    FPR0,MIN                MIN = -65*LOG16 = -180.21867\n         BNH   SMALL                   ARG < MIN, GIVE ANS=0\n         DD    FPR0,LOGE2              Y = X*LOG2(E) BY ACCURATE DIVIDE\n         STE   FPR0,SIGN               SAVE SIGN OF Y\n         LER   FPR2,FPR0               DECOMPOSE Y = (-4A'-B'-C'/16)-D'\n         AU    FPR2,SCALER             BY FORCING CHARACTISTIC OF X'45'\n         STE   FPR2,FIELDS             -4A'-B'-C'/16 IN FIELDS,\n         SDR   FPR2,FPR2               UNNORMALIZED\n         AE    FPR2,FIELDS             NORMALIZE THIS AND SUBTRACT IT\n         SDR   FPR0,FPR2               FROM Y TO OBTAIN -D' IN FPR0\n         L     R2,FIELDS\n         TM    SIGN,X'80'              Y NEGATIVE ?\n         BO    READY                   YES, BRANCH\n*                                      Y NON-NEGATIVE,\n         SD    FPR0,ONO16              -D = /D'/-1/16\n         LA    R2,1(,R2)              -4A-B-C/16 = -(-4A'-B'-(C'+1)/16)\n         LCR   R2,R2                   NOW IN ANY CASE, B, C,\nREADY    SR    R3,R3                   AND D ARE POSITIVE\n         SRDL  R2,4                    C IN HIGH R3\n         SRL   R3,25\n         SRDL  R2,2                    B IN HIGH R3, C IN LOW R3\n         SLL   R2,24\n         LCR   R0,R2                   A (IN SCALE B7) IN R0,\n         SR    R2,R2                   CHAR MODIFIER\n         SLDL  R2,2                    B IN R2, 8*C IN R3\n         LDR   FPR2,FPR0               COMPUTE 2**-D BY USE OF\n         ME    FPR0,C6                 CHEBYSHEV INTERPOLATION\n         AD    FPR0,C5                 POLYNOMIAL OF DEGREE 6\n         MDR   FPR0,FPR2\n         AD    FPR0,C4\n         MDR   FPR0,FPR2\n         AD    FPR0,C3\n         MDR   FPR0,FPR2\n         AD    FPR0,C2\n         MDR   FPR0,FPR2\n         AD    FPR0,C1\n         MDR   FPR0,FPR2\n         AD    FPR0,C0A                ADD C0 = 1. IN 2 STEPS\n         AD    FPR0,C0A                TO PROTECT LAST DIGIT\n         LTR   R3,R3                   MULTIPLY 2**(-C/16)\n         BZ    SKIP2                   IN DOING SO, AVOID\n         CE    FPR0,ONE                MULTIPLICATION BY 1\n         BL    SKIP1\n         LD    FPR0,MCONST-8(R3)\n         B     SKIP2\n*\nSKIP1    MD    FPR0,MCONST-8(R3)\nSKIP2    LTR   R2,R2                   MULTIPLY 2**(-B)\n         BZ    SKIP3                   BY HALVING B TIMES\nSKIP3A   HDR   FPR0,FPR0\n         BCT   R2,SKIP3A\nSKIP3    STD   FPR0,SIGN               ADD A TO CHARACTERISTIC\n         A     R0,SIGN\n         ST    R0,SIGN\n         SDR   FPR0,FPR0               NORMALIZE ANSWER JUST IN CASE\n         AD    FPR0,SIGN\n*\nEXIT     RETURN (14,12)                RETURN\n*\nSMALL    SDR   FPR0,FPR0               IF X IS VERY LARGE NEGATIVE,\n         B     EXIT                    GIVE 0 AS ANSWER\n*\nERROR    L     R13,4(R13)              RESTORE FSA ADDR\n         B     FSAERR+24*4(R13)        PARAM GREATER 174.673\n*\nFSAERR   EQU   X'1CC'\n*\nSIGN     DC    D'0'\nFIELDS   EQU   SIGN+4\nLOGE2    DC    X'40B17217F7D1CF79'     LOG 2 (BE) TRUNCATED\nONO16    DC    X'4010000000000000'\nONE      DC    X'41100000'\nC6       DC    X'3D9E0F1E'             .1507368551403575E-3\nC5       DC    X'3E575D42BB7276D4'     .1333073417706260E-2\nC4       DC    X'3F276553A5F9BC94'     .9618117095313700E-2\nC3       DC    X'3FE35846A61AEE7A'     .5550410840231345E-1\nC2       DC    X'403D7F7BFF0289DE'     .2402265069563678\nC1       DC    X'40B17217F7D1CC79'     .6931471805599346\nC0A      DC    X'4080000000000000'     .5    C0/2\nMCONST   DC    X'40F5257D152486CC'     2**(-1/16)\n         DC    X'40EAC0C6E7DD2439'     2**(-2/16)\n         DC    X'40E0CCDEEC2A94E1'     2**(-3/16)\n         DC    X'40D744FCCAD69D6B'     2**(-4/16)\n         DC    X'40CE248C151F8481'     2**(-5/16)\n         DC    X'40C5672A115506DB'     2**(-6/16)\n         DC    X'40BD08A39F580C37'     2**(-7/16)\n         DC    X'40B504F333F9DE65'     2**(-8/16)\n         DC    X'40AD583EEA42A14B'     2**(-9/16)\n         DC    X'40A5FED6A9B15139'     2**(-10/16)\n         DC    X'409EF5326091A112'     2**(-11/16)\n         DC    X'409837F0518DB8A9'     2**(-12/16)\n         DC    X'4091C3D373AB11C3'     2**(-13/16)\n         DC    X'408B95C1E3EA8BD7'     2**(-14/16)\n         DC    X'4085AAC367CC487B'     2**(-15/16)\nSCALER   DC    X'45000000'\nMAX      DC    X'42AEAC4E'             174.6731\nMIN      DC    X'C2B437DF'             -180.2187\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHILLO   0201-12230-12230-1200-00126-00126-00000-LEVEL\nLLO TITLE 'IHILLOGM, LOGARITHMIC FUNCTION, LONG PRECISION, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        WRITE X = (16**P)*(2**-Q)*M\n*        Q BETWEEN 0 AND 3\n*        AND M BETWEEN 1/2 AND 1\n*        DEFINE A=1, B=0\n*        IF M IS > SQRT2/2, OTHERWISE A=1/2, B=1\n*        WRITE Z = (M-A)/(M+A), THEN\n*        LOG(X) = (4P-Q-B)*LOG(2) + LOG((1+Z)/(1-Z))\n*\n*        ENTRY POINT -\n*        IHILLO - LOG FUNCTION, LONG\n*                 LA   R1,PARMLIST\n*                 BALR R14,R15\n*                 DATA PASSED BY NAME\n*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0\n*\n*        EXIT - ERROR -\n*        IF ARGUMENT ZERO OR NEGATIVE GOTO ERROR ROUTINE VIA\n*        B   FSAERR+25*4(R13)\n*\n*        TABLES/WORKAREAS - N/A\n*\nIHILLOGM CSECT\n*\n         ENTRY IHILLO\n*\nFPR0     EQU   0                       RESULT REGISTER\nFPR2     EQU   2                       SCRATCH REGISTER\n*\nIHILLO   SAVE  (14,12),,'IHILLOGM LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHILLOGM,R15\n         L     R1,0(,R1)               OPTAIN ARGUMENT IN R0,R1\n         LM    R0,R1,0(R1)\n         LTR   R2,R0\n         BNP   ERROR                   0 OR NEGATIVE, ERROR\n         SRDL  R2,24                   CHAR IN LOW R2\n         SLL   R2,2                    FIRST DIGIT IN HIGH R3\n         STH   R2,IPART+2              FLOAT 4*CHAR AND SAVE IT\n         SR    R2,R2\n         SLDL  R2,4                    FIRST DIGIT IN R2\n         IC    R2,TABLE(R2)            NO OF LEADING ZEROS (=Q) IN R2\n         SLDL  R0,0(R2)\n         STM   R0,R1,BUFF\n         MVI   BUFF,X'40'              M = FRACTION*2**Q  IN CELL BUFF\n         LA    R1,8\n         LD    FPR0,BUFF               PICK UP M IN FPR0\n         CE    FPR0,LIMIT              M > SQRT2/2, R1=8 ?\n         BH    READY                   YES, BRANCH\n         SR    R1,R1                   M < SQRT2/2, R1=0,\n         LA    R2,1(,R2)               CRANK R2 BY 1, Q+B IN R2\nREADY    LDR   FPR2,FPR0               Z = (M-A)/(M+A),  A = 1 OR 1/2\n         SD    FPR0,HALF               SUBTRACT A IN 2 STEPS TO PROTECT\n         SD    FPR0,ZERO(R1)           THE LAST DIGIT\n         AD    FPR2,HALF(R1)           M+A HAS ONLY 53BITS. NOT SERIOUS\n         DDR   FPR0,FPR2\n         STD   FPR0,BUFF\n         MDR   FPR0,FPR0               COMPUTE LOG((1+Z)/(1-Z))\n         LDR   FPR2,FPR0               BY CHEBYSHEV INTERPOLATION\n         MD    FPR2,C7                 POLYNOMIAL (IN ZSQ) OF DEGREE 7\n         AD    FPR2,C6\n         MDR   FPR2,FPR0\n         AD    FPR2,C5\n         MDR   FPR2,FPR0\n         AD    FPR2,C4\n         MDR   FPR2,FPR0\n         AD    FPR2,C3\n         MDR   FPR2,FPR0\n         AD    FPR2,C2\n         MDR   FPR2,FPR0\n         AD    FPR2,C1\n         MDR   FPR2,FPR0             F = ZSQ*(C1+ZSQ*(C2+...+ZSQ*C7)..)\n         LD    FPR0,BUFF               LOG((1+Z)/(1-Z)) = Z*(2+F)\n         MDR   FPR2,FPR0                                = Z+Z+Z*F\n         ADR   FPR2,FPR0               TO GAIN ACCURACY\n         ADR   FPR2,FPR0\n         LD    FPR0,IPART              4*CHARACTERISTIC IN FPR0\n         LA    R2,256(,R2)             ADD 4*(BASE CHARAC=64) TO Q+B\n         STH   R2,IPART+2              FLOAT THIS AND SUB FROM FPR0\n         SE    FPR0,IPART              TO OBTAIN 4P-Q-B\n         MD    FPR0,LOGE2              MULTIPLY LOG(2) BASE E\n         ADR   FPR0,FPR2               AND ADD TO LOG((1+Z)/(1-Z))\n*\n         RETURN (14,12)                RETURN\n*\nERROR    B     FSAERR+25*4(R13)        PARAMETER \u00ac> ZERO\n*\nFSAERR   EQU   X'1CC'\n*\nBUFF     DC    D'0'\nIPART    DC    X'4600000000000000'\n*\nTABLE    DC    X'0303020201010101'   * THESE 4\nZERO     DC    X'0000000000000000'   | CONSTANTS\nHALF     DC    X'4080000000000000'   | MUST BE\n         DC    X'4110000000000000'   V TOGETHER\n*\nC7       DC    X'4025E9B17CA9B973'     .1480971268990510\nC6       DC    X'40273337E26DBA7F'     .1531252792171731\nC5       DC    X'402E8CD32A425C06'     .1818363168880382\nC4       DC    X'4038E38A00083F6B'     .2222219705656678\nC3       DC    X'4049249251450212'     .2857142876064318\nC2       DC    X'40666666665EBAA3'     .3999999999930233\nC1       DC    X'40AAAAAAAAAAAD6C'     .666666666666764\nLOGE2    DC    X'40B17217F7D1CF7B'     LOG 2 (BE) + 1 IN LAST DGT\nLIMIT    DC    X'40B504F3'             1/SQRT 2\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHILOR   0201-12230-12230-1200-00294-00294-00000-LEVEL\nLOR      TITLE 'IHILOREA, OUTREAL LONG PRECISION, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        CONVERT BINARY ARITHMETIC VALUE, FROM SECOND ACTUAL\n*        PARAMETER, TO ZONED DECIMAL FORM AND TRANSFER TO AN\n*        OUTPUT BUFFER\n*\n*        ENTRY POINTS -\n*        IHILOREL - FROM GENERATED OBJECT MODULE\n*                   LA   R1,PARMLIST\n*                   BALR R14,R15\n*                   DATA PASSED BY NAME\n*        IHILORAR - FROM ARRAY MODULE IHIOAR\n*                   LA   R7,DATA\n*                   BALR R14,R15\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES -\n*        IHIIOR - EVALUATE DATA SET NUMBER\n*               - OPEN DATASET\n*               - CHANGE TO NEXT OUTPUT RECORD\n*        IHIFSA - CNVIRD - CONVERT INTEGER TO REAL LONG\n*        IHIPTT - POWER OF TEN TABLE LONG PREC\n*\n*        EXIT - NORMAL - RELOAD REGISTERS AND RETURN VIA R14\n*\n*        EXIT - ERROR - TOO LONG RECORD NO 38\n*                       BRANCH TO IHIFSA\n*                       L    R13,IHIFSA\n*                       B    FSAERR+XX*4(R13) XX ERROR NO\n*\n*        TABLES/WORK AREAS - N/A\n*\nIHILOREA CSECT\n*\n         ENTRY IHILOREL\n         ENTRY IHILORAR\n*\n         USING DSTABLE,R5\n*\nFPR0     EQU   0                   FLOATING POINT NUMBER\n*\n*        R5                            -> DSTABLE ENTRY\n*        R7                            -> SOURCE\n*        R4                            =  CHARACTER POINTER\n*        R8                            =  BLANK COUNTER\n*        R2                               EXPONENT > EIGHT\n*        R3                               EXPONENT < EIGHT\n*        R9                               DECIMAL EXPONENT\n*        R8                               BLANK COUNTER\n*        R15                           -> POWER TEN TABLE\n*\n*        DISPLACEMENTS IN ADRLST IN IHIFSA\n*\nCI       EQU   0             DISPLACEMENT FOR - IHIIORCI\nCL       EQU   4                                IHIIORCL\nEV       EQU   8                                IHIIOREV\nNX       EQU   12                               IHIIORNX\nOP       EQU   16                               IHIIOROP\nOQ       EQU   20                               IHIIOROQ\n*\nIHILORAR SAVE  (14,12),,'IHILORAR LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHILORAR,R15\n         LR    R10,R13                 CHAIN SAVE AREAS\n         LA    R13,SAVEAREA\n         ST    R10,4(,R13)\n         ST    R13,8(,R10)\n         LA    R10,COMMON\n         DROP  R15\n         USING COMMON,R10\n         B     SOUFLPA\n*\n         DROP  R10\n*\nIHILOREL SAVE  (14,12),,'IHILOREL LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHILOREL,R15\n         LR    R12,R13                 R12 -> FSA\n         LA    R13,SAVEAREA\n         ST    R12,4(,R13)\n         ST    R13,8(,R12)\n         LA    R10,COMMON\n         DROP  R15\n         USING COMMON,R10\n*\n*        EVALUATE DATASET NUMBER (EVDSN)\n*\nCOMMON   L     R15,IORLST(,R12)\n         L     R15,EV(,R15)\n         BALR  R14,R15\nSOUFLP   L     R7,4(,R1)               R7 -> SOURCE\nSOUFLPA  OI    DSF,DS2+DS3             DS2, DS3 = 1\n         NI    DSF,255-DS7             DS7 = 0\n         LTR   R7,R7\n         BP    REAL1\n*\n*        CALL CONVERSION ROUTINE (LOADED IN FSA)\n*\n         STM   R14,R13,8(R13)          SAVE REGS\n         LR    R2,R13                  R2 -> SAVEAREA\n         L     R14,0(,R7)              INTEGER INTO R14\n         LA    R7,ACNVIRD(R12)\n         LR    R13,R12                 R13 -> FSA\n         BALR  R8,R7\n         LM    R14,R13,8(R2)           RESTORE REGS\n         B     REAL1A                  NUMBER IN FPRO AFTER CONVERSION\n*\nREAL1    LD    FPR0,0(,R7)             NUMBER IN FPR0\nREAL1A   TM    DSF,DS0                 DATASET OPEN ?\n         BO    NOCLO                   YES, BRANCH\n         OI    DSF,DS6                 DS6 = 1 OPEN FOR OUTPUT\n         L     R15,IORLST(,R12)\n         L     R15,OP(,R15)\n         BALR  R14,R15\nNOCLO    L     R4,R                    CHARACTER POINTER\n         LA    R8,22(,R4)\n         C     R8,RE                   BUFFER CAN ACCEPT 22 DIGITS ?\n         BNH   NONEXREC                YES, BRANCH\n         L     R8,RE\n         SR    R8,R4\n         BNP   CALLNXT                 NO, REQUEST NEW RECORD\nBLANKS   MVI   0(R4),C' '              BLANK IN BUFFER\n         LA    R4,1(,R4)               INCR R\n         BCT   R8,BLANKS\nCALLNXT  L     R15,IORLST(,R12)\n         L     R15,NX(,R15)\n         BALR  R14,R15                 GET NEXT RECORD\n         L     R4,R\n         LA    R8,22(,R4)\n         C     R8,RE\n         BH    ORLERR                  TOO SHORT RECORD LENGTH\n         OI    DSF,DS3\nNONEXREC LA    R9,16\n         LTDR  FPR0,FPR0               NUMBER IS ZERO ?\n         BNZ   NOT0                    NO, BRANCH\n         MVI   0(R4),C' '              NUMBER IS ZERO\n         MVC   1(21,R4),0(R4)\n         MVI   1(R4),C'0'\n         B     TERMIN\n*\nNOT0     MVI   0(R4),C'+'              ZONE IS INSERTED\n         BP    EXPLOOP\n         MVI   0(R4),C'-'\n         LCDR  FPR0,FPR0\nEXPLOOP  STD   FPR0,CHAR\n         SR    R3,R3\n         IC    R3,CHAR\n         MVI   SE,0\n         S     R3,KF78\n         BP    EXPLOAA\n         BZ    EXP0                    EXPONENT = 78\n         MVI   SE,X'80'\n         LCR   R3,R3\nEXPLOAA  MH    R3,LOG2\n         AH    R3,ROUND\n         SRL   R3,14\n         C     R3,KF78\n         BNH   EXPLOBB\n         L     R3,KF78                 EXPONENT = 78\nEXPLOBB  TM    SE,X'80'\n         L     R15,VPTTAB              R15 -> POWER TEN TABLE\n         BZ    EXPLOCC\n         SR    R9,R3\n         B     EXPLODD\n*\nEXPLOCC  LA    R15,128(,R15)\n         AR    R9,R3\nEXPLODD  LR    R2,R3\n         SR    R3,R3                   CLEAR REGISTER\n         SRDA  R2,3\n         SLA   R2,3\nTESTEXP1 BZ    EXP1LS8\n         C     R2,KF72\n         BL    EXP1LS8A                EXPONENT NEGATIVE\n         MD    FPR0,128(,R15)\n         S     R2,KF72\n         B     TESTEXP1\n*\nEXP1LS8A MD    FPR0,56(R2,R15)\nEXP1LS8  SRL   R3,26                   EXPONENT MULTIPLIED EIGHT\n         LTR   R3,R3\n         BZ    EXPLOOP\n         MD    FPR0,0(R3,R15)\n         B     EXPLOOP\n*\nEXP0     CD    FPR0,TENP16             NUMBER >= 10**16 ?\n         BNL   DIG17                   YES, BRANCH\nEXP0AA   MVI   CHAR,0\n         LM    R2,R3,CHAR\n         D     R2,TENP9I\n*\n*        TRANSFORM NUMBER TO DECIMAL FORM\n*        EDIT OUTPUT NUMBER IN I/O BUFFER\n*\n         CVD   R3,BUFF                 QUOTE CONVERTED\n         UNPK  1(9,R4),BUFF+3(5)\n         OI    9(R4),X'F0'\n         CVD   R2,BUFF\n         UNPK  10(9,R4),BUFF+3(5)\n         OI    18(R4),X'F0'\n         CLI   2(R4),C'0'              LEADING ZERO ?\n         BNE   TRANSAA\n         BCTR  R9,0\n         MVC   2(16,R4),3(R4)\nTRANSAA  MVC   1(1,R4),2(R4)\n         MVI   2(R4),C'.'              DECIMAL POINT INSERTED\n         MVI   18(R4),C''''            APOSTROPHE INSERTED\nDECEXP   CVD   R9,BUFF\n         UNPK  19(3,R4),BUFF+6(2)\n         LTR   R9,R9\n         BNM   DECEXPAA\n         MVI   19(R4),C'-'             EXPONENT SIGN IS NEGATIVE\n         B     DECEXPBB\n*\nDECEXPAA MVI   19(R4),C'+'\nDECEXPBB OI    21(R4),X'F0'            ZONE INSERTED EXPONENT\n*\n*        TERMINATION ROUTINE INSERT BLANKS\n*        IF RECORD END CALL NEXTREC\n*\nTERMIN   LA    R4,22(,R4)\n         SR    R8,R8\n         IC    R8,K\nTERMINAA C     R4,RE\n         BE    RECEND\n         MVI   0(R4),C' '\n         LA    R4,1(,R4)\n         BCT   R8,TERMINAA\n         C     R4,RE\n         BE    RECEND\n         ST    R4,R\nTERMINBB L     R13,SAVEAREA+4\n*\n         RETURN (14,12)\n*\nRECEND   L     R15,IORLST(,R12)\n         L     R15,NX(,R15)\n         BALR  R14,R15\n         B     TERMINBB\n*\n*        NUMBER >= 10**16\n*\nDIG17    AW    FPR0,FIVE\n         STD   FPR0,CHAR\n         CD    FPR0,TWOP56B\n         BL    EXP0AA\n         MVC   1(18,R4),TWOP56         NUMBER > 16**14\n         B     DECEXP\n*\nORLERR   LR    R13,R12\n         B     FSAERR+38*4(R12)\n*\nVPTTAB   DC    V(IHIPTTAB)\n*\nACNVIRD  EQU   X'120'\n*\n*        CONSTANTS AND STORAGE\n*\nSAVEAREA DC    18F'0'\n*\nKF72     DC    F'72'\nKF78     DC    F'78'\nLOG2     DC    H'19728'\nROUND    DC    H'8192'\nTENP9I   DC    F'1000000000'\nBUFF     DC    D'0'\nCHAR     DC    D'0'\nFIVE     DC    X'4E00000000000005'\nTWOP56B  DC    X'4F10000000000000'\nTENP16   DC    DE16'1'\nSE       DC    X'00'\nTWOP56   DC    C'7.205759403792794'''\n*\n         LTORG\n*\n         DSTABLE DSECT=YES\n*\nFAS      DSECT\n*\n         COPY  FSAREA\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHILSC   0201-12230-12230-1200-00151-00151-00000-LEVEL\nLSC      TITLE 'IHILSCSN, SINE/COSINE, LONG PRECISION, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        1. DIVIDE MAGNITUDE OF ARG BY PI/4 TO FIND OCTANT AND\n*           FRACTION\n*        2. IF COSINE ADD 2 TO OCTANT NUMBER\n*           IF SINE FOR NEGATIVE ARG, ADD 4 TO OCTANT NUMBER\n*        3. COMPUTE SINE OR COSINE OF FRACTION*PI/4 DEPENDING ON\n*           THE OCTANT\n*        4. IF OCTANT NUMBER IS FOR LOWER PLANE MAKE SIGN MINUS\n*\n*        ENTRY POINTS -\n*        IHILSCC - COSINE FUNCTION, LONG\n*        IHILSCS - SINE FUNCTION, LONG\n*                  LA   R1,PARMLIST\n*                  BALR R14,R15\n*                  DATA PASSED BY NAME\n*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0\n*\n*        EXIT - ERROR -\n*        IF ABS(ARG) \u00ac< PI*2**50 GOTO ERROR ROUTINE VIA\n*                                B    FSAERR+27*4(R13)\n*\n*        TABLES/WORKAREAS - N/A\n*\nIHILSCSN CSECT\n*\n         ENTRY IHILSCC\n         ENTRY IHILSCS\n*\nFPR0     EQU   0                       RESULT REGISTER\nFPR2     EQU   2                       SCRATCH REGISTERS\nFPR4     EQU   4\n*\nIHILSCC  SAVE  (14,12),,'IHILSCC  LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHILSCC,R15\n         LA    R10,COMMON\n         DROP  R15\n         USING COMMON,R10\n         LA    R0,2                    OCTANT CRANK OF 2 TO R0\n         L     R1,0(,R1)               R1 -> ARGUMENT ADDR\n         B     COMMON\n*\n         DROP  R10\n*\nIHILSCS  SAVE  (14,12),,'IHILSCS  LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHILSCS,R15\n         LA    R10,COMMON\n         DROP  R15\n         USING COMMON,R10\n         SR    R0,R0\n         L     R1,0(,R1)               R1 -> ARGUMENT\n         TM    0(R1),X'80'             IF ARG IS +, CRANK OF 0 TO R0\n         BZ    COMMON                  IF ARG IS -, CRANK OF 4 TO R0\n         LA    R0,4\nCOMMON   LD    FPR0,0(,R1)             PICK UP THE ARGUMENT\n         LPER  FPR0,FPR0               FORCE SIGN OF ARG TO +\n         CE    FPR0,MAX                /X/ >= PI*2**50 ?\n         BNL   ERROR                   YES, ERROR\n         DD    FPR0,PIOV4              DIV BY PI/4, SEPARATE INTEGER\n         LDR   FPR2,FPR0               PART AND FRACT PART OF QUOTIENT\n         AW    FPR2,SCALER             FORCE CHARACTERISTIC X'4E'\n         STD   FPR2,ARG                INTEGER PART UNNORMAL = OCTANT\n         SDR   FPR2,FPR2\n         AD    FPR2,ARG                INTEGER PART NORMALIZED\n         SDR   FPR0,FPR2               FRACTION PART TO FPR0\n         AL    R0,ARG+4                ADJUST OCTANT NUMBER WITH CRANK\n         ST    R0,OCTNT                SAVE IT\n         TM    OCTNT+3,X'01'           IF ODD OCTANT, TAKE COMPLEMENT\n         BZ    EVEN                    OF FRACT TO OBTAIN MODIFIED ARG\n         SD    FPR0,HALF\n         SD    FPR0,HALF               SUBTRACT 1 IN 2 STEPS\nEVEN     LPDR  FPR4,FPR0\n         SR    R1,R1                   R1 = 0 FOR COSINE POLYNOMIAL\n         TM    OCTNT+3,X'03'           THIS IS FOR OCTANT 2,3,6, OR 7\n         BM    LABAA                   IF OCTANT 1,4,5, OR 8, USE SINE\n         LA    R1,8                    POLYNOMIAL.   R1 = 8\nLABAA    MDR   FPR0,FPR0               CALC SIN OR COS OF MODIFIED ARG\n         LDR   FPR2,FPR0               USING PROPER CHEBYSHEV\n         MD    FPR0,C7(R1)             INTERPOLATION POLYNOMIAL\n         AD    FPR0,C6(R1)\n         MDR   FPR0,FPR2              SIN(X)/X POLYN OF DEGREE 6 IN XSQ\n         AD    FPR0,C5(R1)            COS(X) POLYN OF DEGREE 7 IN XSQ\n         MDR   FPR0,FPR2\n         AD    FPR0,C4(R1)\n         MDR   FPR0,FPR2\n         AD    FPR0,C3(R1)\n         MDR   FPR0,FPR2\n         AD    FPR0,C2(R1)\n         MDR   FPR0,FPR2\n         AD    FPR0,C1(R1)\n         LTR   R1,R1\n         BZ    COSF\n         MDR   FPR0,FPR4               COMPLETE SIN POLYNOMIAL BY\n         B     SIGN                    MULTIPLYING BY X\n*\nCOSF     MDR   FPR0,FPR2               COMPLETE COS POLYNOMIAL\n         AD    FPR0,HALF               (ONE MORE DEGREE)\n         AD    FPR0,HALF               ADD 1 IN 2 STEPS\nSIGN     TM    OCTNT+3,X'04'           IF MODIFIED OCTANT IS IN\n         BZ    SIGNAA                  LOWER PLANE, SIGN IS NEGATIVE\n         LNER  FPR0,FPR0\n*\nSIGNAA   RETURN (14,12)                RESTORE CALLERS REGS AND RETURN\n*\nERROR    B     FSAERR+27*4(R13)        PARAMETER \u00ac< PI*2**50\n*\nFSAERR   EQU   X'1CC'\n*\nARG      DC    D'0'\n*\nSCALER   DC    X'4E00000000000000'\n*\nC7       DC    X'B66C992E84B6AA37'\n         DC    X'3778FCE0E5AD1685'     S6\nC6       DC    X'387E731045017594'\n         DC    X'B978C01C6BEF8CB3'     S5\nC5       DC    X'BA69B47B1E41AEF6'\n         DC    X'3B541E0BF684B527'     S4\nC4       DC    X'3C3C3EA0D06ABC29'\n         DC    X'BD265A599C5CB632'     S3\nC3       DC    X'BE155D3C7E3C90F8'\n         DC    X'3EA335E33BAC3FBD'     S2\nC2       DC    X'3F40F07C206D6AB1'\n         DC    X'C014ABBCE625BE41'     S1\nC1       DC    X'C04EF4F326F91777'     LAST DGT REDUCED BY 2\nPIOV4    DC    X'40C90FDAA22168C2'     S0\nHALF     DC    X'4080000000000000'     1/2 = C0/2\n*\nMAX      DC    X'4DC90FDA'\nOCTNT    DC    F'0'\n*\n*        REGSITER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHILSQ   0201-12230-12230-1200-00097-00097-00000-LEVEL\nQRT      TITLE 'IHILSQRT, SQUARE ROOT, LONG PRECISION, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        WRITE X = M*16**(2P-Q), M MANTISSA, Q=0 OR 1\n*        THEN SQRT(X) = SQRT(M)*(4**-Q)*(16**P)\n*\n*        ENTRY POINT -\n*        IHILSQ - SQRT FUNCTION, LONG\n*                 LA   R1,PARMLIST\n*                 BALR R14,R15\n*                 DATA PASSED BY NAME\n*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        EXIT - NORMAL -\n*        RETURN VIA R14, RESULT IN FPR0\n*\n*        EXIT - ERROR -\n*        IF ARGUMENT NEGATIVE GOTO ERROR ROUTINE VIA\n*        B   FSAERR+23*4(R13)\n*\n*        TABLES/WORKAREAS - N/A\n*\nIHILSQRT CSECT\n*\n         ENTRY IHILSQ\n*\nFPR0     EQU   0                       RESULT REGISTER\nFPR2     EQU   2                       SCRATCH REGISTERS\nFPR4     EQU   4\n*\nIHILSQ   SAVE  (14,12),,'IHILSQRT LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHILSQRT,R15\n         L     R1,0(,R1)\n         LD    FPR0,0(,R1)             OBTAIN ARGUMENT\n         LTDR  FPR4,FPR0               ARG = 0 ?\n         BZ    FIN                     YES, ANS = 0, RETURN\n         BM    ERROR                   NEGATIVE ARG, ERROR\n         STE   FPR0,BUFF               CONSTRUCT Y = M*16**P AS FOLLOWS\n         SR    R0,R0\n         IC    R0,BUFF                 P+64 = INT PART OF (CHAR+65)/2\n         AH    R0,BIAS\n         SRDL  R0,1                    P+64 IN R0, R1 IS - IF EVEN CHAR\n         STC   R0,BUFF                 Y IS READY IN BUFF\n         STC   R0,B                    CONSTRUCT (2/9)*16**P IN B\n         LE    FPR0,BUFF               COMPUTE ((2/9+(8/9)*M)*16**P\n         ME    FPR0,A\n         AE    FPR0,B\n         LTR   R1,R1\n         BM    OK                      EVEN CHAR, 1ST APPROX IS READY\n         HER   FPR0,FPR0               ODD CHAR, DIVIDE BY 4 TO OBTAIN\n         HER   FPR0,FPR0               1ST APPROXIMATION\nOK       LER   FPR2,FPR4               NEWTON RAPHSON ITERATIONS\n         DER   FPR2,FPR0               Y(N+1) = (Y(N)+ARG/Y(N))/2\n         AER   FPR0,FPR2               2 PASSES IN SHORT FORM\n         HER   FPR0,FPR0\n         LER   FPR2,FPR4\n         DER   FPR2,FPR0\n         AER   FPR0,FPR2\n         HER   FPR0,FPR0\n         LDR   FPR2,FPR4               2 PASSES IN LONG FORM\n         DDR   FPR2,FPR0\n         HDR   FPR2,FPR2\n         HDR   FPR0,FPR0\n         ADR   FPR0,FPR2\n         DDR   FPR4,FPR0\n         SWR   FPR4,FPR0\n         HDR   FPR4,FPR4\n         ADR   FPR0,FPR4\n*\nFIN      RETURN (14,12)                RESTORE REGS AND RETURN\n*\nERROR    B     FSAERR+23*4(R13)        NEGATIVE PARAMETER\n*\nFSAERR   EQU   X'1CC'\n*\nBUFF     DC    F'0'\nA        DC    X'40E38E39'\nB        DC    X'4038E38E'\n*\nBIAS     DC    H'65'\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIOAR   0201-12230-12230-1200-00096-00096-00000-LEVEL\nAOR      TITLE 'IHIOARRY, OUTARRAY REAL, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        TRANSFER NUMBERS FROM ARRAY INDICATED BY SECOND ACTUAL\n*        PARAMETER TO OUTPUT BUFFER BY CALLING OUTREAL LONG OR\n*        SHORT REPEATEDLY\n*\n*        ENTRY POINT -\n*        IHIOARRY - FROM GENERATED OBJECT MODULE\n*                   LA   R1,PARMLIST\n*                   BALR R14,R15\n*                   DATA PASSED BY NAME\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES -\n*        IHIIOR - EVALUATE DATA SET NUMBER\n*        IHISOR - OUTREAL SHORT\n*        IHILOR - OUTREAL LONG\n*\n*        EXIT - NORMAL - RELOAD REGISTERS AND RETURN VIA R14\n*\n*        EXIT - ERROR - N/A\n*\n*        TABLES/WORK AREAS - N/A\n*\nIHIOARRY CSECT\n*\n         SAVE  (14,12),,'IHIOARRY LEVEL 2.1 &SYSDATE &SYSTIME'\n         LR    R8,R15\n         USING IHIOARRY,R8\n         LR    R12,R13                  R12 -> FSA\n         LA    R13,ASAVE(,R12)          R13 -> SECOND FSA SAVEAREA\n         SR    R3,R3\n*\n*        EVALUATE DATASET NUMBER\n*\n         L     R15,VIOREV              R15 -> IHIIOREV ROUTINE\n         BALR  R14,R15                 CALL IHIIOREV\n*\n*        EVALUATE SOURCE ADDR\n*\n         ICM   R1,B'1111',4(R1)\n         BNM   OTARY1                  >= 0, BRANCH\n         O     R3,=X'80000000'\n         N     R1,=X'00FFFFFF'\nOTARY1   L     R2,12(,R1)              R2 -> DESTEND+1\n         L     R7,8(,R1)               R7 -> STARTDEST\n         AR    R7,R3\n         AR    R2,R3\n*\n*        CALL ROUTINE OUREAL LONG OR SHORT\n*\n         LA    R4,4                    SETUP FOR SHORT\n         TM    OPTSW(R12),X'20'        LONG OR SHORT PRECISION ?\n         BO    OTARY2                  SHORT, BRANCH\n         LA    R4,8                    LONG\nOTARY2   L     R15,ARROUTR(R4)\n         BALR  R14,R15\n         TM    OPTSW(R12),X'20'        LONG OR SHORT\n         BO    OTARY3                  SHORT\n         LTR   R7,R7                   LONG\n         BP    OTARY3\n         SH    R7,=H'4'\nOTARY3   AR    R7,R4                   INCREASE DEST ADDR\n         CR    R7,R2\n         BL    OTARY2                  DESTEND NOT REACHED\n         LR    R13,R12\n*\n         RETURN (14,12)\n*\n*        EXTERNAL ADDRS\n*\nVIOREV   DC    V(IHIIOREV)\n*\nARROUTR  DC    A(0)                    +00\n         DC    V(IHISORAR)             +04\n         DC    V(IHILORAR)             +08\n*\n         LTORG\n*\nFAS      DSECT\n*\n         COPY  FSAREA\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIOBA   0201-12230-12230-1200-00073-00073-00000-LEVEL\nAOB      TITLE 'IHIOBARR, OUTBARRAY, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        TRANSFER BOOLEAN VALUES FROM ARRAY DEFINED BY SECOND\n*        ACTUAL PARAMETER TO AN OUTPUT BUFFER BY CALLING\n*        OUTBOOLEAN REPEATEDLY\n*\n*        ENTRY POINTS -\n*        IHIOBARR - FROM GENERATED OBJECT MODULE\n*                   LA   R1,PARMLIST\n*                   BALR R14,R15\n*                   DATA PASSED BY NAME\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES -\n*        IHIIOR - EVALUATE DATASET NUMBER\n*\n*        IHIOBO - INBOOLEAN\n*\n*        EXIT - NORMAL - RELOAD REGISTERS AND RETURN VIA R14\n*\n*        EXIT - ERROR - N/A\n*\n*        TABLES/WORK AREAS - N/A\n*\nIHIOBARR CSECT\n*\n         SAVE  (14,12),,'IHIOBARR LEVEL 2.1 &SYSDATE &SYSTIME'\n         LR    R7,R15\n         USING IHIOBARR,R7\n         LR    R12,R13                 R12 -> FSA\n         LA    R13,ASAVE(,R12)         R13 -> SECOND FSA SAVEAREA\n*\n*        EVALUATE DATASET NUMBER\n*\n         L     R15,VIORREC             R15 -> IHIIOREC ROUTINE\n         BALR  R14,R15                 CALL IHIIOREC\n         L     R1,4(,R1)\n         L     R4,12(,R1)              R4 -> SOURCEEND+1\n         L     R2,8(,R1)               R2 -> SOURCE\n*\n*        CALL ROUTINE OUTBOOLEAN\n*\nOUTBY1   L     R15,VOBOAR              R15 -> IHIOBOAR ROUTINE\n         BALR  R14,R15                 CALL IHIOBOAR\n         LA    R2,1(,R2)               INCREASE SOURCE ADDR BY ONE\n         CR    R2,R4\n         BL    OUTBY1                  LOOP, MORE VALUE TO WRITE\n         LR    R13,R12\n*\n         RETURN (14,12)                RESTORE REGS AND RETURN\n*\n*        EXTERNAL ADDRS\n*\nVIORREC  DC    V(IHIIOREV)\nVOBOAR   DC    V(IHIOBOAR)\n*\nFAS      DSECT\n*\n         COPY  FSAREA\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIOBO   0201-12230-12230-1329-00183-00183-00000-LEVEL\nBOO      TITLE 'IHIOBOOL, OUTBOOLEAN, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        TRANSFER BOOLEAN VALUE FROM SECOND PARAMETER TO AN\n*        OUTPUT BUFFER WITH CHARACTER STRING 'TRUE' OR 'FALSE'\n*\n*        ENTRY POINTS -\n*        IHIOBOOL - FROM GENERATED OBJECT MODULE\n*                   LA   R1,PARMLIST\n*                   BALR R14,R15\n*                   DATA PASSED BY NAME\n*        IHIOBOAR - FROM ARRAY MODULE IHIOBA\n*                   LA   R2,DATA\n*                   BALR R14,R15\n*        DATA PASSED BY NAME\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES -\n*        IHIIOR - EVALUATE DATASET NUMBER\n*               - OPEN DATASET\n*               - CHANGE TO NEXT RECORD\n*\n*        EXIT - NORMAL - RELOAD REGISTERS AND RETURN VIA R14\n*\n*        EXIT - ERROR - TOO LONG RECORD - NO 38\n*                       BRANCH TO IHIFSA\n*                       L    R13,IHIFSA\n*                       B    FSAERR+XX*4(R13) XX ERROR NO\n*\n*        TABLES/WORK AREAS - N/A\n*\nIHIOBOOL CSECT\n*\n         ENTRY IHIOBOAR\n*\n*        DISPLACEMENTS IN ADRLST IN IHIFSA\n*\nCI       EQU   0             DISPLACEMENT FOR - IHIIORCI\nCL       EQU   4                                IHIIORCL\nEV       EQU   8                                IHIIOREV\nNX       EQU   12                               IHIIORNX\nOP       EQU   16                               IHIIOROP\nOQ       EQU   20                               IHIIOROQ\n*\n         USING DSTABLE,R5              R5 -> DSTABLE ENTRY\n*\n         SAVE  (14,12),,'IHIOBOOL LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHIOBOOL,R15\n         LR    R12,R13                 CHAIN SAVE AREAS\n         LA    R13,SAVEAREA\n         ST    R12,4(,R13)\n         ST    R13,8(,R12)\n         LA    R7,COMMON\n         DROP  R15\n         USING COMMON,R7\n*\n*        EVALUATE DATASET NUMBER\n*\n         L     R15,IORLST(,R12)\n         L     R15,EV(,R15)\n         BALR  R14,R15\n         L     R1,4(,R1)\n         ST    R1,ASOURCE\n         B     COMMON\n*\n         DROP  R7\n*\nIHIOBOAR SAVE  (14,12),,'IHIOBOAR LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHIOBOAR,R15\n         LR    R7,R13                  CHAIN SAVE AREAS\n         LA    R13,SAVEAREA\n         ST    R7,4(,R13)\n         ST    R13,8(,R7)\n         LA    R7,COMMON\n         DROP  R15\n         USING COMMON,R7\n*\nCOMMON   OI    DSF,DS2+DS3             DS2, DS3 SET TO ONE\n         NI    DSF,255-DS7             DS7 IS SET TO 0\n         TM    DSF,DS0                 DATASET OPEN ?\n         BO    OTBOOL1                 YES, BRANCH\n         OI    DSF,DS6                 NO, OPEN DATASET\n         L     R15,IORLST(,R12)\n         L     R15,OP(,R15)\n         BALR  R14,R15                 CALL DATASET OPEN ROUTINE\nOTBOOL1  L     R4,RE\n         L     R3,R\n         LA    R3,7(,R3)\n         CR    R4,R3\n         BNL   OTBOOL2                 SEVEN CHARACTER FREE IN RECORD\n*\n*        NOT ROOM ENOUGH TO STORE BOOLEAN VALUE IN RECORD\n*        FILL CURRENT RECORD BY BLANKS\n*        CALL FOR ROUTINE NEXTREC\n*\n         L     R3,R\n         L     R4,RE\n         SR    R4,R3\n         BZ    OTBOOL7\n         MVI   0(R3),C' '\n         BCTR  R4,0\n         BCTR  R4,0\n         LTR   R4,R4\n         BM    OTBOOL7\n         EX    R4,BLANKS\nOTBOOL7  L     R15,IORLST(,R12)\n         L     R15,NX(,R15)\n         BALR  R14,R15\n         L     R3,R\n         LA    R3,7(,R3)\n         C     R3,RE\n         BH    OERROR                  TOO SHORT RECORD LENGTH\n         OI    DSF,DS3\nOTBOOL2  L     R2,ASOURCE\n         SR    R9,R9\n         IC    R9,0(,R2)\n         L     R3,R\n         LTR   R9,R9\n         BZ    OTBOOL3\n         MVC   0(L'TRUE,R3),TRUE       BOOLEAN VALUE TRUE OR FALSE\n         B     OTBOOL3A                TO RECORD WHICH ONE DEPENDING\n*\nOTBOOL3  MVC   0(L'FALSE,R3),FALSE     ON VALUE OF SOURCE\nOTBOOL3A LA    R3,7(,R3)\n         ST    R3,R                    UPDATE CHARACTER POINTER\n*\n*        ROUTINE BLADEL\n*\n         SR    R8,R8\n         IC    R8,K                    NUMBER OF DELIMITERS\nOTBOOL4  C     R3,RE\n         BE    OTBOOL5                 RECORD END REACHED\n         MVI   0(R3),C' '              FILL WITH BLANK\n         LA    R3,1(,R3)\n         BCT   R8,OTBOOL4\n         ST    R3,R                    UPDATE CHARACTER POINTER\n         B     OTBOOL6\n*\n*        CALL NEXTREC\n*\nOTBOOL5  L     R15,IORLST(,R12)\n         L     R15,NX(,R15)\n         BALR  R14,R15\nOTBOOL6  L     R13,SAVEAREA+4\n*\n         RETURN (14,12)                RESTORE REGS AND RETURN\n*\nOERROR   LR    R13,R12\n         B     FSAERR+38*4(R12)\n*\nBLANKS   MVC   1(0,R3),0(R3)           EXE INSTRUCTION\n*\nASOURCE  DC    A(0)\n*\nTRUE     DC    C'''TRUE'' '\nFALSE    DC    C'''FALSE'''\n*\nSAVEAREA DC    18F'0'\n*\n         LTORG\n*\n*        DSTABLE MAPPING DSECT\n*\n         DSTABLE DSECT=YES\n*\nFAS      DSECT\n*\n         COPY  FSAREA\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIOIN   0201-12230-12230-1200-00216-00216-00000-LEVEL\nNTE      TITLE 'IHIOINTE, OUT INTEGER, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        TRANSFER NUMBER FROM INTEGER INDICATED BY SECOND ACTUAL\n*        PARAMETER TO OUTPUT BUFFER IN ZONED DECIMAL FORM\n*\n*        ENTRY POINTS -\n*        IHIOINTG - FROM GENERATED OBJECT MODULE\n*                   LA   R1,PARMLIST\n*                   BALR R14,R15\n*                   DATA PASSED BY NAME\n*        IHIOINAR - FROM ARRAY MODULE IHIOTA\n*                   LA   R7,DATA\n*                   BALR R14,R15\n*                   DATA PASSED BY NAME\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES -\n*\n*        IHIIOR - EVALUATE DATASET NUMBER\n*               - OPEN DATASET\n*               - CHANGE TO NEXT OUTPUT RECORD\n*        CNVRI  - CONVERT REAL TO INTEGER\n*\n*        EXIT - NORMAL - RELOAD REGISTERS AND RETURN VIA R14\n*             - ERROR  - TOO LONG RECORD     NO 38\n*                        BRANCH TO IHIFSA\n*                        L   R13,IHIFSA\n*                        B   FSAERR+XX*4(13)   XX ERROR NO\n*\n*        TABLES/WORK AREAS - N/A\n*\n*        ATTRIBUTES - SERIALLY REUSABLE\n*\n*        NOTES -\n*        LINKING TO IHIOINAR DEVIATES FROM STANDARD CHARACTER\n*        DEPENDENCE\n*\nIHIOINTE CSECT\n*\n         ENTRY IHIOINTG\n         ENTRY IHIOINAR\n*\nFPR0     EQU   0                       FPRO\n*\n         USING DSTABLE,R5\n*\n*        DISPLACEMENTS IN ADRLST IN IHIFSA\n*\nCI       EQU   0                       IHIIORCI\nCL       EQU   4                       IHIIORCL\nEV       EQU   8                       IHIIOREV\nNX       EQU   12                      IHIIORNX\nOP       EQU   16                      IHIIOROP\nOQ       EQU   20                      IHIIOROQ\n*\nIHIOINAR SAVE  (14,12),,'IHIOINAR LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHIOINAR,R15\n         LR    R10,R13                 CHAIN SAVE AREAS\n         LA    R13,SAVEAREA\n         ST    R10,4(,R13)\n         ST    R13,8(,R10)\n         LA    R10,COMMON\n         DROP  R15\n         USING COMMON,R10\n         B     SOUINTA\n*\n         DROP  R10\n*\nIHIOINTG SAVE  (14,12),,'IHIOINTG LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHIOINTG,R15\n         LR    R12,R13                 R12 -> FSA  TO FSA REG\n         LA    R13,SAVEAREA\n         ST    R12,4(,R13)\n         ST    R13,8(,R12)\n         LA    R10,COMMON\n         DROP  R15\n         USING COMMON,R10\n*\n*        EVALUATE DATASET NUMBER (EVDSN)\n*\nCOMMON   L     R15,IORLST(,R12)\n         L     R15,EV(,R15)\n         BALR  R14,R15\n*\n*        EVALUATE ADDR OF SOURCE\n*        TEST IF SOURCE NUMBER IS REAL\n*\nSOUINT   L     R7,4(,R1)               ADDR OF SOURCE\nSOUINTA  OI    DSF,DS2+DS3             DS2, DS3 = 1\n         NI    DSF,255-DS7             TURN OFF EOF DS7\n         LTR   R7,R7\n         BP    INT1\n*\n*        CALL CONVERSION ROUTINE\n*\n         LE    FPR0,0(,R7)\n         TM    OPTSW(R12),X'20'        LONG OR SHORT PRECISION ?\n         BO    CONVA                   SHORT PRECISION STATED\n         LD    FPR0,0(,R7)             LONG PRECISION STATED\nCONVA    L     R15,IORLST(,R12)\n         L     R15,CI(,R15)\n         BALR  R14,R15\n         B     DSTEST\n*\nINT1     L     R0,0(,R7)               NUMBER IN R0\n*\n*        DATASET OPEN ?\n*\nDSTEST   TM    DSF,DS0\n         BO    NOCLO1                  DCB IS OPEN\n         OI    DSF,DS6                 DS6 = 1\n         L     R15,IORLST(,R12)\n         L     R15,OP(,R15)\n         BALR  R14,R15                 OPEN DATASET\n*\n*        RECORD ACCEPT 11 DIGITS ?\n*        IF NOT FILL RECORD WITH BLANKS AND CALL NEXTREC\n*\nNOCLO1   L     R2,R                    CHARACTER POINTER\n         LA    R3,11(,R2)\n         C     R3,RE\n         BNH   NONR1                   BUFFER CAN ACCEPT 11 DIGITS\n         L     R9,RE\n         SR    R9,R2\n         BNP   GETREC\nBLANKS   MVI   0(R2),C' '              BLANK IN BUFFER\n         LA    R2,1(,R2)               INCREASE R\n         BCT   R9,BLANKS\nGETREC   L     R15,IORLST(,R12)\n         L     R15,NX(,R15)\n         BALR  R14,R15\n         L     R2,R\n         LA    R3,11(,R2)\n         C     R3,RE\n         BH    OINERR                  TOO SHORT RECORD LENGTH\n         OI    DSF,DS3\n*\n*        TEST SOURCE NUMBER AND CONVERT TO DECIMAL\n*\nNONR1    LTR   R0,R0\n         BZ    OUTINT0                 NUMBER IS ZERO\n         CVD   R0,BUFF\n         UNPK  1(10,R2),BUFF+2(6)\n         OI    10(R2),X'F0'            ZONE INSERTED\n*\nLEAD0    CLI   1(R2),C'0'\n         BNE   TERMIN0\n         MVI   0(R2),C' '              LEADING ZERO IS BLANKED\n         LA    R2,1(,R2)\n         B     LEAD0\n*\nTERMIN0  LTR   R0,R0\n         BP    POSITIVE\n         MVI   0(R2),C'-'              - SIGN INSERTED\n         B     TERMIN1\n*\nPOSITIVE MVI   0(R2),C'+'              + SIGN INSERTED\n*\nTERMIN1  SR    R4,R4\n         IC    R4,K                    VALUE OF K IN REGISTER\nTERMIN1A C     R3,RE\n         BE    RECEND                  RECORD END IS REACHED\n         MVI   0(R3),C' '              FILL WITH BLANKS\n         LA    R3,1(,R3)\n         BCT   R4,TERMIN1A\n         C     R3,RE\n         BE    RECEND\n         ST    R3,R\nTERMIN1B L     R13,SAVEAREA+4\n*\n         RETURN (14,12)                RESTORE REGS AND RETURN\n*\n*        OUTINTEGER NUMBER IS 0\n*\nOUTINT0  MVI   0(R2),C' '\n         MVC   1(9,R2),0(R2)           BLANKS IN BUFFER\n         MVI   10(R2),C'0'             0 IN BUFFER\n         B     TERMIN1\n*\nRECEND   L     R15,IORLST(,R12)\n         L     R15,NX(,R15)\n         BALR  R14,R15\n         B     TERMIN1B\n*\n*        RECORD LENGTH < 11\n*\nOINERR   LR    R13,R12\n         B     FSAERR+38*4(R12)\n*\nBUFF     DC    D'0'\n*\nSAVEAREA DC    18F'0'\n*\n         LTORG\n*\n         DSTABLE DSECT=YES\n*\nFSAAREA  DSECT\n*\n         COPY  FSAREA\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIOST   0201-12230-12230-1200-00127-00127-00000-LEVEL\nOST  TITLE 'IHIOSTRG, LIBRARY I/O SERVICE RTN, OUTSTRING, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        TRANSFER STRING DEFINED BY SECOND ACTUAL PARAMETER\n*        TO AN OUTPUT BUFFER\n*\n*        ENTRY POINT -\n*        IHIOSTRG - FROM GENERATED OBJECT MODULE\n*        LA    R1,PARMLIST\n*        BALR  R14,R15\n*        DATA PASSED BY NAME\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES-\n*        IHIIOR - EVALUATE DATASET NUMBER\n*               - OPEN DATASET\n*               - CHANGE TO NEXT OUTPUT RECORD\n*\n*        EXIT - NORMAL - RELOAD REGISTERS AND RETURN VIA R14\n*             - ERROR  - N/A\n*\n*        TABLES/WORK AREAS - N/A\n*\nIHIOSTRG CSECT\n*\n*        DISPLACEMENTS IN ADRLST IN IHIFSA\n*\nCI       EQU   0             DISPLACEMENT FOR - IHIIORCI\nCL       EQU   4                                IHIIORCL\nEV       EQU   8                                IHIIOREV\nNX       EQU   12                               IHIIORNX\nOP       EQU   16                               IHIIOROP\nOQ       EQU   20                               IHIIOROQ\n*\n         SAVE  (14,12),,'IHIOSTRG LEVEL 2.1 &SYSDATE &SYSTIME'\n         LR    R8,R15\n         USING IHIOSTRG,R8\n         ST    R13,SAVAR+4\n         LR    R12,R13\n         LA    R13,SAVAR\n         USING DSTABLE,R5\n*\n*        EVALUATE DATASET NUMBER\n*\n         L     R15,IORLST(R12)\n         L     R15,EV(,R15)\n         BALR  R14,R15\n*\n*        STORE SOURCE ADDR\n*\n         L     R1,4(,R1)\n         ST    R1,ASTRING              SAVE STRING ADDR\n         OI    DSF,DS2+DS3             DS2,DS3=1 OUTPUT\n         NI    DSF,255-DS7             DS7=0 NO END OF DATA\n         TM    DSF,DS0                 DATASET OPEN ?\n         BO    OUTSTR1                 YES, BRANCH\n         OI    DSF,DS6                 NO, DATASET IS NOT OPEN\n         L     R15,IORLST(R12)\n         L     R15,OP(,R15)\n         BALR  R14,R15                 CALL FOR ROUTINE OPEN\nOUTSTR1  L     R2,ASTRING              R2 -> STRING\n         MVC   STRLTH,0(R2)            MOVE L'STRING\n         LH    R4,STRLTH\n         BCTR  R4,0\n         BCTR  R4,0                    REAL STRING LENGTH TO REGISTER\n         LTR   R4,R4                   ZERO LENGTH STRING ?\n         BZ    OUTSTR3                 YES, BRANCH\n         LA    R2,2(,R2)               R2 -> STRING\nOUTSTR4  LR    R3,R4\n         OI    DSF,DS3\n         A     R4,R\n         C     R4,RE\n         BH    OUTSTR2                 OVERFLOW IN CURRENT RECORD\n         BCTR  R3,0\n         L     R9,R\n         EX    R3,OUTMOV               CONTENT OF STRING TO BUFFER\n         LA    R3,1(,R3)\n         ST    R4,R\n         C     R4,RE\n         BNE   OUTSTR3\n         L     R15,IORLST(R12)\n         L     R15,NX(,R15)\n         BALR  R14,R15                 CURRENT RECORD FILLED\nOUTSTR3  L     R13,SAVAR+4\n*\n         RETURN (14,12)                RETURN TO CALLER\n*\nOUTSTR2  L     R7,RE                   RE-R AVAILIABLE, PLACE IN\n         S     R7,R                    CURRENT RECORD\n         L     R9,R\n         BCTR  R7,0\n         EX    R7,OUTMOV\n         LA    R7,1(,R7)\n         LR    R4,R3\n         SR    R4,R7\n         AR    R2,R7\n         L     R15,IORLST(R12)\n         L     R15,NX(,R15)\n         BALR  R14,R15\n         B     OUTSTR4\n*\nOUTMOV   MVC   0(1,R9),0(R2)           MOVE STRING\n*\nSAVAR    DC    18F'0'\nASTRING  DC    A(0)\nSTRLTH   DC    H'0'\n*\n         LTORG\n*\n         DSTABLE  DSECT=YES\n*\nFAS      DSECT\n*\n         COPY  FSAREA\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIOSY   0201-12230-12230-1200-00138-00138-00000-LEVEL\nOSY   TITLE 'IHIOSYMB, LIBRARY I/O SERVICE RTN, OUTSYMBOL, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        COMPARE NUMBER ASSIGNED TO THIRD ACTUAL PARAMETER WITH\n*        AN INTERNAL STRING AND TRANSFER CHARACTER IN\n*        CORRESPONDING POSITION TO AN OUTPUT BUFFER\n*\n*        ENTRY POINT -\n*        IHIOSYMB - FROM GENERATED OBJECT MODULE\n*        LA   R1,PARMLIST\n*        DATA PASSED BY NAME\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES -\n*        IHIIOR - EVALUATE DATASET NUMBER\n*               - OPEN DATASET\n*               - CHANGE TO NEXT OUTPUT RECORD\n*\n*        EXITS - NORMAL - RELOAD REGISTERS AND RETURN VIA R14\n*\n*        EXITS - ERROR  - SOURCE DOES NOT MATCH STRING NO 8\n*        BRANCH TO FSA    LA  R13,IHIFSA\n*                         B   FSAERR+XX*4(13) XX ERROR NO\n*\n*        TABLES/WORK AREAS - N/A\n*\nIHIOSYMB CSECT\n*\n*        R3                            -> SOURCE\n*        R4                            -> START OF STRING\n*        R8                             = INTEGER NUMBER FROM SOURCE\n*        R9                             = L'SOURCE STRING\n*        R10                           -> CHARACTER POINTER\n*\n         USING DSTABLE,R5\n*\n*        DISPLACEMENTS IN ADRLST IN IHIFSA\n*\nCI       EQU   0             DISPLACEMENT FOR - IHIIORCI\nCL       EQU   4                                IHIIORCL\nEV       EQU   8                                IHIIOREV\nNX       EQU   12                               IHIIORNX\nOP       EQU   16                               IHIIOROP\nOQ       EQU   20                               IHIIOROQ\n*\n         SAVE  (14,12),,'IHIOSYMB LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LR    R7,R15\n         USING IHIOSYMB,R7\n         ST    R13,SAVEAREA+4          SAVE HIGH SAVEAREA ADDR\n         LR    R12,R13                 R12 -> FSA\n         LA    R13,SAVEAREA\n*\n*        EVALUATE DATASET NUMBER (EVDSN)\n*\n         L     R15,IORLST(,R12)\n         L     R15,EV(,R15)\n         BALR  R14,R15\n         L     R4,4(,R1)               R4 -> STRING\n*\n*        TEST IF DATASET IS OPEN\n*\n         NI    DSF,255-DS7             DS7 = 0\n         OI    DSF,DS2+DS3             DS2, DS3 = 1\n         TM    DSF,DS0                 DATASET OPEN ?\n         BO    SOURCE0                 YES, BRANCH\n         OI    DSF,DS6                 DS6 = 1\n         L     R15,IORLST(,R12)\n         L     R15,OP(,R15)\n         BALR  R14,R15                 OPEN DATASET\nSOURCE0  L     R3,8(,R1)               R3 -> SOURCE\n         LTR   R3,R3                   CONVERSION REQUIRED ?\n         BP    EVSOURCE                NO CONVERSION NEEEDED\n         TM    OPTSW(R12),X'20'        YES, LONG OR SHORT PREC ?\n         BO    SOURCE1                 SHORT\n         LD    0,0(,R3)\n         B     SOURCE1A\n*\nSOURCE1  LE    0,0(,R3)\nSOURCE1A L     R15,IORLST(,R12)\n         L     R15,CI(,R15)\n         BALR  R14,R15                 REQUEST CONVERSION\n         LR    R8,R0\n         B     EVSOURAA\n*\nEVSOURCE L     R8,0(,R3)               SOURCE INTEGER LOADED\nEVSOURAA LTR   R8,R8\n         BM    ERR8                    INTEGER -VE\n         L     R10,R                   CHARACTER POINTER\n         BP    EVSOURBB                INTEGER +VE\n         MVI   0(R10),C' '             INTEGER = ZERO\n         B     TERMIN\n*\nEVSOURBB LH    R9,0(,R4)               LENGTH OF STRING\n         LA    R8,1(,R8)               INTEGER INCR BY ONE\n         BCTR  R9,0                    LENGTH DECR BY ONE\n         CR    R8,R9\n         BH    ERR8\n         AR    R8,R4\n         MVC   0(1,R10),0(R8)\nTERMIN   LA    R10,1(,R10)\n         C     R10,RE\n         BNL   NEXTREC\n         ST    R10,R\nTERMINA  LR    R13,R12\n*\n         RETURN (14,12)\n*\nNEXTREC  L     R15,IORLST(,R12)\n         L     R15,NX(,R15)\n         BALR  R14,R15\n         B     TERMINA\n*\nERR8     LR    R13,R12\n         B     FSAERR+8*4(R12)         SOURCE DOES NOT MATCH STRING\n*\nSAVEAREA DC    18F'0'                  MODULE SAVE AREA\n*\n         LTORG\n*\n         DSTABLE  DSECT=YES\n*\nFAS      DSECT\n*\n         COPY  FSAREA\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIOTA   0201-12230-12230-1200-00088-00088-00000-LEVEL\nARR      TITLE 'IHIOTARR, OUTTARRAY, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        TRANSFER NUMBERS FROM ARRAY INDICATED BY SECOND\n*        PARAMETER TO OUTPUT BUFFER BY CALLING OUTINTEGER\n*        REPEATEDLY\n*\n*        ENTRY POINT -\n*        IHIOTARR - FROM GENERATED OBJECT MODULE\n*                   LA   R1,PARMLIST\n*                   BALR R14,R15\n*                   DATA PASSED BY NAME\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES -\n*        IHIIOR - EVALUATE DATASET NUMBER\n*        IHIOIN - OUTINTEGER\n*\n*        EXIT - NORMAL - RELOAD REGISTERS RETURN VIA R14\n*\n*        EXIT - ERROR - N/A\n*\n*        TABLES/WORK AREAS - N/A\n*\nIHIOTARR CSECT\n*\n         SAVE  (14,12),,'IHIOTARR LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LR    R8,R15\n         USING IHIOTARR,R8\n         LR    R12,R13                 R12 -> FSA\n         LA    R13,ASAVE(,R13)         R13 -> SECOND FSA SAVEAREA\n         SR    R3,R3\n*\n*        EVALUATE DATASET NUMBER\n*\n         L     R15,VIOREV\n         BALR  R14,R15\n*\n*        EVALUATE SOURCE ADDR\n*\n         ICM   R1,B'1111',4(R1)         GET SECOND PARAMETER\n         BNM   OUTT1                    >= 0, BRANCH\n         O     R3,=X'80000000'          MINUS, INSERT FLAG BYTE\n         N     R1,=X'00FFFFFF'\nOUTT1    L     R2,12(,R1)               R2 -> DESTEND+1\n         L     R7,8(,R1)                R7 -> STARTDEST\n         AR    R7,R3\n         AR    R2,R3\n*\n*        CALL ROUTINE OUTINTEGER\n*\nOUTT2    L     R15,VOINAR\n         BALR  R14,R15\n         AH    R7,=H'4'\n         BP    OUTT2A\n         TM    OPTSW(R12),X'20'\n         BO    OUTT2A\n         LA    R7,4(,R7)                INCR DEST ADDR\nOUTT2A   CR    R7,R2\n         BL    OUTT2                    DESTEND NOT REACHED\n         LR    R13,R12\n*\n         RETURN (14,12)                 RESTORE REGS AND RETURN\n*\n*        EXTERNAL ADDRS\n*\nVIOREV   DC    V(IHIIOREV)\nVOINAR   DC    V(IHIOINAR)\n*\n         LTORG\n*\nFAS      DSECT\n*\n         COPY  FSAREA\n*\n*        REGSITER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHIPTT   0201-12230-12230-1200-00068-00068-00000-LEVEL\nTAB      TITLE 'IHIPTTAB, POWER OF TEN TABLE, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        CONSISTS ONLY OF FLOATING POINT CONSTANTS\n*\n*        ENTRY POINT - IHIPTTAB -\n*                      USED TO ADDR DESIRED CONSTANT FROM\n*                      INREAL AND OUTREAL LONG\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        EXITS - NORMAL - N/A\n*              - ERROR  - N/A\n*\n*        TABLES/WORK AREAS - N/A\n*\n*        NOTES -\n*        CONSTANT IS ADDRESSED IN FOLLOWING WAY\n*                 LA R15,IHIPTTAB\n*                 MD R1,D2(R2,15)\n*        DATA PASSED BY VALUE\n*\nIHIPTTAB CSECT\n*\n         DC    D'0'\n         DC    DE1'1'\n         DC    DE2'1'\n         DC    DE3'1'\n         DC    DE4'1'\n         DC    DE5'1'\n         DC    DE6'1'\n         DC    DE7'1'\n         DC    DE8'1'\n         DC    DE16'1'\n         DC    DE24'1'\n         DC    DE32'1'\n         DC    DE40'1'\n         DC    DE48'1'\n         DC    DE56'1'\n         DC    DE64'1'\n         DC    DE72'1'\n*\n         DC    DE-1'1'\n         DC    DE-2'1'\n         DC    DE-3'1'\n         DC    DE-4'1'\n         DC    DE-5'1'\n         DC    DE-6'1'\n         DC    DE-7'1'\n         DC    DE-8'1'\n         DC    DE-16'1'\n         DC    DE-24'1'\n         DC    DE-32'1'\n         DC    DE-40'1'\n         DC    DE-48'1'\n         DC    DE-56'1'\n         DC    DE-64'1'\n         DC    DE-72'1'\n*\n         END\n./ ADD NAME=IHISAT   0201-12230-12230-1200-00108-00108-00000-LEVEL\nTAN      TITLE 'IHISATAN, ATAN, SHORT PRECISION, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        1. REDUCE THE CASE TO THE 1ST OCTANT BY USING\n*           ATAN(-X)=-ATAN(X), ATAN(1/X)=PI/2-ATAN(X)\n*        2. REDUCE FURTHER TO THE CASE /X/ LESS THAN TAN(PI/2) BY\n*           ATAN(X)=PI/6+ATAN((X*SQRT3-1)/(X+SQRT3)\n*        3. FOR THE BASIC RANGE (X LESS THAN TAN(PI/12)),\n*           USE A FRACTIONAL APPROXIMATION\n*\n*        ENTRY POINT -\n*        IHISAT - ATAN FUNCTION, SHORT\n*                 LA   R1,PARMLIST\n*                 BALR R14,R15\n*                 DATA PASSED BY NAME\n*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0\n*\n*        EXIT - ERROR - N/A\n*\n*        TABLES/WORKAREAS - N/A\n*\nIHISATAN CSECT\n*\n         ENTRY IHISAT\n*\nFPR0     EQU   0\nFPR2     EQU   2\nFPR4     EQU   4\nFPR6     EQU   6\n*\n*\nIHISAT   SAVE  (14,12),,'IHISATAN LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHISATAN,R15\n         L     R1,0(,R1)\n         LE    FPR0,0(R1)              OBTAIN ARGUMENT\n         STE   FPR0,SIGN               SAVE ARG FOR SIGN CONTROL\n         LPER  FPR0,FPR0               SET SIGN POSITIVE\n         SR    R1,R1                   R1 DENOTES THE SECTION TO WHICH\n         CE    FPR0,ONE                ANSWER BELONGS. BREAK POINTS ARE\n         BNH   REDUC                 TAN(PI/12), TAN(PI/4), TAN(5PI/12)\n         LE    FPR0,ONE                ARG > 1, TAKE INVERSE\n         DER   FPR0,FPR0\n         LER   FPR0,FPR0\n         LA    R1,8                    SET R1 TO 8\nREDUC    CE    FPR0,TAN15              ARG > TAN(PI/12) ?\n         BNH   OK                      NO, BRANCH\n         LER   FPR0,FPR0               REDUCE THE ARG BY USING\n         ME    FPR0,RT3M1              ATAN(X) = PI/6+ATAN(Y)\n         SE    FPR0,ONE                WHERE Y = (X*SQRT3-1)/(X+SQRT3)\n         AER   FPR0,FPR0\n         AE    FPR0,RT3                CALC X*SQRT3-1 AS X(SQRT3-1)-1+X\n         DER   FPR0,FPR0               TO PROTECT SIGNIFICANT DIGITS\n         LA    R1,4(,R1)               INCR R1 BY 4\nOK       LER   FPR4,FPR0               NOW MAGNITUDE OF REDUCED ARG IS\n         MER   FPR0,FPR0               LESS THAN TAN(PI/12)=0.26795\n         LER   FPR0,FPR0\n         ME    FPR0,C                  COMPUTE ANGLE BY\n         LER   FPR6,FPR0\n         AE    FPR0,A                  ATAN(X)/X = D-C*XSQ+B/(XSQ+A)\n         LE    FPR0,B\n         DER   FPR0,FPR0\n         SER   FPR0,FPR6\n         AE    FPR0,D\n         MER   FPR0,FPR4\n         C     R1,KF8                  DEPENDING ON THE SECTION WHICH\n         BL    LABAA                   ANSWER BELONGS, ADD OR SUBTRACT\n         LCER  FPR0,FPR0               REDUCED ANSWER FROM A BASE ANGLE\nLABAA    AE    FPR0,ZERO(R1)\n         TM    SIGN,X'80'              SIGN OF ANS SHOULD AGREE WITH\n         BZ    LABBB                   SIGN OF ARG\n         LCER  FPR0,FPR0\n*\nLABBB    RETURN (14,12)                RESTORE REGS AND RETURN\n*\nSIGN     DC    F'0'\nONE      DC    X'41100000'\nTAN15    DC    X'40449851'             TAN 15 DEGREES\nRT3M1    DC    X'40BB67AF'             SQRT3-1\nRT3      DC    X'411BB67B'             SQRT3\nKF8      DC    F'8'\nA        DC    X'41168A5E'             1.4087812\nB        DC    X'408F239C'             0.55913709\nC        DC    X'3FD35F49'             0.051604543\nD        DC    X'409A6524'             0.60310579\n*\nZERO     DC    F'0'                *\n         DC    X'40860A92'         |   PI/6\n         DC    X'411921FB'         |   PI/2\n         DC    X'4110C152'         V   PI/3\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHISEX   0201-12230-12230-1200-00131-00131-00000-LEVEL\nXPT      TITLE 'IHISEXPT, EXPONENTIAL, SHORT PRECISION, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        Y = X*LOG2(E) = 4R-S-T\n*        WHERE R AND S ARE INTEGERS\n*        T FRACTION AND BOTH S AND T ARE NON NEGATIVE\n*        THEN E**X = 2**Y = (16**R)(2**-S)N2**-T)\n*\n*        ENTRY POINT -\n*        IHISEX - EXP FUNCTION, SHORT\n*                 LA   R1,PARMLIST\n*                 BALR R14,R15\n*                 DATA PASSED BY NAME\n*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0\n*\n*        EXIT - ERROR - IF ARGUMENT NOT POSITIVE GOTO ERROR\n*                       OUTINE VIA\n*                       B    FSAERR+25*4(R13)\n*\n*        TABLES/WORKAREAS - N/A\n*\nIHISEXPT CSECT\n*\n         ENTRY IHISEX\n*\nFPR0     EQU   0                       RESULT REGISTER\n*\nIHISEX   SAVE  (14,12),,'IHISEXPT LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHISEXPT,R15\n         L     R1,0(,R1)\n         LE    FPR0,0(,R1)             OBTAIN ARGUMENT\n         CE    FPR0,MAX                > MAX ?\n         BH    ERROR                   YES, ERROR\n         CE    FPR0,MIN                > MIN ?\n         BH    OK1                     YES, ACCEPTABLE\n         SER   FPR0,FPR0               VERY SMALL, GIVE 0 AS ANSWER\n         B     EXIT\n*\nOK1      L     R1,0(,R1)               PICK UP ARGUMENT AGAIN\n         SLDL  R0,8\n         N     R0,MASK                 =X'0000007F' CHARACTERISTIC OF X\n         CH    R0,SMALL                R0 > 57 ?\n         BH    OK2                     YES, BRANCH\n         LE    FPR0,ONE                NO, ABS VALUE OF X < 2**-28\n*                                      GIVE 1 AS RESULT\n         B     EXIT                    THIS AVOIDS SHIFT TROUBLE\n*\nOK2      SRL   R1,1                    NORMAL CASE MANTISSA OF X IN R1\n         SLL   R0,2                    B0 -4*CHARACTERISTIC\n         LCR   R2,R0\n         M     R0,LOG2E                LOG E BASE 2 IN B1, PROD IN B2\n         SRDL  R0,287(R2)              B33  /R/ IN R0, /S+T/ IN R1\n         LTER  FPR0,FPR0\n         BNP   OK3                     X NOT POSITIVE, BRANCH\n         X     R0,ALLF                 X POSITIVE, -R = -R(R'+1) IN R0\n         X     R1,ALLF                 S+T = 4-(S'+T') IN R1\nOK3      SLL   R0,24\n         LR    R2,R0                   SAVE -R IN R2 B7, CHAR MODIFIER\n         SLDL  R0,2                    S IN R0 LOW, T IN R1 HIGH\n         LR    R3,R0                   SAVE S IN R3, FOR SHIFT COUNT\n         SRL   R1,4                    T                    (B3)\n         LR    R6,R1                   SAVE T       IN R6   (B3)\n         MR    R0,R1                   T*T                  (B7)\n         LR    R5,R0\n         M     R4,C                    C*T*T        IN R4   (B4)\n         A     R0,A\n         LR    R5,R0                   A+T*T        IN R5   (B7)\n         L     R0,B\n         DR    R0,R5                   B/(A+T*T)    IN R1   (B3)\n         SR    R1,R6\n         SRL   R1,1                    -T+B/(A+T*T) IN R1   (B4)\n         A     R1,D\n         AR    R1,R4                   C*T*T+D-T+B/(A+T*T)  (B4)\n         LR    R4,R6\n         SRL   R4,2                    2*T                  (B6)\n         DR    R4,R1                   2*T/(C*T*T+D-T+B/(A+T*T))   (B1)\n         A     R5,FXONE                2**(-T) NOW READY IN  B1\n         SRL   R5,0(R3)                (2**-S)(2**-T) READY (B1)\n         A     R5,FUDGE                ROUND AND\n         C     R5,FXONE                FLOAT THIS NUMBER\n         BL    OK4\n         L     R5,ONE\n         B     JOIN\n*\nOK4      SRL   R5,6\n         O     R5,FXONE                BASE CHARACTERISTIC\nJOIN     SR    R5,R2                   ADJUST CHARACTERISTIC WITH -R\n         ST    R5,BUFF\n         LE    FPR0,BUFF\n*\nEXIT     RETURN (14,12)                RESTORE REGS AND RETURN\n*\nERROR    L     R13,4(,R13)             RESTORE FSA ADDR\n         B     FSAERR+24*4(R13)        PARAM > 174.673\n*\nFSAERR   EQU   X'1CC'\n*\n         DC    0F'0'\nMAX      DC    X'42AEAC4F'             174.673\nMIN      DC    X'C2B437E0'             -180.218\nONE      DC    X'41100000'\nMASK     DC    X'0000007F'\nLOG2E    DC    X'5C551D95'             LOG E BASE 2    B1\nALLF     DC    X'FFFFFFFF'\nA        DC    X'576AE119'             87.4174972      B7\nB        DC    X'269F8E6B'             617.972269      B11\nC        DC    X'B9059003'             -0.034657359    B-4\nD        DC    X'B05CFCE3'             -9.95459578     B4\nFXONE    DC    X'40000000'             1. B1  ALSO BASE CHARACTERISTIC\nFUDGE    DC    X'00000020'\nBUFF     DC    F'0'\nSMALL    DC    H'57'\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHISLO   0201-12230-12230-1200-00109-00109-00000-LEVEL\nOGM     TITLE 'IHISLOGM, LOGARITHMIC FUNCTION, SHORT PREC, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        WRITE X = M*16**P, M MANTISSA\n*        PICK A BASE VALUE A DEPENDING ON SIZE OF M\n*        WRITE Z = (M-A)/(M+A)\n*        THEN LOG(X) = P*LOG(16) + LOG(A) + LOG((1+Z)/(1-Z))\n*\n*        ENTRY POINT -\n*        IHISLO - LOG FUNCTION, SHORT\n*                 LA   R1,PARMLIST\n*                 BALR R14,R15\n*                 DATA PASSED BY NAME\n*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0\n*\n*        EXIT - ERROR - IF ARGUMENT NOT POSITIVE GOTO ERROR\n*                       OUTINE VIA\n*                       B    FSAERR+25*4(R13)\n*\n*        TABLES/WORKAREAS - N/A\n*\nIHISLOGM CSECT\n*\n         ENTRY IHISLO\n*\nFPR0     EQU   0                       RESULT REGISTER\nFPR2     EQU   2                       SCRATCH REGISTER\n*\nIHISLO   SAVE  (14,12),,'IHISLOGM LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHISLOGM,R15\n         L     R1,0(,R1)\n         ICM   R0,B'1111',0(R1)        OBTAIN ARGUMENT\n         BNP   ERROR                   ARG 0 OR NEGATIVE, ERROR\n         SRDL  R0,24\n         SRL   R1,8\n         ST    R1,ARG                  STORE MANTISSA M ALONE\n         OI    ARG,X'40'               FLOAT IT\n         SLL   R0,2                    4*CHAR IN R0\n         STH   R0,IPART+2              SAVE THIS IN FLOAT FORM\n         SR    R14,R14                 SET R14 TO O,4 OR 8\n         SRL   R1,21                   DEFINE A TO BE 1, 1/4, OR 1/16\n*                                      IF M IS IN\n         IC    R14,TABLE(R1)         (1/2,1),(2/8,1/2),OR IN (J/16,1/8)\n         LE    FPR0,ARG                OBTAIN  Z = (M-A)/(M+A)\n         LER   FPR2,FPR0\n         SE    FPR0,ONE(R14)\n         AE    FPR2,ONE(R14)           POSSIBLY ONLY 21 SIGNIF BPTS\n         DER   FPR0,FPR2\n         STE   FPR0,ARG                Z READY, STORE IT AT ARG\n         MER   FPR0,FPR0               Z**2\n         LE    FPR2,C4                 COMPUTE LOG((1+Z)/(1-Z)) USING\n         MER   FPR2,FPR0             CHEBYSHEV INTERPOLATION POLYNOMIAL\n         AE    FPR2,C3\n         MER   FPR2,FPR0\n         AE    FPR2,C2\n         MER   FPR2,FPR0\n         AE    FPR2,C1\n         MER   FPR2,FPR0\n         LE    FPR0,ARG\n         MER   FPR2,FPR0\n         AER   FPR2,FPR0\n         AER   FPR2,FPR0\n         LE    FPR0,IPART              4*(P+64)\n         SRL   R14,1                   0,2 OR 4 = - LOG(A) BASE 2\n         LA    R14,256(,R14)           4*64-LOG2(A)\n         STH   R14,IPART+2             STORE THIS AND FLOAT IT\n         SE    FPR0,IPART              4*P+LOG2(A)\n         ME    FPR0,LOGE2\n         ADR   FPR0,FPR2               NATURAL LOG READY\n*\n         RETURN (14,12)                RESTORE REGISTERS AND RETURN\n*\nERROR    B     FSAERR+25*4(R13)        PARAMETER ZERO OR NEGATIVE\n*\nFSAERR   EQU   X'1CC'\n*\nARG      DC    F'0'\nIPART    DC    X'46000000'\n*\nTABLE    DC    X'0804040400000000'\n*\nONE      DC    X'41100000'         *   1   FOLLOWING 3 CONSTANTS MUST\n         DC    X'40400000'         |   1/4       BE CONSECUTIVE\n         DC    X'40100000'         V   1/16\n*\nLOGE2    DC    X'40B17219'             LOG(2) BASE E + FUDGE 1\nC4       DC    X'4048157B'             0.28157778\nC3       DC    X'4047973F'             0.27965158\nC2       DC    X'40667685'             0.40024595\nC1       DC    X'40AAAA71'             0.66666322\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHISOR   0201-12230-12230-1200-00312-00312-00000-LEVEL\nREA      TITLE 'IHISOREA, OUTREAL, SHORT PRECISION, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        CONVERT BINARY ARITHMETIC VALUE FROM SECOND PARAMETER\n*        TO ZONED DECIMAL FORM AND TRANSFER TO AN OUTPUT BUFFER\n*\n*        ENTRY POINTS -\n*        IHISOREL - FROM GENERATED OBJECT MODULE\n*                   LA   R1,PARMLIST\n*                   BALR R14,R15\n*                   DATA PASSED BY NAME\n*        IHISORAR - FROM ARRAY MODULE IHIOAR\n*                   LA   R7,DATA\n*                   BALR R14,R15\n*                   DATA PASSED BY NAME\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES -\n*        IHIIOR - EVALUATE DATA SET NUMBER\n*               - OPEN DATA SET\n*               - CHANGE TO NEXT OUTPUT RECORD\n*        IHIFSA - CNVIR - CONVERT INTEGER TO REAL SHORT\n*\n*        EXIT - NORMAL - RELOAD REGISTERS AND RETURN VIA R14\n*\n*        EXIT - ERROR - TOO LONG RECORD NO 38\n*                       BRANCH TO IHIFSA\n*                       L   R13,IHIFSA\n*                       B FSAERR+XX*4(R13) XX ERROR NO\n*\n*        TABLES - PTTAB - POWER OF TEN TABLE, SHORT PREC\n*\n*        NOTES -\n*        LINKING TO IHISORAR DEVIATES FROM STANDARD\n*\nIHISOREA CSECT\n*\n         ENTRY IHISOREL\n         ENTRY IHISORAR\n*\n         USING DSTABLE,R5\n*\nFPR0     EQU   0                       FLOATING-POINT NUMBER\n*\n*        R2                            EXPONENT > 8\n*        R3                            EXPONENT < 8\n*        R4                            CHARACTER POINTER\n*        R7                            -> SOURCE\n*        R8                            BLANK COUNTER\n*        R9                            DECIMAL EXPONENT\n*        R10                           -> POWER TEN TABLE\n*\n*        DISPLACEMENTS IN ADRLST IN IHIFSA\n*\nCI       EQU   0             DISPLACEMENT FOR - IHIIORCI\nCL       EQU   4                                IHIIORCL\nEV       EQU   8                                IHIIOREV\nNX       EQU   12                               IHIIORNX\nOP       EQU   16                               IHIIOROP\nOQ       EQU   20                               IHIIOROQ\n*\nIHISORAR SAVE  (14,12),,'IHISORAR LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHISORAR,R15\n         LR    R11,R13                 CHAIN SAVE AREAS\n         LA    R13,SAVEAREA\n         ST    R11,4(,R13)\n         ST    R13,8(,R11)\n         LA    R11,COMMON\n         DROP  R15\n         USING COMMON,R11\n         B     SOUFLPA\n*\n         DROP  R11\n*\nIHISOREL SAVE  (14,12),,'IHISOREL LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHISOREL,R15\n         LR    R12,R13                 R12 -> FSA  STORAGE AREA TO FSA\n         LA    R13,SAVEAREA\n         ST    R12,4(,R13)\n         ST    R13,8(,R12)\n         LA    R11,COMMON\n         DROP  R15\n         USING COMMON,R11\n*\n*        EVALUATE DATASET NUMBER (EVDSN)\n*\nCOMMON   L     R15,IORLST(,R12)\n         L     R15,EV(,R15)\n         BALR  R14,R15\nSOUFLP   L     R7,4(,R1)               R7 -> SOURCE\nSOUFLPA  OI    DSF,DS2+DS3             DS2, DS3 = 1\n         NI    DSF,255-DS7             DS7 = 0\n         LTR   R7,R7\n         BP    REAL1\n*\n*        CALL CONVERSION ROUTINE (LOADED IN FSA)\n*\n         STM   R14,R13,8(R13)          SAVE REGS\n         LR    R2,R13                  R2 -> SAVEAREA\n         L     14,0(,R7)               INTEGER INTO R14\n         LA    R7,ACNVIRD(R12)\n         LR    R13,R12                 R13 -> FSA\n         BALR  R8,R7                   CALL CONVERSION ROUTINE\n         LM    R14,R13,8(R2)           RESTORE REGS\n         B     REAL1A                  NUMBER IN FPR0 AFTER CONVERSION\n*\nREAL1    LE    FPR0,0(,R7)             NUMBER IN FPR0\nREAL1A   TM    DSF,DS0                 DATASET OPEN ?\n         BO    NOCLO                   YES, BRANCH\n         OI    DSF,DS6                 DS6 = 1 OPEN FOR OUTPUT\n         L     R15,IORLST(,R12)\n         L     R15,OP(,R15)\n         BALR  R14,R15                 CALL OPEN ROUTINE\nNOCLO    L     R4,R                    CHARACTER POINTER\n         LA    R8,13(,R4)\n         C     R8,RE                   BUFFER CAN ACCEPT 13 DIGITS ?\n         BNH   NONEXREC                YES, BRANCH\n         L     R8,RE\n         SR    R8,R4\n         BNP   CALLNXT                 NO, REQUEST NEW RECORD\nBLANKS   MVI   0(R4),C' '              BLANK IN BUFFER\n         LA    R4,1(,R4)               INCR R\n         BCT   R8,BLANKS\nCALLNXT  L     R15,IORLST(,R12)\n         L     R15,NX(,R15)\n         BALR  R14,R15                 GET NEXT RECORD\n         L     R4,R\n         LA    R8,13(,R4)\n         C     R8,RE\n         BH    ORSERR                  TOO SHORT RECORD LENGTH\n         OI    DSF,DS3\nNONEXREC LA    R9,7\n         LTER  FPR0,FPR0               NUMBER ZERO ?\n         BNZ   NOT0                    NO, BRANCH\n         MVI   0(R4),C' '              NUMBER IS ZERO\n         MVC   1(12,R4),0(R4)\n         MVI   1(R4),C'0'\n         B     TERMIN\n*\nNOT0     MVI   0(R4),C'+'              ZONE IS INSERTED\n         BP    EXPLOOP\n         MVI   0(R4),C'-'\n         LCER  FPR0,FPR0\nEXPLOOP  STE   FPR0,CHAR\n         SR    R3,R3\n         IC    R3,CHAR\n         MVI   SE,0\n         S     R3,KF70\n         BP    EXPLOAA\n         BZ    EXP0                    EXPONENT = 78\n         MVI   SE,X'80'\n         LCR   R3,R3\nEXPLOAA  MH    R3,LOG2\n         AH    R3,ROUND\n         SRL   R3,14\n         C     R3,KF70\n         BNH   EXPLOBB\n         L     R3,KF70                 EXPONENT = 70\nEXPLOBB  TM    SE,X'80'\n         LA    R10,PTTAB-4             R10 -> PTTAB-4\n         BZ    EXPLOCC\n         SR    R9,R3\n         B     EXPLODD\nEXPLOCC  LA    R10,64(,R10)\n         AR    R9,R3\nEXPLODD  LR    R2,R3\n         SR    R3,R3                   CLEAR REGISTER\n         SRDA  R2,3\n         SLA   R2,3\nTESTEXP1 BZ    EXP1LS8\n         C     R2,KF72\n         BL    EXP1LS8A                EXPONENT NEGATIVE\n         ME    FPR0,64(,R10)\n         S     R2,KF72\n         B     TESTEXP1\n*\nEXP1LS8A SRL   R2,1\n         ME    FPR0,28(R2,R10)\nEXP1LS8  SRL   R3,27                   EXPONENT MULTIPLIED FOUR\n         LTR   R3,R3\n         BZ    EXPLOOP\n         ME    FPR0,0(R3,R10)\n         B     EXPLOOP\n*\nEXP0     CE    FPR0,TENP7              NUMBER > 10**7 ?\n         BNL   DIG8                    YES, BRANCH\nEXP0AA   MVI   CHAR,0\n         L     R3,CHAR\n         CVD   R3,BUFF                 INTEGER CONVERTED\n         UNPK  1(9,R4),BUFF+3(5)\n         OI    9(R4),X'F0'\n         CLI   2(R4),C'0'              LEADING ZERO ?\n         BNE   TRANSAA\n         BCTR  R9,0\n         MVC   2(7,R4),3(R4)\nTRANSAA  MVC   1(1,R4),2(R4)\n         MVI   2(R4),C'.'              DECIMAL POINT INSERTED\n         MVI   9(R4),C''''             APOSTROPHE INSERTED\nDECEXP   CVD   R9,BUFF\n         UNPK  10(3,R4),BUFF+6(2)\n         LTR   R9,R9\n         BNM   DECEXPAA\n         MVI   10(R4),C'-'             EXPONENT SIGN IS NEGATIVE\n         B     DECEXPBB\n*\nDECEXPAA MVI   10(R4),C'+'\nDECEXPBB OI    12(R4),X'F0'            ZONE INSERTED EXPONENT\nTERMIN   LA    R4,13(,R4)\n         SR    R8,R8\n         IC    R8,K\nTERMINAA C     R4,RE\n         BE    RECEND\n         MVI   0(R4),C' '\n         LA    R4,1(,R4)\n         BCT   R8,TERMINAA\n         C     R4,RE\n         BE    RECEND\n         ST    R4,R\nTERMINBB L     R13,SAVEAREA+4\n*\n         RETURN (14,12)                RESTORE CALLERS REGS AND RETURN\n*\nRECEND   L     R15,IORLST(,R12)\n         L     R15,NX(,R15)\n         BALR  R14,R15\n         B     TERMINBB\n*\nDIG8     AU    FPR0,FIVE\n         STE   FPR0,CHAR\n         CE    FPR0,TWOP24B\n         BL    EXP0AA\n         MVC   1(9,R4),TWOP24           NUMBER GE 10**7\n         B     DECEXP\n*\nORSERR   LR    13,R12\n         B     FSAERR+38*4(R12)\n*\nACNVIRD  EQU   X'120'\n*\n*        INTERNAL CONSTANTS AND STORAGE\n*\nKF72     DC    F'72'\nKF70     DC    F'70'\nLOG2     DC    H'19728'\nROUND    DC    H'8192'\nTENP7    DC    X'46989680'\nFIVE     DC    X'46000005'\nTWOP24B  DC    X'47100000'\nTWOP24   DC    C'1.677722'''\nSE       DC    X'00'\nCHAR     DC    E'0'\nBUFF     DC    D'0'\n*\n*        POWER OF TEN TABLE SHORT PRECISION\n*\nPTTAB    DC    EE1'1'\n         DC    EE2'1'\n         DC    EE3'1'\n         DC    EE4'1'\n         DC    EE5'1'\n         DC    EE6'1'\n         DC    EE7'1'\n         DC    EE8'1'\n         DC    EE16'1'\n         DC    EE24'1'\n         DC    EE32'1'\n         DC    EE40'1'\n         DC    EE48'1'\n         DC    EE56'1'\n         DC    EE64'1'\n         DC    EE72'1'\n         DC    EE-1'1'\n         DC    EE-2'1'\n         DC    EE-3'1'\n         DC    EE-4'1'\n         DC    EE-5'1'\n         DC    EE-6'1'\n         DC    EE-7'1'\n         DC    EE-8'1'\n         DC    EE-16'1'\n         DC    EE-24'1'\n         DC    EE-32'1'\n         DC    EE-40'1'\n         DC    EE-48'1'\n         DC    EE-56'1'\n         DC    EE-64'1'\n         DC    EE-72'1'\n*\nSAVEAREA DC    18F'0'\n*\n         LTORG\n*\n         DSTABLE DSECT=YES\n*\nFAS      DSECT\n*\n         COPY  FSAREA\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHISSC   0201-12230-12230-1200-00137-00137-00000-LEVEL\nCSN      TITLE 'IHISSCSN, SINE/COSINE, SHORT PRECISION, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        1. DIVIDE MAGNITUDE OF ARG BY PI/4 TO FIND OCTANT AND\n*           FRACTION\n*        2. IF COSINE ADD 2 TO OCTANT NUMBER\n*           IF SINE FOR NEGATIVE ARG, ADD 4 TO OCTANT NUMBER\n*        3. COMPUTE SINE OR COSINE OF FRACTION*PI/4 DEPENDING ON\n*           THE OCTANT\n*        4. IF OCTANT NUMBER IS FOR LOWER PLANE MAKE SIGN MINUS\n*\n*        ENTRY POINTS -\n*        IHISSCC - COSINE FUNCTION, SHORT\n*        IHISSCS - SINE FUNCTION, SHORT\n*                  LA   R1,PARMLIST\n*                  BALR R14,R15\n*                  DATA PASSED BY NAME\n*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0\n*\n*        EXIT - ERROR -\n*        IF ABS(ARG) \u00ac< PI*2**18 GOTO ERROR ROUTINE VIA\n*                                B    FSAERR+26*4(R13)\n*\n*        TABLES/WORKAREAS - N/A\n*\nIHISSCSN CSECT\n*\n         ENTRY IHISSCC\n         ENTRY IHISSCS\n*\nFPR0     EQU   0                       RESULT REGISTER\nFPR2     EQU   2                       SCRATCH REGISTERS\nFPR4     EQU   4\n*\nIHISSCC  SAVE  (14,12),,'IHISSCC  LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHISSCC,R15\n         LA    R10,COMMON\n         DROP  R15\n         USING COMMON,R10\n         MVI   CRANK+3,X'02'           FOR COSINE, OCTANT CRANK IS 2\n         L     R1,0(,R1)               COS(X) = SIN(PI/2+X)\n         B     COMMON\n*\n         DROP  R10\n*\nIHISSCS  SAVE  (14,12),,'IHISSCS  LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHISSCS,R15\n         LA    R10,COMMON\n         DROP  R15\n         USING COMMON,R10\n         MVI   CRANK+3,X'00'           OCTANT CRANK IS 0 IF +ARG\n         L     R1,0(,R1)               OCTANT CRANK IS 4 IF -ARG\n         TM    0(R1),X'80'             SIN(-X) = SIN(PI+X)\n         BZ    COMMON\n         MVI   CRANK+3,X'04'\nCOMMON   SDR   FPR0,FPR0               CLEAR FPR0 DOUBLE\n         SDR   FPR2,FPR2               CLEAR FPR2 DOUBLE\n         LE    FPR0,0(,R1)             OBTAIN ARGUMENT\n         LPER  FPR0,FPR0               CONSIDER ARGUMENT TO BE POSITIVE\n         CE    FPR0,MAX                /X/ >= PI*2**18 ?\n         BNL   ERROR                   YES, ERROR\n         MD    FPR0,FOVPI              MULTIPLY BY 4/PI (LONG FORM)\n         CE    FPR0,ONE                < 1 ?\n         BL    SMALL                   YES, BRANCH\n         AW    FPR0,CH46               PROD CHAR OF 46, UNNORMALIZED\n         LER   FPR2,FPR0               INT PART OF PROD TO FPR2, UNNORM\n         SDR   FPR0,FPR2               FRACT PART OF PROD TO FPR0, NORM\nSMALL    AU    FPR2,CRANK              ADD OCTANT CRANK TO FPR2, UNNORM\n         STE   FPR2,OCTNT              SAVE IT\n*                                      LAST 3 BITS ARE MODIFIED OCTANT\n         TM    OCTNT+3,X'01'           IF ODD OCTANT, TAKE COMPLEMENT\n         BZ    EVEN                    OF FRACTION TO OBTAIN THE\n         SE    FPR0,ONE                MOFIFIED FRACTION R\n         LPER  FPR0,FPR0\nEVEN     SR    R1,R1                   R1 = 0 FOR COSINE POLYNOMIAL\n         TM    OCTNT+3,X'03'           THIS IS FOR OCTANT 2,3,6, OR 7\n         BM    LABAA                   IF OCTANT 1,4,5, OR 8, USE SINE\n         LA    R1,4                    POLYNOMIAL, R1 = 4\nLABAA    LER   FPR4,FPR0\n         MER   FPR0,FPR0               COMPUTE SIN OR COS OF MODIFIED\n         LER   FPR2,FPR0               FRACTION USING PROPER CHEBYSHEV\n         ME    FPR0,C3(R1)             INTERPOLATION POLYNOMIAL\n         AE    FPR0,C2(R1)\n         MER   FPR0,FPR2\n         AE    FPR0,C1(R1)\n         MER   FPR0,FPR2\n         AE    FPR0,C0(R1)             SIN(R)/R  OR COS(R) READY\n         LTR   R1,R1\n         BZ    LABBB\n         MER   FPR0,FPR4               IF SINE POLYNOMIAL, MULTIPLY R\nLABBB    TM    OCTNT+3,X'04'\n         BZ    LABCC                   IF MODIFIED OCTANT IS IN\n         LNER  FPR0,FPR0               LOWER PLANE, SIGN IS NEGATIVE\n*\nLABCC    RETURN (14,12)                RESTORE CALLERS REGS AND RETURN\n*\nERROR    B     FSAERR+26*4(13)\n*\nFSAERR   EQU   X'1CC'\n*\n         DC    0D'0'\nFOVPI    DC    X'41145F306DC9C830'\nCH46     DC    X'4600000000000000'\nCRANK    DC    X'46000000'\nMAX      DC    X'45C90FDB'\n*\nC3       DC    X'BE14E5E0'         *   -0.00031888   C3\n         DC    X'BD25B368'         |   -0.00003595   S3\nC2       DC    X'3F40EBD6'         |    0.01584991   C2\n         DC    X'3EA32F62'         |    0.00249001   S2\nC1       DC    X'C04EF4E5'         |   -0.30842425   C1 + FUDGE 1\n         DC    X'C014ABBC'         |   -0.08074543   S1\nC0       DC    X'41100000'         |    1.0          C0\n         DC    X'40C90FDB'         V    0.78539816   S0\nONE      EQU   C0\n*\nOCTNT    DC    F'0'\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHISSQ   0201-12230-12230-1200-00100-00100-00000-LEVEL\nQRT      TITLE 'IHISSQRT, SQUARE ROOT, SHORT PRECISION, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        WRITE X = M*16**(2P-Q), M MANTISSA, Q=0 OR 1\n*        THEN SQRT(X) = SQRT(M*16**-Q)*16**P\n*\n*        ENTRY POINT -\n*        IHISSQ - SQRT FUNCTION, SHORT\n*                 LA   R1,PARMLIST\n*                 BALR R14,R15\n*                 DATA PASSED BY NAME\n*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        EXIT - NORMAL -\n*        RETURN VIA R14, RESULT IN FPR0\n*\n*        EXIT - ERROR -\n*        IF ARGUMENT NEGATIVE GOTO ERROR ROUTINE VIA\n*        B   FSAERR+23*4(R13)\n*\n*        TABLES/WORKAREAS - N/A\n*\nIHISSQRT CSECT\n*\n         ENTRY IHISSQ\n*\nFPR0     EQU   0                       RESULT REGISTER\nFPR2     EQU   2                       SCRATCH REGISTERS\nFPR4     EQU   4\n*\nIHISSQ   SAVE  (14,12),,'IHISSQRT LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IHISSQRT,R15\n         L     R1,0(,R1)\n         L     R0,0(,R1)               OBTAIN ARGUMENT\n         LE    FPR4,0(,R1)\n         LTR   R0,R0\n         BZ    ZRANS                   ARG IS 0, RESULT IS 0\n         BM    ERROR                   NEGATIVE ARG, ERROR\n         AL    R0,BIAS                 ADD X'41' TO CHAR\n         SRDL  R0,25\n         SLL   R0,24                   CHAR OF RESULT IS READY\n         LR    R14,R0                  KEEP IT IN R14\n         LTR   R1,R1                   SIGN BIT OF R1 = 1-Q\n         BM    LABAA\n         A     R14,FOUR                Q=1,ADD 4 (B31) TO R14 FOR INDEX\nLABAA    SRL   R1,3                    SCALE 1+M (Q=0) OR M (Q=1) TO B3\n         A     R1,C(R14)               OBTAIN FIRST APPROXIMATION BY\n*                                      A HYPERBOLIC FIT OF THE\n         L     R0,B(R14)               RESPECTIVE INTERVAL\n         DR    R0,R1                   Q=1, INTERPRET M AS M/16 (B-1)\n         A     R1,A(R14)\n         AR    R1,R14                  ADD ON CHAR TO COMPLETE FIRST\n         ST    R1,BUFF                 APPROXIMATION\n         LER   FPR0,FPR4               GIVE 2 PASSES OF NEWTON-RAPHSON\n         DE    FPR0,BUFF               ITERATION\n         AE    FPR0,BUFF\n         HER   FPR0,FPR0\n         DER   FPR4,FPR0\n         SER   FPR4,FPR0               Y2 =(Y1+X/Y1)/2 = (X/Y1-Y1)/2+Y1\n         HER   FPR4,FPR4               USE THE LATTER TO PROTECT\n         AER   FPR0,FPR4               LAST DIGIT\n*\nFIN      RETURN (14,12)                RESTORE REGS AND RETURN\n*\nZRANS    SER   FPR0,FPR0\n         B     FIN\n*\nERROR    SLL   R0,1\n         LTR   R0,R0                   NEGATIVE ZERO ?\n         BZ    ZRANS\n         B     FSAERR+23*4(R13)        NEGATIVE PARAMETER\n*\nFSAERR   EQU   X'1CC'\n*\nBUFF     DC    F'0'\nBIAS     DC    X'41000000'\nFOUR     DC    F'4'\nA        DC    X'01CE9FE0'             1.8071270   A0 (B7)\n         DC    X'006DC57C'             0.4287950   A1 (B7) MINUS 4(B31)\nB        DC    X'FFE6C37D'            -1.5772732   B0 (B11)\n         DC    X'FFFA82EB'            -0.0214398   B1 (B7)\nC        DC    X'FF44546F'             0.95418214  C0 (B3) MINUS 1(B3)\n         DC    X'0E0A7419'             0.0548470   C1 (B-1)\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IHISYS   0201-12230-12230-1200-00822-00822-00000-LEVEL\nSYS      TITLE 'IHISYSCT, SYSACT I/O SERVICE ROUTINES, ALGOL F LIB'\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n*        FUNCTION/OPERATION -\n*        CONSISTS OF 15 ROUTINES WITH DIFFERENT ACTIONS ON DATASET\n*        WHICH DEPENDING ON SECOND PARAMETER IN SYSACT\n*\n*        ENTRY POINTS -\n*        IHISYSCT - FROM GENERATED OBJECT MODULE\n*                   LA   R1,PARMLIST\n*                   BALR R14,R15\n*                   DATA PASSED BY NAME\n*\n*        INPUT - SYSACT4 READS TWO RECORDS AFTER REPOSITIONING\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES -\n*        IHIIOR - EVALUATE DATASET NUMBER\n*               - OPEN DATASET\n*               - CHANGE TO NEXT RECORD\n*               - CLOSE DATASET\n*               - CONVERT REAL TO INTEGER\n*\n*        EXITS - NORMAL - RELOAD REGISTERS RETURN VIA R14\n*              - ERROR  -\n*                DATASET NUMBER OUT OF RANGE                      NO 0\n*                INCOMPATIBLE ACTIONS ON SAME DATASET             NO 2\n*                INPUT REQUEST BEYOND END OF DATASET              NO 5\n*                UNDEFINED FUNCTION NUMBER                        NO 9\n*                DATASET CLOSED                                   NO 10\n*                DATASET OPEN                                     NO 11\n*                QUANTITY IN SYSACT PROCEDURE MUST BE A VARIABLE  NO 12\n*                QUANTITY IN SYSACT PROCEDURE OUT OF RANGE        NO 13\n*                BACKWARD REPOSITIONING NOT DEFINED               NO 14\n*                BRANCH TO IHIFSA\n*                          L  R13,IHIFSA\n*                          B  FSAERR+XX*4(R13)       XX  ERROR NO\n*\n*        TABLES/WORK AREAS - N/A\n*\n*        ATTRIBUTES - SERIALLY REUSABLE\n*\n*        NOTES -\n*        THE OPERATION OF THIS MODULE DOES NOT DEPEND UPON A\n*        SPECIAL INTERNAL REPRESENTATION OF THE EXTERNAL\n*        CHARACTER SET\n*\n*        REGISTERS\n*        R1  -> PARAMETER LIST\n*        R5  -> DSTABLE ENTRY FOR DATASET\n*        R6   = DATASET NUMBER\n*        R8  -> DCB AND DECB\n*        R12 -> FSA\n*        R13 -> SAVE AREA IN FSA\n*        R14 -> RETURN\n*        R15 -> ROUTINE SYSACT\n*\nIHISYSCT CSECT\n*\n*        FLOATING POINT REGISTER\n*\nFR0      EQU   0\n*\n*        DISPLACEMENTS IN ADRLST IN IHIFSA\n*\n*                                      DISPLACEMENT FOR -\nCI       EQU   0                       IHIIORCI\nCL       EQU   4                       IHIIORCL\nEV       EQU   8                       IHIIOREV\nNX       EQU   12                      IHIIORNX\nOP       EQU   16                      IHIIOROP\nOQ       EQU   20                      IHIIOROQ\n*\n         SAVE  (14,12),,'IHISYSCT LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LR    R7,R15                  LOAD BASE REGISTER\n         USING IHISYSCT,R7\n         LR    R12,R13                 ADDR OF FIXED STORAGE AREA\n*                                      TO R12\n         ST    R13,SAVEAR+4\n         LA    R13,SAVEAR\n         L     R15,IORLST(,R12)        R15 -> COMMON I/O ROUTINES\n         L     R15,EV(,R15)            EVALUATE DATASET NUMBER\n         BALR  R14,R15\n*\n*        ON RETURN -\n*        R6  = DATASET NUMBER\n*        R5 -> DSTABLE ENTRY\n*\n         USING DSTABLE,R5\n*\n*        EVALUATE SECOND PARAMETER FUNCTION\n*\n         ICM   R2,B'1111',4(R1)\n         BNM   SYS1\n         TM    OPTSW(R12),X'20'        CONVERSION TO INTEGER TEST PRE\n         BO    SYS11                   SHORT\n         LD    FR0,0(,R2)              LONG\n         B     SYS11A\n*\nSYS11    LE    FR0,0(,R2)\nSYS11A   L     R15,IORLST(,R12)\n         L     R15,CI(,R15)\n         BALR  R14,R15                 CONVERT TO INTEGER\n         B     SYS1A\n*\nSYS1     L     R0,0(,R2)\nSYS1A    LTR   R2,R0\n         BNP   SYSERR9                 ZERO OR NEG, FUNCT OUT OF RANGE\n         C     R2,=F'15'               EXCEED FUNCTION RANGE\n         BH    SYSERR9                 YES, FUNCTION OUT OF RANGE\n         SLA   R2,2                    CONVERT TO OFFSET\n         L     R3,SYSVECT(R2)          R3 -> REQUESTED SYSACT ROUTINE\n*\n*        EVALUATE THIRD PARAMETER QUANTITY\n*\n         SR    R9,R9                   ZERO REG USED AS FLAG\n         L     R2,8(,R1)\n         SLL   R2,1\n         LTR   R2,R2\n         BM    SYS11B\n         LA    R9,1(,R9)               QUANTITY IS A VARIABLE\nSYS11B   SRL   R2,1\n         N     R2,=X'00FFFFFF'\n         L     R4,0(,R2)\n*\n*        R3 -> REQUESTED SYSSACT\n*        R2 -> QUANTITY\n*        R4  = QUANTITY\n*        R9 EQUAL ONE IF QUANTITY IS A VARIABLE ELSE ZERO\n*\n         BR    R3                      BRANCH TO SYSACT ROUTINE\n*\nRETSYS   L     R13,SAVEAR+4\n*\n         RETURN (14,12)                RESTORE CALLERS REGS AND RETURN\n*\nSYSERR9  LR    R13,R12                 UNDEFINED FUNCTION NUMBER ERR9\n         B     FSAERR+9*4(R12)\n*\n*        BRANCH TO NEXTREC IN IHIIOR\n*\nNXREC    L     R15,IORLST(R12)\n         L     R15,NX(R15)\n         BR    R15\n*\n*----------------------------------------------------------------------\n*        ROUTINE SYSACT1\n*----------------------------------------------------------------------\n*\n*        QUANTITY = R\n*\nSYSACT1  TM    DSF,DS0\n         BO    SYS1T1\nSYSCLOSD LR    R13,R12                 DATASET IS CLOSED ERROR 10\n         B     FSAERR+10*4(R12)\n*\nSYS1T1   LTR   R9,R9\n         BP    SYS1T2\nSYSCONST LR    R13,R12                 QUANTITY SHOULD BE A VARIABLE\n         B     FSAERR+12*4(R12)        ERROR12\n*\nSYS1T2   L     R4,R\n         S     R4,RE\n         AH    R4,P\n         LA    R4,1(,R4)\n         ST    R4,0(,R2)\n         B     RETSYS\n*\n*----------------------------------------------------------------------\n*        ROUTINE SYSACT2\n*----------------------------------------------------------------------\n*\n*        R = QUANTITY\n*\nSYSACT2  LTR   R4,R4\n         BP    SYSACT2A\n         B     SYS2T1\n*\nSYSACT2A CH    R4,P\n         BNH   SYS2T1+6\nSYS2T1   LR    R13,R12\n         B     FSAERR+13*4(R12)        QUANTITY OUT OF RANGE ERROR 13\n*\n         TM    DSF,DS0\n         BZ    SYSCLOSD                DATASET IS CLOSED\n         LR    R3,R4\n         A     R3,RE\n         SH    R3,P\n         BCTR  R3,0\n         S     R3,R\n         BP    SYS2T2\n*\n*        NEW CHARACTER POINTER LESS OR EQUAL R\n*\n         TM    DSF,DS2\n         BO    SYS2T3\n         TM    DSF+1,DS10              DATASET OPENED BY SYSACT 12 ?\n         BO    SYS2T30\n         TM    DSF,DS7                 EOD BEEN REACHED ?\n         BO    SYSEOD\n         BAL   R14,NXREC               LAST I/O PROCEDURE WAS INPUT\n         TM    DSF,DS7                 END OF DATA REACHED ?\n         BZ    SYS2T1A\n         LR    R3,R4                   QUANTITY = 1 ?\n         BCT   R3,SYSEOD               NO, INPUT REQUEST BEYOND EOD\nSYS2T1A  A     R4,RE\n         SH    R4,P                    ASSIGN A NEW VALUE TO CHARACTER\n         BCTR  R4,0\n         ST    R4,R\n         B     RETSYS\n*\nSYS2T30  LTR   R6,R6                   DATASET NUMBER = 0 ?\n         BZ    SYSINCOM                YES, BRANCH\n         OI    DSF,DS2\n*\n*        LAST I/O PROCEDURE WAS OUTPUT\n*\nSYS2T3   L     R3,RE\n         S     R3,R\n         BZ    SYS2T31\n         LA    R15,SYBLANK             FILL RECORD WITH BLANKS\n         BALR  R14,R15\nSYS2T31  BAL   R14,NXREC\n*\n         LR    R3,R4\n         BCTR  R3,0\n         LTR   R3,R3\n         BZ    SYS2T32\n         OI    DSF,DS3\n         LA    R15,SYBLANK             FILL RECORD WITH BLANKS\n         BALR  R14,R15\nSYS2T32  L     R11,R\n         AR    R4,R11\n         BCTR  R4,0                    CHARACTER POINTER\n         ST    R4,R                    QUANTITY+R-1 ASSIGN TO R\n         B     RETSYS\n*\n*        NEW CHARACTER POINTER GREATER THAN R\n*\nSYS2T2   TM    DSF,DS2\n         BO    SYS2T20\n         TM    DSF+1,DS10              DS BEEN OPENED BY SYSACT 12 ?\n         BZ    SYS2T5\n         LTR   R6,R6                   DATASET NUMBER = 0 ?\n         BZ    SYSINCOM                YES, BRANCH\n         OI    DSF,DS2\nSYS2T20  LR    R3,R4                   LAST I/O WAS OUTPUT\n         A     R3,RE\n         S     R3,R\n         OI    DSF,DS3\n         SH    R3,P\n         BCTR  R3,0\n         LA    R15,SYBLANK             FILL RECORD WITH BLANKS\n         BALR  R14,R15\n*\nSYS2T5   TM    DSF,DS7                 EOD BEEN REACHED ?\n         BO    SYSEOD\nSYS2T4   A     R4,RE\n         SH    R4,P                    ASSIGN NEW VALUE TO CHAR POINTER\n         BCTR  R4,0\n         ST    R4,R\n         B     RETSYS\n*\n*----------------------------------------------------------------------\n*        ROUTINE SYSACT3\n*----------------------------------------------------------------------\n*\n*        QUANTITY = S\n*\nSYSACT3  TM    DSF,DS0\n         BZ    SYSCLOSD                DATASET CLOSED ERROR10\n         LTR   R9,R9\n         BZ    SYSCONST                QUANTITY NOT A VARIABLE ERR 12\n         LH    R4,S\n         ST    R4,0(,R2)\n         B     RETSYS\n*\n*----------------------------------------------------------------------\n*        ROUTINE SYSACT4\n*----------------------------------------------------------------------\n*\n*        UNDEFINED IF DATASET SPLIT INTO SECTION BY SYSACT8 OR\n*        IF THE DATASET IS 0 OR 1\n*\n*        ACTION AFTER INPUT - S = QUANTITY\n*                             R = 1\n*        ACTION AFTER OUTPUT - S = QUANTITY\n*                              R = 1\n*        IF FORWARD SKIPPING FILL SKIPPED RECORDS WITH BLANKS\n*\nSYSACT4  L     R8,ADCB\n         LTR   R4,R4                   TEST QUANTITY\n         BP    SYS4T01\n         LR    R13,R12\n         B     FSAERR+13*4(R12)        QUANTITY OUT OF RANGE\n*\nSYS4T01  TM    DSF+1,DS9               DATASET SECTIONED ?\n         BO    SYSINCOM\n         LTR   R2,R6                   DATASET NO = 1 OR 0 ?\n         BZ    SYSINCOM\n         BCT   R2,SYS4T0\n         B     SYSINCOM\n*\nSYS4T0   TM    DSF,DS0                 DATASET OPEN ?\n         BZ    SYSCLOSD\n         CH    R4,S                    QUANTITY > S ?\n         BL    SYS4T2                  NO, LESS\n         BE    SYS4T3                  NO, EQUAL\nSYS4T1   TM    DSF,DS2                 LAST I/O OUTPUT ?\n         BO    SYS4T15                 YES, BRANCH TO SYS4T15\n*\n*        LAST I/O INPUT AND QUANTITY > S\n*\n         TM    DSF+1,DS10              DS BEEN OPENED BY SYSACT 12 ?\n         BZ    SYS4T12\n         OI    DSF,DS2                 DATASET OPEN FOR OUTPUT\n         B     SYS4T15\n*\nSYS4T12  LA    R15,SYSNOT              QUANTITY IN NOTTAB ?\n         BALR  R14,R15\n         TM    DSF,DS7                 EOD BEEN REACHED ?\n         BO    SYSEOD\n         LTR   R3,R3\n         BP    SYS4T21                 YES, BRANCH TO SYS4T21\nSYS4T13  TM    DSF,DS7                 END OF DATA BEEM REACHED ?\n         BO    SYSEOD\n         BAL   R14,NXREC               GET NEXT RECORD\n         CH    R4,S                    QUANTITY = S ?\n         BNE   SYS4T13\n         B     RETSYS\n*\n*        LAST I/O OUTPUT AND QUANTITY > S\n*\nSYS4T15  L     R3,RE                   FILL RECORD WITH BLANKS\n         S     R3,R\n         BZ    SYS4T14\n         LA    R15,SYBLANK\n         BALR  R14,R15\nSYS4T14  BAL   R14,NXREC\n         CH    R4,S                    QUANTITY = S ?\n         BNE   SYS4T15\n         B     RETSYS\n*\nSYS4T2   LA    R15,SYSNOT              QUANTITY IN NOTTAB ?\n         BALR  R14,R15\n         LTR   R3,R3\n         BZ    SYSERR14                NO BACKWARD REP. NOT DEFINED\n         TM    DSF,DS2                 LAST I/O OUTPUT ?\n         BO    SYS4T24\n*\n*        LAST I/O INPUT AND QUANTITY < S\n*\n         OI    DSF,DS5                 DS5=1\n         NI    DSF,255-DS6-DS7         SET DS6 AND DS7 = 0\nSYS4T21  OI    DSF+1,DS8               DS8=1\n         USING IHADCB,R8\n*\n         CHECK SYDECB\n*\n         NI    DSF+1,255-DS8           SET DS8=0\nSYS4T22  LR    R0,R10\n         LR    R1,R8\n*\n         POINT (1),(0)\n*\n         L     R2,NBB\n*\n         READ  SYDECB,SF,(R8),(R2),MF=E\n*\n         L     R2,BB\n         AH    R2,BL\n         ST    R2,RE\n         LR    R2,R4\n         BCTR  R2,0\n         STH   R2,S                    S = QUANTITY - 1\n         BAL   R14,NXREC\n         TM    DSF,DS1                 DATASET BLOCKED ?\n         BO    RETSYS\n         SR    R2,R2                   YES, EVALUATE NUMBER OF FIRST\n         L     R3,BL                   RECORD IN THE BLOCK =\n         SRL   R3,16                   ENTIER((QUANTITY-1)/(BLKLTH/\n         L     R1,S                    RECLNTH))*(BLKLNTH/RECLNTH)+1\n         SLL   R1,16\n         SRL   R1,16\n         DR    R2,R1\n         LR    R1,R3\n         SR    R2,R2\n         LR    R3,R4\n         BCTR  R3,0\n         DR    R2,R1\n         MR    R2,R1\n         LA    R3,1(R3)\n         STH   R3,S\nSYS4T23  CH    R4,S                    QUANTITY = S ?\n         BE    RETSYS\n         BAL   R14,NXREC\n         B     SYS4T23\n*\n*        LAST I/O WAS OUTPUT AND QUANTITY < S\n*\nSYS4T24  TM    DSF,DS1                 DATASET BLOCKED ?\n         BO    SYS4T25\n         L     R3,BB\n         AH    R3,BL\n         ST    R3,RE\nSYS4T25  L     R3,RE                   FILL BLOCK WITH BLANKS\n         S     R3,R\n         BZ    SYS4T26\n         LA    R15,SYBLANK\n         BALR  R14,R15\nSYS4T26  BAL   R14,NXREC\n*\nSYS4T27  CHECK SYDECB\n*\n         CLOSE ((R8),LEAVE),TYPE=T     SET END OF DATA MARK\n*\n         OI    DSF,DS5\n         NI    DSF,255-DS2-DS6         SET DS2 AND DS6 = 0\n         B     SYS4T22                 WAS LAST I/O OUTPUT\n*\nSYS4T3   TM    DSF,DS2\n         BZ    SYS4T31\n*\n*        LAST I/O OUTPUT AND QUANTITY = S\n*\n         OI    DSF,DS4\n         L     R3,BB\n         AH    R3,BL\n         ST    R3,RE\n         S     R3,R                    FILL BLOCK WITH BLANKS\n         BZ    SYS4T33\n         LA    R15,SYBLANK\n         BALR  R14,R15\nSYS4T33  BAL   R14,NXREC               WRITE BLOCK\n         LA    R15,SYSNOT              MAKE NOTTAB ENTRY\n         BALR  R14,R15\n         B     SYS4T27\n*\n*        LAST I/O INPUT AND QUANTITY = S\n*\nSYS4T31  L     R2,RE\n         SH    R2,P\n         ST    R2,R                    RESET CHARACTER POINTER\n         B     RETSYS\n*\nSYSEOD   LR    R13,R12\n         B     FSAERR+5*4(R12)\n*\n*        SCAN NOTTAB IN ORDER TO FIND OUT IF AN ENTRY HAS BEEN\n*        MADE FOR QUANTITY\n*        IF YES R3 IS SET TO ONE, ADDR OF NOTEADR IN R10\n*\nSYSNOT   L     R3,ANOTTAB(R12)\n         LR    R10,R3\nSYSNOT1  C     R10,0(,R3)\n         BE    SYSNOT2\n         LA    R10,8(,R10)\n         LR    R2,R6\n         CH    R2,0(,R10)\n         BNE   SYSNOT1\n         CH    R4,2(,R10)\n         BNE   SYSNOT1\n         SR    R3,R3\n         LA    R3,1(,R3)\n         LA    R10,4(,R10)\n         BR    R14\n*\nSYSNOT2  SR    R3,R3\n         BR    R14\n*\nSYSERR14 LR    R13,R12                 BACKWARD REPOSITIONING NOT\n         B     FSAERR+14*4(R12)        DEFINED\n*\n*----------------------------------------------------------------------\n*        ROUTINE SYSACT5\n*----------------------------------------------------------------------\n*\n*        QUANTITY = P\n*\nSYSACT5  TM    DSF,DS0\n         BZ    SYSCLOSD                DATASET CLOSED ERROR10\n         LTR   R9,R9\n         BZ    SYSCONST                QUANTITY NOT A VARIABLE ERR 12\n         LH    R4,P\n         ST    R4,0(,R2)\n         B     RETSYS\n*\n*----------------------------------------------------------------------\n*        ROUTINE SYSACT6\n*----------------------------------------------------------------------\n*\n*        P = QUANTITY\n*        DATASET HAS TO BE CLOSED\n*\nSYSACT6  TM    DSF,DS0\n         BO    SYSOPEN\n         LTR   R4,R4                   TEST QUANTITY\n         BNP   SYSQOUTR                MINUS OR ZERO\n         C     R4,=F'32760'\n         BH    SYSQOUTR                TOO GREAT\n         STH   R4,P\n         B     RETSYS\n*\nSYSOPEN  LR    R13,R12                 DATASET IS OPEN ERROR 11\n         B     FSAERR+11*4(R12)\n*\n*----------------------------------------------------------------------\n*        ROUTINE SYSACT7\n*----------------------------------------------------------------------\n*\n*        QUANTITY = Q\n*\nSYSACT7  LTR   R9,R9\n         BZ    SYSCONST                QUANTITY NOT A VARIABLE ERR 12\n         SR    R4,R4\n         IC    R4,Q\n         ST    R4,0(,R2)\n         B     RETSYS\n*\n*----------------------------------------------------------------------\n*        ROUTINE SYSACT8\n*----------------------------------------------------------------------\n*\n*        Q = QUANTITY\n*        DATASET HAS TO BE CLOSED\n*        ASSIGNING A VALUE TO Q\n*\nSYSACT8  TM    DSF,DS0\n         BO    SYSOPEN                 DATASET IS OPEN ERROR11\n         LTR   R6,R6                   DATASET 0 ?\n         BZ    SYSINCOM                YES, INCOMPATIBLE ACTION\n         LTR   R3,R4                   TEST QUANTITY\n         BNP   SYSQOUTR                MINUS OR ZERO\n         S     R3,KF256\n         BP    SYSQOUTR\n         BZ    SYSQOUTR\n         STC   R4,Q\n         OI    DSF+1,DS9               RECORD CONTAIN CNTL CHARACTER\n         B     RETSYS\n*\nSYSDSN0  LR    R13,R12                 DATASET NUMBER OUT OF RANGE\n         B     FSAERR(R12)\n*\nSYSQOUTR LR    R13,R12                 QUANTITY OUT OF RANGE ERROR 13\n         B     FSAERR+13*4(R12)\n*\nKF256    DC    F'256'\n*\n*----------------------------------------------------------------------\n*        ROUTINE SYSACT9\n*----------------------------------------------------------------------\n*\n*        QUANTITY = K\n*\nSYSACT9  LTR   R9,R9\n         BZ    SYSCONST                QUANTITY NOT A VARIABLE ERR 12\n         SR    R4,R4\n         IC    R4,K\n         ST    R4,0(,R2)\n         B     RETSYS\n*\n*----------------------------------------------------------------------\n*        ROUTINE SYSACT10\n*----------------------------------------------------------------------\n*\n*        K = QUANTITY\n*        ASSIGN NUMBER OF BLANK DELIMTERS\n*\nSYSACT10 LTR   R4,R4                   TEST QUANTITY\n         BNP   SYSQOUTR                MINUS OR ZERO\n         C     R4,KF256\n         BNL   SYSQOUTR                TOO GREAT\n         STC   R4,K\n         B     RETSYS\n*\n*----------------------------------------------------------------------\n*        ROUTINE SYSACT11\n*----------------------------------------------------------------------\n*\n*        ASSIGN VALUE TO QUANTITY FOR DEFINING IF DATASET OPEN\n*        OR CLOSED\n*\nSYSACT11 LTR   R9,R9\n         BZ    SYSCONST                QUANTITY NOT A VARIABLE ERR 12\n         SR    R4,R4\n         TM    DSF,DS0\n         BZ    SYS11T1                 DATASET IS CLOSED\n         LA    R4,1(,R4)\n         TM    DSF,DS7\n         BO    SYS11T2                 DS7 EQUAL 1\n         TM    DSF,DS2\n         BO    SYS11T1                 OUTPUT\n         TM    DSF,DS1\n         BO    SYS11T1                 UNBLOCKED\n         L     R11,R\n         L     R1,RE\n         SH    R1,P\n         CR    R1,R11\n         BNE   SYS11T1                 R NOT EQUAL RE MINUS P\n         L     R1,BB\n         AH    R1,BL\n         SR    R1,R11\nSYS11T3  CLI   0(R11),C' '\n         BNE   SYS11T1                 CHARACTER NOT BLANK\n         LA    R11,1(R11)\n         BCT   R1,SYS11T3\n         L     R8,ADCB\n*\n         CHECK SYDECB\n*\n         TM    DSF,DS7\n         BZ    SYS11T1                 NO END OF DATA\nSYS11T2  LNR   R4,R4\nSYS11T1  ST    R4,0(,R2)\n         B     RETSYS\n*\n*----------------------------------------------------------------------\n*        ROUTINE SYSACT12\n*----------------------------------------------------------------------\n*\n*        OPEN OR CLOSE DATASET\n*\nSYSACT12 LTR   R4,R4\n         BZ    SYS12T1\n         BCT   R4,SYSQOUTR             QUANTITY OUT OF RANGE\n         TM    DSF,DS0                 ROUTINE SHOULD PERFORM OPEN\n         BO    SYS12T2                 DATASET WAS OPEN ALREADY\n         OI    DSF+1,DS10              DS10=1 DS OPENED BY SYSACT 12\n         L     R15,IORLST(R12)\n         L     R15,OQ(R15)             OPEN DATASET\n         BALR  R14,R15\n         B     RETSYS\n*\nSYS12T1  TM    DSF,DS0                 ROUTINE SHOULD PERFORM CLOSE\n         BZ    SYS12T2                 DATASET WAS CLOSED ALREADY\n         L     R15,IORLST(R12)\n         L     R15,CL(,R15)\n         BALR  R14,R15\nSYS12T2  B     RETSYS\n*\n*----------------------------------------------------------------------\n*        ROUTINE SYSACT13\n*----------------------------------------------------------------------\n*\n*        QUANTITY = S\n*        SETTING DS4 FLAG USED BY A LATER SYSACT4 FOR AN ENTRY\n*        TO NOTTAB\n*\nSYSACT13 TM    DSF,DS0\n         BZ    SYSCLOSD                DATASET IS CLOSED ERROR10\n         TM    DSF+1,DS9               DATASET SECTIONED ?\n         BO    SYSINCOM                YES, INCOMPATIBLE ACTION\n         LTR   R3,R6                   DATASET NO = 1 OR 0 ?\n         BZ    SYSINCOM\n         BCT   R3,SYS13T1\n*\nSYSINCOM LR    R13,R12                 INCOMPATIBLE ACTION ON THE SAME\n         B     FSAERR+2*4(R12)         DATASET\n*\nSYS13T1  LTR   R9,R9\n         BZ    SYSCONST                QUANTITY NOT A VARIABLE ERR 12\n         LH    R4,S\n         ST    R4,0(,R2)\n         OI    DSF,DS4                 SET FLAG DS4\n         B     RETSYS\n*\n*----------------------------------------------------------------------\n*        ROUTINE SYSACT14\n*----------------------------------------------------------------------\n*\n*        SKIPS RECORDS OR FILLS THEM BY BLANKS, DEPENDING ON THE\n*        LAST I/O PROCEDURE\n*\nSYSACT14 LTR   R4,R4\n         BNP   SYSQOUTR                QUANTITY OUT OF RANGE ERROR13\n         TM    DSF,DS0\n         BZ    SYSCLOSD\nSYS14T1  AH    R4,S\n         TM    Q,X'FF'\n         BZ    SYS14T2\n*\n*        SECTIONED FORMAT ONLY OUTPUT POSSIBLE\n*\n         SR    R2,R2\n         IC    R2,Q\n         CR    R4,R2\n         BNH   SYS14T2\n         L     R3,RE\n         S     R3,R                    NUMBER OF BLANKS IN R3\n         BZ    SYS14T11\n         LA    R15,SYBLANK             FILL RECORD WITH BLANKS\n         BALR  R14,R15\nSYS14T11 MVC   S+1(1),Q\n         OI    DSF,DS2                 OUTPUT\n         BAL   R14,NXREC               SKIP TO BEGIN OF NEXT SECTION\n         B     RETSYS\n*\n*        NOT SECTIONED FORMAT OR QUANTITY LESS OR EQUAL Q\n*\nSYS14T2  TM    DSF,DS2\n         BZ    SYS14T4                 LAST I/O WAS INPUT\nSYS14T3  L     R3,RE\n         S     R3,R\n         BZ    SYS14T5\n         LA    R15,SYBLANK             FILL RECORD WITH BLANKS\n         BALR  R14,R15\nSYS14T5  BAL   R14,NXREC\n         CH    R4,S\n         BNE   SYS14T3\n         B     RETSYS\n*\n*        INPUT\n*\nSYS14T4  TM    DSF+1,DS10              DS BEEN OPENED BY SYSACT 12 ?\n         BO    SYS14T7\n*\n*        ONLY INPUT READ THE FOLLWING UNTIL RECORD POINTER S\n*        EQUALS QUANTITY\n*\nSYS14T6  TM    DSF,DS7                 EOD BEEN REACHED ?\n         BO    SYSEOD\n         BAL   R14,NXREC\n         CH    R4,S\n         BE    RETSYS\n         B     SYS14T6\n*\nSYS14T7  LTR   R6,R6                   DATASET NUMBER = 0 ?\n         BZ    SYSINCOM                YES, BRANCH\n         OI    DSF,DS2                 OUTPUT\n         B     SYS14T3\n*\n*----------------------------------------------------------------------\n*        ROUTINE SYSACT15\n*----------------------------------------------------------------------\n*\n*        SKIP TO RECORD EQUAL QUANTITY IN NEXT SECTION IF DATA\n*        IS NOT SECTIONED. SYSACT14 IS INVOKED\n*\nSYSACT15 LTR   R4,R4\n         BNP   SYSQOUTR                QUANTITY OUT OF RANGE ERROR13\n         TM    DSF,DS0\n         BZ    SYSCLOSD\n         TM    Q,X'FF'\n         BZ    SYS14T1                 DATA IS NOT SECTIONED SYSACT14\n*                                      IS INVOKED\n         SR    R3,R3\n         IC    R3,Q\n         CR    R4,R3\n         BH    SYSQOUTR\n         L     R3,RE\n         S     R3,R                    FILL RECORD WITH BLANKS\n         BZ    SYS15T0\n         LA    R15,SYBLANK             FILL RECORD WITH BLANKS\n         BALR  R14,R15\nSYS15T0  MVC   S+1(1),Q\n         OI    DSF,DS2                 OUTPUT\n         BAL   R14,NXREC\n         LR    R3,R4\n         BCT   R3,SYS14T3\n*\nSYS15T1  B     RETSYS                  QUANTITY EQUALS ONE\n*                                      FIRST RECORD IN NEXT SECTION\n*\n*        SYBLANK FILL RECORD WITH BLANKS\n*\nSYBLANK  L     R11,R\nSYBLANK1 MVI   0(R11),C' '\n         LA    R11,1(,R11)\n         BCT   R3,SYBLANK1\n         BR    R14\n*\n*        CONSTANTS\n*\nSAVEAR   DC    18F'0'                  SAVEAREA\n*\n         LTORG\n*\n*        SYSACT VECTOR TABLE\n*\nSYSVECT  DS    A(0)\n         DC    A(SYSACT1)\n         DC    A(SYSACT2)\n         DC    A(SYSACT3)\n         DC    A(SYSACT4)\n         DC    A(SYSACT5)\n         DC    A(SYSACT6)\n         DC    A(SYSACT7)\n         DC    A(SYSACT8)\n         DC    A(SYSACT9)\n         DC    A(SYSACT10)\n         DC    A(SYSACT11)\n         DC    A(SYSACT12)\n         DC    A(SYSACT13)\n         DC    A(SYSACT14)\n         DC    A(SYSACT15)\n*\n*        DSTABLE\n*\n         DSTABLE  DSECT=YES\n*\n*        DSECT FOR ADDRESSING DECB\n*\n         PRINT NOGEN\n*\n         DCBD  DSORG=BS,DEVD=DA\n*\n         PRINT GEN\n*\n         READ  SYDECB,SF,MF=L\n*\nFAS      DSECT\n*\n         COPY  FSAREA\n*\n         IEZREGS\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AL21LMAC": {"ttr": 52229, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x135\\x01[\\x01[\\x00\\x00\\xd3\\xc9\\xc2\\xd9\\xd4\\xc1\\xc3@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T13:35:00", "lines": 347, "newlines": 347, "modlines": 0, "user": "LIBRMAC"}, "text": "./ ADD NAME=DSTABLE  0201-12230-12230-1200-00067-00067-00000-LEVEL\n         MACRO\n         DSTABLE &DSECT=YES\n.*\n.*       COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n.*\n.*       LEVEL 2.1 -\n.*       THIS IS A NEW MACRO REQUIRED AS PART OF THE\n.*       REFURBISHMENT OF THE LAST IBM RELEASE OF\n.*       THE ALGOL F COMPILER\n.*\n.*       FUNCTION -\n.*       DSTABLE GENERATES EITHER A DSECT OR THE MODEL PATTERN\n.*       FOR A DSTABLE ENTRY USED FOR DATASET CONTROL\n.*\n.*       NOTES -\n.*       1. THIS MACRO IS REQUIRED FOR THE ASSEMBLY OF THE\n.*          ALGOL F COMPILER AS WELL AS THE ALGOL F LIBRARY\n.*\n         AIF   ('&DSECT' EQ 'NO').LAB1\n.*\nDSTABLE  DSECT\n*\n         AGO   .LAB2\n.LAB1    ANOP\n.*\nDSTABLE  DC    0F'0'\n.LAB2    ANOP\nADCB     DC    F'0'                    -> DCB\nR        DC    F'0'                    CHARACTER POINTER\nRE       DC    F'0'\nNBB      DC    F'0'\nBB       DC    F'0'\nS        DC    H'1'                    RECORD POINTER\nP        DC    H'80'                   RECORD LENGTH\nK        DC    X'02'                   NUMBER OF BLANK DELIM CHARS\nQ        DC    X'00'                   NO OF RECORDS PER SECTION\nDSF      DC    H'00'                   DATASET FLAGS\n*\n*        DATASET FLAGS - DSF\n*\nDS0      EQU   X'80'                   DATASET OPEN\nDS1      EQU   X'40'\nDS2      EQU   X'20'                   LAST I/O OUTPUT\nDS3      EQU   X'10'\nDS4      EQU   X'08'\nDS5      EQU   X'04'\nDS6      EQU   X'02'                   OPEN FOR OUTPUT\nDS7      EQU   X'01'                   END OF FILE\n*\n*        DATASET FLAGS - DSF+1\n*\nDS8      EQU   X'80'                   END OF DATA\nDS9      EQU   X'40'\nDS10     EQU   X'20'                   OPENED BY SYSACT 12\nDS11     EQU   X'10'                   INDICATE IHIERR-ROUT\nDSEOD    EQU   X'08'\nDSIOERR  EQU   X'04'                   I/O ERROR\nDS14     EQU   X'02'                   DATASET OPENED\nDS15     EQU   X'01'                   CLOSE FROM IHIERR\n*\nNOTEADR  DC    F'0'\nBL       DC    H'0'                    LRECL+ TWO ARB\n         DC    H'0'\n*\nDSTABLEL EQU   *-DSTABLE               L'DSTABLE ENTRY\n*\n         MEND\n./ ADD NAME=FSACONV  0201-12230-12230-1200-00087-00087-00000-LEVEL\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n***********************************************************************\n*\n*        TYPE CONVERSION ROUTINES\n*\n*        FSACONV\n*\n***********************************************************************\n*\n*        PERFORM CONVERSION BETWEEN INTEGER AND REAL TYPE\n*        FOR EITHER SINGLE OR DOUBLE PRECISION\n*\n*        CALLING SEQUENCES -\n*\n*        REAL TO INTEGER CONVERSION\n*        BAL   R8,CNVRDI(R13)           REAL NUMBER IN FPR0\n*                                       RETURN WITH INTEGER IN R14\n*\n*        INTEGER TO REAL CONVERSION\n*        BAL   R8,CNVIRD(R13)           INTEGER NUMBER IN R14\n*                                       RETURN WITH REAL NO IN FPR0\n*\n*        ALGOL ENTIER FUNCTION\n*        BAL   R8,ENTIER(R13)           REAL NUMBER IN FPR0\n*                                       RETURN WITH INTEGER IN R14\n*\n*        INTEGER TO REAL CONVERSION\n*\n         USING FSAREA,R13\nCONVIR   EQU   *\nCNVIRD   EQU   *-FSAREA\n         X     R14,CNVCNST1+4\n         ST    R14,CNVBUF1+4\n         LD    FPR0,CNVBUF1\n         SD    FPR0,CNVCNST1\nCNVINST  EQU   *                        ***\n         STD   FPR0,CNVBUF2               *\n         MVC   CNVBUF2+1(3),CNVCNST1+1    *\n         AD    FPR0,CNVBUF2               *\n         BR    R8                         *\n*                                         * FOR LONG PRECISION, THESE\n*        REAL TO INTEGER CONVERSION       * ARE REPLACED AT EXECUTION\n*                                         * TIME BY THE INSTRUCTIONS\n*                                         * AT CNVINSTD\nENTIER   EQU   *-FSAREA                   *\n         STE   FPR0,CNVBUF3               *\n         LD    FPR0,CNVBUF3               *\n         B     ENTIER1                    *\n*                                         *\nCNVRDI   EQU   *-FSAREA                   *\n         STE   FPR0,CNVBUF3               *\n         LD    FPR0,CNVBUF3               *\n*                                       ***\n         AD    FPR0,CNVCNST2\nENTIER1  STD   FPR0,CNVBUF4\n         CE    FPR0,CNVCNST3\n         BNL   ERROR40(R13)\n         AW    FPR0,CNVCNST1\n         BP    LABEL1\n         CLC   CNVBUF4(8),CNVCNST4\n         BH    ERROR40(R13)\nLABEL1   STD   FPR0,CNVBUF2\n         L     R14,CNVBUF2+4\n         X     R14,CNVCNST1+4\n         SD    FPR0,CNVCNST1\n         CD    FPR0,CNVBUF4\n         BNHR  R8\n         BCTR  R14,R8\n*\n         DC    0D'0'\nCNVBUF1  DC    X'4E00000000000000'\nCNVBUF2  DC    D'0'\nCNVBUF3  DC    X'0000000000000000'\nCNVBUF4  DC    D'0'\nCNVCNST1 DC    X'4E00000080000000'\nCNVCNST2 DC    X'4080000000000000'\nCNVCNST4 DC    X'C880000000000000'\nCNVCNST3 DC    X'48800000'\n*\n         DC    0F'0'\n*\n*        END OF SYMLIB PART OF FIXED STORAGE AREA\n*\n./ ADD NAME=FSAREA   0201-12230-12230-1200-00134-00134-00000-LEVEL\n*\n*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n*\n*        STATUS - LEVEL 2.1\n*\n***********************************************************************\n*\n*        COMMON DATA AREA\n*\n*        FSAREA\n*\n***********************************************************************\n*\n*        DATA THAT IS IMMEDIATELY ACCESSIBLE TO ALL\n*        MODULES DURING THE EXECUTION\n*\n*        ADDRESSED BY MEANS OF R13 OR (FOR THE LIBRARY\n*        SUBROUTINES) BY R12\n*\nFSAREA   EQU   *\n*\n*        SAVE AREAS\n*\n         DS    18F                     STANDARD SAVE AREA\nASAVE    EQU   *-FSAREA                ALTERNATE SAVE AREA USED BY\n         DS    18F                     CERTAIN SUBROUTINES\n*\n*        MISCELLANEOUS WORK AREAS AND CONSTANTS\n*\nFCTVALST EQU   *-FSAREA                TEMPORARY STORAGE FOR\n         DS    D                       FUNCTION VALUES\nASTLOC   EQU   *-FSAREA                DISPL FOR ADDR OF STAND LOCTN\n         DC    A(FSAREA+FCTVALST)\nBRRST    EQU   *-FSAREA                TEMPORARY SAVE REG BRR\nHW       EQU   BRRST                   TEMPORARY HALFWORD STORAGE\n         DS    F\nPROLREG  EQU   *-FSAREA                STORAGE FOR PBT AND LAT WHEN\n         DS    2A                      A PROCEDURE IS FORMAL PARAM\n*\n*        HALFWORD CONTAINING PBN OF CALLED BLOCK IN SECOND BYTE\n*\n         DS    0H\n         DC    X'00'\nPROLPBN  EQU   *-FSAREA                STORAGE FOR CALLED PBN\n         DC    X'00'\nEIGHT    EQU   *-FSAREA                CONST FOR REDUCING RAS\n         DC    H'8'\n*\n         DS    0F\nADSTAB   EQU   *-FSAREA                ADDR OF DSTABLE\n         DS    A                       IN THE OBJECT PROGRAM\nANOTTAB  EQU   *-FSAREA                ADDR OF NOTE TABLE\n         DS    A                       (INSERTED BY THE OPEN ROUTINE)\n*\nIHIFSAST EQU   *\nPGOPSW   EQU   *-FSAREA                PROGRAM CHECK OLD PSW\n         DS    2F\nFSAPICA  EQU   *-FSAREA                OLD PICA ADDR\n         DC    F'0'\nSCRCS    EQU   *-FSAREA                SEMICOLON NUMBER\n         DS    H\nDTSW     EQU   *-FSAREA                OPTION SWITCHES\nOPTSW    EQU   DTSW\n         DC    X'00'                   DUMP-80, TRACE-40, SHORT-20\nFSAERCOD EQU   *-FSAREA                ERROR CODE FOR ERROR ROUTINE\n         DS    C\n*\n*        RETURN ADDRESS STACK POINTERS DO NOT CHANGE ORDER\n*\n         DS    0F\nIHIFSARS EQU   *\nRASSTART EQU   *-FSAREA                ADDR OF FIRST ENTRY IN RAS-8\n         DS    F\nRASPT    EQU   *-FSAREA                RAS POINTER FROM TOP\n         DS    F\nRASEND   EQU   *-FSAREA                ADDR OF LAST  ENTRY IN RAS+8\n         DS    F\nRASPB    EQU   *-FSAREA                RAS POINTER FROM BOTTOM\n         DS    F\n*\n*        LIST OF BRANCH INSTRUCTIONS TO COMMONLY USED SUBROUTINES\n*\nBRLIST   DS    0F\nCAP1     EQU   *-FSAREA                FIRST PART CAPS\n         NOP   0\nCAP2     EQU   *-FSAREA                SECOND PART CAPS\n         NOP   0\nPROLOGP  EQU   *-FSAREA                PROLOGUE FORMAL PARAMETER ENTRY\nPROLOGFP EQU   PROLOGP\n         NOP   0\nPROLOG   EQU   *-FSAREA                PROLOGUE PROGRAM USUAL ENTRY\n         NOP   0\nRETPROG  EQU   *-FSAREA                DISPLACEMENT RETURN PROGRAM\n         NOP   0\nEPILOGP  EQU   *-FSAREA                EPILOGUE PROGRAM,PROCEDURE ENTRY\n         NOP   0\nEPILOGB  EQU   *-FSAREA                EPILOGE PROGRAM,BETA-BLOCK ENTRY\n         NOP   0\nEPILPR3  EQU   *-FSAREA                EPILOGUE PROGRAM ENTRY 3\n         NOP   0\nCSWE1    EQU   *-FSAREA                FIRST PART CSWES\n         NOP   0\nCSWE2    EQU   *-FSAREA                SECOND PART CSWES\n         NOP   0\nLOADPP   EQU   *-FSAREA                LOAD PRECOMPILED PROC ROUTINE\n         NOP   0\nTRACE    EQU   *-FSAREA\n         MVC   0(0),0\n         NOP   0\n         NOP   0\nTERMNTE  EQU   *-FSAREA                NORMAL TERMINATION EXIT\n         NOP   0\nBCR      EQU   *-FSAREA\n         BCR   0,0                     VARIABLE CONDITIONAL BRANCH\nGETMSTO  EQU   *-FSAREA\n         NOP   0\n*\nVALUCALL EQU   *-FSAREA\n         NOP   0\nIORLST   EQU   *-FSAREA\n         NOP   0\n*\nFSAERR   EQU   X'1CC'                  DISPL  FOR ERROR LIST\n*\n*        DISPLACEMENTS FOR CERTAIN ERROR EXITS IN FSA\n*\nOUTOFB   EQU   FSAERR+4*16\nNUMBIND  EQU   FSAERR+4*19\nARRAYBD  EQU   FSAERR+4*15\nERROR40  EQU   FSAERR+4*40\nOERR22   EQU   FSAERR+4*22\nENDLESL  EQU   FSAERR+4*17\nOERR21   EQU   FSAERR+4*21\n*\n./ ADD NAME=IHIENTRY 0201-12230-12230-1200-00055-00055-00000-LEVEL\n         MACRO\n&NAME    IHIENTRY  &REG=R15,&ID\n.*\n.*       IHIENTRY\n.*\n.*       COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY\n.*\n.*       GENERATE A MODULE EYE CATCHER OF THE SAME FORMAT AS THE\n.*       SAVE MACRO BUT DO NOT SAVE REGISTERS AS THE ALGOL RUNTIME\n.*       OFTEN DOES NOT PROVIDE FOR THE SAVING OF REGS IN THE\n.*       STANDARD MANNER AND FOR STANDARD MODULE ENTRY\n.*       THE BRANCH REGISTER MAY BE SET TO ANOTHER REGISTER IF\n.*       R15 IS NOT THE ENTRY POINT REGISTER BY USE OF THE\n.*       REG PARAMETER\n.*\n         LCLA  &A,&B,&C\n         LCLC  &E,&F,&G,&H\n         AIF   ('&ID' EQ '').NULLID\n         AIF   ('&ID' EQ '*').SPECID\n         AIF   ('&ID'(1,1) NE '''').NOQUOTE\n&B       SETA  1\n&C       SETA  2\n.NOQUOTE ANOP\n&A       SETA  ((K'&ID+2)/2)*2+4-&C\n*\n&NAME    B     &A.(,&REG)          BRANCH AROUND ID\n&A       SETA  K'&ID-&C\n         DC    AL1(&A)             LENGTH OF IDENTIFIER\n&E       SETC  '&ID'(&B+1,&A)\n         DC    CL&A'&E'                          IDENTIFIER\n         AGO   .CONTA\n.NULLID  ANOP\n&NAME    DS    0H\n         AGO   .CONTA\n.SPECID  AIF   ('&NAME' EQ '').CSECTN\n&E       SETC  '&NAME'\n&A       SETA  1\n.CONTQ   AIF   ('&E'(1,&A) EQ '&E').LEAVE\n&A       SETA  &A+1\n         AGO   .CONTQ\n.LEAVE   ANOP\n&B       SETA  ((&A+2)/2)*2+4\n*\n&NAME    B     &B.(,&REG)          BRANCH AROUND ID\n         DC    AL1(&A)\n         DC    CL&A'&E'            IDENTIFIER\n         AGO   .CONTA\n.CSECTN  AIF   ('&SYSECT' EQ '').E4\n&E       SETC  '&SYSECT'\n&A       SETA  1\n         AGO   .CONTQ\n.E4      IHBERMAC 78,360                    CSECT NAME NULL\n.CONTA   ANOP\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AL21SAMP": {"ttr": 52235, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x16\\x08\\x02h\\x02h\\x00\\x00\\xd7\\xc4\\xc6@@@@@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T16:08:00", "lines": 616, "newlines": 616, "modlines": 0, "user": "PDF"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}, "AL21SASM": {"ttr": 52490, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x135V\\xe6V\\xe6\\x00\\x00\\xc3\\xd6\\xd4\\xd7\\xe2\\xd9\\xc3@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T13:35:00", "lines": 22246, "newlines": 22246, "modlines": 0, "user": "COMPSRC"}, "text": "./ ADD NAME=IEX00    0201-12230-12230-1200-00400-00400-00000-LEVEL\nX00      TITLE 'IEX00 - COMPILER DIRECTORY, ALGOL F'\n*\n*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER\n*\n*        FUNCTION/OPERATION -\n*        THIS MODULE HAS TWO FUNCTIONS -\n*        1. IT PROVIDES THE INITIAL ENTRY POINT TO AND FINAL\n*           EXIT POINT FROM THE ALGOL COMPILER\n*        2. IT CONTAINS ROUTINES AND DATA WHICH MAY BE NEEDED BY\n*           SOME OR ALL OF THE FOLLOWING COMPILER PHASES\n*\n*        ENTRY POINTS -\n*        IEX00000 - INITIAL ENTRY POINT. MAY BE ENTERED BY AN\n*                   JCL EXEC STATEMENT OR BY ANY ONE OF THE\n*                   MACROS LINK, CALL, XCTL OR ATTACH\n*        IEX00PIC - PROGRAM INTERRUPT ROUTINE\n*        IEX00ED1 - END OF DATA ROUTINE FOR SYSUT1\n*        EODAD2   - END OF DATA ROUTINE FOR SYSUT2\n*        EODAD3   - END OF DATA ROUTINE FOR SYSUT3\n*        IEX00EDI - END OF DATA ROUTINE FOR SYSIN\n*                   (THE FOUR END OF DATA ROUTINES ABOVE ARE\n*                   DUMMIES WHICH ONLY TRANSFER CONTROL TO THE\n*                   ACTUAL ROUTINES, THE ADDRESSES OF WHICH HAVE\n*                   BEEN STORED IN THE COMMON WORK AREA)\n*        IEX00SYN - SYNCHRONOUS ERROR ROUTINE FOR ALL DATA SETS\n*                   EXCEPT SYSPRINT\n*        SYNPR    - SYNCHRONOUS ERROR ROUTINE FOR SYSPRINT\n*        IEX00PRI - A COMMON SUBROUTINE FOR WRITING OUTPUT TO\n*                   SYSPRINT\n*\n*        INPUT - N/A\n*\n*        OUTPUT -\n*        THE SUBROUTINE PRINT EXECUTES ALL OUTPUT OPERATIONS ON\n*        SYSPRINT\n*        RECORD LENGTH IS 121 BYTES WITH ASA CONTROL CHARACTERS\n*\n*        EXTERNAL ROUTINES -\n*        IEX00001 - THE COMMON WORK AREA\n*        THIS IS NOT AN EXECUTABLE ROUTINE BUT RATHER A\n*        COLLECTION OF TABLES, DATA AND WORK AREAS WHICH ARE\n*        NEEDED BY SOME OR ALL OF THE COMPILER PHASES, THUS\n*        SUPPLEMENTING THE FUNCTION OF THIS MODULE. IT IS\n*        ASSEMBLED SEPARATELY AND LINKAGE EDITED WITH THIS\n*        MODULE. ITS CONTENTS AND FORMAT CAN BE FOUND IN THE\n*        DUMMY CONTROL SECTION WORKAREA\n*\n*        IEX10000 - THE COMPILER INITIALIZATION PHASE\n*        THE WHOLE CHAIN OF COMPILER PHASES STARTING WITH\n*        IEX10000 AND ENDING WITH IEX51002 CAN BE REGARDED AS A\n*        SUBROUTINE TO THIS MODULE. IT IS ENTERED BY A MACRO\n*        LINK EP=IEX10000. ON ENTRY, R0 CONTAINS THE ADDRESS\n*        OF THE COMMON WORK AREA. CONTROL IS FINALLY RETURNED TO\n*        THIS MODULE FROM IEX51002 BY A RETURN MACRO WITH THE\n*        COMPLETION CODE IN R15\n*\n*        EXITS - NORMAL -\n*        THE FINAL EXIT FROM THE COMPILER IS BY A RETURN MACRO\n*        TO THE INVOKING PROGRAM. R15 CONTAINS A RETURN\n*        CODE TO INDICATE WHETHER THE COMPILATION WAS SUCCESSFUL\n*        OR NOT\n*\n*        EXIT FROM THE SUBROUTINE PRINT IS BY A RETURN MACRO\n*        R1 CONTAINS THE ADDR OF A BUFFER AREA INTO\n*        WHICH THE NEXT OUTPUT LINE CAN BE MOVED\n*\n*        EXITS - ERRORS -\n*        EXIT FROM THE COMMON ERROR ROUTINES PIROUT, SYNAD AND\n*        SYNPR IS NORMALLY TO AN ERROR ROUTINE WHICH IS PRIVATE\n*        TO EACH COMPILER PHASE. THE ADDR OF THIS ROUTINE HAS\n*        BEEN STORED IN ERET IN THE COMMON WORK AREA. HOWEVER, IF\n*        THE PIROUT ROUTINE IS ENTERED FOR THE SECOND TIME, EXIT\n*        IS MADE TO THE ROUTINE GOTOEND IN THIS MODULE WHICH IN\n*        ITS TURN XCTL'S TO THE TERMINATING PHASE IEX51002\n*\n*        EXIT FROM THE ROUTINES SYNAD AND SYNPR IS BY LOADING\n*        ERET INTO R15 AND BRANCHING\n*\n*        EXIT FROM THE ROUTINE PIROUT IS BY MOVING THE RETURN\n*        ADDRESS INTO THE OLD PSW AND EXECUTING A RETURN MACRO.\n*\n*        TABLES/WORK AREAS -\n*        SAVE     - THE SAVE AREA IN STANDARD FORMAT\n*        IEX00PIC - THE PROGRAM INTERRUPT CONTROL AREA\n*        SYSPRINT - DCB FOR SYSPRINT\n*        SYSLIN   - DCB FOR SYSLIN\n*        SYSPUNCH - DCB FOR SYSPUNCH\n*        SYSUT2   - DCB FOR SYSUT2\n*        SYSUT3   - DCB FOR SYSUT3\n*        WORKAREA - THE COMMON WORKAREA IN THE EXTERNAL CONTROL\n*                   SECTION IEX0001\n*\n*        ATTRIBUTES - NOT SERIALLY REUSABLE\n*\n*        NOTES -\n*        THIS MODULE IS TO BE LINKAGE EDITED WITH THE COMMON\n*        WORK AREA (MODULE IEX00001). THE RESULTING LOAD MODULE\n*        FORMS THE RESIDENT PART (IEX00) OF THE ALGOL COMPILER\n*\n*        THE OPERATION OF THIS MODULE DEPENDS UPON AN INTERNAL\n*        REPRESENTATION OF THE EXTERNAL CHARACTER SET WHICH IS\n*        EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME\n*\nIEX00000 CSECT\n*\n*        BIT PATTERNS\n*\nONSW     EQU   X'F0'                    ON SWITCH IN BRANCH INSTR\nOFFSW    EQU   X'0F'                    OFF SWITCH IN BRANCH INSTR\n*\n*        ENTRY POINTS\n*\n         ENTRY IEX00LIN,IEX00PCH,IEX00PRT,IEX00UT2,IEX00UT3\n         ENTRY IEX00SYN,IEX00ED1,IEX00EDI,IEX00PIC,IEX00PRI\n*\n         USING IEX00000,R15\n*\n         SAVE  (14,12),,'IEX00000 LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LA    R2,SAVE\n         ST    R13,SAVE+4\n         ST    R2,8(,R13)\n         LR    R13,R2\n         L     R0,=V(IEX00001)         R0 -> COMMON WORKAREA\n*\n         LINK  EP=IEX10                LINK TO PHASE 10\n*\n*        TWO PARAMETERS ARE TRANSMITTED TO PHASE 10, R0\n*        CONTAINS THE ADDR OF THE COMMON WORKAREA, R1 CONTAINS\n*        THE ADDR OF THE PARAMETER LIST OF THE INVOKER\n*\n*        FINAL EXIT OF THE COMPILER\n*\n*        PHASE 51 GENERATED THE RETURN CODE IN R15\n*        THE RETURN CODE IS PASSED BACK TO THE INVOKER\n*\n         BALR  R14,0\n         USING *,R14\n         L     R13,SAVE+4\n*\n         RETURN (14,12),RC=(15)\n*\n*        SAVEAREA FOR THIS LEVEL OF CONTROL\n*\nSAVE     DC    18F'0'\n*\n         LTORG\n*\n*        THE FOLLOWING SECTION CONTAINS -\n*        THE PROGRAM INTERRUPT CONTROL AREA\n*        THE PROGRAM CHECK\n*        AND I/O ERROR ROUTINES\n*        THE PRINT ROUTINE AND THE DCBS FOR SYSLIN, SYSPUNCH,\n*        SYSPRINT, SYSUT2 AND SYSUT3\n*\n         USING WORKAREA,R13\n*\n*        PROGRAM INTERRUPT CONTROL AREA\n*\nIEX00PIC SPIE  PIROUT,((1,15)),MF=L\n*\n*        PROGRAM INTERRUPT ROUTINE\n*\n         USING *,R15\nPIROUT   TM    COMPFLGS+1,TERM         PROG INTERRUPT IN\n*                                      TERMINATING PHASE ?\n         BO    TERMERR                 YES, BRANCH\n         TM    COMPFLGS+1,ERR\n         BO    ERRERR                  PROG INTERRUPT IN ERROR RTN\n         STM   R4,R7,PISAVE            SAVE REGISTERS\n         L     R6,NEXTERR              ADDR OF NEXT BYTE IN ERROR POOL\n         MVC   0(2,R6),=AL1(20,209)    PATTERN FOR MSG 209\n         MVC   2(2,R6),SEMCNT          SEMICOLON COUNTER\n         TM    COMPFLGS+2,NOSC         SEMICOLON COUNTER VALID ?\n         BZ    *+8                     YES, BRANCH\n         OI    0(R6),X'80'             INDICATE SCNTR NOT VALID\n         SR    R7,R7                   INITIALIZE INDEX\n         L     R5,4(R1)                FIRST HALF OF PSW\nLOOP     SR    R4,R4\n         SLDL  R4,4                    GET HALF A BYTE OF OLD PSW\n         STC   R4,4(R7,R6)             STORE FOR CONVERSION\n         LA    R7,1(R7)                INCREASE INDEX\n         CH    R7,=H'8'                PERFORM LOOP\n         BL    LOOP                    EIGHT TIMES\n         L     R5,8(,R1)               SECOND HALF OF PSW\nLOOP2    SR    R4,R4\n         SLDL  R4,4                    GET HALF A BYTE OF OLD PSW\n         STC   R4,4(R7,R6)             STORE FOR CONVERSION\n         LA    R7,1(R7)                INCREASE INDEX\n         CH    R7,=H'16'               PERFORM LOOP\n         BL    LOOP2                   EIGHT TIMES\n         TR    4(16,R6),=C'0123456789ABCDEF' TRANSLATE TO PRINTABLE HEX\n         LA    R6,20(R6)               UPDATE POINTER\n         ST    R6,NEXTERR              TO ERROR POOL\nFIRSTERR OI    COMPFLGS+1,ERR          SET ERROR ROUT SWITCH ON\n         LM    R4,R7,PISAVE            RESTORE REGISTERS\nTERMERR  MVC   9(3,R1),ERET+1          ADDR OF ERR RTN TO OLD PSW\n         OI    COMPFLGS,TERR           INDICATE TERMINATING ERROR\n*\n         RETURN\n*\nPISAVE   DC    4F'0'                   REGISTER SAVE AREA\n*\nERRERR   MVC   9(3,R1),=AL3(GOTOEND)   SET ADDR IN OLD PSW\n*\n         RETURN\n*\n         DROP  R15\nGOTOEND  BALR  R15,0\n         USING *,R15\n*\n         XCTL  EP=IEX51002             GOTO TERMINATING PHASE\n*\n         DROP  R15\n*\n*        ENTRY OF THE END OF DATA EXIT ROUTINES\n*\nIEX00ED1 EQU   *\nEODAD1   L     R15,EODUT1              SYSUT1\n         BR    R15\n*\nEODAD2   L     R15,EODUT2              SYSUT2\n         BR    R15\n*\nEODAD3   L     R15,EODUT3              SYSUT3\n         BR    R15\n*\nIEX00EDI EQU   *\nEODADIN  L     R15,EODIN               SYSIN\n         BR    R15\n*\n*\n*        SYNAD ROUTINE (ENTRY POINT FOR SYSPRINT)\n*\nSYNPR    OI    COMPFLGS+2,PRT          SET SYSPRINT DOWN SWITCH ON\n         BALR  R15,0\n*\n*        SYNAD ROUTINE\n*        FOR ALL DATA SETS EXCEPT SYSPRINT\n*\n         USING *,R15\nIEX00SYN EQU   *\nSYNAD    LA    R2,0(,R1)               GET DCB ADDR\n*\n         CLOSE ((R2))\n*\n         DROP  R15\n         BALR  R15,0\n         USING *,R15\n         L     R3,NEXTERR              STORE ERROR PATTERN\n         MVC   0(2,R3),PTTRN210        IN ERROR POOL\n         MVC   2(2,R3),SEMCNT\n         USING IHADCB,R2\n         MVC   4(8,R3),DCBDDNAM\n         DROP  R2\n         LA    R3,12(R3)               UPDATE ERROR POINTER\n         ST    R3,NEXTERR\n         OI    COMPFLGS,TERR           INDICATE TERMINATING ERROR\n         TM    COMPFLGS+2,PRT          SYSPRINT NOT AVAIL ?\n         BZ    SYNADX                  NO, BRANCH, MUST BE OTHER DCB\n         LM    R4,R14,SAVEP            RESTORE REGS FROM PRINT ROUTINE\nSYNADX   L     R15,ERET                EXIT TO ERROR ROUTINE\n         BR    R15                     IN CURRENT PHASE\n*\nPTTRN210 DC    AL1(12),AL1(210)\n*\n         DROP  R15\n*\n*        PRINTS ONE LINE ON SYSPRINT\n*\n*        IT ALSO TAKES CARE OF LINE COUNTING, PAGE COUNTING AND\n*        PRINTING OF HEADING LINES AT THE TOP AF EACH NEW PAGE\n*\n*        CALLING SEQUENCE -\n*        L     R15,PRTRTADD          ENTRY ADDR IN CWA\n*        BALR  R14,R15\n*\n*        ON RETURN, R1 -> PRINT BUFFER\n*\n*        GENERAL REGISTERS\n*\n*        R6       LINE COUNTER\n*        R12      SYSPRINT DCB ADDR\n*        R14      RETURN ADDR\n*\n         USING IEX00PRI,R15\nIEX00PRI STM   R14,R12,SAVEP+12\n         DROP  R15\n         LR    R5,R15\n         USING IEX00PRI,R5\n         L     R12,APRTDCB             R12 -> SYSPRINT DCB\n         LH    R6,LINCNT               TEST LINE COUNTER\n         CH    R6,MAXLINES\n         BNH   PRINTL                  NOT HIGH, NO NEED TO PRINT HEAD\n*\n*        PRINT HEADINGS\n*\n         AP    PAGECNT,=P'1'           ADD ONE TO PAGE COUNT\n         MVC   PAGENUMB,PAGEPATT       MOVE IN PAGE EDIT PATTERN\n         ED    PAGENUMB,PAGECNT+2      FORMAT PAGE NUMBER\n*\nNOPAGENO PUT   (R12)                   REQUEST QSAM BUFFER\n*\n         MVC   0(L'PAGEHD1,R1),PAGEHD1 MOVE HEADING LINE 1 INTO BUFFER\n*\n         PUT   (R12)                   REQUEST QSAM BUFFER\n*\n         MVC   0(L'PAGEHD2,R1),PAGEHD2 MOVE HEADING LINE 2 INTO BUFFER\n*\n         PUT   (R12)                   REQUEST QSAM BUFFER\n*\n         MVC   0(L'PAGEHD3,R1),PAGEHD3 MOVE HEADING LINE 2 INTO BUFFER\n         LA    R6,3                    PRINTED 3 LINES\n*\nPRINTL   PUT   (R12)                   REQUEST QSAM BUFFER\n*\n         MVI   0(R1),C' '\n         MVC   1(120,R1),0(R1)         BLANK BUFFER\n         LA    R1,11(,R1)              MAKE A LEFT HAND MARGIN\n         LA    R6,1(,R6)               INCR LINE COUNTER\n         STH   R6,LINCNT               SAVE UPDATED LINECNT\n         LM    R14,R0,SAVEP+12         RESTORE ALL REGS EXCEPT R1\n         LM    R2,R12,SAVEP+28\n         SR    R15,R15\n         BR    R14                     RETURN TO CALLER\n*\nSAVEP    DC    18F'0'                  REG SAVE AREA\n*\nPAGEPATT DC    XL4'40202020'           PAGE NUMBER ED PATTERN\n*\n         LTORG\n*\n*        PRINT NOGEN\n*\n*        DATA CONTROL BLOCKS\n*\nSYSPRINT DCB   DDNAME=SYSPRINT,                                        C\n               DSORG=PS,                                               C\n               MACRF=(PL),                                             C\n               RECFM=FBA,                                              C\n               LRECL=121,                                              C\n               SYNAD=SYNPR\n*\nSYSLIN   DCB   DDNAME=SYSLIN,                                          C\n               DSORG=PS,                                               C\n               MACRF=(PL),                                             C\n               RECFM=FB,                                               C\n               LRECL=80,                                               C\n               SYNAD=SYNAD\n*\nSYSPUNCH DCB   DDNAME=SYSPUNCH,                                        C\n               DSORG=PS,                                               C\n               MACRF=(PL),                                             C\n               RECFM=FB,                                               C\n               LRECL=80,                                               C\n               SYNAD=SYNAD\n*\nSYSUT2   DCB   DDNAME=SYSUT2,                                          C\n               DSORG=PS,                                               C\n               MACRF=(R,W),                                            C\n               RECFM=F,                                                C\n               SYNAD=SYNAD,                                            C\n               EODAD=EODAD2\n*\nSYSUT3   DCB   DDNAME=SYSUT3,                                          C\n               DSORG=PS,                                               C\n               MACRF=(RP,WP),                                          C\n               BLKSIZE=2000,                                           C\n               RECFM=U,                                                C\n               SYNAD=SYNAD,                                            C\n               EODAD=EODAD3\n*\n*\n*        PRINT GEN\n*\nIEX00PRT EQU   SYSPRINT\nIEX00LIN EQU   SYSLIN\nIEX00PCH EQU   SYSPUNCH\nIEX00UT2 EQU   SYSUT2\nIEX00UT3 EQU   SYSUT3\n*\nWORKAREA DSECT\n*\n         COPY  WORKAREA\n*\n*        DUMMY CONTROL SECTION TO PROVIDE ADDRESSABILITY OF DCB\n*\n         PRINT NOGEN\n*\n         DCBD  DSORG=(PS),DEVD=(DA)\n*\n         PRINT GEN\n*\n*        REGISTER AND BIT EQUATES\n*\n         IEZREGS\n*\n         IEZBITS\n*\n         END\n./ ADD NAME=IEX10    0201-12230-12230-1200-00751-00751-00000-LEVEL\nX10      TITLE 'IEX10 - COMPILER INITIALIZATION PHASE, ALGOL F'\n*\n*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER\n*\n*        FUNCTION/OPERATION -\n*        THIS MODULE PERFORMS THE FOLLOWING INITIALIZATION\n*        ACTIONS -\n*        1. SAVE THE REGISTERS AND ESTABLISH THE LOWER\n*           PART OF THE COMMON WORKAREA AS THE NEW SAVEAREA\n*           TO BE USED THROUGHOUT THE COMPILATION\n*        2. EXECUTE A SPIE MACRO\n*        3. SCAN THE OPTION PARAMETER FIELD PROVIDED BY THE USER\n*           AND SET THE SWITCHES IN COMPFLGS ACCORDINGLY\n*        4. IF PROVIDED BY THE USER, INSERT NEW DD NAMES INTO\n*           THE DCB'S AND STORE THE INITIAL PAGECOUNT IN THE COMMON\n*           COMMON WORKAREA\n*        5. OBTAIN STORAGE FOR THE ERROR POOL AND MOVE ANY ERROR\n*           PATTERNS ALREADY STORED FROM THE PRELIMINARY ERROR POOL\n*           INTO THE NEW POOL\n*        6. COMPLETE AND OPEN THE DCB'S FOR ALL DATASETS TO BE USED\n*        7. OBTAIN THE TIME AND DATE WITH A TIME MACRO\n*           STORE IT IN EDITED FORM IN A HEADLINE, WHICH IS\n*           PRINTED AT THE TOP OF THE FIRST PAGE\n*        8. TRANSFER CONTROL TO THE SCANI/II PHASE (IEX11)\n*\n*        IF ERRORS ARE DETECTED IN THE STEPS DESCRIBED ABOVE\n*        (SUCH AS INVALID OPTION PARAMETERS OR INCORRECT DD\n*        CARDS), SOME OF THE STEPS MAY BE BYPASSED, AND AN ERROR\n*        EXIT MAY BE TAKEN\n*\n*        ENTRY POINTS -\n*        IEX10000 - THE ONLY ENTRY POINT TO THIS MODULE\n*                   CONTROL IS TRANSFERRED HERE FROM IEX00 BY THE\n*                   MACRO LINK EP=IEX10. R0 THEN CONTAINS THE\n*                   ADDR OF THE COMMON WORKAREA AND R1 THE ADDR\n*                   OF THE PARAMETER LIST PROVIDED BY THE USER\n*\n*        INPUT - N/A\n*\n*        OUTPUT -\n*        THE TEXT STORED AT FIRSTLIN IS OUTPUT TO SYSPRINT AS A\n*        91-CHARACTER RECORD WITH MACHINE CONTROL CHARACTER\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        IF NO TERMINATING ERRORS ARE FOUND, CONTROL IS\n*        TRANSFERRED TO THE SCANI/II PHASE BY MEANS OF THE MACRO\n*        'XCTL EP=IEX11'\n*\n*        EXITS - ERRORS -\n*        IF A PROGRAM CHECK OR UNRECOVERABLE I/O ERROR OCCURS\n*        DURING ONE OF THE INITIALIZATION STEPS, CONTROL IS\n*        TRANSFERRED (VIA AN ERROR ROUTINE IN IEX00) TO THE\n*        ROUTINE GOTOTERM IN THIS MODULE. FROM THERE AN EXIT IS\n*        MADE TO THE TERMINATING PHASE BY MEANS OF THE MACRO\n*        XCTL EP=IEX51002\n*\n*        IF ANY OTHER TERMINATING ERROR IS DETECTED, CONTROL IS\n*        TRANSFERRED TO THE ROUTINE GOTOEDIT IN THIS MODULE. FROM\n*        THERE AN EXIT IS MADE TO THE ERROR EDITING MODULE BY\n*        MEANS OF THE MACRO XCTL EP=IEX21000\n*\n*        TABLES/WORK AREAS -\n*        STARTING AT PTRN200 - ERROR PATTERNS FOR ALL\n*                   ERRORS WHICH MAY BE DETECTED IN THIS MODULE\n*        FIRSTLIN - THE FIRST OUTPUT LINE TO BE PRINTED\n*                   CONTAINS PROGRAM IDENTIFICATION AND\n*                   LEVEL AND THE DATE OF THE RUN\n*        PARMLIST - A TABLE USED FOR DECODING THE OPTION\n*                   PARAMETERS\n*\n*        ATTRIBUTES - NOT REUSABLE\n*\n*        NOTES -\n*        THIS MODULE IS ONLY INTENDED TO BE USED IN CONNECTION\n*        WITH THE OTHER MODULES COMPRISING THE ALGOL COMPILER\n*\n*        THE OPERATION OF THIS MODULE DEPENDS UPON AN INTERNAL\n*        REPRESENTATION OF THE EXTERNAL CHARACTER SET WHICH IS\n*        EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME\n*\nIEX10000 CSECT\n*\n*        REGISTER ASSIGNMENTS\n*\n*        R4         RUNNING ADDR OF PARAMETER FIELD MINUS 2\n*        R5         ADDR OF BYTE FOLLOWING LAST BYTE OF FIELD MINUS 2\n*        R6         RUNNING ADDR OF PARAMETER LIST\n*        R7         ADDR OF LAST ENTRY OF PARAMETER LIST\n*        R8         LENGTH-1 OF PARAMETER\n*        R9         CURRENT FIELD IN ERROR POOL\n*        R10        NEXT FIELD IN ERROR POOL\n*        R11        BYTE COUNT OF PARAMETER IN ERROR\n*\n         SAVE  (14,12),,'IEX10000 LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         LR    R2,R15                  SET BASE\n         USING IEX10000,R2\n         ST    R0,8(R13)               ADDR OF LOWER LEVEL SAVAREA\n         LR    R12,R13\n         LR    R13,R0\n         ST    R12,4(R13)              ADDR OF HIGHER LEVEL SAVEAREA\n         USING WORKAREA,R13\n*\n*        EXECUTE THE SPIE MACRO\n*\n         L     R3,PICAADD              ADDR OF PICA OF COMPILER\n*\n         SPIE  MF=(E,(3))\n*\n         ST    R1,PICAADD              STORE ADDR OF OLD PICA IN\n         MVC   ERET,=A(GOTOTERM)       ERROR ROUT FOR NEXT PART\n*                                      OF PHASE\n*\n*        INTERROGATE THE CONTROL PARAMETERS AND SET SWITCHES IN\n*        THE WORKAREA\n*\n         L     R14,4(,R13)\n         L     R14,24(,R14)            GET CALLERS R1\n         LTR   R14,R14                 ZERO ?\n         BZ    BYPASSOP                YES, NO OPTIONS ARE SPECIFIED\n         L     R4,0(,14)               ADDR OF PARMETER FIELD\n         LA    R4,0(,R4)               RESET HIGH ORDER BYTE\n         LH    R5,0(,R4)               FIELD LENGTH\n         LTR   R5,R5                   NONZERO FIELD LENGTH ?\n         BZ    DDNAMES                 NO CONTROL PARAMETERS SPECIFIED\n         AR    R5,R4                   END OF FIELD\n         LA    R7,LSTENTRY             LAST ENTRY OF LIST\n         SR    R8,R8                   ZERO REG\nFNDCOMMA CLI   2(R4),C','              COMMA ?\n         BNE   FNDPAR                  NO, BRANCH\nSTEP1    LA    R4,1(,R4)               STEP FIELD\nCOMP1    CR    R4,R5\n         BL    FNDCOMMA                IF NOT END OF FIELD YET\n         TM    COMPFLGS+1,NLOAD+NDECK  NOLOAD AND NODECK ?\n         BNO   DDNAMES                 NO, BRANCH\n         OI    COMPFLGS,COMPMODE       YES, FORCE SYNTAX MODE ONLY\n         B     DDNAMES                 END OF FIELD\n*\n         USING LENGTH,R6\nCOMPINST CLC   2(0,R4),PARAM\nFNDPAR   CLC   2(5,R4),=C'SIZE='\n         BE    FNDSIZE\n         LA    R6,PARMLIST\nNXTPAR   IC    R8,LENGTH\n         EX    R8,COMPINST\n         BNE   NOTFOUND\n         LA    R10,1(R4,R8)            ADDR OF BYTE FOLLOWING\n*                                      PARAMETER-2\n         CLI   2(R10),C','             COMMA ?\n         BE    SETBIT                  YES, BRANCH\n         CR    R10,R5                  END OF PARAMETER FIELD ?\n         BL    ERROR200                IF NO\nSETBIT   LR    R4,R10\n         EX    0,INSTR\n         DROP  R6\n         B     COMP1\n*\nNOTFOUND CR    R6,R7\n         LA    R6,LENGTH-PARMLIST(R6)  STEP LIST ADDR\n         BL    NXTPAR                  IF NOT END OF LIST YET\n*\nERROR200 L     R9,NEXTERR              ADDR OF NEXT FREE BYTE\n*                                      IN ERRORPOOL\n         CLI   0(R9),C'X'              TEST IF THE PRELIMINARY ERROR\n         BE    FULLPOOL                POOL IS FILLED\n         LA    R10,16(R9)\n         ST    R10,NEXTERR\n         MVC   0(16,R9),PTRN200        PATTERN WITH BLANKS\n*                                      TO ERROR POOL\n         LA    R11,12(0)\nMOVE     MVC   4(1,R9),2(R4)\n         LA    R9,1(R9)\nMOVENOT  LA    R4,1(R4)\n         CLI   2(R4),C','\n         BE    STEP1                   IF END OF PARAMETER\n         CLR   R4,R5\n         BNL   DDNAMES                 IF END OF PARAMETER LIST\n         SH    R11,=H'1'\n         BP    MOVE\n         B     MOVENOT\n*\nFNDSIZE  LA    R10,5(R4)               ADDR OF FIRST DIGIT -2\n         SR    R11,R11                 SET COUNT OF DIGITS TO ZERO\nTSTDIGIT CLI   2(R10),C'0'             TEST IF\n         BL    ERROR200                THE CHARACTER\n         CLI   2(R10),C'9'             IS A DIGIT\n         BH    ERROR200\n         LA    R10,1(R10)\n         CR    R10,R5                  END OF PARAMTER FIELD ?\n         BE    PCKSIZE\n         CLI   2(R10),C','             DIGIT IS FOLLOWED ?\n*                                      BY A COMMA\n         BE    PCKSIZE\n         LA    R11,1(R11)              ADD 1 TO DIGIT COUNT\n         CH    R11,=H'7'               TEST IF TOO MANY DIGITS\n         BE    ERROR200\n         B     TSTDIGIT\n*\nPCKINSTR PACK  FIELD1,7(0,R4)\nPCKSIZE  EX    R11,PCKINSTR            L2 IS IN TEGH\n         CVB   R6,FIELD1\n         LR    R4,R10\n         C     R6,=F'45056'            SPECIFIED STORAGE SIZE\n         BL    ERROR208                IS TOO SMALL ?\n         ST    R6,SIZE\n         B     COMP1\n*\nERROR208 L     R9,NEXTERR\n         MVC   0(4,R9),PTRN208         PATTERN FOR MSG 208\n*                                      TO ERROR POOL\n         LA    R9,4(R9)                UPDATE POINTER TO NEXT\n         CLI   0(R9),C'X'              TEST IF THE PRELIMINARY ERROR\n         BE    FULLPOOL                POOL IS FILLED\n         ST    R9,NEXTERR              FREE ENTRY\n         B     COMP1\n*\nFULLPOOL MVC   0(4,R9),PTRN206         PATTERN FOR MESSAGE 206\n         LA    R9,4(R9)                UPDATE POINTER TO\n         ST    R9,NEXTERR              NEXT FREE ENTRY\n         B     DDNAMES                 NO PARAMETER TESTING ANY MORE\n*\n*        FIND THE DD NAMES\n*\nDDNAMES  TM    0(14),X'80'\n         BO    BYPASSOP                IF NO DDNAMES AND HEADING INFO\n         L     R4,4(14)\n         LH    R5,0(R4)\n         LTR   R5,R5\n         BZ    BYPASSOP                IF NO DDNAMES SPECIFIED\n         CL    R5,=F'80'               MORE THAN TEN\n         BNH   FNDDCB-4                DD NAMES\n         L     R5,=F'80'               NOT ALLOWED\n         L     R9,NEXTERR\n         MVC   0(4,R9),PTRN207         PATTERN TO ERROR POOL\n         LA    R9,4(R9)                UPDATE POINTER\n         ST    R9,NEXTERR              TO ERROR POOL\n         LA    R6,DCBTABLE             R6 -> TABLE OF DCB ADDRS\nFNDDCB   L     R7,0(R6)\n         LTR   R7,R7                   THIS DATASET EXIST ?\n         BZ    NXTDDNAM                NO, BRANCH\n         CLC   2(8,R4),=XL8'00'        NULL DDNAME ?\n         BE    NXTDDNAM                YES, BRANCH\n         USING IHADCB,R7\n         MVC   DCBDDNAM,2(R4)          MOVE IN OVERRIDE DDNAME\n         DROP  R7\nNXTDDNAM LA    R4,8(R4)                INCR DDNAME PTR\n         LA    R6,4(R6)\n         SH    R5,=H'8'                DECR COUNT\n         BP    FNDDCB\n*\n*        ACQUIRE THE ERROR POOL AND THE SOURCE PROG BUFFER 1\n*        STORE CONTENT OF PRELIMINARY ERROR POOL IN NEW ERROR\n*        POOL\n*\nBYPASSOP L     R0,POOLS                SIZE OF ERROR POOL\n         LR    R4,R0\n         A     R0,SRCE1S               SIZE OF SOURCE PROG BUFFER 1\n         LR    R6,R0                   SIZE OF TOTAL AREA\n*\n         GETMAIN R,LV=(0)\n*\n         XI    COMPFLGS+1,NOBUF        COMMON BUFFER AREA PRESENT\n         L     R5,NEXTERR              ADDR OF NEXT FREE BYTE\n*                                      IN PREL POOL\n         LA    R7,PRELPOOL             ADDR OF BEGIN OF PREL POOL\n         SR    R5,R7                   NUMBER OF BYTES IN ERROR POOL\n         EX    R5,MVCPOOL\n         B     JUMPEXEA                BRANCH AROUND MVC INSTR\n*\nMVCPOOL  MVC   0(0,R1),PRELPOOL        EXE INSTRUCTION\n*\nJUMPEXEA ST    R1,ERRPOOL              ADDR OF FIRST BYTE OF POOL\n         AR    R5,R1                   ADDR OF NEXT FREE BYTE\n         ST    R5,NEXTERR\n         AR    R4,R1                   ADDR OF END OF POOL +1\n         ST    R4,SRCE1ADD             ADDR OF SOURCE PROG BUFFER 1\n         AR    R6,R1                   END ADDR OF SOURCE PROG BUFFER 1\n         ST    R6,SRCE1END\n         SH    R4,=H'24'               ADDR OF END OF POOL-23\n         ST    R4,ENDPOOL\n*\n*        COMPLETE THE DCBS\n*\n         LM    R3,R12,DCBTABLE         ADDRS OF THE DCBS\n*                                      R4, R5, R6 NOT USED\n         USING IHADCB,R3               SYSLIN DCB\n         MVC   DCBEXLST+1(3),=AL3(LINEX)  ADDR OF EXLIST\n         DROP  R3\n         USING IHADCB,R7               SYSIN DCB\n         MVC   DCBEXLST+1(3),=AL3(INEX)  ADDR OF EXLIST\n         DROP  R7\n         USING IHADCB,R8\n         MVC   DCBEXLSA,=AL3(PRINTEX)  EXLIST FOR PRINT DCB\n         DROP  R8\n         USING IHADCB,R9               SYSPUNCH DCB\n         MVC   DCBEXLST+1(3),=AL3(PCHEX)  ADDR OF EXLIST\n         DROP  R9\n         USING IHADCB,R10              SYSUT1 DCB\n         LH    R4,SRCE1S+2             SOURCE PROG BUFFER 1 SIZE\n         STH   R4,DCBBLKSI             BLOCK SIZE\n         DROP  R10\n         USING IHADCB,R11              SYSUT2 DCB\n         STH   R4,DCBBLKSI             BLOCK SIZE\n         DROP  R11\n         MVC   ERET,=A(OPEXERR)        ERROR ROUTINE FOR OPEN EXIT\n*                                      ROUTINES\n*\n*        OPEN THE SYSLIN, SYSPRINT, SYSPUNCH, SYSUT2 AND SYSUT3 DCBS\n*\n         OPEN  ((3),OUTPUT,(8),OUTPUT,(9),OUTPUT,(11),OUTIN,(12),OUTIN)\n*\n         OPEN  ((10),OUTIN,(R7),INPUT)  OPEN SYSUT1 AND SYSIN DCBS\n*\n         MVC   ERET,=A(GOTOTERM)\n*\n*        TEST IF THE SYSPRINT DCB HAS BEEN OPENED\n*\n         USING IHADCB,R8\nTSTDCB   TM    DCBOFLGS,DCBOFOPN       OPEN SUCCESSFULL ?\n         DROP  R8\n         BO    EDITDATE                YES, BRANCH\n         OI    COMPFLGS+2,PRTNO        SYSPRINT DCB FAILED TO OPEN\n         LR    R7,R8                   DCB ADDR\n         L     R4,NEXTERR\n         B     ERROR201\n*\n*        GET DATE AND TRANSLATE IT TO DD MMM YYYY HH:MM:SS\n*\nEDITDATE TIME  DEC                     GET SYSTEM DATE\n*\n         STM   R0,R1,TEMP2             STORE SYSTEM TIME AND DATE\n*                                      INTO TEMP2 AND TEMP3\n         ED    HEADTIME,TEMP2          FORMAT TIME\n         UNPK  TEMP(3),TEMP3+1(2)      UNPACK YY\n         MVC   HEADYEAR+2(2),TEMP      MOVE YEAR ACROSS\n         ZAP   TEMP1,TEMP3+2(2)        JULIN DAY NO INTO DOUBLE WORD\n         CVB   R14,TEMP1               GET JULIAN DAY IN BINARY\n         LA    R15,MNTHTBL             R15 -> MNTHTBL\n         SH    R15,=H'8'               ADJUST ADDR FOR FIRST ITERATION\n         TM    TEMP3+1,X'01'           IF ODD YEAR THEN\n         BO    NOTLEAP                 NOT LEAP YEAR\n         TM    TEMP3+1,X'12'           TEST FOR LEAP (OK TILL 2099)\n         BNM   NEXTMNTH                IF MIXED NOT LEAP YEAR\nNOTLEAP  CH    R14,H60                 DDD AFTER 28TH FEBRUARY?\n         BL    NEXTMNTH                NO, LEAP YEAR IRRELEVANT\n         LA    R14,1(,R14)             YES, FUDGE DDD ACCORDINGLY\nNEXTMNTH LA    R15,8(,R15)             INCREMENT THRU MONTH TABLE\n         SH    R14,0(,R15)             DECREASE NUMBER OF DAYS\n         BP    NEXTMNTH                NOT YET, TRY NEXT MONTH\n*                                      FOUND THE CORRECT MONTH\n         AH    R14,0(,R15)             ADD BACK THE DAYS IN MONTH\n         CVD   R14,TEMP1               GET DAY OF MONTH\n         OI    TEMP1+7,X'0F'           MAKE UNPK RESULT PRINTABLE\n         UNPK  HEADDAY,TEMP1+6(2)      FORMAT DAY OF MONTH\n         MVC   HEADMON,2(R15)          MOVE IN MONTH NAME\n*\n*        SETUP HEADING LINE\n*\n         MVC   PAGEHD1,HEADING         FIRST LINE ON PAGE\n*\n         MVC   ERET,=A(GOTOEDIT)       ERROR ROUTINE FOR REST OF PHASE\n*\n*        TEST IF THE OTHER DCBS HAVE BEEN OPENED\n*\n         LM    R3,R12,DCBTABLE         R3 -> SYSLIN DCB\n         L     R4,NEXTERR\n         USING IHADCB,R3\n         TM    COMPFLGS+1,NLOAD        NOLOAD SPECIFIED ?\n         BO    TSTPUNCH                YES, BRANCH\n         TM    DCBOFLGS,DCBOFOPN       DCB OPENED SUCCESSFULLY ?\n         BO    TSTPUNCH                YES, BRANCH\n         OI    COMPFLGS+1,NLOAD        NO, SET NOLOAD OPTION\n         MVC   0(4,R4),PTRN202         PATTERN FOR MSG 202\n         LA    R4,4(R4)                POINTER TO NEXT FREE ENTRY\n         DROP  R3\n         USING IHADCB,R9               R9 -> SYSPUNCH\nTSTPUNCH TM    COMPFLGS+1,NDECK        NODECK SPECIFIED ?\n         BO    TSTIN                   YES, BRANCH\n         TM    DCBOFLGS,DCBOFOPN       SYSPUNCH DCB OPEN SUCESSFULLY ?\n         BO    TSTIN                   YES, BRANCH\n         OI    COMPFLGS+1,NDECK        NO, SET NODECK OPTION\n         MVC   0(4,R4),PTRN203         PATTERN FOR MSG 203\n         LA    R4,4(R4)                POINTER TO NEXT FREE ENTRY\n         DROP  R9\n*\nTSTIN    BAL   R14,TSTDCBRT            DCB ADDR FOR SYSIN IS IN REG 7\n         LR    R7,R10                  TEST SYSUT1\n         BAL   R14,TSTDCBRT\n         LR    R7,R11                  TEST SYSUT2\n         BAL   R14,TSTDCBRT\n         LR    R7,R12                  TEST SYSUT3\n*\n*        ENTRY IF SYSPRINT NOT OPENED\n*\nERROR201 LA    R14,STPOINTR            DO NOT RETURN\n         USING IHADCB,R7\nTSTDCBRT TM    DCBOFLGS,DCBOFOPN       DCB OPENED ?\n         BOR   R14                     YES, RETURN\n         MVC   0(4,R4),PTRN201         PATTERN FOR MSG 201\n         MVC   4(8,R4),DCBDDNAM        MOVE DDNAME INTO MSG\n         LA    R4,12(R4)               UPDATE POINTER\n         OI    COMPFLGS+1,NOGO         SET NOGO SWITCH ON\n         BR    R14                     RETURN\n*\n         DROP  R7\nSTPOINTR ST    R4,NEXTERR\n*\n*        END OF INITIALIZATION OF THE COMPILER\n*        GOTO SCAN 1/2 OR TO PHASE 21 FOR ERROR EDITING IF\n*        COMPILATION IS IMPOSSIBLE\n*\n         TM    COMPFLGS+1,NOGO\n         BO    GOTOEDIT                IF COMPILATION IMPOSSIBLE\n         L     R2,=A(IEX10001)\n         BR    R2                      TO INITIALIZE IEX11\n*\n*        DCB EXIT ROUTINES\n*\n         USING IHADCB,R1\n*\n*        SYSIN OPEN EXIT\n*\nINEXRT   LH    R6,DCBBLKSI             GET BLKSIZE\n         LTR   R6,R6                   VALUE PROVIDED ?\n         BNZR  R14                     YES, RETURN\n         MVC   DCBBLKSI,DCBLRECL       NO, SET BLKSIZE TO LRECL\n         BR    R14                     RETURN\n*\n*        SYSLIN OPEN EXIT\n*\nLINEXRT  LH    R6,DCBBLKSI             GET BLKSIZE\n         LTR   R6,R6                   VALUE PROVIDED ?\n         BNZR  R14                     YES, RETURN\n         LA    R6,3200                 SET A DEFAULT OF 3200\n         STH   R6,DCBBLKSI             UPDATE BLKSIZE\n         BR    R14                     RETURN\n*\n*        SYSPUNCH OPEN EXIT\n*\nPCHEXRT  LH    R6,DCBBLKSI             GET BLKSIZE\n         LTR   R6,R6                   VALUE PROVIDED ?\n         BNZR  R14                     YES, RETURN\n         MVC   DCBBLKSI,DCBLRECL       NO, SET BLKSIZE TO LRECL\n         BR    R14                     RETURN\n*\n*        SYSPRINT OPEN EXIT\n*\nPRTEXRT  LH    R6,DCBBLKSI             GET BLKSIZE\n         LTR   R6,R6                   VALUE PROVIDED ?\n         BNZR  R14                     YES, RETURN\n         MVC   DCBBLKSI,DCBLRECL       NO, SET BLKSIZE TO LRECL\n         BR    R14                     RETURN\n*\n         DROP  R1\n*\n*        ERROR ROUTINES\n*\n*        ROUTINE FOR UNEXPECTED ERROR DURING OPEN\n*        ENTERED VIA ERET\n*\nOPEXERR  OI    COMPFLGS+1,NOGO\n         BR    R14                     GO BACK TO OPEN ROUTINE\n*\n         DROP  R2\n*\n*        EXIT TO TERMINATING PHASE IF ERROR EDITING NOT POSSIBLE\n*\nGOTOTERM BALR  R2,0\n         USING *,R2\n         BAL   R4,CLOSE\n*\n         XCTL  EP=IEX51002             GO TO TERMINATING PHASE\n*\n         DROP  R2\n*\n*        TERMINATE VIA ERROR EDITING PHASE\n*\nGOTOEDIT BALR  R2,0\n         USING *,R2\n         BAL   R4,CLOSE\n         OI    COMPFLGS,TERR           INDICATE TERMINATING ERROR\n*\n         XCTL  EP=IEX21000             GO TO EDIT PHASE\n*\n         DROP  R2\n*\n*        SUBROUTINE FOR CLOSING SYSIN AND SYSUT1\n*\nCLOSE    BALR  R3,0\n         USING *,R3\n         L     R6,ASYSDCB              R6 -> SYSIN DCB\n         USING IHADCB,R6\n         TM    DCBOFLGS,DCBOFOPN       OPEN SUCCESFULLY ?\n         DROP  R6\n         BO    *+8                     YES, BRANCH\n         OI    SWITCH+1,X'F0'          NO, SYSIN NOT OPENED\n         L     R7,AUT1DCB              R7 -> SYSUT1 DCB\n*\n         CLOSE ((6),,(7))              CLOSE SYSIN AND SYSUT1\n*\nSWITCH   NOPR  R4                      RETURN IF SYSIN NOT OPENED\n*\n         FREEPOOL (R6)                 FREE SYSIN BUFFER\n*\n         BR    R4                      RETURN\n*\n         DROP  R3\n*\n         LTORG\n*\n*        DCB EXIT LIST FOR SYSIN, SYSLIN, SYSPUNCH AND SYSPRINT\n*\n         DC    0F'0'\nINEX     DC    X'85',AL3(INEXRT)\nLINEX    DC    X'85',AL3(LINEXRT)\nPCHEX    DC    X'85',AL3(PCHEXRT)\nPRINTEX  DC    X'85',AL3(PRTEXRT)\n*\n*\n*        PATTERNS FOR THE ERROR MESSAGES OF THE INITIALIZATION\n*        PHASE\n*\n*        W OPTION PARAMETER ... IS INVALID. THE PARAMETER IS\n*        DISREGARDED\n*\nPTRN200  DC    AL1(128+16,200),AL2(0),CL12' '\n*\n*        T DD CARD FOR ... IS INCORRECT OR MISSING\n*\nPTRN201  DC    AL1(128+12,201),AL2(0)\n*\n*        W DD CARD FOR SYSLIN IS INCORRECT OR MISSING. OPTION\n*        NOLOAD IS ASSUMED\n*\nPTRN202  DC    AL1(128+4,202),AL2(0)\n*\n*        W DD CARD FOR SYSPUNCH IS INCORRECT OF MISSING. OPTION\n*        NODECK IS ASSUMED\n*\nPTRN203  DC    AL1(128+4,203),AL2(0)\n*\n*        T BLOCKSIZE SPECIFIED FOR SYSIN IS INCORRECT\n*\nPTRN204  DC     AL1(128+4,204),AL2(0)\n*\n*        W BLOCKSIZE SPECIFIED FOR ... IS INCORRECT. UNBLOCKED\n*        OUTPUT IS GENERATED INSTEAD\n*\nPTRN205A DC    AL1(128+12,205),AL2(0),CL8'SYSLIN'\nPTRN205B DC    AL1(128+12,205),AL2(0),CL8'SYSPUNCH'\nPTRN205C DC    AL1(128+12,205),AL2(0),CL8'SYSPRINT'\n*\n*        W INCORRECT PARAMETER FIELD. NO OPTION PARAMETERS ARE\n*        HANDLED ANY MORE\n*\nPTRN206  DC    AL1(128+4,206),AL2(0)\n*\n*        W POSSIBLE ERROR IN DD NAMES PARAMETER\n*\nPTRN207  DC    AL1(128+4,207),AL2(0)\n*\n*        T SIZE PARAMERER IS INCORRECT. MINIMUM STORAGE SIZE FOR\n*        ALGOL F COMPILER IS 45056 BYTES\n*\nPTRN208  DC   AL1(128+4,208),AL2(0)\n*\n*        FIRST LINE OF PRINTED OUTPUT\n*\nHEADING  DC    CL121' '                HEADING LINE\n         ORG   HEADING\n         DC    C'1'                    ASA CNTL\n         DC    C'360S-AL-531 LEVEL 2.1'  IDENTIFY UPDATED SOURCE\n         DC    C'          OS ALGOL F'\n         ORG   HEADING+87\nHEADDAY  DC    C'DD'                                            |\n         DC    C' '                                             |\nHEADMON  DC    C'MMM'                  ALPHA 3 CHAR MONTH       |\n         DC    C' '                                             |\nHEADYEAR DC    C'20XX'                                          |\nHEADTIME DC    XL9'4021217A21217A2121'  PATTERN FOR TIME        |\n         DC    C'      '                                        |\nHEADPAGE DC    C'PAGE   1'                                      |\n         ORG   ,                                                V\n*\n*        TABLE OF OPTION PARAMETERS\n*\nPARMLIST DC    AL1(6)                  (LENGTH-1) OF PARAM\n         DC    CL9'PROGRAM'            PARAMETER\n         NI    COMPFLGS,PGR            SET SWITCH IN COMPFLGS\nLENGTH   DC    AL1(8)\nPARAM    DC    CL9'PROCEDURE'\nINSTR    OI    COMPFLGS,PROC\n         DC    AL1(4)\n         DC    CL9'SHORT'\n         NI    COMPFLGS,SHRT\n         DC    AL1(3)\n         DC    CL9'LONG'\n         OI    COMPFLGS,LNG\n         DC    AL1(5)\n         DC    CL9'SOURCE'\n         NI    COMPFLGS+1,SRCE\n         DC    AL1(7)\n         DC    CL9'NOSOURCE'\n         OI    COMPFLGS+1,NSRCE\n         DC    AL1(3)\n         DC    CL9'LOAD'\n         NI    COMPFLGS+1,LOAD\n         DC    AL1(5)\n         DC    CL9'NOLOAD'\n         OI    COMPFLGS+1,NLOAD\n         DC    AL1(3)\n         DC    CL9'DECK'\n         NI    COMPFLGS+1,DECK\n         DC    AL1(5)\n         DC    CL9'NODECK'\n         OI    COMPFLGS+1,NDECK\n         DC    AL1(5)\n         DC    CL9'EBCDIC'\n         NI    COMPFLGS+1,EBCDIC\n         DC    AL1(5)\n         DC    CL9'NOTEST'\n         OI    COMPFLGS+2,NOTEST\n         DC    AL1(3)\n         DC    CL9'TEST'\n         NI    COMPFLGS+2,TEST\n         DC    AL1(2)\n         DC    CL9'ISO'\n         OI    COMPFLGS+1,ISO\n         DC    AL1(1)\n         DC    CL9'NS'\n         OI    COMPFLGS+1,NSRCE\n         DC    AL1(1)\n         DC    CL9'ND'\n         OI    COMPFLGS+1,NDECK\n         DC    AL1(1)\n         DC    CL9'NL'\n         OI    COMPFLGS+1,NLOAD\n         DC    AL1(1)\n         DC    CL9'EB'\n         NI    COMPFLGS+1,EBCDIC\n         DC    AL1(1)\n         DC    CL9'PG'\n         NI    COMPFLGS,PGR\n         DC    AL1(1)\n         DC    CL9'PC'\n         OI    COMPFLGS,PROC\n         DC    AL1(1)\n         DC    CL9'NT'\n         OI    COMPFLGS+2,NOTEST\n         DC    AL1(1)\n         DC    CL9'SP'\n         NI    COMPFLGS,SHRT\n         DC    AL1(1)\n         DC    CL9'LP'\n         OI    COMPFLGS,LNG\n         DC    AL1(0)\n         DC    CL9'D'\n         NI    COMPFLGS+1,DECK\n         DC    AL1(0)\n         DC    CL9'I'\n         OI    COMPFLGS+1,ISO\n         DC    AL1(0)\n         DC    CL9'L'\n         NI    COMPFLGS+1,LOAD\n         DC    AL1(0)\n         DC    CL9'S'\n         NI    COMPFLGS+1,SRCE\nLSTENTRY DC    AL1(0)\n         DC    CL9'T'\n         NI    COMPFLGS+2,TEST\n*\n*        WORKSPACE FOR TRANSLATING THE SIZE PARAMETER AND THE\n*        ACTUAL DATE\n*\n         DC    0D'0'\nFIELD1   DC    PL8'0'\n*\nTEMP     DC    F'0'                    TEMP WORK SLOT\nTEMP1    DC    D'0'                    WORK SPACE FOR DEC TO BIN CONV\nTEMP2    DC    F'0'                    TEMP WORK SLOT\nTEMP3    DC    F'0'                    TEMPORARY WORK SPACE\n*\n*        TABLE OF THE MONTH NAMES AND THE NUMBER OF DAYS\n*\nMNTHTBL  DC    H'31'                   JAN DAYS IN MONTH\n         DC    C'JAN '                     3 CHAR MONTH CODE\n         DC    C'01'                       MONTH NUMBER\n         DC    H'29'                   FEB\n         DC    C'FEB '\n         DC    C'02'\n         DC    H'31'                   MAR\n         DC    C'MAR '\n         DC    C'03'\n         DC    H'30'                   APR\n         DC    C'APR '\n         DC    C'04'\n         DC    H'31'                   MAY\n         DC    C'MAY '\n         DC    C'05'\n         DC    H'30'                   JUN\n         DC    C'JUN '\n         DC    C'06'\n         DC    H'31'                   JUL\n         DC    C'JUL '\n         DC    C'07'\n         DC    H'31'                   AUG\n         DC    C'AUG '\n         DC    C'08'\n         DC    H'30'                   SEP\n         DC    C'SEP '\n         DC    C'09'\n         DC    H'31'                   OCT\n         DC    C'OCT '\n         DC    C'10'\n         DC    H'30'                   NOV\n         DC    C'NOV '\n         DC    C'11'\n         DC    H'255'                  DEC (ALLOW FOR STUPID DDD)\n         DC    C'DEC '\n         DC    C'12'\n*\nH60      DC    H'60'\n*\nIEX10001 CSECT\n*\n         USING IEX10001,R2\n*\n*        INSTRUCTIONS FOR INITIALIZING IEX11 CAN BE INSERTED HERE\n*\n         XCTL  EP=IEX11000             EXIT TO NEXT PHASE\n*\n*        DUMMY CONTROL SECTION TO PROVIDE ADRESSABILITY OF DCB\n*\n         PRINT NOGEN\n*\n         DCBD  DSORG=(PS),DEVD=(DA)\n*\n         PRINT GEN\n*\nWORKAREA DSECT\n*\n         COPY  WORKAREA\n*\n*        CWA SYMBOL DEFINITIONS FOR IEX11 CAN BE INSERTED HERE\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END   IEX10000\n./ ADD NAME=IEX11    0201-12230-12230-1200-04989-04989-00000-LEVEL\nX11      TITLE 'IEX11 - SCAN I/II, ALGOL F'\n*\n*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER\n*\n*        FUNCTION/OPERATION -\n*        TO TRANSFORM THE SOURCE PROGRAM TO MODIFICATION LEVEL 1,\n*        WHICH INCLUDES A ONE FOR ONE TRANSLATION OF ALL\n*        CHARACTERS, THE REPLACEMENT OF ALL ALGOL DELIMITERS BY\n*        ONE BYTE OPERATORS AND THE REMOVAL OR MODIFICATION OF\n*        ALL DECLARATIONS\n*        1. TABULATE AND CLASSIFY ALL VALID IDENTIFIERS\n*        2. ASSIGN A SERIAL PROGRAM BLOCK NUMBER TO ALL BLOCKS\n*           AND PROCEDURES AND A SERIAL GROUP NUMBER TO ALL BLOCKS,\n*           PROCEDURES AND FOR STATEMENTS\n*        3. RECOGNIZE SYNTACTICAL ERRORS IN THE SOURCE PROGRAM\n*           AND TO GENERATE APPROPRIATE ERROR PATTERNS\n*        4. PRINT A LISTING ON SYSPRINT OF THE SOURCE PROGRAM IF\n*           OPTION SOURCE IS SPECIFIED\n*        5. PREPARE TABLES TO BE USED BY THE SUCCEEDING PHASES.\n*           THE TABLES ARE PBTAB1, GROUPTABLE, AND SCOPETABLE\n*\n*        ENTRY POINTS -\n*        IEX11000 SCAN I/II XCTL EP=IEX11000\n*\n*        INPUT - THE SOURCE PROGRAM IS READ IN FROM SYSIN\n*\n*        OUTPUT -\n*        1. THE SOURCE PROGRAM, MODIFICATION LEVEL 1, IS WRITTEN\n*           ON SYSUT1\n*        2. AN ITAB RECORD IS WRITTEN FOR EACH BLOCK ON SYSUT3\n*        3. ESD CARD FOR THE OBJECT MODULE AND TXT CARDS FOR THE\n*           CONSTANTS 0 THROUGH 15 AND THE STRINGS IN THE CONSTANT\n*           POOL ARE WRITTEN ON SYSLIN AND OR SYSPUNCH IF THE\n*           OPTIONS LOAD AND OR DECK IS SPECIFIED\n*        4. THE SOURCE PROGRAM IS LISTED ON SYSPRINT IF THE\n*           SOURCE OPTION IS SPECIFIED\n*\n*        EXITS - NORMAL -\n*        CONTROL IS GIVEN TO ITAB MANIPULATION, XCTL EP=IEX20000\n*        IF NO TERMINATING ERROR HAS BEEN DETECTED\n*\n*        EXITS - ERROR -\n*        IF A TERMINATING ERROR HAS BEEN DETECTED CONTROL IS\n*        GIVEN TO THE ERROR MESSAGE HANDLING PHASE XCTL\n*        EP=IEX21000\n*\n*        EXTERNAL ROUTINES - THE PRINT ROUTINE IN IEX00 IS USED\n*\n*        TABLES/WORKAREAS -\n*        BPRTAB   - BRANCH ADDR TABLE\n*        TESTTABL - FOR MAINLOOP SCANNING\n*        TRINTEXT - FOR TRANSLATION FROM INTERNAL TO EBCDIC\n*                   CHARACTER SET\n*        COMTABLE - USED BY COMMENT PROGRAM\n*        STRTABLE - USED BY STRING PROGRAM\n*        BTABLE   - USED BY BLANK PROGRAM\n*        KEYTAB   - USED BY TRANSOP\n*        PTTABLE  - USED BY POINT AND POINT IN LIST PROGRAMS\n*        TREXTINT - FOR TRANSLATION FROM EBCDIC TO INTERNAL\n*                   CHARACTER SET\n*        KFCONST  - CONTAIN THE FULL WORD CONSTANTS 0 THROUGH 15\n*        ATABLE   - USED BY APOSTROF\n*        SCTAB    - USED TO SAVE THE STARTING SEMICOLON COUNTER\n*                   FOR THE BLOCKS\n*        KEYWTAB  - TABLE OF ALGOL KEYWORDS\n*        KWLUTAB  - DISPLACEMENTS INTO KEYWTAB\n*        DELPRGTB - BRANCH ADDR TABLE AFTER A DELIMITER HAS\n*                   BEEN FOUND\n*        ARTABLE  - USED BY LIST PROGRAM\n*        WA       - 80 BYTE WORKAREA WITH 17 PRECEEDING CHARACTERS,\n*                   USED FOR INPUT RECORDS. THE 17 EXTRA BYTES USED\n*                   TO OVERLAP BETWEEN ONE RECORD AND THE NEXT ONE\n*        STACK    - USED FOR THE SCOPE STRUCTURE HANDLING\n*        ITAB     - USED TO TABULATE ALL VALID IDENTIFIERS\n*        SAVEPRT  - DUMMY PRINTAREA. USED TO PICK UP STRINGS FROM\n*                   IN EBCDIC FORM IF THE OPTION 'NOSOURCE'\n*                   IS SPECIFIED\n*\n*        NOTES -\n*        CHARACTER CODE DEPENDENCE IF THE SOURCE PROGRAM IS IN\n*        ISO CODE A SCAN IS MADE IN THE PROGRAM CIB TO EXCHANGE\n*        THE CHARACTERS -\n*        4C, 7B, 7C, 6C, 50,\n*        WITH THE EBCDIC CHARACTERS -\n*        5D, 7E, 7D, 4D, 4E\n*        THEN WHEN THE SOURCE PROGRAM IN WA IS IN EBCDIC FORM IT\n*        IS TRANSFERRED TO THE PRINTBUFFER, POSSIBLY THE DUMMY\n*        PRINTAREA. THE SOURCE PROGRAM IN WA IS THEN TRANSLATED\n*        TO INTERNAL CODE BY MEANS OF THE HEXADECIMAL TABLE\n*        TREXTINT. THE INVERSE TABLE, TRANSLATING FROM INTERNAL TO\n*        EBCDIC CODE, IS CALLED TRINTEXT AND IS IN CHARACTER FORM.\n*        THE TRANSFER OF PRECOMPILED AND CODE PROCEDURE NAMES,\n*        THE TRANSFER OF STRINGS AND CONSTANTS TO THE CONSTANT\n*        POOL AND THE OPERATION OF THE ROUTINE GENERATE DEPENDS\n*        ON AN INTERNAL REPRESENTATION OF THE EXTERNAL CHARACTER\n*        SET WHICH IS EQUIVALENT TO THE ONE USED AT ASSEMBLY\n*        TIME. THE OPERATION OF THE OTHER PARTS DOES NOT DEPEND\n*        UPON A PARTICULAR INTERNAL REPRESENTATION OF THE\n*        EXTERNAL CHARACTER SET\n*\n*        THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN\n*        CONNECTION WITH THE OTHER MODULES OF THE ALGOL COMPILER.\n*        IN PARTICULAR IT REQUIRES THE COMMON WORKAREA\n*\n*        INITIALIZATION\n*        MAINLOOP AND ITS SUBPROGRAMS\n*        BLANK\n*        TRANSOP (*,/,(,>,<,NOT,)\n*        RIGHTPAR\n*        POINT\n*        COLON\n*        LABEL\n*        LETDEL\n*        ASSIGN\n*        APOSTROPHE\n*        SCALE\n*        BLKAPOS\n*        ZETAAPOS\n*        NPAFAPO (NOT PERMITTED)\n*        SOME GENERAL ROUTINES\n*        STATE (STATEMENT PROGRAM)\n*        ERROR ROUTINES\n*        ITABCLEA\n*        IDCHCK1\n*        FINDSEMCO\n*        AND TABLES AND CONSTANTS OUTSIDE CWA\n*\n*        COB (CHANGE OUTPUT BUFFER)\n*        CIB (CHANGE INPUT BUFFER)\n*        DELIMITER EROUT (DELIMITER ERROR ROUTINE)\n*        NORMAL (/ OR AND NOT STEP LESS IMPL UNTIL WHILE POWER\n*        EQUIU\n*        NOTLESS GREATER NOTEQUAL NOT GREATER)\n*        BOLCON ('TRUE', 'FALSE')\n*        GIF (GOTO, IF)\n*        TED (THEN, ELSE, DO)\n*        BEGIN\n*        BEGI (BLOCKHEAD)\n*        END\n*        FOREND\n*        PBLCKEND\n*        COM (COMMENT)\n*        FOR\n*        TYPE (REAL, INTEGER, BOOLEAN)\n*        IER (IDENT ERROR ROUTINE)\n*        CODE\n*\n*        IDCHECK (SPECIFIED IDENTIFIERS)\n*        VALUE\n*        TYPEARRAY\n*        ARRAY\n*        TRATE (ARRAY AND SWITCH LIST)\n*        PONTLST\n*        SEMCLST\n*        LEFTPARL\n*        RIGHTPARL\n*        SLASHLST\n*        COMMALST\n*        COLONLST\n*        SWITCH\n*        STRING\n*        TYPPROC\n*        PROCEDURE\n*        PROCEDEL (PROC LETTERSTRING)\n*        ENDMISSIN (UNBALANCED BEGIN END COUNT)\n*\n*        TERMINATION\n*\nIEX11000 CSECT\n*\n*        R3                       OUTPUT POINTER\n*        R4                       POINTS TO FIRST APOSTROPHE\n*        R4                       TRANSOP REGISTER\n*        R4                       LINK REGISTER FOR PRGBLOCKEND\n*        R4                       LINK REGISTER FOR FDREND\n*        R6                       RETURN REG FROM ERROR ROUTINES\n*        R7                       ITAB POINTER\n*        R8                       BASE REGISTER\n*        R9                       RETURN REGISTER FROM BEGI\n*        R10                      TESTLOOP AND LIST MAIN RETURN REG\n*        R11                      BASE REGISTER\n*        R12                      SPECIFICATION HANDLING\n*        R12                      RETURN REG FROM COB\n*        R14                      LABEL POINTER\n*\n*        INITIALIZATION\n*\n*        GETMAIN FOR -\n*        1. KOPOOL\n*        2. STACK\n*        3. ITABBUF\n*        4. OUTPUTAREA2\n*        5. ITAB\n*        ALPHA 00 IS PUT IN STACK AND SP (STACK POINTER) IS MADE\n*        TO POINT TO NEXT BYTE\n*        ADDR OF THE FIRST O/P AREA IS TAKEN FROM CWA AND PUT\n*        IN ADDARI. THE ADDR OF SECOND O/P AREA (FROM\n*        GETMAIN) IS PUT IN ADDARI+4\n*        AITAB, LIGP, LPBP, AITAB AND ELI ARE INITILIZED IN\n*        ITAB. HEADLINE FOR PB0 IS CREATED.\n*        AITAB, LPBP, LIGP WILL POINT TO PB0 HEAD\n*        AITL TO NEXT FREE ENTRY\n*        ELI TO LAST POSITION+1 OF ITAB\n*        APE WILL POINT TO LAST POSITION IN FIRST OUTPUT BUFFER\n*        WADDARI (CURRENT OUTPUT BUFFER) WILL POINT TO FIRST\n*        OUTPUT BUFFER\n*        R3 WILL POINT TO FIRST O/P BUFFER\n*        PRINTING OF HEADLINES IS INITIALIZED IF SOURCE WAS\n*        SPECIFIED\n*        SWITCHES ARE SET TO ZERO\n*        FIRST ENTRIES IN TABLES ARE SET TO ZERO\n*\n         IEXENTRY 'IEX11000 LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IEX11000,R5,R8,R11\n         LR    R5,R15\n         LA    R8,2048(,R5)\n         LA    R8,2048(,R8)\n         LA    R11,2048(,R8)\n         LA    R11,2048(,R11)\n*\n         USING WORKAREA,R13\n         LA    R12,SLUT2\n         ST    R12,ERET                INTERUPT BEFORE GETMAIN\n         LH    R1,KH4096               KOPOOL\n         LA    R1,1000(,R1)            STACK\n         A     R1,SRCE1S               O/P BUFFER 1\n         A     R1,ITAB10S              ITAB\n         LA    R1,2000(,R1)            ITAB BUF\n         ST    R1,POOLLEN              STORE TOTAL LENGTH\n         LR    R0,R1\n*\n         GETMAIN R,LV=(0)              GET AREAS NEEDED\n*\n         ST    R1,POOLLOC              SAVE LOCATION\n         LA    R12,ENDMISS             END OF DATA ADDR\n         ST    R12,EODIN\n         LA    R12,EODADIN\n         ST    R12,ERET                ADDR AFTER GETMAIN\n         ST    R1,AKOPOOL              ADDR OF KOPOOL\n         LA    R1,4095(,R1)\n         MVC   1(4,R1),KF0             INITIALIZE STACK\n         LA    R1,2(,R1)\n         ST    R1,SP                   ADDR OF SECOND BYTE IN STACK\n         LA    R1,999(,R1)\n         ST    R1,AITABBUF             INITIALIZE ITAB BUFFER\n         LA    R1,2000(,R1)\n         ST    R1,ADDARI+4                       OUTPUTAREA 2\n         A     R1,SRCE1S\n         ST    R1,AITAB                          ITAB\n         ST    R1,LIGP                 SURROUNDING GROUP ADDR\n         ST    R1,LPBP                             BLOCK ADDR\n         MVI   0(R1),0                 CLEAR FIRST TWO ITAB ENTRIES\n         MVC   1(21,R1),0(R1)\n         MVI   3(R1),X'FF'             CONSTRUCT CONTINUATION\n         MVI   5(R1),XFBLANK           LINE FOR PB0\n         LA    R12,11(,R1)\n         ST    R12,AITL                ADDR OF FIRST FREE ENTRY\n         A     R1,ITAB10S\n         ST    R1,ELI                  END OF ITAB\n         L     R3,SRCE1ADD             ADDR OF FIRST OUTPUT BUFFER\n         A     R3,SRCE1S\n         BCTR  R3,0\n         ST    R3,APE                  END OF FIRST O/P BUFFER\n         L     R3,SRCE1ADD             OUTPUT AREAS CONSTANTS\n         MVC   ADDARI(4),SRCE1ADD\n         MVC   WADDARI(4),ADDARI       CURRENT O/P AREA ADDR\n         LA    R12,SAVEPRNT            APRNTAR INITIALIZED WITH\n         ST    R12,APRNTAR             DUMMY PRINT AREA ADDR\n*\n*        SETUP HEADING TEXT\n*\n         MVC   PAGEHD1D+30(L'HEAD1),HEAD1\n         MVC   PAGEHD2D+4(L'HEAD2),HEAD2\n         MVI   LINCNT+1,255            FORCE HEADINGS\n         BAL   R9,CIB                  GET FIRST RECORD AND ADDR\n*                                      OF FIRST PRINTAREA\n         SR    R2,R2                   ZERO REG\n         STC   R2,ONC                  ZERO COUNTERS\n         STC   R2,DISP                 ZERO SWITCHES\n         LA    R12,64\n         ST    R12,PRPT                PROGRAM POINTER\n         STH   R2,IGC                  ZERO ITAB GROUP COUNTER\n         ST    R2,MGESITL\n         STC   R2,PBC                  ZERO PROGRAM BLOCK COUNTER (PBC)\n         STC   R2,ONC                  ZERO OUTPUT RECORD COUNTER (ONC)\n         STC   R2,BITS1                ZERO SWITCHBITS\n         STC   R2,BITS2\n         STC   R2,BITS3\n         STH   R2,SEMCNT               ZERO SEMICOLON COUNTER\n         STC   R2,FSN                  ZERO FSN\n         STC   R2,PBTAB1               ZERO PB0\n         ST    R2,GPTAB+3              ZERO GROUP AND SCOUP TABLE\n         STC   R2,SPTAB\n         STC   R2,0(,R3)               FIRST BYTE IN FIRST OUTPUTRECD\n         ST    R3,OPIN\n         ST    R3,LAPIN                SET LABEL POINTERS\n         STC   R2,OPIN+4\n         LA    R12,GPTAB\n         ST    R12,AGT                 ADDR TO GROUPTABLE\n         L     R12,AITABBUF\n         BCTR  R12,0\n         ST    R12,ATOPSTAK            HIGHEST BYTE IN STACK TO USE\n         B     TESTLOOP                GOTO START PROCESSING\n*\nEXMVC    MVC   0(1,R3),0(R4)\n*\n*        MAINLOOP\n*\n*        SCANS THE INPUT STREAM WHICH IS IN INTERNAL CODE\n*\n*        EVERYTHING PRECEDING THE FIRST REAL ALGOL WORD WILL BE\n*        SKIPPED WITH THE HELP OF THE FALG BITS2, X'20'\n*\nTESTLOOP BALR  R10,0\n         LR    R9,R10                  RETURN ADDR FOR CIB PROGRAM\n         LR    R4,R1\n         SR    R2,R2\n         TRT   0(73,R1),TESTTABL       SCAN INTERNAL CODE WITH TESTTABL\n         TM    BITS2,X'20'             FIRST BEGIN FOUND ?\n         BZ    FIRSTSTR                NO\nCONT     LR    R15,R1                  FIND LENGTH OF SCANNED BYTES\n         SR    R15,R4\n         BZ    SUBROUT\n         BAL   R12,COB\n         LA    R0,0(R15,R3)\n         C     R0,APE                  SPACE LEFT IN O/P BUFFER ?\n         BH    MSBLOOP\n         BCTR  R15,0\n         EX    R15,EXMVC               MOVE SCANNED BYTES\n         LR    R3,R0                   INCREASE OUTPUT POINTER\nSUBROUT  L     R6,BPRTAB(R2)\n         BR    R6                      BRANCH TO PROGRAM\n*\n*        MSBLOOP\n*\n*        USED WHEN SCANNED BYTES HAS TO BE PLACED IN TWO O/P AREAS\n*\nMSBLOOP  L     R6,APE\n         SR    R6,R3\n         BCTR  R6,0\n         EX    R6,EXMVC                MOVE TO FIRST O/P AREA\n         LA    R3,1(R6,R3)\n         BAL   R12,COBSPEB             CHANGE O/P BUFFER\n         LA    R12,1(R6,R4)\n         SR    R15,R6\n         BCTR  R15,0\n         BCTR  R15,0\n         EX    R15,MOVERST             MOVE TO 2ND O/P BUFFER\n         LA    R3,1(R15,R3)\n         B     SUBROUT                 RETURN\n*\nMOVERST  MVC   0(1,R3),0(R12)\nFIRSTSTR CLI   0(R1),XFQUOTE           QUOTE ?\n         BE    APOSTROF\n         CLI   0(R1),XFZETA            ZETA ?\n         BE    CIB\n         LA    R1,1(,R1)               IF NEITHER- CONTINUE SCANNING\n         B     TESTLOOP\n*\n*        BLANK\n*\n*        SCANS TO THE NEXT NONBLANK CHARACTER\n*        ALL BLANK CHARACTER WILL BE SKIPPED\n*        USED BY MAIN LOOP AND ARRAYLIST\n*\nBLANK    LA    R1,1(,R1)               INCREASE INPUT POINTER\n         CLI   0(R1),XFBLANK           BLANK ?\n         BNER  R10                     NO, RETURN\n         LA    R1,1(,R1)               YES, INCREASE INPUT POINTER\n         SR    R2,R2\n         TRT   0(73,R1),BTABLE         SCAN INPUT TO NEXT DELIMITER\n         BR    R10                     RETURN\n*\n*        TRANSOP\n*\n*        CHECKS THE NEXT BYTE IN THE INPUT AREA AGAINS A\n*        KEY IE IF ( FOUND, NEXT BYTE WILL BE CHECKED FOR /, IF\n*        A SLASH IS FOUND A LEFT SQUARE BRACKET WILL BE\n*        TRANSFERED OTHERWISE A (\n*        USED BY MAIN LOOP AND ARRAYLIST\n*\nTRANSOP  LA    R4,KEYTAB(R2)           GET CORRECT ENTRY IN TABLE\nINCR     LA    R1,1(,R1)\nINCRA    CLC   0(1,R1),3(R4)           INPUT EQUAL EXPECTED ONE ?\n         BE    TROE                    YES, TAKE SUBSTITUTE CHAR\n         CLI   0(R1),XFBLANK           BLANK ?\n         BE    INCR\n         CLI   0(R1),XFZETA            ZETA ?\n         BNE   TRONE                   IF NEITHER TAKE CHAR IN I/P\n         LA    R9,INCRA\n         B     CIB\n*\nTRONE    BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVC   0(1,R3),2(R4)           TAKE CHAR FOUND IN INPUT\n         LA    R3,1(,R3)\n         BR    R10                     RETURN\n*\nTROE     BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVC   0(1,R3),1(R4)           TAKE SUBSTITUTE CHAR FROM TABLE\n         L     R12,BRACKET\n         CLI   0(R3),XFRSQBR           RIGHT SQUARE BRACKET ?\n         BNE   TSTMORE                 NO\n         BCTR  R12,0                   YES, SUBTRACT 1 FROM CTR\n         B     NOUPDAT\n*\nTSTMORE  CLI   0(R3),XFLSQBR           LEFT SQUARE BRACKET ?\n         BNE   NOUPDAT                 NO\n         LA    R12,1(,R12)             YES, INCR COUNTER\nNOUPDAT  ST    R12,BRACKET\n         LA    R3,1(,R3)\n         LA    R1,1(,R1)\n         BR    R10                     RETURN\n*\n*        RIGHTPAR\n*\n*        INSERTS A ) IN O/P, SETS THE LABEL POINTERS\n*\nRIGHTPAR BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVI   0(R3),XFRBRAC           TRANSFER ) TO OUTPUT BUFFER\n         ST    R3,OPIN                 NOTE ITS POSITION\n         MVI   OPINCHAR,XFRBRAC\n         MVC   OPIN+4(1),ONC           AND THE OUTPUT RECORD NUMBER\n         LA    R3,1(,R3)\n         ST    R3,LAPIN                NOTE POSITION WHERE LETTERSTRING\n         LA    R1,1(,R1)               MAY START\n         B     TESTLOOP\n*\n*        POINT\n*\n*        SCANS FOR -\n*        DECPOINT\n*        ERROR\n*        COLON\n*        SEMICOLON\n*        ASSIGN\n*        USED BY MAIN LOOP AND ARRAYLIST\n*\nPOINT    LA    R1,1(,R1)               SCAN SOURCE STRING\n         LA    R9,*                    RETURN ADDR FOR CIB PROGRAM\n         SR    R2,R2                   CLEAR FUNCTION BYTE REG\n         TRT   0(73,R1),PTTABLE        TO NEXT DELIMITER\n         L     R6,BPRTAB(R2)           BRANCH TO SELECTED\n         BR    R6                      SUBROUTINE\n*\n*        DECPOINT\n*\n*        TRANSFERS A DECIMAL POINT\n*\nDECPOINT BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVI   0(R3),XFDECPT           TRANSFER DECIMAL POINT\n         LA    R3,1(,R3)\n         BR    R10\n*\n*        ASSIGN\n*\n*        TRANSFERS A ASSIGN CHAR TO O/P\n*        RETURNS VIA STATEMENT\n*\nASSIGN   BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVI   0(R3),XFASSIGN          TRANSFER .= TO OUTPUTBUFFER\n         LA    R1,1(,R1)               INCR INPUT POINTER\n         LA    R3,1(,R3)               INCR OUTPUT POINTER\n         B     STATE                   BRANCH TO STATEMENT PROGRAM\n*\n*        STATE\n*\n*        1. CHECKS WITH PROBIT IF FIRST LABEL, FOR, IF, GOTO OR\n*           ASSIGN STATMENT AFTER A PROCEDURE\n*        2. CHECKS THAT ALL PARAMETERS HAVE BEEN SPECIFIED\n*        3. TURNS OFF THE PROBIT AND THE BEGBIT, POSSIBLE\n*           PROCEEDING BEGIN WILL BE COMPOUND BEGIN\n*\nSTATE    NI    BITS1,X'7F'             BEGBIT = 0\n         L     R15,SP\n         CLI   0(R15),X'0C'            PROC IN STACK ?\n         BNER  R10                     IF NO RETURN\n         MVI   0(R15),X'14'\n         NI    BITS1,X'BF'             PROBIT.=0\n         CLI   PZ,0                    ALL PARAMETERS SPECIFIED ?\n         BER   R10                     YES, RETURN\n         BAL   R12,ERROR10             NO, GENERATE E10\n         BR    R10                     RETURN\n*\n*        APOSTROF\n*\n*        SCANS FOR -\n*        SCALE\n*        BLANK\n*        ZETA\n*        NOT PERMITTED\n*        ONE MORE APOSTROPHE (DELIMITER)\n*        R4 WILL POINT TO THE APOSTROPHE\n*        USED BY TESTLOOP AND LIST\n*\nAPOSTROF MVI   FBYTE,0                 ZERO FBYTE\nENTRAPR  LR    R4,R1                   R4 WILL POINT TO FIRST APOST\n         LA    R1,1(,R1)\n         BALR  R9,0\n         SR    R2,R2\n         TRT   0(73,R1),ATABLE         SOURCE STRING IS SCANNED TO\n*                                      THE NEXT SIGNIFICANT DELIMITER\n         L     R6,BPRTAB(R2)           R6 -> SELECTED SUBROUTINE\n         BR    R6                      BRANCH TO ROUTINE SELECTED\n*\n*        SCALE\n*\n*        CORRECT ONLY DIRECT AFTER TESTLOOP OR LIST\n*        CHECK THAT THE APOSTROPHE IS ONLY ONE CHAR IN FRONT OF\n*        DIGIT\n*\nSCALE    TM    FBYTE,X'FF'\n         BO    COMCEE2                 COMMENT UNDER PROCESS\n         BM    TYPESPEC                DECLARATION UNDER PROCESS\nSCALEOK  LR    R6,R1\n         TM    BITS2,X'20'             PROGRAM STARTED YET ?\n         BZ    TESTLOOP                NO, RETURN\n         BCTR  R6,0\n         CLI   0(R6),XFQUOTE           QUOTE ONE BYTE BEFORE SIGN\n*                                      OR DIGIT ?\n         BNE   EROUT                   IF NO, BRANCH TO ERROR ROUTINE\n         BAL   R12,COB                 CHECK IF O/P AREA FILLED\nMOVETEN  MVI   0(R3),X'3F'             MOVE SCALE FACTOR TO OUTPUT REC\n         LA    R3,1(,R3)               INCREASE OUTPUT\n         BR    R10                     RETURN\n*\n*        BLKAPOS\n*\n*        SHIFT THE BLANK OR BLANKS AWAY AND MOVES THE QUOTE\n*        AND VALID CHARACTERS UP TO THE RIGHT\n*\n*        SETS R4 TO POINT NEW LOCATION OF THE QUOTE\n*        USED BY MAINLOOP AND INDIRECT BY THE ARRYLIST AND THE\n*        NPAFTAPO\n*\nBLKAPOS  LR    R15,R1                  NOTE POSITION OF FIRST BLANK\nBLKAPOSA TRT   0(73,R1),BTABLE\n         LR    R6,R1                   CALC NUMBER OF BLANKS\n         SR    R6,R15                  NUMBER OF BLANKS IN R6\n         LR    R14,R15\n         SR    R14,R4\n         C     R14,KF11                BYTES EXCEED THE LIMIT ALREADY ?\n         BH    EROUT\n         BCTR  R14,0                   NUMBER OF BYTES TO BE SHIFTED\n         LA    R15,0(R6,R4)            COMPUTE NEW POSITION OF QUOTE\n         EX    R14,MAPOS               MOVE QUOTE AND SCANNED CHARS\n         EX    R14,MAPOS2\n         LR    R4,R15                  NOTE NEW POSITION OF QUOTE\n         BR    R9                      RETURN\n*\nMAPOS    MVC   BUCKET(1),0(R4)\nMAPOS2   MVC   0(1,R15),BUCKET\n*\nBUCKET   DC    11X'00'\n*\n*        ZETAAPO\n*\n*        MOVES SCANNED BYTES AND APOSTROPHE IN FRONT OF WA AND\n*        PUTS R4 TO NEW START LOCATION OF POSSIBLE DELIMITER\n*        USED BY MAINLOOP AND ARRAYLIST\n*\nZETAAPO  LR    R15,R4                  COMPUTE\n         LR    R14,R1                  NUMBER OF SCANNED\n         SR    R14,R4                  BYTES\n         C     R14,KF11                EXCEED LIMIT ?\n         BH    EROUT                   YES\n         LA    R4,WA                   NO, CALCULATE WHERE TO MOVE\n         SR    R4,R14                  CHAR STRING\n         BCTR  R14,0\n         EX    R14,MOVBEFWA            MOVE CHAR IN FRONT OF WA\n         B     CIB                     CHANGE INPUT BUFFER\n*\nMOVBEFWA MVC   0(1,R4),0(R15)\n*\n*        NPAFAPO\n*\n*        GIVES ERROR MESSAGE AND UTILIZES BLANKAPO TO SHIFT THE\n*        INVALID CHARACTER AWAY\n*        USED BY MAINLOOP AND ARRAYLIST\n*\nNPAFTAPO TM    FBYTE,X'FF'\n         BM    TYPESPEC                INVALID IDENTIFIER\n         BO    COMCED2                 COMMENT UNDER PROCESS\n         TM    BITS2,X'20'             PROGRAM STARTED YET ?\n         BZ    NPAFTAPA                NO, BYPASS ERROR MSG\n         BAL   R6,ERR7\n*\n         DC    X'0401'                 E1\n*\nNPAFTAPA LR    R15,R1\n         LA    R1,1(,R1)               GOTO BLKAPOS TO SHIFT AWAY\n         B     BLKAPOSA                INVALID CHARACTER\n*\n*        COLON\n*\n*        ENTERD FROM MAINLOOP OR POINT\n*        CHECKS FOR   :=  ASSIGN\n*                     :(  DELIMITER\n*                         LABEL\n*\nCOLON    LR    R6,R1                   STORE PRECEEDING 6 CHARACTERS\n         S     R6,KF6                  TO BE USED ONLY IF INCORRECT\n         MVC   BUCKET(6),0(R6)         USE OF COLON E3\nCOLON2   LA    R1,1(,R1)               R1 -> NEXT INPUT CHAR\nEQUAL    CLI   0(R1),XFEQUAL           COLON FOLLOWED BY EQUAL SIGN ?\n         BE    ASSIGN                  BRANCH TO ASSIGN PROGRAM\n         CLI   0(R1),XFLBRAC           COLON FOLLOWED BY LEFT BRACKET ?\n         BE    LETDEL                  BRANCH TO DELIMITER PROCESSING\n         CLI   0(R1),XFBLANK           COLON FOLLOWED BY BLANK ?\n         BE    COLON2                  REPEAT SEARCH\n         CLI   0(R1),XFZETA            COLON FOLLOWED BY ZETA ?\n         BNE   LABEL01                 NO, BRANCH TO LABEL PROCESSING\n         LA    R9,EQUAL                YES, PROVIDE RETURN ADDR\n         B     CIB                     GET NEW INPUT BUFFER\n*\n*        LABEL\n*\n*        OPIN POINTS TO LAST OPERATOR WHICH MIGHT BE\n*        FOLLOWED BY A LABEL\n*        R14 IS THE POINTER, STEPPING UP BETWEEN LAPIN AND\n*        THE COLON POINTED TO BY R3\n*        OPIN+4 CONTAINS THE O/P REC NUMBER WHEN OPIN WAS SET\n*        LABEL IS CHECKED FOR VALIDITY. THE FIRST 6 CHAR\n*        ARE MOVED TO OUTPUT AND ITAB\n*        CHECKS IF THE LABEL IS SPLIT OVER MORE THAN ONE\n*        O/P BUFFER\n*\n*        IF THE LABEL IS SPLIT BY ONE O/P BUFFER END THE HANDLING\n*        IS THE SAME AS IF NOT EXECPT THAT WHEN ZETA\n*        IS FOUND R14 IS UPDATED TO THE FIRST CHARACTER OF THE\n*        CURRENT O/P REC\n*\n*        E3 IF THERE IS NO LABEL\n*        E6 IF LABEL LONGER THAN 1024 BYTES\n*        E7 IF LABEL CONTAINS INVALID CHARACTER\n*        E8 IF LABEL STARTS WITH INVALID CHAR\n*\nLABEL01  CLC   ONC,OPIN+4              LABEL EXCEEDS ONE O/P REC ?\n         BE    LABEL                   NO\n         SR    R4,R4\n         IC    R4,OPIN+4\n         LA    R4,1(,R4)\n         IC    R2,ONC\n         CR    R2,R4                   LABEL EXCEEDS 2 O/P REC ?\n         BE    LABEL                   NO\n         BAL   R6,ERR4\n*\n         DC    X'0406'                 TERMINATING ERROR\n*\nLABEL    L     R14,LAPIN\n         CR    R3,R14                  ANY IDENTIFIER ?\n         BE    ERROR3                  E3 COLON DELETED\n         CLI   OPINCHAR,XFRBRAC        LABEL PROCEEDED BY RIGHT BRACK ?\n         BE    ERROR3                  YES, E3 IS GIVEN\nLABNAME  CLI   0(R14),XFA              FIRST CHAR SPECIAL OR NUMERIC ?\n         BL    LABNAMER                YES, BRANCH, NOT LETTER\n         L     R7,AITL                 NO, LETTER\n         MVC   0(1,R7),0(R14)          MOVE CONTENTS OF R14 TO ITAB\n         LA    R7,1(,R7)               INCR R7\n         LA    R2,1                    INITIALIZE R2 WITH 1\nLABID    LA    R14,1(,R14)             GET NEXT CHAR\n         CR    R14,R3                  R14 = R3 ?\n         BE    LABEND\nLABCHECK CLI   0(R14),XFZETA           ZETA ?\n         BNE   LABCHK1                 NO, BRANCH\n         L     R14,WADDARI             GET START OF CURRENT O/P AREA\n         B     LABCHECK\n*\nLABCHK1  BL    ERROR7\n         C     R2,KF6                  R2 = 6 ?\n         BE    LABID                   YES, DON'T MOVE MORE CHAR TO\n*                                      ITAB\n         MVC   0(1,R7),0(R14)          MOVE CONTENT OF PINTOIN\n         LA    R7,1(,R7)               INCR R7, R2\n         LA    R2,1(,R2)\n         B     LABID\n*\nLABNAMER CLI   0(R14),XFZETA           ZETA ?\n         BNE   LABNAM01                NO, BRANCH\n         L     R14,WADDARI             UPDATE R14 TO CURRENT O/P BUFFER\n         B     LABNAME\n*\nLABNAM01 CLI   0(R14),XFBLANK          BLANK ?\n         BE    LABNAME                 YES, BRANCH\n         BAL   R6,ERR7\n*\n         DC    X'0408'                 E8\n*\n         B     ERROR7A\n*\nERROR7   BAL   R6,ERR2\n*\n         DC    X'0007'                 E7 INCORRECT LABEL\n*\nERROR7A  L     R15,AITL\n         BAL   R12,ITABCLEC            CLEAR THE ITAB ENTRY\n         BR    R10\n*\n*        LABEND\n*\n*        IF (LABEL:LABELX) THE LN (LABEL NUMBER) WILL ONLY BE\n*        INCREASED ONCE\n*        INTERNAL NAME IS CREATED AND LN INSERTED\n*        X'27' IS MOVED TO THE O/P TO INDICATE LABEL OPIN,\n*        OPIN+4 AND LAPIN ARE UPDATED\n*        ITABCLEA IS ACTIVATED TO PREPARE NEXT ITABENTRY\n*\nLABEND   CLI   OPINCHAR,XFLABEL        +. LABEL PRECEEDED BY LABEL\n         BE    LABLAHEI                YES, DO NOT UPDATE LN\n         LH    R15,LN                  LN = LN+4\n         LA    R15,4(,R15)\nLABCREAT CLC   LN(2),KH4096            LN = 2**12 ?\n         BL    LABCRT01\n         BAL   R6,ERR7\n*\n         DC    X'04D8'                 E216\n*\n         LA    R15,LATBEG              RESET LN\nLABCRT01 STH   R15,LN\nLABLAHEI L     R15,AITL\n         MVI   6(R15),X'CC'            CREATE INTERNAL NAME\n         MVI   7(R15),X'08'\n         L     R14,LPBP\n         MVC   8(1,R15),10(R14)        PROGRAM BLOCK NR AITL + 7\n         MVC   9(2,R15),LN             LN IN AITL+9\n         BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVI   0(R3),XFLABEL           MOVE LABEL IND TO O/P\n         ST    R3,OPIN                 SET LABEL POINTERS\n         MVI   OPINCHAR,XFLABEL\n         MVC   OPIN+4(1),ONC\n         LA    R3,1(,R3)\n         ST    R3,LAPIN\n         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY\n         B     STATE                   RETURN VIA STATEMENT PCM\n*\n*        LETDEL\n*\n*        :( HAS BEEN FOUND IN THE I/P\n*        IF OPIN POINTS TO A RIGHT PARENTHESIS IT SHOULD BE\n*        LETTER DELIMITER, WHICH SHOULD BE REMOVED AND REPLACED\n*        BY A COMMA\n*        IT IS CHECKED THAT ALL CHARACTERS ARE LETTERS OTHERWISE\n*        E3 IS GIVEN\n*\nLETDEL   CLI   OPINCHAR,XFRBRAC        OPIN POINTS TO A RIGHT BRACKET ?\n         BNE   ERROR3                  NO, E3, COLON DELETED\n         CLC   ONC(1),OPIN+4           LETDEL EXCEEDS ONE O/P REC ?\n         BNE   LETDELB2                YES\n         L     R14,OPIN\n         LA    R6,1(,R14)\n         CR    R6,R3                   AT LEAST ONE CHAR ?\n         BE    ERROR3                  NO, E3 DELETE COLON\nLETDELE1 LA    R14,1(,R14)             OTHER CHAR THAN\n         CLI   0(R14),XF9              LETTERS ?\n         BNH   ERROR3\n         LA    R6,1(,R14)\n         CR    R6,R3                   ALL CHAR CHECKED ?\n         BNE   LETDELE1                NO, CHECK NEXT\n         L     R3,OPIN                 SET O/P POINTER TO BEGINING OF\n         MVI   0(R3),XFCOMMA           THE STRING, MOVE IN A COMMA\n         LA    R3,1(,R3)\n         LA    R1,1(,R1)               GET NEXT CHAR\n         BR    R10\n*\n*        DELIMITER EXCEEDS ONE O/P RECORD\n*\nLETDELB2 SR    R6,R6                   DOES THE STRING\n         IC    R6,OPIN+4               EXCEED 2 O/P RECORDS ?\n         LA    R6,1(,R6)\n         IC    R2,ONC\n         CR    R6,R2\n         BE    LETDEL01                NO\n         BAL   R6,ERR4\n*\n         DC    X'0404'                 E4  GOES TO COMPFIN\n*\nLETDEL01 L     R14,OPIN                MAKE R14 POINT TO LETTER DEL\nLETDELB3 LA    R14,1(,R14)\n         CLI   0(R14),XFA              LETTER ?\n         BNL   LETDELB3                YES\n         CLI   0(R14),XFZETA           NO, ZETA ?\n         BNE   ERROR3\n         L     R14,WADDARI             CHANGE BACK SO R14 POINT\n*                                      TO CURR.O/P\nLETDELF4 CLI   0(R14),XFA              LETTER ?\n         BL    ERROR3                  E3 DELETE COLON\n         LA    R14,1(,R14)             SKIP ALL LETTERS\n         CR    R14,R3                  UNTIL END OF DELIMITERS\n         BNE   LETDELF4\n         L     R3,WADDARI              LOAD ADDR OF CURRENT O/P REC\n         MVI   0(R3),X'3D'             MOVE IN $ RHO\n         LA    R3,1(,R3)\n         LA    R1,1(,R1)               GET NEXT CHAR\n         BR    R10\n*\n*        SEMCO\n*\n*        IF THE DELTA BIT IS ON, THE DELTA AND SEMICOLON COUNTER\n*        (SEMCNT) IS MOVED TO THE OUTPUT\n*        IF THE DELTABIT IS OFF THE STACK IS INSPECTED\n*\n*        BEGIN, BETA OR PROC* -\n*        A SEMICOLON AND THE SEMCNT IS MOVED TO THE O/P AND\n*        PROCESSING IS CONTINUES VIA TEST\n*\n*        FOR -\n*        THE FORSTATMENT IS COMPLETE, THE FOREND PROGRAM IS\n*        ACTIVATED\n*        THE RETURN IS TO STACKTST TO SEE IF ONE MORE FOR\n*        STATEMENT OR A PROC** HAS ENDED AT THE SAME TIME\n*\n*        PROC -\n*        A PROCEDURE CONSISTING OF ONLY ONE STATMENT OR A DUMMY\n*        STATMENT HAS ENDED IT IS CHECKED THAT ALL PARAMETERS\n*        HAVE BEEN SPECIFIED, AND THE PROC** PGM IS JOINED\n*\n*        PROC** -\n*        A PROCEDURE CONSISTING OF ONE LABELED STATEMENT OR ONE\n*        FOR, IF, GOTO OR ASSIGN STATEMENT HAS ENDED\n*        THE PROGRAM BLOCKEND PROGRAM IS ACTIVATED AND A DELTA\n*        AND THE SEMCNT IS MOVED OUT\n*\n*        THE FINAL EXIT IS IN ALL CASES TO TEST\n*\nSEMC60   OI    COMPFLGS+2,SET60        SET SWITCH FOR 60 CHAR SET\nSEMCO    LH    R4,SEMCNT\n         C     R4,SCOVFL               TEST SEMICOLON OVERFLOW\n         BL    SEMCO01\n         BAL   R6,ERR7\n*\n         DC    X'0411'                 E17\n*\n         MVC   SEMCNT,KF0              ZERO SEMICOLON COUNT\nSEMCO01  LA    R4,1(,R4)               INCR SEMICOLON COUNTER\n         STH   R4,SEMCNT\n         LA    R0,3(,R3)               PROVIDE 3 BYTES IN OUTPUT BUF\n         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P\n         NI    BITS3,FMOFF\n         TM    BITS1,X'20'             TEST DELTABIT\n         BO    DELTA                   ON, BRANCH TO DELTA TRANSFER\n         LA    R4,STACKTST             RETURN REG (FOREND, PBLCKEND)\n         L     R15,SP\n         IC    R2,0(,R15)              SELECT BRANCH ADDR\n         L     R6,PROG2(R2)            DEPENDING ON WHAT IS IN STACK\n         BR    R6\n*\nPROG2    DC    A(ERR8)                 +00 ALPHA   SHOULD NOT OCCUR\n         DC    A(SCTRANS)              +04 BETA\n         DC    A(SCTRANS)              +08 BEGIN\n         DC    A(SEMPROC)              +12 PROC\n         DC    A(SCTRANS)              +16 PROC*\n         DC    A(SEMPROC2)             +20 PROC**\n         DC    A(FOREND)               +24 FOR\n*\nDELTA    NI    BITS1,X'DF'             DELTA BIT= 0\n         MVI   0(R3),XFDELTA           TRANSFER DELTA\n         B     SCTRANSA\n*\nSCTRANS  MVI   0(R3),XFSCOLON          TRANSFER SEMICOLON\nSCTRANSA MVI   OPINCHAR,XFSCOLON\n         ST    R3,OPIN                 NOTE POS OF SEMICOLON IN OPIN\n         MVC   OPIN+4(1),ONC           AND O/P NO\n         MVC   1(2,R3),SEMCNT          TRANSFER SEMICOLON COUNTER\n         LA    R3,3(,R3)               INCREASE OUTPUT POINTER\n         ST    R3,LAPIN\n         NI    BITS1,X'7F'             BEGBIT.=0\n         LA    R1,1(,R1)               INCREASE INPUT POINTER\n         B     TESTLOOP\n*\nSEMPROC  NI    BITS1,X'BF'             PROBIT.=0\n         CLI   PZ,0                    ALL PARAMETERS SPECIFIED\n         BE    SEMPROC2\n         BAL   R12,ERROR10\nSEMPROC2 BAL   R4,PBLCKEND\n         LA    R0,3(,R3)               PROVIDE 3 BYTES IN OUTPUT BUF\n         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P\n         MVI   0(R3),XFDELTA           TRANSFER DELTA\n         B     SCTRANSA\n*\nSTACKTST CLI   0(R15),X'14'\n         BE    SEMPROC2                PROC**\n         BH    FOREND                  FOR\n         LA    R0,3(,R3)\n         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P\n         B     SCTRANS\n*\n*        ERROR ROUTINE\n*\n*        GENERATES ERROR PATTERNS\n*\n*        MAINLY CLOSED SUBROUTINES, ENTERED WITH BAL R6\n*        FOLLOWED BY TWO BYTES. FIRST BYTE SPECIFIES THE LENGTH,\n*        IF KNOW AND SECOND BYTE ERROR NUMBER.\n*        USES ERROR1 TO CHECK FOR ERRORPOL OVERFLOW AND TO\n*        INSERT NUMBER, LENGTH AND SEMCNT\n*\n*        ERR0\n*\n*        GENERATES E212 PATTERN\n*        EXITS TO COMFIN\n*\nERR0     MVI   0(R15),X'02'\n         MVI   1(R15),X'D4'            E212\n         LA    R15,2(,R15)\n         ST    R15,NEXTERR\n         B     COMPFIN\n*\n*        ERR1\n*\n*        E1\n*        ACTIVATES ERR7, SKIPS INVALID CHARACTER AND RETURNS TO\n*        EITHER TESTLOOP OR LIST\n*        ENTERED VIA BPRTAB WHEN USED BY TESTLOOP OR LIST\n*        INVALID CHARACTER FOLLOWING AN APOSTROPHE IS TREATED\n*        SPECIALLY IN NPAFTAPO\n*\nERR1     BAL   R6,ERR7                 NOT PERMITTED CHARACTER\n*\n         DC    X'0401'                 E1\n*\n         LA    R1,1(,R1)\n         BR    R10                     RETURN TO TEST OR TRATE\n*\n*        ERR2\n*\n*        ERR2      7, 16, 31, 32, 33, 34\n*             ENTERED   ERROR7, IER, ARRAYERR, SWITCHERR\n*                       SLASHERR, SEMCLST, SEMCLER, ARRYSLSH\n*                       SLASHLST, PNAMERR\n*             NAME TAKE FROM AITL\n*        ERR2B          10, 36, 37\n*                       ERROR10, PROCFIN, ERROP37\n*             NAME TAKEN FROM LPBP-11\n*        ERR2C     14\n*                       EROUT\n*             DELIMITER TAKEN FROM BUCKET\n*        ERR2E     16, 26, 27, 30\n*                       IDVALCHK, VALDLB2, IDSELSE, NOTFOUND\n*             NAME TAKEN FROM IDBUCKET\n*        ERR2D UTILISES ERROR2 TO FIND LENGTH\n*                       ERROR1 TO CREATE MESSAGE\n*                       MOVES IN INFORMATION\n*                       RETURNS TO CALLING SEQUENCE\n*\nERR2     L     R7,AITL                 NAME FROM AITL\n         B     ERR2D\n*\nERR2B    L     R7,LPBP                 NAME FRM LPBP-11\n         S     R7,KF11\n         B     ERR2D\n*\nERR2C    MVC   BUCKET(6),1(R4)         DELIMITER FROM BUCKET\n         LA    R7,BUCKET\n         B     ERR2D\n*\nERR2E    LA    R7,IDBUCKET             E26 NAME FROM IDBUCKET\nERR2D    STM   R12,R15,ERRSAVE\n         BAL   R12,ERROR2              GET NAME AND LENGTHS\n         BAL   R12,ERROR1              CREATE ENTRY IN ERRPOOL\n         EX    R2,ERRMOVE              MOVE THE NAME\n         LM    R12,R15,ERRSAVE\n         B     2(,R6)\n*\n*        ERROR3\n*\n*        GENERATES PATTERN FOR E3\n*        ENTERED FROM LABEL, COLONLST\n*        TAKES INFORMATION FROM BUCKET\n*\nERROR3   STM   R12,R15,ERRSAVE         GET PARAMETER FIELD\n         LA    R6,PARAM3\n         BAL   R12,ERROR1              CREATE PATTERN\n         MVC   4(6,R15),BUCKET         MOVE IN INFORMATION\n         LM    R12,R15,ERRSAVE\n         BR    R10\n*\nPARAM3   DC    X'0A03'\n*\n*        ERR4\n*\n*        PROCESS ALL TERMINATING ERRORS THAT ARE 4 BYTTES LONG\n*\n*        NO - 4, 6, 20, 22, 38, 41, 44, 213, 215, 216\n*        ENTERED FROM - LABEL, ITABCLEA, COB, BEGIN, BEG1,\n*                       PBLCKEND, FOR, PROCEDUR, ENDMISS\n*        EXITS TO COMPFIN\n*\nERR4     BAL   R12,ERROR1\n*\n*        COMPFIN\n*\n*        TERMINATING ERROR HAS BEEN FOUND\n*        SETS TERR IN COMPFLGS\n*        EXITS TO KOPOOLRL IN TERMINATION\n*\nCOMPFIN  OI    COMPFLGS,TERR           SET TERMINATING ERROR BIT\n         B     KOPOOLRL                EXIT TO TERMINATION\n*\n*        ERR5\n*\n*        ERR5A     E35  FROM BPRTAB, DISP IN TESTTABL\n*        ERR5      E2   FROM BPRTAB, DISP IN ARTABLE\n*        GENERATES ERROR PATTERN RETURNS TO TESTLOOP OR LIST\n*\nERR5A    LA    R6,PPARLST              GET PARAMETER FIELD\n         B     ERR5B\n*\nERR5     LA    R6,PONTPAR              GET PARAMETER FIELD\nERR5B    STM   R12,R15,ERRSAVE\n         BAL   R12,ERROR1              GENERATE PATTERN\n         LM    R12,R15,ERRSAVE\n         BR    R10                     RETURN TO TESTLOOP OR LIST\n*\nPPARLST  DC    X'0423'\nPONTPAR  DC    X'0402'                 E2\n*\n*        ERR6\n*\n*        GENERATES PATTERN FOR E6\n*        TESTS IF PROGRAM STARTED IF NOT, NO ERROR MESSAGE\n*        TEST IF IN COMMENT OR IDENTIFIER PROGRAM\n*        TAKES THE 6 CHARACTERS PRECEEDING THE FIRST QUOTE\n*        RETURNS TO APOSTROPHE PROGRAM TO TEST ON SECOND\n*        QUOTE\n*\nERR6     TM    BITS2,X'20'             FIRST BEGIN FOUND YET ?\n         BZ    TESTLOOP                NO\n         TM    FBYTE,X'FF'\n         BO    ENTRAPR                 INVALID IDENTIFIER\n         BZ    ERR6A                   COMMENT\n         LA    R1,1(,R1)\n         B     TPSPECER\n*\nERR6A    BCTR  R1,0\n         STM   R12,R15,ERRSAVE\n         BAL   R12,ERROR1\n         S     R1,KF6                  SUBTRACT 6\n         MVC   4(6,R15),0(R1)          MOVE OUT INFORMATION TO POOL\n         LA    R1,7(,R1)\n         LM    12,15,ERRSAVE\n         B     ENTRAPR                 RETURN TO TEST SECOND APOST\n*\n*        ERR7\n*\n*        TAKES CARE OF ALL SERIOUS AND WARNING MESSAGES THAT ARE\n*        4 BYTES LONG\n*\n*        ENTERED FROM -\n*        ERR1, IERSPEC, ARNAMSE, SWITCHNSE, PNAMESE, LABNAMER,\n*        CODE, SEMCO, ERR18 ERR23, CODE, SPEC, VALUE, VALDLB2,\n*        FIRSTBEG, ERR9, LABEL, PROCEDURE, SWITCH, COM\n*        1, 5, 8, 15, 17, 18, 23, 24, 25, 28, 29, 42, 43, 216\n*        RETURNS TO CALLING SEQUENCE\n*\nERR7     STM   R12,R15,ERRSAVE\n         BAL   R12,ERROR1              CREATE ENTRY\n         LM    R12,R15,ERRSAVE\n         B     2(,R6)\n*\n*        ERR8\n*\n*        GENERATES ERROR PATTERN E11 ONCE\n*\n*        IF FOUND DELIMITER IS COMMENT E18 IS GIVEN INSTEAD\n*        ENTERED FROM - TYPESPEC, STARTDEL\n*        EXITS TO TESTLOOP\n*\nERR8     TM    BITS3,E11BIT            MESSAGE ALLREADY GIVEN ONCE ?\n         LA    R1,1(,R1)               GET NEXT CHARACTER\n         BO    TESTLOOP                YES, RETURN\n         CLI   BCHAR,X'38'             COMMENT FOUND ?\n         BE    E18                     YES GENERATE E18 INSTEAD\n         OI    BITS3,E11BIT            SET E11BIT\n         BAL   R6,ERR7                 GENERATE E11 PATTERN\n*\n         DC    X'040B'\n*\n         B     E18A\n*\nE18      BAL   R6,ERR7\n*\n         DC    X'0412'\n*\nE18A     BR    R10                     RETURN\n*\n*        ERR9\n*\n*        GENERATE E9 PATTERN\n*\n*        ENTERED FROM - TED, END, READROUT\n*        EXITS TO EODADIN\n*\nERR9     BAL   R6,ERR7                 PROGRAM CONT AFTER LAST END\n*\n         DC    X'042B'\n*\n         B     EODADIN\n*\n*        ERROR10\n*\n*        GENERATES E10 PATTERN\n*\n*        INSERTS IN THE NOT SPECIFID PARAMETERS AN ALL PURPOSE\n*        IDENTIFIER\n*        RETURNS TO CALLING PROGRAM\n*\nERROR10  BAL   R6,ERR2B\n*\n         DC    X'000A'                 E10\n*\n         L     R6,LPBP\nFINDEMTY LA    R6,11(,R6)              GET FIRST PARAMETER\n         C     R6,AITL                 ALL PARAMETERS CHECKED ?\n         BER   R12                     WHEN ALL CHECKED RETURN\n         CLI   6(R6),0                 INSERT ALL PURPOSE IDENTIFIER\n         BNE   FINDEMTY                IN EMPTY INTERNAL NAMES\n         MVC   6(5,R6),ALLPUPOS\n         B     FINDEMTY\n*\nALLPUPOS DC    X'91FF010000'\n*\n*        ERR13\n*\n*        GENERATES E13 PATTERN\n*        PICKS UP THE DELIMITER FROM KEYWTAB\n*\nERR13    STM   12,15,ERRSAVE\n         LA    R12,5(,R14)             INCREASE TO GET WHOLE LENGTH\n         STC   R12,0(R6)\n         BAL   R12,ERROR1\n         L     R14,ERRSAVE+8           GET LENGTH OF DELIMITER\n         LA    R7,1(,R4)               GET START ADDR OF DELIMITER\n         EX    R14,ERRMOVE             MOVE DELIMITER TO ERROR PATTERN\n         LM    12,15,ERRSAVE\n         B     2(0,R6)                 RETURN\n*\n*        ERROR21\n*\n*        GENERATES E21 PATTERN\n*        PICKS UP DELIMITER FROM DELIMITER TABLE\n*        EXITS TO PROGRAM WHICH CALLED FOR BEG1\n*\nERROR21  STM   12,15,ERRSAVE\n         LA    R6,5(,R14)              INCREASE L TO GET WHOLE LENGTH\n         STC   R6,E21PAR\n         LA    R6,E21PAR\n         BAL   R12,ERROR1\n         L     R7,SAVE1                GET DEK FROM DELIMITER TABLE\n         L     R14,ERRSAVE+8           LENGTH FROM SAVEAREA\n         EX    R14,ERRMOVE             MOVE IN DEK IN ERROR MESSAGE\n         LA    R3,1(,R3)               SUBSTITUTE BEG1 DECREASION\n         LM    12,15,ERRSAVE           BEGIN WILL REMAIN COMPOUND\n         BR    R9                      RETURN\n*\nE21PAR   DC    X'0015'                 E21\n*\n*        ERROR1\n*\n*        CHECKS IF SPACE LEFT IN ERRORPOOL\n*        INSERTS LENGTH, SEMCNT, ERROR NUMBER\n*        RETURNS TO CALLIN ERROR PUTINE\n*\nERROR1   MVC   ERRMOD1+3(1),0(R6)      MOVES IN THE LENGTH AND\n         MVC   ERRMOD2+1(1),0(R6)      ERROR NUMBER IN THE FOLLOWING\n         MVC   ERRMOD3+1(1),1(R6)      INSTRUCTIONS\n         L     R15,NEXTERR\nERRMOD1  LA    R14,0(,R15)\n         C     R14,ENDPOOL             ROOM LEFT IN ERRORPOOL ?\n         BNH   *+8                     FOR THIS MESSAGE\n         B     ERR0                    NO, GENERATE E212\n*\n         L     R15,NEXTERR\n         ST    R14,NEXTERR             CORRECT NEXTERR POINTER\nERRMOD2  MVI   0(R15),0                MOVE IN LENGTH\nERRMOD3  MVI   1(R15),0                        ERRORNUMBER\n         MVC   2(2,R15),SEMCNT                 SEMICOLON COUNTER\n         LR    R14,R1                  MAKE R14 POINT TO SIX CHAR\n         SH    R14,KH7                 BEFORE CURRENT INPUT POINTER\n         BR    R12\n*\n*        ERROR2\n*\n*        FINDS FIRST NONZERO CHAR IN BUCKET, ITAB, IDBUCKET OR\n*        BUCKET\n*\nERROR2   LA    R2,5                    INITIALIZE R2 FOR THE LOOP\nERROR2A  STC   R2,ERRKCAL+3\nERRKCAL  CLI   0(R7),0                 LOOP TO FIND THE FIRST 0 CHAR\n         BNE   ERRKC01                 OR END OF EXTERNALNAME\n         BCT   R2,ERROR2A\nERRKC01  LA    R15,5(,R2)              INCREASE TO GET THE WHOLE\n         STC   R15,0(,R6)              ERROR MESSAGE LENGTH\n         BR    R12\n*\n         CNOP  0,4\nERRMOVE  MVC   4(1,R15),0(R7)\n*\nKH7      DC    X'0007'\n*\n*        IDCHECK1\n*\n*        CHECKS IDENTIFIER NAMES FOR ARRAY, PROCEDURE AND SWITCH\n*\n*        MOVES THE FIRST 6 CHARACTERS OF THE NAME TO ITAB AND THE\n*        OUTPUT\n*        RETURNS VIA R6 WHEN A CHARACTER IS FOUND THAT IS NOT\n*        LETTER, DIGIT, BLANK OR ZETA\n*\nIDCHECK1 BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVC   0(1,R3),0(R1)           MOVE OUT FIRST CHAR\n         LA    R3,1(,R3)\n         L     R7,AITL                 GET ITAB POINTER\n         MVC   0(1,R7),0(R1)           MOVE IN FIRST CHAR TO ITAB\n         LA    R7,1(,R7)\n         LA    R2,1                    INITIALIZE R2\n         LA    R9,IDCHECK3\nIDCHECK2 LA    R1,1(,R1)               GET NEXT CHAR\nIDCHECK3 CLI   0(R1),XFZETA            WHAT IS CHAR ?\n         BLR   R6                      NOT LETTER\n         BE    CIB                     ZETA\n         C     R2,KF6                  LETTER, 6 CHAR MOVED ALREADY ?\n         BE    IDCHECK2                YES, SKIP ADDITIONAL CHAR\n         BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVC   0(1,R3),0(R1)           MOVE CHAR TO OUTPUT\n         LA    R3,1(,R3)\n         MVC   0(1,R7),0(R1)           TO ITAB\n         LA    R7,1(,R7)               INCREASE\n         LA    R2,1(,R2)               POINTERS\n         B     IDCHECK2                GO AND CHECK NEXT CHAR\n*\n*        FINDSEMC\n*\n*        CHECKS FOR SEMICOLON OR POINT\n*        COMMA BLANKS AND I/P BUFFER CHANGE IS HANDLED\n*        IF SEMICOLON IS FOUND THE RETURN IS VIA R12 IF NOT\n*        THE RETURN IS VIA R6\n*\nFINDSEMA LA    R1,1(,R1)\nFINDSEMC LA    R9,*\n         CLI   0(R1),XFSCOLON          SEMICOLON ?\n         BE    0(,R12)                 YES, SEMICOLON FOUND\n         CLI   0(R1),XFPERIOD          POINT ?\n         BE    FINDCOMA                YES, LOOK FOR COMMA\n         CLI   0(R1),XFBLANK           BLANK ?\n         BE    FINDSEMA                YES, BACK TO START\n         CLI   0(R1),XFZETA\n         BE    CIB\n         BR    R6                      ERROR, NO SEMICOLON\n*\nFINDCOMA LA    R9,*+8\nFINDCOMB LA    R1,1(,R1)\n         CLI   0(R1),XFCOMMA           COMMA ?\n         BE    0(,R12)                 YES, SEMICOLON FOUND\n         CLI   0(R1),XFBLANK           BLANK ?\n         BE    FINDCOMB\n         CLI   0(R1),XFZETA\n         BE    CIB\n         BR    R6                      ERROR, NO SEMICOLON\n*\n*        ITABCLEA\n*\n*        CHECKS FOR ITAB OVERFLOW AND CLEARS THE NEXT ENTRY\n*\nITABCLEA L     R15,AITL\n         LA    R15,11(,R15)\nITABCLEC C     R15,ELI                 ROOM FOR ONE MORE ITAB ENTRY ?\n         BL    ITABCLEB\n         BAL   R6,ERR4\n*\n         DC    X'04D5'                 E213\n*\nITABCLEB LR    R7,R15                  INCREASE ITAB POINTERS\n         ST    R15,AITL\n         MVI   0(R15),0                CLEAR NEXT\n         MVC   1(10,R15),0(R15)        ITAB ENTRY\n         BR    R12                     RETURN\n*\n*        COB\n*\n*        CHECKS IF NEW O/P BUFFER IS NEEDED\n*\n*        ENTRY IS TO COBSPEC IF TWO OR MORE CONTINIOUS BYTES ARE\n*        NEEDED\n*        THE CHANGE OF ADDR BETWEEN THE TWO BUFFERS IS DONE\n*        WITH DISP. DISP IS EITHER 0 OR 4 SO ADDARI+DISP WILL\n*        PICK UP EITHER ADDARI OR THE ADDR OF THE ALTERNATE\n*        O/P BUFFER\n*        WADDARI POINTS TO THE FIRST BYTE OF THE CURRENT O/P\n*        BUFFER\n*        R3 IS THE CURRENT O/P POINTER\n*        APE POINTS TO THE LAST BYTE OF THE CORRENT BUFFER\n*        ONC CONTAINS THE CURRENT O/P RECORD NUMBER\n*        ZETA IS THE BUFFER END INDICATION\n*\nCOBSPEC  C     R0,APE                  SPACE LEFT FOR X MORE BYTES ?\n         BLR   R12                     YES, RETURN\n         B     COBSPEB                 NO CHANGE OUTPUT BUFFER FIRST\n*\nCOB      C     R3,APE                  SPACE LEFT FOR ONE MORE BYTE ?\n         BLR   R12                     YES, RETURN\nCOBSPEB  MVI   0(R3),XFZETA            MOVE ZETA TO O/P BUFFER\n         STM   R14,R2,SAVE1            SAVE REGISTERS\n         ST    R6,SAVE1+24\n         CLI   ONC,255                 ALREADY 256 OUTPUT RECORDS ?\n         BL    COBSPED                 NO, BYPASS ERROR MSG\n         BAL   R6,ERR4                 YES, TERMINATE COMPILATION\n*\n         DC    X'04D7'                 E215\n*\nCOBSPED  L     R3,WADDARI              LOAD ADDR OF CURRENT O/P REC\n         LA    R6,SYSUT1               R6 -> SYSUT1 DCB ADDR\n         CLI   ONC,0                   FIRST OUTPUT RECORD ?\n         BE    WRITEOB                 YES, SKIP CHECK\n*\n         CHECK ODECB                   CHECK IF BEFORE LAST RECORD IS\n*                                      WRITTEN\nWRITEOB  WRITE ODECB,SF,(R6),(R3)\n*\n         XI    DISP,X'04'              CHANGE ADDR DISPLACEMENT\n         IC    R2,DISP\n         L     R3,ADDARI(R2)           COMPUTE VALID O/P BUFFER ADDR\n         ST    R3,WADDARI              STORE IN WADDARI\n         LR    R14,R3                  COMPUTE ADDR OF LAST BYTE IN\n         A     R14,SRCE1S              THE NEW OUTPUT AREA\n         BCTR  R14,0\n         ST    R14,APE                 SAVE IN APE\n         IC    R2,ONC                  INCREASE OUTPUT RECORD COUNTER\n         LA    R2,1(,R2)\n         STC   R2,ONC\n         L     R6,SAVE1+24\n         LM    R14,R2,SAVE1\n         BR    R12                      RETURN TO CALLING SEQUENCE\n*\n*        CIB\n*\n*        GET NEXT RECORD AND PRINTS IT WITH THE SEMICOLON COUNTER\n*\n*        IF ISO CODE IS SPECIFIED A TRANSLATION IS FIRST MADE TO\n*        EBCDIC\n*        THE RECORD IS TRANSLATED AND THE RECORD END INDICATION\n*        ZETA IS INSERTED\n*\nCIB      STM   R14,R2,SAVE1            SAVE REGS\n         SH    R1,KH7                  MOVE SEVEN CHAR INFRONT\n         MVC   WABEFOR(7),0(R1)        OF WORKAREA\n         TM    COMPFLGS+1,NSRCE        NOSOURCE SPECIFIED ?\n         BO    GETREC                  YES, SKIP PRINTING\n         L     R15,PRTRTADD            PRINT\n         BALR  R14,R15\n         ST    R1,APRNTAR              SAVE NEW PRINT BUFFER ADDR\nGETREC   L     R1,ASYSDCB              R1 -> SYSIN DCB ADDR\n*\n         GET   (1),WA                  GET NEXT RECORD\n*\nTESTISO  TM    COMPFLGS+1,ISO          ISO INPUT ?\n         BO    ISOTRANS                YES, TRANSLATE ISO TO EBCDIC\n         L     R1,APRNTAR\n         TM    COMPFLGS+1,NSRCE        NOSOURCE SPECIFIED ?\n         BO    NOPRINT                 YES, MOVE TO DUMMY PRINTAREA\n         LH    R15,SEMCNT              CONVERT SEMICOLON COUNTER\n         CVD   R15,DOUBLE\n         MVC   0(L'SCPATTN,R1),SCPATTN  MOVE IN SEMICOLON COUNT PATTERN\n         ED    0(L'SCPATTN,R1),DOUBLE+5  FORMAT SEMICOLON COUNT\n         MVC   10(80,R1),WA            MOVE RECORD TO PRINT BUFFER\n         B     PRNTREC\n*\nNOPRINT  MVC   SAVEPRNT+8(72),WA       IF NSRCE MOVE WA TO DUMMY PRINT\nPRNTREC  LM    R14,R2,SAVE1\n         LA    R1,WA                   SET INPUT POINTER\n         TR    WA(72),TREXTINT         TRANSLATE RECORD\n         MVI   72(R1),XFZETA           MOVE RECORD END IDENTIFIER\n         BR    R9                      RETURN\n*\nISOTRANS ST    R6,SAVE1+24\n         LA    R6,WA                   GET START OF WA\n         LA    R15,79(,R6)             GET END OF WA\nLOOP     CLI   0(R6),X'4C'             )\n         BE    IRPAR\n         CLI   0(R6),X'7B'             =\n         BE    IEQUAL\n         CLI   0(R6),X'7C'             '\n         BE    IAPOST\n         CLI   0(R6),X'6C'             (\n         BE    ILPAR\n         CLI   0(R6),X'50'             +\n         BNE   LOOPEND\n         MVI   0(R6),X'4E'             +\n         B     LOOPEND\n*\nIRPAR    MVI   0(R6),X'5D'             )\n         B     LOOPEND\n*\nIEQUAL   MVI   0(R6),X'7E'             =\n         B     LOOPEND\n*\nIAPOST   MVI   0(R6),X'7D'             '\n         B     LOOPEND\n*\nILPAR    MVI   0(R6),X'4D'             (\nLOOPEND  LA    R6,1(,R6)\n         CR    R6,R15                  ALL CHAR CHECKED IN WA ?\n         BNH   LOOP                    NO, CHECK NEXT\n         L     R6,SAVE1+24             YES, RETURN\n         B     TESTISO+8\n*\n*        DELTMIT\n*\n*        TWO QUOTES HAVE BEEN FOUND\n*\n*        IT IS CHECKED THAT THE LENGTH IS NOT ZERO OR EXCEED THE\n*        MAXIMUM LIMIT FOR A DELIMITER (10 CHARACTERS)\n*        R4 POINTS TO THE FIRST AND R1 TO THE LAST QUOTE\n*        THE LENGTH IS USED TO GET A DISPLACEMENT FROM THE KWLUTAB\n*        FOR A SECTION IN THE KEYWTAB. A SECTION IN THE KEYWTAB\n*        CONTAINS ALL DELIMITERS OF THE SAME LENGTH.\n*        1. THE FIRST BYTE IN EACH SECTION SAYS HOW MANY ENTRIES\n*           THERE ARE IN THE SECTION. THEREAFTER A DELIMITER PLUS 3\n*           BYTES OF INTERNAL CODE MAKES A SUBSECTION.\n*        2. THE FIRST 2 BYTES OF THE INTERNAL CODE IS\n*           CHARECTERISTCS FOR THE DELIMITER.\n*        3. THE THIRD BYTE IS A DISPLACEMENT TO THE DELPRGTB,\n*           WHERE THE ADDR IS PICKED UP TO THE PROGRAM TO HANDLE\n*           THE DELIMITER.\n*        A CHECK IS MADE WHEN A DELIMITER IS FOUND IF IT IS THE\n*        FIRST FOUND IN THE PROGRAM. THE EXIT IS THEN TO\n*        STARTDEL. THE TEST IS ON BITS2 X'20'. IF NO DELIMITER IS\n*        FOUND THE EXIT IS TO THE EROUT PROGRAM.\n*        FBYTE - SWITCH -\n*        1. THE FBYTE IS FF IF AN APOSTROPHE IS FOUND IN THE\n*           COMMENT PROGRAM\n*        2. THE FBYTE IS F0 IF AN APOSTROPHE IS FOUND IN THE TYPE\n*           PROGRAM INSTEAD OF THE FIRST CHARACTER OF THE NAME\n*        3. OTHERWISE IT IS 00\n*\nDELIMIT  SR    R15,R15\n         LR    R14,R1\n         BCTR  R14,0\n         SR    R14,R4                  COMPUTE LENGTH OF KEYWORD\n         BP    DELIM01                 > ZERO ?\n         BAL   R6,ERR6                 ZERO, ERROR\n*\n         DC    X'0A0C'                 E12 DELETE FIRST APOSTROPHE\n*\nDELIM01  C     R14,KF11                LIMIT EXEEDED ALREADY ?\n         BH    EROUT                   BRANCH TO ERROR ROUTINE\n         BCTR  R14,0\n         LA    R9,KWLUTAB\n         TM    FBYTE,X'FF'             TEST FBYTE\n         BO    COMSPEC\n         BM    TYPESPEC\n         SLA   R14,2                   START OF LOOKUP STRING\n         L     R9,0(R14,R9)\n         IC    R15,0(,R9)              NUMBER OF ENTRIES IN THIS SECT\n         LA    R9,1(,R9)               AND ADDR OF FIRST WORD ENTRY\n         SRA   R14,2(0)\nCLCLOOP  EX    R14,EXCLC               DELIMITER FOUND ?\n         BNE   NOMATCH                 NO, TRY NEXT IN SAME SECTION\n         IC    R2,3(R14,R9)            YES, MATCH\n         TM    BITS2,X'20'             PROGRAM STARTED YET ?\n         BO    DELIM02                 YES\n         B     STARTDEL                NO, CHECK FOR CORRECT START\n*\nDELIM02  L     R6,DELPRGTB(R2)         BRANCH TO APPROPRIATE SUBPGM\n         BR    R6                      DEPENDING ON DISP IN KEYWTAB\n*\nNOMATCH  LA    R9,4(R14,R9)            GET NEXT DELIMITER\n         BCT   R15,CLCLOOP             ANY DELIMITERS LEFT TO CHECK ?\n         B     EROUT                   BRANCH TO ERROR ROUTINE\n*\nEXCLC    CLC   1(1,R4),0(R9)           EXECUTED INSTRUCTION\n*\n*        EROUT\n*\n*        CHECKS ALL SECTIONS OF THE KEYWTAB FOR AN EQUAL DELIMITER\n*        TO THE ONE IN I/P, DISREGARDING LENGTH\n*\n*        IF NO EQUAL FOUND E14 IS GENERATED AND THE FIRST\n*        APOSTROPHE IS DELETED. EXIT IS THEN TO TEST.\n*        IF AN EQUAL IS FOUND E13 IS GENERATED AND AN BRANCH IS\n*        TAKEN TO THE APPROPRIATE SUBPROGRAM\n*\nEROUT    TM    FBYTE,X'FF'\n         BM    TYPESPEC                INVALID IDENTIFIER\n         BO    COMCEE2                 COMMENT\nEROUTOK  LA    R2,10                   GO THROUGH ALL POSSIBILITIES\n         SR    R15,R15                 ZERO R14, R15\n         SR    R14,R14\nEROUT2   SLA   R14,2\n         LA    R9,KWLUTAB\n         L     R9,0(R14,R9)            GET SECTION IN KEYWTAB\n         IC    R15,0(,R9)              NUMBER OF ENTRIES IN STRING\n         LA    R9,1(,R9)               FIRST ENTRY\n         SRA   R14,2\nCLCERR   EX    R14,EXCLC               DELIMITER FOUND ?\n         BNE   EROUT3                  NO\n         TM    BITS2,STARTBIT          YES, PROGRAM STARTED YET ?\n         BZ    STARTDEL                NO, CHECK FOR A CORRECT START\n         BAL   R6,ERR13\n*\n         DC    X'000D'                 E13\n*\n         LA    R1,1(R14,R4)            SET R1 TO ONE BEYOND DELIMITER\n         IC    R2,3(R14,R9)            GET DISPLACEMENT OF PROGRAM\n         L     R6,DELPRGTB(R2)         IN DELPRGTB\n         BR    R6                      BRANCH TO PROGRAM\n*\nEROUT3   LA    R9,4(R14,R9)            NOW GET NEXT DELIMITER\n         BCT   R15,CLCERR              ALL DEL IN STRING CHECKED ?\n         LA    R14,1(,R14)             YES, GET NEXT STRING\n         BCT   R2,EROUT2\n         TM    BITS2,X'20'             PROGRAM STARTED YET ?\n         BZ    TESTLOOP                NO, RETURN TO MAINLOOP SCANNING\n         BAL   R6,ERR2C\n*\n         DC    X'0A0E'                 E14\n*\n         LA    R1,1(,R4)               GET NEXT CHAR\n         BR    R10                     RETURN\n*\n*        TYPESPEC\n*\n*        'REAL'' OR 'INTEGER'' OR 'BOOLEAN'' HAS BEEN FOUND\n*\n*        THE ONLY VALID DELIMITERS ARE AT THIS POINT ARRAY OR\n*        PROCEDURE\n*\nTYPESPEC CLC   1(L'KWPROC,R4),KWPROC   PROCEDURE ?\n         BE    TYPPROC                 YES\n         TM    BITS2,X'20'             PROGRAM STARTED YET ?\n         BZ    ERR8                    NO, GENERATE E11\n         CLC   1(L'KWARRAY,R4),KWARRAY  ARRAY ?\n         BE    TYPEARRY                YES\n*                                      INVALID IDENTIFIER HAS BEEN\n*                                      FOUND GOTO IER SPEC\nTPSPECER TM    BITS1,X'40'             SPECIFICATION ?\n         BO    TPSPEC01\n         LA    R15,TYPEDAFI            NO, SET RETURN TO TYPE PGM\n         B     IERSPEC\n*\nTPSPEC01 LA    R15,IDCHECK             YES, SET RETURN TO IDCHECK\n         B     IERSPEC\n*\n*        COMSPEC\n*\n*        TWO APOSTROPHES HAVE BEEN FOUND IN A COMMENT\n*\n*        VALID DELIMITERS TO END A COMMENT ARE END OR ELSE\n*\nCOMSPEC  LA    R9,KWELSE\n         CLC   1(L'KWELSE,R4),KWELSE   COMMENT ENDING WITH ELSE ?\n         BNE   COMSPECN                NO\n         C     R14,KF3                 YES, CHECK CORRECT LENGTH\n         BE    TED                     ELSE\n         B     ENTRAPR                 R10 TO FIND ANOTHER QUOTE\n*\nCOMSPECN CLC   1(L'KWEND,R4),KWEND     COMMENT ENDED WITH END ?\n         BNE   ENTRAPR                 NO, R10 TO FIND ANOTHER QUOTE\n         C     R14,KF2                 YES, CHECK CORRECT LENGTH\n         BE    END                     END\n         B     ENTRAPR                 R10 TO FIND ANOTHER QUOTE\n*\n*        STARTDEL\n*\n*        THE ONLY VALID DELIMITERS TO START A PROGRAM IS BEGIN\n*        OR IF PRECOMPILED PROCEDURE IS SPECIFIED PROCEDURE OR\n*        TYPE PROCEDURE\n*\nSTARTDEL STC   R2,BCHAR                GET DELIMITERS CHARACTERISTIC\n*                                      FROM KEYWTAB\n         CLI   BCHAR,X'24'             BEGIN FOUND ?\n         BE    FIRSTBEG                YES\n         TM    COMPFLGS,PROC           PRECOMPILED SPECIFIED ?\n         BZ    ERR8                    NO, GENERATE E11\n         CLI   BCHAR,X'3C'             FOUND WORD IS PROCEDURE ?\n         BNE   TYPEPR01                NO\n         B     PROCEDUR                YES\n*\nTYPEPR01 CLI   BCHAR,X'18'             TYPE FOUND ?\n         BNE   ERR8                    NO\nTYPEPREC LA    R1,1(,R1)               LOOK FOR QUOTE TYPE PROC\nTYPEPREA CLI   0(R1),XFQUOTE           QUOTE FOUND ?\n         BNE   TYPEPR02                NO, BRANCH\n         BCTR  R1,0                    YES, DECREASE TO LET TYPE PGM\n         B     TYPE                    FIND THE QUOTE AGAIN\n*\nTYPEPR02 CLI   0(R1),XFBLANK           BLANK ?\n         BE    TYPEPREC\n         CLI   0(R1),XFZETA            ZETA ?\n         BNE   ERR8                    NEITHER, GENERATE E11\n         ST    R9,SAVE1+20             CHANGE I/P AND LOOK AGAIN\n         BAL   R9,CIB\n         L     R9,SAVE1+20\n         B     TYPEPREA\n*\n*        NORMAL\n*\n*        INSERTS IN THE O/P THE INTERNAL CODE FROM KEYWTAB\n*\nNORMAL   BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         LA    R9,1(R14,R9)            COMPUTE ADDR OF CODE\n         MVC   0(1,R3),0(R9)           MOVE CODE TO OUTPUT BUFFER\n         LA    R3,1(,R3)               INCREASE OUTPUT AND\n         LA    R1,1(,R1)               INPUT POINTERS\n         BR    R10\n*\n*        BOLCON\n*\n*        MOVES OUT SIX BYTES OF INTERNAL CODE FOR FALSE OR TRUE\n*\nBOLCON   LA    R0,6(,R3)\n         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P\n         MVC   0(5,R3),INT             TRANSFER FIRST PART\n*                                      OF INTERNAL NAME\n         LA    R7,1(R14,R9)            AND\n         MVC   5(1,R3),0(R7)           LAST PART\n         LA    R3,6(,R3)               INCR OUTPUT POINTER\n         LA    R1,1(,R1)               INCR INPUT POINTERS\n         BR    R10\n*\n*        GIF\n*\n*        TRANSFERS INTERNAL CODE BYTE AND EXITS TO THE STATEMENT\n*        PROGRAM TO CHECK IF A PROCEDURE BOBY HAS STARTED\n*\nGIF      BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         LA    R7,1(R14,R9)            TRANSFER INTERNAL CODE\n         MVC   0(1,R3),0(R7)\n         LA    R3,1(,R3)               INCR OUTPUT POINTER\n         LA    R1,1(,R1)               INCR INPUT POINTER\n         B     STATE                   BRANCH TO STATEMENT PROGRAM\n*\n*        TED\n*\n*        TRANSFERS INTERNAL CODE\n*        SETS POSSIBLE LABEL POINTERS\n*\nTED      TM    BITS2,ENDBIT            ELSE ENDED FINAL END COMMENT ?\n         BO    ERR9                    YES\n         BAL   R12,COB\n         LA    R9,1(R14,R9)\n         MVC   0(1,R3),0(R9)           TRANSFER INTERNAL CODE\n         ST    R3,OPIN                 SET LABEL POINTERS\n         MVC   OPIN+4(1),ONC\n         MVC   OPINCHAR(1),0(R9)\n         LA    R3,1(,R3)\n         ST    R3,LAPIN\n         LA    R1,1(,R1)\n         NI    BITS2,X'FE'             SET ENDELSE BIT TO ZERO\n         BR    R10\n*\n*        BEGIN\n*\n*        TEST IF PROC IN STACK\n*\n*        TRANSFERS 'BEGIN' TO OUTPUT AND STACK\n*        SETS OPIN, OPIN+4, LAPIN, BEGBIT\n*        BEGBIT IS USED TO DISTINGUISH BETWEEN COMPOUND BEGIN\n*        AND BLOCK BEGIN. IF A DECLARATION IS FOUND WHEN THE\n*        BEGBIT IS ON IT'S A BLOCK BEGIN THE BEGBIT IS TURNED OF\n*        BY THE STATEMENT PROGRAM AND THE BEG1 PROGRAM\n*\nBEGIN    L     R15,SP\n         CLI   0(R15),X'0C'            PROC IN STACK ?\n         BE    BEGPROC                 YES, BRANCH TO PROC PROCESSING\n         LA    R0,4(,R3)\n         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P\n         MVI   0(R3),X'0C'             TRANSFER BEGIN TO O/P\n         MVI   OPINCHAR,X'0C'          SET LABELSAVE\n         ST    R3,OPIN                 NOTE ITS POSITION IN OPIN AND\n         MVC   OPIN+4(1),ONC           THE NUMBER OF THE OUTPUT BUFFER\n         LA    R3,1(,R3)               INCREASE OUTPUT POINTER\n         ST    R3,LAPIN                NOTE WHERE LABEL MAY START\n         OI    BITS1,X'80'             BEGBIT.= 1\n         LA    R15,1(,R15)             INCR STACK POINTER\n         C     R15,ATOPSTAK\n         BL    BEGINAA\n         BAL   R6,ERR4                 STACK OVERFLOW\n*\n         DC    X'0414'                 E20\n*\nBEGINAA  MVI   0(R15),X'08'            PUT BEGIN IN STACK\n         ST    R15,SP\nBEGINAB  LA    R1,1(,R1)\n         B     TESTLOOP\n*\n*        BEGPROC\n*\n*        PROCEDURE - SPECIFICATIONS - BEGIN HAS BEEN FOUND\n*\n*        PROC BODY IS TO COME. PROC IS CHANGED TO PROC*\n*        ITS CHECKED THAT ALL PARAMETERS HAVE BEEN SPECIFIED\n*        THE RETURN IS TO TEST VIA THE BEGIN PROGRAM\n*\nBEGPROC  MVI   0(R15),X'10'            CONVERT PROC INTO PROC*\n         NI    BITS1,X'BF'             PROBIT=0\n         CLI   PZ,0                    ALL PARAMETERS SPECIFIED ?\n         BE    BEGINAB                 YES\n         BAL   R12,ERROR10             NO, GENERATE E11\n         B     BEGINAB\n*\n*        FIRSTBEG\n*\n*        THE FIRST BEGIN IS CONSIDERED AS A BLOCK BEGIN\n*        THE START BIT IS TURNED OFF\n*        THE BEG1 PROGRAM IS JOINED\n*        IF PRECOMPILED PROCEDURE HAS BEEN SPECIFID E42 IS GIVEN\n*        AS A WARNING AND THE BEGIN IS DISREGARDED\n*\nFIRSTBEG TM    COMPFLGS,PROC           PRECOMPILED PROCEDURE ?\n         BZ    FIRSTB01                NO, BRANCH\n         BAL   R6,ERR7                 YES, GIVE WARNING MESSAGE\n*\n         DC    X'042A'\n*\n         LA    R1,1(,R1)               DISREGARD THE BEGIN\n         B     TESTLOOP\n*\nFIRSTB01 OI    BITS2,X'20'             NO, TURN STARTBIT OFF\n         LA    R9,TESTLOOP             MAKE RETURN FROM BEGI BE TEST\n         LA    R1,1(,R1)\n         B     BEG1FRST                FIRST BEGIN = BLOCK BEGIN\n*\n*        BEGI\n*\n*        BLOCK BEGIN PROGRAM\n*\n*        CHANGES BEGIN TO BETA IN STACK AND OUTPUT\n*        INCREASES ITAB GROUP NUMBER AND PROGRAM BLOCK NUMBER\n*        ENTRIES ARE MADE IN -\n*        GROUPTABEL\n*        SURROUNDING BLOCKS IG. NR\n*        PBTAB1\n*        SURROUNDING PBN\n*        SCTAB - CURRENTSC COUNTER\n*        ITAB\n*        ADDRS OF SURROUNDING BLOCK AND IG HEAD ENTRIES, NEW\n*        PBN AND IGN\n*        LPBP (ADDR OF CURRENT PROGRAM BLOCK HEAD ENTRY)\n*        AND\n*        LIGP (ADDR OF CURRENT ITAB GROUP HEAD ENTRY)\n*        ARE UPDATED\n*        PUTS BETA + NEW PBN AND IGN TO OUTPUT REC.\n*\nBEG1     BCTR  R3,0\n         NI    BITS1,BEGOFF            BEGBIT 0\n         CLI   0(R3),X'0C'             BEGIN IN O/P ?\n         BNE   ERROR21                 NO, DECLARATION INCORRECT PLACE\nBEG1FRST MVI   0(R3),X'0D'             MOVE BETA TO O/P\n         L     R15,SP                  AND\n         MVI   0(R15),X'04'            STACK\n         SR    R6,R6\n         LH    R6,IGC\n         LA    R6,1(,R6)               INCREASE ITAB GROUP NUMBER\n         STH   R6,IGC\n         AR    R6,R6                   ENTRY IS TO GO INTO\n         AH    R6,IGC                  A(GT)+3*(IGC)\n         A     R6,AGT\n         L     R7,LIGP\n         MVC   0(2,R6),8(R7)           ENTRY INTO GROUPTABLE\n         MVI   2(R6),0\n         NI    0(R6),X'7F'             CLEAR POSSIBLE PHI IND\n         CLI   PBC,255                 MORE THAN 255 BLOCKS ?\n         BNE   BEG1FAAA\n         BAL   R6,ERR4\n*\n         DC    X'0416'                 E22\n*\nBEG1FAAA IC    R2,PBC\n         LA    R2,1(,R2)               INCR PROGRAM BLOCK NUMBER\n         STC   R2,PBC\n         L     R7,LPBP\n         LA    R6,PBTAB1\n         AR    R6,R2\n         MVC   0(1,R6),10(R7)          ENTRY INTO PROGRAM BLOCK TABLE\n         STC   R2,1(,R3)               TRANSFER PBN TO O/P\n         AR    R2,R2                   MAKE ENTRY OF CURRENT\n         LA    R6,SCTAB(R2)            SEMCNT COUNTER IN SCTAB\n         MVC   0(2,R6),SEMCNT\n         MVC   2(2,R3),IGC             IGN IN OUTPUT BUFFER\n         LA    R3,4(,R3)\n         ST    R3,LAPIN                SET LABEL POINTERS\n         L     R15,AITL                MAKE BLOCK HEAD IN ITAB\n         MVC   0(4,R15),LIGP\n         MVC   4(4,R15),LPBP\n         MVC   8(2,R15),IGC\n         MVC   10(1,R15),PBC\n         ST    R15,LPBP                UPDATE LIGP AND LPBP\n         ST    R15,LIGP\n         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY\n         BR    R9\n*\n*        END\n*\n*        ACTION DEPENDS ON WHAT IS IN THE STACK\n*\n*        TURNS IN ALL CASES OFF THE DELTABIT AND THE END ELSE\n*        BIT\n*        GENERAL RETURN POINT IS CSPEND IF RETURN ADDR, IN\n*        R4, IS NOT CHANGED\n*        FINAL RETURN IS TO TEST VIA SEMCO OR COMMENT PROGRAM\n*        PROC** IN STACK ACTIVATES PBLOCKEND AND RETURNS TO END\n*        TO INSPECT THE STACK AGAIN\n*\nEND      NI    BITS1,X'DF'             DELTABIT.=0\n         TM    BITS2,ENDBIT            END FINISHED FINAL END COMMENT ?\n         BO    ERR9                    YES\n         NI    BITS2,X'FE'             SET ENDELSE BIT TO ZERO\nCSPEND   LA    R4,*                    RETURN FOR PBLCKEND, FOREND\n         L     R15,SP\n         IC    R2,0(,R15)              BRANCH\n         L     R6,PROG1(R2)            DEPENDING ON TOP BYTE\n         BR    R6                      OF THE STACK\n*\nPROG1    DC    A(ERR8)                 +00 E11 IF ALPHA\n         DC    A(BLOCKEND)             +04 BETA\n         DC    A(COMPDEND)             +08 BEGIN\n         DC    A(PREND)                +12 PROC\n         DC    A(STAREND)              +16 PROC*\n         DC    A(PBLCKEND)             +20\n         DC    A(FOREND)               +24 FOR\n*\n*        STAREND\n*\n*        PROC* HAS ENDED\n*\n*        ACTIVATES THE PBLOCK END PROGRAM AND RETURNS AFTERWARDS\n*        TO TEST VIA COMMENT PROGRAM\n*\nSTAREND  OI    BITS1,X'20'             DELTABIT= 1\n         LA    R4,COMMEND              LOAD ADDR OF END ENTRY\n*                                      INTO COMMENT PROGRAM\n         B     PBLCKEND\n*\n*        PREND\n*        PROC HAS ENDED\n*\n*        CHECKS IF ALL PARAMETERS SPECIFIED.\n*        TURNS OFF THE PROBIT.\n*        A PROC THAT ENDS WITH 'END' IS NOT CORRECTED, THEREFORE\n*        THE STACK IS AGAIN INSPECTED AFTER THE PBLOCKEND PROGRAM\n*        HAS BEEN ACTIVATED\n*\nPREND    NI    BITS1,X'BF'             PROBIT.=0\n         CLI   PZ,0                    ALL PARAMETERS SPECIFIED ?\n         BE    PBLCKEND                YES, ACTIVATE PBLCKEND\n         BAL   R12,ERROR10             NO, GENERATE E10 FIRST\n         B     PBLCKEND\n*\n*        COMPDEND\n*\n*        A COMPOUND STATMENT HAS ENDED\n*\n*        TRANSFERS END '2C' TO OUTPUT AND RELEASES BEGIN IN\n*        STACK.\n*        THEN IT CHECKS IF THE END OF THIS COMPOUND STATEMENT\n*        INDICATES THE END OF ANY FOR STATMENT(S) OR PROC**.\n*        THIS IS DONE WITH BITS2 X'01' AND THE COMMENT PROGRAM.\n*        IF THE END IS FOLLOWED BY A ., OR 'END' THE STACK IS\n*        INSPECTED AGAIN.\n*        IF THE END IS FOLLOWED BY AN 'ELSE' THE COMPOUND\n*        STATMENT ITSELF IS ALL THAT HAS ENDED AT THIS POINT.\n*\nCOMPDEND BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVI   0(R3),XFEND             TRANSFER END TO OUTPUT BUFFER\n         LA    R3,1(,R3)               INCR OUTPUT POINTER\n         L     R15,SP                  RELEASE BEGIN IN\n         BCTR  R15,0                   STACK\n         ST    R15,SP\nCOMPENDI CLI   0(R15),X'00'            ALPHA IN STACK ?\n         BE    PGMEND                  YES, LOGICAL PROGRAM END\n         CLI   0(R15),X'14'            PROC** ?\n         BL    COMMEND                 BRANCH TO COM-PROGRAM, END-ENTRY\n*                                      FOR BEGIN OR BETA OR PROC*\n*                                      IN STACK\n         OI    BITS2,X'01'             SET END-ELSE BIT\n         B     COMMEND                 CHECK HOW END COMMENT ENDS\n*                                      DCOMMENT ENDED WITH A SEMICOLON\nCOMPEND2 NI    BITS2,X'FE'             RESET END ELSE BIT\n         L     R15,SP                  INSPECT STACK AGAIN\n         CLI   0(R15),X'14'            PROC** OR FOR IN STACK ?\n         BE    COMPEND3                PROC**\n         LA    R4,COMPEND4             FOR GOTO FORENS AND THEN\n         B     FOREND                  TEST AGAIN - COMPEND4\n*\nCOMPEND3 OI    BITS1,X'20'             PROC**- SET DELTABIT\n         LA    R4,SEMCO                RETURN FROM PBLCKEND\n         B     PBLCKEND                BLOCKEND FOR PROC**\n*\nCOMPEND4 CLI   0(R15),X'14'            PROC**,FOR OR SE ?\n         BE    COMPEND3                PROC**\n         BH    FOREND                  FOR\n         B     SEMCO                   SOMETHING ELSE\n*\n*        BLOCKEND\n*\n*        A BETA BLOCK HAS ENDED\n*\n*        THE RETURN AFTER THE PBLOCKEND PROGRAM IS TO THE\n*        COMPENDI TO CHECK IF SOME MORE ITAB GROUP SHOULD END AT\n*        THIS POINT\n*\nBLOCKEND BAL   R4,PBLCKEND             EXECUTE PROGRAM BLOCKEND\n         B     COMPENDI\n*\n*        FOREND\n*\n*        CORRECTS THE LIGP POINTER\n*\n*        INSERTS A CONTINUATION LINE IN ITAB IF THE FORSTATMENT\n*        CONTAINED ANY LABEL.\n*        IF THE FORSTATMENT DID NOT CONTAIN ANY DEKLARATIONS THE\n*        PREVIOUSC CREATED FOR HEADENTRY IS ERASED.\n*        IF ONE CONTINUATION LINE IS CREATED, FOLLOWING\n*        ENCLOSING FORSTATEMENTS WILL OVERLAY THE FIRST\n*        CONTINUATION LINE, IF LABELS OR NOT ETA AND SURROVNDING\n*        ITABGROUPS IG NR. IS MOVED TO THE OUTPUT\n*        FOR IS RELEASED IN THE STACK\n*\n*        ENTERED FROM SEMCO, END\n*        EXITS TO END, COMPEND4, STACKTST (IN SEMCO)\n*\nFOREND   L     R6,LIGP\n         MVC   LIGP(4),0(R6)           GET PREVIOUS LIGP HEAD\n         L     R15,AITL                CURRENT ENTRY\n         S     R15,KF11                MINUS ELEVEN\n         TM    6(R15),X'FF'            CONTINUATION LINE NEEDED ?\n         BZ    EMPTYFOR                NO\n         BO    FORENDAA                OVERLAY PREVIOUS CONT LINE\n         LA    R15,11(,R15)            CREATE NEW CONT LINE\nFORENDAA L     R6,LIGP\n         MVC   8(2,R15),8(R6)          COPY IG NUMBER\n         MVI   6(R15),X'FF'            CONTINUATION LINE INDICATOR\n         NI    8(R15),X'7F'            CLEAR POSSIBLE PHI INDICATOR\n         MVI   5(R15),XFBLANK\n         BAL   R12,ITABCLEA+4          CLEAR NEXT ENTRY\n         B     EMPTYFAA\n*\nEMPTYFOR BAL   R12,ITABCLEC            CLEAR FORHEAD FOR EMPTY FORGROUP\nEMPTYFAA LA    R0,3(,R3)\n         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P\n         MVI   0(R3),XFBLANK           INSERT ETA\n         L     R6,LIGP\n         MVC   1(2,R3),8(R6)           AND CURRENT IGN IN OUTPUT BUFFER\n         NI    1(R3),X'7F'             CLEAR EVENTUALLY PHI\n         LA    R3,3(,R3)\n         L     R15,SP                  RELEASE FOR IN STACK\n         BCTR  R15,0\n         ST    R15,SP\n         BR    R4                      RETURN\n*\n*        PBLCKEND\n*\n*        ERASES EMPTY CONTINUATION LINES\n*        WRITES OUT THE PROGRAM BLOCK TO SYSUT3\n*        LENGTH IS CALCULATED AND SAVED IN ITABLEN AND STORED IN\n*        THE FIRST TWO BYTES OF THE ITAB RECORD\n*        SEMCNT IS PICKED UP FROM SCTAB AND ENTERED IN BYTES 6+7\n*        THE BLOCK IS MOVED TO THE ITAB BUFFER WHERE IT\n*        IS WRITTEN OUT\n*        THE SURROUNDING BLOCKS NEW DECLARATIONS WILL BE\n*        OVERLAYING THE OUTWRITTEN RECORD\n*        AITL WILL POINT TO THE HEADENTRY'S PLACE OF THE BLOCK\n*        WHICH NOW WAS WRITTEN OUT\n*        LPBP TO THE SURROUNDING BLOCKS HEADENTRY\n*        LIGP TO THE SURROUNDING ITABGROUPS HEADENTRY\n*        AITL, LPBP AND LIGP WILL BE MODIFIED ACCORDINLY\n*        EPSILON, THE SURROUNDING BLOCKS PBN AND IGN WILL BE PUT\n*        TO THE OUTPUT\n*        THE BLOCK INDICATOR IN THE STACK WILL BE RELEASED IF\n*        STACK NOW IS EMPTY - ALPHA IN STACK - PGMEND WILL SET\n*        THE END BIT AND CHANGE END OF DATA EXIT TO EODADIN. THIS\n*        WILL CAUSE THE COMMENT PROGRAM TO CHECK FOR AN CORRECT\n*        ENDCOMMENT BUT NOTHING MORE IS TO BE PROCESSED.\n*        FOR PROGRAM BLOCK 0, IF ANY, THE BLOCK WILL ONLY BE\n*        WRITTEN OUT AND NO FURTHER ACTIONS TAKEN.\n*\n*        ENTERED FROM END (BETA, PROC*), SEMCO (PROC, PROC**)\n*\n*        EXITS TO COMMEND (NORMAL), COMPEND4 (PROC OR PROC**\n*        FOLLOWED BY END), TERMINATION (NOPBN0)\n*\nPBLCKEND L     R15,AITL\nPBLCKEAA S     R15,KF11                SUBTRACT 11 TO EARSE\n         CLI   6(R15),0                EMPTY\n         BE    PBLCKEAA                CONTINUATION\n         LA    R15,11(,R15)\nWRTITAB  S     R15,LPBP                COMPUTE LENGTH OFITAB SECTION\n         ST    R15,ITABLEN\n         C     R15,KF2000              ITAB SECTION TOO LONG ?\n         BL    WRTITABA                NO, BYPASS ERROR\n         BAL   R6,ERR4\n*\n         DC    X'0426'                 E38 MORE THAN 184 IDENTIFIERS\n*\nWRTITABA MVC   AITL(4),LPBP            UPDATE AITL\n         L     R6,LPBP\n         MVC   LIGP(4),0(R6)           UPDATE LIGP\n         MVC   LPBP(4),4(R6)           UPDATE LPBP\n         MVC   0(2,R6),ITABLEN+2       INSERT LENGTH IN HEADENTRY\n         MVI   5(R6),XFBLANK\n         STM   R14,R3,SAVE1            SAVE REGISTERS\n         SR    R2,R2\n         IC    R2,10(,R6)              GET CORRENT PBN\n         AR    R2,R2                   INSERT SEMCNT AT BLOCKSTART\n         LA    R7,SCTAB(R2)            IN HEADING\n         MVC   6(2,R6),0(R7)\n         TM    BITS2,X'08'             PB0 ?\n         BZ    WRTITABB                NO\n         MVI   6(R6),0                 CORRECT SEMCNT\n         MVI   7(R6),0                 FOR PB0\nWRTITABB TM    BITS3,FRSITB            FIRST BLOCK TO BE WRITTEN ?\n         BZ    WRT1                    YES, DO NOT CHECK\n         STM   R14,R15,ERRSAVE         CHECK PREVIOUS WRITE\n*\n         CHECK ITABC\n*\n         LM    R14,R15,ERRSAVE\nWRT      L     R7,AITABBUF             ADDR OF BUFFER\nCOMPARE1 C     R15,KF256               MORE THAN 256 BYTES TO MOVE ?\n         BL    EXMVC1                  NO, MOVE ALL AT ONCE\nCOMPARE2 MVC   0(256,R7),0(R6)         YES, MOVE A SECTION OF 256\n         LA    R6,256(,R6)             BYTES AT A TIME\n         LA    R7,256(,R7)\n         S     R15,KF256\n         C     R15,KF256               STILL MORE THAN 256 LEFT ?\n         BH    COMPARE2                YES, MOVE NEXT SECTION\nEXMVC1   EX    R15,MOVE4               MOVE A SECTION OF LESS THAN 256\n         LA    R3,0(R15,R7)\n         L     R7,AITABBUF             LOAD ADDR OF ITAB BUFFER\n         L     R15,AUT3DCB                          SYSUT3 DCB\n         L     R14,ITABLEN                          LENGTH\n*\n         WRITE ITABC,SF,(R15),(R7),(R14)\n*\n         LM    R14,R3,SAVE1\n         TM    BITS2,X'08'             PB0 WAS WRITTEN ?\n         BOR   R4                      BRANCH BACK IF TERBIT ON\n         L     R6,AITL                 CLEAR\n         MVI   0(R6),0                 NEXT\n         MVC   1(10,R6),0(R6)          ITABENTRY\n         LA    R0,4(,R3)\n         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P\n         MVI   0(R3),X'2A'             INSERT EPSILON\n         L     R6,LPBP\n         MVC   1(1,R3),10(R6)                 PBN\n         L     R6,LIGP\n         MVC   2(2,R3),8(R6)                  IGN\n         NI    2(R3),X'7F'             CLEAR FIRST BIT OF IGN (PHI IND)\n         LA    R3,4(,R3)\n         L     R15,SP                  RELEASE\n         BCTR  R15,0                   TOPBYTE\n         ST    R15,SP                  IN STACK\n         TM    BITS1,X'01'             TERMINATION BIT ON ?\n         BOR   R4                      YES, RETURN TO ENDMISS PGM\n         CLI   0(R15),0                STACK EMPTY ?\n         BE    PGMEND                  YES, LOGICAL PROGRAM ENP\n         BR    R4                      RETURN\n*\nPGMEND   OI    BITS2,ENDBIT            SET ENDBIT\n         LA    R12,EODADIN             NEW EOD ADDR\n         ST    R12,EODIN\n         B     COMMEND\n*\nWRT1     OI    BITS3,FRSITB            DON'T CHECK FIRST TIME\n         B     WRT\n*\nMOVE4    MVC   0(1,R7),0(R6)           PBLCKEND MOVE FOR ITAB\n*\nSCTAB    DC    XL256'00'\n         DC    XL254'00'\n*\n*        COMMENT\n*\n*        THREE ENTRIES -\n*        1. COM FOR THE ALGOL WORD COMMENT\n*           SETS CODIT=1, CHECKS THAT COMMENT IS IN A LEGAL\n*           POSITION\n*        2. COMERR FOR ERRORS IN DECLARATIONS\n*           ALL CHARACTERS TO NEXT SEMICOLON WILL BE SKIPPED\n*           SET COBIT AND DELTABIT = 1\n*        3. COMMEND ENTERED AFTER AN END IS FOUND\n*           SKIPS ALL CHARACTERS TO NEXT ; OR END OR ELSE SETS\n*           THE COBIT = 0\n*\nCOMERR   OI    BITS2,X'40'             SET COBIT AND\n         OI    BITS1,X'20'             DELTABIT ON\n         B     COMCEE2\n*\nCOMMEND  NI    BITS2,X'BF'             SET COBIT TO 0\n         B     COMCED2\n*\nCOM      OI    BITS2,X'40'             SET COBIT TO I\n         LR    R4,R3\n         BCTR  R4,0\n         CLI   0(R4),X'0C'             BEGIN IN O/P ?\n         BE    COMCED2\n         BCTR  R4,0\n         BCTR  R4,0\n         CLI   0(R4),X'0B'             BETA IN O/P ?\n         BE    COMCED2\n         CLI   0(R4),XFDELTA           DELTA IN O/P ?\n         BE    COMCED2\n         BCTR  R4,0\n         CLI   0(R4),X'0D'             SEMICOLON IN O/P ?\n         BE    COMCED2\n         BAL   R6,ERR7                 E18\n*\n         DC    X'0412'\n*\nCOMCED2  LA    R1,1(,R1)               INCR R1\nCOMCEE2  BALR  R9,0\n         SR    R2,R2\n         TRT   0(73,R1),COMTABLE       SCAN THE COMMENT\n         LA    R4,0(R2,R9)             BRANCH WITH OFFSET FROM COMTABLE\n         BR    R4                      TO APPROPRIATE ROUTINE\n*\n***********************************************************************\n*\n*        ROUTINES COMAPOST, COMZETA, COMPOINT AND COMSEMCO\n*        ARE ADDRESSED AS OFFSETS FROM COMCEE2 VIA COMTABLE\n*\n*        COMAPOST\n*\n*        IF AN END COMMENT IS PROCESSED, COBIT= 0, CHECK IF\n*        APOSTROPHE IS THE START OF END OR ELSE OTHERWISE RETURN\n*        TO SCAN THE COMMENT AGAIN\n*\nCOMAPOST TM    BITS2,X'40'             COBIT ON ?\n         BO    COMCED2                 YES, RETURN TO SCANNING AGAIN\n         MVI   FBYTE,X'FF'             SET FBYTE\n         B     ENTRAPR                 RETURN TO APOSTROE PROGRAM\n*\nCOMZETA  B     CIB                     ZETA - RETURN TO COMERR\n*\n*        COMPOINT\n*\n*        CHECK FOR SEMICOLON ., IF NOT RETURN\n*\nCOMPOINT LA    R6,COMCEE2               RETURN IF NOT SEMCOLON\n         BAL   R12,FINDSEMC\n*\n*        COMSEMCO\n*\n*        ENDELSE BIT ON -\n*        END COMMENT AFTER BEGIN OR BETA ENDED WITH A ., MEANS\n*        THAT THE END MIGHT ALSO CLOSE AN FOR STATEMENT OR A\n*        PROCEDURE.\n*        ENDBIT ON -\n*        FINAL END HAS BEEN REACHED NOTHING IS TO FOLLOW THIS\n*        COMMENT IN THE CORRECT CASE.\n*        AN SEMICOLON AFTER AN COMMENT IS NOT TO BE COUNTED THAT\n*        IS COBIT= 1 AND DELTABIT=0 RETURN TO TEST OTHERWISE\n*        RETURN VIA SEMICOLON PROGRAM\n*\nCOMSEMCO TM    BITS2,X'01'             END ELSE BIT ?\n         BO    COMPEND2                YES\n         TM    BITS2,ENDBIT            FINAL END COMMENT HAS ENDED ?\n         BO    READROUT                YES, OK\n         TM    BITS2,X'40'             COMMENT ?\n         BZ    SEMCO                   NO\n         TM    BITS1,X'20'             DELIMITER ERROR ?\n         BO    SEMCO                   YES\n         LA    R1,1(,R1)               FOR A COMMENT SKIP SEMICOLON\n         B     TESTLOOP\n*\n***********************************************************************\n*\n*        FOR\n*\n*        INCREASES IG AND FSN NUMBER\n*        MAKES ENTRIES IN SCOPE AND GROUPTABE\n*        MOVES FOR (18) TO OUTPUT FOLLOWED BY NEW IG NUMBER\n*        CHECKS IF PROC IN STACK, IF YES PROC IS CHANGED TO\n*        PROC**\n*        PUTS FOR IN STACK\n*        AN FORHEAD ENTRY IS MADE IN ITAB\n*        THE RETURN IS TO TEST\n*\nFOR      LA    R0,3(,R3)\n         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P\n         LH    R15,IGC                 INCREASE ITAB GROUP NUMBER\n         LA    R15,1(,R15)\n         MVI   0(R3),XFFOR             MOVE 'FOR'\n         STH   R15,IGC                 AND IGN\n         MVC   1(2,R3),IGC\n         LA    R3,3(,R3)               TO OUTPUT BUFFER\n         CLI   FSN,255                 > 255 FOR STATEMENTS ?\n         BNE   FORAA\n         BAL   R6,ERR4\n*\n         DC    X'0429'                 E41\n*\nFORAA    IC    R2,FSN                  INCREASE FSN\n         LA    R2,1(,R2)\n         STC   R2,FSN\n         LA    R12,SPTAB-1\n         AR    R12,R2\n         L     R15,LPBP\n         MVC   0(1,R12),10(R15)        MAKE ENTRY IN SCOUP TABLE\n         NI    BITS1,X'7F'             BEGBIT= 0\n         L     R12,SP\n         C     R12,ATOPSTAK            STACK OVERFLOW ?\n         BL    FORBB\n         BAL   R6,ERR4\n*\n         DC    X'0414'                 E20\n*\nFORBB    CLI   0(R12),X'0C'            PROC IN STACK ?\n         BNE   NOPROCBY                NO\n         MVI   0(R12),X'14'            MAKE PROC BE PROC**\n         NI    BITS1,X'BF'             PROBIT=0\n         CLI   PZ,0                    ALL PARAMETERS SPECIFIED ?\n         BE    NOPROCBY                YES\n         BAL   R12,ERROR10             NO, GENERATE E10\nNOPROCBY L     R12,SP\n         LA    R12,1(,R12)             INCR STACK POINTER\n         MVI   0(R12),XFFOR            PUT FOR INTO STACK\n         ST    R12,SP\n         LH    R12,IGC\n         AR    R12,R12\n         AH    R12,IGC\n         A     R12,AGT\n         L     R15,LIGP\n         MVC   0(2,R12),8(R15)         ENTRY INTO GROUP TABLE\n         STC   R2,2(R12)\n         NI    0(R12),X'7F'            CLEAR POSSIBLE PHI IND\n         L     R15,AITL\n         MVC   0(4,R15),LIGP           CONSTRUCT FOR HEAD ENTRY IN ITAB\n         MVI   5(R15),X'2B'\n         MVC   8(2,R15),IGC\n         ST    R15,LIGP                UPDATE LIGP\n         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITAB ENTRY\n         LA    R1,1(,R1)\n         B     TESTLOOP\n*\n*        TYPE\n*\n*        ENTRED FOR INTEGER, REAL AND BOOLEAN.\n*        TESTS FOR NEWBLOCK, BEGBIT, AND IF IDENTIFIER IS\n*        SPECIFIED, PROBIT.\n*        MOVES INTERNAL NAME CHARACTERISTICS AND PBN TO ITAB.\n*        CHECKS THE IDENTIFIER FOR VALIDITY AND MOVES UP TO 6\n*        CHARACTERS TO ITAB EXTERNAL NAME.\n*        IF THE FIRST CHARACTER FOUND IS AN APOSTROPHE THE CHECK\n*        IS VIA APOSTROF, DELIMITER AND TYPESPEC FOR ARRAY OR\n*        PROCEDURE (FBYTE=F0)\n*\nTYPE     TM    BITS1,X'40'             PROBIT = 1 ?\n         BO    SPECENT                 YES\n         TM    BITS1,X'80'             BEGBIT = 1 ?\n         BZ    TYPEAA\n         ST    R9,SAVE1                IF YES GOTO BEGI PGM\n         BAL   R9,BEG1\n         L     R9,SAVE1\nTYPEAA   L     R15,AITL                MOVE CHARACTERISTICS TO ITAB\n         MVI   6(R15),X'C0'            TO THE 7TH AND 8TH\n         MVI   7(R15),X'30'            BYTE OF THE ENTRY\n         LA    R6,2(R14,R9)            MODIFIY THE LAST 4 BITS WITH\n         MVN   7(1,R15),0(R6)          INFORMATION FROM THE KEYWTAB\n         L     R6,LPBP\n         MVC   8(1,R15),10(R6)         MOVE IN PROGRAM BLOCK NUMBER\nTYPEDAFI LA    R1,1(,R1)               GET NEXT CHARACTER\n         CLI   0(R1),XFA               CHAR A LETTER ?\n         BNL   TYPENAME                YES\n         CLI   0(R1),XFBLANK           BLANK ?\n         BE    TYPEDAFI\n         CLI   0(R1),XFZETA            ZETA ?\n         BNE   TYPEBB\n         LA    R9,TYPEDAFI+4           CHANGE INPUT\n         B     CIB                     BUFFER\n*\nTYPEBB   CLI   0(R1),XFQUOTE           QUOTE ?\n         BE    TYPECC\n         LA    R15,TYPEDAFI            STORE RETURN ADDR\n         B     IERSPEC                 GOTO ERROR ROUTINE\n*\nTYPECC   MVI   FBYTE,X'F0'             MOVE F0 TO FBYTE\n         B     ENTRAPR                 CHECK FOR TYPE ARRAY OR PROC\n*\nTYPENAME L     R7,AITL                 GET ITAB POINTER\n         MVC   0(1,R7),0(R1)           MOVE FIRST CHAR TO ITAB\n         LA    R7,1(,R7)               INCREASE POINTER\n         LA    R2,1                    INITIALIZE COUNTER\n         LA    R9,TYPENM03             RTN IF CHANGE OF I/P BUF NEEDED\nTYPENM02 LA    R1,1(,R1)               GET NEXT CHAR\nTYPENM03 CLI   0(R1),XFZETA            LETTER, ZETA OR SOMETHING ELSE ?\n         BE    CIB                     CHANGE I/P BUFFER\n         BL    TLISTSE                 CHECK FURTHER\n         C     R2,KF6                  6 CHAR ALREADY MOVED IN ?\n         BE    TYPENM02                YES\n         MVC   0(1,R7),0(R1)           NO, MOVE IN NEXT CHAR\n         LA    R7,1(,R7)               INCREASE\n         LA    R2,1(,R2)               POINTERS\n         B     TYPENM02                TAKE NEXT CHAR\n*\nTLISTSE  CLI   0(R1),XFBLANK           BLANK ?\n         BE    TYPENM02\n         CLI   0(R1),XFCOMMA           COMMA ?\n         BE    TYPECOMA\n         LA    R15,TYPEDAFI            RETURN ADDR FOR IER\n         LA    R6,IER                  RETURN ADDR IF NO SEMICOLON\n         BAL   R12,FINDSEMC            LOOK FOR SEMICOLON\n*\n*        TYPESEMC\n*\n*        SEMICOLON FOUND\n*        END OF THIS DECLARATION\n*        DELTABIT IS TURNED ON AND THE RETURN TO TEST IS VIA\n*        SEMCO\n*\nTYPESEMC BAL   R12,ITABCLEA            CLEAR NEXT ITAB ENTRY\n         OI    BITS1,X'20'             SET DELTABIT TO ONE\n         B     SEMCO                   GO TO SEMICOLON PROGRAM\n*\n*        TYPECOMA\n*\n*        AN COMMA ENDED THE IDENTIFIER\n*        THE INTERNAL NAME IS COPIED AND TYPE PROGRAM UTILIZED\n*        AGAIN\n*\nTYPECOMA L     R9,AITL\n         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY\n         MVC   6(3,R15),6(R9)          COPY ID AND PBN FIELDS\n         B     TYPEDAFI                RETURN TO CHECK NEXT IDENTIFIER\n*\n*        IER\n*\n*        IDENTIFIER ERROR ROUTINE\n*\n*        HAS 2 ENTRIES -\n*        1. IERSPEC IF FIRST CHARACTER IS IN ERROR, E5\n*        2. IER ANY OTHER CHARACTER, E16\n*        RETURN -\n*        1. VIA R15 IF AN COMMA IS FOUND AFTER\n*           THE IDENTIFIER IN ERROR.\n*        2. TO TEST VIA SEMCO IF AN SEMICOLON IS FOUND.\n*        3. TO PROCFIN IF AN RIGHT PARENTHESIS IS FOUND AND THE\n*        FMBIT IS ON WHICH INDICATES THAT THE FORMAL PARAMETER\n*        LIST OF A PROCEDURE IS UNDER PROCESS\n*\n*        R15 MIGHT LEAD TO TYPEDAFI, IDCHECK, PROCID\n*\nIERSPEC  BAL   R6,ERR7\n*\n         DC    X'0405'                 E5\n*\n         B     IERSPECA\n*\nIER      BAL   R6,ERR2\n*\n         DC    X'0010'                 E16\n*\nIERSPECA L     R7,AITL                 RESET R7 TO START\n         MVI   0(R7),0                 CLEAR EXTERNAL NAME PART\n         MVC   1(5,R7),0(R7)\nIERCOMMA LA    R1,1(,R1)\n         LA    R6,IERSELSE             RETURN IF NO SEMICOLON FOUND\n         BAL   R12,FINDSEMC            LOOK FOR SEMICOLON\nIERSEMCO L     R15,AITL                SEMICOLON FOUND - END OF DCL.\n         BAL   R12,ITABCLEC            CLEAR ITAB ENTRY\n         TM    BITS3,FMBIT             FORMAL PARAMETER LIST PROCESSED?\n         BO    SCYES3-8                YES, RETURN TO PROCEDURE END\n         OI    BITS1,X'20'             DELTABIT = 1\n         NI    BITS2,X'EF'             VALBIT=0\n         MVC   KB(2),KF0               CKB = 00\n         B     SEMCO                   RETURN TO TEST VIA SEMCO\n*\nIERSELSE CLI   0(R1),XFCOMMA           COMMA ?\n         BER   R15                     RETURN IF COMMA FOUND\n         TM    BITS3,FMBIT             FORMAL PARAMETER LIST PROCESSED?\n         BZ    IERCOMMA                NO\n         CLI   0(R1),XFRBRAC           RIGHT BRACKET ?\n         BE    PROCFIN                 YES, GOTO PROCEDURE END HANDLING\n         B     IERCOMMA                CONTINUE CHECKING NEXT CHAR\n*\n*        CODE\n*\n*        SETS THE PROBIT TO ZERO\n*        CHECKS THAT CODE IS IN THE CORRECT PLACE AND IS\n*        FOLLOWED BY A SEMICOLON\n*        CORRECTS THE INTERNAL NAME OF THE PROCEDURE\n*        TRANSFER THE NAME IN EXTERNAL FORM TO OUTPUT\n*        RETURNS VIA PROGRAM BLOCK END TO TEST\n*\nCODE     NI    BITS1,X'BF'             PROBIT=0\n         CLI   PZ,0                    ALL PARAMETERS SPECIFIED ?\n         BZ    CODEAA                  YES\n         BAL   R12,ERROR10             NO, GENERATE E10\nCODEAA   L     R15,SP\n         CLI   0(R15),X'0C'            PROC IN STACK ?\n         BNE   CODERR                  IF NO BRANCH TO ERROR\n         LR    R14,R3\n         S     R14,KF3\n         CLI   0(R14),XFDELTA          DELTA IN O/P ?\n         BNE   CODERR                  IF NO  BRANCH TO ERROR\n         L     R15,LPBP\n         S     R15,KF11                GET PROCEDURE NAME\n         XI    7(R15),X'80'            INTERNAL NAME IS CORRECTED\n         TM    19(R15),X'80'           TYPE PROCEDURE ?\n         BZ    CODEBB\n         XI    29(R15),X'80'           YES, CORRECT SECOND NAME ENTRY\nCODEBB   LA    R0,9(,R3)\n         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P\n         MVI   0(R3),X'3C'             TRANSFER GAMMA\n         MVC   1(6,R3),0(R15)          TRANSFER NAME AND\n         TR    1(6,R3),TRINTEXT        CONVERT TO EXTERNAL CODE\n         MVI   7(R3),C' '              MOVE IN EXTERNAL BLANK\n         MVI   8(R3),C' '              MOVE IN EXTERNAL BLANK\n         LA    R3,9(,R3)\n         OI    BITS1,X'20'             DELTABIT = 1\nSEARCH   LA    R6,NOSEMC               RETURN IF NO SEMICOLON FOUND\n         LA    R4,SEMCO                RETURN ADDR FOR PBLCKEND\n         LA    R1,1(,R1)\n         BAL   R12,FINDSEMC            SEMICOLON FOLLOWS ?\n         B     PBLCKEND                SEMICOLON FOUND, GOTO PBLCKEND\n*\nNOSEMC   BAL   R6,ERR7\n*\n         DC    X'040F'                 E15\n*\n         LA    R6,FINDSEMC             PERIOD FOUND ?\n         CR    R6,R9\n         BE    PBLCKEND                NO\n         BCTR  R1,0                    YES\n         MVI   0(R1),XFPERIOD          MOVE IN A PERIOD\n         BCTR  R1,0                    DECREASE R1, WILL BE INCREASED\n         B     PBLCKEND                BY SEMCO. RETURN VIA PBLCKEND\n*\nCODERR   BAL   R6,ERR7\n*\n         DC    X'0418'                 E24\n*\n         B     COMERR                  SKIP TO NEXT SEMICOLON\n*\n*        SPEC\n*\n*        ENTERED FOR LABEL AND STRING\n*        CHECKS THAT THEY ARE IN PROCEDURE HEAD\n*\nSPEC     TM    BITS1,X'40'             PROBIT ON ?\n         BO    SPECENT                 YES, PROCESS SPECIFIED\n*                                      LABEL OR STRING\n         BAL   R6,ERR7\n*\n         DC    X'0419'                 E25\n*\n         B     COMERR                  SKIP TO NEXT SEMICOLON\n*\n*        SPECENT\n*\n*        ENTERED FOR SPECIFICATIONS FROM -\n*        TYPE\n*        SPEC\n*        ARRAY\n*        SWITCH\n*        PROCEDURE\n*        SAVES IN KB THE CHARACTERISTICS TAKEN FROM THE\n*        DELIMITER TABLE\n*\nSPECENT  LA    R15,1(R14,R9)           MOVE IN IDFIELD\n         MVC   KB(2),0(R15)\n*\n*        IDCHECK\n*\n*        ENTERED FROM -\n*        VALUE\n*        TYPEARRAY\n*        TYPEPROCEDURE\n*        SPECENT\n*        CHECKS THE NAME FOR FORMAL PARAMETERS\n*        FINDS THE ENTRY IN ITAB AND INSERTS THERE THE\n*        CHARACTERISTICS AND PROGRAM BLOCK NUMBER.\n*        DECREASES THE PARAMETER COUNT PZ BY ONE FOR EACH\n*        CORRECT PARAMETER FOUND .\n*        IF A COMMA ENDS THE IDENTIFIER IDCHECK WILL BE\n*        ACTIVATED AGAIN.\n*        IF A SEMICOLON ENDS THE DELIMITER THE RETURN IS TO TEST\n*        VIA SEMICOLON PROGRAM\n*\nIDCHECK  LA    R1,1(,R1)               GET NEXT CHAR\n         CLI   0(R1),XF9               LETTER ?\n         BNH   IDNOLETR                NO\n         MVC   IDBUCKET(6),KF0         CLEAR BUCKET WITH ZEROS\n         LA    R7,IDBUCKET\n         LA    R14,1\n         MVC   0(1,R7),0(R1)           MOVE FIRST CHAR TO BUCKET\n         LA    R7,1(,R7)\n         LA    R9,IDLOOPAA             RETURN IF CIB NEEDED\nIDLOOP   LA    R1,1(,R1)               GET NEXT CHAR\nIDLOOPAA CLI   0(R1),XFZETA            ZETA ?\n         BE    CIB                     YES\n         BL    IDSEARCH                SOMETHING ELSE\n         C     R14,KF6                 LETTER OR DIGIT\n         BE    IDLOOP                  6 CHAR MOVED ALREADY YES ?\n         MVC   0(1,R7),0(R1)           NO, MOVE CHAR\n         LA    R7,1(,R7)               INCREASE POINTERS\n         LA    R14,1(,R14)\n         B     IDLOOP                  TAKE NEXT CHAR\n*                                      FIRST CHAR WAS NOT LETTER\nIDNOLETR CLI   0(R1),XFBLANK           BLANK ?\n         BE    IDCHECK                 YES, GET NEXT CHAR\n         CLI   0(R1),XFZETA            ZETA ?\n         BNE   IDNOLETA                NO\n         LA    R9,IDCHECK+4            YES, CHANGE I/P-BUFFER\n         B     CIB                     BUFFER\n*\nIDNOLETA CLI   0(R1),XFQUOTE           QUOTE ?\n         BE    IDNOLETB                YES\n         LA    R15,IDCHECK             NO, SET RETURN ADD AND GOTO\n         B     IERSPEC                 IDENTIFIER ERROR ROUTINE\n*\nIDNOLETB MVI   FBYTE,X'F0'             SET FBYTE, LOOK FOR TYPE\n         B     ENTRAPR                 ARRAY OR TYPE PROC\n*\nIDSELSE  BAL   R6,ERR2E\n*\n         DC    X'0010'                 E16\n*\n         LA    R15,IDCHECK             RETURN ADDR FOR IER\n         B     IERCOMMA                GOTO IDENTIFIER ERROR ROUTINE\n*\nIDBUCKET DC    6X'00'\n*\nIDSEARCH CLI   0(R1),XFBLANK           BLANK ?\n         BE    IDLOOP                  YES, BRANCH\n         CLI   0(R1),XFCOMMA           COMMA ?\n         BE    IDCOMMA                 YES, BRANCH\n         LA    R6,IDSELSE              IF NOT SEMICOLON FOUND\n         BAL   R12,FINDSEMC            LOOK FOR SEMICOLON\n         OI    BITS1,X'20'             SEMICOLON FOUND SET DELTABIT\nIDCOMMA  CLC   PRIMPAR(4),KF0          ARE THERE ANY PARAMETERS ?\n         BE    NOTFOUND                NO\n         L     R12,PRIMPAR             GET FIRST PARAMETER\n*\n*        COMPID\n*\n*        A LOOP TO FIND THE PARAMETER IN ITAB\n*\nCOMPID   CLC   IDBUCKET(6),0(R12)      CHECK IF IDENTIFIER FOUND\n         BE    IDVALCHK                FOUND\n         LA    R12,11(,R12)            NOT FOUND. TRY NEXT PARAMETER\n         C     R12,AITL                IF THERE ARE ANY LEFT\n         BNE   COMPID                  YES\nNOTFOUND BAL   R6,ERR2E\n*\n         DC    X'001B'                 E27\n*\n         B     IDENDER\n*\nIDVALCHK TM    BITS2,X'10'             VALUE CALL ?\n         BO    VALDLB2                 YES, GOTO VAL ROUTINE\n         TM    6(R12),X'06'            SPECIAL USE BITS ON ?\n         BZ    IDCHKEND                NO\n         BAL   R6,ERR2E                YES, CREATE\n*\n         DC    X'001A'                 E26\n*\n         B     IDENDER                 GET NEXT IDENTIFIER\n*\n*        IDCHKEND\n*\n*        INSERTS CHARACTERISTICS AND PBN, DECRESES PZ.\n*        IF BOTH VALUE AND NAME BIT ON BYTE 7 EQVALS 30 A VALUE\n*        SPECIFICATION HAS BEEN MADE EARLIER SO IT IS CORRECTED\n*        TO BE A CALL BY VALUE.\n*\nIDCHKEND L     R6,LPBP\n         MVC   8(1,R12),10(R6)         INSERT PBN\n         OC    6(2,R12),KB\n         IC    R6,PZ                   CORRECT IDFIELD IS CREATED\n         BCTR  R6,0                    PZ = PZ-1\n         STC   R6,PZ\n         TM    7(R12),X'30'            VALUE BIT ON ?\n         BM    IDENDER\nVALCALL  NI    7(R12),X'EF'            YES, ZERO NAME BIT\nIDENDER  TM    BITS1,X'20'             DELTABIT ON ?\n         BZ    IDCHECK                 NO, GET NEXT IDENT\n         MVC   KB(2),KF0               YES, CLEAR IDFIELD\n         NI    BITS2,X'EF'             SET VALBIT TO ZERO\n         B     SEMCO                   GOTO SEMICOLON PROGRAM\n*\n*        VALUE\n*\n*        CHECKS THAT SPECIFICATION IS IN A PROCEDURE HEAD\n*        EXITS FIRST TO IDCHECK TO FIND THE PARAMETER WILL THEN\n*        RETURN TO VALDLB2 FOR FUTHER CHECKS AND TO INSERT THE\n*        VALUE BIT IN THE INTERNAL NAME\n*\nVALUE    TM    BITS1,X'40'             PROCEDURE ?\n         BZ    VALUERR                 NO, ERROR\n         OI    BITS2,X'10'             YES, SET VALUE BIT TO ONE\n         B     IDCHECK                 AND GO TO IDCHEK\n*\nVALUERR  BAL   R6,ERR7                 E28 VALVE\n*\n         DC    X'041C'                 OUTSIDE PROC\n*\n         B     COMERR                  SKIP TO NEXT SEMICOLON\n*\nVALDLB2  TM    7(R12),X'20'            VALUE BIT ON IN IDENTIFIER ?\n         BZ    VALDLB3                 NO\n         BAL   R6,ERR2E\n*\n         DC    X'001E'                 E30\n*\n         B     IDENDER                 GET NEXT IDENTIFIER\n*\nVALDLB3  TM    6(R12),X'06'            SPECIAL USE BIT ENTERED ?\n         BZ    VALDLB4                 NO\n         BAL   R6,ERR7\n*\n         DC    X'041D'                 E29\n*\n         XI    7(R12),X'30'            MOVE IN IDFIELD\n         B     IDENDER                 GET NEXT IDENTIFIER\n*\nVALDLB4  MVI   7(R12),X'30'            CORRECT - MOVE IN IDFIELD\n         B     IDENDER                 GET NEXT IDENTIFIER\n*\n*        TYPEARRAY\n*\n*        ENTERED FROM TYPESPEC\n*        TEST FOR PROBIT, BEGBIT\n*        INSERTS CHARACTERISTICS IN INTERNAL NAME WITHOUT\n*        DESTROYING THE TYPE SPECIFICATIONS ENTERED BY THE TYPE\n*        PROGRAM\n*        JOINS ARRAY PROGRAM FOR A SPECIFIED TYPEARRAY THE EXIT\n*        IS TO IDCHECK\n*\nTYPEARRY TM    BITS1,X'40'             PROBIT ON ?\n         BO    TARYDHB3                YES, SPECIFICATION\n         TM    BITS1,X'80'             BEGBIT ON ?\n         BZ    TYPEARAA\n         ST    R9,SAVE1                YES\n         BAL   R9,BEG1                 GO AND PROCESS PROGRAMBLOCK HEAD\n         L     R9,SAVE1\nTYPEARAA L     R7,AITL\n         MVI   6(R7),X'C8'             MOVE IN\n         XI    7(R7),X'34'             ID FIELD\n         B     ARRYDME1                GOTO ARRAY PROCECING\n*\nTARYDHB3 MVI   KB,X'CA'                MOVE IN\n         OI    KB+1,X'04'              TYPE ARRAY SPECIFICATION ID\n         B     IDCHECK\n*\n*        ARRAY\n*\n*        TESTS FOR PRO AND BEGBIT\n*        ENTERS CHARACTERISTICS IN INTERNAL NAME\n*        TYPEARRAY JOINS HERE\n*        PBN IS ENTERED IN INTERNAL NAME\n*        09 FOR ARRAY IS MOVED TO OUTPUT\n*        THE NAME IS CHECKED AND MOVED TO OUTPUT AND ITAB SHOULD\n*        BE FOLLOWED BY A COMMA OR LEFT PARENTHISIS\n*        SETS N (NUMBER OF ARRAYS WITH SAME DIMENSIONS) TO ONE\n*\nARRAY    TM    BITS1,X'40'             PROBIT ON ?\n         BO    SPECENT                 YES\n         TM    BITS1,X'80'             BEGBITI ON ?\n         BZ    ARRAYAA\n         ST    R9,SAVE1                YES, PROCESS PROGRAM BLOCK HEAD\n         BAL   R9,BEG1\n         L     R9,SAVE1\nARRAYAA  L     R7,AITL\n         MVI   6(R7),X'C8'             MOVE IN\n         MVI   7(R7),X'06'             IO FIELD\nARRYDME1 L     R6,LPBP\n         MVC   8(1,R7),10(R6)          MOVE IN PROGRAM BLOCK NUMBER\n         LA    R6,9(,R7)               MOVE ADDR OF AITL+9\n         ST    R6,DIM                  TO DIM\n         BAL   R12,COB\n         MVI   0(R3),X'09'             MOVE ARRAY ID TO O/P\n         LA    R3,1(,R3)\nARRYNAME LA    R1,1(,R1)               GET FIRST CHAR\n         CLI   0(R1),XF9               LETTER ?\n         BNH   ARNAMESE                NO\n         TM    BITS1,X'04'             LISTBIT ON ?\n         BO    ARRYMULT                YES\n         MVC   N(1),KF1+3              SET N=1\nARRYID   BAL   R6,IDCHECK1             CHECK, MOVE IDENT TO ITAB\nARRYSE   CLI   0(R1),XFBLANK           O/P BLANK ?\n         BE    IDCHECK2\n         CLI   0(R1),XFLBRAC           LEFT BRACKET ?\n         BE    ARRYLPAR                YES, BRANCH\n         CLI   0(R1),XFLSQBR           LEFT SQUARE BRACKET ?\n         BE    ARRYLPAR                YES, BRANCH\n         CLI   0(R1),XFCOMMA           COMMA ?\n         BE    ARCOMMA\nARRAYERR BAL   R6,ERR2                 SOMETHING ELSE FOUND\n*\n         DC    X'0010'                 E16\n*\n         BAL   R12,COB\n         MVI   0(R3),X'3D'             MOVE IN RHA\n         LA    R3,1(,R3)\nARYEXIT  L     R15,AITL\n         BAL   R12,ITABCLEA+8          CLEAR ITAB-ENTRY\nARYEXITA NI    BITS1,X'F7'             TURN OFF ARBIT\n         LA    R10,TESTLOOP            RESET RETURN REG TO MAINLOOP\n         B     COMERR                  SKIP TO NEXT SEMICOLON\n*\nARNAMESE CLI   0(R1),XFBLANK           NAME STARTS WITH BLANK ?\n         BE    ARRYNAME                YES, BRANCH\n         CLI   0(R1),XFZETA            ZETA ?\n         BNE   ARNAMEAA\n         LA    R9,ARRYNAME+4\n         B     CIB\n*\nARNAMEAA BAL   R6,ERR7                 FIRST CHAR OF NAME IN ERROR\n*\n         DC    X'0405'\n*\n         B     ARYEXIT                 DELETE DECLARATION\n*\n*        ARRAYPAR\n*\n*        ENTERED WHEN A LEFT BRACKET OR LEFT SQUARE BRACKET IS\n*        FOUND AFTER THE NAME\n*        INITIALIZES D DIMENSION COUNTER=0\n*        SETS THE ARBIT C PARENTHESIS COUNT=1\n*        SEARCHES FOR A SLASH\n*        MOVES OUT SUBSCRIPT BRACKETS TO OUTPUT\n*        EXITS TO ARRAYLIST\n*\nARRYLPAR OI    BITS1,X'08'             ARBIT = 1\n         LA    R12,1\n         STH   R12,C                   C=1\n         LA    R12,0\n         STC   R12,D                   D=0\n         CLI   0(R1),XFLSQBR           LEFT SQUARE BRACKET ON ENTRY ?\n         BE    ARRYLSQB                YES, BRANCH\n         LA    R1,1(,R1)               GET NEXT CHAR\nARRYSLSH CLI   0(R1),XFSLASH           SLASH ?\n         BE    ARRYLSQB                YES, MOVE IN LEFT SQUARE BRACKET\n         CLI   0(R1),XFBLANK           BLANK ?\n         BE    ARRYSLSH-4              YES, GET NEXT CHAR\n         CLI   0(R1),XFZETA            ZETA ?\n         BNE   ARRYSLAA                NO, GOTO ERROR ROUTINE\n         LA    R9,ARRYSLSH             YES, CHANGE\n         B     CIB                     INPUT BUFFER\n*\nARRYSLAA BAL   R6,ERR2\n*\n         DC    X'001F'                 E31\n*\n         BCTR  R1,0\nARRYLSQB BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVI   0(R3),XFLSQBR           MOVE IN LEFT SQUARE BRACKET\n         LA    R3,1(,R3)               INCR\n         LA    R1,1(,R1)               POINTERS\n         B     LIST                    GOTO PROCESS ARRAY LIST\n*\n*        ARCOMMA\n*\n*        COPIES INTERNAL PART OF ITAB ENTRY SETS THE LISBIT\n*        EXITS TO ARRAYNAME TO CHECK FIRST CHARACTER OF NEXT NAME\n*        THE LIST BIT WILL THEN CAUSE ARRAYMULT TO BE\n*        EXECUTED BEFORE THE REST OF THE NAME IS CHECKED\n*        INCREASES N, NUMBER OF ARRAYS WITH THE SAME DIMENSIONS,\n*        BY ONE\n*\nARCOMMA  L     R9,AITL                 SAVE AITL\n         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY\n         MVC   6(3,R15),6(R9)          COPY ID AND PBN FIELDS\n         IC    R6,N                    INCREASE\n         LA    R6,1(,R6)               N\n         STC   R6,N                    BY ONE\n         OI    BITS1,X'04'             SET LISTBIT TO ONE\n         B     ARRYNAME                GET NEXT EXTERNAL NAME\n*\n*        ARRAYMULT\n*\n*        MOVES OUT THE COMMA PREVIOUSLY FOUND\n*        SETS THE LISTBIT TO ZERO\n*        RETURNS TO ARRAYID (AVOIDS RESETING N TO ONE)\n*\nARRYMULT BAL   R12,COB\n         MVI   0(R3),XFCOMMA           MOVE OUT THE COMMA\n         LA    R3,1(,R3)\n         NI    BITS1,X'FB'             SET LISTBIT TO ZERO\n         B     ARRYID\n*\n*        LIST\n*\n*        USED FOR ARRAY AND SWITCH LIST PROCESSING\n*        MAKES THE TRT AGAINST ARTABLE AND UTILIZES MAINLOOP TO\n*        MOVE SCANNED BYTES AND BRANCH TO THE APPROPRIATE\n*        PROGRAM, EITHER A LIST PROGRAM OR ONE OF THE COMMON\n*        PROGRAMS. THE RETURN WILL BE TO LIST VIA R10\n*        R10 WILL POINT TO LIST UNTIL CHANGED BY ENDLIST TO\n*        POINT TO TESTLOOP AGAIN\n*\nLIST     BALR  R10,0                   SET RETURN REGISTER\n         LR    R4,R1                   START CHAR IN SCAN\n         LR    R9,R10                  RETURN FROM CIB\n         SR    R2,R2\n         TRT   0(73,R1),ARTABLE        SCAN AGAINST AR TABLE\n         B     CONT                    UTILIZE TESTLOOP\n*\n*        PONTLST\n*\n*        USES THE SAME POINTABEL AS MAINLOOP BUT ADDS 56 TO THE\n*        DISPLACEMENTS\n*\nPONTLST  LA    R1,1(,R1)               GET NEXT CHAR\n         SR    R2,R2\n         TRT   0(73,R1),PTTABLE        SCAN TO NEXT DELIMITER\n         LA    R6,BPRTAB               IN PTTABLE\n         L     R6,56(R6,R2)\n         BR    R6                      BRANCH ACCORDING TO 56+\n*                                      DISP+ BPRTAB\nPZETA    LA    R9,PONTLST+4            ZETA IN POINTLIST\n         B     CIB\n*\n*        RIGTPARL\n*\n*        MOVES OUT THE RIGHT PARENTHESIS\n*        DECREASES THE PARENTHESIS COUNT AND RETURNS TO LIST\n*\nRIGTPARL BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVI   0(R3),XFRBRAC           MOVE IN RIGHT BRACKET\n         LA    R3,1(,R3)\n         LA    R1,1(,R1)               GET NEXT  CHAR\n         LH    R6,C\n         BCTR  R6,0                    DECREASE PARENTHESIS COUNT\n         STH   R6,C\n         BR    R10\n*\n*        LEFTPARL\n*\n*        INCREASES THE PARENTHESIS COUNT\n*        CHECKS IF NEXT CHARACTER IS A SLASH, IF IT IS MOVES A\n*        SUBSCRIPT BRACKET OUTPUT, IF NOT MOVES A SIMPLE\n*        PARENTHESIS\n*\nLEFTPARL LH    R6,C                    INCREASE PARENTHESIS COUNT\n         LA    R6,1(,R6)\n         STH   R6,C\n         CLI   0(R1),XFLSQBR           LEFT SQUARE BRACKET ON INPUT ?\n         BE    LPARDQAA                YES, BRANCH\nLPARDQC3 LA    R1,1(,R1)               GET NEXT CHAR\n         CLI   0(R1),XFSLASH           SLASH ?\n         BNE   SIMPLPAR                NO, SIMPLE PARENTHESIS\nLPARDQAA BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVI   0(R3),XFLSQBR           YES, MOVE IN SQUARE BRACKET\nLPARDQ63 LA    R1,1(,R1)               INCREASE POINTERS\n         LA    R3,1(,R3)\n         BR    R10                     RETURN\n*\nSIMPLPAR CLI   0(R1),XFBLANK           NEXT CHAR BLANK ?\n         BE    LPARDQC3                YES\n         CLI   0(R1),XFZETA            NO, ZETA ?\n         BNE   SIMPLPAA\n         LA    R9,LPARDQC3+4\n         B     CIB\n*\nSIMPLPAA BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVI   0(R3),XFLBRAC           MOVE IN LEFT PARENTHESIS\n         B     LPARDQ63+4\n*\n*        COMMALST\n*\n*        INCREASES THE DIEMSION COUNTER D IF C THE PARENTHESIS\n*        COUNTER IS 1 FOR ARRAY OR 0 FOR SWITCH LIST\n*\nCOMMALST TM    BITS1,X'08'             AR BIT = 0 ?\n         BZ    COMMAG3\n         CLC   C(2),KF1+2              C=1 ?\n         BNE   COMMAJ2                 NO\nCOMMAH2  IC    R2,D                    INCREASE D-COUNTER\n         LA    R2,1(,R2)\n         STC   R2,D\nCOMMAJ2  BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVI   0(R3),XFCOMMA           MOVE COMMA TO OUTPUT\n         LA    R3,1(,R3)               INCREASE POINTERS\n         LA    R1,1(,R1)\n         BR    R10\n*\nCOMMAG3  CLC   C(2),KF0                C=0 ?\n         BE    COMMAH2\n         B     COMMAJ2\n*\n*        COLONLST\n*\n*        CORRECT ONLY FOR AN ARRAY LIST\n*\nCOLONLST TM    BITS1,X'08'             ARBIT ON ?\n         BZ    ERROR3                  E3 COLON DELETE D\n         BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVI   0(R3),XFCOLON           MOVE COLON TO O/P\n         LA    R3,1(,R3)\n         LA    R1,1(,R1)               GET NEXT CHAR\n         BR    R10                     AND RETURN\n*\n*        SEMCLST\n*\n*        IS ONLY VALID FOR AN SWITCH IN WHICH CASE INDICATES\n*        THE END OF THE SWITCH LIST\n*        THE NUMBER OF COMPONENTS IS INSERTED IN THE INTERNAL\n*        NAME\n*        EXIT IS TO ENDLIST\n*\nSEMCLST  TM    BITS1,X'08'             ARBIT=1 ?\n         BO    SEMCLER                 YES, ERROR\n*\n*        END OF SWITCH HANDLING\n*\n         CLI   D,16                    MORE THAN 15 COMPONENTS ?\n         BL    SEMCLAA\n         BAL   R6,ERR2\n*\n         DC    X'0021'                 E33\n*\n         B     COMPFIN\n*\nSEMCLAA  L     R7,AITL                 INSERT DIMENSION COUNTER\n         SR    R6,R6\n         IC    R6,D\n         SLA   R6,4                    IN LEFTMOST 4 BYTES\n         STC   R6,D\n         MVZ   9(1,R7),D               IN DECLARATION\n         B     ENDLIST                 GO TO ENDLIST\n*\n*        SEMCLER\n*\n*        ENTERED IF A SEMICOLON IS FOUND IN AN ARRAY LIST\n*        GIVES E32, CLEAR THE ITAB ENTRY SETS THE ARBIT OFF,\n*        DELTABIT ON AND RETURNS TO TEST VIA SEMCO\n*\nSEMCLER  BAL   R6,ERR2\n*\n         DC    X'0020'                 E32\n*\n         L     R15,AITL\n         BAL   R12,ITABCLEC            CLEAR THE ENTRY\n         OI    BITS1,X'20'             DELTABIT ON\n         NI    BITS1,X'F7'             ARRAYBIT OFF\n         B     SEMCO                   RETURN TO SEMCO, WILL RESET R10\n*\n*        SLASHLST\n*\n*        CHECKS IF NEXT CHARACTER IS A RIGHT PARENTHESIS\n*        IT IS NOT MOVES OUT A SLASH\n*        IF IT IS MOVES OUT A RIGHT SQUARE BRACKET\n*        DECREASES THE PARENTHESIS COUNT\n*        RETURNS TO LIST IF EITHER AN SWITCH LIST IS PROCESSED\n*        OR THE PARENTHESIS COUNT NOT IS 0\n*\nSLASHLST CLI   0(R1),XFRSQBR           RIGHT SQUARE BRACKET ON ENTRY ?\n         BE    SLASHRSB                YES, BRANCH\n         LA    R1,1(,R1)               GET NEXT CHAR\n         CLI   0(R1),XFRBRAC           RIGHT BRACKET ?\n         BNE   SLASHSE                 NO SOMETHING ELSE\nSLASHRSB BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVI   0(R3),XFRSQBR           TRANSFER A RIGHT SQUARE BRACKET\n         LA    R3,1(,R3)\n         LA    R1,1(,R1)\n         LH    R6,C                    DECREASE PARENTHESIS COUNT\n         BCTR  R6,0\n         STH   R6,C\n         TM    BITS1,X'08'             ARBIT = 1 ?\n         BZ    0(,R10)                 NO, RETURN\n         CLC   C(2),KF0                C=0 ?\n         BNE   0(,R10)                 NO, RETURN\n*\n*        ARRAY END HANDLING\n*\n*        INSERT THE DIMENSION COUNTERS IN THE INTERNAL NAME OR\n*        NAMES IF MORE THAN ONE ARRAY WITH THE SAME DIMENSIONS\n*\n*        IF A COMMA FOLLOWS THE CHARACTERISTICS AND THE PBN IS\n*        COPIED AND THE NEXT ARRAY NAME IS HANDLED\n*        IF A SEMICOLON FOLLOWS ENDLIST IS ACTIVATED\n*\n         IC    R2,D\n         CLI   D,16                    MORE THAN 16 DIMENSIONS ?\n         BL    SLASHLAA\n         BAL   R6,ERR2\n*\n         DC    X'0021'                 EOO\n*\n         B     COMPFIN\n*\nSLASHLAA SLA   R2,4                    SHIFT DIMENSION COUNTER\n         STC   R2,D\nSLASHREP L     R6,DIM\n         MVZ   0(1,R6),D               INSERT DIMENSION COUNTER\n         LA    R6,11(,R6)              INCREASE DIM POINTER\n         ST    R6,DIM\n         IC    R12,N                   DECREASE\n         BCTR  R12,0                   REP DECLARATION COUNTER\n         STC   R12,N\n         CLC   N(1),KF0                ZERO ?\n         BNE   SLASHREP                NO, INSERT DIM IN NEXT\n         B     SLASHEND+4              ITAB ENTRY\n*\nSLASHSE  CLI   0(R1),XFBLANK           BLANK ?\n         BE    SLASHLST\n         CLI   0(R1),XFZETA            ZETA ?\n         BNE   SLASHLBB\n         LA    R9,SLASHLST+4\n         B     CIB\n*\nSLASHLBB BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVI   0(R3),XFSLASH           MOVE IN A SLASH\n         LA    R3,1(,R3)\n         BR    R10\n*\nSLASHEND LA    R1,1(,R1)               GET NEXT CHAR\n         CLI   0(R1),XFCOMMA           COMMA ?\n         BNE   SLSHENSE                NO SOMETHING ELSE\n         BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVI   0(R3),XFCOMMA           MOVE IN A COMMA\n         LA    R3,1(,R3)\n         L     R9,AITL                 SAVE AITL\n         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY\n         MVC   6(3,R15),6(R9)          COPY ID AND PBN FIELDS\n         B     ARRYNAME                GET NEXT NAME\n*\nSLSHENSE CLI   0(R1),XFBLANK           BLANK ?\n         BE    SLASHEND\n         CLI   0(R1),XFZETA            ZETA ?\n         BNE   SLASHLCC\n         LA    R9,SLASHEND+4\n         B     CIB\n*\nSLASHLCC LA    R6,SLASHERR             RETURN IF NO SEMICOLON FOUND\n         BAL   R12,FINDSEMC            LOOK FOR SEMICOLON\n*\n*        ENDLIST\n*\n*        SETS DELTABIT TO ONE, ARBIT TO ZERO, CLEARS NEXT ITABENTRY\n*\n*        RESETS THE RETUN REGISTER TO TEST\n*        RETURNS TO TESTLOOP VIA SEMCO\n*\nENDLIST  OI    BITS1,X'20'             DELTA BIT =1\n         NI    BITS1,X'F7'             ARBIT= 0\n         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY\n         LA    R10,TESTLOOP            RESET RETURN REG TO MAINLOOP\n         B     SEMCO                   GO TO SEMICOLON PROGRAM\n*\nSLASHERR BAL   R6,ERR2\n*\n         DC    X'0022'                 E34\n*\n         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY\n         B     ARYEXITA                CLEAR ENTRY IN ITAB AND RETURN\n*\n*        SWITCH\n*\n*        TESTS ON PROBIT (SPECIFICATION) AND BEGBIT (PROGRAM\n*        BLOCK HEAD)\n*        INSERTS CHARACTERISTICS AND PBN IN INTERNAL NAME\n*        INCREASES AND INSERTS LABELNUMBER LN\n*        MOVES 0A SWITCH TO OUTPUT\n*        SETS ARBIT TO ZERO\n*        CHECKS THE NAME FOR VALIDITY AND MOVES FIRST 6\n*        CHARACTERS TO OUTPUT AND ITAB VIA IDCHECK\n*        SEARCHES FOR ASSIGN TO FOLLOW THE SWITCHNAME\n*        INITIALIZES C PARENTHESIS COUNT AND D DIMENSION COUNT\n*        WITH ZERO AND N WITH ONE\n*        EXITS TO LIST\n*\nSWITCH   TM    BITS1,X'40'             PROCEDURE HEAD ?\n         BO    SPECENT                 YES\n         TM    BITS1,X'80'             BLOCK START ?\n         BZ    SWITCHAA\n         ST    R9,SAVE1\n         BAL   R9,BEG1                 YES, PROCESS BLOCK BEGIN\n         L     R9,SAVE1\nSWITCHAA L     R15,AITL                MOVE IN ID FIELDS\n         MVI   6(R15),X'CC'\n         MVI   7(R15),X'0C'\n         L     R12,LPBP\n         MVC   8(1,R15),10(R12)        AND PBN- NUMBER\n         LH    R12,LN                  INCREASE LABEL NUMBER\n         LA    R12,4(,R12)\n         CLC   LN(2),KH4096            LN OVERFLOW ?\n         BL    SWITCHBB\n         BAL   R6,ERR7\n*\n         DC    X'04D8'                 E216\n*\n         LA    R12,LATBEG              RESET LN\nSWITCHBB STH   R12,LN\n         MVC   9(2,R15),LN             MOVE IN LABEL NUMBER\n         BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVI   0(R3),X'0A'             MOVE IN $ SWITCH\n         LA    R3,1(,R3)\n         NI    BITS1,X'F7'             SET ARBIT TO ZERO\nSWTCHB3  LA    R1,1(,R1)               GET FIRST CHAR\n         CLI   0(R1),XF9               LETTER ?\n         BL    SWTCHNSE                NO\n         BAL   R6,IDCHECK1             INITIALIZE N WITH ONE\nSWITCHSE CLI   0(R1),XFBLANK           BLANK ?\n         BE    IDCHECK2\n         CLI   0(R1),XFCOLON           COLON ?\n         BE    SWCOLON\n         CLI   0(R1),XFPERIOD          PERIOD ?\n         BNE   SWITCHER\nSWPOINT  LA    R1,1(,R1)               ONE POINT HAS BEEN FOUND\n         CLI   0(R1),XFPERIOD          ONE MORE PERIOD ?\n         BE    SWCOLON\n         CLI   0(R1),XFEQUAL           EQUAL ?\n         BE    EQUALOK\n         CLI   0(R1),XFBLANK           BLANK ?\n         BE    SWPOINT\n         CLI   0(R1),XFZETA            ZETA ?\n         BNE   SWITCHER\n         LA    R9,SWPOINT+4\n         B     CIB\n*\nSWCOLON  LA    R1,1(,R1)               A COLON OR TWO POINTS ARE FOUND\n         CLI   0(R1),XFEQUAL           EQUAL ?\n         BE    EQUALOK                 YES '= OR  = OR  = ARE FOUND\n         CLI   0(R1),XFBLANK           BLANK ?\n         BE    SWCOLON\n         CLI   0(R1),XFZETA            ZETA ?\n         BNE   SWITCHER\n         LA    R9,SWCOLON+4\n         B     CIB\n*\nEQUALOK  BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVI   0(R3),XFASSIGN          MOVE IN ASSIGNMENT\n         LA    R3,1(,R3)               INCREASE O/P POINTER\n         SR    R6,R6\n         STH   R6,C                    C=0\n         MVI   N,X'01'                 N=1\n         STC   R6,D                    D=0\n         LA    R1,1(,R1)               GET NEXT CHAR\n         B     LIST                    GO TO PROCESS LIST\n*\nSWTCHNSE CLI   0(R1),XFBLANK           BLANK ?\n         BE    SWTCHB3\n         CLI   0(R1),XFZETA            ZETA ?\n         BNE   SWTCHNAA\n         LA    R9,SWTCHB3+4\n         B     CIB\n*\nSWTCHNAA BAL   R6,ERR7\n*\n         DC    X'0405'                 E5\n*\n         B     SWTCHNBB\n*\nSWITCHER BAL   R6,ERR2\n*\n         DC    X'0010'                 E16\n*\n         BAL   R12,COB\n         MVI   0(R3),X'3D'             MOVE IN RHA\n         LA    R3,1(,R3)\nSWTCHNBB L     R6,AITL                 CLEAR ITAB-ENTRY\n         MVI   0(R6),0\n         MVC   1(10,R6),0(R6)\n         B     COMERR                  COM-PRGM ERROR-ENTRY\n*\n*        STRING\n*\n*        MOVES INTERNAL NAME TO OUTPUT\n*\n*        START ADDR IS IN PRPT THE STRINGS TWO FIRST BYTES\n*        SPECIFIES ITS LENGTH THE TRT TESTS ONLY FOR APOSTROPHE\n*        AND ZETA\n*\n*        NOTE -\n*        THE STRING IS TAKEN FROM THE PRINT AREA (OR DUMMY) AND\n*        MOVED TO KOPOOL TO CAPTURE THE STRING IN EBCDIC\n*\nSTRING   LA    R0,6(,R3)               PROVIDE 6 BYTES IN O/P\n         BAL   R12,COBSPEC\n         MVC   0(4,R3),SINT            MOVE FIRST 4 BYTES OF INTERNAL\n         MVC   4(2,R3),PRPT+2          NAME AND LAST TWO BYTES IN O/P\n         LA    R3,6(,R3)\n         L     R14,PRPT                GET CURRENT DISP WITHIN KOPOOL\n         LA    R14,2(,R14)             INCREASE FOR LEN SPECIFICATION\n         C     R14,KF4095              STRING POOL OVERFLOW ?\n         BNH   STRAAA\n         BAL   R12,E23\nSTRAAA   LA    R1,1(,R1)\n         MVC   SQC,KF1                 STRINQUOTE=1\nCDE2     LA    R9,*                    PROVIDE RETURN ADDR FOR CIB\n         LR    R4,R1\n         SR    R2,R2\n         TRT   0(73,R1),STRTABLE       SCAN STRING\n         LR    R7,R1                   COMPUTE NUMBER OF SCANNED BYTES\n         SR    R7,R4\n         BZ    SROUT\n         LA    R0,0(R7,R14)            STRINGPOOL OVERFLOW ?\n         C     R0,KF4095\n         BNH   STRBBB\n         BAL   R12,E23\nSTRBBB   BCTR  R7,0                    MOVE SCANNED BYTES TO KOPOOL\n         L     R6,AKOPOOL\n         LA    R15,0(R6,R14)           COMPUTE NEW KOPOOL ADDR\n         LA    R0,WA                   COMPUTE ADDR\n         LR    R12,R4                  OF STRING IN\n         SR    R12,R0                  PRINT BUFFER\n         L     R6,APRNTAR              R6 -> PRINT BUFFER\n         LA    R12,10(R6,R12)          GET STRING FROM PRINT BUFFER\n         EX    R7,MV1\n         LA    R14,1(R7,R14)           INCREASE PRPT\nSROUT    L     R12,BPRTAB(R2)          BRANCH TO APPROPRIATE\n         BR    R12                     SUBROUTINE\n*\n*        QUOTE\n*\n*        CHECKS IF THE APOSTROPHE IS THE START OF A QUOTE SIGN\n*\n*        USES REPL TO MOVE THE FOUND CHARACTER(S) TO KOPOOL\n*        REPL+1 WILL BE A LEFT OR RIGHT PARENTHESIS\n*        HOW MUCH OF REPL THAT IS TO BE MOVED TO KOPOOL IS KEPT\n*        TRACK OF IN R7\n*        IF A COMPLETE LEFT STRING QUOTE IS FOUND THE STRING\n*        QUOTE COUNTER IS INCREASED AND THE REPL MOVED TO\n*        KOPOOL\n*        IF A COMPLETE RIGHT STRING QUOTE IS FOUND IT IS CHECKED\n*        IF IT IS THE CLOSING ONE FOR THE STRING (SQC=0) IF IT\n*        IS ENDSTRING IS ACTIVATED IF NOT REPL IS MOVED TO KOPOOL\n*        AFTER SQC IS DECREASED\n*        IF NO COMPLETE QUOTE IS FOUND THE CHARACTER(S) FOUND\n*        ARE MOVED TO KOPOOL FROM REPL, LENGTH SPECIFIED BY R7\n*        AND THE SCANNING OF THE STRING IS REASSUMED\n*\nQUOTE    LA    R1,1(,R1)\n         LA    R9,*+4\n         CLI   0(R1),XFRBRAC           RIGHT BRACKET IN SOURCE ?\n         BNE   NORIP                   NO, BRANCH\n         MVI   REPL+1,C')'             MAKE REPL A RIGHT STRING QUOTE\n         B     TESTAPOS                LOOK FOR APOSTROPHE\n*\nNORIP    CLI   0(R1),XFLBRAC           LEFT BRACKET ?\n         BNE   TESTZETA                NO\n         MVI   REPL+1,C'('             MAKE REPL A LEFT STRING QUOTE\n         B     TESTAPOS                LOOK FOR APOSTROPHE\n*\nTESTZETA CLI   0(R1),XFZETA            ZETA ?\n         BE    CIB                     YES\n         LA    R7,1                    NO MOVE STRING ONLY FIRST QUOTE\n         B     CID1                    MOVE REPL\n*\nTESTAPOS LA    R1,1(,R1)\n         LA    R9,*+4                  NEW RETURN FOR CIB\n         CLI   0(R1),XFQUOTE           SECOND QUOTE ?\n         BE    CID                     YES\n         CLI   0(R1),XFZETA            ZETA\n         BE    CIB                     YES\n         LA    R7,2                    NO, MOVE TO STRING ONLY FIRST\n         B     CID1                    QUOTE AND THE BRACKET\n*\nCID      LA    R1,1(,R1)\n         L     R12,SQC\n         CLI   REPL+1,C'('             LEFT STRING QUOTE ?\n         BNE   CIDAA                   NO\n         LA    R12,1(,R12)             YES, INCREASE STRING QUOTE COUNT\n         B     CIDBB\n*\nCIDAA    S     R12,KF1                 RIGHT QUOTE DECREASE QUOTE COUNT\n         BNP   ENDSTRIN                BRANCH IF LAST QUOTE\nCIDBB    ST    R12,SQC\n         LA    R7,3\nCID1     LA    R0,0(R7,R14)\n         C     R0,KF4095               STRING POOL OVERFLOW ?\n         BNH   CIDCC\n         BAL   R12,E23\nCIDCC    L     R6,AKOPOOL\n         LA    R6,0(R6,R14)            COMPUTE NEW KOPOOL ADDR\n         BCTR  R7,0\n         EX    R7,MV2                  MOVE CONTENTS OF REPL TO KOPOOL\n         LA    R14,1(R7,R14)           INCREASE PRPT\n         B     CDE2                    RESUME SCAN OF STRING\n*\n*        ENDSTRIN\n*\n*        INCREASES PRPT\n*        PUTS THE LENGTH OF THE STRING (DIFFERENCE BETWEEN NEW\n*        AND OLD PRPT) AS TWO FIRST BYTES IN THE STRING\n*\nENDSTRIN L     R9,PRPT                 COMPUTE LENGTH AND PUT IT\n         STH   R14,PRPT+2              AS THE FIRST 2 BYTES IN STRING\n         L     R6,AKOPOOL              AND\n         LA    R12,0(R6,R9)            STORE NEW DISPLACEMENT\n         SR    R14,R9                  IN PRPT\n         STCM  R14,B'0011',0(R12)\n         BR    R10                     RETURN TO TESTLOOP\n*\nE23      NOP   E23AA                   NO BRANCH FIRST TIME\n         BAL   R6,ERR7                 RECORD ERROR\n*\n         DC    X'0417'                 E23\n*\nE23AA    OI    E23+1,X'F0'             NO ERROR RECORDING NEXT\n         LA    R14,64\n         ST    R14,PRPT                RESET PRPT TO 64 AGAIN\n         BR    R12                     RESUME STRING PROCESSING\n*\nMV1      MVC   0(1,R15),0(R12)\nMV2      MVC   0(1,R6),REPL\n*\nSQC      DC    F'0'                    STRING QUOTE COUNTER (AFTER MV2\nSINT     DC    X'2EC90000'             STRING INTERNAL NAME OF\n*                                      THE CONSTANT POOL NAMED KOPOOL\nREPL     DC    C''' '''                BUCKET TO BUILD STRING QUOTES\n*\n*        TYPPROC\n*\n*        TEST PRO AND BEGBIT (FORMAL PARAMETER, BLOCKSTART)\n*        MOVE PHI TO OUTPUT\n*        INSERT CHARACTERISTICS IN INTERNAL NAME\n*        JOIN PROCEDURE PROGRAM\n*\nTYPPROC  TM    BITS1,X'40'             PROCEDURE PROCEDED ?\n         BZ    TYPPROCA                NO\n         MVI   KB,X'CA'                YES, MOVE IN IDFIELD\n         OI    KB+1,X'C0'\n         B     IDCHECK\n*\nTYPPROCA TM    BITS1,X'80'             BEGBIT ON ?\n         BZ    TYPPROCB                NO\n         ST    R9,SAVE1\n         BAL   R9,BEG1                 GOTO PROCESS PROGRAM BLOCK HEAD\n         L     R9,SAVE1\nTYPPROCB LA    R0,4(,R3)               PROVIDE FOUR BYTES IN OUTPUT\n         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P\n         MVI   0(R3),X'0F'             MOVE PHI TO O/P\n         L     R15,AITL\n         XI    7(R15),X'F0'            MOVE IN THE IDCODE\n         MVI   6(R15),X'CA'            TO ITAB\n         B     PROCEAG1                JOIN THE PROCEDURE PROGRAM\n*\n*        PROCEDURE\n*\n*        TEST PRO AND BEGBIT\n*        MOVE PI TO OUTPUT\n*        INSERT CHARACTERISTICS IN INTERNAL NAME\n*        TYPE PROCEDURE JOINS PROCEDURE PROGRAM AT THIS POINT\n*        IF ALPHA IN STACK, PRECOMPILED PROCEDURE, THE STARTBIT\n*        IS TURNED ON.\n*        PROC IS PUT IN STACK.\n*        PROGRAM BLOCK AND ITAB GROUP NUMBER ARE INCREASED.\n*        THE NEW PBN IS INSERTED IN THE INTERNAL NAME.\n*        LABELNUMBER IS INCREASED AND INSERTED IN THE INTERNAL\n*        NAME.\n*        THE SURRONDING BLOCKNUMBET IS ENTERED IN PBTAB1.\n*        THE SURROUNDING ITAB GROUP NUMBER IN GROUPTABLE\n*        SEMCNT IS ENTERED IN SCTAB\n*        PROBIT AND IDBIT ARE SET TO ONE\n*        PROBIT WILL STAY AS ONE TILL THE WHOLE PROCEDURE HEAD\n*        IS PROCESSED. THE IDBIT IS ONLY ONE WHILE THE PROCEDURE\n*        NAME IS PROCESSED\n*        THE FM (FORMAL PARAMETER) BIT IS ONE WHEN THE FORMAL\n*        PARAMETER LIST IS PROCESSED\n*        THE ITAB GROUP NUMBER IS MOVED TO O/P\n*\nPROCEDUR TM    BITS1,X'40'             PROBIT ON ?\n         BO    SPECENT                 YES, GOTO IDCHECK VIA SPECENT\n         TM    BITS1,X'80'             BEGBIT ON ?\n         BZ    PROCEDAA                NO\n         ST    R9,SAVE1\n         BAL   R9,BEG1                 GOTO PROCESS PROGRAM BLOCK HEAD\n         L     R9,SAVE1\nPROCEDAA LA    R0,4(,R3)               PROVIDE FOUR BYTES IN OUTPUT\n         BAL   R12,COBSPEC\n         MVI   0(R3),X'0E'             TRANSFER PI IN OUTPUT BUFFER\n         L     R15,AITL\n         MVI   6(R15),X'CA'            CONSTRUCT FIRST PART\n         MVI   7(R15),X'C0'            INTERNAL NAME ?\nPROCEAG1 L     R14,SP\n         CLI   0(R14),0                ALPHA IN STACK ?\n         BNE   L3\n         OI    BITS2,X'20'             TURN ON THE STARTBIT\n         OI    BITS3,PROCESD\nL3       LA    R14,1(,R14)             INCREASE STACK POINTER\n         C     R14,ATOPSTAK            STACK OVERFLOW ?\n         BL    L3AA                    NO, BYPASS ERROR\n         BAL   R6,ERR4\n*\n         DC    X'0414'                 E20\n*\nL3AA     MVI   0(R14),X'0C'            PUT PROC IN STACK\n         ST    R14,SP\n         CLI   PBC,X'FF'               PBN OVERFLOW ?\n         BNE   L3BB                    NO\n         BAL   R6,ERR4\n*\n         DC    X'0416'                 E22\n*\nL3BB     IC    R2,PBC\n         LA    R2,1(,R2)               INCR PROGRAM BLOCK NUMBER\n         STC   R2,8(,R15)              INSERT PBN IN INTERVAL NAME\n         STC   R2,PBC\n         LA    R14,PBTAB1(R2)          CONSTRUCTION\n         L     R6,LPBP                 PBTAB1-ENTRY\n         MVC   0(1,R14),10(R6)\n         AR    R2,R2\n         LA    R14,SCTAB(R2)\n         MVC   0(2,R14),SEMCNT         MAKE ENTRY IN SCTAB\n         LH    R14,LN                  INCREASE\n         LA    R14,4(,R14)             LABEL NUMBER BY 4\n         CLC   LN(2),KH4096            LN OVERFLOW ?\n         BL    L3CC\n         BAL   R6,ERR7\n*\n         DC    X'04D8'                 E216\n*\n         LA    R14,LATBEG              RESET LN\nL3CC     STH   R14,LN\n         L     R15,AITL\n         MVC   9(2,R15),LN             PUT LN IN INTERNAL NAME\n         LH    R15,IGC                 INCREASE\n         LA    R15,1(,R15)             ITAB GROUP NUMBER\n         STH   R15,IGC\n         MVC   1(2,R3),IGC             INSERT IT IN OUTPUT BUFFER\n         LA    R3,3(,R3)\n         AR    R15,R15\n         AH    R15,IGC\n         A     R15,AGT\n         L     R7,LIGP\n         MVC   0(2,R15),8(R7)          CONSTRACT ENTRY\n         MVI   2(R15),0                IN GROUP TABLE\n         NI    0(R15),X'7F'            CLEAR POSSIBLE PHI IND.\n         MVC   PRIMPAR(4),KF0          CLEAR PRIMPAR WITH ZEROS\n         OI    BITS1,X'50'             PROBIT =1,IDBIT =1\n         MVI   PZ,0                    SET PARAMTER COUNT TO ZERO\n*\n*        PROCID\n*\n*        PROCESSES PROCEDURE NAME (IDBIT=1) AND THE FORMAL\n*        PARAMETER LIST (IDBIT=0).\n*        CHECKS THE NAMES FOR VALIDITY AND MOVES THEM TO ITAB\n*        AND OUTPUT. THIS IS DONE VIA IDCHECK1.\n*\nPROCID   LA    R1,1(,R1)\n         CLI   0(R1),XFA               IDENTIFIER STARTS WITH LETTER ?\n         BL    NOLETTER\n         BAL   R6,IDCHECK1             CHECK AND MOVE IDENTIFIER\n*                                      TO O/P AND ITAB\n         CLI   0(R1),XFBLANK           BLANK ?\n         BE    IDCHECK2\n         TM    BITS1,X'10'             IDBIT ONE ?\n         BZ    EDA1                    GOTO PROCESS FORMAL PARAM NAME\n*\n*        PROCEDURE NAME\n*\n*        CHECKS IF NAME IS FOLLOWED BY A FORMAL PARAMETER LIST\n*        FOLLOWS OR ; NO PARAMETERS.\n*        CHECKS IF PROCEDURE IS TO BE PRECOMPILED, IF YES THE\n*        NAME IN EXTERNAL FORM AND EXPANDED WITH TWO ZEROS IS PUT\n*        FOR AN ESDCARD IF SYLIN OR DECK HAS BEEN SPECIFIED\n*        THE NEW BLOCK ENTRY IS DONE IN ITAB\n*        ADDR OF SURROUNDING BLOCK AND ITAB GROUP, PBN AND IGN\n*        ARE INSERTED\n*        IF TYPEPROCEDURE, BIT 0 IN BYTE 8 IS TURNED ON AND A\n*        SECOND ENTRY OF THE NAME IS DONE AFTER THE HEAD ENTRY\n*        IDBIT IS SET TO ZERO, FMBIT TO ONE\n*        IF THE NAME WAS FOLLOWED BY A SEMICOLON THE SEMCO IS\n*        ACTIVATED\n*        IF THE NAME WAS FOLLOWED BY A (PROCID IS ACTIVATED TO\n*        PROCESS THE NAME IN THE LIST\n*\n         CLI   0(R1),XFLBRAC           IDENTIFIER FOLLOWED BY ) ?\n         BE    EBF4\n         LA    R6,ERROR16              RETURN IF NOT SEMICOLON\n         BAL   R12,FINDSEMC            SEMICOLON ?\n         OI    BITS1,X'20'             YES, DELTABIT = 1\nEBF4     TM    BITS3,PROCESD\n         BZ    DEL1                    NO\n         NI    BITS3,PROCOFF\n         TM    COMPFLGS+1,NLOAD+NDECK  DECK AND OR LOAD SPECIFIED ?\n         BO    DEL1                    NO, NO NEED FOR ESD CARD\n         L     R15,AITL\n         MVC   ESDNAME(6),0(R15)       MOVE IN AND\n         TR    ESDNAME(6),TRINTEXT     TRANSLATE EXTERNAL NAME\nDEL1     TM    BITS1,X'20'             DELTABIT = 1 ?\n         BO    ECA3\n         BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         MVI   0(R3),XFLBRAC           INSERT )\n         LA    R3,1(,R3)\nECA3     BAL   R12,ITABCLEA\n         MVC   0(4,R15),LIGP           MOVE ADDR HEADING ENTRY OF\n*                                      EMBRACING ITAB GROUP\n         MVC   4(4,R15),LPBP           AND PBLOCK TO ENTRY\n         MVC   8(2,R15),IGC            INSERT CURRENT IGN\n         MVC   10(1,R15),PBC           AND CURRENT PBN\n         ST    R15,LIGP                NEW VALUE OF LIGP\n         ST    R15,LPBP                AND LPBP\n         S     R15,KF11                DECREASE R15 BY 11\n         TM    7(R15),X'03'            TYPE PROCEDURE ?\n         BNZ   TPROHEAD\n         LA    R15,22(,R15)            IF NO INCREASE ITAB POINTER\nECJ3     BAL   R12,ITABCLEC\n         OI    BITS3,FMBIT             FMBIT\n         TM    BITS1,X'20'             DELTABIT = 1 ?\n         BO    SEMCO                   YES, BRANCH TO SEMICOLON PROGRAM\n         NI    BITS1,X'EF'             IDBIT'= 0\n         B     PROCID                  CHECK NEXT IDENTIFIER\n*\n*        CONSTRUCT TYPE PROCEDURE ENTRIES\n*\nTPROHEAD OI    19(R15),X'80'           FLAGBIT IN IGN IS SET ON\n         LA    R0,22(,R15)             ONE MORE ENTRY IN ITAB AVAIL\n         C     R0,ELI\n         BNE   TPROHEAA\n         BAL   R6,ERR4\n*\n         DC    X'04D5'                 E213\n*\nTPROHEAA MVC   22(11,R15),0(R15)       ENTER PROCEDURE NAME ONCE MORE\n         XI    28(R15),X'08'           NO-ASSIGNMENTBIT IS SWITCHED OFF\n         LA    R15,33(,R15)            INCREASE ITAB POINTER\n         B     ECJ3                    BRANCH BACK TO MAIN PROGRAM\n*\nNOLETTER CLI   0(R1),XFBLANK           BLANK INSTEAD OF LETTER ?\n         BE    PROCID\n         LA    R9,PROCID+4\n         CLI   0(R1),XFZETA            ZETA ?\n         BE    CIB                     CHANGE INPUT BUFFER\n         TM    BITS1,X'10'\n         BO    ERROR16A\n         LA    R15,PROCID              LOAD RETURN ADDR\n         B     IERSPEC                 BRANCH TO IDENTIFIER ERROR RTN\n*\nERROR16  BAL   R12,COB\n         MVI   0(R3),X'3D'             MOVE IN RHA\n         LA    R3,1(,R3)\n         TM    BITS1,X'10'             PROC NAME UNDER PROCESS ?\n         BO    PNAMERR                 YES\n         LA    R15,PROCID              LOAD RETURN ADDR\n         B     IER                     GO TO IDENTIFIER ERROR ROUTINE\n*\nERROR16A BAL   R6,ERR7\n*\n         DC    X'0405'                 E5\n*\n         B     PNAMERRA\n*\nPNAMERR  BAL   R6,ERR2\n*\n         DC    X'0010'                 E16\n*\nPNAMERRA L     R7,AITL\n         MVI   0(R7),0                 CLEAR ERRONEOUS NAME\n         MVC   1(5,R7),0(R7)\n         LA    R6,PROCIDSE             THE PROCEDURE HEAD SHOULD\n         BAL   R12,FINDSEMC\n         B     EBF4-4                  BE FOLLOWED BY EITHER  ( OR .,\n*\nPROCIDSE CLI   0(R1),X'06'             KEEP LOOPING UNTIL :-\n         BE    EBF4                    LEFT PARENTHESIS FOUND\n         BAL   R12,FINDSEMC-4\n         B     EBF4-4                  SEMICOLON FOUND\n*\n*        FORMAL PARAMETER LIST\n*\n*        IF A COMMA TERMINATES THE NAME, THE COMMA IS TRANSFERED\n*        TO OUTPUT AND THE PARAMETER COUNT (PZ) IS INCREASED BY\n*        ONE. AND PROCID IS ACTIVATED AGAIN TO TAKE NEXT NAME.\n*        IF A ) FOLLOWED BY A SEMICOLON TERMINATES THE NAME\n*        PROCFIN IS ACTIVATED.\n*        IF A ) BUT NO SEMICOLON TERMINATES THE NAME PROCDEL IS\n*        ACTIVATED.\n*        IS SOMETHING ELSE IS FOUND RHA IS MOVED TO OUTPUT, THE\n*        PARAMETER COUNT IS NOT INCREASED AND IER ACTIVATED\n*        (NOLETTER, ERROR16).\n*\nEDA1     CLI   0(R1),XFCOMMA           COMMA TERMINATES IDENTIFIER ?\n         BNE   PAR\nPROCEND  IC    R2,PZ                   INCREASE\n         LA    R2,1(,R2)               PARAMETER\n         STC   R2,PZ                   COUNT BY ONE\n         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY\n         BAL   R12,COB                 CHECK IF O/P AREA FILLED\n         CLI   0(R1),XFCOMMA           COMMA ?\n         BNE   PROCFIN\n         MVI   0(R3),XFCOMMA           MOVE COMMA TO OUTPUT BUFFER\n         LA    R3,1(,R3)               INCREASE OUTPUT POINTER\n         B     PROCID                  BRANCH TO CHECK THE\n*                                      NEXT IDENTIFIER\nPAR      CLI   0(R1),XFRBRAC           ) TERMINATES IDENTIFIER ?\n         BE    PROCEND\n         BAL   R12,COB\n         MVI   0(R3),X'3D'             MOVE IN RHA\n         LA    R3,1(,R3)\n         LA    R15,PROCID              NOTE RETURN ADDR\n         B     IER                     BRANCH TO IER\n*\n*        PROCFIN\n*\n*        THE PARAMETER LIST HAS BEEN COMPLETLY CHECKED\n*        THE RIGHT PARENTHESIS IS MOVED TO OUTPUT\n*        DELTABIT IS SET TO ONE\n*        THE PARENTHESIS COUNT IS INSERTED IN THE PROCEDURE NAME\n*        (NAMES IF TYPEPROCEDURE)\n*        FMBIT IS TURNED OFF\n*        THE RETURN TO TEST IS VIA SEMCO\n*        IF SOMETHING ELSE, E5 OR E16 IS GENERATED AND\n*        EVERYTHING SKIPPED TILL A (OR A; IS FOUND (NOLETTER,\n*        PNAMERR)\n*\nPROCFIN  LA    R1,1(,R1)\n         LA    R6,PROCDEL              RETURN IF NO SEMICOLON\n         BAL   R12,FINDSEMC            SEMICOLON ?\n         BAL   R12,COB\n         LA    R14,SEMCO               EXIT FROM PROCEDUR\nSCYES3   MVI   0(R3),XFRBRAC           MOVE RIGHT PARENTHESIS\n         LA    R3,1(,R3)\n         OI    BITS1,X'20'             DELTABIT'=1\n         CLI   PZ,16                   MORE THAN 15 PARAMETERS ?\n         BL    SCYES3A\n         BAL   R6,ERR2B\n*\n         DC    X'0024'                 E36\n*\n         B     COMPFIN\n*\nSCYES3A  L     R15,LPBP\n         S     R15,KF11                R15 CONTAINS ADDR OF PROC ENTRY\n         SR    R6,R6\n         IC    R6,PZ\n         SLA   R6,4(0)\n         STC   R6,PZ\n         MVZ   9(1,R15),PZ             INSERT NUMBER OF PARAMETERS INTO\n*                                      INTERNAL NAME OF THE PROCEDURE\n         SRA   R6,4\n         STC   R6,PZ                   NOTE NUMBER OF PARAMETER\n         NI    BITS3,FMOFF             FMBIT=0\n         TM    19(R15),X'80'           TYPE PROCEDURE ?\n         BZ    TESTPAR                 NO\n         MVZ   31(1,R15),9(R15)        INSERT NUMBER OF PARAMETERS INTO\n*                                      SECOND NAME ENTRY IN ITAB\n         LA    R15,33(,R15)            GET ADDR OF FIRST PARAMETER\n         B     TESTPARA\n*\nTESTPAR  LA    R15,22(,R15)\nTESTPARA CLI   PZ,0                    ANY PARAMETERS ?\n         BER   R14                     NO, BRANCH TO SEMCO OR COMERR\n         ST    R15,PRIMPAR             YES, SAVE ADDR OF FIRST\n         BR    R14                     BRANCH TO SEMCO OR COMERR\n*\n*        PROCDEL\n*\n*        A RIGHT PARENTHESIS HAS BEEN FOUND IN THE LIST THAT NOT\n*        WAS FOLLOWED BY A .,\n*        IF A LETTERSTRING IS FOUND, NOTHING BUT LETTERS AND\n*        BLANKS FOLLOWED BY ..(A COMMA IS MOVED TO OUTPUT AND\n*        PROCID ACTIVATED TO TAKE NEXT NAME.\n*        IF ANYTHING ELSE IS FOUND E37 IS GENERATED AND COMERR\n*        ACTIVATED TO SKIP TO NEXT SEMICOLON\n*        ADDR OF COMERR IS PUT IN R14\n*\nPROCDEL  LA    R9,DELCHECK+4\nDELCHECK LA    R1,1(,R1)\n         CLI   0(R1),XFA               LETTER ?\n         BNL   DELCHECK\n         CLI   0(R1),XFZETA            ZETA ?\n         BE    CIB\n         CLI   0(R1),XFCOLON           COLON ?\n         BE    DELCOLON\n         CLI   0(R1),XFBLANK\n         BE    DELCHECK\n         CLI   0(R1),XFPERIOD          PERIOD ?\n         BNE   ERROR37\nDELPOINT LA    R1,1(,R1)\n         CLI   0(R1),XFPERIOD          ONE MORE PERIOD ?\n         BE    DELCOLON\n         CLI   0(R1),XFBLANK\n         BE    DELPOINT\n         CLI   0(R1),XFZETA            ZETA ?\n         BNE   ERROR37\n         LA    R9,DELPOINT+4\n         B     CIB\n*\nDELCOLON LA    R1,1(,R1)\n         CLI   0(R1),XFLBRAC           LEFT BRACKET ?\n         BE    DELPAREN\n         CLI   0(R1),XFBLANK           BLANK ?\n         BE    DELCOLON\n         CLI   0(R1),XFZETA            ZETA ?\n         BNE   DELCOLAA\n         LA    R9,DELCOLON+4\n         B     CIB\n*\nDELCOLAA BCTR  R1,0                    NO BRACKETS FOLLOWS THE COLON\n         B     ERROR37                 RESET R1 AND GOTO ERROR 37\n*\nDELPAREN BAL   R12,COB\n         MVI   0(R3),XFCOMMA           MOVE COMMA TO OUTPUT INSTEAD OF\n         LA    R3,1(,R3)               DELIMITER INCREASE O/P POINTER\n         B     PROCID                  RETURN TO PROCEDURE CHECKING\n*\nERROR37  BAL   R6,ERR2B\n*\n         DC    X'0025'                 E37\n*\n         LA    R14,COMERR\n         B     SCYES3\n*\n*        ENDMISS\n*\n*        ENTERED IF END OF DATA FOUND BEFORE LOGICAL\n*        PROGRAM END IS FOUND BY SCAN I/II\n*        CLOSES WHAT REMAINS OPEN IN STACK\n*        GENERATES PATTERN FOR ERROR MESSAGE 39\n*\nENDMISS  TM    BITS2,STARTBIT          FIRST BEGIN FOUND ?\n         BO    ENDMISSA                YES\n         BAL   R6,ERR4\n*\n         DC    X'042C'                 E44 NOTHING PROCESSED\n*\nENDMISSA OI    BITS1,TERBIT\nTERMSEAC LA    R4,TERMSEAC             RETURN FOR PBLCKEND PROG\n         L     R15,SP                  GET STACK POINTER\n         CLI   0(R15),X'04'            BETA IN STACK ?\n         BE    STEPUP\n         CLI   0(R15),X'08'            BEGIN ?\n         BE    STEPUP\n         CLI   0(R15),X'10'            PROC* ?\n         BNE   TERMBRNC\nSTEPUP   LH    R6,ENDCOUNT             INCREASE END COUNT\n         LA    R6,1(,R6)\n         STH   R6,ENDCOUNT\nTERMBRNC IC    R2,0(,R15)\n         L     R6,TERMTAB(R2)          BRANCH ACORDING TO STACK BYTE\n         BR    R6\n*\nTERMTAB  DC    A(ERROR39)              +00\n         DC    A(PBLCKEND)             +04 BEGIN\n         DC    A(TERMBGN)              +08 BETA\n         DC    A(PBLCKEND)             +12 PROC\n         DC    A(PBLCKEND)             +16 PROC*\n         DC    A(PBLCKEND)             +20 PROC**\n         DC    A(FOREND)               +24 FOR\n*\nTERMBGN  BAL   R12,COB\n         MVI   0(R3),XFEND             MOVE OUT END TO O/P\n         LA    R3,1(,R3)\n         L     R15,SP\n         BCTR  R15,0                   RELEASE BEGIN IN STACK\n         ST    R15,SP\n         B     TERMSEAC\n*\n*        SLUT2\n*\n*        ENTERED FROM IEX00 IF INTERUPT OCCURS BEFORE GETMAIN\n*\nSLUT2    OI    BITS3,NOFREE             INTERUPT OCCURED PRIOR\n         B     SCANEND                  GOTO PROCESS TERMINATING PART\n*\n*        READROUT\n*\n*        ENTERED AFTER FINAL END COMMENT HAS BEEN CHECKED SHOULD\n*        EXIT TO EODADIN VIA OS EOD ROUTINE\n*\nREADROUT LA    R1,1(,R1)\n         LA    R9,*+4\n         TRT   0(73,R1),BTABLE         ONLY VALID CHARACTER AFTER\n         CLI   0(R1),XFZETA            FINAL END COMMENT IS ZETA ?\n         BE    CIB\n         B     ERR9                    ANYTHING ELSE FOUND\n*\nE39PAR   DC    X'0727'                 E39\n*\nERROR39  LA    R6,E39PAR\n         BAL   R12,ERROR1              CREATE E39 PATTERN\n         LH    R6,ENDCOUNT\n         CVD   R6,DOUBLE\n         UNPK  SAVE1(4),DOUBLE+5(3)\n         OI    SAVE1+3,X'F0'           INSERT NUMBER OF ENDS MISSING\n         MVC   4(3,R15),SAVE1+1        IN ERROR PATTERN\n*\n*        EODADIN\n*\n*        FALL THROUGH TO TERMINATION SECTION\n*\n*        TERMINATION\n*\n*        WRITES PB0 ITAB BLOCK FOR A PRECOMPILED PROCEDURE\n*        WRITES LAST O/P REC IF MORE THAN ONE O/P RECORD\n*        CORRECTS PRPT AND MOVES THE CONSTANTS 0 TROUGH 15 TO\n*        THE CONSTANT POOL\n*        IF NO TERMINATION ERROR AND EITHER DECK OR LOAD IS\n*        SPECIFIED ESD CARD AND TXT CARDS ARE GENERATED WITH\n*        GENERATE\n*        CHECKS LAST ITAB RECORD WRITTEN, IF ANY\n*        CLOSES SYSIN, SYSUT1, SYSUT3\n*        MAKES A FREEMAIN\n*        EXITS -\n*        IEX20 IF NO TERMINATING ERROR\n*        IEX21 IF TERMINATING ERROR\n*\nEODADIN  TM    COMPFLGS,TERR           TERMINATING ERROR ?\n         BO    KOPOOLRL                YES, DO NOT WRITE OUT ANYTHING\n         L     R1,AITAB                CHECK IF PB0\n         LA    R1,11(,R1)              CONTAINS ANYTHING\n         C     R1,AITL\n         BE    NOPBN0                  NO PB0\n         L     R15,AITL\n         OI    BITS2,X'08'             SET SWITCH\n         BAL   R4,WRTITAB              WRITE OUT PB0\nNOPBN0   BAL   R12,COB\n         MVI   0(R3),X'2D'             MOVE OMEGA TO O/P\n         LA    R3,1(,R3)\n         CLI   ONC,0                   ONLY ONE O/P RECORD ?\n         BE    NOPBN0A                 YES, BRANCH\n         BAL   R12,COBSPEB             NO, WRITE LAST O/P BUFFER\n         B     KOPOOLRL\n*                                      SOURCE PROGRAM IN STORAGE\nNOPBN0A  OI    COMPFLGS+2,SPIC         LEAVE THE SINGLE BUFFER IN CORE\nKOPOOLRL L     R7,POOLLOC\n         MVC   0(64,R7),KFCONST        MOVE THE CONSTANTS 0 TO 15\n         L     R6,PRPT\n         A     R6,KF7                  MAKE PRPT POINT\n         ST    R6,PRPT                 TO THE NEAREST\n         NI    PRPT+3,X'F8'            DOUBLE WORD BOUNDARY\n         MVC   PBN+1(1),PBC            SAVE NUMBER OF BLOCKS\n         IC    R1,FSN\n         BCTR  R1,0                    CORRECT FSN\n         STC   R1,ZFSNMAX              SET FOR SCAN 3\n         CLC   MGESITL,KF25000         WILL ITAB OVER FLOW ?\n         BL    KOPOOLAA\n         BAL   R6,ERR7\n*\n         DC    X'0413'                 E 19\n*\nKOPOOLAA TM    COMPFLGS+1,NDECK+NLOAD  DECK AND OR LOAD SPECIFIED\n         BO    SCANEND                 NO, SKIP ESD CARD GENERATION\n         SR    R6,R6\n         MVC   ESDPARM,ESDNAME         SET NAME OF PROCEDURE/BEGIN\nKOPOOLBB BAL   R2,GENESD               GENERATE ESD RECORD\n*\nESDPARM  DC    CL8' '                  ESD NAME\n         DC    X'0000'                 ESD TYPE SD\n*\n         MVC   29(3,R1),KF0            CORRECT FIRST ESD CARD\n         L     R2,AKOPOOL\n         MVC   GENTLEN,PRPT+2          GET LENGTH OF KOPOOL FOR TXT\n         BAL   R14,GENTXTS             GENERATE TXT CARD\n*\nGENTLEN  DC    H'0'                    UPDATED PRIOR TO GENTXTS CALL\n*\nSCANEND  TM    BITS3,FRSITB\n         BZ    CLSYSUT3\n*\n         CHECK ITABC\n*\nCLSYSUT3 L     R6,AUT3DCB\n*\n         CLOSE ((R6),REREAD),TYPE=T    RESET SYSUT3\n*\n         L     R6,ASYSDCB              CLOSE SYSIN\n*\n         CLOSE ((R6))\n*\n         FREEPOOL (R6)\n*\n         L     R6,AUT1DCB\n         TM    COMPFLGS,TERR           TERMINATING ERROR ?\n         BO    CLSPERM                 YES, CLOSE SYSUT1 FOR GOOD\n*\n         CLOSE ((R6),REREAD),TYPE=T    RESET SYSUT1\n*\n         B     FREE\n*\nCLSPERM  CLOSE ((R6),REREAD)           CLOSE SYSUT1\n*\nFREE     TM    BITS3,NOFREE            INTERUPT BEFORE GETMAIN ?\n         BO    GETERRPH                YES, DO NOT MAKE FREEMAIN\n         L     R0,POOLLEN\n         L     R1,POOLLOC\n*\n         FREEMAIN R,LV=(0),A=(1)\n*\n         OI    COMPFLGS+2,NOSC         SET SWITCH FOR ERROR MESSAGES\n         TM    COMPFLGS,TERR           TERMINATING ERROR ?\n         BO    GETERRPH                YES, CALL IEX21\n         ICM   R6,B'1111',BRACKET      BRACKET COUNTER ZERO ?\n         BZ    NEXTMOD                 YES, BRANCH\n         OI    COMPFLGS,COMPMODE+SERR  NO, SET SYNTAX MODE\n*\nNEXTMOD  XCTL  EP=IEX20000             GOTO ITAB MANIPULATION\n*\nGETERRPH XCTL  EP=IEX21000             GOTO ERROR MESSAGE HANDLING\n*\n*        GENERATE\n*\n*        REGISTER DEFINITIONS\n*\n*        R1                            OUTPUT RECORD POINTER\n*        R2                            ADDR OF INFORMATION\n*        R3                            TYPE OF RECORD TO BE GENERATED\n*        R4                            RETURN REG\n*        R14                           L'INFORMATION FROM CALL\n*        R15                           L'WITHIN RECORD\n*\n*        BIT PATTERNS\n*\nSDENTRY  EQU   X'00'                   SD ENTRY IDENTIFICATION\nLDENTRY  EQU   X'01'                   LD ENTRY IDENTIFICATION\nRLDFLAG  EQU   B'00001101'             FLAG USED IN RLD ENTRY\n*\n*        ADDR DISPLACEMENTS\n*\nGENESD   LA    R14,16                  R14 ALWAYS 16\n         LA    R3,ESDT                 INDICATE ESD CALL\n         MVC   PIDENT,0(R2)            NAME TO IDENT PART\n         B     GEN3                    CALL FOR FIRST OUT REC\n*\nGENTXTS  LA    R4,2(,R14)              COMPUTE RETURN ADDR\n         LH    R14,0(,R14)             LOAD R14 GIVEN IN CALL\nGEN2     LA    R3,TXTT                 INDICATE TXT CALL\n*\nGEN1     L     R1,SAVOUTA              LOAD ADDR OF OUT RECORD\n         CLC   1(3,R1),1(R3)           RECORD RIGHT TYPE ?\n         BNE   GEN3                    NO, CALL IOR NEW\n         CLC   10(2,R1),12(R3)         RECORD FILLED ?\n         BNL   GEN3                    YES, CALL FOR NEW\nGEN6     LA    R15,56\n         LH    R0,10(,R1)              R0 = L'INFORMATION IN REC\n         SR    R15,R0                  R15 = EMPTY POS LEFT IN RECORD\n         CR    R15,R14                 ENOUTH SPACE LEFT ?\n         BL    GEN6A                   NO\n         LR    R15,R14                 YES R15=R14 FROM CALL\nGEN6A    AR    R15,R0\n         STH   R15,10(,R1)             INSERT NEW LENGTH INTO RECORD\n*\n         SR    R15,R0\n         AR    R1,R0                   START ADDR WITHIN RECORD\n         SR    R14,R15                 REMAINING LENGTH\n         B     14(,R3)                 TO DIFFERENT MOVE ROUTINES\n*\nGEN4     LTR   R14,R14                 MORE INFORMATION MUST BE MOVED ?\n         BH    GEN3                    YES\n         BR    R4\n*\nGEN3     EQU   *                       CALL FOR NEW OUTPUT RECORD\nPUNCH    ST    14,ERRSAVE\n         TM    COMPFLGS+1,NLOAD+NDECK  BOTH DECK AND LOAD SPECIFIED ?\n         BZ    BOTH                    YES\n         L     R1,APCHDCB              R1- > SYSPUNCH DCB\n         TM    COMPFLGS+1,NDECK        DECK ?\n         BZ    PUT1                    YES\nPUT1A    L     R1,ALINDCB              R1 -> SYSLIN DCB\n*\nPUT1     PUT   (R1)                    PUT FOR SYSLIN AND SYSPUNCH IF\n*\n         ST    R1,SAVOUTA              ONLY SYSPUNCH SPECIFIED\n         L     14,ERRSAVE\n         B     PUNCHOUT\n*\nBOTH     TM    BITS2,X'02'             FIRST PUT ?\n         BZ    FIRSTPUT                YES\n         L     R14,OUTAREA2            COPY SYSLIN BUFFER TO SYSPUNCH\n         L     R1,SAVOUTA\n         MVC   0(80,R14),0(R1)         BUFFER\nPUT2     L     R1,APCHDCB              R1- > SYSPUNCH DCB\n*\n         PUT   (R1)                    PUT FOR SYSPUNCH WHEN BOTH HAS\n*\n         ST    R1,OUTAREA2             BEEN SPECIFIED\n         B     PUT1A                   GOTO PUT SYSLIN\n*\nFIRSTPUT OI    BITS2,X'02'\n         B     PUT2\n*\nPUNCHOUT MVC   0(4,R1),0(R3)           INSERT FIRST 4 BYTES\n         MVI   4(R1),C' '              INSERT ONE BLANK\n         MVC   5(67,R1),4(R1)          BLANK OUTPUT RECORD\n         MVC   72(4,R1),PIDENT         INSERT PROGRAM IDENT\n         AP    CARDCNT,KP1             INCR CARD COUNT\n         UNPK  76(4,R1),CARDCNT        UNPACK INTO RECORD\n         OI    79(R1),X'F0'            MAKE PRINTABLE\n         MVC   10(2,R1),4(R3)          INSERT INITIAL LENGTH\n         MVC   14(6,R1),6(R3)          INSERT ESID+R AND P\n         CLC   TXTT+1(3),1(R3)         TXT RECORD PROCESSED ?\n         BNE   GEN6                    NO\n         ST    R6,4(R1)                YES, INSERT R6\n         MVI   4(R1),C' '\n         B     GEN6\n*\n*        TABLES AND MOVE ROUTINES\n*\n*        ESD RECORD\n*\nESDT     DC    X'02'                   RECORD CODE\n         DC    C'ESD'                  IDENTIFICATION\n         DC    H'0'                    INITIAL LENGTH 0\n         DC    C'      '\n         DC    H'48'                   MAXIMUM LENTH IN RECORD\n*\n*        MOVE ESD INFORMATION TO OUTPUT\n*\nGEN7     MVC   16(9,R1),0(R2)          MOVE ESD NAME AND ESD TYPE SD TO\n*                                      ESD OUTPUT RECORD\n         MVC   25(L'ESDCON,R1),ESDCON  CHANGE LAST PART OF ENTRY\n         LA    R3,1                    SET ESID NUMBER TO 1\n         STH   R3,14(R1)               INSERT ESID NUMBER\n         B     10(,R2)                 RETURN TO CALLING ROUTINE\n*\n*        TXT RECORD\n*\nTXTT     DC    X'02'                   RECORD CODE\n         DC    C'TXT'                  IDENTIFICATION\n         DC    H'0'                    INITIAL LENGTH 0\n         DC    H'1'                    ESID\n         DC    C'    '\n         DC    H'56'                   MAXIMUM LENGTH\n*\n*        MOVE TXT INFORMATION TO OUTPUT\n*\nGEN8     BCTR  R15,0                   DECR R15\n         STC   R15,*+5                 INSERT LENGTH TO MOVE IN MVC\n         MVC   16(0,R1),0(R2)          MOVE INFORMATION TO OUTAREA\n         LA    R6,1(R15,R6)            INCREASE PROGRAM POINTER\n         LA    R2,1(R15,R2)            MODIFY DATA ADDR\n         B     GEN4                    EXIT MOVE TXT ROUTINE\n*\n*        BPRTAB\n*\n*        CONTAINS ADDR CONSTANTS OF PROGRAMS UTILIZED BY -\n*        TEST\n*        LIST\n*        POINT\n*        APOSTROF\n*        POINTLST\n*\n*        THE ADDRESSES ARE PICKED UP WITH DISPLACEMENTS FROM -\n*        TESTTABL\n*        ARTABLE\n*        PTTABLE\n*        ATABLE\n*        PTTABLE FOR POINTLST 56 IS ADDED TO DISP GIVEN\n*\nBPRTAB   DC    A(0)              + 00\n         DC    A(TRANSOP)        + 04\n         DC    A(TRANSOP)        + 08\n         DC    A(TRANSOP)        + 12\n         DC    A(TRANSOP)        + 16\n         DC    A(TRANSOP)        + 20\n         DC    A(TRANSOP)        + 24\n         DC    A(COLON)          + 28  COLON\n         DC    A(SEMCO)          + 32  SEMICOLON\n         DC    A(RIGHTPAR)       + 36\n         DC    A(BLANK)          + 40\n         DC    A(ERR1)           + 44\n         DC    A(POINT)          + 48\n         DC    A(APOSTROF)       + 52\n         DC    A(CIB)            + 56\n         DC    A(ASSIGN)         + 60\n         DC    A(DECPOINT)       + 64\n         DC    A(ERR5)           + 68  ERROR AFTER POINT\n         DC    A(BLKAPOS)        + 72  BLANK AFTER APOSTROPHE\n         DC    A(NPAFTAPO)       + 76  NOT PERMITTED AFTER APOSTR\n         DC    A(SCALE)          + 80  DIGIT OR SIGN AFTER APOSTROPHE\n         DC    A(COLONLST)       + 84  COLON IN LIST\n         DC    A(SEMCLST)        + 88  SEMICOLON IN LIST\n         DC    A(DELIMIT)        + 92  DELIMITER PROGRAM\n         DC    A(ZETAAPO)        + 96  ZETA AFTER APOSTROPHE\n         DC    A(EROUT)          +100  ERROR (FROM W1,W2OR W3 TAB)\n         DC    A(LEFTPARL)       +104  LEFT PARENTHESIS IN LIST\n         DC    A(RIGTPARL)       +108  RIGHT PARENTHESIS IN LIST\n         DC    A(PZETA)          +112  ZETA AFTER POINT IN LIST\n         DC    A(ASSIGN)         +116  ASSIGNMENT POINT IN LIST\n         DC    A(DECPOINT)       +120  DECPOINT IN LIST\n         DC    A(ERR5A)          +124  POINT ERROR IN LIST\n         DC    A(COMMALST)       +128  COMMA IN LIST\n         DC    A(PONTLST)        +132  POINT IN LIST\n         DC    A(SLASHLST)       +136  SLASH IN LIST\n         DC    A(QUOTE)          +140  QUOTE\n         DC    A(SEMC60)         +144\n*\n*        PTTABLE\n*\n*        USED BY -\n*        POINT\n*        PONTLST\n*        GIVES DISPLACEMENTS TO BPRTAB\n*        WHEN USED BY PONTLST 56 IS ADDED TO ORIGINAL DISP\n*\nPTTABLE  DC    AL1(68)                +00   XFPLUS\n         DC    AL1(68)                +01   XFMINUS\n         DC    AL1(68)                +02   XFASTER\n         DC    AL1(68)                +03   XFSLASH\n         DC    AL1(0)                 +04\n         DC    AL1(0)                 +05\n         DC    AL1(68)                +06   XFLBRAC\n         DC    AL1(68)                +07   XFCOLON\n         DC    AL1(0)                 +08   XFLSQBR\n         DC    AL1(0)                 +09\n         DC    AL1(0)                 +0A\n         DC    AL1(68)                +0B   XFSCOLON\n         DC    AL1(0)                 +0C\n         DC    AL1(0)                 +0D\n         DC    AL1(0)                 +0E\n         DC    AL1(0)                 +0F\n         DC    AL1(60)                +10   XFEQUAL\n         DC    AL1(68)                +11   XFLT\n         DC    AL1(68)                +12   XFGT\n         DC    AL1(0)                 +13\n         DC    AL1(0)                 +14\n         DC    AL1(0)                 +15\n         DC    AL1(0)                 +16\n         DC    AL1(0)                 +17\n         DC    AL1(0)                 +18\n         DC    AL1(0)                 +19\n         DC    AL1(0)                 +1A\n         DC    AL1(0)                 +1B\n         DC    AL1(0)                 +1C\n         DC    AL1(0)                 +1D\n         DC    AL1(0)                 +1E\n         DC    AL1(0)                 +1F\n         DC    AL1(68)                +20   XFNOT\n         DC    AL1(0)                 +21\n         DC    AL1(68)                +22   XFOR\n         DC    AL1(68)                +23   XFAMPER\n         DC    AL1(0)                 +24\n         DC    AL1(32)                +25   XFCOMMA\n         DC    AL1(68)                +26   XFRBRAC\n         DC    AL1(0)                 +27\n         DC    AL1(0)                 +28   XFRSQBR\n         DC    AL1(0)                 +29\n         DC    AL1(0)                 +2A\n         DC    AL1(0)                 +2B   XFBLANK\n         DC    AL1(68)                +2C\n         DC    AL1(28)                +2D   XFPERIOD\n         DC    AL1(68)                +2E   XFQUOTE\n         DC    AL1(56)                +2F\n         DC    AL1(64)                +30   XF0\n         DC    AL1(64)                +31   XF1\n         DC    AL1(64)                +32   XF2\n         DC    AL1(64)                +33   XF3\n         DC    AL1(64)                +34   XF4\n         DC    AL1(64)                +35   XF5\n         DC    AL1(64)                +36   XF6\n         DC    AL1(64)                +37   XF7\n         DC    AL1(64)                +38   XF8\n         DC    AL1(64)                +39   XF9\n         DC    AL1(0)                 +3A\n         DC    AL1(0)                 +3B\n         DC    AL1(0)                 +3C\n         DC    AL1(0)                 +3D\n         DC    AL1(0)                 +3E\n         DC    AL1(0)                 +3F\n         DC    AL1(68)                +40   XFA\n         DC    AL1(68)                +41   XFB\n         DC    AL1(68)                +42   XFC\n         DC    AL1(68)                +43   XFD\n         DC    AL1(68)                +44   XFE\n         DC    AL1(68)                +45   XFF\n         DC    AL1(68)                +46   XFG\n         DC    AL1(68)                +47   XFH\n         DC    AL1(68)                +48   XFI\n         DC    AL1(68)                +49   XFJ\n         DC    AL1(68)                +4A   XFK\n         DC    AL1(68)                +4B   XFL\n         DC    AL1(68)                +4C   XFM\n         DC    AL1(68)                +4D   XFN\n         DC    AL1(68)                +4E   XFO\n         DC    AL1(68)                +4F   XFP\n         DC    AL1(68)                +50   XFQ\n         DC    AL1(68)                +51   XFR\n         DC    AL1(68)                +52   XFS\n         DC    AL1(68)                +53   XFT\n         DC    AL1(68)                +54   XFU\n         DC    AL1(68)                +55   XFV\n         DC    AL1(68)                +56   XFW\n         DC    AL1(68)                +57   XFX\n         DC    AL1(68)                +58   XFY\n         DC    AL1(68)                +59   XFZ\n         DC    AL1(68)                +59   XFDOLLAR\n         DC    AL1(68)                +59   XFUNDER\n         DC    AL1(68)                +59   XFHASH\n         DC    AL1(68)                +59   XFAT\n*\n*        ATABLE\n*\n*        USED BY THE APOSTROPHE PROGRAM\n*        GIVES DISPLACEMENTS TO BPRTAB\n*\nATABLE   DC    AL1(80)                +00   XFPLUS\n         DC    AL1(80)                +01   XFMINUS\n         DC    AL1(100)               +02   XFASTER\n         DC    AL1(0)                 +03   XFSLASH\n         DC    AL1(0)                 +04\n         DC    AL1(0)                 +05\n         DC    AL1(0)                 +06   XFLBRAC\n         DC    AL1(100)               +07   XFCOLON\n         DC    AL1(0)                 +08   XFLSQBR\n         DC    AL1(0)                 +09\n         DC    AL1(0)                 +0A\n         DC    AL1(100)               +0B   XFSCOLON\n         DC    AL1(0)                 +0C\n         DC    AL1(0)                 +0D\n         DC    AL1(0)                 +0E\n         DC    AL1(0)                 +0F\n         DC    AL1(100)               +10   XFEQUAL\n         DC    AL1(100)               +11   XFLT\n         DC    AL1(100)               +12   XFGT\n         DC    AL1(0)                 +13\n         DC    AL1(0)                 +14\n         DC    AL1(0)                 +15\n         DC    AL1(0)                 +16\n         DC    AL1(0)                 +17\n         DC    AL1(0)                 +18\n         DC    AL1(0)                 +19\n         DC    AL1(0)                 +1A\n         DC    AL1(0)                 +1B\n         DC    AL1(0)                 +1C\n         DC    AL1(0)                 +1D\n         DC    AL1(0)                 +1E\n         DC    AL1(0)                 +1F\n         DC    AL1(100)               +20   XFNOT\n         DC    AL1(0)                 +21\n         DC    AL1(100)               +22   XFOR\n         DC    AL1(100)               +23   XFAMPER\n         DC    AL1(0)                 +24\n         DC    AL1(100)               +25   XFCOMMA\n         DC    AL1(100)               +26   XFRBRAC\n         DC    AL1(0)                 +27\n         DC    AL1(0)                 +28   XFRSQBR\n         DC    AL1(0)                 +29\n         DC    AL1(0)                 +2A\n         DC    AL1(72)                +2B   XFBLANK\n         DC    AL1(76)                +2C\n         DC    AL1(100)               +2D   XFPERIOD\n         DC    AL1(92)                +2E   XFQUOTE\n         DC    AL1(96)                +2F\n         DC    AL1(80)                +30   XF0\n         DC    AL1(80)                +31   XF1\n         DC    AL1(80)                +32   XF2\n         DC    AL1(80)                +33   XF3\n         DC    AL1(80)                +34   XF4\n         DC    AL1(80)                +35   XF5\n         DC    AL1(80)                +36   XF6\n         DC    AL1(80)                +37   XF7\n         DC    AL1(80)                +38   XF8\n         DC    AL1(80)                +39   XF9\n         DC    AL1(0)                 +3A\n         DC    AL1(0)                 +3B\n         DC    AL1(0)                 +3C\n         DC    AL1(0)                 +3D\n         DC    AL1(0)                 +3E\n         DC    AL1(0)                 +3F\n         DC    AL1(0)                 +40   XFA\n         DC    AL1(0)                 +41   XFB\n         DC    AL1(0)                 +42   XFC\n         DC    AL1(0)                 +43   XFD\n         DC    AL1(0)                 +44   XFE\n         DC    AL1(0)                 +45   XFF\n         DC    AL1(0)                 +46   XFG\n         DC    AL1(0)                 +47   XFH\n         DC    AL1(0)                 +48   XFI\n         DC    AL1(0)                 +49   XFJ\n         DC    AL1(0)                 +4A   XFK\n         DC    AL1(0)                 +4B   XFL\n         DC    AL1(0)                 +4C   XFM\n         DC    AL1(0)                 +4D   XFN\n         DC    AL1(0)                 +4E   XFO\n         DC    AL1(0)                 +4F   XFP\n         DC    AL1(0)                 +50   XFQ\n         DC    AL1(0)                 +51   XFR\n         DC    AL1(0)                 +52   XFS\n         DC    AL1(0)                 +53   XFT\n         DC    AL1(0)                 +54   XFU\n         DC    AL1(0)                 +55   XFV\n         DC    AL1(0)                 +56   XFW\n         DC    AL1(0)                 +57   XFX\n         DC    AL1(0)                 +58   XFY\n         DC    AL1(0)                 +59   XFZ\n         DC    AL1(0)                 +5A   XFDOLLAR\n         DC    AL1(0)                 +5B   XFUNDER\n         DC    AL1(0)                 +5C   XFHASH\n         DC    AL1(0)                 +5D   XFAT\n*\n*        BTABLE\n*\n*        BLANK TABLES - SCANS FOR FIRST NONBLANK CHARACTER\n*        USED BY -\n*        BLANK\n*        BLKAPOS BLANK AFTER APOSTROPHE\n*        READROUT IN TERMINATION\n*\nBTABLE   DC    X'FF'                  +00   XFPLUS\n         DC    X'FF'                  +01   XFMINUS\n         DC    X'FF'                  +02   XFASTER\n         DC    X'FF'                  +03   XFSLASH\n         DC    X'00'                  +04\n         DC    X'00'                  +05\n         DC    X'FF'                  +06   XFLBRAC\n         DC    X'FF'                  +07   XFCOLON\n         DC    X'FF'                  +08   XFLSQBR\n         DC    X'00'                  +09\n         DC    X'00'                  +0A\n         DC    X'FF'                  +0B   XFSCOLON\n         DC    X'00'                  +0C\n         DC    X'00'                  +0D\n         DC    X'00'                  +0E\n         DC    X'00'                  +0F\n         DC    X'FF'                  +10   XFEQUAL\n         DC    X'FF'                  +11   XFLT\n         DC    X'FF'                  +12   XFGT\n         DC    X'00'                  +13\n         DC    X'00'                  +14\n         DC    X'00'                  +15\n         DC    X'00'                  +16\n         DC    X'00'                  +17\n         DC    X'00'                  +18\n         DC    X'00'                  +19\n         DC    X'00'                  +1A\n         DC    X'00'                  +1B\n         DC    X'00'                  +1C\n         DC    X'00'                  +1D\n         DC    X'00'                  +1E\n         DC    X'00'                  +1F\n         DC    X'FF'                  +20   XFNOT\n         DC    X'00'                  +21\n         DC    X'FF'                  +22   XFOR\n         DC    X'FF'                  +23   XFAMPER\n         DC    X'00'                  +24\n         DC    X'FF'                  +25   XFCOMMA\n         DC    X'FF'                  +26   XFRBRAC\n         DC    X'00'                  +27\n         DC    X'FF'                  +28   XFRSQBR\n         DC    X'00'                  +29\n         DC    X'00'                  +2A\n         DC    X'00'                  +2B   XFBLANK\n         DC    X'FF'                  +2C\n         DC    X'FF'                  +2D   XFPERIOD\n         DC    X'FF'                  +2E   XFQUOTE\n         DC    X'FF'                  +2F\n         DC    X'FF'                  +30   XF0\n         DC    X'FF'                  +31   XF1\n         DC    X'FF'                  +32   XF2\n         DC    X'FF'                  +33   XF3\n         DC    X'FF'                  +34   XF4\n         DC    X'FF'                  +35   XF5\n         DC    X'FF'                  +36   XF6\n         DC    X'FF'                  +37   XF7\n         DC    X'FF'                  +38   XF8\n         DC    X'FF'                  +39   XF9\n         DC    X'00'                  +3A\n         DC    X'00'                  +3B\n         DC    X'00'                  +3C\n         DC    X'00'                  +3D\n         DC    X'00'                  +3E\n         DC    X'00'                  +3F\n         DC    X'FF'                  +40   XFA\n         DC    X'FF'                  +41   XFB\n         DC    X'FF'                  +42   XFC\n         DC    X'FF'                  +43   XFD\n         DC    X'FF'                  +44   XFE\n         DC    X'FF'                  +45   XFF\n         DC    X'FF'                  +46   XFG\n         DC    X'FF'                  +47   XFH\n         DC    X'FF'                  +48   XFI\n         DC    X'FF'                  +49   XFJ\n         DC    X'FF'                  +4A   XFK\n         DC    X'FF'                  +4B   XFL\n         DC    X'FF'                  +4C   XFM\n         DC    X'FF'                  +4D   XFN\n         DC    X'FF'                  +4E   XFO\n         DC    X'FF'                  +4F   XFP\n         DC    X'FF'                  +50   XFQ\n         DC    X'FF'                  +51   XFR\n         DC    X'FF'                  +52   XFS\n         DC    X'FF'                  +53   XFT\n         DC    X'FF'                  +54   XFU\n         DC    X'FF'                  +55   XFV\n         DC    X'FF'                  +56   XFW\n         DC    X'FF'                  +57   XFX\n         DC    X'FF'                  +58   XFY\n         DC    X'FF'                  +59   XFZ\n         DC    X'FF'                  +5A   XFDOLLAR\n         DC    X'FF'                  +5B   XFUNDER\n         DC    X'FF'                  +5C   XFHASH\n         DC    X'FF'                  +5D   XFAT\n*\n*        TESTTABL\n*\n*        USED BY MAIN LOOP SCANNING - GIVES DISPLACEMENTS TO BPRTAB\n*\nTESTTABL DC    AL1(0)                 +00   XFPLUS\n         DC    AL1(0)                 +01   XFMINUS\n         DC    AL1(4)                 +02   XFASTER\n         DC    AL1(8)                 +03   XFSLASH\n         DC    AL1(0)                 +04\n         DC    AL1(0)                 +05\n         DC    AL1(12)                +06   XFLBRAC\n         DC    AL1(28)                +07   XFCOLON\n         DC    AL1(0)                 +08   XFLSQBR\n         DC    AL1(0)                 +09\n         DC    AL1(0)                 +0A\n         DC    AL1(144)               +0B   XFSCOLON\n         DC    AL1(0)                 +0C\n         DC    AL1(0)                 +0D\n         DC    AL1(0)                 +0E\n         DC    AL1(0)                 +0F\n         DC    AL1(0)                 +10   XFEQUAL\n         DC    AL1(16)                +11   XFLT\n         DC    AL1(20)                +12   XFGT\n         DC    AL1(0)                 +13\n         DC    AL1(0)                 +14\n         DC    AL1(0)                 +15\n         DC    AL1(0)                 +16\n         DC    AL1(0)                 +17\n         DC    AL1(0)                 +18\n         DC    AL1(0)                 +19\n         DC    AL1(0)                 +1A\n         DC    AL1(0)                 +1B\n         DC    AL1(0)                 +1C\n         DC    AL1(0)                 +1D\n         DC    AL1(0)                 +1E\n         DC    AL1(0)                 +1F\n         DC    AL1(24)                +20   XFNOT\n         DC    AL1(0)                 +21\n         DC    AL1(0)                 +22   XFOR\n         DC    AL1(0)                 +23   XFAMPER\n         DC    AL1(0)                 +24\n         DC    AL1(0)                 +25   XFCOMMA\n         DC    AL1(36)                +26   XFRBRAC\n         DC    AL1(0)                 +27\n         DC    AL1(0)                 +28   XFRSQBR\n         DC    AL1(0)                 +29\n         DC    AL1(0)                 +2A\n         DC    AL1(40)                +2B   XFBLANK\n         DC    AL1(44)                +2C\n         DC    AL1(48)                +2D   XFPERIOD\n         DC    AL1(52)                +2E   XFQUOTE\n         DC    AL1(56)                +2F\n         DC    AL1(0)                 +30   XF0\n         DC    AL1(0)                 +31   XF1\n         DC    AL1(0)                 +32   XF2\n         DC    AL1(0)                 +33   XF3\n         DC    AL1(0)                 +34   XF4\n         DC    AL1(0)                 +35   XF5\n         DC    AL1(0)                 +36   XF6\n         DC    AL1(0)                 +37   XF7\n         DC    AL1(0)                 +38   XF8\n         DC    AL1(0)                 +39   XF9\n         DC    AL1(0)                 +3A\n         DC    AL1(0)                 +3B\n         DC    AL1(0)                 +3C\n         DC    AL1(0)                 +3D\n         DC    AL1(0)                 +3E\n         DC    AL1(0)                 +3F\n         DC    AL1(0)                 +40   XFA\n         DC    AL1(0)                 +41   XFB\n         DC    AL1(0)                 +42   XFC\n         DC    AL1(0)                 +43   XFD\n         DC    AL1(0)                 +44   XFE\n         DC    AL1(0)                 +45   XFF\n         DC    AL1(0)                 +46   XFG\n         DC    AL1(0)                 +47   XFH\n         DC    AL1(0)                 +48   XFI\n         DC    AL1(0)                 +49   XFJ\n         DC    AL1(0)                 +4A   XFK\n         DC    AL1(0)                 +4B   XFL\n         DC    AL1(0)                 +4C   XFM\n         DC    AL1(0)                 +4D   XFN\n         DC    AL1(0)                 +4E   XFO\n         DC    AL1(0)                 +4F   XFP\n         DC    AL1(0)                 +50   XFQ\n         DC    AL1(0)                 +51   XFR\n         DC    AL1(0)                 +52   XFS\n         DC    AL1(0)                 +53   XFT\n         DC    AL1(0)                 +54   XFU\n         DC    AL1(0)                 +55   XFV\n         DC    AL1(0)                 +56   XFW\n         DC    AL1(0)                 +57   XFX\n         DC    AL1(0)                 +58   XFY\n         DC    AL1(0)                 +59   XFZ\n         DC    AL1(0)                 +5A   XFDOLLAR\n         DC    AL1(0)                 +5B   XFUNDER\n         DC    AL1(0)                 +5C   XFHASH\n         DC    AL1(0)                 +5D   XFAT\n*\n*        ARTABLE\n*\n*        USED BY LIST EQUIVALENT TO THE USE OF TESTTABLE BY TESTLOOP\n*        GIVES DISPLACEMENT TO BPRTAB\n*\nARTABLE  DC    AL1(0)                 +00   XFPLUS\n         DC    AL1(0)                 +01   XFMINUS\n         DC    AL1(4)                 +02   XFASTER\n         DC    AL1(136)               +03   XFSLASH <-------\n         DC    AL1(0)                 +04                  |\n         DC    AL1(0)                 +05                  |\n         DC    AL1(104)               +06   XFLBRAC <--    |\n         DC    AL1(84)                +07   XFCOLON   |    |\n         DC    AL1(104)               +08   XFLSQBR <--    |\n         DC    AL1(0)                 +09                  |\n         DC    AL1(0)                 +0A                  |\n         DC    AL1(88)                +0B   XFSCOLON       |\n         DC    AL1(0)                 +0C                  |\n         DC    AL1(0)                 +0D                  |\n         DC    AL1(0)                 +0E                  |\n         DC    AL1(0)                 +0F                  |\n         DC    AL1(0)                 +10   XFEQUAL        |\n         DC    AL1(16)                +11   XFLT           |\n         DC    AL1(20)                +12   XFGT           |\n         DC    AL1(0)                 +13                  |\n         DC    AL1(0)                 +14                  |\n         DC    AL1(0)                 +15                  |\n         DC    AL1(0)                 +16                  |\n         DC    AL1(0)                 +17                  |\n         DC    AL1(0)                 +18                  |\n         DC    AL1(0)                 +19                  |\n         DC    AL1(0)                 +1A                  |\n         DC    AL1(0)                 +1B                  |\n         DC    AL1(0)                 +1C                  |\n         DC    AL1(0)                 +1D                  |\n         DC    AL1(0)                 +1E                  |\n         DC    AL1(0)                 +1F                  |\n         DC    AL1(24)                +20   XFNOT          |\n         DC    AL1(0)                 +21                  |\n         DC    AL1(0)                 +22   XFOR           |\n         DC    AL1(0)                 +23   XFAMPER        |\n         DC    AL1(0)                 +24                  |\n         DC    AL1(128)               +25   XFCOMMA        |\n         DC    AL1(136)               +26   XFRBRAC        |\n         DC    AL1(0)                 +27                  |\n         DC    AL1(136)               +28   XFRSQBR <-------\n         DC    AL1(0)                 +29\n         DC    AL1(0)                 +2A\n         DC    AL1(40)                +2B   XFBLANK\n         DC    AL1(44)                +2C\n         DC    AL1(132)               +2D   XFPERIOD\n         DC    AL1(52)                +2E   XFQUOTE\n         DC    AL1(56)                +2F\n         DC    AL1(0)                 +30   XF0\n         DC    AL1(0)                 +31   XF1\n         DC    AL1(0)                 +32   XF2\n         DC    AL1(0)                 +33   XF3\n         DC    AL1(0)                 +34   XF4\n         DC    AL1(0)                 +35   XF5\n         DC    AL1(0)                 +36   XF6\n         DC    AL1(0)                 +37   XF7\n         DC    AL1(0)                 +38   XF8\n         DC    AL1(0)                 +39   XF9\n         DC    AL1(0)                 +3A\n         DC    AL1(0)                 +3B\n         DC    AL1(0)                 +3C\n         DC    AL1(0)                 +3D\n         DC    AL1(0)                 +3E\n         DC    AL1(0)                 +3F\n         DC    AL1(0)                 +40   XFA\n         DC    AL1(0)                 +41   XFB\n         DC    AL1(0)                 +42   XFC\n         DC    AL1(0)                 +43   XFD\n         DC    AL1(0)                 +44   XFE\n         DC    AL1(0)                 +45   XFF\n         DC    AL1(0)                 +46   XFG\n         DC    AL1(0)                 +47   XFH\n         DC    AL1(0)                 +48   XFI\n         DC    AL1(0)                 +49   XFJ\n         DC    AL1(0)                 +4A   XFK\n         DC    AL1(0)                 +4B   XFL\n         DC    AL1(0)                 +4C   XFM\n         DC    AL1(0)                 +4D   XFN\n         DC    AL1(0)                 +4E   XFO\n         DC    AL1(0)                 +4F   XFP\n         DC    AL1(0)                 +50   XFQ\n         DC    AL1(0)                 +51   XFR\n         DC    AL1(0)                 +52   XFS\n         DC    AL1(0)                 +53   XFT\n         DC    AL1(0)                 +54   XFU\n         DC    AL1(0)                 +55   XFV\n         DC    AL1(0)                 +56   XFW\n         DC    AL1(0)                 +57   XFX\n         DC    AL1(0)                 +58   XFY\n         DC    AL1(0)                 +59   XFZ\n         DC    AL1(0)                 +5A   XFDOLLAR\n         DC    AL1(0)                 +5B   XFUNDER\n         DC    AL1(0)                 +5C   XFHASH\n         DC    AL1(0)                 +5D   XFAT\n*\n*        TRINTEXT\n*\n*        CONVERT TABLE FOR INTERNAL CODE TO EBCDIC\n*\n*        USED BY CODE TO TRANSLATE PROCEDURE NAME PROCEDURE TO\n*        TRANSLATE PROCEDURE NAME FOR ESD CARD IF PRECOMPILED\n*        SPECIFIED\n*\nTRINTEXT DC    96C' '\n         ORG   TRINTEXT+XFBLANK\n         DC    C' '\n         ORG   TRINTEXT+XF0\n         DC    C'0123456789'\n         ORG   TRINTEXT+XFA\n         DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n         ORG   TRINTEXT+XFDOLLAR\n         DC    C'$_#@'\n         ORG\n*\n*        KWLUTAB\n*\n*        USED TO REFERENCE ENTRIES IN KEYWTAB FOR KEYWORDS\n*\nKWLUTAB  DC    A(KEYWDL01)             KEY WORDS LENGTH OF 1\n         DC    A(KEYWDL02)             KEY WORDS LENGTH OF 2\n         DC    A(KEYWDL03)             KEY WORDS LENGTH OF 3\n         DC    A(KEYWDL04)             KEY WORDS LENGTH OF 4\n         DC    A(KEYWDL05)             KEY WORDS LENGTH OF 5\n         DC    A(KEYWDL06)             KEY WORDS LENGTH OF 6\n         DC    A(KEYWDL07)             KEY WORDS LENGTH OF 7\n         DC    A(KEYWDL08)             KEY WORDS LENGTH OF 8\n         DC    A(KEYWDL09)             KEY WORDS LENGTH OF 9\n         DC    A(KEYWDL10)             KEY WORDS LENGTH OF 10\n*\n*        KEYWTAB\n*\n*        CONTAINS ALL KEYWORDS, EACH FOLLOWED BY 3 BYTES OF\n*        INFORMATION BEING 2 BYTES OF CHARACTERISTICS AND A\n*        DISPLACEMENT INTO DELPRGTB\n*        FOR A SECTION IN THE KEYWTAB. A SECTION CONTAINS\n*        ALL THE KEYWORDS OF THE SAME LENGTH\n*        1. THE FIRST BYTE IN EACH SECTION SAYS HOW MANY ENTRIES\n*           THERE ARE IN THE SECTION. THEREAFTER THE DELIMITER PLUS 3\n*           BYTES OF INTERNAL CODE MAKES A SUBSECTION\n*        2. THE FIRST 2 BYTES OF THE INTERNAL CODE IS\n*           CHARECTERISTCS FOR THE DELIMITER\n*        3. THE THIRD BYTE IS A DISPLACEMENT TO THE DELPRGTB,\n*           WHERE THE ADDR IS PICKED UP TO THE PROGRAM TO HANDLE\n*           THE KEYWORD\n*\nKEYWTAB  EQU   *\nKEYWDL01 DC    AL1(2)                  NUMBER OF ENTRIES\n         IEXCGEN DC,'/'                /\n         DC    XL2'0400',XL1'00'\n         IEXCGEN DC,'('                (\n         DC    XL2'0000',XL1'04'       LEFT BRACKET (STRING)\n*\nKEYWDL02 DC    AL1(3)                  NUMBER OF ENTRIES\n         IEXCGEN DC,'DO'               DO\n         DC    XL2'1C00',XL1'08'\n         IEXCGEN DC,'IF'               IF\n         DC    XL2'1D00',XL1'0C'\n         IEXCGEN DC,'OR'               OR\n         DC    XL2'2200',XL1'00'\n*\nKEYWDL03 DC    AL1(4)                  NUMBER OF ENTRIES\nKWEND    IEXCGEN DC,'END'              END\n         DC    XL2'0000',XL1'10'\n         IEXCGEN DC,'FOR'              FOR\n         DC    XL2'0000',XL1'14'\n         IEXCGEN DC,'AND'              AND\n         DC    XL2'2300',XL1'00'\n         IEXCGEN DC,'NOT'              NOT\n         DC    XL2'2000',XL1'00'\n*\nKEYWDL04 DC    AL1(9)                  NUMBER OF ENTRIES\n         IEXCGEN DC,'REAL'             REAL\n         DC    XL2'C212',XL1'18'\n         IEXCGEN DC,'STEP'             STEP\n         DC    XL2'1900',XL1'00'\n         IEXCGEN DC,'THEN'             THEN\n         DC    XL2'1E00',XL1'08'\nKWELSE   IEXCGEN DC,'ELSE'             ELSE\n         DC    XL2'1F00',XL1'08'\n         IEXCGEN DC,'GOTO'             GOTO\n         DC    XL2'1700',XL1'0C'\n         IEXCGEN DC,'TRUE'             TRUE\n         DC    XL2'0700',XL1'1C'\n         IEXCGEN DC,'LESS'             LESS\n         DC    XL2'1100',XL1'00'\n         IEXCGEN DC,'CODE'             CODE\n         DC    XL2'0000',XL1'20'\n         IEXCGEN DC,'IMPL'             IMPL\n         DC    XL2'2100',XL1'00'\n*\nKEYWDL05 DC    AL1(10)                 NUMBER OF ENTRIES\n         IEXCGEN DC,'BEGIN'            BEGIN\n         DC    XL2'0000',XL1'24'\n         IEXCGEN DC,'UNTIL'            UNTIL\n         DC    XL2'1A00',XL1'00'\nKWARRAY  IEXCGEN DC,'ARRAY'            ARRAY\n         DC    XL2'CA16',XL1'28'\n         IEXCGEN DC,'VALUE'            VALUE\n         DC    XL2'0000',XL1'2C'\n         IEXCGEN DC,'LABEL'            LABEL\n         DC    XL2'CA18',XL1'30'\n         IEXCGEN DC,'WHILE'            WHILE\n         DC    XL2'1B00',XL1'00'\n         IEXCGEN DC,'FALSE'            FLASE\n         DC    XL2'0000',XL1'1C'\n         IEXCGEN DC,'POWER'            POWER\n         DC    XL2'0500',XL1'00'\n         IEXCGEN DC,'EQUAL'            EQUAL\n         DC    XL2'1000',XL1'00'\n         IEXCGEN DC,'EQUIV'            EQUIV\n         DC    XL2'2400',XL1'00'\n*\nKEYWDL06 DC    AL1(2)                  NUMBER OF ENTRIES\n         IEXCGEN DC,'SWITCH'           SWITCH\n         DC    XL2'CA1C',XL1'34'\n         IEXCGEN DC,'STRING'           STRING\n         DC    XL2'CB10',XL1'30'\n*\nKEYWDL07 DC    AL1(5)\n         IEXCGEN DC,'INTEGER'          INTEGER\n         DC    XL2'C211',XL1'18'\n         IEXCGEN DC,'BOOLEAN'          BOOLEAN\n         DC    XL2'C213',XL1'18'\n         IEXCGEN DC,'COMMENT'          COMMENT\n         DC    XL2'0000',XL1'38'\n         IEXCGEN DC,'NOTLESS'          NOTLESS\n         DC    XL2'1500',XL1'00'\n         IEXCGEN DC,'GREATER'          GREATER\n         DC    XL2'1200',XL1'00'\n*\nKEYWDL08 DC    AL1(1)                  NUMBER OF ENTRIES\n         IEXCGEN DC,'NOTEQUAL'         NOTEQUAL\n         DC    XL2'1300',XL1'00'\n*\nKEYWDL09 DC    AL1(1)                  NUMBER OF ENTRIES\nKWPROC   IEXCGEN DC,'PROCEDURE'        PROCEDURE\n         DC    XL2'CAD0',XL1'3C'\n*\nKEYWDL10 DC    AL1(1)                  NUMBER OF ENTRIES\n         IEXCGEN DC,'NOTGREATER'       NOTGREATER\n         DC    XL2'1400',XL1'00'\n*\n*        DELPRGTB\n*\n*        BRANCH ADDR TABLE USED AFTER A KEYWORD HAS BEEN FOUND\n*\nDELPRGTB DC    A(NORMAL)               +00\n         DC    A(STRING)               +04\n         DC    A(TED)                  +08\n         DC    A(GIF)                  +12\n         DC    A(END)                  +16\n         DC    A(FOR)                  +20\n         DC    A(TYPE)                 +24\n         DC    A(BOLCON)               +28\n         DC    A(CODE)                 +32\n         DC    A(BEGIN)                +36\n         DC    A(ARRAY)                +40\n         DC    A(VALUE)                +44\n         DC    A(SPEC)                 +48\n         DC    A(SWITCH)               +52\n         DC    A(COM)                  +56\n         DC    A(PROCEDUR)             +60\n         DC    A(TYPEARRY)             +64\n         DC    A(TYPPROC)              +68\n*\n*        COMTABLE\n*\n*        USED BY COMMENT PROGRAM\n*        TESTS FOR SEMICOLON, PERIOD, QUOTE AND ZETA\n*        GIVES DISPLACEMENT TO PROGRAMS FROM COMCEE2+2\n*\nCOMTABLE DC    XL96'00'\n         ORG   COMTABLE+XFSCOLON\n         DC    AL1(42)                 COMCEE2+2+42\n         ORG   COMTABLE+XFPERIOD\n         DC    AL1(34)                 COMCEE2+2+34\n         ORG   COMTABLE+XFQUOTE\n         DC    AL1(14)                 COMCEE2+2+14\n         ORG   COMTABLE+XFZETA\n         DC    AL1(30)                 COMCEE2+2+30\n         ORG   ,\n*\n*        STRTABLE\n*\n*        USED BY STRING PROGRAM\n*        SCANS FOR QUOTE OR ZETA\n*        PROVIDES DISPLACEMENTS TO BPRTAB\n*\nSTRTABLE DC    XL96'00'\n         ORG   STRTABLE+XFQUOTE\n         DC    AL1(140)\n         ORG   STRTABLE+XFZETA\n         DC    AL1(56)\n         ORG   ,\n*\n*        KEYTAB\n*\n*        USED BY TRANSOP\n*        BYTE 3 IS EXPECTED BYTE, IF THAT ONE MATCHES CHAR IN\n*        INPUT BYTE 1 IS PUT OUT OTHERWISE BYTE 2\n*        THE DISPLACEMENT FROM TESTTABL OR ATABLE IS USED TO GET\n*        THE APPROPRIATE ENTRY IN KEYTAB\n*        USED WHEN -\n*                   FOUND                    EXPECTED\n*                   *                        *\n*                   /                        )\n*                   (                        /\n*                   <                        =\n*                   >                        =\n*                   \u00ac                        =\n*\nKEYTAB   DC    X'00000000'                                  +00\n         DC    X'00',AL1(XFPOWER),AL1(XFASTER),AL1(XFASTER) +04 XFASTER\n         DC    X'00',AL1(XFRSQBR),AL1(XFSLASH),AL1(XFRBRAC) +08 XFSLASH\n         DC    X'00',AL1(XFLSQBR),AL1(XFLBRAC),AL1(XFSLASH) +12 XFLBRAC\n         DC    X'00',AL1(20),AL1(XFLT),AL1(XFEQUAL)         +16 XFLT\n         DC    X'00',AL1(21),AL1(XFGT),AL1(XFEQUAL)         +20 XFGT\n         DC    X'00',AL1(19),AL1(XFNOT),AL1(XFEQUAL)        +24 XFNOT\n*\n*        TREXTINT\n*\n*        USED IN CIB TO TRANSLATE FROM EBCDIC TO INTERNAL CODE\n*\nTREXTINT DC    256AL1(XFEND)\n         ORG   TREXTINT+C' '\n         DC    AL1(XFBLANK)\n         ORG   TREXTINT+C'.'\n         DC    AL1(XFPERIOD),AL1(XFLT),AL1(XFLBRAC),AL1(XFPLUS)\n         DC    AL1(XFOR),AL1(XFAMPER)\n         ORG   TREXTINT+C'$'\n         DC    AL1(XFDOLLAR)\n         ORG   TREXTINT+C'*'\n         DC    AL1(XFASTER),AL1(XFRBRAC),AL1(XFSCOLON),AL1(XFNOT)\n         DC    AL1(XFMINUS),AL1(XFSLASH)\n         ORG   TREXTINT+C','\n         DC    AL1(XFCOMMA)\n         ORG   TREXTINT+C'_'\n         DC    AL1(XFUNDER)\n         ORG   TREXTINT+C'>'\n         DC    AL1(XFGT)\n         ORG   TREXTINT+C':'\n         DC    AL1(XFCOLON)\n         ORG   TREXTINT+C'#'\n         DC    AL1(XFHASH),AL1(XFAT)\n         ORG   TREXTINT+C''''\n         DC    AL1(XFQUOTE),AL1(XFEQUAL)\n         ORG   TREXTINT+X'81'          LOWER CASE A\n         DC    AL1(XFA),AL1(XFB),AL1(XFC),AL1(XFD),AL1(XFE),AL1(XFF)\n         DC    AL1(XFG),AL1(XFH),AL1(XFI)\n         ORG   TREXTINT+X'91'          LOWER CASE J\n         DC    AL1(XFJ),AL1(XFK),AL1(XFL),AL1(XFM),AL1(XFN),AL1(XFO)\n         DC    AL1(XFP),AL1(XFQ),AL1(XFR)\n         ORG   TREXTINT+X'A2'          LOWER CASE S\n         DC    AL1(XFS),AL1(XFT),AL1(XFU),AL1(XFV),AL1(XFW),AL1(XFX)\n         DC    AL1(XFY),AL1(XFZ)\n         ORG   TREXTINT+C'\u00dd'\n         DC    AL1(XFLSQBR)\n         ORG   TREXTINT+C'\u00a8'\n         DC    AL1(XFRSQBR)\n         ORG   TREXTINT+C'A'\n         DC    AL1(XFA),AL1(XFB),AL1(XFC),AL1(XFD),AL1(XFE),AL1(XFF)\n         DC    AL1(XFG),AL1(XFH),AL1(XFI)\n         ORG   TREXTINT+C'J'\n         DC    AL1(XFJ),AL1(XFK),AL1(XFL),AL1(XFM),AL1(XFN),AL1(XFO)\n         DC    AL1(XFP),AL1(XFQ),AL1(XFR)\n         ORG   TREXTINT+C'S'\n         DC    AL1(XFS),AL1(XFT),AL1(XFU),AL1(XFV),AL1(XFW),AL1(XFX)\n         DC    AL1(XFY),AL1(XFZ)\n         ORG   TREXTINT+C'0'\n         DC    AL1(XF0),AL1(XF1),AL1(XF2),AL1(XF3),AL1(XF4),AL1(XF5)\n         DC    AL1(XF6),AL1(XF7),AL1(XF8),AL1(XF9)\n         ORG   ,                       RESTORE LOCATION COUNTER\n*\n*        KFCONST\n*\n*        KEEPS THE CONSTANTS 0 THROUGH 15\n*        THE CONSTANTS ARE USED WITHIN SCAN 1/2 FOR CALCULATION\n*        AND ARE THEN INSERTED AS THE FIRST 64 BYTES OF THE\n*        CONSTANT POOL\n*\nKFCONST  DC    0F'0'\nKF0      DC    F'0'                    +00\nKF1      DC    F'1'                    +04\nKF2      DC    F'2'                    +08\nKF3      DC    F'3'                    +12\nKF4      DC    F'4'                    +16\nKF5      DC    F'5'                    +20\nKF6      DC    F'6'                    +24\nKF7      DC    F'7'                    +28\nKF8      DC    F'8'                    +32\nKF9      DC    F'9'                    +36\nKF10     DC    F'10'                   +40\nKF11     DC    F'11'                   +44\nKF12     DC    F'12'                   +48\nKF13     DC    F'13'                   +52\nKF14     DC    F'14'                   +56\nKF15     DC    F'15'                   +60\n*\n*        VARIABLES AND CONSTANTS\n*\nKF25000  DC    F'25000'\nKF2000   DC    F'2000'\nKF4095   DC    F'4095'\nKH4096   DC    H'4096'\nDOUBLE   DC    D'0'\nKF256    DC    F'256'\nINT      DC    X'2EC8030000'           COMMON PART OF THE INTERNAL\n*                                      NAMES OF BOOLEAN CONSTANTS\nENDCOUNT DC    H'0'\nERRSAVE  DC    4F'0'\n*\nESDNAME  DC    CL8'PROGRAM'\nKP1      DC    PL1'1'                  CARD COUNT INCREMENT\n*\nHEAD1    DC    C'SOURCE PROGRAM'\nHEAD2    DC    C'SC     SOURCE STATEMENT'\n*\nOPINCHAR DC    C'0'\nBRACKET  DC    F'0'                    BRACKET COUNTER\nESDCON   DC    X'00000040404040'       ESD CONSTANT 7 BYTES\nSCPATTN  DC    XL6'402020202020'       SEMICOLON EDIT PATTERN\n*\nSAVE1    DC    7F'0'\nSAVEPRNT DC    CL88' '\nSCOVFL   DC    F'65535'                (2**16)-1\n*\n         LTORG\n*\nWORKAREA DSECT\n*\n         COPY  WORKAREA                COMMON WORKAREA\n*\nC        DS    H                  PARENTHESIS COUNT\nKB       DS    H                  HOLDS ID FIELD FOR SPECIFICATIONS\nPOOLLEN  DS    F                  LENGTH OF AREA GOTTEN FROM GETMAIN\nPOOLLOC  DS    F                  START LOC OF AREA FROM GETMAIN\nAITABBUF DS    F                  ADDR OF ITAB BUFFER\nELI      DS    F                  ADDR OF ONE LOC  BEYOND ITAB AREA\nADDARI   DS    A                  ADDR OF FIRST O/P BUFFER\n         DS    A                  ADDR OF SECOND O/P BUFFER\nDISP     DS    C                  DISPLACEMENT TO ADDARI\nD        DS    C                  DIMENSION COUNTER\nSP       DS    F                  CURRENT STACK POINTER\nAPE      DS    F                  LAST AVAILABLE BYTE IN CURRENT O/P\nWASAVE   DS    CL12\nWABEFOR  DS    CL7\nWA       DS    CL80               READIN AREA FOR SYSIN SOURCE RECORDS\nAPRNTAR  DS    A                  ADDR OF CURRENT PRINT BUFFER\nATOPSTAK DS    A                  LAST BYTE IN THE STACK\nIGC      DS    H                  ITAB GROUP COUNTER\nAGT      DS    A                  ADDR OF GROUPE TAB -3\nAKOPOOL  DS    A                  ADDR OF THE CONSTANT POOL (0)\nLAPIN    DS    A                  ADDR OF LAST POSSIBLE LABEL START\nDIM      DS    A                  ADDR FOR DIMENSION IN ITAB NAME\nPRIMPAR  DS    A                  ADDR OF FIRST SPECIFICATION\nAITAB    DS    A                  START ADDR OF ITAB\nAITL     DS    A                  CURRENT ITAB ENTRY ADDR\nLIGP     DS    A                  POINTER TO CURRENT IG HEAD ENTRY\nLPBP     DS    A                  POINTER TO CURRENT PBHEADING\nWADDARI  DS    A                  CURRENT O/P BUFFER ADD\nITABLEN  DS    F                  ITAB LENGTH\nMGESITL  DS    F                  ACCUMULATED ITAB LENGTH\nBCHAR    DS    C                  SAVE CHAR\nFBYTE    DS    CL1                SWITCH BYTE FOR APOSTROPHE\nFSN      DS    C                  FOR STATEMENT COUNTER\nZFSNMAX  DS    C\nPBC      DS    C                  PROGRAM BLOCK COUNTER\nONC      DS    C                  O/P REC COUNTER\nN        DS    C                  NUMBER OF ARRAYS WITH SAME DIM\nOPIN     DS    A                  POINTS TO LAST LABEL OPERATER\n         DS    C                  O/P REC NO WHEN OPIN WAS SET\nPZ       DS    C                  COUNTS NUMBER OF PARMETERS\nBITS1    DS    C                  INTERNAL SWITCHES\nBEGBIT   EQU   X'80'              BLOCK BEGIN\nBEGOFF   EQU   X'7F'\nPROBIT   EQU   X'40'              PROCEDURE HEAD PROCESSING\nDELTABIT EQU   X'20'              SEMICOLON FOUND AFTER DECLARATION\nIDBIT    EQU   X'10'              PROCEDURE NAME\nARBIT    EQU   X'08'              ARRAY PROCESSED\nLISTBIT  EQU   X'04'              COMMA FOUND AFTER ARRAY NAME\nTERBIT   EQU   X'01'              RETURN TO TERM AFTER PBLCKEND\nBITS2    DS    C\nENDBIT   EQU   X'80'              LOGICAL END HAS BEEN FOUND\nCOBIT    EQU   X'40'              COMMENT\nSTARTBIT EQU   X'20'              ZERO UNTIL FIRST BEGIN FOUND\nVALBIT   EQU   X'10'              VALUE\nPB0BIT   EQU   X'08'              WRITE PB0 FOR PRE COMP PROC\nFRSTPUT  EQU   X'02'              FIRST PUT IN GENERATE\nENDELSE  EQU   X'01'              END MAY CLOSE FOR OR PROC**\nBITS3    DS    C\nE11BIT   EQU   X'80'              E11 HAS BEEN GENERATED ONCE\nFMBIT    EQU   X'40'              FORMAL PARAMETER BIT\nFMOFF    EQU   X'BF'\nNOFREE   EQU   X'20'              INTERUPT BEFORE GETMAIN\nFRSITB   EQU   X'10'              FIRST ITAB REC IS WRITTEN\nPROCESD  EQU   X'08'              WRITE SED CARD FOR PRE COMP PROC\nPROCOFF  EQU   X'F7'\n*\n*        CHARACTER EQUATES\n*\n         IEXCHAR\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END   IEX11000\n./ ADD NAME=IEX20    0201-12230-12230-1200-00775-00775-00000-LEVEL\nX20      TITLE 'IEX20 - ITAB MANIPULATION, ALGOL F'\n*\n*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER\n*\n*        FUNCTION/OPERATION -\n*        EACH ITAB BLOCK IS SCANNED FOR DUPLICATE IDENTIFIERS\n*        RELATIVE DISPLACEMENTS IN DSA IS ALLOCATED FOR ALL\n*        IDENTIFIERS, EXCEPT PROCEDURES, LABELS AND SWITCHES\n*        THE ITAB BLOCKS ARE WRITTEN IN PROGRAM BLOCK NUMBER\n*        ORDER TO SYSUT3\n*        THE ITAB BLOCKS ARE PRINTED ON SYSPRINT IN PROGRAM\n*        BLOCK NUMBER ORDER AND WITH THE IDENTIFIERS IN\n*        ALPHABETIC FORM WITHIN EACH BLOCK, IF THE OPTION\n*        SOURCE IS SPECIFIED\n*        CREATES PBTAB2\n*\n*        ENTRY POINT -\n*        IEX20000 ITAB MANIPULATION - XCTL EP=IEX20\n*\n*        INPUT - THE ITAB BLOCKS ARE READ IN FROM SYSUT3\n*\n*        OUTPUT -\n*        THE ITAB BLOCKS ARE WRITTEN TO SYSUT3 AND PRINTED ON\n*        SYSPRINT IF THE OPTION SOURCE IS SPECIFIED\n*\n*        EXTERNAL ROUTINES - THE PRINT ROUTINE IN IEX00 IS USED\n*\n*        EXITS - NORMAL -\n*        CONTROL IS GIVEN TO IEX21 XCTL EP=IEX21\n*\n*        EXITS - ERROR - N/A\n*\n*        TABLES/WORKAREA -\n*        ATAB     - ADDR IS OF THE ITAB RECORDS IN PROGRAM BLOCK\n*                   NUMBER ORDER\n*        TRINTEXT - TRANSLATION OF INTERNAL CHARACTERS TO EBCDIC\n*                   CHARACTERS\n*        TAB      - PRINTING OF HEXADECIMAL DIGITS\n*        WORK     - BUILDING THE PRINT ENTRIES\n*\n*        NOTES -\n*        CHARACTER CODE DEPENDENCE\n*        THE OUTPUT ON SYSPRINT -\n*        THE IDENTIFIER NAME IS TRANSLATED BY MEANS OF TRINTEXT,\n*        WHICH IS A CHARACTER TABLE\n*        THE HEXADECIMAL PART IS TRANSLATED BY MEANS OF TAB\n*        THE REMAINING PARTS DEPEND ON THE INTERNAL\n*        REPRESENTATION OF THE EXTERNAL CHARACTER SET WHICH IS\n*        EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME\n*        THE OPERATION OF THE OTHER PARTS OF THE PHASE DOES NOT\n*        DEPEND UPON A PARTICULAR INTERNAL REPRESENTATION OF THE\n*        EXTERNAL CHARACTER SET\n*\nIEX20000 CSECT\n*\n*        R1                       PBN\n*        R2                       CALCULATIONS\n*        R3                       PARAMETER FOR CONVERT ROUTINE\n*        R3                       DOUBLE WORD POINTER\n*        R4                       WORD POINTER\n*        R5                       KEEPS TRACK OF WHEN TO PRINT\n*        R5                       HALF WORD POINTER\n*        R6                       BYTE POINTER\n*        R7                       CURRENT IDENTIFIER\n*        R8                       CURRENT BLOCKHEAD\n*        R9                       SCANS FOR DUPLICATES\n*        R10                      ARRAY STORAGE ALLOCATIONS\n*        R11                      BASE REGISTER\n*        R12                      RETURN FROM CONVERT, PRINT ROUTINE\n*        R14                      PBN DURING PRINTING\n*        R15\n*\n*        INITIALIZATION\n*\n*        GETMAIN FOR ITAB AND ATAB\n*        FIRST ENTRY IN ATAB IS MADE ZERO IF NO PBN 0\n*        PRINTING OF HEADING LINES IS INITIALIZED IF SOURCE SPECIFIED\n*        FPLEN IS MADE 4 IF SHORT SPECIFIED OTHERWISE IT REMAINS 8\n*\n         IEXENTRY 'IEX20000 LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IEX20000,R11\n         LR    R11,R15\n         USING WORKAREA,R13\n         LA    R15,SLUT2               INTERUPT BEFORE GETMAIN\n         ST    R15,ERET\n         L     R1,ITAB20S              ITAB\n         LA    R1,1024(,R1)            ATAB\n         LR    R0,R1\n*\n         GETMAIN R,LV=(0)              GET ITAB ATAB AREAS\n*\n         LA    R15,SLUT\n         ST    R15,ERET                INTERRUPT ADDR AFTER GETMAIN\n         ST    R1,AREALOC\n         ST    R1,AITAB                ITAB START LOCATION\n         A     R1,ITAB20S\n         ST    R1,ATABAD               ATAB START LOCATION\n         SR    R2,R2                   ZERO REG FOR INIT VALUES\n         ST    R2,KF0\n         ST    R2,SAVEPB\n         TM    COMPFLGS,PROC           A PB0 ?\n         BO    INITIAL                 YES, BRANCH\n         LA    R15,1                   NO, PROGRAM BLK 1 IS FIRST BLOCK\n         ST    R15,SAVEPB\nINITIAL  ST    R2,0(,R1)\n         ST    R2,SAVE                 INITIALIZE WITH ZEROS\n         MVC   SAVE1(16),SAVE\n         STC   R2,BITS1                INITIALIZE SWITCHES\n         LA    R10,PBTAB2\n         ST    R10,APBTAB2             START ADDR OF PBTAB2\n         TM    COMPFLGS+1,NSRCE        SOURCE SPECIFIED ?\n         BO    INITIALA                NO\n         MVI   LINCNT+1,255            FORCE HEADINGS TO BE PRINTED\n         MVI   PAGEHD1C+1,C' '         BLANK FIRST HEADING LINE\n         MVC   PAGEHD1C+2(109),PAGEHD1C+1\n         MVC   PAGEHD2D(L'PAGEHD2D),PAGEHD1D  BLANK 2ND HEADING LINE\n         MVC   PAGEHD3D(L'PAGEHD3D),PAGEHD1D  BLANK 3RD HEADING LINE\n         MVC   PAGEHD1D+39(L'HEAD1),HEAD1\n         MVC   PAGEHD2D(L'HEAD2),HEAD2\n         MVC   PAGEHD3D(L'HEAD3),HEAD3\n         BAL   R12,PRINTITB            INITIALIZE PRINTING FOR ITAB\nINITIALA SR    R1,R1\n         TM    COMPFLGS,LNG            LONG OR SHORT PRECISION\n         BO    READBLK                 LONG, BRANCH\n         MVI   FPLEN+1,4               SET SHORT FPLEN=4\n*\n*        SCAN FOR DUPLICATES\n*\n*        READS IN A NEW BLOCK\n*        START ADDR IN R8 END ADDR IN AITAB\n*        COMPARES EACH IDENTIFIER WITH ALL IDENTIFIERS FOLLOWING\n*        IT IN THE BLOCK\n*        IF TWO EQUAL FOUND AND IF NOT FIRST ONE IS A FORMAL\n*        PARAMETER AND SECOND NOT E45 IS GENERATED\n*        WHEN ALL IDENTIFIERS IN THE BLOCK HAVE BEEN CHECK THE\n*        EXIT IS TO ALLOSTUR\n*\nREADBLK  L     R12,AITAB               START ADDR OF NEW BLOCK\n         L     R2,AUT3DCB              R2 -> SYSUT3 DCB\n*\n*        READ IN NEW BLOCK\n*\n         READ  UT3DECB,SF,(R2),(R12),'S'\n*\n         CHECK UT3DECB\n*\n         SR    R2,R2\n         IC    R2,10(,R12)             GET NEW PBN\n         SLA   R2,2\n         L     R7,ATABAD\n         ST    R12,0(R2,R7)            SAVE ADDR OF BLOCK IN ATAB\n         LR    R8,R12\n         MVC   LENCOUNT,0(R12)         GET LENTH OF BLOCK\n         AH    R12,LENCOUNT\n         ST    R12,AITAB               SAVE END ADDR OF BLOCK\n         LR    R7,R8\n         TM    8(R8),X'80'             BLOCK TYPE PROC ?\n         BZ    SCANNXT                 NO\n         LA    R7,22(,R8)              YES, SKIP CHECKING AGAINST\n         B     SCANNXTA                TYPE PROCEDURE NAME\n*\nSCANNXT  LA    R7,11(,R7)\nSCANNXTA C     R7,AITAB                ALL IDENTIFIERS CHECKED ?\n         BE    ALLOSTOR                YES, GO TO ALLOCATE STORAGE\n         CLI   5(R7),X'2B'             FOR HEAD OR CONT ENTRY ?\n         BE    SCANNXT                 YES, SKIP CHECKING\n         CLI   0(R7),0                 INVALID PROCEDURE NAME ?\n         BE    SCANNXT                 YES, SKIP CHECKING\n         LR    R9,R7\nCHECKNXT LA    R9,11(,R9)\n         C     R9,AITAB                ALL IDENT CHECKED AGAINST\n         BE    SCANNXT                 THE ONE PROCESSED ?\n         CLI   5(R9),X'2B'             FOR HEAD OR CONT ENTRY ?\n         BE    CHECKNXT\n         CLC   0(6,R9),0(R7)           COMPARE EACH IDENTIFIER AGAINST\n*                                      ALL FOLLOWING INDENTIFIERS\n*                                      IN THE BLOCK\n         BNE   CHECKNXT\n         TM    7(R7),X'30'             TWO EQUAL FOUND. PROCESSED\n         BM    CHECKNAA                ONE FORMAL PARAMETER ?\n         B     E43                     NO\n*\nCHECKNAA TM    7(R9),X'30'             COMPARED ONE IS FORMAL PARAM\n         BM    E43                     YES\n         B     CHECKNXT                NO\n*\n*        ALLOSTOR\n*\n*        ALLOCATES STORAGE FOR THE IDENTIFIERS\n*        FOR A TYPE PROC BLOCK ALLOCATION STARTS AT 32 OTHERWISE\n*        AT 24.\n*        NO BLOCK MAY GET MORE THAN 4K ALLOCATED.\n*        IT IS ALSO CHECKED THAT THERE IS NO PROC, STRING OR\n*        SWITCH CALLED BY VALUE.\n*        WHEN ALL DECLARATIONS IN THE BLOCK ARE PROCESSED R3-FPLEN\n*        WILL BE PUT IN PBTAB2.\n*        IF THERE ARE MORE BLOCKS TO BE PROCESSED THE EXIT IS TO\n*        IDENTIFIER SCAN OTHERWISE TO WRITE ITAB.\n*        FOUR POINTERS ARE USED -\n*        R3 DOUBLE WORD POINTER\n*        R4 WORD\n*        R5 HALF WORD R6 BOOLEAN\n*        R3 IS INCREASED BY FPLEN WHICH IS 8 FOR LONG, 4 FOR SHORT.\n*        FOR LONG PRECISION ALL 4 POINTERS ARE USED\n*        FOR SHORT R4 IS NEVER USED, WILL CONTAIN 0 ALL THE\n*        TIME\n*        REAL WILL BE ALLOCATED TO R3, 4 OR 8 BYTES.\n*        INTEGER WILL GET R3 OR R4. R3 ALWAYS IF SHORT R4 IF\n*        LONG AND R4 NOT ZERO.\n*        OTHERWISE R3, IN WHICH CASE R4 WILL EQUAL R3+4 FOR THE\n*        NEXT INTEGER.\n*        BOOLEAN WILL GET R3, R4, R5 OR R6 IF LONG R3, R5 OR R6\n*        IF SHORT.\n*        FIRST BOOLEAN FOUND WILL GET EITHER R4 OR R3.\n*        R5 IS THEN INITILIZED TO R4+2 OR R3+2\n*        R6                       R4+1    R3+1\n*        SECOND BOOLEND WILL GET THE VALUE OF R6 AND R6 WILL BE 0.\n*        THIRD BOOLEAN WILL GET R5 AND R5 WILL BE 0 R6=R5+1.\n*        FORTH BOOLEAN WILL GET R6 AND R6 WILL BE 0.\n*        THIS WILL THEN BE REPEATED FOR EVERY FOUR BOOLEAN\n*        IDENTIFIERS. ALL FORMAL PARAMETERS WILL GET THE R3 VALUE\n*        AND R3 WILL BE INCREASED BY 8.\n*        ARRAYS WILL GET R3 VALUE AND R3 WILL BE INCREASED BY\n*        4(DIM+6)+X WHERE X IS 4 WHEN LONG PRECISION AND DIM IS\n*        AN UNEVEN NUMBER, OTHERWISE X IS 0.\n*        LABEL, SWITCH , PROCEDURE WILL NOT GET ANYTHING\n*        EX. OF STORAGE ALLOCATION\n*        LONG           SHORT\n*        01234567       01234567  FP   FORMAL PARAMETER\n*        FP             FP        R    REAL\n*        FP             FP        INT  INTEGER\n*        R              R   INT   B    BOOLEAN\n*        INT INT        INT INT   NU   NOT USED SPACE\n*        INT BBB        BBB R\n*        R              INT R\n*        INT NU\n*        R\n*\nALLOSTOR TM    8(R8),X'80'             THE BLOCK A TYPE PROCEDURE ?\n         BZ    ALLOSTAA                NO\n         LA    R3,32                   YES, SET DOUBLE WORD POINTER\n         NI    8(R8),X'7F'             CLEAR TYPE PROCEDURE INDICATION\n         B     STARTALL\n*\nALLOSTAA LA    R3,24                   SET DOUBLE WORD POINTER\nSTARTALL SR    R4,R4                   SET ALL POINTERS TO ZERO\n         SR    R5,R5\n         SR    R6,R6\n         LR    R7,R8                   GET FIRST VARIABLE\n         B     GETNEXT\n*\nSTORALLO AH    R3,FPLEN                INCREASE ALLOCATION POINTER\nSTORALLA C     R3,KF4095               HAS 4K BEEN ALLOCATED ALREADY ?\n         BH    E44\nGETNEXT  LA    R7,11(,R7)              GET NEXT VARIABLE\n         STM   R3,R6,DPC               STORE ALL POINTERS\n         C     R7,AITAB                ALL VARIABLES TAKEN CARE OF ?\n         BE    LASTREC                 YES\n         CLI   5(R7),X'2B'             FOR HEADING OR CONTINUATION ?\n         BE    GETNEXT\n         CLI   6(R7),X'91'             ALL PURPOSE IDENTIFIER ?\n         BE    GETNEXT\n         TM    7(R7),X'30'             FORMPARAM, DEK VAR OR CONST?\n         BM    FORMPARM\n         BZ    CONST\n         TM    7(R7),X'03'             BOOLEAN VARIABLE ?\n         BO    BOOLEAN\n         TM    COMPFLGS,LNG            SHORT PRECISION ?\n         BZ    REAL                    YES, ALLOCATE SAME FOR REAL AND\n*                                      INTEGER\n         TM    7(R7),X'01'             INTEGER OR REAL ?\n         BO    INTEGER\nREAL     MVC   9(2,R7),DPC+2           MOVE IN DISPLACEMENT\n         B     STORALLO\n*\nINTEGER  LTR   R4,R4                   EMPTY HOLE LEFT FOR INTEGER ?\n         BZ    INTEGERA                NO\n         MVC   9(2,R7),WPC+2           YES, FILL THE HOLE AND MAKE\n         LA    R4,0                    WORD POINTER= 0\n         B     GETNEXT\n*\nINTEGERA MVC   9(2,R7),DPC+2           MOVE IN DOUBLEWORD PTR AND MAKE\n         LA    R4,4(,R3)               WORDPTR POINT TD EMPTY HOLE NEXT\n         B     STORALLO                TO IT\n*\nBOOLEAN  LTR   R6,R6                   SPACE LEFT NEXT TO PREV BOOL ?\n         BZ    BOOLEANA                NO\n         MVC   9(2,R7),BPC+2           YES, MOVE IN DISPLACEMENT\n         SR    R6,R6                   MAKE BYTE POINTER 0\n         B     GETNEXT\n*\nBOOLEANA LTR   R5,R5                   SPACE LEFT NEXT TO 2 PREV BOOL ?\n         BZ    TESTWPA                 NO\n         MVC   9(2,R7),HPC+2           YES, MOVE IN DISPLACEMENT\n         LA    R6,1(,R5)               MAKE BYTE POINTER POINT TO NEXT\n         SR    R5,R5                   HALFWORD POINTER 0\n         B     GETNEXT                 FREE BYTE\n*\nTESTWPA  TM    COMPFLGS,LNG            SHORT PRECISION ?\n         BZ    TAKEDP                  YES, DO NOT USE R4 POINTER\nTESTWP   LTR   R4,R4                   R4 POINTER FREE ?\n         BZ    TAKEDP                  NO, TAKE R3 POINTER INSTEAD\n         MVC   9(2,R7),WPC+2           YES, USE R4 AS DISPLACEMENT\n         LA    R6,1(,R4)               SET R5 AND R6\n         LA    R5,2(,R4)               TO FREE BYTES IN WORD\n         SR    R4,R4                   SET R4 TO ZERO\n         B     GETNEXT\n*\nTAKEDP   MVC   9(2,R7),DPC+2           USE R3 AS DISPLACEMENT\n         LA    R6,1(,R3)               SET R4, R5, R6 TO FREE BYTES\n         LA    R5,2(,R3)               WITHIN THE DOUBLE WORD\n         LA    R4,4(,R3)\n         B     STORALLO\n*\nCONST    TM    7(R7),X'04'             FOR LABEL, STRING, PROCEDURE\n         BZ    GETNEXT\n         TM    7(R7),X'08'             DO NOT ALLOCATE ANY STORAGE\n         BO    GETNEXT\n         SR    R10,R10\n         IC    R10,9(R7)\n         SRA   R10,4                   FOR AN ARRAY\n         LA    R10,6(,R10)             STORAGE NEEDED IS 4(DIM+6)+X\n         SLA   R10,2\n         OC    9(2,R7),DPC+2           OR IN THE DISP TO SAVE DIMENSION\n         TM    COMPFLGS,LNG            X IS 4 IF LONG PRECISION\n         BZ    CONSTAA\n         TM    9(R7),X'10'             DIM IS AN UNEVEN NUMBER\n         BZ    CONSTAA                 INCREASE IF NEEDED TO GET\n         LA    R10,4(,R10)             ON DOUBLE WORD BOUNDARY\nCONSTAA  LA    R3,0(R10,R3)\n         B     STORALLA\n*\nFORMPARM TM    7(R7),X'03'             TYPE PARAMETER ?\n         BZ    NOTTYPE                 NO\nFORMPALL MVC   9(2,R7),DPC+2           MOVE IN DISPLACEMENT\n         LA    R3,8(,R3)\n         B     STORALLA\n*\nNOTTYPE  TM    7(R7),X'10'             CALL BY NAME ?\n         BO    FORMPALL                YES\n         TM    7(R7),X'03'             NO, CHECK IF VALUE CALL CORRECT\n         BZ    NOTTYPEA\n         B     FORMPALL\n*\nNOTTYPEA CLI   7(R7),X'28'             LABEL CALLED BY VALUE ?\n         BE    FORMPALL\n         B     E45                     PROC SWITCH OR STRING\n*                                      CALLED BY VALUE\nLASTREC  SR    R2,R2                   CONSTRUCT ENTRY OF PBTAB2\n         IC    R2,10(,R8)              GET PBN\n         SLA   R2,1\n         L     R14,APBTAB2\n         LA    R14,0(R2,R14)\n         SH    R3,FPLEN                GET LAST BYTE USED\n         STH   R3,0(,R14)\n         L     R1,SAVEPB\n         CH    R1,PBN                  ALL ITAB REC WRITTEN OUT ?\n         LA    R1,1(,R1)\n         ST    R1,SAVEPB\n         BNE   READBLK                 NO\n*\n*        WRITITAB\n*\n*        WRITES THE ITAB RECORD TO SYSUT3 IN PROGRAM BLOCK NUMBER\n*        ORDER\n*        THE ADDR TO WHERE THE BLOCK IS GOING TO BE WRITTEN\n*        IS PICKED UP FROM ATAB\n*        IN EACH BLOCK THE LENGTH OF THE NEXT BLOCK IS INSERTED\n*\nWRITITAB L     R12,ATABAD              START OF ADDR TABLE\n         L     R10,AUT3DCB             R10 -> SYSUT3 DCB ADDR\n*\n         CLOSE ((R10),REREAD),TYPE=T   GET TO START OF SYSUT3\n*\n         SR    R2,R2\n         TM    COMPFLGS,PROC           IS THERE A PB0 ?\n         BZ    ITLP2                   NO\nITABLOOP L     R10,0(,R12)             GET ADDR OF BLOCK\n         L     R7,AUT3DCB              DCB ADDR\n         L     R5,4(,R12)              GET ADDR OF NEXT BLOCK\n         CH    R2,PBN                  LAST BLOCK ?\n         BE    ITABLOOA                YES\n         MVC   2(2,R10),0(R5)          INSERT LENGTH OF NEXT BLOCK\nITABLOOA MVC   LENCOUNT,0(R10)         GET LENGTH OF CURRENT BLOCK\n         LH    R15,LENCOUNT\n*\n         WRITE PRCH4,SF,(R7),(R10),(R15)\n*\n         CHECK PRCH4\n*\nITLP2    LA    R12,4(,R12)             GET ADDR OF NEXT BLOCK\n         CH    R2,PBN                  ALL ITAB REC WRITTEN OUT ?\n         LA    R2,1(,R2)\n         BNE   ITABLOOP                NO\n         B     ITABPRNT                YES\n*\n*        E43\n*\n*        GENERATES ERROR MESSAGE 45\n*        RETURNS TO SCANNING FOR DUPLICATES\n*\nE43      BAL   R15,ERRNAME\n         MVI   1(R10),X'2D'            E45\n         B     SCANNXT\n*\n*        E45\n*\n*        GENERATER ERROR MESSAGE 47\n*        RETURNS TO FORMPALL AS IF VAR WAS CORRECT\n*\nE45      BAL   R15,ERRNAME\n         MVI   1(R10),X'2F'            E47\n         B     FORMPALL\n*\n*        E44\n*\n*        GENERATES ERROR MESSAGE 214\n*        RETURNS TO LASTREC TO TAKE NEXT BLOCK, IF ANY\n*\nE44      L     R3,SAVEPB\n         BAL   R12,CONVERT             CONVERT PBN\n         L     R10,NEXTERR\n         LA    R12,7(,R10)             SPACE LEFT IN ERROR POOL ?\n         C     R12,ENDPOOL\n         BH    E0\n         ST    R12,NEXTERR\n         MVI   0(R10),X'87'            MOVE LENGTH AND BLANK SC INDIC\n         MVI   1(R12),X'D6'            E214\n         MVC   4(3,R10),SAVE+1         PBN\n         B     LASTREC\n*\n*        ERRNAME\n*\n*        FINDS THE LENGTH OF THE VARIABLE IN ERROR, CHECKS FOR\n*        ERRPOOL OVERFLOW, MOVES IN THE NAME OF THE VAR AND\n*        LENGTH OF MESSAGE\n*        RETURNS TO CALLING PROGRAM, E43 OR E44\n*\nERRNAME  LA    R12,5\nERRNAMEC STC   R12,ERRNAMEA+3          UPDATE NEXT INSTRUCTION\nERRNAMEA CLI   0(R7),0                 FIND LENGTH OF NAME\n         BNE   ERRNAMEB\n         BCT   R12,ERRNAMEC\nERRNAMEB L     R9,NEXTERR\n         LA    R9,5(R12,R9)\n         C     R9,ENDPOOL              CHECK SPACE IN ERRORPOOL\n         BH    E0\n         L     R10,NEXTERR\n         ST    R9,NEXTERR\n         EX    R12,MOVE                INSERT NAME IN ERROR PATTERN\n         LA    R12,5(,R12)\n         STC   R12,0(,R10)\n         OI    0(R10),X'80'            BLANK SC INDICATOR\n         BR    R15\n*\nE0       LA    R12,NEXTERR\n         MVI   0(R12),X'02'\n         MVI   1(R12),X'D4'            E212\n         ST    R12,NEXTERR\n         B     SLUT\n*\nMOVE     MVC   4(1,R10),0(R7)\n*\n*        ITABPRNT\n*\n*        PRINTS ON SYSPRINT, IF SOURCE SPECIFIED, ALL VARIABLES\n*        THE BLOCKS IN PBN NUMBER ORDER AND WITH THE VAR SORTED\n*        WITHIN EACH BLOCK\n*        R5 KEEPS TRACK OF WHEN PRINTING IS NEEDED, THE\n*        INFORMATION ABOUT EACH VAR IS BUILT UP IN WORK AND THEN\n*        TRANSFERRED TO PRINTAREA. WHEN 3 VAR HAVE BEEN PLACED IN\n*        THE PRINTAREA THE LINES IS PRINTED\n*        THE ADDR TO THE BLOCK IS TAKEN FROM ATAB\n*        THE LENGTH IS TAKEN FROM THE FIRST 2 BYTES IN THE BLOCK\n*        THE SURROUNDING PBN FROM PBTAB1\n*        THE STARTING SC COUNTER FOR THE BLOCK FROM BYTE 6 AND 7\n*        IN THE BLOCK\n*        IF THE BLOCK DOES NOT CONTAIN ANY VAR ONLY THE PBN AND\n*        SURROUNDING PBN ARE PRINTED\n*        ALL HEAD ENTRIES, FOR AND CONT LINES ARE SKIPPED\n*        EACH NEW BLOCK IS PRECEEDED BY A BLANK LINE\n*        START ADDR OF THE BLOCK IS IN R8\n*        END ADDR OF THE BLOCK IS IN AITAB, THIS ADDR WILL BE\n*        R8+11 WHEN ALL VAR PROCESSED\n*\nITABPRNT TM    COMPFLGS+1,NSRCE        SOURCE SPECIFIED ?\n         BO    SLUT                    NO\n         SR    R14,R14                 CLEAR REG\n         TM    COMPFLGS,PROC           THERE A PB0 ?\n         BO    GETPBA                  YES, PROCESS PB0, R14=0\nGETPB    LA    R14,1(,R14)             INCREASE PBN\nGETPBA   LR    R12,R14\n         SLA   R12,2\n         L     R8,ATABAD               GET ADDR OF NEW BLOCK\n         L     R8,0(R12,R8)            VIA ATAB + 4 TIMES PBN\n         MVC   LENCOUNT,0(R8)          GET LENGTH OF THE BLOCK\n         LH    R12,LENCOUNT\n         LA    R12,0(R12,R8)           GET END OF BLOCK\n         ST    R12,AITAB               STORE END OF IT\n         BAL   R12,PRINTITB            PRINT A BLANK LINE\n         LR    R3,R14                  CONVERT PBN\n         BAL   R12,CONVERT\n         MVC   0(3,R1),SAVE+1          NEW PBN\n         IC    R3,PBTAB1(R14)          CONVERT SURROUNDING PBN\n         BAL   R12,CONVERT\n         MVC   10(3,R1),SAVE+1         SURROUNDING PBN\n         MVC   SCSAVE(2),6(R8)         CONVERT SC COUNTER TO DECIMAL\n         LH    R12,SCSAVE\n         CVD   R12,DOUBLE              STARTING SC OF BLOCK IS INSERTED\n         UNPK  4(5,R1),DOUBLE\n         OI    8(R1),X'F0'\n         CLC   LENCOUNT,KA11           EMPTY BLOCK ?\n         BNE   ITABPRNX                NO\n         BAL   R12,PRINTITB            FOR AN EMPTY BLOCK PRINT\n         B     ENDBLOCK                ONLY THE BLOCK NUMBERS\n*\nITABPRNX SR    R5,R5\n*\n*        GETNVAR\n*\n*        LOOPS THROUGH BLOCK TO GET THE CURRENT LOWEST VARIABLE\n*        EXITS TO ENDBLOCK WHEN ALL VAR IN THE BLOCK HAVE BEEN\n*        PROCESSED, OTHERWISE TO TESTVAR\n*\nGETNVAR  LA    R7,11(,R8)              GET FIRST VAR AFTER HEADING\n         LR    R10,R7\n         C     R7,AITAB                ALL VAR PROCESSED ?\n         BE    ENDBLOCK                YES\n         CLI   5(R7),X'2B'             HEAD OR CONTINUATION LINE ?\n         BE    ENDVAR2\nTESTNXT  LA    R10,11(,R10)            GET NEXT VAR\n         C     R10,AITAB               ALL VAR COMPARED ?\n         BE    TESTVAR\n         CLI   5(R10),X'2B'            HEAD OR CONTINUATION LINE ?\n         BE    TESTNXT                 YES, SKIP THAT LINE\n         CLC   0(6,R7),0(R10)          COMPARE CURRENT LOWEST - NEW ?\n         BL    TESTNXT                 CURRENT LOWEST STILL LOW\n         LR    R7,R10                  NO, SHIFT R7 TO NEW\n         B     TESTNXT\n*\n*        TESTVAR\n*\n*        CHECKS THE INTERNAL NAME TO FIND TYPE AND MOVES\n*        CHARACTERISTICS TO WORKAREA\n*\nTESTVAR  TM    6(R7),X'91'             ALL PURPOSE IDENTIFIER ?\n         BO    ENDVAR                  YES\n         TM    7(R7),X'03'             TYPE ?\n         BO    BOL                     TYPE=BOOLEAN\n         BZ    BOLA                    NOT TYPE\n         TM    7(R7),X'01'             INTEGER OR REAL ?\n         BZ    TESTVARA\n         MVI   WORK+7,C'I'             INTEGER\n         B     BOLA\n*\nTESTVARA MVI   WORK+7,C'R'             REAL\n         B     BOLA\n*\nBOL      MVI   WORK+7,C'B'             BOOLEAN\nBOLA     TM    7(R7),X'0C'\n         BZ    TESTPROC\n         BO    SWITCH\n         TM    7(R7),X'08'             ARRAY OR LABEL ?\n         BZ    ARRAY\n         MVI   WORK+8,C'L'             LABEL\nTESTPROC TM    7(R7),X'C0'\n         BO    PROCEDUR\n         BZ    FORMAL\n         TM    7(R7),X'40'\n         BZ    FORMAL\n         MVI   WORK+11,C'C'            CODE PROCEDURE\n         B     PROCEDUR\n*\nFORMAL   TM    7(R7),X'30'             SPECIFIED IDENTIFIER ?\n         BO    ENDVAR\n         BZ    ENDVAR\nFORMALC  NI    BITS1,PROCOFF           RESET PROCEDURE BIT\n         TM    6(R7),X'01'\n         BZ    FORMALA\n         MVI   WORK+8,C'T'             STRING\nFORMALA  TM    7(R7),X'10'             NAME OR VALUE CALL ?\n         BZ    FORMALB\n         MVI   WORK+10,C'N'            NAME\n         B     ENDVAR\n*\nFORMALB  MVI   WORK+10,C'V'            VALUE\n         B     ENDVAR\n*\nSWITCH   MVI   WORK+8,C'S'             SWITCH\n         B     CONVERT2                CONVERT NUMBER OF COMPONENTS\n*\nPROCEDUR MVI   WORK+9,C'P'             PROCEDURE\n         OI    BITS1,PROCBIT           SET PROCEDURE BIT\n         B     CONVERT2                CONVERT NUM OF PARAMETERS\n*\nARRAY    MVI   WORK+9,C'A'             ARRAY\n*\n*        CONVERT2\n*\n*        ENTERED FOR PROCEDURE, ARRAY AND SWITCH CONVERTS THE\n*        NUMBER OF PARAMETERS, DIMENSIONS OR COMPONENTS TO\n*        DECIMAL FORM AND PUTS IT IN WORK\n*        FOR ARRAY OR SWITCH THE COUNTER IS FIRST INCREASED BY\n*        ONE TO GET THE REAL VALUE.\n*\nCONVERT2 TM    7(R7),X'30'\n         BM    FORMALC\n         IC    R3,9(,R7)\n         SRA   R3,4                    SWITCH OR PROCEDURE\n         TM    BITS1,PROCBIT           TEST IF PROC PARAMETERS\n         BO    *+8                     YES\n         LA    R3,1(,R3)               NO, INCREASE DIM COUNTER\n         NI    BITS1,PROCOFF           TO GIVE CORRECT VALUE\n         BAL   R12,CONVERT             CONVERT IT TO DECIMAL\n         MVC   WORK+13(2),SAVE+2       AND MOVE IT OUT\n         B     FORMAL\n*\n*        CONVERT\n*\n*        CONVERTS FROM HEXADECIMAL TO DECIMAL\n*        USED FOR LN, DISP AND PBN TO BE WRITEN OUT\n*\nCONVERT  CVD   R3,DOUBLE               CONVERT TO DECIMAL\n         UNPK  SAVE(4),DOUBLE+5(3)     UNPACK\n         OI    SAVE+3,X'F0'            MAKE PRINTABLE\n         BR    R12                     RETURN\n*\n*        PRINTITB\n*        PRINTS A LINE, SAVES NEW PRINTAREA ADDR, RESETS R5\n*\nPRINTITB STM   R14,R15,SAVE1\n         L     R15,PRTRTADD            PRINT A RECORD\n         BALR  R14,R15\n         ST    R1,APRNTAR              SAVE ADDR OF NEXT PRINT AREA\n         LM    R14,R15,SAVE1\n         SR    R5,R5                   RESET R5\n         BR    R12                     RETURN\n*\n*        ENDVAR\n*\n*        MOVES EXTERNAL NAME TO WORK, TRANSLATES IT\n*        CONVERTS LN OR DISP AND MOVES THAT TO WORK\n*        MOVES WORK TO CURRENT PRINTAREA WITH AN EXECUTE MVC\n*        INCREASES R5 AND CHECKS IF ONE LINE HAS BEEN FILLED UP\n*        IN THAT CASE - PRINTS THAT LINE\n*        SHIFTS AWAY THE NOW PROCESSED VAR AND STORES THE NEW\n*        ENDING ADDR OF THE BLOCK IN AITAB\n*        RETURNS TO PROCESS NEXT VAR\n*\nENDVAR   MVC   WORK(6),0(R7)           MOVE EXTERNAL NAME\n         TR    WORK(6),TRINTEXT\n         MVC   SAVE2(2),9(R7)          MOVE\n         UNPK  SAVE3,SAVE2             CONVERT DISP OR LABEL NUMBER\n         TR    SAVE3+1(3),TAB-240      TO BE WRITTEN OUT\n         MVC   WORK+16(3),SAVE3+1\n         EX    R0,MOVEVAR(R5)          MOVE OUT WORK TO PRINT AREA\n         MVI   WORK,C' '               CLEAR WORK\n         MVC   WORK+1(L'WORK-1),WORK\n         LA    R5,8(,R5)\n         C     R5,KF24                 TIME TO PRINT ?\n         BNE   ENDVAR2                 NO\n         BAL   R12,PRINTITB            YES, CALL FOR PRINT ROUTINE\nENDVAR2  L     R10,AITAB\n         LA    R12,12(,R7)             LEN TO MOVE ITAB UP TO\n         C     R12,AITAB               NOTHING TO MOVE ?\n         BNH   ENDVAR3\n         ST    R7,AITAB                STORE ADDR OF CURRENT AS ENDADDR\n         B     GETNVAR\n*\nENDVAR3  SR    R10,R12                 CALCULATE NEW END ADDR OF THE\n         LA    R12,1(R10,R7)           BLOCK AND STORE IT IN AITAB\n         ST    R12,AITAB\nCOMPARE  C     R10,KF256\n         BNH   EX1\n         MVC   0(256,R7),11(R7)        TRANSFER A 256 BYTE SECTION\n         LA    R7,256(,R7)             OF THE BLOCK AT THE TIME\n         S     R10,KF256\n         B     COMPARE\n*\nEX1      EX    R10,MOVEITAB            MOVE LAST PARTIAL SECTION\n         B     GETNVAR\n*\n*        ENDBLOCK\n*\n*        PRINTS LAST LINE OF BLOCK, IF NEEDED\n*        EXITS TO GETPB IF ANY BLOCK LEFT TO BE PROCESSED\n*        OTHERWISE A FREEMAIN IS DONE AND LINK TO IEX21\n*\nENDBLOCK C     R5,KF0                  VAR LEFT TO BE WRITTEN OUT ?\n         BE    *+8\n         BAL   R12,PRINTITB\n         LA    R12,1(,R14)\n         CH    R12,PBN                 ALL BLOCKS PROCESSED ?\n         BNH   GETPB                   NO, TAKE NEXT\nSLUT     L     R1,ITAB20S              ITAB AREA\n         LA    R1,1024(0,R1)           AND ATAB AREA ARE MADE\n         LR    R0,R1                   FREEMAIN FOR\n         L     R1,AREALOC\n*\n         FREEMAIN R,LV=(0),A=(1)\n*\nSLUT2    XCTL  EP=IEX21000\n*\n*        HEADING LINES\n*\nHEAD1    DC    C'IDENTIFIER TABLE'\n*\nHEAD2    DC    C'PBN SC    PBN      NAME   TYPE  DM DSP       NAME   TYX\n               PE  DM DSP       NAME   TYPE  DM DSP'\n*\nHEAD3    DC    C'          SURR                  PR LN                 X\n                   PR LN                     PR LN '\n*\nSCSAVE   DC    H'0'                    SAVE SEMICOLON COUNTER\nKF256    DC    F'256'                  USED BY MOVE LOOP\nSAVE2    DC    C'000'                  USED FOR CONVERSION\nSAVE3    DC    XL5'00'\nDOUBLE   DC    D'0'\nMOVEITAB MVC   0(1,R7),11(R7)          USED BY ENDVAR\nWORK     DC    CL30' '                 USED TO BUILD PRINT RECORD\nKF4095   DC    F'4095'                 STORAGE ALLOCATION MAXIMUM\n*\nMOVEVAR  MVC   19(27,R1),WORK          USED TO SORT REC TO BE PRINTED\n         CNOP  0,4\n         MVC   45(27,R1),WORK\n         CNOP  0,4\n         MVC   71(19,R1),WORK\n*\nKF24     DC    F'24'                   USED BY ENDVAR\nFPLEN    DC    H'8'                    4 = SHORT PREC, 8 = LONG PREC\n*                                      INCREASE VALUE DURING\n*                                      STORAGE ALLOCATION\n*\n*        TRANSLATE FOR INTERNAL TO EBCDIC CODE\n*\nTRINTEXT DS    0CL96\n         DC    C' '\n         DC    47C')'\n         DC    C'0123456789'\n         DC    6C')'\n         DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ$_#@))'\n*\n*        FOR PRINTABLE HEXADECIMAL\n*\nTAB      DC    C'0123456789ABCDEF'\nKA11     DC    AL2(11)\n*\n         LTORG\n*\nWORKAREA DSECT\n         COPY  WORKAREA\nKF0      DS    F                  ZERO CONSTANT\nSAVE     DS    F\nSAVE1    DS    4F\nAPBTAB2  DS    A                  START ADDR OF PBTAB2\nATABAD   DS    A                  START ADDR OF ATAB\nDPC      DS    F                  SAVE AREAS FOR R3, R4, R5 AND R6\nWPC      DS    F\nHPC      DS    F\nBPC      DS    F\nAITAB    DS    F                  ITAB ADDR\nAPRNTAR  DS    A                  ADDR OF CURRENT PRINTAREA\nAREALOC  DS    A                  ADDR OF GETMAIN POOL\nSAVEPB   DS    F                  COUNTS NO OF BLOCKS READ\nLENCOUNT DS    H                  SAVES LENGTH OF BLOCK\nBITS1    DS    C\nPROCBIT  EQU   X'02'              PROCEDURE IS PROCESSED\nPROCOFF  EQU   X'FD'\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END   IEX20000\n./ ADD NAME=IEX21    0201-12230-12230-1200-00114-00114-00000-LEVEL\nX21      TITLE 'IEX21 - ERROR MESSAGE EDITING, ALGOL F'\n*\n*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER\n*\n*        FUNCTION/OPERATION -\n*        THE ERROR PATTERNS GENERATED DURING SCANI/II AND ITAB\n*        MANIPULATION ARE HANDLED AND THE CORRESPONDING\n*        DIAGNOSTIC MESSAGES ARE GENERATED\n*\n*        ENTRY POINT -\n*        IEX21000 - ERROR MESSAGE EDITING XCTL EP=IEX21\n*        THE MODULE IS ENTERED FROM IEX20\n*\n*        INPUT - N/A\n*\n*        OUTPUT -\n*        THE DIAGNOSTIC MESSAGES ARE PUT OUT ON SYSPRINT\n*        IF SYSPRINT IS NOT AVAILABLE A WTO IS ISSUED\n*\n*        EXTERNAL ROUTINE -\n*        THE PRINT ROUTINE IN IEX00 IS USED\n*\n*        EXIT - NORMAL -\n*        IF NO TERMINATING ERROR HAS OCCURRED, CONTROL IS GIVEN\n*        TO THE NEXT PHASE BY MEANS OF XCTL EP=IEX30000\n*\n*        EXIT - ERROR -\n*        IF A TERMINATING ERROR HAS OCCURRED (IN THIS MODULE OR\n*        ONE OF THE PRECEDING) CONTROL IS GIVEN TO THE\n*        TERMINATING MODULE BY MEANS OF XCTL EP=IEX51002\n*\n*        TABLES/WORKAREAS -\n*        THE MESSAGE TEXTS WITH CORRESPONDING ADDR TABLE ARE\n*        IN THE LOAD MODULE IEX21M\n*        THE ERROR MESSAGE EDITING ROUTINE, CSECT IEX60000, ALSO\n*        USES THE FOLLOWING TABLES -\n*        WINTEBC  - TRANSLATION OF INTERNAL CHARACTERS TO EBCDIC\n*        WSYMBSRC - TRANSLATION OF SOURCE OPERATORS\n*        WSYMBSTK - TRANSLATION OF STACK OPERATORS\n*        WORDSEBC - TRANSLATION OF COMPOUND SYMBOLS IF SOURCE IN\n*                   EBCDIC\n*        WORDSISO - TRANSLATION OF COMPOUND SYMBOLS IF SOURCE IN\n*                   ISOCODE\n*        WEBCDIC  - TRANSLATION EBCDIC EBCDIC\n*        A WORKAREA OF 270 BYTES, WAREA, IS USED FOR BUILDING\n*        THE MESSAGES\n*\n*        NOTES -\n*        CHARACTER CODE DEPENDENCE - FOR THE BUILDING OF A MESSAGE\n*        (CODE PART BETWEEN COT03 AND COT12) THE FOLLOWING\n*        APPLIES, IN CASE NO SOURCE INFORMATION IS TO BE INSERTED\n*        (COT31), OR IF THE INFORMATION IS EBCDIC CHARACTERS\n*        (COT07), THE OPERATION OF CSECT IEX60000 DEPENDS UPON AN\n*        INTERNAL REPRESENTATION OF THE EXTERNAL CHARACTER SET\n*        WHICH IS EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME.\n*        IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL\n*        CHARACTERS (COT33) THE OPERATION OF CSECT IEX60000\n*        DEPENDS UPON A TRANSLATION FROM THE INTERNAL\n*        REPRESENTATION TO THE EBCDIC CHARACTER SET BY MEANS OF\n*        THE TABLE WINTEBC.\n*        IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL\n*        ALGOL SYMBOLS (COT10) THE OPERATION OF CSECT IEX60000\n*        DEPENDS UPON A TRANSLATION FROM THE INTERNAL\n*        REPRESENTATION TO THE EBCDIC CHARACTER SET BY MEANS OF\n*        THE TABLES 'WSYMBSTK'/'WSYMBSRC' AND 'WORDSISO'/\n*        'WORDSEBC'.\n*        FOR THE OUTPUT OF A MESSAGE (CODE PART BETWEEN COT12\n*        AND COT21) THE FOLLOWING APPLIES -\n*        WHEN A MESSAGE HAS BEEN BUILT IN EBCDIC, AN EBCDIC TO\n*        EBCDIC TRANSLATION IS PERFORMED BEFORE OUTPUT BY MEANS\n*        OF THE TABLE WEBCDIC. THUS THE OUTPUT MAY BE MODIFIED\n*        BY MAKING CHANGES IN THIS TABLE\n*\n*        THE OPERATION OF CSECT IEX21000 DOES NOT DEPEND UPON A\n*        PARTICULAR INTERNAL REPRESENTATION OF THE EXTERNAL\n*        CHARACTER SET\n*\n*        THIS MODULE IS LINKED WITH THE MODULE IEX21M TO FORM\n*        MODULE IEX21\n*\n*        THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN\n*        CONNECTION WITH THE OTHER MODULES OF THE ALGOL COMPILER\n*        IN PARTICULAR IT REQUIRES THE COMMON WORKAREA.\n*\nIEX21000 CSECT\n*\n         IEXENTRY 'IEX21000 LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IEX21000,R15\n*\n         L     R2,=A(IEX60000)         ADDR ERROR MSG EDIT ROUTINE\n         LA    R14,SCAN3               LOAD RETURN ADDR\n         LA    R1,ERRINFO              ADDR INFO FOR ERROR ED ROUTINE\n         BR    R2                      GOTO ERROR MESSAGE EDITING\n*\nSCAN3    XCTL  EP=IEX30000\n*\nERRINFO  DC    V(IEX21M00)             ADDR OF MESSAGE TEXTS\n         DC    V(IEX21M01)             ADDR OF ADDR TABLE\n         DC    H'152'                  MODIFICATION NUMBER\n*\n         LTORG\n*\n         COPY  IEX60000\n*\nWORKAREA DSECT\n*\n         COPY  WORKAREA\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IEX21M   0201-12230-12230-1200-00338-00338-00000-LEVEL\nX2M      TITLE 'IEX21M - ERROR MESSAGE TEXT POOL 1, ALGOL F'\n*\n*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER\n*\n*        FUNCTION/OPERATION -\n*        THIS MODULE CONTAINS MESSAGE TEXTS FOR ALL ERRORS THAT\n*        MAY BE DETECTED BY IEX00, IEX10, IEX11, AND IEX20, AND\n*        THE CORRESPONDING ADDRESS TABLE\n*\n*        ENTRY POINT - N/A\n*\n*        INPUT -  N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES -  N/A\n*\n*        EXITS - NORMAL -  N/A\n*\n*        EXITS - ERROR -  N/A\n*\n*        TABLES/WORKAREAS -  N/A\n*\n*        NOTES -\n*        THIS MODULE IS LINKED WITH THE MODULE IEX21 TO FORM THE\n*        MODULE IEX21\n*\nIEX21M00 CSECT\n*\n         ENTRY IEX21M01\n*\n*        ERROR MESSAGE POOL 1\n*\nWEMPOOL1 EQU   *\n*\nW001     DC    X'1C00'\n         DC    CL27'WINVALID CHARACTER DELETED.'\n*\nW002     DC    X'2100'\n         DC    CL32'WILLEGAL PERIOD. PERIOD DELETED.'\n*\nW003     DC    X'2F0300130C240020000F20'\n         DC    CL37'WINVALID COLON AFTER . COLON DELETED.'\n*\nW004     DC    X'1900'\n         DC    CL24'TLETTER STRING TOO LONG.'\n*\nW005     DC    X'3F00'\n         DC    CL62'SIDENTIFIER BEGINS WITH INVALID CHARACTER. IDENTIFIX\n               ER DELETED.'\n*\nW006     DC    X'2500'\n         DC    CL36'TLABEL CONTAINS TOO MANY CHARACTERS.'\n*\nW007     DC    X'5005001412240027001B27F00000000D43'\n         DC    CL64'WLABEL BEGINNING WITH  CONTAINS INVALID CHARACTER.CX\n               OLON DELETED.'\n*\nW008     DC    X'3500'\n         DC    CL52'WLABEL BEGINS WITH INVALID CHARACTER. COLON DELETEDX\n               .'\n*\nW010     DC    X'3703001F0C24002C000B2C'\n         DC    CL45'SSPECIFICATION PART OF PROCEDURE  INCOMPLETE.'\n*\nW011     DC    X'2800'\n         DC    CL39'SPROGRAM STARTS WITH ILLEGAL DELIMITER.'\n*\nW012     DC    X'3C0300150C240022001A22'\n         DC    CL50'WTWO APOSTROPHES AFTER . FIRST APOSTROPHE DELETED.'\n*\nW013     DC    X'3E0300310C24003E00003E'\n         DC    CL52'WAPOSTROPHE ASSUMED AFTER DELIMITER BEGINNING WITH X\n               .'\n*\nW014     DC    X'470300180C240025002225'\n         DC    CL61'SDELIMITER BEGINNING WITH  INVALID. FIRST APOSTROPHX\n               E DELETED.'\n*\nW015     DC    X'3400'\n         DC    CL51'WMISSING SEMICOLON AFTER ''CODE''. SEMICOLON ASSUMEX\n               D.'\n*\nW016     DC    X'5A0500191224002C001B2CF00000001248'\n         DC    CL74'SIDENTIFIER BEGINNING WITH  CONTAINS INVALID CHARACX\n               TER.IDENTIFIER DELETED.'\n*\nW017     DC    X'3E00'\n         DC    CL61'SMORE THAN 65535 SEMICOLONS. SEMICOLON COUNTER RESEX\n               T TO ZERO.'\n*\nW018     DC    X'2A00'\n         DC    CL41'WDELIMITER ''COMMENT'' IN ILLEGAL POSITION.'\n*\nW020     DC    X'6200'\nC        DC    CL97'TBLOCKS, COMPOUND STATEMENTS, FOR STATEMENTS AND PRX\n               OCEDURE DECLARATIONSNESTED TO TOO MANY LEVELS.'\n*\nW021     DC    X'2B03000A0C240017001417'\n         DC    CL33'SDECLARATOR  IN ILLEGAL POSITION.'\n*\nW022     DC    X'1F00'\n         DC    CL30'TMORE THAN 255 PROGRAM BLOCKS.'\n*\nW023     DC    X'1700'\n         DC    CL22'SSTRING POOL OVERFLOW.'\n*\nW024     DC    X'3700'\n         DC    CL54'SDELIMITER ''CODE'' IN ILLEGAL POSITION. ''CODE'' DX\n               ELETED.'\n*\nW025     DC    X'530300310CF0000000153E'\n         DC    CL73'SSPECIFIER ''STRING'' OR ''LABEL'' IN ILLEGAL POSITX\n               ION.SPECIFICATION DELETED.'\n*\nW026     DC    X'430300090C240016002D16'\n         DC    CL57'WPARAMETER  MULTIPLY SPECIFIED. FIRST SPECIFICATIONX\n                USED.'\n*\nW027     DC    X'550500091224001C00231CF00000001540'\n         DC    CL69'SPARAMETER  MISSING FROM FORMAL PARAMETER LIST.SPECX\n               IFICATION IGNORED.'\n*\nW028     DC    X'3E00'\n         DC    CL61'SDELIMITER ''VALUE'' IN ILLEGAL POSITION. ''VALUE''X\n                PART DELETED.'\n*\nW029     DC    X'2900'\n         DC    CL40'WSPECIFICATION PART PRECEDES VALUE PART.'\n*\nW030     DC    X'2D0300090C240016001716'\n         DC    CL35'WPARAMETER  REPEATED IN VALUE PART.'\n*\nW031     DC    X'660500391224004C00004CF0000000194D'\n         DC    CL86'WLEFT PARENTHESIS NOT FOLLOWED BY / AFTER ARRAY IDEX\n               NTIFIER .SUBSCRIPT BRACKET ASSUMED.'\n*\nW032     DC    X'5C05003512240048000048F00000001349'\n         DC    CL76'SMISSING RIGHT PARENTHESIS IN BOUND PAIR LIST OF ARX\n               RAY .DECLARATION DELETED.'\n*\nW033     DC    X'440300370C240044000044'\n         DC    CL58'TMORE THAN 16 DIMENSIONS OR COMPONENTS IN DECLARATIX\n               ON OF .'\n*\nW034     DC    X'6805000D12240020002320F00000002444'\n         DC    CL88'SARRAY SEGMENT  NOT FOLLOWED BY SEMICOLON OR COMMA.X\n               CHARACTERS TO NEXT SEMICOLON DELETED.'\n*\nW035     DC    X'3900'\n         DC    CL56'WILLEGAL PERIOD IN ARRAY OR SWITCH LIST. PERIOD DELX\n               ETED.'\n*\nW036     DC    X'360300290C240036000036'\n         DC    CL44'TMORE THAN 15 PARAMETERS IN DECLARATION OF .'\n*\nW037     DC    X'6805003012240043000043F00000002444'\n         DC    CL88'SSEMICOLON MISSING AFTER FORMAL PARAMETER LIST OF .X\n               CHARACTERS TO NEXT SEMICOLON DELETED.'\n*\nW038     DC    X'2B00'\n         DC    CL42'TTOO MANY IDENTIFIERS DECLARED IN A BLOCK.'\n*\nW039     DC    X'790484000F00390FF00000003049'\n         DC    CL108'S MISSING ''END'' BRACKETS. OPEN BLOCKS, COMPOUND X\n               STATEMENTS,FOR STATEMENTS AND PROCEDURE DECLARATIONS CLOX\n               SED.'\n*\nW041     DC    X'1F00'\n         DC    CL30'TMORE THAN 255 FOR STATEMENTS.'\n*\nW042     DC    X'3A00'\n         DC    CL57'W''BEGIN'' PRECEDES PRECOMPILED PROCEDURE. ''BEGIN'X\n               ' DELETED.'\n*\nW043     DC    X'5E0300300CF0000000213D'\n         DC    CL84'SEQUAL NUMBER OF ''BEGIN'' AND ''END'' BRACKETS FOUX\n               ND.REMAINING PART OF PROGRAM IGNORED.'\n*\nW044     DC    X'1A00'\n         DC    CL25'TNO SOURCE PROGRAM FOUND.'\n*\nW045     DC    X'4003000A0C240017002917'\n         DC    CL54'SIDENTIFIER  MULTIPLY DECLARED. LAST DECLARATION USX\n               ED.'\n*\nW045B    DC    X'300300230C240030000030'\n         DC    CL38'SILLEGAL CALL BY VALUE OF IDENTIFIER .'\n*\n*        DIRECTORY MESSAGES, INITIATION PHASE\n*\nW200     EQU   *\nW046     DC    X'380300100C84001D001B1D'\n         DC    CL46'WOPTION PARAMETER  INVALID. PARAMETER IGNORED.'\n*\nW201     EQU   *\nW047     DC    X'2D03000B0C840018001518'\n         DC    CL35'TDD CARD FOR  INCORRECT OR MISSING.'\n*\nW202     EQU   *\nW048     DC    X'4100'\n         DC    CL64'WDD CARD FOR SYSLIN INCORRECT OR MISSING. OPTION NOX\n               LOAD ASSUMED.'\n*\nW203     EQU   *\nW049     DC    X'4300'\n         DC    CL66'WDD CARD FOR SYSPUNCH INCORRECT OR MISSING. OPTION X\n               NODECK ASSUMED.'\n*\nW204     EQU   *\nW050     DC    X'2A00'\n         DC    CL41'TBLOCKSIZE SPECIFIED FOR SYSIN INCORRECT.'\n*\nW205     EQU   *\nW051     DC    X'480300170C840024002424'\n         DC    CL62'WBLOCKSIZE SPECIFIED FOR  INCORRECT. UNBLOCKED OUTPX\n               UT ASSUMED.'\n*\nW206     EQU   *\nW052     DC    X'4200'\n         DC    CL65'WTOO MANY OPTION PARAMETER ERRORS. SUBSEQUENT PARAMX\n               ETERS IGNORED.'\n*\nW207     EQU   *\nW053     DC    X'2700'\n         DC    CL38'WPOSSIBLE ERROR IN DD NAMES PARAMETER.'\n*\nW208     EQU   *\nW054     DC    X'2D00'\n         DC    CL44'WSIZE PARAMETER INVALID. SIZE 45056 ASSUMED.'\n*\n*        OTHER DIRECTORY MESSAGES\n*\nW209     EQU   *\nW055     DC    X'460400360FF00000840046000046'\n         DC    CL57'TCOMPILATION UNSUCCESSFUL DUE TO PROGRAM INTERRUPT.X\n                PSW .'\n*\nW056     EQU   *\nW210     EQU   *\n         DC    X'300300230C840030000030'\n         DC    CL38'TUNRECOVERABLE I/O ERROR ON DATA SET .'\n*\nW057     EQU   *\nW211     EQU   *\n         DC    CL56'PROGRAM INTERRUPT IN ERROR MESSAGE EDITING ROUTINE.X\n                PSW '\n*\nW058     EQU   *\nW212     DC    X'1200'\n         DC    CL17'TTOO MANY ERRORS.'\n*\nW059     EQU   *\nW213     DC    X'2800'\n         DC    CL39'TINTERNAL OVERFLOW OF IDENTIFIER TABLE.'\n*\nW060     EQU   *\nW214     DC    X'3903002D0C84003A00003A'\n         DC    CL48'SDATA STORAGE AREA EXCEEDED, PROGRAM BLOCK NO. .'\n*\nW215     EQU   *\nW061     DC    X'1A00'\n         DC    CL25'TSOURCE PROGRAM TOO LONG.'\n*\nW216     DC    X'2600'\n         DC    CL37'STOO MANY LABELS. LABEL NUMBER RESET.'\n*\n         DC    0F'0'\n*\n*        ADDRESS TABLE FOR WEMPOOL1\n*\nIEX21M01 DC    A(0)\n         DC    A(W001)\n         DC    A(W002)\n         DC    A(W003)\n         DC    A(W004)\n         DC    A(W005)\n         DC    A(W006)\n         DC    A(W007)\n         DC    A(W008)\n         DC    A(0)\n         DC    A(W010)\n         DC    A(W011)\n         DC    A(W012)\n         DC    A(W013)\n         DC    A(W014)\n         DC    A(W015)\n         DC    A(W016)\n         DC    A(W017)\n         DC    A(W018)\n         DC    A(0)\n         DC    A(W020)\n         DC    A(W021)\n         DC    A(W022)\n         DC    A(W023)\n         DC    A(W024)\n         DC    A(W025)\n         DC    A(W026)\n         DC    A(W027)\n         DC    A(W028)\n         DC    A(W029)\n         DC    A(W030)\n         DC    A(W031)\n         DC    A(W032)\n         DC    A(W033)\n         DC    A(W034)\n         DC    A(W035)\n         DC    A(W036)\n         DC    A(W037)\n         DC    A(W038)\n         DC    A(W039)\n         DC    A(0)\n         DC    A(W041)\n         DC    A(W042)\n         DC    A(W043)\n         DC    A(W044)\n         DC    A(W045)\n         DC    A(0)\n         DC    A(W045B)\n         DC    A(W046)\n         DC    A(W047)\n         DC    A(W048)\n         DC    A(W049)\n         DC    A(W050)\n         DC    A(W051)\n         DC    A(W052)\n         DC    A(W053)\n         DC    A(W054)\n         DC    A(W055)\n         DC    A(W056)\n         DC    A(W057)\n         DC    A(W058)\n         DC    A(W059)\n         DC    A(W060)\n         DC    A(W061)\n         DC    A(W216)\n*\n         END\n./ ADD NAME=IEX30    0201-12230-12230-1200-03071-03071-00000-LEVEL\nX30      TITLE 'IEX30 - SCAN III, ALGOL F'\n*\n*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER\n*\n*        FUNCTION/OPERATION -\n*        EXTERNAL NAMES OF IDENTIFIERS ARE REPLACED BY THE\n*        INTERNAL NAMES CONTAINED IN THE ITAB ENTRY OF THE\n*        IDENTIFIER, AND CONSTANTS ARE REPLACED BY INTERNAL NAMES\n*        CONSTRUCTED IN IEX30\n*        OBJECT CODE IS PRODUCED FROM THE CONSTANT POOL IF\n*        PARAMETERS DECK OR LOAD ARE SPECIFIED IN THE\n*        EXEC STATEMENT\n*        FOR STATEMENTS ARE CLASSIFIED FOR FURTHER USE BY IEX50\n*        THE SUBSCRIPT TABLE (SUTAB) AND THE LEFT VARIABLE TABLE\n*        (LVTAB) ARE CONSTRUCTED FOR FURTHER USE BY IEX40\n*        SOURCE PROGRAM ERRORS CAUSES GENERATION OF ERROR\n*        PATTERNS FOR FUTHER USE BY 1EX31\n*\n*        ENTRY POINT - IEX30000 FROM IEX21000 VIA XCTL\n*\n*        INPUT -\n*        THE SOURCE PROGRAM MODIFICATION LEVEL 1 IS READ FROM\n*        SYSUT1\n*        THE IDENTIFIER TABLE (ITAB) IS READ FROM SYSUT3\n*\n*        OUTPUT -\n*        THE SOURCE PROGRAM MODIFICATION LEVEL 2 IS WRITTEN OUT\n*        ON SYSUT2\n*        OBJECT TXT RECORDS IS WRITTEN ON SYSLIN OR/AND SYSPUNCH\n*        IF THE PARAMETERS LOAD OR/AND DECK ARE SPECIFIED IN THE\n*        EXEC CARD\n*        THE SUBSCRIPT TABLE (SUTAB) IS WRITTEN OUT ON SYSUT3\n*        A LINEAR SUBSCRIPT EXPRESSION ENCOUNTED IN A FOR\n*        STATEMENT THAT IS OPTIMIZABLE IN REGARD TO SUBSCRIPTS\n*        WILL GENERATE AN ENTRY IN THIS TABLE\n*        THE LEFT VARIABLE TABLE (LVTAB) IS WRITTEN OUT ON\n*        SYSUT3. INTEGER LEFT VARIABLES ENCOUNTED IN FOR\n*        STATEMENT THAT IS OPTIMIZABLE IN REGARD TO SUBSCRIPTS\n*        WILL GENERATE AN ENTRY IN THIS TABLE\n*\n*        EXTERNAL ROUTINES -\n*        THE INTERRUPT ROUTINE OF IEX00 ARE USED FOR ALL\n*        INTERRUPTS EXCEPT FLOATING POINT OVERFLOW\n*\n*        EXITS - NORMAL -\n*        CONTROL IS ALWAYS GIVEN TO IEX31 BY MEANS OF XCTL\n*        EP=IEX31\n*\n*        TABLES/WORKAREAS -\n*        GROUP TABLE (GPTAB) CONSTRUCTED IN IEX11, USED TO\n*        DIAGNOSE BRANCHES INTO FOR STATEMENTS.\n*        SCOPE TABLE (SPTAB) CONSTRUCTED IN IEX11, USED TO CHECK\n*        SUBSCRIPT EXPRESSIONS FOR POSSIBLE OPTIMIZATION\n*        FOR STATEMENT TABLE (FSTAB) CONSTRUCTED IN IEX30\n*        COMPLEATED IN IEX40 AND FINALLY USED IN IEX50, CONTAINS\n*        A CLASSIFICATION BYTE FOR EVERY FOR STATEMENT\n*        ERROR POOL CONSTRUCTED IN IEX30 AND USED IN IEX31,\n*        CONTAINS ERROR PATTERNS GENERATED FROM SOURCE PROGRAM\n*        ERRORS\n*        CONSTANT POOL INTERNAL TABLE IN IEX30. THE FIRST\n*        APPEARANCE OF A CONSTANT IN THE SOURCE STREAM GENERATES\n*        AN ENTRY IN THE TABLE. THE RELATIVE ADDRESS OF THE\n*        CONSTANT POOL ENTRY IS USED IN CONSTRUCTING THE\n*        INTERNAL NAME OF A CONSTANT CRITICAL VARIABLE TABLE\n*        (CRIDTAB) INTERNAL TABLE IN IEX30\n*        DURING THE TREATMENT OF A FOR STATEMENT THE TABLE\n*        CONTAINS ENTRIES CORRESPONDING TO THE IDENTIFIERS IN THE\n*        FOR LIST\n*\n*        NOTES -\n*        THE OPERATION OF THIS MODULE DOES NOT DEPEND ON ANY\n*        SPECIAL REPRESENTATION OF THE CHARACTER SET. THIS MODULE\n*        IS ONLY INTENDED TO BE EXECUTED IN CONNECTION WITH THE\n*        OTHER MODULES OF THE ALGOL COMPILER. IN PARTICULAR IT\n*        REQUIRES THE COMMON WORKAREA\n*\nIEX30000 CSECT\n*\n*        R3                            INPUT RECORD POINTER REGISTER\n*        R4                            OUTPUT RECORD POINTER REGISTER\n*\n*        BIT PATTERNS\n*\nSARRAY   EQU   X'80'                   HANDLING ARRAY DECLARATION\nSSWITCH  EQU   X'40'                   HANDLING SWITCH DECLARATION\nFF       EQU   X'FF'\n*                                      SCALE FACTOR MASKS\nSFSIGN   EQU   X'80'                   SIGNED SCALE FACTOR\nSFL0     EQU   X'40'                   LEADING ZERO IN SCALE FACTOR\nSF19     EQU   X'20'                   SIGNIFICANT DIGIT IN SCALE FAC\nSF       EQU   X'10'                   SCALE FACTOR PRESENT\nSFDIGIT  EQU   X'60'\nSFLSIGN  EQU   X'E0'\nPRECERR  EQU   X'08'                   REAL CONSTANT EXCEEDS PRECISION\n*\n*        CLASSIFICATION MASKS OF I/O STATUS ON SYSUT3\n*\nREADM    EQU   X'80'                   UNCHECKED READ OPERATION\nWRITEM   EQU   X'40'                   UNCHECKED WRITE OPERATION\nREADC    EQU   X'20'                   CHECKED READ OPERATION\nWRITEC   EQU   X'10'                   CHECKED WRITE OPERATION\n*\n*        FOR STATEMENT CLASSIFICATION MASKS\n*\nNOCOUNT  EQU   X'80'                   COUNTING LOOP IMPOSSIBLE\nNOSUOP   EQU   X'40'                   NO SUBSCRIPT OPTIMIZATION\nOUTOFFOR EQU   X'20'                   BRANCH OUT OF FOR STATEMENT\nNORMAL   EQU   X'F0'                   NORMAL LOOP\nSTEPM    EQU   X'08'                   STEP IN FORLIST\nWHILEM   EQU   X'84'                   WHILE IN FOR LIST\n*\n         IEXENTRY 'IEX30000 LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IEX30000,R10,R11,R12\n         LR    R10,R15\n         LA    R11,2048(,R15)\n         LA    R11,2048(,R11)\n         LA    R12,2048(,R11)\n         LA    R12,2048(,R12)\n*\n         USING WORKAREA,R13\n*\n         LA    R5,TERM1                ERROR EXIT ADDR\n         ST    R5,ERET\n         LA    R5,LOMEGA6              PROVIDE EOD ADDR\n         ST    R5,EODUT1               FOR UT1\n         MVC   SEMCNT,ZERO             ZERO SEMICOLON COUNTER\n*\n         SPIE  INTERUPT,((1,7),9,11,12,15)\n*\n         ST    R1,OLDSPIE              SAVE ADDR OF OLD PICA\n*\n*        ALLOCATE STORAGE FOR TABLESD\n*\n         LH    R0,KH4096               CONSTANT POOL SIZE\n         A     R0,ITAB30S              ITABSIZE\n         A     R0,SRCE1S               INPUT BUFFER SIZE\n         A     R0,SRCE3S               OUTPUT BUFFER SIZE\n         A     R0,SRCE3S               OUTPUT BUFFER SIZE\n         A     R0,CRIDTABS             CRIDTAB SIZE\n         A     R0,SUTAB30S             SUTAB SIZE\n         A     R0,LVTAB30S             LVTAB SIZE\n         AH    R0,KH8                  RECORD KEY LENGTH\n         ST    R0,TABSIZE              SAVE TABLE AREA LENGTH\n*\n         GETMAIN R,LV=(0)              ALLOCATE STORAGE\n*\n         LA    R5,TERM2                ERROR RETURN ADDR\n         ST    R5,ERET\n         ST    R1,ZKOPOOL              CONSTANT POOL START ADDR\n         AH    R1,KH4096\n         ST    R1,ZIBSTAO              ITAB START ADDR\n         A     R1,ITAB30S\n         ST    R1,ZIBREAD              SECOND INPUT BUFFER START ADDR\n         A     R1,SRCE1S\n         ST    R1,ZOBWORK              OUTPUT BUFFER START ADDR\n         A     R1,SRCE3S\n         ST    R1,ZOBWRITE             OUTPUT BUFFER START ADDR\n         A     R1,SRCE3S\n         ST    R1,ZFOCRI               CRIDTAB START ADDR\n         A     R1,CRIDTABS\n         ST    R1,SUSTRT               SUTAB START ADDR\n         A     R1,SUTAB30S\n         LA    R1,4(,R1)\n         ST    R1,LVSTRT               LVTAB START ADDR\n*\n*        INITIALIZE INPUT BUFFERS\n*\n         L     R3,SRCE1ADD             ADDR OF FIRST INPUT BUFFER\n         ST    R3,ZIBRUN\n         TM    COMPFLGS+2,SPIC         SOURCE PROG IN STORAGE ?\n         BO    INCORE                  YES\n         BAL   R15,ICHAI               READ FIRST RECORD\n*\n*        ITAB POINTERS INITIALIZATION\n*\nINCORE   L     R1,ZIBSTAO              ITAB START ADDR\n         MVC   0(256,R1),FIXITAB       INSERT ITAB FIXED PART\n         MVC   256(FIXITABL-256,R1),FIXITAB+256\n         LA    R5,FIXITABL-11(,R1)     R5 -> LAST FIXED ENTRY\n         ST    R5,ZCURITEN             STORE IN ZCURITEN\n         LA    R5,11(,R5)              ADDR FIRST FREE ITAB ENTRY\n         ST    R5,ZITREC\n         A     R1,ITAB30S              ITAB END ADDR PLUS 1\n         ST    R1,ZITEND\n         L     R1,AUT3DCB              R1 -> SYSUT3 DCB\n*\n         NOTE  (1)                     ID OF LAST ITAB BLOCK\n*\n         ST    R1,SULTSTRT             TRANSFER TO SUBSCRIPT HANDLING\n         ST    R1,NOTEW                PREPARE WRITE OF SUTAB OR LVTAB\n         L     R5,AUT3DCB              R5 -> SYSUT3 DCB\n*\n         CLOSE ((R5),REREAD),TYPE=T    TEMPORARY CLOSE\n*\n         BAL   R15,ITABREAD            READ FIRST ITAB RECORD\n*\n*        INITIALIZE OUTPUT BUFFERS\n*\n         L     R4,ZOBWORK              START OF ACTIVE OUTPUT BUFFER\n         L     R5,SRCE3S               LENGTH OF OUTPUT BUFFER\n         SH    R5,KH12                 SET BUFFER END PTRS\n         AR    R5,R4\n         ST    R5,ZFILE9\n         LA    R5,3(,R5)\n         ST    R5,ZFILE6\n         LA    R5,1(,R5)\n         ST    R5,ZFILE5\n         LA    R5,2(,R5)\n         ST    R5,ZFILE3\n         LA    R5,1(,R5)\n         ST    R5,ZFILE2\n         LA    R5,1(,R5)\n         ST    R5,ZFILE1\n         BCTR  R4,0\n*\n*        CRIDTAB AND FSTAB INITIALIZATION\n*\n         L     R1,ZFOCRI               CRIDTAB START ADDR\n         SH    R1,KH9                  INITIALIZE PTRS\n         ST    R1,PFANO\n         ST    R1,PFA                  CURRENT CRIDTAB PTR\n         A     R1,CRIDTABS             GET ADDR OF LAST ENTRY\n         ST    R1,PFAMAX               END PTR\n         MVI   ZFOSTA,0                ZERO FSTAB\n         MVC   ZFOSTA+1(254),ZFOSTA\n         LA    R5,FSTAB-1              START ADDR OF FSTAB -1\n         ST    R5,ZFSPTR               INITIALIZE FORSTATEMENT ZERO\n*\n*        SUTAB INITIALIZATION\n*\n         L     R1,SUSTRT               SUTAB START ADDR\n         MVC   0(4,R1),SUKEY           SET SUTAB KEY\n         SH    R1,KH10                 INITIALIZE PTRS\n         ST    R1,ZSUDAD               START PTR\n         ST    R1,ZSUTAPO              CURRENT PTR\n         A     R1,SUTAB30S\n         ST    R1,ZSUTMAX              END PTR\n*\n*        LVTAB INITIALIZATION\n*\n         L     R1,LVSTRT               LVTAB START ADDR\n         MVC   0(4,R1),LVKEY           SET LVTAB KEY\n         ST    R1,ZLESTA               START PTR\n         ST    R1,ZLEVA                CURRENT PTR\n         A     R1,LVTAB30S\n         ST    R1,ZLEMAX               END PTR\n*\n*        LITERAL HANDLING INITIALIZATION\n*\n         TM    COMPFLGS,LNG            LONG PRECISION ?\n         BNZ   INLIT2                  YES\n         LA    R5,4\n         ST    R5,LREAL\n         LA    R5,7\n         ST    R5,NREAL                MAXIMAL PRECISION\n*\n*        CONSTANT POOL INITALIZATION\n*\nINLIT2   L     R1,ZKOPOOL              CONSTANT POOL START ADDR\n         LH    R5,KH4096               LENGTH OF CONSTANT POOL\n         AR    R5,R1                   CONSTANT POOL END ADDR\n         ST    R5,ZKOPEND              END PTR\n         A     R1,PRPT\n         ST    R1,ZWP                  WORD PTR\n         ST    R1,ZDWP                 DOUBLE WORD PTR\n         ST    R1,ZLITSTA              START ADDR OF ACTIVE POOL\n         AH    R1,TXTPUT               TXT OUTPUT PTR\n         ST    R1,ZTEXTCO\n         MVC   ZKBNMAX(2),PBN          PREPARE CONSTANT POOL EXCHANGE\n         MVC   KBN(2),ZERO             CURRENT POOL NUMBER\n*\n*        START READ INTO ALTERNATE INPUT BUFFER IF NECESSARY\n*\n         TM    COMPFLGS+2,SPIC         SOURCE PROG IN STORAGE ?\n         BO    INITEND                 YES\n         BAL   R15,ICHA\nINITEND  NI    COMPFLGS+2,255-NOSC     SET SEMICOLON COUNTER VALID\n         TM    COMPFLGS,PROC           PRECOMPILED PROCEDURE ?\n         BZ    GENTEST                 NO\n         BAL   R15,ITABMOVE            YES, GET ITAB RECORD\n         B     GENTEST\n*\nGENTEST1 LA    R3,1(,R3)\nGENTEST  SR    R2,R2\n         TRT   0(80,R3),GENER\n         B     *(R2)\n         B     LETTER                  + 04\n         B     DIGIT19                 + 08\n         B     DIGIT0                  + 12\n         B     DECPOIN                 + 16\n         B     SCAFACT                 + 20\n         B     QUOTE                   + 24\n         B     BETA                    + 28\n         B     PIPHI                   + 32\n         B     FOR                     + 36\n         B     EPSILON                 + 40\n         B     ETA                     + 44\n         B     DO                      + 48\n         B     WHILE                   + 52\n         B     SEMIDELT                + 56\n         B     OPBRACK                 + 60\n         B     COMMA                   + 64\n         B     CLOBRACK                + 68\n         B     ZETA                    + 72\n         B     GAMMA                   + 76\n         B     OMEGA                   + 80\n         B     OTHOP                   + 84\n         B     RHO                     + 88\n         B     STEP                    + 92\n         B     ARRAY                   + 96\n         B     SWITCH                  +100\n         B     DIPOW                   +104\n*\n*        STRING OR LOGICAL VALUE\n*\nQUOTE    C     R4,ZFILE5               OUTPUT BUFFER EXCHANGE ?\n         BH    LQUOT2                  YES\nLQUOT3   MVC   1(5,R4),1(R3)           OUTPUT INTERNAL NAME\n         LA    R3,6(,R3)\n         CLI   0(R3),X'2E'             FOLLOWS AN OPERATOR ?\n         BNL   LQUOT1                  PROBABLY NOT, MIGHT BE ZETA\nLQUOT5   LA    R4,5(,R4)               STEP OUTPUT PTR\n         B     GENTEST                 BRANCH TO GENTEST\n*\nLQUOT2   BAL   R15,OUCHA               BRANCH TO SUBROUTINE OUCHA\n         B     LQUOT3                  BRANCH TO LQUOT3\n*\nLQUOT1   CLI   0(R3),XFZETA            ZETA ?\n         BNE   LQUOT4                  NO, GIVE ERROR MESSAGE\n         BAL   R15,ICHA                CHANGE INPUT BUFFER\n         CLI   0(R3),X'2E'             FOLLOWS OPERATOR ?\n         BL    LQUOT5                  YES\nLQUOT4   MVC   ZIDEX(6),ZPOINT         REPLACE OPERAND BY SIX POINTS\n         LA    R8,ZIDEX+6\n         LA    R0,ZIDEX+12\n         MVC   ZERRONU,INVOP\n         B     INCOROP                 INCORRECT OPERAND ERROR ROUTINE\n*\n*        PROGRAM BLOCK BEGIN\n*\nBETA     CLI   LETTER+1,X'F0'          PROCEDURE BLOCK TO READ ?\n         BE    LBETA4                  YES\nBETA1    BAL   R15,ITABMOVE            READ ITAB BLOCK\nLBETA2   C     R4,ZFILE2               COMPARE ZOUT WITH ZFILE(2)\n         BH    LBETA1                  BRANCH IF HIGH\nLBETA3   MVC   1(2,R4),0(R3)\n         LA    R4,2(,R4)               INCR ZOUT BY 2\n         MVC   ZIGN(2),2(R3)           IGN IS RECOGNIZED AND STORED\n         LA    R3,4(,R3)               INCR ZIN BY 4\n         B     GENTEST                 BRANCH TO GENTEST\n*\nLBETA1   BAL   R15,OUCHA               BRANCH TO SUBROUTINE OUCHA\n         B     LBETA3                  BRANCH TO LBETA 2\n*\nLBETA4   BAL   R15,ITABMOP             READ PROCEDURE BLOCK\n         B     BETA1\n*\n*        PROCEDURE BLOCK BEGIN\n*\nPIPHI    NI    IDENT4+1,X'0F'          PROC HEAD SWITCH ON\n         CLI   LETTER+1,X'F0'          PROCEDURE BLOCK TO READ ?\n         BE    LPIPHI6\nPIPHI1   MVC   ZIGN(2),1(R3)           SAVE CURRENT IGN\n         C     R4,ZFILE6               SPACE IN OUTPUT BUFFER ?\n         BH    LPIPHI1                 BRANCH IF HIGH\nLPIPHI2  MVC   1(1,R4),0(R3)           OPERATOR IS MOVED TO O-BUFFER\n         LA    R4,1(,R4)               INCR ZOUT BY 1\n         LA    R3,3(,R3)               INCR ZIN BY 3\nLPIPHI3  CLI   0(R3),XFA               LETTER FOLLOWS IN SOURCE INPUT ?\n         BL    LPIPHI4                 NO\n         OI    LETTER+1,X'F0'          YES, SET PROCEDURE SWITCH\n         B     LETTER                  GET IDENT AND READ ITAB\n*\nLPIPHI4  CLI   0(R3),XFZETA            ZETA IN SOURCE INPUT ?\n         BE    LPIPHI5                 YES\n         BAL   R15,ITABMOVE            NO, READ ITAB BLOCK\n         B     GENTEST\n*\nLPIPHI5  BAL   R15,ICHA                GET NEXT INPUT RECORD\n         B     LPIPHI3\n*\nLPIPHI1  BAL   R15,OUCHA               BRANCH TO SUBROUTINE OUCHA\n         B     LPIPHI2                 BRANCH TO LPIPHI2\n*\nLPIPHI6  BAL   R15,ITABMOP             READ PROCEDURE BLOCK\n         B     PIPHI1\n*\n*        FOR STATEMENT BEGIN\n*\nFOR      MVI   ZFORTEST,X'C0'          ZFORTEST IS SET TO X'C0'\n         L     R5,ZFSPTR               UPDATE PTR TO FSTAB ENTRY\n         LA    R5,1(,R5)\n         ST    R5,ZFSPTR\n         LA    R6,FSTAB                GET FOR STATEMENT NUMBER\n         SR    R5,R6\n         STC   R5,ZFSN\nLFOR3    MVC   ZIGN(2),1(R3)           IGN IS RECOGNIZED AND STORED\n         C     R4,ZFILE1               TEST IF SPACE IN OUTPUT BUFFER\n         BH    LFOR1                   BRANCH IF HIGH\nLFOR4    MVC   1(1,R4),0(R3)\n         LA    R4,1(,R4)               INCR ZOUT\n         LA    R3,3(,R3)               INCR ZIN BY 3\n         B     GENTEST                 BRANCH TO GENTEST\n*\nLFOR1    BAL   R15,OUCHA               CALL SUBROUTINE OUCHA\n         B     LFOR4                   BRANCH TO LFOR2\n*\n*        END OF PROGRAM OR PROCEDURE BLOCK\n*\nEPSILON  CLI   LETTER+1,X'F0'          ITAB BLOCK TO READ ?\n         BE    EPSILON2                YES\nEPSILON1 L     R6,ZCURITEN             ADDR LAST ITAB ENTRY\n         SH    R6,ZCURITLE             ZCURITEN = ZCURITEN - ZCURITLE\n         ST    R6,ZCURITEN             ZCURITEN IS STORED\n         MVC   ZCURITLE(2),17(R6)      ZCURITLE IS UPDATED\n         B     LBETA2                  BRANCH TO LBETA2\n*\nEPSILON2 BAL   R15,ITABMOP             READ ITAB BLOCK\n         B     EPSILON1\n*\n*        FOR STATEMENT END\n*\nETA      MVI   ZFORTEST,0              ZERO ZFORTEST\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    LFOR3                   YES\n         BAL   R15,CRIFODEL            CALL CRIFODEL\n         B     LFOR3                   BRANCH TO LFOR3\n*\n*        FOR LIST END\n*\nDO       MVI   ZFORTEST,0              ZERO ZFORTEST\nLDO3     C     R4,ZFILE1               COMPARE ZOUT WITH ZFILE\nOTHOP    EQU   LDO3\n         BH    LDO1                    HIGH, BRANCH\nLDO2     MVC   1(1,R4),0(R3)           OPERATOR IS MOVED TO O BUFFER\n         LA    R4,1(,R4)               INCR ZOUT\n         B     GENTEST1\n*\nLDO1     BAL   R15,OUCHA               BRANCH TO SUBROUTINE OUCHA\n         B     LDO2                    BRANCH TO LDO2\n*\n*        WHILE\n*\nWHILE    L     R5,ZFSPTR               ADDR FSTAB ENTRY\n         OI    0(R5),WHILEM            INDICATE 'WHILE HAS APPEARED'\n         B     LDO3\n*\n*        STEP OPERATOR\n*\nSTEP     L     R5,ZFSPTR               ADDR FSTAB ENTRY\n         OI    0(R5),STEPM             INDICATE 'STEP HAS APPEARED'\n         B     LDO3\n*\n*        DIVIDE AND POWER ROUTINE\n*\nDIPOW    CLI   ZFORTEST,0              OPERATOR IN FOR LIST ?\n         BE    OTHOP                   NO, MOVE TO OUTPUT STREAM\n         L     R5,ZFSPTR               YES, ADDR FSTAB ENTRY\n         OI    0(R5),NOCOUNT           COUNTING LOOP IMPOSSIBLE\n         B     OTHOP                   MOVE TO OUTPUT STREAM\n*\n*        SEMICOLON OR DELTA\n*\nSEMIDELT MVC   SEMCNT,1(R3)            SAVE SEMICOLON COUNTER\n         OI    IDENT4+1,X'F0'          PROC HEAD SWITCH OFF\n         C     R4,ZFILE3               COMPARE ZOUT WITH ZFILE(3)\n         BH    LSEM1                   HIGH, BRANCH\nLSEM2    MVC   1(3,R4),0(R3)           OPERATOR,SC ARE MOVED TO O-BUFF\n         LA    R4,3(,R4)               ZOUT IS INCREASED BY 3\n         LA    R3,3(,R3)               ZIN IS INCREASED BY 3\n         MVI   STATUS,0                TURN OFF SWITCH OR ARRAY BITS\n         B     GENTEST                 BRANCH TO GENTEST\n*\nLSEM1    BAL   R15,OUCHA               CALL SUBROUTINE OUCHA\n         B     LSEM2                   BRANCH TO LSEM2\n*\nSWITCH   OI    STATUS,SSWITCH          SET ON SWITCH SWITCH\n         B     OTHOP\n*\nARRAY    OI    STATUS,SARRAY           SET ON ARRAY SWOTCH\n         MVC   BRCNT(2),ZERO           ZERO BRACKET COUNTER\n         B     OTHOP                   OUTPUT OPERATOR\n*\n*        PROGRAM END\n*\nOMEGA    MVC   1(1,R4),0(R3)\n         OI    COMPFLGS+2,NOSC         SET SEMICOLON COUNTER NOT VALID\n         TM    COMPFLGS+2,SPIC         SOURCE PROG IN STORAGE ?\n         BO    LOMEGA6                 YES, BRANCH\n*\n         CHECK SREAD\n*\nLOMEGA6  L     R5,AUT1DCB              R5 -> SYSUT1 DCB\n*\n         CLOSE ((R5))                  CLOSE SYSUT1 FINALY\n*\n         CLC   KH1,ZOUTCOT             ZOUTCOT = 1 ?\n         BE    LOMEGA1                 YES, BRANCH\n         LA    R4,1(,R4)               SAVE OMEGA FROM OVERLAY\n         BAL   R15,OUCHA               WRITE LAST RECORD\n         NI    COMPFLGS+2,255-SPIC     OUTPUT ON SECONDARY STORAGE\n*\n         CHECK SWRITE                  CHECK LAST OUTPUT RECORD\n*\n*        WRITE OUT CONSTANT POOL\n*\nLOMEGA3  L     R9,ZDWP                 ADDR OF FREE BYTE IN CONST POOL\n         LR    R5,R9\n         AH    R5,TXTPUT               MORE TXT TO WRITE ?\n         C     R5,ZTEXTCO\n         BE    LOMEGA2\n         BAL   R14,TXTTRAF             YES, WRITE REST OF CONST POOL\n*\nLOMEGA2  EQU   *\nTERM2    EQU   *\n         SR    R5,R5\n         IC    R5,ZFSN\n         STH   R5,FSNMAX\n         MVC   SUCOUNT(2),SUCNT        NUMBER OF SUTAB RECORDS\n         MVC   LVCOUNT(2),LVCNT        NUMBER OF LVTAB RECORDS\n         L     R1,SULENGTH             GET FULL LENGTH OF SUTAB\n         A     R1,ZSUTAPO\n         S     R1,ZSUDAD\n         ST    R1,ZSUTEN               LENGTH OF SUTAB\n         BZ    LOMEGA4\n         CLC   ZSUTAPO(4),ZSUDAD       ANYTHING IN SUTAB BUFFER ?\n         BE    LOMEGA5                 NO\n         BAL   R5,CHECK                CHECK LAST I/O OPERATION ON UT3\n         L     R5,SUSTRT               WRITE START ADDR\n         L     R6,SUTAB30S             LENGTH OF RECORD\n         BAL   R15,WRITE               WRITE\n*\nLOMEGA5  L     R1,LVLENGTH             GET FULL LENGTH OF LVTAB\n         A     R1,ZLEVA\n         S     R1,ZLESTA\n         ST    R1,ZLEVEN               LENGTH OF LVTAB\n         BZ    LOMEGA4\n         CLC   ZLEVA(4),ZLESTA         ANYTHING IN LVTAB BUFFER ?\n         BE    LOMEGA4                 NO\n         BAL   R5,CHECK                CHECK LAST I/O OPERATION ON UT3\n         L     R5,LVSTRT               LVTAB BUFFER START ADDR\n         L     R6,LVTAB30S             LENGTH OF LVTAB BUFFER\n         BAL   R15,WRITE               WRITE\n*\nLOMEGA4  BAL   R5,CHECK                CHECK LAST I/O OPERATION ON UT3\n         L     R5,AUT2DCB              R5 -> SYSUT2\n*\n         CLOSE ((R5),REREAD),TYPE=T    CLOSE SYSUT2 TEMPORARILY\n*\n         L     R0,TABSIZE              RELEASE MAIN STORAGE\n         L     R1,ZKOPOOL\n*\n         FREEMAIN R,LV=(0),A=(1)\n*\nTERM1    L     R1,OLDSPIE\n*\n         SPIE  MF=(E,(1))\n*\n         XCTL  EP=IEX31                TRANSFER TO NEXT PHASE\n*\nLOMEGA1  OI    COMPFLGS+2,SPIC         SOURCE PROG IN STORAGE\n         L     R1,SRCE1ADD             ADDR OF RESIDENT BUFFER\n         L     R2,ZOBWORK              ADDR OF OUTPUT BUFFER\n         L     R5,SRCE1S               BUFFER LENGTH\n         BCTR  R5,0\n         LR    R6,R5\n         SRA   R6,8                    GET MULTIPLE OF 256\n         LTR   R6,R6                   MAXIMUM 256 ?\n         BZ    LOMEGA12                YES\nLOMEGA11 MVC   0(256,R1),0(R2)         MOVE BLOCK OF 256\n         LA    R1,256(,R1)\n         LA    R2,256(,R2)\n         BCT   R6,LOMEGA11\nLOMEGA12 EX    R5,ONERM                MOVE REST OF BUFFER\n         B     LOMEGA3\n*\nONERM    MVC   0(0,R1),0(R2)           LENGTH IN R5\n*\n*        CODE PROCEDURE\n*\nGAMMA    C     R4,ZFILE9               COMPARE ZOUT WITH ZFILE9\n         BH    LGAMMA1                 HIGH, BRANCH\nLGAMMA2  MVI   1(R4),X'2E'             NEW CODE FOR GAMMA IS SET\n         MVC   2(8,R4),1(R3)           OPT, EXTERNAL NAME TO O-BUFF\n         LA    R3,9(,R3)               INCR ZIN BY 9\n         LA    R4,9(,R4)\n         B     GENTEST                 BRANCH TO GENETEST\n*\nLGAMMA1  BAL   R15,OUCHA\n         B     LGAMMA2                 BRANCH TO LGAMMA2\n*\n*        END OF INPUT BUFFER\n*\nZETA     BAL   R15,ICHA                BRANCH TO SUBROUTINE ICHA\n         B     GENTEST                 BRANCH TO GENTEST\n*\n*        OPENING BRACKET\n*\nOPBRACK  TM    STATUS,SARRAY           HANDLING ARRAY DECLARATION ?\n         BO    LOPBRA5                 YES\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    OTHOP                   YES\n         L     R7,ZITAN                ZITEAN IS LOADED INTO R7\n         TM    7(R7),X'08'             AN ARRAY IDENTIFIER ?\n         BO    LDO3                    NO\n         TM    7(R7),X'04'\n         BZ    LDO3\n         CLC   PFA(4),PFANO            PFA = PFANO ?\n         BE    LDO3                    YES, BRANCH\n         CLI   ZLVOV,X'FF'             TABLE OVERFLOW ?\n         BE    LDO3                    YES\n         CLC   ZARSPO(4),ZARNO         COMPARE ZARSPO WITH ZARNO\n         BE    LOPBRA4                 NO SUBSCRIPT NESTING\n         BAL   R15,SUCRIDEL\n         L     R8,ZARSPO               ZARSPO IS SET INTO R8\n         C     R8,ZARMAX               ZARSPO EQUAL TO ZARMAX ?\n         BE    LOPBRA4                 YES, BRANCH\n         MVC   10(1,R8),ZPOSIX+1       NUMBER OF COMMAS TO ARIDSTACK\n         LA    R8,7(,R8)               ADDR NEXT ENTRY\nLOPBRA3  ST    R8,ZARSPO               ZARSPO IS SET TO ZARSTACK\n         MVC   0(3,R8),8(R7)           ARRAY IDENTIFIER IS STORED\n         LA    R0,1(,R4)\n         ST    R0,ZBRACK               ZBRACK IS SET TO ZOUT+1\n         S     R0,ZOBWORK\n         ST    R0,ALIGN                RELATIVE BUFFER ADDR\n         MVC   5(2,R8),ALIGNH\n         MVC   4(1,R8),ZOUTCOT+1       RECORD COUNTER TO ARIDSTAB\n         MVC   ZPOSIX(2),ZERO          ZPOSIX IS SET TO 0\n         MVI   ZCLOBRA,X'00'           ZCLOBRA IS SET TO X'00'\n         B     LDO2                    PUT OUT OPERATOR\n*\nLOPBRA4  LA    R8,ZARSTACK             START ADDR OF ARIDSTAB\n         B     LOPBRA3                 BRANCH TO LOPBRA3\n*\nLOPBRA5  LH    R5,BRCNT                INCREASE BRACKET COUNTER\n         LA    R5,1(0,R5)\n         STH   R5,BRCNT\n         B     OTHOP                   OUTPUT OPERATOR\n*\n*        COMMA\n*\nCOMMA    TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    OTHOP                   YES\n         CLC   ZARSPO(4),ZARNO         ZARSPO = ZARNO ?\n         BE    LDO3                    YES, BRANCH\n         CLC   ZPOSIX(2),KH15          ZPOSIX = 15 ?\n         BE    LCOMMA1                 YES, BRANCH\n         CLI   ZCLOBRA,0               ZCLOBRA = X'FF' ?\n         BNE   LCOMMA2                 NO, BRANCH\n         L     R7,ZBRACK               ZBRACK IS SET INTO R7\n         LA    R7,18(,R7)\n         CR    R4,R7                   COMPARE ZOUT AND ZBRACK+18\n         BH    LCOMMA3\n         BAL   R9,SUSCRITE             OPTIMIZATION POSSIBLE ?\nLCOMMA4  LH    R7,ZPOSIX               ZPOSIX IS SET INTO R7\n         LA    R7,1(,R7)               INCR ZPOSIX BY 1\n         STH   R7,ZPOSIX\n         LA    R7,1(,R4)\n         ST    R7,ZBRACK               ZBRACK IS SET TO ZOUT+1\n         B     LDO2                    PUT OUT OPERATOR\n*\nLCOMMA1  OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE\n         B     LDO3                    BRANCH TO LDO3\n*\nLCOMMA2  MVI   ZCLOBRA,0               ZERO ZCLOBRA\nLCOMMA3  BAL   R15,SUCRIDEL\n         B     LCOMMA4                 BRANCH TO LCOMMA4\n*\n*        CLOSING BRACKET\n*\nCLOBRACK TM    STATUS,SARRAY           HANDLING ARRAY DECLARATION ?\n         BO    CLOBRA3\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    OTHOP                   YES\n         CLC   ZARSPO(4),ZARNO         THERE AN ARIDSTAB ENTRY ?\n         BE    LDO3                    NO\n         CLI   ZCLOBRA,0               PRECEEDING SUBSCR OPER CLOBRA ?\n         BNE   CLOBRA1                 YES\n         L     R7,ZBRACK               SUBSCRIPT MORE THAN 18 BYTES ?\n         LA    R7,18(,R7)\n         CR    R4,R7\n         BH    CLOBRA1                 YES, NO OPTIMIZATION\n         BAL   R9,SUSCRITE             TEST IF OPTIMIZABLE\nCLOBRA2  L     R7,ZARSPO               UPDATE CURRENT ARIDSTAB PTR\n         SH    R7,KH7\n         ST    R7,ZARSPO\n         C     R7,ZARNO                ARIDSTAB EMPTY\n         BE    LDO3                    YES\n         MVC   ZPOSIX+1(1),10(R7)      RESET SUBSC POSITION CNTR\n         LA    R7,1(,R4)               SET ZBRACK\n         ST    R7,ZBRACK\n         MVI   ZCLOBRA,X'FF'           LAST SUBSCR OPER CLOBRACK\n         B     LDO3\n*\nCLOBRA1  BAL   R15,SUCRIDEL            NO OPTIMIZATION POSSIBLE\n         B     CLOBRA2\n*\nCLOBRA3  LH    R5,BRCNT                DECREASE BRACKET COUNTER\n         BCTR  R5,0\n         STH   R5,BRCNT\n         B     OTHOP                   OUTPUT OPERATOR\n*\n*        LETTER\n*\n*        SCAN FOR END OF IDENTIFIER\n*        BRANCH TO IDENT TO SEARCH FOR THE IDENTIFIER IN ITAB\n*        REPLACE IDENTIFIER BY INTERNAL NAME\n*\n*        INITIALIZED REG = IDENTIFIER START ADDR\n*        SUBROUTINE LINK IDENTX\n*\nLETTER5  BAL   R15,ITABMOP             READ ITAB RECORD\n         B     LETTERP\n*\nLETTER   NOP   LETTER5                 BRANCH TO READ ITAB RECORD\nLETTERP  LA    R8,ZIDEX\n         LA    R0,ZIDEX+6\nLETTER4  LR    R9,R3\n         SR    R2,R2\n         SR    R1,R1\nLETTER6  TRT   0(256,R3),IDENTI\n         BZ    LETTER0                 STILL SAME IDENTIFIER\n         LR    R3,R1                   UPDATE R3\n         B     *(R2)\n         B     ZETALET                 +04\n         B     RHO                     +08\n         B     ERROR1                  +12\n*                                      END OF IDENTIFIER IS FOUND\n         B     IDENT                   ITAB SEARCH\n*\nLETTER1  ST    R7,ZITAN                SAVE POINTER TO LAST IDENTIFIER\n         C     R4,ZFILE5               SPACE IN OUTPUT BUFFER\n         BH    LETTER2                 NO SPACE\nLETTER3  MVC   1(5,R4),6(R7)           MOVE INTERNAL NAME TO OUTPUT BUF\n         LA    R4,5(,R4)\n         B     GENTEST\n*\nLETTER2  BAL   R15,OUCHA\n         B     LETTER3\n*\nLETTER0  LA    R3,256(,R3)             UPDATE INPUT PTR\n         B     LETTER6\n*\n*        END OF INPUT BUFFER IN THE MIDDLE OF AN IDENTIFIER\n*\nZETALET  BAL   R15,MOVE\n         BAL   R15,ICHA\n         B     LETTER4\n*\n*        LETTER STRING USED AS PARAMETER DELIMITER\n*        REPLACE STRING BY COMMA\n*\nRHO      CLI   0(R4),XFRBRAC           RIGHT BRACKET ?\n         BNE   GENTEST1                NO\n         MVI   0(R4),XFCOMMA           REPLACE RIGHT BRACKET BY COMMA\n         B     GENTEST1\n*\n*        INVALID CHARACTER IN IDENTIFIER\n*\nERROR1   BAL   R15,MOVE\n         MVC   ZERRONU,INVOP\n         B     INCOROP\n*\n*        IDENT\n*\n*        A SEARCH THRU ITAB FOR THE IDENTIFIER WITH THE START\n*        ADDRESS IN ZIDSTAR IS DONE. IF FOUND BRANCH TO ROUTINE\n*        FOL1 FOR TYPECHECK, IF NOT REPLACE IDENTIFIER WITH ALL\n*        PURPOSE IDENTIFIER\n*\n*        RECEIVED REG = ADDR OF IDENTIFIER START\n*        INITIALIZED R7\n*\nIDENT    BAL   R15,MOVE                MOVE IDENTIFIER\n         MVC   0(5,R8),ZERO            FILL UP WITH ZERO\n*                                      START ITAB SEARCH\n         L     R7,ZCURITEN             ADDR OF LAST ITAB ENTRY\n         L     R1,ZIBSTAO              ITAB START ADDR\n         LA    R0,11\n         LCR   R0,R0                   MINUS ELEVEN\nIDENT2   LA    R5,IDENT4\nIDENT3   CLC   0(6,R7),ZIDEX           IDENTIFIER SEARCH\n         BER   R5                      FOUND\nIDENT6   BXH   R7,R0,IDENT3            PROCEED SEARCH, IF NOT\n         MVC   ZBEGERR,OPSTART\n         ST    R8,ZENDERR\n         MVC   ZERRONU,UNDEFOP\n         BAL   R15,MOVERRO\n         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE\n         LA    R7,ZALLPU               ALL PURPOSE IDENTIFIER\n         B     LETTER1\n*\nIDENT4   B     IDENT5                  BRANCH IF NOT PROC HEAD\n*\n         TM    6(R7),X'02'             PROC OR FORMAL PARAMETER ?\n         BZ    IDENT6                  NO, CONTINUE SEARCH\n         CLC   8(1,R7),CURPBN          DECLARED IN LAST BLOCK ?\n         BNE   IDENT6                  NO, CONTINUE SEARCH\nIDENT5   TM    STATUS,SARRAY           HANDLING ARRAY DECLARATION ?\n         BZ    FOLI                    NO\n         CLC   BRCNT(2),ZERO           IDENTIFIER IN ARRAY LIST ?\n         BE    FOLI                    NO, ARRAY IDENTIFIER\n         CLC   8(1,R7),CURPBN          DECLARED IN LAST BLOCK ?\n         BL    FOLI                    NO\n         MVC   ZSTO(2),6(R7)           IDENT CHARACTERISTIC\n         NC    ZSTO(2),ZSTO1\n         CLC   ZSTO(2),ZSTO2           FUNCTION PROCEDURE ?\n         BE    IDENT7                  YES\n         CLI   ZSTO,X'02'              FORMAL PARAM OR PROC ?\n         BE    FOLI                    YES\nIDENT7   MVC   ZBEGERR,OPSTART         GIVE WARNING MESSAGE\n         ST    R8,ZENDERR\n         MVC   ZERRONU,ARRAYERR\n         BAL   R15,MOVERRO\n         AR    R7,R0                   PROCEED SEARCH FOR IDENTIFIER\n         B     IDENT2\n*\n*        FOLI\n*\n*        CHECK TYPE OF IDENTIFIER\n*\nFOLI     IC    R5,6(,R7)               ISOLATE SPECIAL USE BITS\n         N     R5,SPECUSE              X'00000006'\n         AR    R5,R5                   SPECIAL USE BITS MULTIPLIED BY 4\n         B     *+4(R5)\n         B     NOCRI               +00 NON-CRITICAL IDENTIFIER\n         B     PROFU               +04 PROCEDURE OR FORMAL PARAMETER\n         B     SWILA               +08 LABEL OR SWITCH\n         B     CRITI               +12 CRITICAL IDENTIFIER\n*\nNOCRI    TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    LETTER1\n         CLI   ZFORTEST,X'00'          APPEARS IDENT BETWEEN FOR - DO\n         BNE   NOCRI1                  YES\n*                                      SHOULD ENTRY TO LVTAB BE DONE ?\n         CLC   PFA(4),PFANO            FOR-STATMENT\n         BE    LETTER1                 NO, NO LVTAB-ENTRY\n         CLI   0(R3),X'16'             IDENTIFIER FOLLOWED BY ASSIGN ?\n         BNZ   LETTER1                 NO, NO LVTEB-ENTRY\n         TM    7(R7),X'02'             INTEGER ?\n         BO    LETTER1                 NO, NO LVTAB-ENTRY\n         BAL   R9,LETRAF               MAKE ENTRY IN LVTAB\n         B     LETTER1                 RETURN\n*\nNOCRI1   BAL   R14,CRIMA               MAKE CRIDTAB ENTRY\n         B     LETTER1\n*\n*        PROFU\n*\n*        BECAUSE OF POSSIBLE SIDE EFFECTS OF A PROCEDURE,\n*        OPTIMIZATION OF SUBSCRIPTS AND FOR-STATEMENTS IS\n*        INHIBITED\n*\n*        SUBROUTINE LINK VIA R15\n*\nPROFU    TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    LETTER1                 YES\n         MVC   ZARSPO(4),ZARNO         SKIP ARIDSTAB\n         CLI   ZFORTEST,X'C0'          CONTROLLED VARIABLE ?\n         BNE   PROFU1                  NO\n         L     R5,ZFSPTR               YES, CLASSIFIED NORMAL\n         OI    0(R5),NORMAL\nPROFU1   MVI   ZFORTEST,X'00'          TURN OFF FOR-SWITCH\n         CLC   PFA(4),PFANO            CRIDTAB EMPTY ?\n         BE    LETTER1                 YES, RETURN\n         BAL   R15,DELCRIV             DELETE ALL CRIDTAB-ENTRIES\n         B     LETTER1                 RETURN\n*\n*        SWILA\n*\n*        IN CASE OF SWITCH OF LABEL DECLARATION NO ACTION IS\n*        TAKEN. IF USED IN A GO-TO-STATEMENT A TEST IS DONE IF\n*        THE ALGOL RULES ARE FOLLOWED. IF NOT GIVE MESSAGE\n*\n*        RECEIVED R7\n*        WORK REG R1, SIGNEMBR, R1, R9\n*\nSWILA    LR    R1,R7                   START SEARCH FOR HEADING ENTRY\nSWILA1   SH    R1,KH11\n         CLI   5(R1),X'2B'             HEADING TEST\n         BNE   SWILA1                  NO HEADING\n         MVC   ALIGNH(2),8(R1)\n         L     R9,ALIGN\n         LH    R2,ZIGN                 ACTUAL IGN\n         LA    R1,ZFOSTA-1             ADDR OF BYTE PRECEED FSTAB\nSWILA2   CR    R2,R9                   COMPARE DECLAR AD AND CUR IGN\n         BH    SWILA3                  CHECK EMBRACING IGN TO CUR IGN\n         BE    LETTER1\n         TM    STATUS,SSWITCH          IN SWITCH DECLARATION ?\n         BZ    SWILA21                 NO, SERIOUS ERROR\n         MVC   ZBEGERR,OPSTART         YES, GIVE WARNING MESSAGE\n         ST    R8,ZENDERR\n         MVC   ZERRONU,SWITCHER\n         BAL   R15,MOVERRO\n         B     LETTER1\n*\nSWILA21  MVC   ZERRONU,GOTOFOR\n         B     INCOROP\n*\nSWILA3   LR    R5,R2                   COMPUTE ADDR OF IGN-TAB-ENTR\n         AR    R5,R2\n         AR    R5,R2                   3+ZIGNEMB\n         LA    R5,GPTAB(R5)            GPTAB+3*ZIGNEMB\n         CLI   2(R5),0                 TEST IF FORGROUP\n         BE    SWILA4                  NO\n         MVC   *+9(1),2(R5)            ADDR ACTUAL ENTRY IN FSTAB\n         OI    0(R1),X'20'             SET BIT IND BRANCH OUT OF FS\nSWILA4   MVC   ALIGNH(2),0(R5)\n         L     R2,ALIGN                LOAD EMBRACING IGN\n         B     SWILA2\n*\n*        CRITI\n*\n*        ROUTINE ENTRED WHEN A CRITICAL IDENTIFIER IS FOUND IN\n*        ITAB. IF THE IDENTIFIER APPEARS BETWEEN FOR AND DO A NEW\n*        CHAINED CRIDTAB-ENTRY IS MADE. OTHERWISE ONLY THE\n*        FSTAB-ENTRY IS TREATED\n*\n*        WORK REG R1,R8\n*\nCRITI    CLI   ZFORTEST,X'00'          CRITICAL IDENTIFIER IN FOR-LIST?\n         BNE   CRITIF                  YES\n*                                      IDENTIFIER NOT FOR-LIST-ELEMENT\n         CLC   ZARSPO(4),ZARNO         CURRENTLY HANDLING SUBSCR EXPR?\n         BC    7,LETTER1               YES\n         L     R1,PFA                  POINTER TO LAST CRIDTAB ENTRY\nCRITI1   CLC   1(3,R1),8(R7)           SCAN CRIDTAB FOR LAST ENTRY\n         BE    CRITI2                  FOUND\n         SH    R1,KH9\n         B     CRITI1\n*\nCRITI2   CLI   0(R3),X'16'             IDENTIFIER FOLLOWED BY ASSIGN ?\n         BE    CRITI3                  YES\n         TM    4(R1),X'80'             CONTROLLED VARIABLE ?\n         BZ    LETTER1                 NO, RETURN\n         SR    R5,R5                   ADDR FSTAB ENTRY\n         IC    R5,0(,R1)\n         LA    R5,ZFOSTA(R5)\n         OI    0(R5),X'80'             ELEMENTARY LOOP\n         B     LETTER1                 RETURN\n*\n*        IDENTIFIER FOLLOWED BY ASSIGNMENT\n*\nCRITI3   SR    R5,R5                   GET ADDR OF FSTAB ENTRY\n         IC    R5,0(,R1)\n         LA    R5,ZFOSTA(R5)\n         TM    4(R1),X'80'             CONTROLLED VARIABLE ?\n         BO    CRITI4                  YES\n         OI    0(R5),NORMAL            NORMAL LOOP\n         TM    4(R1),X'40'             MORE CHAINED ENTRIES ?\n         BZ    LETTER1                 NO, RETURN\n         MVC   ALIGNH(2),5(R1)         GET ADDR OF NEXT ENTRY\n         L     R1,ALIGN\n         A     R1,ZFOCRI\n         B     CRITI3                  HANDLE NEXT ENTRY\n*\nCRITI4   OI    0(R5),X'40'             INDICATE ASSIGN TO CTR VAR\n         B     LETTER1\n*\n*        TREATMENT OF CRIT ID IN FOR-LIST\n*\nCRITIF   BAL   R14,CRIMA               MAKE CRIDTAB ENTRY\n         L     R8,PFA                  PTR TO LAST CRIDTAB ENTRY\n         LR    R1,R8                   START SCAN FOR PREVIOUS ENTRY\nCRITIF1  SH    R1,KH9\n         C     R1,PFANO                THERE A PREVIOUS ENTRY ?\n         BNH   LETTER1                 NO, DELETED AT CRIDTAB OVERFLOW\n         CLC   1(3,R1),1(R8)           PREVIOUS ENTRY ?\n         BNE   CRITIF1                 NO\n*                                      PREVIOUS ENTRY IN CRIDTAB FOUND\n         BAL   R15,PUTCHAIN            CHAIN NEW ENTRY TO PREVIOUS\n         TM    4(R8),X'80'             NEW ENTRY CONTROLLED VARIABLE\n         BZ    CRITIN                  NO\n*\n*        TREATMENT OF CONTROLLED VARIABLE\n*\nCRITIC   SR    R5,R5\n         IC    R5,0(,R1)               FSN OF CHAINED CRIDTAB ENTRY\n         LA    R5,ZFOSTA(R5)           ADDR OF CHAINED FSTAB ENTRY\n         TM    4(R1),X'80'             CHAINED ENTRY CONTROLLED ?\n         BO    CRITIC1                 YES\n         OI    0(R5),NORMAL            INDICATE NORMAL LOOP\n         TM    4(R1),X'40'             MORE CHAINED ENTRIES ?\n         BZ    LETTER1                 NO, RETURN\n         MVC   ALIGNH(2),5(R1)         GET ADDR OF NEXT CHAINED ENTRY\n         L     R1,ALIGN\n         A     R1,ZFOCRI\n         B     CRITIC\n*\nCRITIC1  OI    0(R5),X'40'             BIT FOR ASSIGN TO CONTROL VAR\n         B     LETTER1\n*\n*        TREATMENT OF NON-CONTROLLED VARIABLE\n*\nCRITIN   TM    4(R1),X'80'             CHAINED ENTRY CONTROLLED ?\n         BO    CRITIN1                 YES\n         TM    4(R1),X'40'             MORE CHAINED ENTRIES ?\n         BZ    LETTER1                 NO\n         MVC   ALIGNH(2),5(R1)         GET ADDR OF CHAINED ENTRY\n         L     R1,ALIGN\n         A     R1,ZFOCRI\n         B     CRITIN\n*\nCRITIN1  SR    R5,R5                   GET ADDR OF CHAINED FSTAB ENTRY\n         IC    R5,0(,R1)\n         LA    R5,ZFOSTA(R5)\n         CLC   0(1,R1),ZFSN            CHAINED ENTRY PART OF ACTIVE FOR\n         BE    CRITIN2                 YES\n         CLC   ZARSPO(4),ZARNO         CURRENTLY HANDLING A SUBSCRIPT ?\n         BNE   LETTER1                 YES, RETURN\n         OI    0(R5),X'80'             SET ELEMENTARY LOOP\n         B     LETTER1\n*\nCRITIN2  OI    0(R5),NORMAL            INDICATE NORMAL LOOP\n         B     LETTER1\n*\n*        PUTCHAIN\n*\n*        ROUTINE TO CHAIN NEW CRIDTAB ENTRY TO PREVIOUS\n*\n*        RETURN VIA R15\n*        RECEIVED REG R8, R1\n*\nPUTCHAIN OI    4(R8),X'40'             BIT FOR PREVIOUS CRITICAL IDENT\n         OI    4(R1),X'20'             BIT FOR SUBSEQUENT CRIT IDENT\n         L     R6,ZFOCRI               CRIDTAB START ADDR\n         LR    R5,R1                   GET BACKWARD CHAIN\n         SR    R5,R6\n         ST    R5,ALIGN\n         MVC   5(2,R8),ALIGNH\n         LR    R5,R8                   GET FORWARD CHAIN\n         SR    R5,R6\n         ST    R5,ALIGN\n         MVC   7(2,R1),ALIGNH\n         BR    R15                     RETURN\n*\n*        CRIMA\n*\n*        SUBROUTINE TO MAKE A NEW CRIDTAB ENTRY\n*\n*        IN CASE OF CRIDTAB OVERFLOW THE ROUTINE CRIFLOW IS\n*        ENTRED TO DELETE FROM CRIDTAB ALL ENTRIES BELONG TO THE\n*        MOST EMBRACING FOR-STATEMENT. CRIFODEL IS ENTERED IF AN\n*        ARRAY ELEMENT IS HANDLED\n*\n*        RETURN VIA R14\n*        RECEIVED REG R7 POINTER TO ACTUELL ITAB ENTRY\n*        WORK REG R8\n*        SUBROUTINE CRIFLOW, LETRAF, CRIFODEL, SUCRIDEL\n*\nCRIMA    TM    7(R7),X'04'             ARRAY ?\n         BO    CRIMA1                  YES, NO OPTIMIZATION POSSIBLE\n         L     R8,PFA                  CURRENT CRIDTAB PTR\n         TM    ZFORTEST,X'C0'          CONTROLLED VARIABLE ?\n         BO    CRIMAC                  YES\n*\n*        TREATMENT OF 'NOT CONTROLLED' VARIABLE\n*\n         C     R8,PFAMAX               CRIDTAB OVERFLOW ?\n         BE    CRIMAN1                 YES\nCRIMAN2  LA    R8,9(,R8)               UPDATE CURRENT PTR\n         MVI   4(R8),X'00'             FLAG BYTE SHOWS NO CNTL VARIABLE\n         TM    7(R7),X'02'             INTEGER ?\n         BZ    CRIMA2                  YES\n         L     R5,ZFSPTR               ADDR FSTAB ENTRY\n         OI    0(R5),NOCOUNT           CLASSIFY AS NOT COUNTING LOOP\n*\nCRIMA2   MVC   1(3,R8),8(R7)           MOVE ADDR PART TO CRIDTAB\n         MVC   0(1,R8),ZFSN            MOVE FSN TO CRIDTAB\n         LR    R5,R7                   GET RELATIVE ADDR IN ITAB\n         S     R5,ZIBSTAO\n         ST    R5,ALIGN                ITAB RELATIVE ADDR\n         MVC   5(2,R8),ALIGNH\n         OI    6(R7),X'06'             TURN ON SPECIAL USE BITS\n         ST    R8,PFA                  SAVE CURRENT PTR\n         BR    R14                     RETURN\n*\nCRIMAN1  BAL   R15,CRIFLOW             DELETE MOST EMBRACING FOR-STAT\n         C     R8,PFANO                ALL CRIDTAB DELETED ?\n         BNE   CRIMAN2                 NO\n         MVI   ZFORTEST,0              NO MORE CRIDTAB ENT TO BE DONE\n         BR    R14\n*\nCRIMAC   TM    7(R7),X'02'             INTEGER ?\n         BZ    CRIMAC1                 YES\n         L     R5,ZFSPTR               CURRENT FSTAB PTR\n         OI    0(R5),X'80'             SET BIT FOR ELEMENTARY LOOP\nCRIMAC4  C     R8,PFAMAX               OVERFLOW ?\n         BE    CRIMAC2                 YES\nCRIMAC3  LA    R8,9(,R8)               UPDATE CURRENT PTR\n         MVI   ZFORTEST,X'80'          INDICATE CONTROL VAR TREATED\n         MVI   4(R8),X'80'             SET BIT FOR CONTROLLED VAR\n         B     CRIMA2\n*\nCRIMAC1  C     R8,PFANO                NESTED FOR STATEMENT ?\n         BE    CRIMAC3                 NO\n         BAL   R9,LETRAF               MAKE LVTAB ENTRY\n         B     CRIMAC4\n*\nCRIMAC2  BAL   R15,CRIFLOW             CRIDTAB OVERFLOW\n         B     CRIMAC3\n*\nCRIMA1   L     R5,ZFSPTR               CURRENT FSTAB PTR\n         OI    0(R5),NORMAL            NORMAL LOOP\n         MVI   ZFORTEST,0              NO MORE CRIDTAB ENTRIES\n         BR    R14                     RETURN\n*\n*        CRIFLOW\n*\n*        THE SUBROUTINE IS ENTERED AT CRIDTAB OVERFLOW TO\n*        DELETE ALL CRIDTAB ENTRIES BELONGING TO THE MOST\n*        EMBRACING FOR STATEMENT\n*\n*        RETURN VIA R15\n*        WORK REG R1, R2, R9\n*\nCRIFLOW  L     R2,ZFOCRI               CRIDTAB START ADDR\n         CLC   0(1,R2),0(R8)           ALL ENTRIES FROM SAME FOR ST ?\n         BE    DELCRIV                 YES, DELETE WHOLE CRIDTAB\n         MVC   FSNEMBR(1),0(R2)        SAVE MOST EMBRACING FSN\nCRIFLOW1 CLC   0(1,R2),FSNEMBR         ENTRY OF MOST EMBRACING FOR ST ?\n         BNE   CRIFLOW2                NO\n         TM    4(R2),X'20'             SUBSEQUENT CHAINED ENTRY ?\n         BO    CRIFLOW3                YES\n         MVC   ALIGNH(2),5(R2)         ADDR ITAB ENTRY\n         L     R5,ALIGN\n         A     R5,ZIBSTAO\n         NI    6(R5),X'F9'             SET SPECIAL USE BITS TO 00\nCRIFLOW4 LA    R2,9(0,R2)              ADDR NEXT CRIDTAB ENTRY\n         B     CRIFLOW1\n*\nCRIFLOW3 MVC   ALIGNH(2),7(R2)         ADDR CHAINED ENTRY\n         L     R5,ALIGN\n         A     R5,ZFOCRI\n         NI    4(R5),X'B0'             TURN OFF BIT FOR PRECEED ENTRY\n         MVC   5(2,R5),5(R2)           INSERT RELATIVE ITAB ADDR\n         B     CRIFLOW4\n*\nCRIFLOW2 SR    R5,R5                   ADDR FSTAB ENTRY OF DEL FOR\n         IC    R5,FSNEMBR\n         LA    R5,ZFOSTA(R5)\n         OI    0(R5),NORMAL            NORMAL LOOP\n         L     R9,ZFOCRI               CRIDTAB START ADDR\n         LR    R1,R2\n         SR    R1,R9                   GET LENGTH OF DELETED PART\n*\nCRIFLOW5 TM    4(R2),X'40'             PRECEEDING CRIDTAB ENTRY ?\n         BZ    CRIFLOW6                NO\n         MVC   ALIGNH(2),5(R2)         DECREASE CHAIN ADDR\n         L     R5,ALIGN\n         SR    R5,R1\n         ST    R5,ALIGN\n         MVC   5(2,R2),ALIGNH\nCRIFLOW6 TM    4(R2),X'20'             SUBSEQUENT CRITAB ENTRY ?\n         BZ    CRIFLOW7\n         MVC   ALIGNH(2),7(R2)         DECREASE CHAIN ADDR\n         L     R5,ALIGN\n         SR    R5,R1\n         ST    R5,ALIGN\n         MVC   7(2,R2),ALIGNH\nCRIFLOW7 MVC   0(9,R9),0(R2)           MOVE ENTRY DOWN IN CRIDTAB\n         CR    R2,R8                   LAST ENTRY ?\n         BE    CRIFLOW8                YES\n         LA    R2,9(,R2)               ADDR NEXT ENTRY\n         LA    R9,9(,R9)\n         B     CRIFLOW5\n*\nCRIFLOW8 SR    R8,R1                   GET ADDR OF LAST CRIDTAB-ENT\n         BR    R15\n*\n*        DELCRIV\n*\n*        ROUTINE TO DELETE ALL ENTRIES IN CRIDTAB AND TURN OFF\n*        THE SPECIAL USE BITS OF CORRESPONDING ITAB ENTRY. ALL\n*        FOR-STATEMENTS WITH CRIDTAB ENTRIES WILL BE CLASSIFIED\n*        NORMAL\n*\n*        RETURN VIA R15\n*        INITIALIZED REG R8\n*\nDELCRIV  L     R5,ZFOCRI               CRIDTAB START ADDR\nDELCRIV1 SR    R6,R6                   ADDR FSTAB ENTRY\n         IC    R6,0(,R5)\n         LA    R6,ZFOSTA(R6)\n         OI    0(R6),NORMAL            CLASSIFIED NORMAL\n         TM    4(R5),X'40'             IDEN CRIT IN EMBR FOR-STAT ?\n         BO    DELCRIV2                YES, ITAB ENTRY ALREADY NON CRI\n         MVC   ALIGNH(2),5(R5)         ADDR ITAB ENTRY\n         L     R6,ALIGN\n         A     R6,ZIBSTAO\n         NI    6(R6),X'F9'             CLEAR SPEC USE BITS\nDELCRIV2 C     R5,PFA                  LAST CRIDTAB ENTRY ?\n         BE    DELCRIV3                YES\n         LA    R5,9(,R5)               ADDR NEXT CRIDTAB ENTRY\n         B     DELCRIV1\n*\nDELCRIV3 L     R8,PFANO\n         ST    R8,PFA\n         BR    R15\n*\n*        CRIFODEL\n*\n*        ROUTINE TO DELETE THE CRIDTAB ENTRIES OF THE LAST FOR\n*        STATEMENT\n*\n*        RETURN VIA R15 WORK REG R8\n*\nCRIFODEL L     R8,PFA                  POINTER TO LAST CRIDTAB-ENTRY\n         MVC   CRIFODS+1(1),0(R8)      INSERT FOR STATEMENT NUMBER\nCRIFOD1  C     R8,PFANO                CRIDTAB EMPTY ?\n         BE    CRIFOD4                 YES, RETURN\nCRIFODS  CLI   0(R8),0                 NEW FORSTATEMENT, OLD FSN INSER\n         BNE   CRIFOD4                 YES, RETURN\n         TM    4(R8),X'40'             IDENTIFIER USED IN EMBR FOR-ST\n         BO    CRIFOD2                 YES\n         MVC   ALIGNH(2),5(R8)         CLEAR SPEC USE BITS IN CRIDTAB\n         L     R5,ALIGN\n         A     R5,ZIBSTAO              ABSOLUTE ITAB ADDR\n         NI    6(R5),X'F9'             CLEAR SPECIAL USE BITS IN ITAB\nCRIFOD3  SH    R8,KH9                  POINT TO PRECEEDING ENTRY\n         B     CRIFOD1\n*\nCRIFOD2  L     R5,ZFOCRI               TURN OFF BIT FOR SUBSEQ ENTRY\n         MVC   ALIGNH(2),5(R8)         ADDR OF PREVIOUS CRIDTAB-ENT\n         A     R5,ALIGN\n         NI    4(R5),X'CF'             TURN OFF BIT FOR SUBSEQ ENTRY\n         B     CRIFOD3                 GET NEXT ENTRY\n*\nCRIFOD4  ST    R8,PFA\n         BR    R15\n*\n*        SUCRIDEL\n*\n*        THE SUBROUTINE IS ENTERED WHEN UNOPTIMIZABLE SUBSCRIPT\n*        EXPRESSION IS FOUND. A SCAN BETWEEN THE TWO LAST\n*        SUBSCRIPT OPERATORS IS DONE IN THE OUTPUT BUFFER. IF A\n*        CONTROLLED CRITICAL IDENTIFIER IS FOUND, CORRESPONDING\n*        ENTRY IN FSTAB IS MADE ELEMENTARY. OTHERWISE NO ACTION\n*\n*        RETURN VIA R15\n*        WORK REG R1, R2, R14\n*\nSUCRIDEL CLC   PFA(4),PFANO            CRIDTAB EMPTY\n         BER   R15                     YES, RETURN\n         LA    R2,1(,R4)               ADDR OF LAST SUBSCR OPERAND\n         L     R1,ZBRACK               ADDR OF FIRST SUBSCR OPERAND\nSUCRID1  LA    R1,1(,R1)               CHECK NEXT BYTE\nSUCRID2  CR    R1,R2                   END OF SCAN ?\n         BNLR  R15                     YES, RETURN\n         TM    0(R1),X'80'             AN OPERAND FOUND ?\n         BZ    SUCRID1                 NO\n         TM    0(R1),X'06'             CRITICAL IDENTIFIER ?\n         BO    SUCRID4                 YES\nSUCRID3  LA    R1,5(,R1)               ADDR NEXT ELEMENT\n         B     SUCRID2\n*\n*        TREATMENT OF CRITICAL IDENTIFIERS\n*\nSUCRID4  L     R14,PFA                 ADDR OF LAST CRIDTAB ENTRY\n         LA    R14,9(,R14)\nSUCRID5  SH    R14,KH9                 FIND IDENTIFIER IN CRIDTAB\n         CLC   1(3,R14),2(R1)          IDENTIFIER FOUND ?\n         BNE   SUCRID5                 NO\n*\nSUCRID6  TM    4(R14),X'80'            CONTROLLED VARIABLE ?\n         BZ    SUCRID7                 NO\n         LA    R5,ZFOSTA               ADDR OF FSTAB\n         MVC   *+9(1),0(R14)           DISPLACEMENT EQUALS FOR NUMBER\n         OI    0(R5),X'80'             ELEMENTARY LOOP\n         B     SUCRID3\n*\n*        FIND CHAINED CONTROLLED VARIABLE\n*\nSUCRID7  TM    4(R14),X'40'            ANY CHAINING ?\n         BZ    SUCRID3                 NO\n         MVC   ALIGNH(2),5(R14)        CRIDTAB CHAIN\n         L     R14,ALIGN\n         A     R14,ZFOCRI              ADDR CHAINED ENTRY\n         B     SUCRID6\n*\n*        LETRAF\n*\n*        MAKE ENTRIES IN LVTAB CORRESPONDING TO ALL\n*        SUBSCRIPTABLE NESTED FOR-STATEMENTS\n*\n*        RETURN VIA R9\n*        RECIEVED REG R7, WORK REG R1, R2, R6\n*\nLETRAF   CLI   ZLVOV,X'FF'             TABLE OVERFLOW OCCURED ?\n         BER   R9                      YES\n         L     R1,PFA                  ADDR OF LAST CRIDTAB ENTRY\nLETRAF1  LR    R2,R1\n         LA    R5,ZFOSTA\n         MVC   *+9(1),0(R1)            ADDR ACTUAL FSTAB ENTRY\n         TM    0(R5),NOSUOP\n         BO    LETRAF2\n         L     R6,ZLEVA\n         C     R6,ZLESTA               WRITE BEEN ISSUED ?\n         BNE   LETRAF5                 NO\n         BAL   R5,CHECK                YES, CHECK\n         CLC   LVLENGTH(4),LVTAB40S    MORE OUTPUT ALLOWED ?\n         BNL   LETRAF4                 NO\n         LH    R5,LVCNT                STEP RECORD COUNTER\n         LA    R5,1(,R5)\n         STH   R5,LVCNT\nLETRAF5  LA    R6,4(,R6)\n         MVC   0(1,R6),0(R1)           PLUG IN FS NUMBER\n         MVC   1(3,R6),8(R7)           PLUG IN ADDR PART OF CUR ID\n         C     R6,ZLEMAX               LVTAB FILLED UP ?\n         BE    LETRAF3                 YES\nLETRAF6  ST    R6,ZLEVA\nLETRAF2  SH    R1,KH9                  GET NEXT CRIDTAB ENTRY\n         C     R1,PFANO                BEGINNING OF CRIDTAB ?\n         BER   R9                      YES, RETURN\n         CLC   0(1,R1),0(R2)           AN ENTRY IN SAME FS ?\n         BE    LETRAF2                 SAME\n         B     LETRAF1                 NEW\n*\nLETRAF3  BAL   R5,CHECK                CHECK POSSIBLE WRITE\n         L     R5,LVSTRT               WRITE START ADDR\n         L     R6,LVTAB30S             LENGTH OF WRITE\n         BAL   R15,WRITE               WRITE\n         L     R5,LVLENGTH             LENGTH OF LVTAB\n         A     R5,LVTAB30S             BUFFER LENGTH\n         ST    R5,LVLENGTH\n         L     R6,ZLESTA               START ADDR OF LVTAB\n         B     LETRAF6\n*\nLETRAF4  BAL   R15,TABOFLO\n         BAL   R15,MOVERRO\n         BR    R9\n*\n*        SUSCRITE\n*\n*        ROUTINE TO CHECK IF AN SUBSCRIPT EXPRESSION IS\n*        OPTIMIZABLE IN WHAT CASE AN SUTAB-ENTRY IS DONE, OTHER\n*        SUBROUTINE SUCRIDEL IS ENTERED BEFORE RETURN\n*\n*        RETURN VIA R9\n*        WORK REG R2, R1, R2, R7, R8, R1\n*        SUBROUTINE LINKS R15, R14, R14\n*\nSUSCRITE L     R1,ZBRACK               INITIALIZE CURRENT POINTER\n         LR    R5,R4                   ADDR OF LAST BYTE OF SUBSCR\n         SH    R5,KH5                  ADDR OPERATOR BEFOR LAST OPD\n         ST    R5,SUBEND\n         CLI   1(R1),XFMINUS           SUBSCRIPT START WITH + OR -\n         BH    SUB1                    NO\n         LA    R1,1(,R1)               POINT TO BYTE BEFORE OPERAND\nSUB1     C     R1,SUBEND               ANY OPERAND IN SUBSCRIPT ?\n         BHR   R9                      NO, RETURN\n         BAL   R15,OPERANDR            TEST OPERAND\n         C     R1,SUBEND               END OF SUBSCRIPT\n         BE    SUBONE\n         CLI   6(R1),XFASTER           WHAT FOLLOWS FIRST OPERAND\n         BL    SUBPM                   PLUS OR MINUS ?\n         BE    SUBAST                  ASTERISK\n*\n*        UNOPTIMIZABLE SUBSCRIPT EXPRESSION\n*\nSUBNOOP  BAL   R15,SUCRIDEL            HANDLE UNOPTIMIZABLE EXPRESSION\n         BR    R9                      RETURN\n*\n*        ONLY ONE OPERAND\n*\nSUBONE   LTR   R8,R2                   CONTROLLED VARIABLE ?\n         BP    SUBONE3                 YES\n         MVC   ADDEND(6),0(R1)         OPERAND IS ADDEND\n         MVC   FACTOR(6),ZEROELEM      SET FACTOR TO ZERO\n         L     R8,ZFOCRI               ADDR OF LAST CRIDTAB ENTRY\n         L     R2,ZARSPO               ADDR CURRENT ARIDSTAB ENTRY\nSUBONE1  SR    R5,R5                   GET FSN\n         IC    R5,0(,R8)\n         STC   R5,OLDFSN\n         LA    R6,ZFOSTA(R5)           ADDR FSTAB ENTRY\n         TM    0(R6),X'40'             SUBSCRIPT OPTIMIZATION POSSIBLE\n         BO    SUBONE2\n         L     R2,ZARSPO               ADDR LAST ARIDSTACK ENTRY\n         LA    R6,SPTAB(R5)            ADDR SPTAB ENTRY\n         CLC   0(1,R6),0(R2)           SCOPE OF ARRAY OK\n         BL    SUBONE2                 NO\n         TM    ADDEND+2,X'30'          CONSTANT ?\n         BZ    SUBONE4                 YES\n         CLC   0(1,R6),ADDEND+3        SCOPE TEST OF ADDEND\n         BL    SUBONE2                 NOT OK\nSUBONE4  BAL   R14,SUTABENT            MAKE SUTAB ENTRY\nSUBONE2  C     R8,PFA                  END OF CRIDTAB\n         BER   R9                      YES, RETURN\n         LA    R8,9(,R8)               FIND ENCLOSED FOR STATEMENT\nOLDFSN   EQU   *+1\n         CLI   0(R8),0                 ENTRY TO SAME FOR STATEMENT ?\n         BE    SUBONE2                 YES, CHECK NEXT ENTRY\n         B     SUBONE1                 NO, POSSIBLY NEW SUTAB ENTRY\n*\n*        OPERAND IS CONTROLLED VARIABLE\n*\nSUBONE3  MVC   FACTOR(1),0(R1)         OPERATOR TO FACTOR\n         MVC   FACTOR+1(5),ONEELEM+1   SET FACTOR TO ONE\nSUBONE5  MVC   ADDEND(6),ZEROELEM      SET ADDEND TO ZERO\n         B     SUBFIN1\n*\n*        FIRST OPERAND FOLLOWED BY + OR -\n*\nSUBPM    MVC   ADDEND(6),0(R1)         FIRST OPERAND PROBABLY ADDEND\n         LR    R7,R2                   SAVE CRIDTAB POINTER\n         LA    R1,6(0,R1)              ADDR SIGN OF SECOND OPERAND\n         BAL   R15,OPERANDR            CHECK SECOND OPERAND\n         C     R1,SUBEND               END OF SUBSCRIPT ?\n         BE    SUBPM1                  YES\n         CLI   6(R1),XFASTER           ASTERISK SHOULD FOLLOW\n         BNE   SUBNOOP                 NOT OPTIMIZABLE\n         BAL   R14,SUBMULT             CHECK MULTIPLICATION\n         B     SUBFIN                  TERMINATE\n*\nSUBPM1   CR    R2,R7                   WHAT IS SECOND OPERAND ?\n         BL    SUBPM3                  ADDEND\n         BE    SUBPM4                  NOT OPTIMIZABLE EXPRESSION\n         LR    R8,R2                   ADDR CRIDTAB ENTRY OF CONTR\n         MVC   FACTOR(1),0(R1)         SIGN OF FACTOR\nSUBPM2   MVC   FACTOR+1(5),ONEELEM+1   SET FACTOR TO ONE\n         B     SUBFIN\n*\nSUBPM3   LR    R8,R7                   SECOND OPERAND ADDEND, SHIFT\n         LR    R7,R2\n         MVC   FACTOR(1),ADDEND        SIGN OF FACTOR\n         MVC   ADDEND(6),0(R1)\n         B     SUBPM2\n*\nSUBPM4   LTR   R8,R7                   CONTROLLED VARIABLE ?\n         BZR   R9                      NO\n         B     SUBFIN4                 YES\n*\n*        FIRST OPERAND FOLLOWED BY ASTERISK\n*\nSUBAST   BAL   R14,SUBMULT             CHECK MULTIPLICATION\n         C     R1,SUBEND               END OF SUBSCRIPT ?\n         BE    SUBONE5                 YES, SET ADDEND TO ZERO\n         CLI   6(R1),XFMINUS           PLUS OR MINUS\n         BH    SUBNOOP                 NO, NO SUBSCRIPT OPTIMIZATION\n         LA    R1,6(,R1)               ADDR SIGN\n         BAL   R15,OPERANDR            CHECK OPERAND\n         MVC   ADDEND(6),0(R1)         SAVE ADDEND\n         LR    R7,R2                   LAST OPERAND WAS ADDEND\n*\nSUBFIN   LTR   R7,R7                   ADDEND CONTROLLED VARIABLE ?\n         BZ    SUBFIN1                 NO\n         SR    R5,R5                   YES, INDICATE ELEMENTARY LOOP\n         IC    R5,0(,R7)\n         LA    R6,ZFOSTA(R5)\n         OI    0(R6),X'80'\n         CR    R8,R7                   OPTIMIZATION POSSIBLE ?\n         BNH   SUBFIN4                 NO\nSUBFIN1  SR    R5,R5                   FSN OF CONTROLLED VAR TO RE6\n         IC    R5,0(0,R8)\n         L     R2,ZARSPO               ADDR LAST ARIDSTAB-ENTRY\n         LA    R6,ZFOSTA(R5)           ADDR FSTAB-ENTRY\n         TM    0(R6),X'40'             SUBSCRIPT OPTIMIZATION POSS ?\n         BO    SUBFIN4                 NO, NO OPTIMIZATION\n         LA    R6,SPTAB(R5)            ADDR SPTAB-ENTRY\n         CLC   0(1,R6),0(R2)           SCOPE OF ARRAY OK ?\n         BL    SUBFIN4                 NO, NO OPTIMIZATION\n         TM    FACTOR+2,X'30'          FACTOR CONSTANT ?\n         BZ    SUBFIN2                 YES\n         CLC   0(1,R6),FACTOR+3        SCOPE OF FACTOR OK\n         BL    SUBFIN4                 NO, NO OPTIMIZATION\nSUBFIN2  TM    ADDEND+2,X'30'          ADDEND CONSTANT ?\n         BZ    SUBFIN3                 YES\n         CLC   0(1,R6),ADDEND+3        SCOPE OF ADDEND OK ?\n         BL    SUBFIN4                 NO, NO OPTIMIZATION\nSUBFIN3  BAL   R14,SUTABENT            MAKE SUTAB ENTRY\n         BR    R9                      RETURN\n*\nSUBFIN4  SR    R5,R5\n         IC    R5,0(0,R8)              FSN OF CONTROLLED VARIABLE\n         LA    R6,ZFOSTA(R5)           ADDR FSTAB ENTRY\n         OI    0(R6),X'80'             ELEMENTARY LOOP\n         BR    R9\n*\n*        OPERANDR\n*\n*        SUBROUTINE TO SUSCRITE TO CHECK WHAT FOLLOWS AN\n*        OPERATOR IF NOT AN INTEGER OPERAND AN ERROR EXIT IS\n*        TAKEN. ELSE THE SETTING OF REGISTER R2 SHOWS TYPE OF\n*        OPERAND\n*\n*        INITIALIZED REG R2\n*\nOPERANDR TM    1(R1),X'80'             OPERAND ?\n         BZ    SUBNOOP                 NO\n         TM    2(R1),X'CE'             INTEGER ?\n         BM    SUBNOOP                 NO\n         TM    1(R1),X'06'             CRITICAL IDENTIFIER ?\n         BO    OPERAND1                YES\nOPERAND4 SR    R2,R2                   INDICATE NO-CONTROLLED VARIABLE\n         BR    R15                     RETURN\n*\n*        OPERAND CONTROLLED VARIABLE ?\n*\nOPERAND1 L     R2,PFA                  ADDR OF LAST CRIDTAB ENTRY\n         LA    R2,9(,R2)               INITIALIZE LOOP\nOPERAND2 SH    R2,KH9                  GET NEXT ENTRY\n         CLC   1(3,R2),3(R1)           OPERAND FOUND\n         BNE   OPERAND2                NO, GET NEXT CRIDTAB ENTRY\n*\nOPERAND3 TM    4(R2),X'80'             CONTROLLED VARIABLE ?\n         BOR   R15                     YES\n         TM    4(R2),X'40'             PRECEEDING CRITICAL IDENTIFIER ?\n         BZ    OPERAND4                NO\n         MVC   ALIGNH(2),5(R2)         GET CRIDTAB CHAIN\n         L     R2,ALIGN                GET ADDR OF CHAINED ENTRY\n         A     R2,ZFOCRI\n         B     OPERAND3                CHECK THIS ENTRY\n*\n*        SUBMULT\n*\n*        SUBROUTINE TO SUSCRITE TO CHECK WHAT FOLLOWS AN\n*        ASTERISK IF NOT INTEGER FACTOR TIMES INTEGER CONTROLLED\n*        VARIABLE AN ERROR EXIT IS TAKEN. OTHERWISE REGISTER R8\n*        AND BUCKET FACTOR ARE INITIALIZED\n*\n*        INITIALIZED R8\n*\nSUBMULT  MVC   FACTOR(6),0(R1)         MOVE OPERAND TO FACTOR\n         LR    R8,R2                   SAVE PTR\n         LA    R1,6(,R1)               ADDR NEXT OPERAND\n         BAL   R15,OPERANDR            CHECK SECOND OPERAND\n         CR    R2,R8                   WHICH OPERAND IS FACTOR ?\n         BH    SUBMULT2                FIRST\n         BE    SUBNOOP                 NONE, NO OPTIMIZATION\n         MVC   FACTOR+1(5),1(R1)       SECOND, MOVE OPERAND TO FACTOR\nSUBMULT1 LTR   R2,R2                   FACTOR CONTROLLED VARIABLE\n         BZR   R14                     NO, RETURN\n         SR    R5,R5                   SET FOR-LOOP OF FACTOR ELEMENT\n         IC    R5,0(0,R2)              FSN OF FACTOR\n         LA    R6,ZFOSTA(R5)           ADDR FSTAB-ENTRY\n         OI    0(R6),X'80'             MAKE LOOP ELEMENTARY\n         BR    R14                     RETURN\n*\nSUBMULT2 LR    R5,R2                   EXCHANGE REGISTERS\n         LR    R2,R8\n         LR    R8,R5\n         B     SUBMULT1\n*\n*        SUTABENT\n*\n*        SUBROUTINE TO SUBSCRITE TO MAKE AN SUTAB ENTRY\n*\nSUTABENT L     R1,ZSUTAPO              CURRENT SUTAB PTR\n         C     R1,ZSUDAD               A WRITE MACRO BEEN GIVEN ?\n         BNE   SUTAB1                  NO\n         BAL   R5,CHECK                CHECK LAST OPERATION ON SYSUT3\n         CLC   SULENGTH(4),SUTAB40S    TABLE OVERFLOW ?\n         BNL   SUTAB4                  YES\n         LH    R5,SUCNT                STEP RECORD COUNTER\n         LA    R5,1(,R5)\n         STH   R5,SUCNT\nSUTAB1   LA    R1,14(,R1)              ADDR NEW SUTAB-ENTRY\n         ST    R1,ZSUTAPO              SAVE SUTAB PTR\n*                                      MAKE SUTAB ENTRY\n         MVC   0(1,R1),0(R8)           INSERT FSN\n         MVC   1(3,R1),0(R2)           ADDR PART OF ARRAY\n         MVC   4(3,R1),FACTOR+3        ADDR PART OF FACTOR\n         MVC   7(3,R1),ADDEND+3        ADDR PART OF ADDEND\n         MVC   10(1,R1),ZPOSIX+1       SUBSCRIPT NUMBER\n         CLI   FACTOR,XFMINUS          SIGN OF FACTOR MINUS ?\n         BNE   SUTAB2                  NO\n         OI    10(R1),X'80'            YES, SET 1 BIT TO ONE\nSUTAB2   CLI   ADDEND,XFMINUS          SIGN OF ADDEND MINUS ?\n         BNE   SUTAB3                  NO\n         OI    10(R1),X'40'            YES, SET 2 BIT TO ONE\nSUTAB3   MVC   11(3,R1),4(R2)          POSITION OF OPENING BRACKET\n         C     R1,ZSUTMAX              SUTAB FILLED UP\n         BLR   R14\n         BAL   R5,CHECK                CHECK POSSIBLE WRITE\n         L     R5,SUSTRT               WRITE START ADDR\n         L     R6,SUTAB30S             LENGTH OF WRITE\n         BAL   R15,WRITE               WRITE\n         L     R5,SULENGTH             GET FULL SUTAB LENGTH\n         A     R5,SUTAB30S\n         ST    R5,SULENGTH\n         MVC   ZSUTAPO(4),ZSUDAD       INITIALIZE CURRENT SUTAB PTR\n         BR    R14\n*\nSUTAB4   BAL   R15,TABOFLO             HANDLE TABLE OVERFLOW\n         BAL   R15,MOVERRO\n         B     SUBFIN4                 NO OPT, MAKE LOOP ELEMENTARY\n*\nOUCHA    STM   R14,R2,REGSAVE          SAVE REGISTERS\nLOUCHAF  B     LOUCHA7                 BRANCH ONLY IF FIRST RECORD\n*\n         CHECK SWRITE\n*\nLOUCHA6  CLC   ZARSPO(4),ZARNO         BUFFER EXCHANGE IN SUBSCR EXPR ?\n         BNE   LOUCHA1                 YES\nLOUCHA5  MVI   1(R4),XFZETA            ZETA TERMINATES O-BUFFER\n         L     R4,ZOBWRITE\n         LR    R6,R4\n         BCTR  R4,0                    INITIALIZE R4\nLOUCHA4  L     R5,SRCE3S               OUTPUT BUFFER LENGTH\n         SH    R5,KH12                 SET END PTRS\n         AR    R5,R6\n         ST    R5,ZFILE9\n         LA    R5,3(,R5)\n         ST    R5,ZFILE6\n         LA    R5,1(,R5)\n         ST    R5,ZFILE5\n         LA    R5,2(,R5)\n         ST    R5,ZFILE3\n         LA    R5,1(,R5)\n         ST    R5,ZFILE2\n         LA    R5,1(,R5)\n         ST    R5,ZFILE1\n         MVC   ZOBWRITE(4),ZOBWORK     ZOBWRITE = ZOBWORK\n         ST    R6,ZOBWORK              START ADDR OF NEW OUT BUFFER\n         LH    R5,ZOUTCOT              OUTPUT RECORD COUNTER\n         CH    R5,KH255                TOO MUCH SOURCE OUTPUT ?\n         BE    LOUCHA8                 YES\n         LA    R5,1(,R5)\n         STH   R5,ZOUTCOT\n         L     R5,AUT2DCB              R5 -> SYSUT2 DCB\n         L     R6,ZOBWRITE             AREA ADDR\n*\n         WRITE SWRITE,SF,(R5),(R6)\n*\n         LM    R14,R2,REGSAVE          RESTORE REGS\n         BR    R15\n*\nLOUCHA1  L     R5,ZBRACK               GET CURRENT LEN OF SUBSCRIPT\n         LR    R6,R4\n         SR    R6,R5                   SUBSCRIPT LENGTH\n         BM    LOUCHA5                 NOTHING TO SAVE\n         CH    R6,KH18                 SUBSCRIPT ALREADY TOO LONG ?\n         BH    LOUCHA2                 YES\n         STC   R6,LOUCHAM+1            LENGTH OF SUBSCRIPT\n         STC   R6,LOUCHAL+3\n         L     R6,ZOBWRITE             START ADDR OF NEW OUT-BUFFER\nLOUCHAM  MVC   0(1,R6),0(R5)           SAVE SUBSCRIPT\n         MVI   0(R5),XFZETA            REPLACE OPENING BRACKET BY ZETA\nLOUCHAL  LA    R4,0(0,R6)              DISPLACEMENT LENGTH OF SUB\n         ST    R6,ZBRACK               ADDR OF OPENING BRACKET\n         CLI   0(R6),XFLSQBR           SUBSCRIPT OPERATOR OPEN BRAC ?\n         BNE   LOUCHA4                 NO\n         L     R5,ZARSPO               YES, UPDATE ARIDSTAB ENTRY\n         LH    R6,ZOUTCOT              OUTPUT RECORD COUNTER\n         LA    R6,1(,R6)               UPDATE\n         STC   R6,4(,R5)               STORE RECORD COUNTER\n         MVC   5(2,R5),ZERO            SET RELATIVE ADDR TO ZERO\n         L     R6,ZOBWRITE             START ADDR OF NEW BUFFER\n         B     LOUCHA4\n*\nLOUCHA2  BAL   R15,SUCRIDEL\n         MVI   ZCLOBRA,X'FF'           ZCLOBRA IS SET TO X'FF'\n         L     R5,ZOBWRITE             START ADDR OF NEW BUFFER\n         BCTR  R5,0\n         ST    R5,ZBRACK\n         B     LOUCHA5                 BRANCH TO LOUCHA5\n*\nLOUCHA7  MVI   LOUCHAF+1,X'00'         TURN OFF SWITCH\n         B     LOUCHA6\n*\nLOUCHA8  MVC   ZERRONU,TOOLONG\n         MVC   ZBEGERR,ZENDERR\n         BAL   R15,MOVERRO\n         B     LOMEGA3\n*\n*        ICHA\n*\n*        THE ROUTINE IS ENTERED WHEN OPERATOR ZETA (END OF INPUT\n*        BUFFER) IS FOUND. IF NECESSARY A PART OF THE OLD BUFFER\n*        IS SAVED IMMEDIATLY BEFORE THE NEW BUFFER. START\n*        ADDR OF SAVED AREA IS STORED IN ZIBWORK\n*\n*        RETURN VIA R15\n*\nICHA     STM   R14,R2,REGSAVE          SAVE REGISTERS\n*\n         CHECK SREAD                   CHECK LAST READ\n*\nICHA1    L     R5,AUT1DCB              R5 -> SYSUT1 DCB\n         L     R6,ZIBRUN               AREA ADDR\n*\n         READ  SREAD,SF,(R5),(R6)\n*\n         LM    R14,R2,REGSAVE          RESTORE REGISTERS\n         L     R3,ZIBREAD              BEGIN OF ACTIVITED BUFFER\n         MVC   ZIBREAD(4),ZIBRUN       EXCHANGE POINTERS\n         ST    R3,ZIBRUN\n         BR    R15\n*\nICHAI    STM   R14,R2,REGSAVE\n         B     ICHA1\n*\n*        ITABMOVE\n*\n*        ITABMOVE IS ENTERED AT THE BEGINNING OF A NEW PROGRAM\n*        BLOCK AND DURING INITIALIZATION. THE READ OF NEXT ITAB-\n*        RECORD IS ALREADY INITIALIZED. IF A MOVE OF NEXT RECORD\n*        IS NECESSARY IT IS DONE BY THE SUBROUTINE ITABM. ALL\n*        CURRENT ITAB-POINTERS IS UPDATED\n*\n*        RETURN VIA R15\n*        WORKREG R7, R8\n*        SUBROUTINE ITABM, MOVERRO\n*\nITABMOP  MVI   LETTER+1,X'00'          TURN OFF PROCEDURE SWITCH\nITABMOVE STM   R14,R2,REGSAVE\n         CLI   IOBYTE,READM            INITIALIZED READ OPERATION ?\n         BNE   ITAB4                   NO\n*\n         CHECK RITAB                   YES, CHECK\n*\n         MVI   IOBYTE,READC            SET READ CHECK MASK\nITAB4    L     R7,ZITREC               ADDR OF BLOCKBEGIN\n         MVC   6(2,R7),ZCURITLE        ITAB REC LENGTH OF EMBR BLOCK\n         MVC   ZCURITLE(2),0(R7)       LENGTH OF BLOCK\n         L     R8,ZCURITEN             A MOVE IS NECESSARY ?\n         LA    R8,11(,R8)\n         CR    R8,R7\n         BE    ITAB1                   NO, MOVE\n*\n*        MOVE ITAB RECORD\n*\n         LH    R6,ZCURITLE             LENGTH OF ITAB RECORD\n         EX    R6,ITABMEX              MOVE FIRST PART\n         LR    R5,R6\n         AR    R7,R5                   END ADDR OF MOVED RECORD\n         AR    R5,R8                   END ADDR OR UNMOVED RECORD\n         SH    R7,KH1792               PREPARE MOVE\n         SH    R5,KH1792               PREPARE MOVE\n         SRA   R6,8                    PREPARE BRANCH\n         SLA   R6,2\n         B     *+4(R6)\n*\n         B     ITABM8                  +00\n         B     ITABM7                  +04\n         B     ITABM6                  +08\n         B     ITABM5                  +12\n         B     ITABM4                  +16\n         B     ITABM3                  +20\n         B     ITABM2                  +24\n         MVC   0(256,R5),0(R7)         +28\n*\nITABM2   MVC   256(256,R5),256(R7)\nITABM3   MVC   512(256,R5),512(R7)\nITABM4   MVC   768(256,R5),768(R7)\nITABM5   MVC   1024(256,R5),1024(R7)\nITABM6   MVC   1280(256,R5),1280(R7)\nITABM7   MVC   1536(256,R5),1536(R7)\nITABM8   EQU   *\n*\nITAB1    LH    R5,ZCURITLE             GET ADDR OF LAST ITAB ENTRY\n         A     R5,ZCURITEN             ACTUAL RECORD LENGTH + PREV ADD\n         ST    R5,ZCURITEN\n         LA    R5,11(,R5)              ADDR OF FIRST FREE BYTE\n         ST    R5,ZITREC\n         CLC   10(1,R8),PBN+1          LAST ITAB RECORD ?\n         BE    ITAB7                   YES\n         MVC   ALIGNH(2),2(R8)         LENGTH OF NEXT BLOCK\n         A     R5,ALIGN                END ADDR OF NEXT BLOCK\n         C     R5,ZITEND               ITAB OVERFLOW ?\n         BH    ITAB10                  YES\n         CLI   IOBYTE,READC            WHICH I/O STATUS ?\n         BE    ITAB6                   CHECKED READ OPERATION\n         BL    ITAB5                   CHECKED WRITE OPERATION\n*\n         CHECK TWRITE                  INITIALIZED WRITE OPERATION\n*\nITAB5    EQU   *\n         L     R1,AUT3DCB              R1 -> SYSUT3 DCB\n*\n         NOTE  (1)                     SAVE ID OF LAST BLOCK\n*\n         ST    R1,NOTEW\n         L     R1,AUT3DCB              R1 -> SYSUT3 DCB\n         MVI   NOTER+3,X'01'           ADDR NEXT ITAB BLOCK\n*\n         POINT (1),NOTER\n*\nITAB6    L     R5,AUT3DCB              R5 -> SYSUT3 DCB\n         L     R6,ZITREC               READ START ADDR\n*\n         READ  RITAB,SF,(R5),(R6),'S'\n*\n         MVI   IOBYTE,READM            SET ITAB READ\nITAB7    LM    R14,R2,REGSAVE          RESTORE REGS\n         MVC   CURPBN(1),10(R8)        SAVE CURRENT PBN\n         BR    R15                     RETURN\n*\nITAB10   ST    R3,ZBEGERR              ERROR EDIT\n         ST    R3,ZENDERR\n         MVC   ZERRONU,ITABOVER\n         BAL   R15,MOVERRO\n         B     LOMEGA3\n*\nITABREAD STM   R14,R2,REGSAVE\n         LA    R8,GENER                 ADDR DUMMY HEADER\n         B     ITAB6\n*\nITABMEX  MVC   0(1,R8),0(R7)\n*\n*        INVALID OPERAND FOUND\n*\n*        SET SYNTAX CHECK MODE AND GIVE ERROR MESSAGE\n*\nINCOROP  OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE\n         LA    R0,ZIDEX+12\nINCOROP5 LR    R9,R3\nINCOROP1 CLI   0(R3),X'2E'             END OF OPERAND ?\n         BL    INCOROP2                YES\n         BE    INCOROP3                STRING OR LOGICAL VALUE\n         CLI   0(R3),XFZETA            END OF INPUT BUFFER ?\n         BE    INCOROP4                YES\n         LA    R3,1(,R3)               PROCEED SCAN FOR OPERAND END\n         B     INCOROP1\n*\nINCOROP4 LR    R1,R3\n         BAL   R15,MOVE\n         BAL   R15,ICHA\n         B     INCOROP5\n*\nINCOROP2 LR    R1,R3\n         BAL   R15,MOVE\n         ST    R8,ZENDERR\n         MVC   ZBEGERR,OPSTART\n         BAL   R15,MOVERRO\n         LA    R7,ZALLPU               REPLACE INCOR ID  BY ALL PUB ID\n         B     LETTER1\n*\nINCOROP3 MVC   0(6,R3),ZPOINT          REPLACE INT NAME BY SIX PERIODS\n         LA    R3,6(,R3)\n         B     INCOROP1\n*\n*        MOVERRO\n*\n*        ERROR EDITING ROUTINE\n*\n*        OUTPUTS ALWAYS FIXED PART CONTAINING LENGTH OF ENTRY,\n*        ERROR NUMBER AND SEMICOLON COUNTER. SOMETMES VARIABLE\n*        PART WHOSE START ADDR IS STORED IN ZBEGERR AND (END\n*        ADDR + 1) IN ZENDERR\n*\n*        RETURN VIA R15\n*\nMOVERRO  L     R5,NEXTERR\n         C     R5,ENDPOOL              ERROR POOL OVERFLOW ?\n         BH    MOVERRO2                YES\n         L     R6,ZENDERR              GET LENGTH OF VARIABLE PART\n         S     R6,ZBEGERR\n         CH    R6,KH12                 LENGTH EXCEEDS MAXIMUM ?\n         BNH   MOVERRO1                NO\n         LH    R6,KH12                 YES, SET LENGTH TO MAX\nMOVERRO1 LA    R6,4(,R6)               LENGTH OF FULL ERROR ENTRY\n         AR    R5,R6                   GET ADDR OF NEXT ERROR ENTRY\n         ST    R5,NEXTERR\n         SR    R5,R6\n         STC   R6,0(,R5)               FIXED PART OF ERROR ENTRY, LEN\n         MVC   1(1,R5),ZERRONU+1       ERROR NUMBER\n         MVC   2(2,R5),SEMCNT          SEMICOLON COUNTER\n         SH    R6,KH5                  ANY VARIABLE PART ?\n         BM    MOVERRO3                NO\n         STC   R6,MOVERROM+1           LENGTH OF MOVE\n         L     R6,ZBEGERR              START ADDR OF ADDITIONAL PART\nMOVERROM MVC   4(1,R5),0(R6)           MOVE ADDITIONAL PART\nMOVERRO3 BR    R15\n*\nMOVERRO2 MVI   0(R5),X'04'             TERMINATING ERROR ENTRY\n         MVI   1(R5),TOOMANY\n         MVC   2(2,R5),SEMCNT\n         LA    R5,4(,R5)\n         ST    R5,NEXTERR\n         B     LOMEGA3\n*\nMOVEP    LR    R5,R3                   FIELD OF ONE BYTE\n         SR    R5,R9\n         BNZ   MOVE\n         LTR   R7,R7                   POINT FOLLOWED BY ZERO ?\n         BMR   R15                     YES, NO SYNTAX ERROR\n         LA    R5,NUMBER(R7)           ADDR IMPLIED POINT\n         CR    R5,R8                   POINT TERMINATE NUMBER\n         BE    QTORLT1                 YES\n*\nMOVE     SR    R1,R9                   LENGTH OF MOVE\n         LR    R5,R8                   CALCULATE END ADDR\n         AR    R5,R1\n         CR    R5,R0                   FULL MOVE POSSIBLE ?\n         BH    MOVE1                   NO\n         EX    R1,MOVEEX               MOVE\n         LR    R8,R5                   STEP PTR\n         BR    R15                     RETURN\n*\nMOVE1    LR    R5,R0                   CALCULATE LEN OF POSSIBLE MOVE\n         SR    R5,R8\n         EX    R5,MOVEEX\n         LR    R8,R0\n         BR    R15                     RETURN\n*\nMOVEEX   MVC   0(0,R8),0(R9)\n*\nCHECK    CLI   IOBYTE,WRITEM           INITIALIZED WRITE OPERATION\n         BNER  R5                      NO, RETURN\n         STM   R14,R2,REGSAVE          SAVE REGS\n*\n         CHECK TWRITE                  CHECK LAST WRITE\n*\n         MVI   IOBYTE,WRITEC           SET WRITE CHECK MASK\n         LM    R14,R2,REGSAVE          RESTORE REGS\n         BR    R5\n*\nWRITE    STM   R14,R2,REGSAVE\n         CLI   IOBYTE,READC            WHICH I/O STATUS ?\n         BL    WRITE2                  CHECKED WRITE OPERATION\n         BE    WRITE1                  CHECKED READ OPERATION\n*\n         CHECK RITAB                   INITIALIZED READ OPERATION\n*\nWRITE1   L     R1,AUT3DCB              R1 -> SYSUT3 DCB\n*\n         NOTE  (1)                     SAVE ID OF LAST BLOCK\n*\n         ST    R1,NOTER\n         L     R1,AUT3DCB              R1 -> SYSUT3 DCB\n         MVI   NOTEW+3,X'01'           ADDR NEXT OUTPUT BLOCK\n*\n         POINT (1),NOTEW\n*\nWRITE2   EQU   *\n         L     R0,AUT3DCB              R0 -> SYSUT3 DCB\n         LA    R6,4(,R6)               ADD KEY LENGTH\n*\n         WRITE TWRITE,SF,(R0),(R5),(R6)\n*\n         MVI   IOBYTE,WRITEM           SET WRITE MASK\n         LM    R14,R2,REGSAVE\n         BR    R15\n*\nTABOFLO  L     R5,PFA                  ADDR OF LAST CRIDTAB ENTRY\nTABOFLO1 SR    R6,R6\n         IC    R6,0(,R5)               FOR STATEMENT NUMBER\n         LA    R6,FSTAB(R6)            ADDR FOR STATEMENT ENTRY\n         OI    0(R6),NOSUOP\n         SH    R5,KH9\n         C     R5,PFANO                END OF CRIDTAB ?\n         BNH   TABOFLO1                NO\n         MVI   ZLVOV,X'FF'             SET ERROR SWITCH\n         MVC   ZARSPO(4),ZARNO         SKIP ALL ARIDSTAB ENTRIES\n         ST    R3,ZBEGERR              ERROR EDITING\n         ST    R3,ZENDERR\n         MVC   ZERRONU,TABOVER\n         BR    R15\n*\nDIGIT19  LA    R8,NUMBER\n         LA    R0,NUMBER+19            MAX LENGTH OF CONSTANT + 1\n         SR    R7,R7\n         LR    R9,R3                   SET FIELD START\n         MVI   SCATEST,0\nDIG191   LA    R1,1(,R3)               TRT START\nDIG192   SR    R2,R2\nDIG193   TRT   0(256,R1),DIG19\n         BZ    DIGL19                  MORE THAN 256 BYTES\n         LR    R3,R1                   UPDATE R3\n         B     *(R2)                   BRANCH TABLE\n         B     DECPTM                  +04\n         B     SCAFACTM                +08\n         B     QTORLT                  +12\n         B     ZETAM                   +16\n         B     RHO                     +20\n         B     OTHER                   +24\n*\nDECPTM   BAL   R15,MOVE\n         AR    R7,R1                   EXPONENT CORRECTION\n         B     DECPOIN1\n*\nSCAFACTM BAL   R15,MOVE\n         AR    R7,R1                   EXPONENT CORRECTION\n         B     SCA1\n*\nQTORLT   BAL   R15,MOVE\n         AR    R7,R1                   NUMBER OF INTEGERS\nQTORLT1  ST    R7,ZEXCORR\n         BAL   R2,CERR                 REBUILD CONSTANT\n         MVC   ZERRONU,INVOP\n         B     INCOROP\n*\nZETAM    BAL   R15,MOVE\n         AR    R7,R1                   EXPONENT CORRECTION\n         BAL   R15,ICHA\n         LR    R1,R3\n         LR    R9,R3\n         B     DIG192\n*\nOTHER    C     R8,NSTART               BUFFER EXCHANGE WITHIN INTEGER ?\n         BNE   OTHER1                  YES\n         LR    R7,R3                   COMPUTE NUMBER OF DIGITS\n         SR    R7,R9\n         B     INTCON\n*\nOTHER1   BAL   R15,MOVE\n         AR    R7,R1                   GET NUMBER OF DIGITS\n         LR    R1,R8                   ADJUST POINTERS\n         LA    R9,NUMBER\n         B     INTCON\n*\nDIGL19   LA    R1,256(,R1)             UPDATE INPUT PTR\n         B     DIG193\n*\nDIGIT0   LA    R8,NUMBER\n         LA    R0,NUMBER+19            MAX LENGTH OF CONSTANT + 1\n         SR    R7,R7\n         MVI   SCATEST,0\n         LA    R1,1(,R3)\nDIG01    SR    R2,R2\nDIG02    TRT   0(256,R1),DIG0\n         BZ    DIGL0                   MORE THAN 256 BYTES\n         LR    R3,R1\n         LR    R9,R3\n         B     *(R2)\n         B     DIG191                  +04\n         B     QTORLT                  +08\n         B     DECPOIN1                +12\n         B     SCA0                    +16\n         B     ZETA0                   +20\n         B     RHO                     +24\n         B     OTHOP0                  +28\n*\nSCA0     LD    0,ZEROFLOA              FLOATING ZERO\n         B     SCA1\n*\nZETA0    BAL   R15,ICHA                CHANGE INPUT BUFFER\n         LR    R1,R3\n         B     DIG01\n*\nOTHOP0   C     R4,ZFILE5               OUTPUT BUFFER FULL ?\n         BNH   OTHOP01                 NO\n         BAL   R15,OUCHA               YES\nOTHOP01  MVC   3(3,R4),ZERO            ADDR PART OF INTERNAL NAME\n         MVC   1(2,R4),ZINTYP          INDICATE INTEGER\n         LA    R4,5(,R4)\n         B     GENTEST\n*\nDIGL0    LA    R1,256(,R1)             UPDATE INPUT PTR\n         B     DIG02\n*\nDECPOIN  LA    R8,NUMBER\n         LA    R0,NUMBER+19            MAX LENGTH OF CONSTANT + 1\n         SR    R7,R7\n         MVI   SCATEST,0\nDECPOIN1 LA    R9,1(,R3)\nDECPOIN2 LA    R1,1(,R3)\nDECPOIN3 SR    R2,R2\nDECPOIN4 TRT   0(256,R1),DECPO\n         BZ    DECPOINL                MORE THAN 256 BYTES\n         LR    R3,R1\n         B     *(R2)\n         B     DECP0                   +04 ZERO\n         B     QTORLTP                 +08\n         B     DECPSCA                 +12 SCALE FACTOR\n         B     DECPZETA                +16 ZETA\n         B     DECPOT                  +20 OTHER OPERATOR\n*\nDECP0    CR    R9,R3                   ZERO FOLLOWING POINT ?\n         BNE   DECPOIN2                NO\n         C     R8,NSTART               PRECEEDING SIGNIFICANT DIGIT ?\n         BNE   DECPOIN2                YES\n         BCTR  R7,0                    NO, DECREASE EXPONENT\n         B     DECPOIN1\n*\nQTORLTP  BAL   R15,MOVE\n         B     QTORLT1\n*\nDECPSCA  BAL   R15,MOVEP               SYNTAX CHECK AND MOVE\n         C     R8,NSTART               ZERO ?\n         BNE   SCA1                    NO\n         LD    0,ZEROFLOA              YES, FLOATING ZERO\n         B     SCA1\n*\nDECPZETA BAL   R15,MOVE\n         BAL   R15,ICHA\n         LR    R9,R3\n         LR    R1,R3\n         B     DECPOIN3\n*\nDECPOT   ST    R7,ZEXCORR\n         BAL   R15,MOVEP               SYNTAX CHECK AND MOVE\n         C     R8,NSTART               ZERO ?\n         BNE   REALCON                 NO, CONVERT NUMBER\n         LD    0,ZEROFLOA              YES, NUMBER IS FLOATING ZERO\n         B     REALHAN                 MAKE A CONSTANT POOL ENTRY\n*\nDECPOINL LA    R1,256(,R1)             UPDATE INPUT PTR\n         B     DECPOIN4\n*\nSCAFACT  SR    R7,R7\n         LD    0,ZONEFLOA              MANTISSA SET TO ONE\n         LA    R8,NUMBER               NO MANTISSA DIGIT\nSCA1     ST    R8,ZTO\n         ST    R7,ZEXCORR\n         LA    R8,SCAWORK\n         LA    R0,SCAWORK+9\n         MVI   SCATEST,X'10'           SCALE FACTOR PRESENT\n         MVI   SCALE,0                 CLEAR OLD SIGN\nSCA20    LA    R9,1(,R3)\nSCA2     LA    R1,1(,R3)\nSCA3     SR    R2,R2\nSCA4     TRT   0(256,R1),SCAFAC\n         BZ    SCAL                    MORE THAN 256 BYTES\n         LR    R3,R1\n         B     *(R2)\n         B     SCA19                   +04\n         B     SCAZERO                 +08\n         B     SCASIGN                 +12\n         B     SCAQL                   +16\n         B     SCAZETA                 +20\n         B     SCAOT                   +24\n*\nSCA19    OI    SCATEST,SF19            SIGNIFICANT DIGIT PRESENT\n         B     SCA2\n*\nSCAZERO  TM    SCATEST,SF19            ANY SIGNIFICANT DIGIT ?\n         BO    SCA2                    YES\n         OI    SCATEST,SFL0            LEADING ZERO\n         B     SCA20\n*\nSCASIGN  EQU   *\n         TM    SCATEST,SFLSIGN         LEADING SIGN ?\n         BNZ   SCAOT                   NO, TREAT AS OTHER OPERATOR\n         MVC   SCALE(1),0(R3)          SAVE SIGN\n         OI    SCATEST,SFSIGN          SIGNED SCALE FACTOR\n         B     SCA20\n*\nSCAZETA  BAL   R15,MOVE                SAVE FIELD\n         BAL   R15,ICHA\n         LR    R1,R3\n         LR    R9,R3\n         B     SCA3\n*\nSCAOT    TM    SCATEST,SFDIGIT         ANY DIGIT ?\n         BZ    SCAQL                   NO, ERROR MESSAGE\n         TM    SCATEST,SF19            ANY SIGNIFICANT DIGIT ?\n         BZ    SCAOT1                  NO\n         BAL   R15,MOVE\n         S     R8,SCAWORKA\n         EX    R8,SCAPACK\n         MVN   ZPACK+7(1),SREF         SET SIGN TO PLUS\n         CLI   SCALE,XFMINUS           MINUS SIGN ?\n         BNE   *+10                    NO\n         MVN   ZPACK+7(1),SREF+1       YES, REPLACE PLUS SIGN\n         CVB   R5,ZPACK                CONVERT\n         AR    R7,R5                   GET EXPONENT\n*\nSCAOT1   ST    R8,ZTOSCA\n         L     R8,ZTO\n         B     REALCON\n*\nSCAPACK  PACK  ZPACK(8),SCAWORK(0)\n*\nSCAQL    BAL   R15,MOVE\n         S     R8,SCAWORKA             SCALE FACTOR LENGTH\n         ST    R8,ZTOSCA\n         L     R8,ZTO\n         BAL   R2,CERR                 REBUILD CONSTANT\n         MVC   ZERRONU,INVOP\n         B     INCOROP\n*\nSCAL     LA    R1,256(,R1)             UPDATE INPUT PTR\n         B     SCA4\n*\n*        CONSTANT ERROR ROUTINE\n*\nCERR     TM    SCATEST,PRECERR         CONSTANT ALREADY REBUILT ?\n         BOR   R2                      YES\n         L     R5,ZEXCORR              NUMBER OF INTEGERS IN MANTISSA\n         LTR   R5,R5                   LEADING ZEROS AFTER POINT ?\n         BM    CERR1                   YES\n         CH    R5,KH12                 CONSTANT TOO LONG ?\n         BNH   CERRA                   NO\n         LH    R5,KH12                 SET MAXIMAL LENGTH\nCERRA    EX    R5,CERREX               MOVE CONSTANT INTEGERS\n         A     R5,OPSTART              ADDR DECIMAL POINT\n         MVI   0(R5),XFDECPT           INSERT POINT\n         BCTR  R8,0\n         CR    R8,R5                   ANY DECIMAL POINT ?\n         BE    *+8                     NO\n         LA    R8,1(,R8)               PREVENT POINT OVERLAY\n         B     CERR2\n*\nCERR1    MVI   ZIDEX,XFDECPT           INSERT POINT\nCERR2    TM    SCATEST,SF              SCALE FACTOR PRESENT ?\n         BZ    CERR3                   NO\n         LA    R0,NUMBER+21\n         MVC   0(2,R8),SCALEQ          INSERT QUOTE AND SIGN\n         TM    SCATEST,SFSIGN          SIGNED SCALE FACTOR ?\n         BO    *+6                     YES\n         BCTR  R8,0\n         LA    R8,2(,R8)\n         L     R1,ZTOSCA\n         LA    R1,1(,R1)               SCALE FACTOR LENGTH\n         LA    R9,SCAWORK\n         AR    R1,R9                   SCALE FACTOR END ADDR\n         BAL   R15,MOVE                MOVE SCALE FACTOR\n*\nCERR3    LA    R5,ZIDEX+12\n         CR    R8,R5                   MORE THAN 12 CHARACTERS ?\n         BNH   *+6                     NO\n         LR    R8,R5                   YES, SET LENGTH TO 12\n         ST    R8,ZENDERR\n         MVC   ZBEGERR,OPSTART\n         BR    R2\n*\nCERREX   MVC   ZIDEX(0),NUMBER\n*\nINTCON   CH    R7,KH10                 NUMBER OF DIGITS ?\n         BL    INTCON1                 NO\n         BH    INTCON2                 YES, REAL CONSTANT\n         CLC   0(10,R9),MAXINT         MAXIMAL INTEGER\n         BH    INTCON2                 GREATER, REAL CONSTANT\nINTCON1  BCTR  R7,0\n         EX    R7,INTPACK              PACK\n         MVN   ZPACK+7(1),SREF         SET PLUS SIGN\n         CVB   R2,ZPACK                PACK\n         B     INTHAN\n*\nINTCON2  ST    R9,ZBEGERR              GIVE ERROR MESSAGE\n         ST    R1,ZENDERR\n         MVC   ZERRONU,RANGEINT\n         BAL   R15,MOVERRO\n         ST    R7,ZEXCORR\n         L     R8,NSTART\n         BAL   R15,MOVE\n         B     REALCON\n*\nINTPACK  PACK  ZPACK(8),0(0,R9)        LENGTH IN R1\n*\nREALCON  LR    R6,R8                   GET LENGTH OF CONSTANT\n         S     R6,NSTART\n         BZ    REALCON7\n*\n*        CONVERT MANTISSA TO FLOATING FORM\n*\n         LD    0,ZEROFLOA              ZERO REG\n         LR    R9,R6                   NUMBER OF DIGITS\n         SR    R7,R9                   UPDATE EXPONENT CORRECTION\n         CH    R9,KH9                  CONVERSION IN ONE STEP ?\n         BH    REALCON1                NO\n         BCTR  R9,0\n         EX    R9,REPACK               PACK\nREALCON2 MVN   ZPACK+7(1),SREF         SET PLUS SIGN\n         CVB   R5,ZPACK                CONVERT TO BINARY\n         ST    R5,ZFLOFIEL+4           CONVERT TO FLOATING FORM\n         AD    0,ZFLOFIEL              GET NORMALIZED FLOATING NUMBER\n         C     R6,NREAL                MORE DIGITS THAN ALLOWED ?\n         BNH   REALCON3                NO\n         BAL   R2,CERR                 REBUILD CONSTANT\n         MVC   ZERRONU,PRECREAL\n         BAL   R15,MOVERRO\n         OI    SCATEST,PRECERR         INDICATE PRECISION ERROR\n         B     REALCON3\n*\n*        CONVERT EXPONENT TO FLOATING FORM\n*\nREALCON7 LTDR  0,0\n         BZ    REALHAN                 NUMBER OF DIGITS\nREALCON3 LPR   R9,R7                   UPDATE EXPONENT CORRECTION\n         BZ    REALHAN                 CONVERSION IN ONE STEP ?\n         LR    R1,R9                   NO\n         LA    R2,ZEXTABP-8\n         LTR   R7,R7                   PACK\n         BP    REALCON6                SET PLUS SIGN\n         LA    R2,ZEXTABN-8            CONVERT TO BINARY\nREALCON6 CH    R9,KH64                 CONVERT TO FLOATING FORM\n         BNL   REALCON5                GET NORMALIZED FLOATING NUMBER\n         N     R9,SCALEMSK\n         BZ    REALCON8                MORE DIGITS THAN ALLOWED ?\n         MD    0,56(R9,R2)             NO\nREALCON8 SLA   R1,3\n         N     R1,SCALEMSK\n         BZ    REALCON9                INDICATE PRECISION ERROR\n         MD    0,0(R1,R2)\nREALCON9 LTDR  0,0                     EXPONENT UNDERFLOW\n         BZ    REALERR1\n         B     REALHAN\n*\nREALCON5 MD    0,120(,R2)              10 ** +- 64\n         LTDR  0,0\n         BZ    REALERR1\n         SH    R9,KH64                 ADJUST EXPONENT\n         B     REALCON6\n*\nREALCON1 SH    R9,KH10\n         CH    R9,KH9                  CONSTANT TOO LONG ?\n         BL    REALCONA                NO\n         BCTR  R9,0                    YES, SKIP THE NINETEENTH DIGIT\n         AH    R7,KH1                  UPDATE R7\nREALCONA EX    R9,REPACK               PACK FIRST PART\n         MVN   ZPACK+7(1),SREF         SET PLUS SIGN\n         CVB   R5,ZPACK                CONVERT TO BINARY\n         ST    R5,ZFLOFIEL+4           CONVERT TO FLOATING FORM\n         AD    0,ZFLOFIEL              NORMALIZE\n         MD    0,ZTEN9                 MULTIPLY BY 10 ** 9\n         LA    R9,NUMBER+1(R9)         ADDR SECOND PART\n         PACK  ZPACK(8),0(9,R9)        PACK SECOND PART\n         B     REALCON2                TERMINATE CONVERSION\n*\nREPACK   PACK  ZPACK(8),NUMBER(0)      LENGTH OF NUMBER IN R9\n*\nREALERR  LA    R5,REALHAN              SET EXIT ADDR\n         ST    R5,ZSTO\n         MVC   9(3,R1),ZSTO+1          MODIFIED OLD PSW IN PIE\n         BAL   R2,CERR                 REBUILD CONSTANT\n         MVC   ZERRONU,RANGEREA\n         BAL   R15,MOVERRO\n         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE\n         BR    R14\n*\nREALERR1 BAL   R2,CERR                 REBUILD CONSTANT\n         MVC   ZERRONU,RANGEREA\n         BAL   R15,MOVERRO\n         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE\n         B     REALHAN\n*\n*        INTEGER HANDLING\n*\nINTHAN   C     R4,ZFILE5               SPACE ENOUGH IN OUTPUT BUFFER ?\n         BNH   INTHANA                 YES\n         BAL   R15,OUCHA               NO, CHANGE BUFFER\nINTHANA  MVC   1(2,R4),ZINTYP          FIRST TWO BYTES OF INTERNAL NAME\nINTHANR  CH    R2,KH15                 NUMBER GREATER THAN 15 ?\n         BH    INTHAN2                 YES\n         SLA   R2,2                    NO, MULTIPLY BY 4\n         STH   R2,ZLIRE\n         MVI   3(R4),0                 OUTPUT\n         MVC   4(2,R4),ZLIRE           FIELD\n         LA    R4,5(,R4)               UPDATE OUTPUT POINTER\n         B     GENTEST                 RETURN\n*\nINTHAN2  TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    INTHAN1                 YES\n         LA    R14,INTHAN6             INITIALIZE INTEGER SEARCH\n         LA    R8,4\n         L     R9,ZWP\n         L     R7,ZDWP\n         L     R1,ZLITSTA\n         SR    R1,R8\n         SR    R9,R8\nINTHAN6  BXH   R1,R8,INTHAN3           EXIT FOR END OF SEARCH\n         C     R2,0(,R1)               INTEGER FOUND ?\n         BNER  R14                     NO, PROCEED SEARCH\n*\nINTHAN1  S     R1,ZKOPOOL              GET REL ADDR\n         STH   R1,ZLIRE                IN CONST POOL\n         MVC   3(1,R4),KBN+1           INSERT CONSTANT BLOCK NUMBER\n         MVC   4(2,R4),ZLIRE           DISPLACEMENT ADDR\n         LA    R4,5(,R4)\n         B     GENTEST\n*\nINTHAN3  AR    R9,R8\n         CR    R9,R7                   DOUBLE WORD BOUNDARY ?\n         BE    INTHAN9                 YES\n*\nINTHAN4  LA    R1,4(,R1)               SCAN REST OF CONSTANT POOL\n         CR    R1,R7                   CURRENT END OF CONSTANT POOL ?\n         BE    INTHAN10                YES\n         C     R2,0(,R1)               LITERAL FOUND ?\n         BNE   INTHAN4                 NO\n         BE    INTHAN1\n*\nINTHAN10 LR    R1,R9\n         LR    R9,R7\nINTHAN7  ST    R9,ZWP                  SAVE PTR\n         ST    R2,0(,R1)               MAKE LITERAL POOL ENTRY\n         B     INTHAN1\n*\nINTHAN9  C     R9,ZKOPEND              END OF LITERAL POOL ?\n         BNL   INTHAN8\n         C     R9,ZTEXTCO              WRITE TXT CARD ?\n         BL    INTHAN5                 NO\n         BAL   R14,TXTTRAF             WRITE\nINTHAN5  LA    R9,4(,R9)               UPDATE POINTERS\n         A     R7,LREAL\n         ST    R7,ZDWP                 SAVE UPDATE ZDWP\n         B     INTHAN7\n*\nINTHAN8  CLC   ZKBNMAX(2),KH255        LAST CONST POOL\n         BE    INTHAN11                YES, GIVE ERROR MESSAGE\n         L     R9,ZDWP\n         BAL   R14,TXTTRAF             OUTPUT TXT RECORD\n         BAL   R14,CPOLEX              CONSTANT POOL EXCHANGE\n         L     R1,ZKOPOOL              START ADDR OF CONSTANT POOL\n         LA    R9,4(,R1)               UPDATE POINTERS\n         LR    R7,R1\n         A     R7,LREAL\n         ST    R9,ZWP\n         ST    R7,ZDWP\n         ST    R1,ZLITSTA\n         ST    R2,0(,R1)\n         B     INTHAN1\n*\nINTHAN11 ST    R1,ZBEGERR              GIVE\n         ST    R1,ZENDERR              ERROR\n         MVC   ZERRONU,MANYCON\n         BAL   R15,MOVERRO             GOTO ERROR RTN\n         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE\n         B     INTHAN1\n*\nREALHAN  C     R4,ZFILE5               SPACE ENOUGH IN OUTPUT BUFFER ?\n         BNH   REALHANA                YES\n         BAL   R15,OUCHA               NO, CHANGE BUFFER\nREALHANA MVC   1(2,R4),ZREALTYP        FIRST TWO BYTES OF INTERNAL NAME\n         CLI   ZFORTEST,0              IN FOR LIST ?\n         BE    REALHAN1                NO\n         L     R5,ZFSPTR               ADDR FSTAB ENTRY\n         OI    0(R5),NOCOUNT           CLASSIFY AS NO COUNTING LOOP\nREALHAN1 TM    COMPFLGS,LNG            LONG PRECISION ?\n         BO    REALH                   YES, BRANCH\n         STE   0,ZSTO                  START ROUNDING\n         MVC   ROUND(1),ZSTO\n         AD    0,ROUND                 ROUND\n         STE   0,ZSTO                  SHORT, TREAT AS INTEGER\n         L     R2,ZSTO\n         B     INTHANR\n*\nREALH    L     R1,ZLITSTA              INITIALIZE LITERAL SEARCH\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    INTHAN1                 YES\n         LA    R6,8\n         LR    R8,R6\n         SR    R1,R6\n         L     R9,ZWP\n         L     R7,ZDWP\n         CR    R9,R7\n         BE    REALH2\n         SR    R7,R6\n         LA    R14,REALH3\nREALH3   BXH   R1,R8,REALH4            EXIT AT END OF SEARCH\n         CD    0,0(,R1)                LITERAL FOUND ?\n         BNER  R14                     NO\n*\nREALH4   LA    R14,REALH5\n         SR    R1,R6\nREALH5   BXH   R1,R6,REALH6            EXIT AT END OF SCAN\n         CD    0,0(,R1)                CONSTANT FOUND ?\n         BNER  R14                     NO\n         B     INTHAN1                 YES\n*\nREALH6   AR    R7,R6\n         C     R7,ZKOPEND              END OF LITERAL POOL ?\n         BNL   REALH10                 YES\nREALH8   AR    R7,R6                   UPDATE ZDWP\n         ST    R7,ZDWP\n         STD   0,0(,R1)\n         B     INTHAN1\n*\nREALH7   BAL   R14,TXTTRAF             OUTPUT TXT\nREALH9   AR    R8,R7                   UPDATE ZWP\n         ST    R8,ZWP\n         B     REALH8\n*\nREALH2   LA    R14,REALH21\n         SR    R7,R6\nREALH21  BXH   R1,R6,REALH22           EXIT AT END OF SCAN\n         CD    0,0(,R1)                LITERAL FOUND ?\n         BNER  R14                     NO\n         B     INTHAN1                 YES\n*\nREALH22  AR    R7,R6\n         C     R7,ZKOPEND              END OF LITERAL POOL\n         BNL   REALH10\n         C     R7,ZTEXTCO              TXT TO BE PUT OUT ?\n         BL    REALH9                  NO\n         B     REALH7                  YES\n*\nREALH10  CLC   ZKBNMAX(2),KH255        LAST CONSTANT POOL ?\n         BE    REALH11                 YES\n         L     R9,ZDWP\n         BAL   R14,TXTTRAF             OUTPUT TXT\n         BAL   R14,CPOLEX              CONSTANT POOL EXCHANGE\n         L     R1,ZKOPOOL              START ADDR OF CONSTANT POOL\n         LA    R7,8(,R1)               UPDATE PTRS\n         ST    R7,ZDWP\n         ST    R7,ZWP\n         ST    R1,ZLITSTA\n         STD   0,0(,R1)                LITERAL ENTRY\n         B     INTHAN1\n*\nREALH11  ST    R3,ZBEGERR              TOO MANY LITERALS, MESSAGE\n         ST    R3,ZENDERR\n         MVC   ZERRONU,MANYCON\n         BAL   R15,MOVERRO\n         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE\n         B     INTHAN1\n*\n*        CONSTANT POOL EXCHANGE\n*\nCPOLEX   L     R15,ZKOPOOL             UPDATE\n         ST    R15,ZLITSTA\n         AH    R15,TXTPUT\n         ST    R15,ZTEXTCO             TXT RECORD POINTER\n         LH    R15,ZKBNMAX\n         LA    R15,1(,R15)\n         STH   R15,ZKBNMAX             CONSTANT POOL\n         STH   R15,KBN                 NUMBER\n         BR    R14                     RETURN\n*\n*        TRANSFER TXT RECORD\n*\nTXTTRAF  STM   R14,R6,TXTSAV           SAVE REGS\n         L     R2,ZTEXTCO\n         SH    R2,TXTPUT               ADDR OUTPUT TXT\n         LR    R5,R9                   CALCULATE LENGTH OF TXT\n         SR    R5,R2\n         STH   R5,TXTLE\n         LR    R5,R9                   GET NEW PUT ADDR\n         AH    R5,TXTPUT\n         ST    R5,ZTEXTCO\n         L     R6,PRPT                 LOAD PROGRAM PTR\n         TM    COMPFLGS+1,NLOAD+NDECK  NOLOAD AND NODECK ?\n         BO    TXTLE2                  YES, BRANCH\n         BAL   R14,GENTXT              OUTPUT OF TEXT\nTXTLE    DC    H'0'                    INSERT LENGTH OF TEXT\nTXTLE1   ST    R6,PRPT                 STORE PROGRAM PTR\n         LM    R14,R6,TXTSAV           RESTORE REGS\n         BR    R14                     RETURN\n*\nTXTLE2   AR    R6,R5                   UPDATE PROGRAM PTR\n         B     TXTLE1\n*\n*        GENERATE TXT RECORDS\n*\nGENTXT   LA    R4,2(,R14)              COMPUTE RETURN ADDR\n         LH    R14,0(,R14)             LOAD LENGTH GIVEN IN CALL\n         LA    R3,TXTT                 INDICATE TXT CALL\n         L     R1,SAVOUTA              LOAD ADDR OF OUT RECORD\n         CLC   1(3,R1),1(R3)           RECORD RIGHT TYPE ?\n         BNE   GEN3                    NO, CALL IOR NEW\n         CLC   10(2,R1),12(R3)         RECORD FILLED ?\n         BNL   GEN3                    YES, CALL FOR NEW\nGEN6     LA    R15,56\n         LH    R0,10(,R1)              R0 = LENGTH OF DATA IN REC\n         SR    R15,R0                  R15 = EMPTY POS LEFT IN RECORD\n         CR    R15,R14                 ENOUGH SPACE LEFT ?\n         BL    GEN6A                   NO\n         LR    R15,R14                 YES, R15 = LENGTH FROM CALL\nGEN6A    AR    R15,R0\n         STH   R15,10(,R1)             INSERT NEW LENGTH INTO RECORD\n         SR    R15,R0\n         AR    R1,R0                   START ADDR WITHIN RECORD\n         SR    R14,R15                 REMAINING LENGTH\n         B     GEN8                    GOTO MOVE TEXT\n*\nGEN4     LTR   R14,R14                 MORE INFORMATION TO BE MOVED ?\n         BZR   R4                      NO, RETURN TO CALLING ROUTINE\n*\n*        OUTPUT NEW RECORD\n*\nGEN3     ST    R14,SAVELT              SAVE LENGTH\n         TM    COMPFLGS+1,NLOAD+NDECK  BOTH DECK AND LOAD SPECIFIED ?\n         BZ    BOTH                    YES, BRANCH\n         TM    COMPFLGS+1,NDECK        ONLY DECK ?\n         L     R1,APCHDCB              R1 -> SYSPUNCH DCB\n         BZ    PUT1                    YES\nPUT1A    L     R1,ALINDCB              R1 -> SYSLIN DCB\n*\nPUT1     PUT   (R1)                    PUT FOR SYSLIN AND SYSPUNCH\n*\n         ST    R1,SAVOUTA              IF ONLY SYSPUNCH SPECIFIED\n         L     R14,SAVELT              RESTORE LENGTH\n         B     PUNCHOUT\n*\nSAVELT   DC    F'0'                    SAVE AREA FOR LENGTH\nBOTH     L     R14,OUTAREA2            COPY SYSLIN BUFFER TO SYSPUNCH\n         L     R1,SAVOUTA\n         MVC   0(80,R14),0(R1)         BUFFER\n         L     R1,APCHDCB\n*\n         PUT   (R1)                    PUT FOR SYSPUNCH WHEN BOTH HAS\n*\n         ST    R1,OUTAREA2             BEEN SPECIFIED\n         B     PUT1A                   GOTO PUT SYSLIN\n*\nPUNCHOUT EQU   *\n         MVC   0(4,R1),0(R3)           INSERT FIRST 4 BYTES\n         MVI   4(R1),C' '              INSERT ONE BLANK\n         MVC   5(67,R1),4(R1)          BLANK OUTPUT RECORD\n         MVC   72(4,R1),PIDENT         INSERT PROGRAM IDENT\n         AP    CARDCNT,KP1             STEP SEQUENCE NUMBER\n         UNPK  76(4,R1),CARDCNT        UNPACK INTO RECORD\n         OI    79(R1),X'F0'            MAKE PRINTABLE\n         MVC   10(2,R1),4(R3)          INSERT INITIAL LENGTH\n         MVC   14(6,R1),6(R3)          INSERT ESID+R AND P\n         ST    R6,4(0,R1)\n         MVI   4(R1),C' '\n         B     GEN6\n*\n*        TXT RECORD\n*\nTXTT     DC    X'02'                   CARD CODE\n         DC    C'TXT'                  IDENTIFICATION\n         DC    H'0'                    INITIAL LENGTH 0\n         DC    H'1'                    ESID\n         DC    C'    '\n         DC    H'56'                   MAXIMUM LENGTH\n*\n*        TXT MOVE ROUTINE\n*\nGEN8     BCTR  R15,0                   DECR R15\n         STC   R15,*+5                 INSERT PROPER LENGTH TO MOVE\n         MVC   16(0,R1),0(R2)          MOVE DATA TO OUT AREA\n         LA    R6,1(R15,R6)            INCREASE PROGRAM POINTER\n         LA    R2,1(R15,R2)            MODIFY DATA ADDR\n         B     GEN4                    OUT OF MOVE TXT ROUTINE\n*\n*        AREAS AND CONSTANTS LOCAL FOR GENTXT\n*\nTXTSAV   DC    9F'0'                   REGISTER SAVE AREA\nKP1      DC    PL1'1'                  CARD COUNT INCREMENT\n*\nINTERUPT CLI   7(R1),X'0C'             FLOATING POINT OVERFLOW ?\n         BE    REALERR                 YES\n         L     R5,OLDSPIE              NO, USE DIRECTORY ROUTINE\n         L     R15,0(,R5)              ADDR ERROR ROUTINE OF DIREC\n         BR    R15                     ENTER ERROR ROUTINE\n*\nZERO     DC    3H'0'\nKH1      DC    H'1'\nKH5      DC    H'5'\nKH7      DC    H'7'\nKH8      DC    H'8'\nKH9      DC    H'9'\nKH10     DC    H'10'\nKH11     DC    H'11'\nKH12     DC    H'12'\nKH15     DC    H'15'\nKH18     DC    H'18'\nKH56     DC    H'56'\nKH64     DC    H'64'\nKH255    DC    H'255'\nKH1792   DC    H'1792'\nKH4096   DC    H'4096'\n*\n*        ERROR MESSAGE NUMBERS\n*\nINVOP    DC    H'80'                   SYNTAX ERROR IN OPERAND\nUNDEFOP  DC    H'81'                   UNDEFINED IDENTIFIER\nRANGEREA DC    H'82'                   REAL CONSTANT OUT OF RANGE\nRANGEINT DC    H'83'                   INTEGER OUT OF RANGE\nPRECREAL DC    H'84'                   PRECISION OF REAL TOO GREAT\nGOTOFOR  DC    H'85'                   GO TO INTO FOR STATEMENT\nMANYCON  DC    H'86'                   TOO MANY CONSTANTS\nTABOVER  DC    H'87'                   OPTIMIZATION TABLE OVERFLOW\nARRAYERR DC    H'88'                   INVALID ARRAY LIST IDENTIFIER\nSWITCHER DC    H'89'                   SWITCH DECLARATION ERROR\nITABOVER DC    H'213'                  ITAB OVERFLOW\nTOOMANY  EQU   212                     TOO MANY ERRORS\nTOOLONG  DC    H'215'                  TOO MUCH SOURCE OUTPUT\n*\n*        SUBSCRIPT TABLE\n*\nZSUTAPO  DC    A(0)                    CURRENT SUTAB PT\nZSUDAD   DC    A(0)                    ADDR OF FIRST SUTAB ENTRY\nZSUTMAX  DC    A(0)                    SUTAB END PT\nSUSTRT   DC    A(0)                    START ADDR OF SUTAB RECORD\nSUKEY    DC    C'SUTB'                 SUTAB RECORD IDENTIFICATION\nSULENGTH DC    F'0'                    ACCUMULATED LENGTH OF SUTAB\nSUCNT    DC    H'0'                    NUMBER OF WRITTEN SUTAB RECORDS\n*\n*        LEFT VARIABLE TABLE\n*\nZLESTA   DC    A(0)                    ADDR OF FIRST LVTAB ENTRY\nZLEVA    DC    A(0)                    CURRENT LVTAB PT\nZLEMAX   DC    A(0)                    LVTAB END PT\nLVSTRT   DC    A(0)                    START ADDR OF LVTAB RECORD\nLVKEY    DC    C'LVTB'                 LVTAB RECORD IDENTIFICATION\nLVLENGTH DC    F'0'                    ACCUMULATED LENGTH OF LVTAB\nLVCNT    DC    H'0'                    NUMBER OF WRITTEN LVTAB RECORDS\n*\n*        INPUT RECORD\n*\nZIBRUN   DC    A(0)                    START OF ACTIVE INPUT BUF\nZIBREAD  DC    A(0)                    START OF NEXT INPUT BUFFER\n*\n*        OUTPUT RECORD\n*\nZOBWORK  DC    A(0)                    START OF ACTIVE OUTPUT BUFFER\nZOBWRITE DC    A(0)                    START OF LAST OUTPUT BUFFER\nZFILE1   DC    A(0)                    OUTPUT RECORD END - 1\nZFILE2   DC    A(0)                    OUTPUT RECORD END - 2\nZFILE3   DC    A(0)                    OUTPUT RECORD END - 3\nZFILE5   DC    A(0)                    OUTPUT RECORD END - 5\nZFILE6   DC    A(0)                    OUTPUT RECORD END - 6\nZFILE9   DC    A(0)                    OUTPUT RECORD END - 9\nZOUTCOT  DC    H'1'                    OUTPUT RECORD NUMBER\n*\n*        IDENTIFIER TABLE\n*\nZIBSTAO  DC    A(0)                    ITAB START ADDR\nZITAN    DC    A(0)                    ADDR OF ITAB ENTRY OF LAST ID\nZCURITEN DC    A(0)                    ADDR OF LAST ITAB ENTRY\nZITREC   DC    A(0)                    START OF NEXT ITAB RECORD\nZITEND   DC    A(0)                    ITAB END ADDR\nZCURITLE DC    H'0'                    LENGTH OF LAST ITAB RECORD\n*\n*        ERROR MESSAGES\n*\nZBEGERR  DC    F'0'                    START OF VARIABLE INFORMATION\nZENDERR  DC    F'0'                    END OF VARIABLE INFORMATION\nZERRONU  DC    H'0'                    ERROR NUMBER\n*\n*        ARRAY IDENTIFIER STACK\n*\nZARMAX   DC    A(ZARSTACK+28)          END ADDR IN ARIDSTACK\nZARNO    DC    A(ZARSTACK-7)           START ADDR OF ARIDSTACK\nZARSPO   DC    A(ZARSTACK-7)           CURRENT POINT IN ARIDSTACK\nZPOSIX   DC    H'0'                    COMPONENT NUMBER IN ARRAY\nZARSTACK DC    XL35'00'                ARIDSTACK\n*\n*        SUBSCRIPT TEST ROUTIN2\n*\nSUBEND   DC    A(0)                    SUBSCRIPT END ADDR\nADDEND   DC    3H'0'                   SAVE AREA FOR ADDEND\nFACTOR   DC    3H'0'                   SAVE AREA FOR FACTOR\nZEROELEM DC    XL6'00C801000000'       INTERNAL CODE FOR +0\nONEELEM  DC    XL6'00C801000004'       INTERNAL CODE FOR +1\nZBRACK   DC    A(0)                    SUBSCRIPT START ADDR - 1\n*\nZSTO     DC    F'0'                    TEMPORARY STORAGE\nZSTO1    DC    X'0670'\nZSTO2    DC    X'0240'\nZIGN     DC    H'0'                    CURRENT IDENTIFIER GROUP NUMBER\nZPOINT   DC    6AL1(XFDECPT)\nZALLPUP  DC    X'91FF010000'           ALL PURPOSE IDENTIFIER\nZALLPU   EQU   ZALLPUP-6\nZIDEX    DC    37X'00'                 WORKAREA\nNUMBER   EQU   ZIDEX+1\nOPSTART  DC    A(ZIDEX)\n*\nBRCNT    DC    H'0'                    BRACKET COUNTER IN ARRAY DECL\nSTATUS   DC    X'00'                   STATUS BYTE\nCURPBN   DC    C' '                    PBN OF LAST BLOCK\nZCLOBRA  DC    X'00'                   SUBSCRIPT TEST BYTE\nZFORTEST DC    X'00'                   FOR STATEMENT TEST BYTE\nZLVOV    DC    X'00'                   SET X'FF' IF NO MORE SUBSC OPT\nZFSN     DC    C' '                    CURRENT FOR STATEMENT NUMBER\nFSNEMBR  DC    C' '                    NUMBER OR EMBRACING BLOCK\nIOBYTE   DC    C' '                    STATUS BYTE FOR SYSUT3\nNOTEW    DC    F'0'                    ID OF LAST WRITTEN RECORD\nNOTER    DC    F'0'                    ID OF LAST READ ITAB RECORD\n*\n*        CRITICAL VARIABLE TABLE\n*\nPFA      DC    A(0)                    CURRENT CRIDTAB PT\nPFANO    DC    A(0)                    START ADDR OF CRIDTAB\nPFAMAX   DC    A(0)                    END ADDR OF CRIDTAB\nZFSPTR   DC    A(0)                    POINT TO CURRENT FSTAB ENTRY\nZFOCRI   DC    A(0)\n*\n*        CONSTANT POOL\n*\nZKOPOOL  DC    A(0)                    START ADDR OF POOL\nZKOPEND  DC    A(0)                    END ADDR OF POOL\nZLITSTA  DC    A(0)                    START ADDR OF USED PART\nZTEXTCO  DC    A(0)                    END ADDR OF TXT PIECE\nZKBNMAX  DC    H'0'                    NUMBER OF NEXT POOL\nTXTPUT   DC    H'56'                   LENGTH OF TXT PIECE\n*\nZPACK    DC    D'0'                    WORKAREA TO PACK NUMBERS\nZEROFLOA DC    D'0.0'\nZONEFLOA DC    D'1.0'\nZTEN9    DC    D'1.0E+9'\nZFLOFIEL DC    X'4E00000000000000'     WORKAREA FOR FLOATING CONVERS\nROUND    DC    X'0000000080000000'     USED TO ROUND SHORT FORM REAL\nZWP      DC    A(0)                    WORD POINTT IN CONSTANT POOL\nZDWP     DC    A(0)                    DOUBLE WORD PT IN CONSTANT POOL\nNSTART   DC    A(NUMBER)               PTR TO NUMBER\nSCALEMSK DC    XL4'38'\nLREAL    DC    F'8'                    SHORT PREC 4, LONG PREC 8\nNREAL    DC    F'18'                   SHORT PREC 7, LONG PREC 18\nZLIRE    DC    H'0'\nZINTYP   DC    X'C801'                 ID OF INTEGER CONSTANT\nZREALTYP DC    X'C802'                 ID OF REAL CONSTANT\nSREF     DC    P'+1'                   PLUS\n         DC    P'-1'                   MINUS, MUST FOLLOW SREF\nSCATEST  DC    C' '                    SCALE FACTOR TEST BYTE\nSCALEQ   DC    AL1(XFQUOTE),X'00'\nSCALE    EQU   SCALEQ+1\nMAXINT   IEXCGEN DC,'2147483647'       MAX INTEGER IN INTERNAL CODE\nSCAWORK  DC    10X'00'                 STORE FOR SCALE FACTOR\nZTO      DC    F'0'\nZEXCORR  DC    F'0'\nZTOSCA   DC    F'0'\nSCAWORKA DC    A(SCAWORK+1)\n*\nOLDSPIE  DC    A(0)                    ADDR OF OLD PICA\nTABSIZE  DC    F'0'                    ACCUMULATED SIZE OF TABLES\nREGSAVE  DC    5F'0'                   SAVEAREA FOR REGISTERS\nSPECUSE  DC    XL4'06'\nALIGN    DC    F'0'                    FULL WORD ALIGNMENT\nALIGNH   EQU   ALIGN+2                 HALF WORD ALIGNMENT\n*\nZEXTABP  DC    D'1.0E+1'\n         DC    D'1.0E+2'\n         DC    D'1.0E+3'\n         DC    D'1.0E+4'\n         DC    D'1.0E+5'\n         DC    D'1.0E+6'\n         DC    D'1.0E+7'\n         DC    D'1.0E+8'\n         DC    D'1.0E+16'\n         DC    D'1.0E+24'\n         DC    D'1.0E+32'\n         DC    D'1.0E+40'\n         DC    D'1.0E+48'\n         DC    D'1.0E+56'\n         DC    D'1.0E+64'\n*\nZEXTABN  DC    D'1.0E-1'\n         DC    D'1.0E-2'\n         DC    D'1.0E-3'\n         DC    D'1.0E-4'\n         DC    D'1.0E-5'\n         DC    D'1.0E-6'\n         DC    D'1.0E-7'\n         DC    D'1.0E-8'\n         DC    D'1.0E-16'\n         DC    D'1.0E-24'\n         DC    D'1.0E-32'\n         DC    D'1.0E-40'\n         DC    D'1.0E-48'\n         DC    D'1.0E-56'\n         DC    D'1.0E-64'\n*\nGENER    DC    X'5454546854685454'\n         DC    X'3C606438541C2020'\n         DC    8X'54'\n         DC    X'245C543430'\n         DC    8X'54'\n         DC    X'4054544438282C545018480C'\n         DC    9X'08'\n         DC    X'00004C581014'\n         DC    30X'04'\n*\nIDENTI   DC    45X'10'\n         DC    X'000C04'\n         DC    13X'00'\n         DC    X'080C0C'\n         DC    30X'00'\n*\nDIG19    DC    45X'18'\n         DC    X'000C10'\n         DC    13X'00'\n         DC    X'140408'\n         DC    30X'0C'\n*\nDIG0     DC    45X'1C'\n         DC    X'00081400'\n         DC    9X'04'\n         DC    X'000000180C10'\n         DC    30X'08'\n*\nDECPO    DC    45X'14'\n         DC    X'00081004'\n         DC    13X'00'\n         DC    X'080C'\n         DC    30X'08'\n*\nSCAFAC   DC    X'0C0C'\n         DC    43X'18'\n         DC    X'00101408'\n         DC    9X'04'\n         DC    4X'00'\n         DC    32X'10'\n*\n*        ITAB ENTRIES FOR STANDARD PROCEDURES\n*\nFIXITAB  DC    X'013F0000002B'         HEADER FOR PBN O\n         DC    X'0000',X'000000'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'ABS'              ABS\n         ORG\n         DC    X'8882',X'002080'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'SIGN'             SIGN\n         ORG\n         DC    X'8881',X'0020C0'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'LENGTH'           LENGTH\n         ORG\n         DC    X'8881',X'0000E0'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'SYSACT'           SYSACT\n         ORG\n         DC    X'8A80',X'911203'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'SQRT'             SQRT\n         ORG\n         DC    X'8882',X'002004'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'SIN'              SIN\n         ORG\n         DC    X'8882',X'002008'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'COS'              COS\n         ORG\n         DC    X'8882',X'00200C'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'ARCTAN'           ARCTAN\n         ORG\n         DC    X'8882',X'002010'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'LN'               LN\n         ORG\n         DC    X'8882',X'002014'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'EXP'              EXP\n         ORG\n         DC    X'8882',X'002018'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'ENTIER'           ENTIER\n         ORG\n         DC    X'8881',X'0020F0'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'INSYMB'           INSYMB\n         ORG\n         DC    X'8A80',X'90181F'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'INREAL'           INREAL\n         ORG\n         DC    X'8A80',X'0A1822'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'ININTE'           ININTE\n         ORG\n         DC    X'8A80',X'091826'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'INBOOL'           INBOOL\n         ORG\n         DC    X'8A80',X'0B182A'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'INARRA'           INARRA\n         ORG\n         DC    X'8880',X'0E182E'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'INTARR'           INTARR\n         ORG\n         DC    X'8880',X'0D1832'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'INBARR'           INBARR\n         ORG\n         DC    X'8880',X'071836'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'OUTSYM'           OUTSYM\n         ORG\n         DC    X'8880',X'10143B'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'OUTREA'           OUTREA\n         ORG\n         DC    X'8880',X'02143E'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'OUTINT'           OUTINT\n         ORG\n         DC    X'8880',X'011442'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'OUTBOO'           OUTBOO\n         ORG\n         DC    X'8880',X'031446'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'OUTARR'           OUTARR\n         ORG\n         DC    X'8880',X'06144A'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'OUTTAR'           OUTTAR\n         ORG\n         DC    X'8880',X'05144E'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'OUTBAR'           OUTBAR\n         ORG\n         DC    X'8880',X'071452'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'OUTSTR'           OUTSTR\n         ORG\n         DC    X'8880',X'001456'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'PUT'              PUT\n         ORG\n         DC    X'8A80',X'04115A'\n*\n         DC    XL6'00'\n         ORG   *-6\n         IEXCGEN DC,'GET'              GET\n         ORG\n         DC    X'8A80',X'04115E'\n*\nFIXITABL EQU   *-FIXITAB               L'FIXITAB\n*\n         LTORG\n*\nWORKAREA DSECT\n*\n         COPY  WORKAREA\n*\nZFOSTA   EQU   FSTAB\n*\n         ORG   SYSUT1\n*\nFSNMAX   DS    H\nLVCOUNT  DS    H\nSUCOUNT  DS    H\nZLEVEN   DS    F\nZSUTEN   DS    F\n*\n*        CHARACTER EQUATES\n*\n         IEXCHAR\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END   IEX30000\n./ ADD NAME=IEX31    0201-12230-12230-1200-00128-00128-00000-LEVEL\nX31      TITLE 'IEX31 - ERROR MESSAGE EDITING, ALGOL F'\n*\n*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER\n*\n*        FUNCTION/OPERATION -\n*        THE ERROR PATTERNS GENERATED DURING SCANIII ARE HANDLED\n*        AND THE CORRESPONDING DIAGNOSTIC MESSAGES ARE\n*        GENERATED\n*\n*        ENTRY POINT - IEX31000 - ERROR MESSAGE EDITING\n*                      XCTL EP=IEX31\n*                      THE MODULE IS ENTERED FROM IEX30\n*\n*        INPUT - N/A\n*\n*        OUTPUT -\n*        THE DIAGNOSTIC MESSAGES ARE PUT OUT ON SYSPRINT. IF\n*        SYSPRINT IS DOWN, THIS IS REPORTED WITH A WTO\n*\n*        EXTERNAL ROUTINE - THE PRINT ROUTINE IN IEX00 IS USED\n*\n*        EXIT - NORMAL -\n*        IF NO TERMINATING ERROR HAS OCCURRED CONTROL IS GIVEN\n*        TO THE NEXT PHASE BY MEANS OF XCTL EP=IEX40.\n*\n*        EXIT - ERROR -\n*        IF A TERMINATING ERROR HAS OCCURRED (IN THIS MODULE OR\n*        THE PRECEDING) CONTROL IS GIVEN TO THE TERMINATING\n*        MODULE BY MEANS OF XCTL EP=51002.\n*\n*        TABLES/WORKAREAS -\n*        THE MESSAGE TEXTS WITH CORRESPONDING ADDRESS TABLE ARE\n*        IN THE LOAD MODULE IEX31M\n*        THE ERROR MESSAGE EDITING ROUTINE, CSECT IEX60000, ALSO\n*        USES THE FOLLOWING TABLES -\n*        WINTEBC  - TRANSLATION OF INTERNAL CHARACTERS TO EBCDIC\n*        WSYMBSRC - TRANSLATION OF INTERNAL SYMBOLS TO EBCDIC\n*        WSYMBSTK - TRANSLATION OF INTERNAL SYMBOLS TO EBCDIC\n*        WORDSEBC - TRANSLATION OF COMPOUND SYMBOLS IF SOURCE\n*                   IN EBCDIC\n*        WORDSISO - TRANSLATION OF COMPOUND SYMBOLS IF SOURCE\n*                   IN ISOCODE\n*        WEBCDIC  - TRANSLATION EBCDIC - EBCDIC\n*        A WORKAREA OF 270 BYTES, WAREA, IS USED FOR BUILDING\n*        THE MESSAGES\n*\n*        ATTRIBUTES - NONE\n*\n*        NOTES -\n*        CHARACTER CODE DEPENDENCE. FOR THE BUILDING OF A\n*        MESSAGE (CODE PART BETWEEN COT03 AND COT12) THE\n*        FOLLOWING APPLIES. IN CASE NO SOURCE INFORMATION IS TO\n*        BE INSERTED (COT31), OR IF THE INFORMATION IS EBCDIC-\n*        CHARACTERS (COT07), THE OPERATION OF CSECT IEX60000\n*        DEPENDS UPON AN INTERNAL REPRESENTATION OF THE EXTERNAL\n*        CHARACTER SET WHICH IS EQUIVALENT TO THE ONE USED AT\n*        ASSEMBLY TIME.\n*\n*        IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL\n*        CHARACTERS (COT33) THE OPERATION OF CSECT IEX60000\n*        DEPENDS UPON A TRANSLATION FROM THE INTERNAL\n*        REPRESENTATION TO THE EBCDIC CHARACTER SET BY MEANS OF\n*        THE TABLE 'WINTEBC'.\n*\n*        IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL\n*        ALGOL SYMBOLS (COT10) THE OPERATION OF CSECT IEX60000\n*        DEPENDS UPON A TRANSLATION FROM THE INTERNAL\n*        REPRESENTATION TO THE EBCDIC CHARACTER SET BY MEANS OF\n*        THE TABLES 'WSYMBSTK'/'WSYMBSRC' AND 'WORDSISO'/'WORDSEBC'.\n*\n*        FOR THE OUTPUT OF A MESSAGE (CODE PART BETWEEN COT12\n*        AND COT21) THE FOLLOWING APPLIES.\n*        WHEN A MESSAGE HAS BEEN BUILT IN EBCDIC, AN EBCDIC -\n*        EBCDIC TRANSLATION IS PERFORMED BEFORE OUTPUT BY MEANS\n*        OF THE TABLE 'WEBCDIC'. THUS THE OUTPUT MAY BE MODIFIED\n*        BY MAKING CHANGES IN THIS TABLE.\n*\n*        THE OPERATION OF CSECT IEX31000 DOES NOT DEPEND UPON A\n*        PARTICULAR INTERNAL REPRESENTATION OF THE EXTERNAL\n*        CHARACTER SET.\n*\n*        AT SYSTEM GENERATION THIS MODULE WILL BE LINKED\n*        TOGETHER WITH THE MODULE IEX31M TO FORM THE MODULE\n*        IEX31.\n*\n*        THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN\n*        CONNECTION WITH THE OTHER MODULES OF THE ALGOL COMPILER,\n*        IN PARTICULAR IT REQUIRES THE COMMON WORKAREA\n*\nIEX31000 CSECT\n*\n         IEXENTRY 'IEX31000 LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IEX31000,R15\n*\n         L     R2,=A(IEX60000)         ADDRESS ERROR MSG EDIT ROUTINE\n         LA    R14,SUSCR               LOAD RETURN ADDRESS\n         LA    R1,ERRINFO              ADDRESS INFO FOR ERROR ED ROUT\n         BR    R2                      GOTO ERROR MESSAGE EDITING\n*\n         DC    0F'0'\n*\n*        INITIALIZATION OF SUBSCR HANDLING\n*\nSUSCR    XCTL  EP=IEX40000\n*\nERRINFO  DC    V(IEX31M00)             ADDR OF MESSAGE TEXTS\n         DC    V(IEX31M01)             ADDR OF ADDR TABLE\n         DC    H'119'                  MODIFICATION NUMBER\n*\n         LTORG\n*\n         COPY  IEX60000\n*\nWORKAREA DSECT\n*\n         COPY  WORKAREA\n*\n*\n*        CHARACTER EQUATES\n*\n         IEXCHAR\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IEX31M   0201-12230-12230-1200-00129-00129-00000-LEVEL\nX31M     TITLE 'IEX31M - MESSAGE TEXTS FOR ERRORS DETECTED BY IEX00 ANDX\n                IEX30, ALGOL F'\n*\n*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER\n*\n*        FUNCTION/OPERATION -\n*        THIS MODULE CONTAINS MESSAGE TEXTS FOR ALL ERRORS THAT\n*        MAY BE DETECTED BY IEX00 AND IEX30, AND THE CORRESPONDING\n*        ADDRESS TABLE\n*\n*        ENTRY POINT - N/A\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        EXITS - NORMAL - N/A\n*\n*        EXITS - ERROR - N/A\n*\n*        TABLES/WORKAREAS - N/A\n*\n*        ATTRIBUTES - N/A\n*\n*        NOTES -\n*        AT SYSTEM GENERATION THIS MODULE WILL BE LINKED\n*        TOGETHER WITH THE MODULE IEX31 TO FORM THE MODULE IEX31\n*\nIEX31M00 CSECT\n*\n         ENTRY IEX31M01\n*\n*        ERROR MESSAGE POOL 2\n*\nWEMPOOL2 EQU   *\n*\nW080     DC    X'3E0300160C240023001B23'\n         DC    CL52'SOPERAND BEGINNING WITH  IS SYNTACTICALLY INCORRECTX\n               .'\n*\nW081     DC    X'2403000A0C240017000D17'\n         DC    CL26'SIDENTIFIER  NOT DECLARED.'\n*\nW082     DC    X'3603001C0C240029000D29'\n         DC    CL44'SREAL CONSTANT BEGINNING WITH  OUT OF RANGE.'\n*\nW083     DC    X'5A05001612240029001E29F00000001149'\n         DC    CL74'WINTEGER BEGINNING WITH  OUT OF RANGE. INTEGER CONSX\n               TANT CONVERTED TO REAL.'\n*\nW084     DC    X'750500291224003C00083CF00000003045'\n         DC    CL101'WPRECISION OF REAL CONSTANT BEGINNING WITH  EXCEEDX\n               S INTERNALLY HANDLED PRECISION. CONSTANT TRUNCATED.'\n*\nW085     DC    X'210300140C240021000021'\n         DC    CL23'SILLEGAL USE OF LABEL .'\n*\nW086     DC    X'1500'\n         DC    CL20'STOO MANY CONSTANTS.'\n*\nW087     DC    X'3A00'\n         DC    CL57'WFULL OPTIMIZATION NOT POSSIBLE DUE TO INTERNAL OVEX\n               RFLOW.'\n*\nW088     DC    X'8805000A1224001C002C1DF00000003D4B'\n         DC    CL120'WIDENTIFIER  IN BOUND EXPRESSION DECLARED IN SAME X\n               PROGRAM BLOCK AS ARRAY. DECLARATION IN SURROUNDING BLOCKX\n                SEARCHED FOR.'\n*\nW089     DC    X'450300040C240011003411'\n         DC    CL59'WGOTO  INVALID OUTSIDE FOR STATEMENT CONTAINING THIX\n               S LABEL.'\n*\n*        DIRECTORY MESSAGES\n*\nW090     EQU   *\nW209     EQU   *\n         DC    X'460400360FF00000840046000046'\n         DC    CL57'TCOMPILATION UNSUCCESSFUL DUE TO PROGRAM INTERRUPT.X\n                PSW .'\n*\nW091     EQU   *\nW210     EQU   *\n         DC    X'300300270C840030000030'\n         DC    CL38'TUNRECOVERABLE I/O ERROR ON DATA SET .'\n*\nW092     EQU   *\nW211     EQU   *\n         DC    CL56'PROGRAM INTERRUPT IN ERROR MESSAGE EDITING ROUTINE.X\n                PSW '\n*\nW093     EQU   *\nW212     DC    X'1200'\n         DC    CL17'TTOO MANY ERRORS.'\n*\nW094     EQU   *\nW213     DC    X'2800'\n         DC    CL39'TINTERNAL OVERFLOW OF IDENTIFIER TABEL.'\n*\nW095     EQU   *\nW215     EQU   *\n         DC    X'1A00'\n         DC    CL25'TSOURCE PROGRAM TOO LONG.'\n*\n*        ADDR TABLE FOR WEMPOOL2\n*\n         DC    0F'0'\nIEX31M01 EQU   *-320\n         DC    A(W080)\n         DC    A(W081)\n         DC    A(W082)\n         DC    A(W083)\n         DC    A(W084)\n         DC    A(W085)\n         DC    A(W086)\n         DC    A(W087)\n         DC    A(W088)\n         DC    A(W089)\n         DC    A(W090)\n         DC    A(W091)\n         DC    A(W092)\n         DC    A(W093)\n         DC    A(W094)\n         DC    A(0)\n         DC    A(W095)\n*\n         END\n./ ADD NAME=IEX40    0201-12230-12230-1200-00832-00832-00000-LEVEL\nX40 TITLE 'IEX40 - SUBSCRIPT HANDLING AND INITIALIZATION OF COMPILATIONX\n                PHASE, ALGOL F'\n*\n*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER\n*\n*        FUNCTION/OPERATION -\n*        IEX40000 BUILDS THE OPTIMIZATION TABLE (OPTAB) USING\n*        THE SUBSCRIPT TABLE, THE LEFT VARIABLE TABLE AND THE FOR\n*        STATEMENT TABLE. AN OPTAB ENTRY CORRESPOND TO AN\n*        OPTIMIZABLE SUBSCRIPT EXPRESSION INSIDE A FOR STATEMENT.\n*        IF NO OPTAB IS PRODUCED THIS IS INDICATED IN THE\n*        COMPILER STATUS BYTES IN COMPFLGS\n*        IEX40001 IS THE INITIALIZATION OF NEXT MODULE, IEX50,\n*        AND PERFORMS THE FOLLOWING FUNCTIONS -\n*        CALCULATION AND RESERVATION OF STORAGE AREAS NEEDED\n*        LOADING REGISTERS WITH START ADDRESSES\n*        READING THE FIRST RECORDS OF SOURCE PROGRAM AND OPTAB\n*        SETTING INITIAL VALUES IN THE PRIVATE PART OF COMMON\n*        WORKAREA\n*\n*        ENTRY POINT - IEX40000\n*\n*        INPUT -\n*        IEX40000 READS TWO TABLES CONSTRUCTED IN IEX30\n*        FROM SYSUT3. THE SUBSCRIPT TABLE (SUTAB) CONTAINS\n*        ENTRIES FOR LINEAR SUBSCRIPT EXPRESSIONS IN FOR\n*        STATEMENTS THAT ARE OPTIMIZABLE IN REGARD TO\n*        SUBSCRIPTS.\n*        THE LEFT VARIABLE TABLE (LVTAB) CONTAINS ENTRIES FOR\n*        INTEGER LEFT VARIABLES IN FOR STATEMENTS THAT ARE\n*        OPTIMIZABLE IN REGARD TO SUBSCRIPTS.\n*        IEX40001 READS THE FIRST TWO RECORDS OF THE\n*        SOURCE PROGRAM FROM SYSUT2 INTO TWO SOURCE BUFFERS.\n*        THE FIRST TWO RECORDS OF OPTAB ARE READ IN FROM SYSUT3\n*        TO TWO OPTAB BUFFERS\n*\n*        OUTPUT -\n*        THE OPTIMIZATION TABLE (UPTAB)IS WRITTEN OUT ON SYSUT3.\n*        OPTAB CONTAINS ONE ENTRY FOR EVERY OPTIMIZABLE\n*        SUBSCRIPT EXPRESSION IN A FOR STATEMENT\n*\n*        EXTERNAL ROUTINES -\n*        THE INTERRUPT ROUTINES OF IEX00 ARE USED\n*\n*        EXIT - NORMAL - CONTROL IS GIVEN TO THE NEXT LOAD\n*        MODULE BY MEANS OF XCTL EP=IEX50\n*\n*        EXITS - ERROR -\n*        INPUT/OUTPUT ERRORS AND PROGRAM INTERRUPTS ARE HANDLED\n*        BY A DIRECTORY ROUTINE WHICH RETURNS CONTROL TO THE\n*        INTERRUPTED MODULE. IF THE ERROR OCCURED BEFORE THE\n*        GETMAIN IN IEX40001 CONTROL IS GIVEN TO THE TERMINATING\n*        MODULE BY MEANS OF XCTL EP=IEX51ER2\n*        IF THE ERROR OCCURED AFTER THE GETMAIN CONTROL IS GIVEN\n*        TO THE TERMINATING MODULE BY MEANS OF\n*        XCTL EP=IEX51ER1\n*\n*        TABLES/WORKAREAS -\n*        THE FOR STATEMENT TABLE (FSTAB) CONSTRUCTED IN IEX30\n*        AND POSSIBLY REVISED BY IEX40000 CONTAINS\n*        CLASSIFICATIONS OF THE FOR STATEMENTS\n*\n*        ATTRIBUTES - NONE\n*\n*        NOTES -\n*        THE OPERATION OF THIS MODULE DOES NOT DEPEND UPON ANY\n*        SPECIAL REPRESENTATION OF THE EXTERNAL CHARACTER SET.\n*        THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN\n*        CONNECTION WITH THE OTHER MODULES OF THE ALGOL COMPILER.\n*        IN PARTICULAR IT REQUIRES THE COMMON WORKAREA\n*\n*\nIEX40000 CSECT\n*\n*        BIT PATTERNS\n*\nFIRSTM   EQU   X'20'                   FIRST ENTRY IN SUTAB CHAIN\nSUCM     EQU   X'10'                   SUCCEDING ENTRY IN SUTAB CHAIN\nLASTM    EQU   X'30'                   LAST ENTRY IN SUTAB CHAIN\nOFFM     EQU   X'CF'                   TURN OFF SUTAB CHAIN BITS\nSUOP     EQU   X'40'                   SUBSCRIPT OPTIMIZATION BIT\n*\n         IEXENTRY 'IEX40000 LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IEX40000,R12\n         LR    R12,R15\n*\n         USING WORKAREA,R13\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    NOSUTAB                 YES\n*\n*        INITIALIZE SUTAB\n*\n         CLC   ZSUTEN(4),KF0           SUTAB EMPTY ?\n         BE    NOSUTAB                 YES\n*\n*        ANY NESTED FOR LOOPS ?\n*\n         SR    R2,R2\n         ST    R2,FOR1\n         MVC   FOR1+4(255),FOR1+3      SET FOR STMT COUNT\n         MVC   FOR2+2(255),FOR2+1      AREAS TO ZERO\n         LH    R0,FSNMAX\n         AH    R0,KH1                  NO OF FOR STMT\n         LA    R1,GPTAB\nGP1      LA    R1,3(,R1)               PTR TO NEXT GPTAB RECORD\n         CLC   KF0(1),2(R1)            FOR STATEMENT ?\n         BE    GP1                     NO\n         SH    R0,KH1                  ALL FOR STMT CHECKED ?\n         BM    GP10                    YES\n         MVC   FOR4(3),0(R1)           MOVE GPTAB RECORD\n         LH    R3,FOR4                 MULTIPLY GPTAB PTR BY 3\n         AR    R3,R3                   GIVES CORRECT ADDR\n         AH    R3,FOR4                 IN GPTAB\n         LA    R3,GPTAB(R3)\n         CLC   KF0(1),2(R3)            NESTED ?\n         BE    GP1                     NO\n         IC    R2,FOR4+2               FOR STMT NO+1\n         LA    R4,FOR2-1(R2)\n         MVC   0(1,R4),2(R3)           STORE ENCLOSING FSN\n         B     GP1\n*\nGP10     LA    R2,TERMIN2              TERMINATION ADDR\n         ST    R2,ERET\n         L     R0,SUTAB40S             RESERVE TABLE AREA\n         A     R0,OPTABS\n         AR    R0,R0\n         AH    R0,KH8\n         ST    R0,TABSIZE              SAVE LENGTH OF TABLE AREA\n*\n         GETMAIN R,LV=(0)              ALLOCATE STORAGE TO SUTAB\n*\n         LA    R2,TERM1                ERROR RETURN ADDR\n         ST    R2,ERET\n         ST    R1,TSTART               SUTAB START ADDR\n*\n*        READ SUTAB\n*\n         LH    R10,SUCOUNT             NUMBER OF SUTAB RECORDS - 1\n         L     R9,SUTYPE               SUTAB RECORD IDENTIFICATION\n         L     R8,SUTAB30S             LENGTH OF WRITTEN SUTAB RECORDS\n         L     R11,TSTART              TABLE START ADDR\n         BAL   R7,READ                 READ FULL SUTAB\n*\n*        R11                           END ADDR OF UNSORTED SUTAB\n*        R10                           FOR STATEMENT NUMBER\n*        R9                            CURRENT PTR IN UNSORTED SUTAB\n*        R8                            PTR FOR CHAINING CHECK\n*        R7                            FULL LENGTH OF DELETED ENTRIES\n*\n*        SCAN SUTAB FOR ENTRY CHAINING AND ENTRY DELETION\n*\n         L     R9,TSTART               TABLE START ADDR WITH KEY\n         LA    R9,4(,R9)               DELETE KEY\n         LR    R11,R9                  CLACULATE END ADDR\n         A     R11,ZSUTEN\n         SR    R10,R10\n         SR    R7,R7\n*\nSUTABS   IC    R10,0(,R9)              ISOLATE ACTUAL FOR STATE NUMBER\n         LA    R2,FSTAB(R10)           ADDR ACRUAL FOR ENTRY\n         TM    0(R2),SUOP              SUBSCRIPT OPTIMIZATION POSSIBLE?\n         BZ    SUTABS2                 YES\n         LA    R7,14(,R7)              LENGTH OF DELETED ENTRIES\n         MVI   0(R9),X'FF'             NOT OPTIMIZABLE ENTRY\n         LA    R9,14(,R9)              GET NEXT ENTRY\n         CR    R9,R11                  SUTAB END ?\n         BE    SORTSU                  YES\n         B     SUTABS\n*\nSUTABS2  LR    R8,R9                   CHECK ENTRY CHAINING\nSUTABS3  LA    R8,14(,R8)              SCAN SUTAB FOWORD FOR CHAINING\n         CR    R8,R11                  SUTAB END ?\n         BE    SORTSU                  YES\n         CLC   10(4,R9),10(R8)         CHAIN ?\n         BE    SUTABS4                 YES\n         LR    R9,R8                   PROCESS NEW ENTRY AS FIRST\n         B     SUTABS\n*\nSUTABS4  IC    R10,0(,R8)              ISOLATE FSN OF NEW ENTRY\n         LA    R2,FSTAB(R10)           ADDR FSTAB ENTRY\n         TM    0(R2),SUOP              SUBSCRIPT OPTIMIZABLE ?\n         BZ    SUTABS5                 YES\n         MVI   0(R8),X'FF'             NO, DELETE ENTRY\n         LA    R7,14(,R7)              COUNT LENGTH OF DELETED ENTRIES\n         B     SUTABS3                 CHECK NEXT ENTRY\n*\nSUTABS5  OI    10(R9),FIRSTM           INDICATE FIRST ENTRY IN CHAIN\nSUTABS6  LR    R9,R8                   ADDR CURRENT LAST CHAIN ENTRY\nSUTABS7  LA    R8,14(,R8)              CHECK NEXT SUTAB ENTRY\n         CR    R8,R11                  SUTAB END ?\n         BE    SUTABS9                 YES\n         CLC   10(4,R9),10(R8)         ANOTHER CHAINED ENTRY ?\n         BE    SUTABS8                 YES\n         OI    10(R9),LASTM            INDICATE ENTRY IN CHAIN\n         LR    R9,R8                   PROCESS NEW ENTRY AS FIRST\n         B     SUTABS\n*\nSUTABS8  IC    R10,0(,R8)              NEW FOR STATEMENT NUMBER\n         LA    R2,FSTAB(R10)           ADDR FSTAB ENTRY\n         TM    0(R2),SUOP              SUBSCRIPT OPTIMIZATION POSSIBLE?\n         BZ    SUTABS10                YES, CHAIN\n         MVI   0(R8),X'FF'             DELETE ENTRY\n         LA    R7,14(,R7)              CALCULATE DELETED LENGTH\n         B     SUTABS7\n*\nSUTABS9  OI    10(R9),LASTM            INDICATE LAST ENTRY IN CHAIN\n         B     SORTSU\n*\nSUTABS10 OI    10(R9),SUCM             INDICATE BETWEEN ENTRY\n         B     SUTABS6\n*\nSORTSU   L     R3,TSTART\n         LA    R2,4(,R3)               START ADDR OF UNSORTED SUTAB\n         ST    R2,ZSTAD                START OF UNSORTED TABLE\n         L     R9,ZSUTEN               GET END OF UNSORTED SUTAB\n         AR    R9,R2\n         A     R3,TABSIZE              END ADDR OF SORTED SUTAB\n         ST    R3,ZSUDEN\n         S     R3,ZSUTEN\n         AR    R3,R7                   START OF SORTED SUTAB\n         C     R3,ZSUDEN               WHOLE SUTAB DELETED ?\n         BE    NOSUTAB1                YES\n         ST    R3,ZSUDAD\n         ST    R3,ZSORTSTA\n         LA    R11,14                  ENTRY LENGTH\n         BAL   R15,SORT                SORT SUTAB\n*\n*        INITIALIZE OPTAB BUFFERS\n*\n         L     R2,TSTART\n         ST    R2,ZOTAWRI              SECOND OPTAB BUFFER\n         A     R2,OPTABS\n         ST    R2,ZOTAFILL             FIRST OPTAB BUFFER\n         A     R2,OPTABS\n         ST    R2,ZOTMAX               ACTUAL BUFFER END\n         CLC   ZLEVEN(4),KF0           LVTAB EMPTY ?\n         BNE   SORTLE                  NO\n         MVC   ZLESTA(4),ZOTMAX        SET DUMMY START ADDR\n         B     SORTLE1\n*\nSORTLE   LH    R10,LVCOUNT             NUMBER OF LVTAB RECORDS - 7\n         L     R9,LVTYPE               LVTAB RECORD IDENTIFICATION\n         L     R8,LVTAB30S             LENGTH OF LVTAB RECORD\n         L     R11,TSTART              START ADDR OF TABLE AREA\n         BAL   R7,READ                 READ LVTAB INTO CORE\n         L     R2,TSTART\n         LA    R2,4(,R2)\n         ST    R2,ZSTAD                START ADDR OF UNSORTED TABLE\n         A     R2,ZLEVEN\n         LR    R9,R2                   END OF UNSORTED TABLE\n         C     R2,ZOTMAX               LVTAB LONGER THAN OPTAB BUFFER ?\n         BH    *+8                     YES\n         L     R2,ZOTMAX               NO, START SORTED TAB AFTER OPTAB\n         ST    R2,ZSORTSTA             START ADDR OF SORTED TABLE\n         ST    R2,ZLESTA\n         LA    R11,4                   ENTRY LENGTH\n         BAL   R15,SORT                SORT LVTAB\n*\nSORTLE1  L     R2,ZLESTA\n         A     R2,ZLEVEN\n         MVI   0(R2),X'FF'             SET LVTAB END\n         L     R2,AUT3DCB              R2 -> SYSUT3 DCB\n*\n         CLOSE ((R2),REREAD),TYPE=T    POINT TO BEGINNING OF DATASET\n*\n*        R4                            PTR TO START OF LVTAB GROUP\n*        R5                            CURRENT PTR IN LVTAB GROUP\n*        R6                            CURRENT SUTAB PTR\n*        R7                            SUTAB CHAIN SEARCHING PTR\n*        R8                            CURRENT OPTAB BUFFER PTR\n*        R9\n*\nOPTAB    L     R4,ZLESTA               START OF LVTAB\n         L     R6,ZSUDAD               START OF SUTAB\n         L     R8,ZOTAFILL             START OF FIRST OPT AB BUFFER\n*\n*        DOES LVTAB GROUP CORRESPOND TO THIS SUTAB ENTRY\n*\nOPT1     CLC   0(1,R6),0(R4)\n         BL    OPT3                    NO LVTAB ENTRIES TO THIS FOR ST\n         LR    R5,R4                   INITIALIZE CURRENT GROUP PTR\n         BH    OPT6                    SCAN FOR NEXT LVTAB GROUP\nOPT2     CLC   1(3,R5),4(R6)           CHECK FACTOR\n         BE    OPT71                   NO OPTIMIZATION\n         CLC   1(3,R5),7(R6)           CHECK ADDEND\n         BE    OPT7                    NO OPTIMIZATION\n         LA    R5,4(0,R5)              ADDR NEXT LVTAB ENTRY\n         CLC   0(1,R5),0(R4)           NEW ENTRY OF SAME GROUP ?\n         BE    OPT2                    YES, PROCEED CHECK\nOPT3     C     R8,ZOTMAX               END OF OPTAB BUFFER ?\n         BNL   OPT10                   YES\nOPT4     MVC   0(14,R8),0(R6)          MOVE SUTAB ENTRY TO OPTAB\n         SR    R2,R2\n         IC    R2,0(0,R8)              FOR STATEMENT NO\n         SR    R0,R0\nOPT42    IC    R0,FOR1(R2)             FOR STATEMENT COUNT\n         AH    R0,KH1                  INCREASE FS COUNT\n         CL    R0,KF86                 > 85 ENTRIES IN OPTAB ?\n         BL    OPT44                   NO\n         LA    R1,FSTAB(R2)\n         OI    0(R1),X'80'             SET ELEMENTARY LOOP\nOPT44    STC   R0,FOR1(R2)             RESTORE FSN COUNT\n         IC    R2,FOR2(R2)\n         CL    R2,KF0                  ANY ENCLOSING FOR STMT ?\n         BE    OPT46                   NO\n         SH    R2,KH1                  GIVES CORRECT FSN\n         B     OPT42                   ADD UP ENCLOSING LOOP\n*\nOPT46    LA    R8,14(,R8)              UPDATE OPTAB PTR\nOPT5     LA    R6,14(,R6)              GET NEXT SUTAB ENTRY\n         C     R6,ZSUDEN               SUTAB END ?\n         BE    TERMIN                  YES\n         TM    10(R6),SUCM             ACTIVE ENTRY ?\n         BZ    OPT1                    YES\n         B     OPT5                    NO, GET NEXT ENTRY\n*\n*        SCAN FOR NEXT LVTAB GROUP\n*\nOPT6     LA    R5,4(,R5)               GET NEXT LVTAB ENTRY\n         CLC   0(1,R5),0(R4)           SAME GROUP ?\n         BE    OPT6                    YES\n         LR    R4,R5                   NO, SET LVTAB GROUP PTR\n         B     OPT1\n*\nOPT7     CLC   4(3,R6),KF0             FACTOR ZERO ?\n         BE    OPT72                   YES\nOPT71    SR    R2,R2                   ADDR FSTAB ENTRY\n         IC    R2,0(,R6)\n         LA    R2,FSTAB(R2)\n         OI    0(R2),X'80'             SET ELEMENTARY LOOP\n*\n*        HANDLE SUTAB CHAINING\n*\nOPT72    TM    10(R6),FIRSTM           ANY CHAINING ?\n         BZ    OPT5\n         LR    R7,R6                   INITIALIZE CHAIN SEARCH\nOPT8     LA    R7,14(,R7)              NEXT SUTAB ENTRY\n         CLC   11(3,R7),11(R6)         ENTRY IN CHAIN ?\n         BNE   OPT8                    NO\n         MVN   SUPOS(1),10(R7)         SUBSCRIPT NUMBER\n         MVN   *+7(1),10(R6)           SUBSCRIPT NUMBER\n         CLI   SUPOS,0                 SUBSCRIPT NUMBER EQUAL ?\n         BNE   OPT8                    NO\n         TM    10(R7),LASTM            LAST ENTRY IN CHAIN ?\n         BO    OPT9                    YES\n         NI    10(R7),OFFM             TURN OFF CHAIN BITS\n         OI    10(R7),FIRSTM           SET FIRST ENTRY BIT\n         B     OPT5\n*\nOPT9     NI    10(R7),OFFM             TURN OFF CHAIN BITS\n         B     OPT5\n*\nOPT10    BAL   R9,OTACHA               CHANGE OPTAB BUFFER\n         B     OPT4\n*\nTERMIN   C     R8,ZOTAFILL             ANY OPTAB ?\n         BNE   TERMINNO                YES\n         OI    COMPFLGS+2,NOPT         NO OPTAB PRESENT\n         B     TERM1\n*\nTERMINNO C     R8,ZOTMAX               END OF OPTAB BUFFER ?\n         BNE   TERMIN1                 NO\n         BAL   R9,OTACHA               CHANGE OUTPUT BUFFER\nTERMIN1  MVI   0(R8),X'FF'             INDICATE END OF SUTAB\n         BAL   R9,OTACHA               WRITE LAST OPTAB RECORD\n*\n         CHECK OWRITE                  CHECK LAST OPTAB RECORD\n*\n         L     R0,AUT3DCB              R0 -> SYSUT3 DCB\n*\n         CLOSE ((R0),REREAD),TYPE=T    POINT TO BEGINNING OF DATASET\n*\nTERM1    LH    R4,FSNMAX\n         SR    R3,R3\n         SR    R1,R1\nTERM12   LA    R1,1(,R1)\n         CLR   R1,R4                   ALL FOR STMT CHECKED ?\n         BH    TERM15                  YES\n         LA    R2,FOR2(R1)\n         CLC   KF0(1),0(R2)            ANY ENCLOSING LOOP ?\n         BE    TERM12                  NO\n         IC    R3,0(R2)                GET NO OF OPTAB ENTRIES\n         SR    R2,R2\n         IC    R2,FOR1-1(R3)           IN ENCLOSING LOOP\n         CL    R2,KF86                 > 85 ?\n         BL    TERM12                  NO\n         LA    R2,255                  MARK FOR SUCCEDING FS\n         STC   R2,FOR1(R1)             THAT THIS FS IS ELEMENT\n         LA    R2,FSTAB(R1)\n         OI    0(R2),X'80'             SET ELEMENTARY LOOP\n         B     TERM12\n*\nTERM15   L     R0,TABSIZE              LENGTH OF TABLE AREA\n         L     R1,TSTART\n*\n         FREEMAIN R,LV=(0),A=(1)\n*\nTERMIN2  TM    COMPFLGS,ERR            ERROR CONDITION ?\n         BO    TERMERR                 YES\n         B     IEX40001                SETUP INITIALIZATION FOR IEX50\n*\nTERMERR  XCTL  EP=IEX51ER2\n*\nNOSUTAB  OI    COMPFLGS+2,NOPT         SET NO SUBSCRIPT OPTIMIZATION\n         B     TERMIN2\n*\nNOSUTAB1 OI    COMPFLGS+2,NOPT         SET NO SUBSCRIPT OPTIMIZATION\n         B     TERM1\n*\nOTACHA   B     OTACHA2                 FIRST TIME SWITCH\n*\n         CHECK OWRITE\n*\nOTACHA1  L     R0,AUT3DCB              R0 -> SYSUT3 DCB\n         L     R2,ZOTAFILL             ADDR OF BUFFER TO WRITE\n         L     R3,OPTABS               SIZE OF OPTAB BUFFER\n*\n         WRITE OWRITE,SF,(R0),(R2),(R3)\n*\n         L     R8,ZOTAWRI              CHANGE OPTAB BUFFERS\n         MVC   ZOTAWRI(4),ZOTAFILL\n         ST    R8,ZOTAFILL\n         LR    R2,R8\n         A     R2,OPTABS               BUFFER END ADDR\n         ST    R2,ZOTMAX\n         BR    R9\n*\nOTACHA2  MVI   OTACHA+1,X'00'          SET OFF FIRST TIME SWITCH\n         B     OTACHA1\n*\n*        R11                           START ADDR OF INPUT AREA\n*        R10                           RECORD COUNT\n*        R9                            RECORD IDENTIFICATION\n*        R8                            RECORD LENGTH\n*        R7                            RETURN REGISTER\n*\nREAD     L     R1,AUT3DCB              R1 -> SYSUT3 DCB\n         MVI   SULTSTRT+3,X'01'        ADDR FIRST INPUT RECORD\n*\n         POINT (1),SULTSTRT\n*\nREAD1    L     R2,AUT3DCB              R2 -> SYSUT3 DCB\n*\n         READ  READR,SF,(R2),(R11),'S'\n*\n         CHECK READR\n*\n         C     R9,0(,R11)\n         BNE   READ1\n         MVC   0(4,R11),SAVETAB        RESTORE OVERLAYED PART\n         BCT   R10,READ2               MORE RECORDS TO READ ?\n         BR    R7                      NO\n*\nREAD2    AR    R11,R8                  UPDATE CURRENT PT2\n         MVC   SAVETAB(4),0(R11)\n         B     READ1\n*\n*        R11                           LENGTH OF TABLE ENTRY\n*        R10                           CURRENT PTR IN UNSORTED TABLE\n*        R9                            END OF UNSORTED TABLE\n*        R15                           RETURN REGISTER\n*        R10                           RELATIVE ADDR IN SORTED TAB\n*        R8                            PTR TO ACTUAL ADDR TAB ENTRY\n*                                      START ADDR OF SORTED TABLE\n*        R7                            PTR TO ACTUAL COUNT TAB ENTRY\n*        R3                            ADDR OF LAST COUNT TAB ENTRY\n*\nSORT     MVC   ZCOSTA(1),KF0           ZERO TABLES\n         MVC   ZCOSTA+1(254),ZCOSTA\n         MVC   ZCOSTA+255(255),ZCOSTA\n         MVC   ZADSTA(255),ZCOSTA\n         MVC   ZADSTA+255(255),ZCOSTA\n         L     R10,ZSTAD               CURRENT PTR\n*\nSORT1    CLI   0(R10),X'FF'            DELETED ENTRY ?\n         BE    SORT2                   YES\n         SR    R2,R2                   ISOLATE ACTUAL FSN\n         IC    R2,0(,R10)\n         AR    R2,R2                   FSN * 2\n         LH    R3,ZCOSTA(R2)           GET OLD COUNTER\n         LA    R3,1(,R3)               INCR\n         STH   R3,ZCOSTA(R2)           STORE NEW COUNTER\n*\nSORT2    AR    R10,R11                 ADDR NEXT ENTRY\n         CR    R10,R9                  END OF TABLE ?\n         BL    SORT1                   NO\n*\n*        BUILD ADDRESS TABLE\n*\n         LH    R2,FSNMAX               GET ADDR OF LAST COUNT ENTRY\n         AR    R2,R2\n         LA    R3,ZCOSTA(R2)           LAST ENTRY\n         SR    R10,R10                 RELATIVE ADDR IN NEW TABLE\n         LA    R7,ZCOSTA               CURRENT COUNT TABLE PTR\n         LA    R8,ZADSTA+2             CURRENT ADDR TABLE PTR\nSORT3    CR    R7,R3                   LAST ENTRY ?\n         BH    SORT4                   YES\n         LH    R1,0(,R7)               NUMBER OF ENTRIES\n         MR    R0,R11                  COMPUTE TABLE LENGTH\n         AR    R10,R1                  RELATIVE TABLE ADDR\n         STH   R10,0(,R8)              MAKE ENTRY IN ADDR TABLE\n         LA    R7,2(,R7)               ADDR NEXT ENTRY\n         LA    R8,2(,R8)               ADDR NEXT ENTRY\n         B     SORT3\n*\n*        BUILD SORTED TABLE\n*\nSORT4    L     R10,ZSTAD               START OF UNSORTED TABLE\n         L     R8,ZSORTSTA             START OF SORTED TABLE\n         LR    R2,R11                  INITIALIZE MOVE OF ENTRY\n         BCTR  R2,0\n         STC   R2,SORTM+1              STORE LEN IN MVC INSTRUCTION\nSORT5    CLI   0(R10),X'FF'            DELETED ENTRY ?\n         BE    SORT6                   YES\n         SR    R2,R2                   ISOLATE FSN\n         IC    R2,0(,R10)\n         AR    R2,R2                   FSN * 2\n         LH    R3,ZADSTA(R2)           GET RELATIVE ADDR\n         LR    R0,R3                   UPDATE RELATIVE ADDR\n         AR    R0,R11\n         STH   R0,ZADSTA(R2)\n         AR    R3,R8                   GET ADDR IN SORTED TABLE\nSORTM    MVC   0(0,R3),0(R10)          MOVE ENTRY\nSORT6    AR    R10,R11                 GET NEXT ENTRY\n         CR    R10,R9                  END OF TABLE ?\n         BNE   SORT5                   NO\n         BR    R15\n*\n         DC    0F'0'\nSUTYPE   DC    C'SUTB'                 SUTAB IDENTIFICATION\nLVTYPE   DC    C'LVTB'                 LVTAB IDENTIFICATION\nKF0      DC    F'0'\nKH8      DC    H'8'\nSUPOS    DC    X'00'\n         DC    0F'0'\nFOR1     DC    XL256'00'               FOR STMT COUNT AREA\nFOR2     DC    XL256'00'               ENCLOSING FS MARK AREA\nKF86     DC    F'86'                   MAX ENTRIES IN OPTAB\nFOR4     DC    3H'0'                   WORK AREA FOR GPTAB REC\nKH1      DC    H'1'\n*\n        TITLE 'IEX40001 - INITIALIZATION OF COMPILATION PHASE, ALGOL F'\n*\n*        CALCULATE AND RESERVE SPACE NEEDED\n*\nIEX40001 LA    R2,INERR1\n         ST    R2,ERET                 PROVIDE DIRECTORY RETURN ADDR\n         SR    R2,R2                   INIT LENGTH OF RES AREA\n         L     R3,SRCE1S               GET LENGTH OF 1ST SOURCE BUFFER\n         TM    COMPFLGS+2,SPIC         SOURCE PROGRAM IN STORAGE ?\n         BO    IN16                    YES\n         LR    R2,R3                   NO, OBTAIN A SECOND BUFFER\nIN16     TM    COMPFLGS+2,NOPT         ANY OPTAB ?\n         BO    IN17                    NO\n         L     R4,OPTABS               OBTAIN LENGTH OF OPTAB BUFFER\n         AR    R2,R4                   ADD TO TOTAL LENGTH\n         AR    R2,R4                   ADD LENGTH OF 2ND OPTAB BUFFER\nIN17     L     R6,OOSTACKS             OBTAIN LENGTH OF OPERATOR STACK\n         AR    R2,R6                   ADD TO TOTAL LENGTH\n         LH    R7,LLAT                 OBTAIN LENGTH OF LAT\n         AR    R2,R7                   ADD TO TOTAL LENGTH\n         ST    R2,FREEMSIZ             STORE LENGTH OF RESERVED AREA\n*\n         GETMAIN R,LV=(R2)             RESERVE AREA\n*\n         LA    R5,INERR2\n         ST    R5,ERET                 PROVIDE NEW DIR RETURN ADDR\n         ST    R1,FREEMADR             STORE ADDR OF RESERVED AREA\n*\n*        LOAD REGISTERS FOR REST OF PHASE\n*\n         L     R8,IBUF1\n         ST    R8,SOURCEB              SET FIRST BUFFER AS CURRENT\n         LR    R10,R1                  GET CORRECT REG FOR OPT ST ADDR\n         TM    COMPFLGS+2,SPIC         SOURCE PROGRAM IN STORAGE ?\n         BO    IN18                    YES\n         ST    R10,IBUF2               NO, STORE ADDR OF 2ND INPUT BUF\n         ST    R10,RSRCB               SECOND BUFFER = READ BUFFER\n         LA    R10,0(R3,R10)           GET ADDR OF NEXT RESERVED AREA\nIN18     TM    COMPFLGS+2,NOPT         ANY OPTAB ?\n         BO    IN19                    NO\n         ST    R10,OPBUF1              YES, STORE ADDR OF FIRST OPTBUF\n         ST    R10,AOPTABE             ADDR FIRST OPTAB ENTRY\n         ST    R10,OPBUFB              FIRST OPTBUF = CURRENT\n         LA    R10,0(R4,R10)           GET ADDR OF SECOND OPTAB BUFFER\n         ST    R10,OPBUF2              STORE        -''-\n         ST    R10,ROPTB               2ND OPTBUF = READ BUFFER\n         LA    R10,0(R4,R10)           GET ADDR OF OPERATOR STACK\nIN19     LA    R9,0(R6,R10)            GET ADDR OF LAT\n         ST    R9,LATAB                STORE IT\n         BCTR  R9,0                    GET ADDR OF OPERAND STACK\n         L     R6,PRPT                 PRPOINTER\n*\n*        INITIALIZE WORKAREA FOR REST OF PHASE\n*\n         TM    COMPFLGS+2,NOPT         ANY OPTAB ?\n         BZ    IN3A                    YES\n         LA    R4,MAXFSN\n         ST    R4,AOPTABE              NO, STORE ADDR OF MAX FS NUMBER\nIN3A     LA    R4,SUTABC-9\n         ST    R4,SUTABCA              INIT LAST USED SUTAB ENTRY\n         LA    R4,IOTAB\n         LA    R3,GPBN                 COMPUTE LENGTH OF AREA WITH 0\n         SR    R3,R4\n         STC   R3,IN3B+1               STORE IN MOVE INSTRUCTION\n         MVI   0(R4),0\nIN3B     MVC   1(0,R4),0(R4)           MOVE ZEROES\n         MVI   MAXFSN,X'FF'            INSERT MAX FS NUMBER\n         MVI   CII+1,X'07'\n         MVI   CIR+1,X'06'\n         MVI   CLEARDIS,X'F0'\n         MVI   ONEENTRY+1,X'08'        INSERT VALUES FOR LONG PREC\n         MVC   MAXOVERF(2),LONG\n         TM    COMPFLGS,LNG            LONG PRECISION ?\n         BO    IN3                     YES, BRANCH\n         MVI   ONEENTRY+1,X'04'        SHORT, CHANGE VALUES\n         MVI   PRECMASK,X'10'\n         MVC   MAXOVERF(2),SHORT\nIN3      MVI   GPBN+1,X'FF'\n         MVC   SEMCNT,KH0              ZERO SEMICOLON COUNTER\n*\n*        INITIALIZE OPERATOR STACK\n*\n         MVI   0(R10),X'25'            INSERT OPERATOR ALPHA\n*\n*        INITIALIZATION OF LABEL ADDRESS TAB\n*\n         L     R2,LATAB\n         MVI   0(R2),0                 ZERO BEGINNING OF LAT\n         MVC   1(LATBEG-1,R2),0(R2)\n         LA    1,15                    ZERO\n         LA    11,79(,R2)                   REST\nTSTZER   MVC   1(256,11),0(11)                   OF\n         LA    11,256(,11)                            LAT\n         BCT   1,TSTZER                                   FOR\n         MVC   1(176,11),0(11)                                 TEST\n         LA    R3,LATNR\nIN4      MVI   0(R2),X'80'             TURN ON FIRST BIT IN LAT ENTRY\n         LA    R2,4(,R2)               STEP ADDR\n         BCT   R3,IN4                  HANDLE NEXT ENTRY IF ANY\n*\n*        START READ IN OF SOURCE PROGRAM, IF NECESSARY\n*\n         TM    COMPFLGS+2,SPIC         SOURCE PROGRAM IN STORAGE ?\n         BZ    IN6                     NO, NO BRANCHES WILL BE TAKEN\n         OI    IN6+1,X'F0'             YES, ALL BRANCHES WILL BE TAKEN\n         OI    IN9+1,X'F0'\n         OI    IN14+1,X'F0'\n*\nIN6      NOP   IN22                    BRANCH IF SOURCE PROG IN CORE\n         L     R3,AUT2DCB              R3 -> SYSUT2 DCB\n*\n         READ  SRC1,SF,(3),(8)         READ FIRST SOURCE RECORD\n*\nIN22     BCTR  R8,0                    INIT SOURCE POINTER\n*\n*        CONSTRUCT PBTAB3\n*\n         LA    R2,PBTAB2               START ADDR OF PBTAB2 IN WORKAREA\n         LA    R5,PBTAB3               START ADDR OF PBTAB3 IN WORKAR\n         LH    R4,PBN                  GET NUMBER OF PRG BLOCKS\n         LA    R4,1(,R4)\nIN8      MVC   0(2,R5),0(R2)           MOVE ONE PBTAB2 ENTRY\n         MVC   2(2,R5),KH0             ZERO REST OF ENTRY\n         LA    R2,2(,R2)               STEP ADDRS\n         LA    R5,4(,R5)\n         BCT   R4,IN8                  MOVE NEXT IF NOT ALL MOVED\n*\n*        CHECK READ OF FIRST SOURCE RECORD IF NECESSARY\n*\nIN9      NOP   IN10                    BRANCH IF SOURCE PROG IN CORE\n*\n         CHECK SRC1\n*\nIN10     LA    R2,1                    INIT RECORD COUNT\n         STC   R2,NUMBBL               STORE IT\n*\n*        START READING OF OPTAB\n*\n         TM    COMPFLGS+2,NOPT         OPTAB EMPTY ?\n         BO    IN14                    YES, BYPASS READING\n         LA    R2,IN14\n         ST    R2,EODUT3               GIVE ADDR OF EOD RTN TO DIR\n         L     R2,OPBUF1               GET ADDR OF FIRST BUFFER\n         L     R4,AUT3DCB              R4 -> SYSUT3 DCB\n*\nIN12     READ  OPTB1,SF,(4),(2),'S'    READ FIRST RECORD\n*\n         CHECK OPTB1\n*\nIN13     NOP   IN14                    BRANCH AFTER SECOND CHECK\n         L     R2,OPBUF2               GET ADDR OF SECOND BUFFER\n         OI    IN13+1,X'F0'\n         B     IN12                    READ SECOND RECORD\n*\n*        READ SECOND SOURCE RECORD IF ANY\n*\nIN14     NOP   IN15                    BRANCH IF SOURCE PROGRAM IN CORE\n         LA    R2,IN15\n         ST    R2,EODUT2               GIVE ADDR OF EOD RTN TO DIR\n         L     R2,IBUF2                GET ADDR OF 2ND BUFFER\n*\n         READ  SRC2,SF,(3),(2)         READ 2ND RECORD\n*\n         CHECK SRC2\n*\nIN15     NI    COMPFLGS+2,255-NOSC     SET SEMICOLON COUNTER VALID FLAG\n*\n*        XCTL TO NEXT LOAD MODULE\n*\n         XCTL  EP=IEX50000\n*\n*        DIRECTORY RETURN BEFORE GETMAIN\n*\nINERR1   XCTL  EP=IEX51ER2\n*\n*        DIRECTORY RETURN AFTER GETMAIN\n*\nINERR2   XCTL  EP=IEX51ER1\n*\n*        CONSTANTS\n*\nLLAT     DC    H'4096'                 LENGTH OF LABEL ADDR TABLE\nSHORT    DC    H'4092'                 TO CHECK OBJ TIME STACK OVFLOW\nLONG     DC    H'4088'                              -''-\n*\n         LTORG\n*\nWORKAREA DSECT\n*\n         COPY  WORKAREA\n*\n         ORG   SYSUT1\n*\nFSNMAX   DS    H\nLVCOUNT  DS    H\nSUCOUNT  DS    H\nZLEVEN   DS    F\nZSUTEN   DS    F\nZCOSTA   DS    255H                    SORT COUNT TABLE\nZADSTA   DS    255H                    SORT ADDR TABLE\nTSTART   DS    F                       START OF TABLE AREA\nSAVETAB  DS    F                       AREA TO SAVE TABLE END\nZSTAD    DS    F                       START ADDR OF UNSORTED TABLE\nZSORTSTA DS    F                       START ADDR OF SORTED TABLE\nZSUDAD   DS    F                       START OF SORTED SUTAB\nZSUDEN   DS    F                       END ADDR OF SORTED SUTAB\nZLESTA   DS    F                       START ADDR OF SORTED LUTAB\nZOTAFILL DS    F                       OPTAB WORK BUFFER ADDR\nZOTAWRI  DS    F                       OPTAB WRITE BUFFER ADDR\nZOTMAX   DS    F                       END OF OUTPUT BUFFER IN USE\nTABSIZE  DS    F                       SIZE OF TABLE AREA\n*\n*        AREA USED BY COMPILATION PHASE\n*\n         ORG   SYSUT1\n*\nRETADR   DS    17F                     SAVE AREA\nPLACE14  DS    F                          -''-\nRUTI     DS    9F                      GPR CONTROL\nRUTR     DS    4F                      FLREG CONTROL\nGPROLN   DS    H                       LABEL NR OF OBJ PRG ENTRY POINT\nKONSUM   DS    H                       WORKPLACE\nWORKPL   DS    F                       WORKPLACE\nIBUF1    EQU   SRCE1ADD                ADDR OF FIRST SOURCE BUFFER\nIBUF2    DS    A                         -''  SECOND    -''-\nSOURCEB  DS    A                         -''  CURRENT   -''-\nRSRCB    DS    A                         -''  READ      -''-\nOPBUF1   DS    A                       ADDR OF FIRST OPTAB BUFFER\nOPBUF2   DS    A                         -''-  SECOND    -''-\nOPBUFB   DS    A                         -''-  CURRENT   -''-\nROPTB    DS    A                         -''-  READ      -''-\nAOPTABE  DS    A                       ADDR OF CURRENT OPTAB ENTRY\nLATAB    DS    A                       ADDR OF LABEL ADDR TABLE\nAPBTAB4  EQU   LATAB                   ADDR OF PBTAB4\nSUTABCA  DS    A                       ADDR OF LAST USED SUTAB ENTRY\nSTRETURN DS    F                       RETURN ADDR\nFREEMADR DS    A                       ADDR FOR FREEMAIN IN 50000\nFREEMSIZ DS    F                       SIZE          -''-\n*\nPBTAB3   DS    1024C                   PROGRAM BLOCK TABLE, 3RD VERS\n*\nIOTAB    DC    18X'00'                 LIST OF DATA SETS\nCII      DC    H'0'                    REGISTER CONTROL\nCIR      DC    H'0'                          -''-\nRII      DC    H'0'                          -''-\nRIR      DC    H'0'                          -''-\nOPDPBN   DC    H'0'                    PROGRAM BLOCK NR (BYTE 2 OF OPD\nOPDADR   DC    H'0'                    BYTES 3 AND 4 OF OPERAND\nOPDLN    DC    H'0'                    LABEL NUMBER TIMES FOUR\nKH0      DC    H'0'                    ZEROES\nCFSN     DC    X'00'                   CURRENT FS NUMBER\nMAXFSN   DC    X'FF'                   MAX FS NUMBER\nCLEARDIS DC    X'F000'                 FOR CLEARING OF DISPLACEM PART\nONEENTRY DC    H'4'                    SHORT, FOR INCR OF OT STACK PTR\n         ORG   ONEENTRY\n         DC    H'8'                    LONG            -''-\nPRECMASK DC    X'10'                   SHORT, TO MODIFY INSTRUCTIONS\n         ORG   PRECMASK\n         DC    X'00'                   LONG            -''-\nNUMBBL   DC    X'00'                   RECORD COUNTER\n         DS    H\nSPBNST   DC    H'0'                    CURRENT PBN\n         DS    H                                   AND DISPLACEMENT\nGPBN     DC    H'255'                  GLOBAL DSA CONTROL\nMAXOVERF DC    H'4092'                 SHORT, TO CHECK OT STACK OVERFL\n         ORG   MAXOVERF\n         DC    H'4088'                 LONG            -''-\nHALFW    DS    H                       WORKPLACE\nUSPEI2   DS    H                       FOR ARRAY DECLA-\nUSPEI4   DS    H                                       RATION HANDLING\nWPLACE   DS    H                       FOR INSTRUCTION GENERATION\nXPLACE   DS    H\nYPLACE   DS    H\nUPLACE   DS    H\nVPLACE   DS    C                                   -''-\nSTRDNAME DS    5C                      TO STORE OPERAND\nCBVTAB   DS    48C                     CALLED-BY-VALUE TABLE\nSUTABC   DS    768C                    FOR SUBSCRIPT OPTIMIZATION\n         ORG   SUTABC\nDSTAB    DS    608C                    DATA SET TABLE\n*\n*        CHARACTER EQUATES\n*\n         IEXCHAR\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END   IEX40000\n./ ADD NAME=IEX50    0201-12230-12230-1200-01946-01946-00000-LEVEL\nX50      TITLE 'IEX50 - COMPILATION PHASE, ALGOL F'\n*\n*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER\n*\n*        FUNCTION/OPERATION -\n*        THIS MODULE PERFORMS THE REAL TRANSLATION OF THE SOURCE\n*        PROGRAM INTO SYSTEM/360 INSTRUCTIONS. THE SOURCE\n*        PROGRAM IS AT MODIFICATION LEVEL 2 AND CONSISTS OF A\n*        SEQUENCE OF ONE BYTE OPERATORS AND FIVE BYTE OPERANDS,\n*        WHICH IS SCANNED SEQUENTIALLY. THE STATUS OF RECOGNITION\n*        OF THE SOURCE PROGRAM IS DESCRIBED BY -\n*        1. A SEQUENCE OF CONTEXTS (SEE BELOW)\n*        2. A SEQUENCE OF STACKED OPERATORS (THE OPERATOR STACK)\n*\n*        THE ACTION OF THE COMPILER IS DETERMINED BY THE\n*        OPERATOR PAIR STACK-SOURCE OPERATOR AND THE CURRENT\n*        CONTEXT. THE OPERATOR PAIR DETERMINES AN ELEMENT IN A\n*        DECISION MATRIX, WHICH IS DETERMINED BY THE CONTEXT. THE\n*        MATRIX ELEMENTS REPRESENT ADDRESSES OF THE COMPILER\n*        PROGRAMS, WHICH PERFORM THE ACTIONS REQUESTED BY ALL\n*        POSSIBLE OPERATOR PAIRS.\n*\n*        THERE ARE THREE CONTEXTS, PROGRAM, STATEMENT, AND\n*        EXPRESSION CONTEXT, AND THE CURRENT CONTEXT IS INDICATED\n*        BY A REGISTER. SWITCHING ING FROM ONE CONTEXT TO\n*        ANOTHER IS IN MOST CASES DETERMINED BY THE STACK-SOURCE\n*        OPERATOR PAIR, IE THE COMPILER PROGRAM ACTIVATED JUST\n*        PERFORMS THE CHANGE OF CONTEXT, BUT IN A FEW CASES THE\n*        SOURCE OPERATOR ALONE DETERMINES THE NEW CONTEXT. IN\n*        THIS LATTER CASE THE OPERATOR IS STACKED TOGETHER WITH A\n*        CONTEXT OPERATOR, INDICATING THE PRECEDING CONTEXT.\n*\n*        BESIDES THE COMPILER PROGRAMS THERE ARE OTHER ROUTINES\n*        PROVIDING DIFFERENT SERVICES. THE MOST IMPORTANT ARE\n*        (THOSE MARKED WITH * ARE USED AS SUBROUTINES BY THE\n*        COMPILER PROGRAMS) -\n*\n*        SUBSTART - SCAN TO NEXT OPERATOR IN SOURCE PROGRAM\n*        COMP     - CHOOSE COMPILER PROGRAM AND BRANCH\n*        JBUFFER  - READ A NEW SOURCE PROGRAM RECORD\n*       *NXTOPT   - GET NEXT ENTRY OF OPTAB\n*       *SERR     - GENERATE AN ERROR PATTERN\n*        CPEND    - NORMAL TERMINATION\n*        CPERRI   - ABNORMAL TERMINATION\n*       *GENERATE - GENERATE TXT AND RLD RECORDS\n*\n*        A COMPILER PROGRAM IS ALWAYS FOLLOWED BY SUBSTART OR COMP\n*        OR A BRANCH TO ANOTHER COMPILER PROGRAM\n*\n*        THE MODULE CONSISTS OF SEVEN CONTROL SECTIONS\n*        IEX50000 - INITIALIZATION AND SUBROUTINES\n*        IEX50001 - DECISION MATRIXES\n*        IEX50002 - COMPILER PROGRAMS HANDLING FOR STATEMENTS\n*                   AND SUBSCRIPT OPTIMIZATION\n*        IEX50003 - COMPILER PROGRAMS HANDLING BEGIN AND END OF\n*                   COMPOUND STATEMENTS AND BLOCKS, PROCEDURE\n*                   DECLARATIONS, ARRAY DECLARATIONS, SWITCH\n*                   DECLARATIONS, GOTO STATEMENTS, SUBSCRIPTED\n*                   VARIABLES AND SWITCH DESIGNATORS, SEMICOLON\n*                   COUNTER\n*        IEX50004 - COMPILER PROGRAMS HANDLING ASSIGNMENTS,\n*                   PROCEDURE CALLS, STANDARD PROCEDURE CALLS\n*        IEX50005 - COMPILER PROGRAMS HANDLING ERRONEOUS CASES,\n*                   BOOLEAN OPERATIONS, ARITHMETIC MINUS, IF,\n*                   THEN, ELSE\n*        IEX50006 - COMPILER PROGRAM HANDLING ARITHMETICAL\n*                   OPERATIONS\n*\n*        ENTRY POINT -\n*        IEX50000 - COMPILATION PHASE XCTL EP=IEX50\n*        THE MODULE IS ENTERED FROM IEX40\n*\n*        INPUT -\n*        THE SOURCE PROGRAM IS READ FROM SYSUT2\n*        OPTAB IS READ FROM SYSUT3\n*\n*        OUTPUT -\n*\n*        THE MAIN PART OF THE OBJECT MODULE IS OUTPUT TO SYSLIN\n*        AND/ OR SYSPUNCH IF THE OPTIONS 'LOAD' AND/OR 'DECK' ARE\n*        SPECIFIED\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        EXIT - NORMAL -\n*        IF NO TERMINATING ERROR HAS OCCURRED, CONTROL IS GIVEN\n*        TO THE TERMINATING MODULE BY MEANS OF XCTL EP=IEX51000\n*\n*        EXIT - ERROR -\n*        IF A TERMINATING ERROR HAS OCCURED, CONTROL IS GIVEN TO\n*        THE TERMINATING MODULE BY MEANS OF XCTL EP=IEX51ER1\n*\n*        TABLES/WORKAREAS -\n*        SCPTAB  - COMPILER PROGRAM ADDR TABLE USED BY ROUTINE\n*                  COMP\n*        TXTT    - INFORMATION FOR TXT RECORDS USED BY ROUTINE\n*                  GENERATE\n*        RLDT    - INFORMATION FOR RLD RECORDS USED BY ROUTINE\n*                  GENERATE\n*        DECAREA - DECISION MATRIXES USED BY ROUTINE COMP\n*\n*        THE PART OF COMMON WORKAREA STARTING AT SYSUT1 IS\n*        INITIALIZED BY THE PRECEDING LOAD MODULE AND USED BY\n*        THIS AND THE NEXT LOAD MODULE\n*\n*        THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN\n*        CONNECTION WITH THE OTHER MODULES OF THE ALGOL COMPILER\n*        IN PARTICULAR IT REQUIRES THE COMMON WORKAREA\n*\nIEX50000 CSECT\n*\n*        R6                            REL ADDR IN OBJ PROGRAM\n*        R7                            DISP IN OBJECT TIME STACK\n*        R8                            SOURCE PROGRAM POINTER\n*        R9                            OPERAND STACK POINTER\n*        R10                           OPERATOR STACK POINTER\n*        R11                           INDICATES CURRENT CONTEXT\n*        R12                           BASE ADDR OF COMP PROGRAMS\n*\n*        OBJECT TIME REGISTER DEFINITIONS\n*\nFPR0     EQU   0                       *\nFPR2     EQU   2                       *\nGPRA     EQU   3                       *   VARIABLE USE\nGPRB     EQU   5                       *\nGPRC     EQU   6                       *\nADR      EQU   8                       FOR TRANSFER OF ADDRS\nCDSA     EQU   10                      ADDRS CURRENT DSA\nGDSA     EQU   9                       ADDRS GLOBAL DSA\nPBT      EQU   11                      ADDRS PROGRAM BLOCK TABLE\nLAT      EQU   12                      ADDRS LABEL ADDR TABLE (LAT)\nFSA      EQU   13                      ADDRS FIXED STORAGE AREA\nENTRY    EQU   15                      ENTRY PT OF LIBRARY SUBRTNS\nBRR      EQU   15                      LINK REGISTER\n*\n*        INITIALIZATION\n*\n*        THIS ROUTINE PERFORMS THE REMAINING INITIALIZATION\n*        THE MAIN PART IS MADE IN IEX40001\n*\n         IEXENTRY 'IEX50000 LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IEX50000,R15            USE ENTRY POINT REG AS BASE\n         USING WORKAREA,R13\n         LA    R5,SUBSTART             LOAD BASE REG FOR SUBSTART\n         DROP  R15\n         USING SUBSTART,R5\n         LA    R4,CPERR1               PROVIDE DIRECTORY\n         ST    R4,ERET                 RETURN ADDR\n         L     R11,DECAADD             LOAD ADDR OF CCT\n         LA    R4,JB3                  PROVIDE\n         ST    R4,EODUT2               EOD ADDR\n         LA    R4,NX4                  FOR UT2\n         ST    R4,EODUT3               AND UT3\n         CNOP  0,8\n*\n*        START OF SUBROUTINE POOL\n*\n*        SCAN SOURCE INPUT TO NEXT OPERATOR\n*\nSUBSTART NI    COMPFLGS,255-OPERAND    OPERAND FLAG OFF\nABC1     CLI   1(R8),XFZETA            TEST SOURCE\n         BL    ABD3                    OPERATOR\n         BH    ABD1                    OPERAND\n         BAL   R4,JBUFFER              BUFFER CHANGE\n         B     ABC1                    CONTINUE\n*\nABD3     LA    R8,1(,R8)               INCR SOURCE PTR\n         B     COMP                    CHOOSE CP\n*\nABD1     OI    COMPFLGS,OPERAND        OPERAND FLAG ON\n         SH    R9,KH5                  SOURCE OPERAND\n         CR    R10,R9                  TO\n         BNL   STACKOFL                STACK\n         MVC   0(5,R9),1(R8)\n         LA    R8,5(,R8)               SOURCE REG INCREASE\n         B     ABC1                    CONTINUE\n*\n*        AN OPERAND IS NOT ALLOWED IN SOURCE\n*\nSPECTEST CLI   1(R8),XFZETA            SPECIAL TEST\n         BL    ABD3                    OPERATOR\n         BH    ABD5                    OPERAND\n         BAL   R4,JBUFFER              BUFFER CHANGE\n         B     SPECTEST\n*\nABD5     LA    R8,6(R8)                SOURCE REG INCREASE\n         BAL   R4,SERR3\nERROR    DC    H'191'\n*\n         BCTR  R8,0                    SOURCE PTR MINUS ONE\n         B     SPECTEST\n*\n*        CHOOSE CP PROGRAM\n*\nCOMP     SR    R1,R1\n         LR    R2,R1\n         IC    R1,0(,R8)               FETCH SOURCE OPERATOR\n         IC    R1,0(R1,R11)            COLUMN VECTOR\n         IC    R2,0(,R10)              FETCH STACK OPERATOR\n         IC    R2,50(R2,R11)           ROW VECTOR\n         AR    R1,R2\n         IC    R1,100(R1,R11)\n         SLL   R1,2(0)                 COMPILER PROGRAM FROM MATRIX\n         L     R12,SCPTAB(R1)          FIND BASE ADDR\n         BR    R12                     BRANCH TO COMPILER PROGRAM\n*\n***********************************************************************\n*\n*        JBUFFER - READ INPUT BUFFER\n*\n***********************************************************************\n*\n* CALL   BAL   R4,JBUFFER              (FROM SUBSTART)\n*        BAL   R4,JBUFFER              (FROM COMPILER PROGRAMS)\n*\n*        REGISTER DEFINITIONS\n*\n*        R3                            SYSUT2 DCB\n*        R2                            ADDR OF CURRENT BUFFER\n*        R8                            ADDR OF CURRENT INPUT BUFFER\n*\nJBUFFER  L     R3,AUT2DCB              R2 -> SYSUT2 DCB\n         L     R2,SOURCEB              GET ADDR OF CURRENT BUFFER\nJB1      B     JB2                     NO CHECK FIRST TIME\n*\n         CHECK SRCECO                  CHECK PREVIOUS READ\n*\nJB2      READ  SRCECO,SF,(R3),(R2)\n*\nJB3      L     R8,RSRCB                GET ADDR OF OLD READ BUFFER\n         ST    R2,RSRCB                CHANGE ADDRS\n         ST    R8,SOURCEB\n         BCTR  R8,0                    GET START ADDR - 1\n         IC    R3,NUMBBL               STEP\n         LA    R3,1(,R3)                    RECORD\n         STC   R3,NUMBBL                           COUNTER\n         MVI   JB1+1,X'00'             CHANGE BRANCH CONDITION\n         BR    R4                      RETURN\n*\n***********************************************************************\n*\n*        NXTOPT - ACQUIRES NEXT ENTRY OF OPTAB\n*\n***********************************************************************\n*\n* CALL   BAL   R4,NXTOPT\n*\nNXTOPT   L     R2,OPBUFB               GET ADDR OF CURRENT BUFFER\n         L     R3,OPREL                GET REL ADDR OF NEW ENTRY\n         LA    R3,14(,R3)\n         C     R3,OPTABS               A NEW BUFFER REQUIRED ?\n         BNL   NX1                     YES\n         AR    R2,R3                   NO, STORE\n         ST    R2,AOPTABE              ADDR OF NEW ENTRY\n         B     NX3\n*\nNX1      B     NX2                     NO CHECK FIRST TIME\n*\n         CHECK OPTCO                   CHECK PREVIOUS READ\n*\nNX2      L     R3,AUT3DCB              R3 -> SYSUT3 DCB\n*\n         READ  OPTCO,SF,(R3),(R2),'S'  READ OPTAB RECORD\n*\n         MVI   NX1+1,X'00'             CHANGE BRANCH CONDITION\nNX4      L     R1,ROPTB                GET ADDR OF OLD READ BUFFER\n         ST    R1,OPBUFB               CHANGE\n         ST    R2,ROPTB                       ADDRS\n         ST    R1,AOPTABE              STORE\n         SR    R3,R3                         ADDRS OF\nNX3      ST    R3,OPREL                                   NEW ENTRY\n         BR    R4                      RETURN\n*\nOPREL    DC    F'0'                    REL ADDR IN CURRENT BUFFER\n*\n*        CONSTANTS LOCATED IN SUBROUTINE POOL\n*\nKH2      DC    H'2'\nKH4      DC    H'4'\nKH5      DC    H'5'\nKH8      DC    H'8'\nKH9      DC    H'9'\nKH10     DC    H'10'\nKH15     DC    H'15'\nKH20     DC    H'20'\nKH290    DC    H'290'\nKH324    DC    H'324'\nKH614    DC    H'614'\nAPI      DC    X'91FF01000000'\n*\nTYPETEST DC    F'3'\nSWVAL    DC    H'0'\nSWREL    DC    H'0'\nGREGN    DC    H'0'\n         DC    0F'0'\nDECAADD  DC    A(DECAREA)               ADDR OF DECISION AREA\n*                                       ADDR OF PROG CONTEXT COL VECTOR\nHEXFFF   DC    X'00000FFF'\nSTC      DC    A(ADRSTC)                ADDR OF STMT CONTEXT COL VECTOR\nEXC      DC    A(ADREXC)                ADDR OF EXPR CONTEXT COL VECTOR\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM ADDR TABLE\n*\n***********************************************************************\n*\n         DC    0F'0'\nSCPTAB   DC    A(CP0,CP1,CP84,CP3)\n         DC    A(CP4,CP84,CP6,CP7)\n         DC    A(CP8,CP84,CP84,CP84)\n         DC    A(CP12,CP84,CP84,CP84)\n         DC    A(CP16,CP17,CP18,CP19)\n         DC    A(CP20,CP21,CP22,CP23)\n         DC    A(CP24,CP25,CP26,CP27)\n         DC    A(CP28,CP29,CP30,CP31)\n         DC    A(CP84,CP33,CP34,CP84)\n         DC    A(CP36,CP84,CP38,CP84)\n         DC    A(CP40,CP41,CP84,CP43)\n         DC    A(CP84,CP45,CP84,CP47)\n         DC    A(CP84,CP49,CP84,CP51)\n         DC    A(CP52,CP84,CP54,CP84)\n         DC    A(CP56,CP57,CP84,CP59)\n         DC    A(CP84,CP61,CP62,CP63)\n         DC    A(CP64,CP65,CP66,CP67)\n         DC    A(CP68,CP69,CP70,CP71)\n         DC    A(CP72,CP73,CP74,CP75)\n         DC    A(CP76,CP77,CP78,CP79)\n         DC    A(CP80,CP81,CP84,CP83)\n         DC    A(CP84,CP85,CP86,CP87)\n*\n*        NON EXISTANT COMPILER PROGRAMS\n*\n*        CP2,  CP5,  CP9,  CP10, CP11, CP13, CP14, CP15, CP32,\n*        CP35, CP37, CP39, CP42, CP44, CP46, CP48, CP50, CP53,\n*        CP55, CP58, CP60, CP82\n*\n***********************************************************************\n*\n*        ERROR PATTERN GENERATION\n*\n***********************************************************************\n*\n* CALL   BAL   R4,SERRX                X=1, 2, 3, 4, SP\n*        DC    H'N'                    N=MSG NUMBER\n*\n*        ENTRY BOTH OPERATORS\n*\nSERR4    LA    R3,2\n         LA    R2,6                     GET LENGTH OF ENTRY\n         B     ER2\n*\n*        ENTRY STACK OPERATOR\n*\nSERR2    LA    R3,3\n         B     ER1\n*\n*        ENTRY SOURCE OPERATOR\n*\nSERR3    LA    R3,1\nER1      LA    R2,5                    GET LENGTH OF ENTRY\nER2      L     R15,NEXTERR             GET ADDR OF POOL ENTRY\n         STC   R2,0(,R15)              INSERT LENGTH OF ENTRY\n         LA    R2,4                    SET POINTER FOR OPERATOR INSERT\n         BCT   R3,ER4                  BRANCH IF STACK OR BOTH\n*\nER3      MVC   EP212+3(1),0(R8)        GET SOURCE OP\n         OI    EP212+3,X'80'           PUT A TAG\n         IC    R1,EP212+3              INSERT SOURCE OPERATOR\n         B     ER5\n*\nER4      IC    R1,0(,R10)              FETCH STACK OPERATOR\nER5      STC   R1,0(R2,R15)            INSERT OPERATOR\n         LA    R2,1(,R2)               INCREASE POINTER\n         BCT   R3,ER6                  STACK OR SOURCE, BRANCH\n         B     ER3                     BOTH\n*\n*        SPECIAL ENTRY FOR MSG 214\n*\nSERRSP   L     R15,NEXTERR             GET ADDR OF POOL ENTRY\n         LH    R3,SPBNST               GET CURRENT PBN\n         CVD   R3,ERDOUBLE             BINARY\n         UNPK  ERDOUBLE(3),ERDOUBLE+6(2)       TO\n         MVZ   ERDOUBLE+2(1),ERDOUBLE              CHARACTER\n         MVC   4(3,R15),ERDOUBLE       MOVE TO ERROR PATTERN\n         LA    R2,7                    SET LENGTH OF ENTRY\n         STC   R2,0(,R15)\n         B     ER6\n*\n*        ENTRY NO OPERATOR\n*\nSERR1    L     R15,NEXTERR\n         LA    R2,4                    INSERT LENGTH OF ENTRY\n         STC   R2,0(,R15)\nER6      MVC   2(2,R15),SEMCNT         INSERT SEMICOLON COUNTER\n         IC    R3,1(,R4)               INSERT ERROR NUMBER\n         STC   R3,1(,R15)\n         LA    R15,0(R2,R15)           UPDATE PTR TO NEXT ENTRY\n         ST    R15,NEXTERR\n         C     R15,ENDPOOL             POOL FULL ?\n         BNH   ER7                     NO\n         MVC   EP212+2(2),SEMCNT       YES, MOVE PATTERN FOR M212\n         MVC   0(4,R15),EP212\n         LA    R15,4(0,R15)            UPDATE PTR TO NEXT ENTRY\n         ST    R15,NEXTERR\n         B     CPERR1                  GOTO TERMINATION\n*\nER7      OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE\n         LA    R3,2                    STEP RETURN ADDR\n         AR    R4,R3\n         BR    R4                      R4 TO CALLER\n*\nEP212    DC    X'04D40000'             ERROR PATTERN FOR MSG 212\nERDOUBLE DC    D'0'\n*\n*        OPERAND/OPERATOR STACK OVERFLOW\n*\n* CALL   B STACKOFL\n*\nSTACKOFL BAL   R4,SERR1\n         DC    H'186'\n*\n         B     CPERR1\n*\n*        NORMAL TERMINATION\n*\nCPEND    TM    COMPFLGS+2,SPIC         SOURCE IN STORE ?\n         BO    CPEND1                  YES\n         BAL   R4,JBUFFER              NO, CHECK LAST READ\nCPEND1   TM    NX1+1,X'F0'             OPTAB READ IN IEX50 ?\n         BO    CPEND2                  NO\n         BAL   R4,NXTOPT               NO, CHECK LAST READ\n*\nCPEND2   XCTL  EP=IEX51000             XCTL TO NEXT MODULE\n*\n*        DIRECTORY RETURN ADDR\n*\nCPERR1   TM    JB1+1,X'F0'             READ TO INPUT BUFFERS\n         BO    CPERR10                 NO\n*\n         CHECK SRCECO                  CHECK LAST READ\n*\nCPERR10  TM    NX1+1,X'F0'             OPTAB READ\n         BO    CPERR11                 NO\n*\n         CHECK OPTCO                   CHECK LAST READ\n*\nCPERR11  XCTL  EP=IEX51ER1             ERROR MSG EDITING AND TERM\n*\n         DC    0H'0'\n*\n***********************************************************************\n*\n*        CONVERSION - INTEGER TO REAL\n*\n***********************************************************************\n*\n*        GENERATES CALL OF CONVERSION ROUTINE FROM INTEGER TO\n*        REAL AFTER LOCATING THE OPERAND\n*        RESERVES ONE OBJECT STACK TIME ENTRY\n*        SETS RIR\n*        INTRODUCES OPERAND ADDRS INTO RUTR\n*        ADJUSTS OPERAND\n*\n* CALL   BAL   R4,TRINRE\n*\nTRINRE   ST    R4,RETADR               STORE RETURN ADDR\n         LA    R4,HQF21\n         BAL   R3,ROUTIN15\n         SR    R1,R1\n         IC    R1,3(R9)                PREPARE INSTRUCTION\n         SRL   R1,4\n         LA    R2,1\n         SLL   R2,0(R1)\n         STC   R2,HQD2+1\n         XI    HQD2+1,X'FF'\nHQD2     NI    RII+1,X'00'\n         BAL   R4,ROUTINE8             RELILO\n         MVN   HQG1+1(1),VPLACE\n         BAL   R2,GENTXT2\nHQG1     LR    R14,0                   ***GENERATE***\nHQH1     TM    RIR+1,X'01'             FPRO FREE ?\n         BZ    HQJ1                    YES, BRANCH\n         BAL   R4,ROUTIN14             STFPR0\nHQJ1     TM    RII,X'01'               ADR FREE ?\n         BZ    HQJ11\n         BAL   R4,ROUTIN10\nHQJ11    BAL   R2,GENTXT4              CALL CONVERSION ROUTINE\n*        BAL   ADR,CNVIRD(0,FSA)       ***GENERATE***\n         BAL   R8,X'120'(,13)          ***NEW GENERATED ***\n         OI    0(R9),X'80'             ADJUST R9 ENTRY\n         NI    0(R9),X'9F'\n         OI    1(R9),X'32'\n         NI    1(R9),X'FE'\n         MVC   2(1,R9),SPBNST+1\n         AH    R7,ONEENTRY             INCR OF 4(SHORT) OR 8(LONG)\n         STH   R7,WORKPL\n         MVC   3(2,R9),WORKPL          INTRODUCE STACK ADDR\n         ST    R9,RUTR                 INTRODUCE R9 ADDR IN RUTR\n         OI    RIR+1,X'01'             SET RIR TO ONE\n         MVI   CIR+1,0                 CIR=0\n         L     R4,RETADR               LOAD RETURN ADDR\n         BR    R4\n*\nHQF21    MVN   HQG2+1(1),VPLACE        PREPARE INSTRUCTION\n         MVC   HQG2+2(2),WPLACE\n         BAL   R2,GENTXT4\nHQG2     L     R14,0(0,0)              ***GENERATE***\n         B     HQH1\n*\n***********************************************************************\n*\n*        CONVERSION - REAL TO INTEGER\n*\n***********************************************************************\n*\n*        SUBROUTINE TO GENERATE CODE TO CALL REAL TO INTEGER\n*        CONVERSION ROUTINE\n*\n* CALL   BAL   R4,TRREIN\n*\n*        AT OBJECT TIME THE INTEGER VALUE IS IN R14 AFTER CONVERSION\n*\n*        BIT PATTERNS\n*\nOBJSTM   EQU   X'C0'                   OBJECT STACK MASK\nRADRFREM EQU   X'01'                   REG ADDR FREE MASK\nFPROOCM  EQU   X'01'                   FPR0 MASK\nOPDVALUM EQU   X'20'                   VALUE MASK\nOPDREGM  EQU   X'40'                   REGISTER MASK\n*\nTRREIN   ST    R4,SAVTRREI             SAVE RETURN ADDR\n         TM    RIR+1,FPROOCM           FPR0 OCCUPIED ?\n         BZ    TRREIN1                 NO\n         C     R9,RUTR                 OPERAND IN FPR0\n         BE    TRREIN8                 YES, RELEASE FPR0\n         BAL   R4,ROUTIN14             STORE FPR0\n         NI    RIR+1,255-FPROOCM       MARK FPR0 FREE\nTRREIN1  LA    R3,TRREIN4              ADDR IF VALUE IN REG\n         BAL   R4,ROUTIN15             FIND DISPL AND REG\nTRREIN2  MVN   TRREIN3+1(1),VPLACE     INSERT REGISTER AND\n         MVC   TRREIN3+2(2),WPLACE     DISPLACEMENT IN LOAD INSTRUCTION\n         BAL   R2,GENTXTP4             GENERATE A LOAD FPR0\nTRREIN3  LD    FPR0,0(0,0)             *INSTRUCTION, FLOATING POINT *\nTRREIN6  TM    RII,RADRFREM            REG ADDR FREE\n         BZ    TRREIN9                 YES\n         BAL   R4,ROUTIN10             STORE ADDR AND RETURN\n         NI    RII,255-RADRFREM\nTRREIN9  BAL   R2,GENTXT4              GENERATE A CALL TO THE REAL-\n*        BAL   ADR,CNVRDI(FSA,0)       *INTEGER CONVERSION ROUTINE\n         BAL   8,X'14C'(13)            ***NEW GENERATED CODE***\n         L     R4,SAVTRREI\n         BR    R4\n*\nTRREIN4  MVN   TRREIN5+1(1),VPLACE\n         BAL   R2,GENTXTP2             GENERATE A LOAD  FPR0\nTRREIN5  LDR   FPR0,0                  *INSTRUCTION FLOATING POINT *\nTRREIN8  BAL   R4,ROUTIN12             RELEASE REG CONTAINING OPD\n         B     TRREIN6\n*\nSAVTRREI DC    F'0'                    SAVE AREA FOR RETURN\n*\n***********************************************************************\n*\n*        S U B R O U T I N E   G E N E R A T E\n*\n***********************************************************************\n*\n*        GENERATE RLD RECORDS\n*\n* CALL   L     R2,                     VALUE OF PROGRAM POINTER\n*        BAL   R14,GENRLD\n*        DC    H' '                    LENGTH OF ADDR TABLE\n*        DC    H'  '                   ESID OF RELOCATION FACTOR R\n*        DC    H'  '                   ESID OF POSITION IDENTIFIER P\n*        ---                           RETURN AFTER CALL GENERATE\n*\n*        GENERATE TXT RECORDS SIX DIFFERENT CALLS\n*\n*        BAL   R2,GENTXT2\n*        RR FORMAT INSTRUCTION OR DATA 2 BYTES LONG\n*        ---                           RETURN AFTER CALL GENERATE\n*\n*        BAL   R2,GENTXTP2\n*        RR FORMAT FLOATING POINT LONG FORM INSTRUCTION\n*        ---                           RETURN AFTER CALL GENERATE\n*\n*        BAL   R2,GENTXT4\n*        INSTRUCTION(S) OR DATA 4 BYTES LONG\n*        ---                           RETURN AFTER CALL GENERATE\n*\n*        BAL   R2,GENTXTP4\n*        RX  FORMAT FLOATING POINT LONG FORM INSTRUCTION\n*        ---                           RETURN AFTER CALL GENERATE\n*\n*        BAL   R2,GENTXT6\n*        INSTRUCTIONS OR DATA 6 BYTES LONG\n*        ---                           RETURN AFTER CALL GENERATE\n*\n*        LA    R2,                     ADDR OF CODE TO BE GENERATED\n*        BAL   R14,GENTXT8\n*        DC    H'  '                   LENGTH OF CODE IN BYTES\n*        ---                           RETURN AFTER CALL GENERATE\n*\n*        REGISTER DEFINITIONS\n*\n*        R1                            OUTPUT RECORD POINTER\n*        R2                            ADDR OF DATA\n*        R3                            TYPE OF RECORD TO BE GENERATED\n*        R4                            RETURN REGISTER\n*        R14                           LENGTH OF DATA FROM CALL\n*        R15                           LENGTH WITHIN RECORD\n*\n*        BIT PATTERNS\n*\nSDENTRY  EQU   X'00'                   SD ENTRY IDENTIFICATION\nLDENTRY  EQU   X'01'                   LD ENTRY IDENTIFICATION\nRLDFLAG  EQU   B'00001100'             FLAG USED IN RLD ENTRY\n*\n*        GENERATE RLD RECORDS\n*\nGENRLD   LA    R4,6(,R14)              COMPUTE RETURN ADDR\n         LA    R3,RLDT                 INDICATE RLD CALL\n         LH    R14,0(,R14)             LOAD LENGTH GIVEN IN CALL\n         SLL   R14,1                   DOUBLE LENGTH\n         B     GEN1                    CONTINUE COMMON PART\n*\n*        GENERATE TXT RECORDS\n*\nGENTXTS  LA    R4,2(,R14)              COMPUTE RETURN ADDR\n         LH    R14,0(,R14)             LOAD LENGTH GIVEN IN CALL\n         B     GEN2                    CONTINUE TXT ENTRY\n*\n*        GENERATE RX OR RS INSTRUCTION, CHANGE PRECISION\n*\nGENTXTP4 XI    GENTXT6+7,X'06'         MODIFY LENGTH INSTRUCTION\n*\n*        GENERATE RR INSTRUCTION, CHANGE PRECISION\n*\nGENTXTP2 OC    0(1,R2),PRECMASK        MODIFY INSTRUCTION, L OR S\n*\n*        GENERATE TXT RECORD,2\n*\nGENTXT2  XI    GENTXT6+7,X'06'         MODIFY LENGTH INSTRUCTION\n*\n*        GENERATE TXT RECORD,4\n*\nGENTXT4  XI    GENTXT6+7,X'02'         MODIFY LENGTH INSTRUCTION\n*\n*        GENERATE TXT RECORD,6\n*\nGENTXT6  ST    R14,PLACE14             SAVE LENGTH REGISTER\n         LA    R14,6                   LENGTH = 2, 4 OR 6\n         MVI   GENTXT6+7,X'06'         RESTORE MODIFIED INSTRUCTION\n         LA    R4,0(R2,R14)            COMPUTE RETURN ADDR\nGEN2     LA    R3,TXTT                 INDICATE TXT CALL\nGEN1     L     R1,SAVOUTA              FETCH OLD OUTPUT RECORD ADDR\n         TM    COMPFLGS+1,NLOAD+NDECK  LOAD OR DECK SPECIFIED ?\n         BO    GEN4A                   NO, OUT OF GENERATE\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    GEN4A\n         CLC   1(3,R1),1(R3)           RECORD RIGHT TYPE ?\n         BNE   GEN3                    NO, CALL FOR NEW\n         CLC   10(2,R1),12(R3)         RECORD FILLED ?\n         BNL   GEN3                    YES, CALL FOR NEW\nGEN6     LA    R15,56\n         LH    R0,10(,R1)              R0 = LENGTH OF DATA IN REC\n         SR    R15,R0                  R15 = EMPTY POS LEFT IN RECORD\n         CR    R15,R14                 ENOUGH SPACE LEFT ?\n         BL    *+6                     NO\n         LR    R15,R14                 YES, R15 = R14 FROM CALL\n         AR    R15,R0\n         STH   R15,10(,R1)             INSERT NEW LENGTH INTO RECORD\n         SR    R15,R0\n         AR    R1,R0                   START ADDR WITHIN RECORD\n         SR    R14,R15                 REMAINING LENGTH\n         B     14(,R3)                 TO DIFFERENT MOVE ROUTINES\n*\nGEN4     LTR   R14,R14                 MORE INFORMATION MUST BE MOVED ?\n         BH    GEN3                    YES\nGEN4A    L     R14,PLACE14             NO, RESTORE R14\n         BR    R4                      RETURN\n*\n*        NEW OUTPUT RECORD\n*\nGEN3     ST    R14,SAVELT              SAVE LENGTH\n         TM    COMPFLGS+1,NLOAD+NDECK  BOTH LOAD AND DECK SPECIFIED ?\n         BZ    BOTH                    YES\n         TM    COMPFLGS+1,NDECK        DECK ONLY ?\n         L     R1,APCHDCB              R1 -> SYSPUNCH DCB\n         BZ    PUT1                    YES\nPUT$1    L     R1,ALINDCB              R1 -> SYSLIN DCB\n*\nPUT1     PUT   (R1)                    PUT FOR SYSLIN AND SYSPUNCH\n*\n         ST    R1,SAVOUTA              SYSPUNCH OR SYSLIN ADDR\n         L     R14,SAVELT              RESTORE LENGTH\n         B     PUNCHOUT                OUT OF ROUTINE PUNCH\n*\nBOTH     L     R14,OUTAREA2            COPY SYSLIN DATA TO SYSPUNCH\n         L     R1,SAVOUTA\n         MVC   0(80,R14),0(R1)         BUFFER\nPUT2     L     R1,APCHDCB              R1 -> SYSPUNCH DCB\n*\n         PUT   (R1)                    PUT FOR SYSPUNCH WHEN BOTH HAS\n*\n         ST    R1,OUTAREA2             BEEN SPECIFIED\n         B     PUT$1                   GOTO PUT SYSLIN\n*\nPUNCHOUT MVC   0(4,R1),0(R3)           INSERT FIRST 4 BYTES\n         MVI   4(R1),C' '              INSERT ONE BLANK\n         MVC   5(67,R1),4(R1)          BLANK OUTPUT RECORD\n         MVC   72(4,R1),PIDENT         INSERT PROGRAM IDENT\n         AP    CARDCNT,KP1             STEP SEQUENCE NUMBER\n         UNPK  76(4,R1),CARDCNT        UNPACK INTO RECORD\n         OI    79(R1),X'F0'            MAKE PRINTABLE\n         MVC   10(2,R1),4(R3)          INSERT INITIAL LENGTH\n         MVC   14(6,R1),6(R3)          INSERT ESID+R AND P\n         CLC   TXTT+1(3),1(R3)         TXT RECORD PROCESSED ?\n         BNE   GEN6                    NO\n         ST    R6,4(R1)                YES INSERT R6\n         MVI   4(R1),C' '\n         B     GEN6\n*\n*        TXT RECORD\n*\n         DC    0H'0'\nTXTT     DC    X'02'                   RECORD CODE\n         DC    C'TXT'                  IDENTIFICATION\n         DC    H'0'                    INITIAL LENGTH 0\n         DC    H'1'                    ESID\n         DC    C'    '\n         DC    H'56'                   MAXIMUM LENGTH\n*\n*        MOVE TXT INFORMATION TO OUTAREA\n*\nGEN8     BCTR  R15,0                   DECR LENGTH\n         STC   R15,*+5                 INSERT PROPER LENGTH TO MOVE\n         MVC   16(0,R1),0(R2)          MOVE DATA TO OUTAREA\n         LA    R6,1(R15,R6)            INCREASE PROGRAM POINTER\n         LA    R2,1(R15,R2)            MODIFY DATA ADDR\n         B     GEN4                    OUT OF MOVE TXT ROUTINE\n*\n*        RLD RECORD\n*\n         DC    0H'0'\nRLDT     DC    X'02'                   RECORD CODE\n         DC    C'RLD'                  IDENTIFICATION\n         DC    H'0'                    INITIAL LENGTH 0\n         DC    C'  '\nRANDP    DC    H'1',H'1'               R AND P ESID ARE 1 AT START\n         DC    H'56'                   MAXIMUM LENGTH IN RECORD\n*\n*        MOVE RLD INFORMATION TO OUTAREA\n*\nGEN9     AR    R15,R1                  INDICATE LAST ENTRY\nGEN5     MVC   16(4,R1),RANDP\n         ST    R2,20(,R1)              MOVE PROGRAM POINTER VALUE AND\n         MVI   20(R1),RLDFLAG          FLAG TO OUTAREA\n         LA    R1,8(,R1)               NEXT ENTRY\n         LA    R2,4(,R2)               NEXT PROGRAM POINTER VALUE\n         CR    R1,R15                  LAST COLUMN FILLED\n         BL    GEN5                    NO, CONTINUE\n         B     GEN4                    OUT OF MOVE RLD ROUTINE\n*\n*        VARIABLES AND CONSTANTS\n*\nSAVELT   DC    F'0'                    SAVE AREA FOR LENGTH\nKP1      DC    PL2'1'                  FOR INCREMENTING CARD COUNT\n*\n***********************************************************************\n*\n*        SUBROUTINE CLEAR REGISTERS\n*\n***********************************************************************\n*\n* CALL   BAL   R4,CLEARRG\n*\n*        GENERATES STORE INSTRUCTIONS FOR ALL REGISTERS THAT\n*        CONTAIN VALID INFORMATION - SET CII, CIR, RII, RIR\n*\nCLEARRG  MVI   GPBN+1,X'FF'            DESTROY GDSA\n         ST    R4,RETADR               STORE RETURN ADDR\n         SR    R14,R14\n         BCTR  R14,0\n         BCTR  R14,0\n         LH    R2,RIR\nKIF22    LA    R14,2(,R14)\n         LTR   R2,R2\n         BZ    KIF21                   YES, BRANCH\n         SRDL  R2,1\n         LTR   R3,R3\n         BNM   KIF22                   NO, BRANCH\n         ST    R2,RETADR+64\n         BAL   R4,ROUTIN13\n         L     R2,RETADR+64\n         B     KIF22\n*\nKIF21    MVI   CIR,0\n         MVI   CIR+1,X'06'\n         MVC   RIR(2),ZEROHW           CLEAR RIR\n         SR    R14,R14\n         BCTR  R14,0\n         LH    R2,RII\nKIF25    LA    R14,1(,R14)\n         LTR   R2,R2\n         BZ    KIF24                   BRANCH IF YES\n         SRDL  R2,1\n         LTR   R3,R3\n         BNM   KIF25                   BRANCH IF NO\n         ST    R2,RETADR+64\n         BAL   R4,ROUTINE9\n         L     R2,RETADR+64\n         B     KIF25\n*\nKIF24    MVI   CII,0\n         MVI   CII+1,X'07'\n         MVC   RII(2),ZEROHW           CLEAR RII\n         L     R4,RETADR               LOAD RETURN ADDR\n         BR    R4\n*\n***********************************************************************\n*\n*        O P E R A N D   R E C O G N I Z E R\n*\n***********************************************************************\n*\n* CALL   BAL   R4,OPDREC\n*\n*        CHECK IF OPERAND IN STACK IS A FORMAL PARAMETER OR A\n*        PROCEDURE WITHOUT PARAMETERS\n*        OPDREC GENERATES AN ACTUAL PARAMETER OR A PROCEDURE CALL\n*\n*        IF OPERAND IS A FORMAL PARAMETER CALLED BY VALUE LABEL\n*        OR ARRAY OPDREC GENERATES LOAD OF REGISTERS GDSA AND/OR ADR\n*\n*        ADDR DISPLACEMENTS\n*\nTYPS     EQU   1                       SECOND BYTE TYPE IN IDENTIFIER\nNUMP     EQU   3                       NO OF PARAMETERS IN IDENTIFIER\nPBNP     EQU   2                       DISP OF PBN IN IDENTIFIER\nTYPF     EQU   0                       FIRST BYTE TYPE IN IDENTIFIER\nRUTIADR  EQU   4*8                     ENTRY IN RUTI TABLE FOR ADR\n*\n*        BIT PATTERNS\n*\nVARIAM   EQU   X'30'                   MASK FOR VARIABLE\nINTRVM   EQU   X'7F'                   INTERMIDIATE VALUE IN STACK\nINTRRM   EQU   X'60'                   INTERMIDIATE VALUE ADDR IN REG\nDESTROY  EQU   X'FF'                   INDICATE THAT GDSA IS NOT VALID\nARRAYM   EQU   X'04'                   ARRAY IDENTIFIER MASK\nLABARRM  EQU   X'0C'                   LABEL OR ARRAY IDENTIFIER MASK\nRIIADRM  EQU   X'01'                   RII MASK FOR RESERVATION OF ADR\nFORMPM   EQU   X'30'                   FORMAL PARAMETER MASK\nPROCM    EQU   X'C0'                   PROCEDURE MASK\nSTPROCM  EQU   X'40'                   STANDARD PROCEDURE MASK\nPARAM    EQU   X'F0'                   NUMBER OF PARAMETER MASK\nFUNCPM   EQU   X'03'                   FUNCTION PROCEDURE MASK\nVALUEM   EQU   X'20'                   VALUE PARAMETER SPEC\nREGADRM  EQU   ADR*16                  REGISTER ADR MASK\n*\nOPDREC   TM    0(R9),X'C0'             IDENTIFIER FROM ITAB ?\n         BNOR  R4                      NO, RETURN\n         TM    TYPS(R9),FORMPM         OPERAND FORMAL PARAMETER ?\n         ST    R4,SAVRT                SAVE RETURN ADDR\n         BM    OPDREC1                 YES, FORMAL\n         TM    TYPS(R9),PROCM          PROCEDURE IDENTIFIER ?\n         BZR   R4                      NO, RETURN\n         TM    TYPS(R9),STPROCM        STANDARD PROCEDURE ?\n         BZR   R4                      YES, RETURN\n         TM    NUMP(R9),PARAM          PARAMETERLESS PROCEDURE ?\n         BNZR  R4                      NO, RETURN\n*\n*        PARAMETERLESS PROCEDURE FOUND\n*\n         BAL   R4,CLEARRG              CLEAR ALL OBJ TIME REGISTERS\n         MVC   PPCODE+2(2),NUMP(R9)    INSERT DISPLACEMENT OF LABEL\n         MVC   PPCODE+5(1),PBNP(R9)    INSERT PROGRAM BLOCK NUMBER\n         LA    R2,PPCODE               GENERATE A PARAMETERLESS\n         BAL   R14,GENTXTS             PROCEDURE\n         DC    H'12'                   CALL\n         TM    TYPS(R9),FUNCPM         FUNCTION PROCEDURE\n         L     R4,SAVRT\n         BZR   R4                      NO, RETURN\n*                                      PARAMETERLESS FUNCTION\n*                                      PROC FOUND\n         B     OPDREC4\n*\n*        FORMAL PARAMETER FOUND\n*\nOPDREC1  TM    TYPS(R9),VALUEM         CALLED BY NAME ?\n         BO    OPDREC3                 NO\n*                                      FORMAL PARAMETER CALLED BY NAME\n         BAL   R4,CLEARRG              CLEAR ALL OBJ TIME REGISTERS\n         SR    R3,R3\n         IC    R3,PBNP(,R9)            PROCEDURE PBN FROM IDENTIFIER\n         SLL   R3,3                    DISPLACEMENT IN PBT\n         STH   R3,CAP+4                INSERTED IN CAP CODE\n         LH    R3,SPBNST               CURRENT PBN\n         SLL   R3,3                    DISPLACEMENT IN PBT\n         STH   R3,CAP+6                INSERTED IN CAP CODE\n         MVC   CAP+10(2),NUMP(R9)      INSERT FORMAL PARAM DISPL\n         LA    R2,CAP                  GENERATE CALL ACTUAL PARAMETER\n         BAL   R14,GENTXTS             CODE\n         DC    H'12'\n*\n         TM    TYPS(R9),PROCM          PROCEDURE\n         BZ    OPDREC4                 NO\n         TM    PROCWPS,X'80'\n         BO    OPDREC4                 NOT PARAMETERLESS, SET IN CP57\n         LA    R2,OPDREC6              GENERATE\n         BAL   R14,GENTXTS             CHECK FOR PARAMETERLESS\n         DC    H'10'                   PROCEDURE\n*\nOPDREC4  AH    R7,ONEENTRY             RESERVE ONE ENTRY IN OBJ STACK\n         STH   R7,SPBNST+2             INSERT NEW DISPL AND\n         MVC   PBNP(3,R9),SPBNST+1     PBN IN INTERNAL NAME\n         XI    TYPF(R9),INTRRM         ADDR OF OPERAND IN REGISTER\n         OI    NUMP(R9),REGADRM        INDICATE REGISTER ADR\n         ST    R9,RUTI+RUTIADR         GPR CONTROL ENTRY RUTI\n         OI    RII,RIIADRM             GPR CONTROL ENTRY RII\n         L     R4,SAVRT\n         TM    TYPS(R9),ARRAYM\n         BOR   R4\n         TM    TYPS(R9),X'03'\n         BZR   R4\n         MVI   PBNP(R9),X'00'          INDICATE SPECIAL ADDR ADR\n*                                      MAY POINT TO FCTVALST IN FSA\n*                                      ROUTINE 9 CHECK THIS\n         BR    R4                      RETURN\n*\n*        FORMAL PARAMETER CALLED BY VALUE\n*\nOPDREC3  TM    TYPS(R9),LABARRM        LABEL OR ARRAY IDENTIFIER\n         BNMR  R4                      NO, RETURN\n         BAL   R4,ROUTINE3             GENERATE LOAD ADR\n         AH    R7,ONEENTRY             OBJECT TIME STACK NOT RELEASED\n         TM    TYPS(R9),ARRAYM         ARRAY IDENTIFIER\n         BO    OPDREC4                 YES, INTERNAL NAME AND REG CONTR\n         LA    R3,4\n         AH    R3,GRD3+2               ADD 4 TO DISP, GRD3 IN ROUTINE3\n         STH   R3,OPDREC5+2            INSERT DISP+4 (CDSA OR GDSA)\n         MVN   OPDREC5+1(1),GRD3+1     IN LOAD GDSA INSTRUCTION\n         BAL   R2,GENTXT4              GENERATE A LOAD GDSA\nOPDREC5  L     GDSA,4(0,0)             INSTRUCTION\n         MVI   GPBN+1,DESTROY          NOTE THAT GDSA IS DESTROYED\n         B     OPDREC4                 INTERNAL NAME AND REG CONTROL\n*\n*        CONSTANTS AND VARIABLES\n*\nPPCODE   L     ADR,0(LAT,0)            PARAMETERLESS PROCEDURE CALL\n         MVI   PROLPBN(FSA),0          CODE, DISP INSERTED\n         BAL   BRR,PROLOG(,FSA)        CODE IS 12 BYTES\n*\n*        CALL ACTUAL PARAMETER, GENERATED CODE\n*        DISPL, PBNP AND PBNC INSERTED\n*\nCAP      BAL   BRR,CAP1(,FSA)          TO CAP SUBROUTINE FIRST PART\n         DC    H'0'                    PBNP, PBN DISP OF PROCEDURE\n         DC    H'0'                    PBNC, PBN DISP OF CURRENT BLOCK\n         L     ADR,0(CDSA,0)           THUNK ADDR FROM PROCEDURE DSA\nOPDREC6  LA    R14,FCTVALST(FSA)       CHECK THAT ACTUAL\n         CR    R14,ADR                 PARAMETER PROCEDURE\n         BNE   OERR21(FSA)             IS PARAMETERLESS\n*\nSAVRT    DC    F'0'                    SAVE AREA FOR RETURN\nPROCWPS  DC    X'00'                   SWITCH TO AVOID PARAMETERLESS\n*                                      PROCEDURE CHECK\n*\n***********************************************************************\n*\n*        S U B R O U T I N E   M A X C H E C K\n*\n***********************************************************************\n*\n*        SUBROUTINE TO CHECK THAT OBJECT TIME STACK POINTER\n*        VALUE IS LESS THAN MAX VALUE PLACED IN WORKPL BY CALLING\n*        ROUTINE\n*\n* CALL   BAL   R4,MAXCH\n*\nMAXCH    STM   R15,R4,MCHSAV           SAVE REGISTERS\n         LH    R4,WORKPL               FETCH CHECKVALUE FROM WORKAREA\n         LH    R3,SPBNST               CURRENT PBN FROM WORKAREA\n         SLL   R3,2                    PBT DISPLACEMENT\n         CH    R4,PBTAB3(R3)           R4 < MAX IN PBTAB3 ?\n         BNH   MAXCH1                  YES, RETURN\n         STH   R4,PBTAB3(R3)           INSERT R4 AS NEW MAX\n         CH    R4,MAXOVERF             OVERFLOW OF OBJECT TIME STACK ?\n         BNH   MAXCH1                  NO, RETURN\n         CR    R7,R4                   R7 ALREADY BEEN RESET ?\n         BL    MAXCH1                  YES, NO ERROR MSG\n         SR    R7,R7                   NO, RESET R7 TO ZERO\n         BAL   R4,SERRSP               ERROR PATTERN GENERATION\n         DC    H'214'                  ERROR 214\n*\nMAXCH1   LM    R15,R4,MCHSAV           RESTORE REGISTERS\n         BR    R4                      RETURN\n*\n*        VARIABLES AND CONSTANTS\n*\nMCHSAV   DC   6F'0'                    SAVE AREA FOR REGISTERS\n*\n***********************************************************************\n*\n*        SEMICOLON COUNTER HANDLING\n*\n***********************************************************************\n*\n* CALL   BAL R4,SCHDL\n*\n*        SET SEMICOLON COUNTER AND MOVE SOURCE POINTER IN SOURCE\n*        STRING\n*\n*        GENERATES SEMICOLON TRACE IF OPTION SPECIFIED\n*\nSCHDL    ST    R4,SCHDLR               SAVE RETURN ADDR\n         MVC   SEMCNT,1(R8)            STORE SEMICOLON NUMBER\n         LA    R8,2(R8)                STEP SOURCE POINTER\n*\n*        GENERATE BRANCH TO TRACE ROUTINE\n*\n         MVC   SCHDL1(2),SEMCNT        SEMICOLON NUM TO GENERATED CODE\n         TM    COMPFLGS+2,NOTEST\n         BO    SCHDL1+2                NO SEMICOLON TRACE GEN\n         BAL   R2,GENTXT6\n         BAL   BRR,TRACE(FSA)          **GENERATED CODE**\nSCHDL1   DC    H'0'                    **GENERATED CODE**\n*\n         L     R4,SCHDLR\n         BR    R4\n*\nSCHDLR   DC    F'0'                    SAVE RETURN ADDR\n*\n***********************************************************************\n*\n*        ROUTINE NUMBER 1\n*\n***********************************************************************\n*\n* CALL   BAL   R4,ROUTINE1\n*\n*        LOAD IN W-PLACE THE DISPLACEMENT OF AN OPERAND THAT IS\n*        NOT AN ADDR\n*        LOAD IN V-PLACE AA OR 99 DEPENDING ON WHERE THE\n*        VARIABLE, CONSTANT OR INTERMEDIATE RESULT IS AND\n*        GENERATES A LOADING OF GDSA IF NECESSARY\n*\nROUTINE1 MVC   WPLACE(2),3(R9)         MOVE DISPLACEMENT OF LO TO W\nGPE2     MVI   VPLACE,X'AA'            MOVE CDSA REG TO V\n         CLC   2(1,R9),SPBNST+1        PBN OF LO CDSA ?\n         BER   R4                      YES, RETURN IF CURRENT DSA\nGPE3     MVI   VPLACE,X'99'            MOVE GLOBAL DSA REG TO V\n         CLI   GPBN+1,X'FF'            C(GDSA) DESTROYED ?\n         BE    GPC3                    YES, BRANCH IF DESTROYED\n         CLC   GPBN(1),2(R9)           GDSA = PBN OF LO\n         BER   R4                      EQUAL, RETURN\nGPC31    SR    R1,R1                   CLEAR R1\n         ST    R4,RETADR+4             STORE RETURN ADDR\n         MVC   GPBN(1),2(R9)           KEEP NEW LOADED GDSA\n         IC    R1,2(,R9)               LOAD IN R1 PBN OF LO\n         SLA   R1,3                    MULTIPLY BY 8\n         STH   R1,WORKPL               PREPARE INSTRUCTION\n         MVC   GPC4+2(2),WORKPL\n         BAL   R2,GENTXT4              GENERATE\nGPC4     L     GDSA,0(PBT,0)\n         L     R4,RETADR+4             LOAD RETURN ADDR\n         BR    R4                      RETURN\n*\nGPC3     MVI   GPBN+1,0                RECONSTRUCT GDSA\n         B     GPC31\n*\n***********************************************************************\n*\n*        ROUTINE NUMBER 2\n*\n***********************************************************************\n*\n* CALL   BAL   R4,ROUTINE2\n*\n*        GENERATES A LOAD INSTRUCTION INTO THE FLOATING POINT\n*        REGISTER SPECIFIED BY R14 OF AN OPERAND THAT IS AN ADDR\n*        ADJUSTS THE OPERAND\n*        STORES OPERAND STACK ADDR INTO RUTR\n*\nROUTINE2 ST    R4,RETADR+8             STORE RETURN ADDR\n         LA    R9,5(,R9)               INCREASE R9\n         BAL   R4,ROUTINE3             BRANCH TO ROUTINE NUMBER 3\nGQE3     SLL   R14,1                   INTRODUCE R9 ADDR IN RUTR\n         ST    R9,RUTR(R14)\n         SLL   R14,3                   PREPARE INSTRUCTION\n         STC   R14,GQD3+1\n         MVN   GQD3+1(1),VPLACE\n         MVC   GQD3+2(2),WPLACE\n         BAL   R2,GENTXTP4\nGQD3     LD    0,0(0,0)                ***GENERATE***\nGQF3     SRL   R14,4\n         SH    R9,KH5                  REDUCE R9\n         STH   R7,WORKPL               INTROD R7 INTO R9 ENTRY\n         MVC   8(2,R9),WORKPL\n         MVZ   8(1,R9),GQD3+1          INTROD REG NUMBER\n         MVC   7(1,R9),SPBNST+1        INTROD PBN\n         OI    5(R9),X'80'             ADJUST R9 ENTRY\n         NI    5(R9),X'9F'\n         L     R4,RETADR+8             LOAD RETURN ADDR\n         BR    R4\n*\n***********************************************************************\n*\n*        ROUTINE NUMBER 3\n*\n***********************************************************************\n*\n* CALL   BAL   R4,ROUTINE3\n*\n*        LOAD IN W-PLACE ZERO\n*        LOAD IN V-PLACE 88\n*        GENERATE A LOADING OF ADR IF NECCESSARY, IN THIS CASE\n*        THE OPERAND IS AN ADDR\n*\nROUTINE3 ST    R4,RETADR+12            STORE RETURN ADDR\n         TM    0(R9),X'40'             ADDR OF LO IN ADR ?\n         BO    GRC3                    NO, NOT\n         MVI   RII,0                   CLEAR RIT OF ADR\nGRE3     SH    R7,ONEENTRY             REDUCE R7 BY 8\nGRG2     MVI   VPLACE,X'88'            V EQUAL ADR\n         MVC   WPLACE(2),ZEROHW        W EQUAL ZERO\n         L     R4,RETADR+12            LOAD RETURN ADDR\n         BR    R4                      RET\n*\nGRC3     TM    RII,X'01'               ADR FREE ?\n         BZ    GRD31                   YES, BRANCH\nGRC4     ST    R14,RETADR3\n         BAL   R4,ROUTIN10\n         L     R14,RETADR3\nGRD31    BAL   R4,ROUTINE1             CALL ROUTINE1\n         MVC   GRD3+2(2),WPLACE        MOVE DISPLACEMENT\n         MVN   GRD3+1(1),VPLACE        MOVE BASE REG\n         BAL   R2,GENTXT4              GENERATE\nGRD3     L     ADR,0(0,0)              ***GENERATE***\n         ST    R9,RUTI+32\n         B     GRE3\n*\nRETADR3  DC    F'0'\n*\n***********************************************************************\n*\n*        ROUTINE NUMBER 4\n*\n***********************************************************************\n*\n* CALL   BAL   R4,ROUTINE4\n*\n*        GENERATES A LOAD INSTRUCTION INTO THE FLOATING POINT\n*        REGISTER SPECIFIED BY R14 OF AN OPERAND THAT IS NOT AN ADDR\n*        ADJUSTS THE OPERAND AND STORES THE OPERAND STACK ADDR\n*        INTO RUTR\n*\nROUTINE4 ST    R4,RETADR+8             STORE RETURN ADDR\n         LA    R9,5(,R9)               INCREASE R9\n         BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1\n         OI    1(R9),X'30'             SET TO VARIABLE\n         B     GQE3                    BRANCH TO ENTRY PT IN RTN NO 2\n*\n***********************************************************************\n*\n*        ROUTINE NUMBER 5\n*\n***********************************************************************\n*\n* CALL   BAL   R4,ROUTINE5\n*\n*        GENERATES A LOAD INSTRUCTION INTO A GENERAL PURPOSE\n*        REGISTER SPECIFIED BY R14 OF AN OPERAND THAT IS NOT AN ADDR\n*        ADJUSTS THE OPERAND AND STORES THE OPERAND STACK ADDR\n*        INTO RUTI\n*\nROUTINE5 ST    R4,RETADR+8             STORE RETURN ADDR\n         LA    R9,5(,R9)               INCREASE R9\n         BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1\n         OI    1(R9),X'30'             SET TO VARIABLE\nGTE3     SLL   R14,2                   INTRODUCE R9 ADDR IN RUTI\n         ST    R9,RUTI(R14)\n         SLL   R14,2                   PREPARE INSTRUCTION\n         STC   R14,GTD3+1\n         STC   R14,GQD3+1\n         MVN   GTD3+1(1),VPLACE\n         MVC   GTD3+2(2),WPLACE\n         BAL   R2,GENTXT4\nGTD3     L     0,0(0,0)                ***GENERATE***\n         B     GQF3                    BRANCH TO ENTRY PT IN RTN NO 2\n*\n***********************************************************************\n*\n*        ROUTINE NUMBER 6\n*\n***********************************************************************\n*\n* CALL   BAL   R4,ROUTINE6\n*\n*        GENERATES A LOAD INSTRUCTION INTO A GENRAL PURPOSE\n*        REGISTER SPECIFIED BY R14 OF AN OPERAND THAT IS AN ADDR\n*        ADJUSTS THE OPERAND AND STORES THE OPERAND STACK ADDR\n*        INTO RUTI\n*\nROUTINE6 ST    R4,RETADR+8             STORE RETURN ADDR\n         LA    R9,5(,R9)               INCREASE R9\n         BAL   R4,ROUTINE3             CALL ROUTINE NUMBER 3\n         B     GTE3                    BRANCH TO ENTRY PT IN RTN NO 5\n*\n***********************************************************************\n*\n*        ROUTINE NUMBER 7\n*\n***********************************************************************\n*\n* CALL   BAL   R4,ROUTINE7\n*\n*        LOADS INTO R14 THE NUMBER OF THE NEXT GENERAL PURPOSE\n*        REGISTER TO BE USED ACCORDING TO CII\n*        IF IT IS OCCUPIED IT BRANCHES TO ROUTINE NUMBER 9 THAT\n*        GENERATES A STORE INSTRUCTION\n*        CII AND RII ARE SET\n*        RESERVES ONE OBJECT TIME STACK ENTRY\n*\nROUTINE7 SR    R14,R14\n         CLI   CII+1,X'07'             CII IS 7 ?\n         BE    GVC2                    YES, BRANCH\n         IC    R14,CII+1(0)            INCREASE CII BY ONE\n         LA    R14,1(,R14)\nGVC2     STC   R14,CII+1\n         LA    R15,1                   LOAD ONE INTO R15\n         SLL   R15,0(R14)              GENERATE MASK\n         STC   R15,GVC21+1\nGVC21    TM    RII+1,0                 GPR OCCUPIED ?\n         BZ    GVE2                    NO, BRANCH\n         ST    R4,RETADR+28            STORE RETURN ADDR\n         BAL   R4,ROUTINE9             CALL ROUTINE9\n         L     R4,RETADR+28            LOAD RETURN ADDR\nGVE2     OC    RII+1(1),GVC21+1        SET TO ONE RII\nGVF2     AH    R7,ONEENTRY             INCREASE R7 BY 4 OR 8\n         BR    R4\n*\n***********************************************************************\n*\n*        ROUTINE NUMBER 8\n*\n***********************************************************************\n*\n* CALL   BAL   R4,ROUTINE8\n*\n*        THE LAST GENERAL PURPOSE REGISTER RESERVED IS RELEASED\n*        CII AND RII ARE SET\n*        ONE OBJECT STACK ENTRY IS RELEASED\n*\nROUTINE8 SR    R14,R14                 CLEAR R14\n         IC    R14,CII+1               LOAD CII INTO R14\n         LA    R15,1                   CLEAR RII OF LO\n         SLL   R15,0(R14)\n         STC   R15,GWD51+1\n         XI    GWD51+1,X'FF'\nGWD51    NI    RII+1,0\n         SH    R7,ONEENTRY             REDUCE R7\nGWD5     CLI   CII+1,0                 CII = ZERO\n         BE    GWD3                    YES, BRANCH\n         BCTR  R14,0                   REDUCE BY ONE\n         STC   R14,CII+1               STORE NEW CII\n         SRL   R15,1                   GPR INDICATED BY\nGWD6     STC   R15,GWD4+1              CII FREE\nGWD4     TM    RII+1,0\n         BZ    GWD5                    FREE, BRANCH\n         BR    R4                      RETURN\n*\nGWD3     MVI   CII+1,X'07'             MAKE CII = 7\n         LA    R14,7\n         CLI   RII+1,0                 ALL GPR FREE ?\n         BER   R4                      YES, RETURN\n         LA    R15,128                 LOAD MASK\n         B     GWD6\n*\n***********************************************************************\n*\n*        ROUTINE NUMBER 10\n*\n***********************************************************************\n*\n* CALL   BAL   R4,ROUTIN10\n*\n*        CLEARS RII OF ADR\n*        LOADS 8 INTO R14\n*        FALLS THROUGH TO ROUTINE NUMBER 9\n*\nROUTIN10 MVI   RII,X'00'\n         LH    R14,KH8\n*\n***********************************************************************\n*\n*        ROUTINE NUMBER 9\n*\n***********************************************************************\n*\n* CALL   BAL   R4,ROUTINE9\n*\n*        GENERATE CODE TO STORE GENERAL PURPOSE REGISTER\n*        SPECIFIED BY R14 IF THE PBN IS NOT ZERO\n*        IF THE PBN IS ZERO IT GENERATES A MOVE INSTRUCTION\n*        THE OPERAND IS ADJUSTED\n*\nROUTINE9 ST    R4,RETADR+36            STORE RETURN ADDR\n         SLL   R14,2                   MULTIPLY BY 4\n         LA    R15,RUTI                LOAD ADDR OF RUTI\n         L     R15,0(R14,R15)          LOAD ADDR OF OPD TO STORE\n         SLL   R14,2                   PREPARE INSTRUCTION\n         NI    3(R15),X'0F'\n         ST    R15,RETADR+48\n         TM    2(R15),X'FF'\n         BZ    GXC4\n         LA    R14,10(,R14)\n         STC   R14,GXC3+1\n         MVC   GXC3+2(2),3(R15)        PREPARE INSTRUCTION\n         BAL   R2,GENTXT4\nGXC3     ST    0,0(CDSA,0)             ***GENERATE***\n         B     HBC2\n*\nGXC4     MVC   GXC5+2(2),3(R15)\n         OI    GXC5+2,X'A0'\n         MVI   GXC5+1,X'07'\n         TM    COMPFLGS,LNG\n         BO    GXC6\n         MVI   GXC5+1,X'03'\nGXC6     NI    0(R15),X'DF'\n         MVC   2(1,R15),SPBNST+1\n         BAL   R2,GENTXT6\nGXC5     MVC   0(4,CDSA),0(ADR)        *** GENERATE ***\n         B     HBC2\n*\n***********************************************************************\n*\n*        ROUTINE NUMBER 11\n*\n***********************************************************************\n*\n* CALL   BAL   R4,ROUTIN11\n*\n*        LOADS INTO R14 THE NUMBER OF THE NEXT FLOATING POINT\n*        REGISTER TO BE USED ACCORDING TO CIR\n*        IF IT IS OCCUPIED IT CALLS ROUTINE NUMBER 13 THAT\n*        GENERATES A STORE INSTRUCTION\n*        CIR AND RIR ARE SET\n*        ONE OBJECT TIME ENTRY IS RESERVED\n*\nROUTIN11 SR    R14,R14                 CLEAR R14\n         CLI   CIR+1,X'06'             CIR = 6 ?\n         BE    GZC2                    YES, BRANCH\n         IC    R14,CIR+1               LOAD CIR INTO R14\n         LA    R14,2(,R14)             INCR CIR BY 2\nGZC2     STH   R14,CIR                 STORE NEW CIR\n         SRL   R14,1                   DIVIDE R14 BY 2\n         LA    R15,1                   LOAD ONE INTO R15\n         SLL   R15,0(R14)              GENERATE MASK\n         SLL   R14,1\n         STC   R15,GZC21+1\nGZC21    TM    RIR+1,0                 FPR OCCUPIED ?\n         BZ    GZE2                    FREE, BRANCH\n         ST    R4,RETADR+44            STORE RETURN ADDR\n         BAL   R4,ROUTIN13             CALL ROUTIN13\n         L     R4,RETADR+44            LOAD RETURN ADDR\nGZE2     OC    RIR+1(1),GZC21+1\nGZF2     AH    R7,ONEENTRY             INCREASE R7 BY 4 OR 8\n         BR    R4\n*\n***********************************************************************\n*\n*        ROUTINE NUMBER 12\n*\n***********************************************************************\n*\n* CALL   BAL   R4,ROUTIN12\n*\n*        THE LAST FLOATING POINT REGISTER RESERVED IS RELEASED\n*        CIR AND RIR ARE SET\n*        ONE OBJECT STACK ENTRY IS RELEASED\n*\nROUTIN12 LH    R14,CIR                 LOAD INTO R14 CIR\n         LA    R15,1                   CLEAR RIR OF BLO\n         SRL   R14,1\n         SLL   R15,0(R14)\n         STC   R15,HAD4+1\n         XI    HAD4+1,X'FF'\nHAD4     NI    RIR+1,0\n         SH    R7,ONEENTRY             REDUCE R7\n         SLL   R14,1\nHAD1     CLI   CIR+1,0                 ZERO ?\n         BE    HAD3                    YES, BRANCH\n         SH    R14,KH2\n         STC   R14,CIR+1\n         SRL   R15,1\nHAD0     STC   R15,HAD2+1\nHAD2     TM    RIR+1,0\n         BZ    HAD1\n         BR    R4\n*\nHAD3     MVI   CIR+1,X'06'             SET CIR = 6\n         LH    R14,CIR\n         CLI   RIR+1,0                 ZERO ?\n         BER   R4                      YES, BRANCH\n         LA    R15,8\n         B     HAD0\n*\n***********************************************************************\n*\n*        ROUTINE NUMBER 14\n*\n***********************************************************************\n*\n* CALL   BAL   R4,ROUTIN14\n*\n*        LOAD ZERO INTO R14\n*        FALL THROUGH TO ROUTINE NUMBER 13\n*\nROUTIN14 SR    R14,R14\n*\n***********************************************************************\n*\n*        ROUTINE NUMBER 13\n*\n***********************************************************************\n*\n*        GENERATE CODE TO STORE FLOATING POINT REGISTER\n*        SPECIFIED BY R14\n*        THE OPERAND IS ADJUSTED\n*\nROUTIN13 ST    R4,RETADR+36            STORE RETURN ADDR\n         SLL   R14,1                   MULTIPLY R14 BY 2\n         LA    R15,RUTR                LOAD ADDR OF RUTR\n         L     R15,0(R14,R15)          LOAD R9 ADDR OF OPERAND\n         SLL   R14,3                   SHIFT REG NO TO OREOARE INSTRUC\n         LA    R14,10(,R14)            INTRODUCE CDSA\n         STC   R14,HBC3+1\n         NI    3(R15),X'0F'\n         MVC   HBC3+2(2),3(R15)\n         ST    R15,RETADR+48\n         BAL   R2,GENTXTP4\nHBC3     STD   0,0(CDSA,0)             *** GENERATE ***\nHBC2     L     R15,RETADR+48\n         XI    0(R15),X'C0'\n         MVC   WORKPL(2),3(R15)\n         BAL   R4,MAXCH\n         SRL   R14,4\n         L     R4,RETADR+36            LOAD RETURN ADDR\n         BR    R4                      RETURN\n*\n***********************************************************************\n*\n*        ROUTINE NUMBER 15\n*\n***********************************************************************\n*\n* CALL   BAL   R4,ROUTIN15\n*\n*        IF THE OPERAND IS AN ADDR BRANCH TO ROUTINE NUMBER 3\n*        IF THE OPERAND IS NOT AN ADDR AND IS IN A REGISTER GET\n*        THE REGISTER NUMBER TO V-PLACE, ELSE IT BRANCHES TO\n*        ROUTINE NUMBER 1\n*\nROUTIN15 TM    0(R9),X'20'\n         BO    ROUTINE3\n         TM    0(R9),X'40'\n         BZ    ROUT151\n         TM    0(R9),X'80'\n         BO    ROUTINE1\n         SH    R7,ONEENTRY\n         B     ROUTINE1\n*\nROUT151  IC    R15,3(,R9)              GET\n         SRL   R15,4                       REG\n         STC   R15,VPLACE                      NUMBER\n         MVZ   VPLACE(1),3(R9)                  TO VPLACE\n         BR    R3                      RETURN\n*\n***********************************************************************\n*\n*        DECOMP\n*\n***********************************************************************\n*\n* CALL   BAL   R4,DECOMP\n*\n*        DECOMPOSE OPERAND BY MOVING ITS PARTS INTO LOW ENDS OF\n*        HALFWORDS\n*\nDECOMP   MVC   OPDPBN+1(1),2(R9)       MOVE PBN\n         MVC   OPDADR(2),3(R9)         MOVE ADDR\n         LH    R1,OPDADR\n         N     R1,HEXFFF\n         STH   R1,OPDLN                LABEL NUMBER\n         BR    R4\n*\n***********************************************************************\n*\n*        STACKAPI\n*\n***********************************************************************\n*\n* CALL   BAL   R4,STACKAPI\n*\n*        STACK ALL PURPOSE IDENTIFIER (API)\n*\nSTACKAPI SH    R9,KH5\n         CR    R10,R9\n         BNL   STACKOFL\n         MVC   0(5,R9),API\n         BR    R4\n*\n***********************************************************************\n*                                                                     *\n*        PROGRAM BLOCK NUMBER HANDLING                                *\n*                                                                     *\n***********************************************************************\n*\n* CALL   BAL   R4,PBNHDL\n*\n*        PROGRAM BLOCK NUMBER HANDLING INSERTS NEW PBN IN\n*        WORKAREA, SPBNST\n*        SAVE R7 IN PBTAB2\n*        INSERT NEW OBJECT TIME STACK POINTER VALUE TO R7\n*\nPBNHDL   SR    R2,R2\n         IC    R2,3(,R8)\n         CLI   0(R8),X'0D'             SOURCE OPERATOR BETA ?\n         BE    PBNHDL1                 YES\n         CLI   0(R8),X'2A'             SOURCE OPERATOR EPSILON ?\n         BNE   PBNHDL2                 NO\n*                                      (=BRANCH IF OPTR IS PI OR PHI)\n*\n*        OPERATOR IS BETA OR EPSILON\n*\nPBNHDL1  IC    R2,1(,R8)\n         LA    R8,1(,R8)\nPBNHDL2  LH    R1,SPBNST               STORE\n         SLL   R1,1                    OLD\n         STH   R7,PBTAB2(R1)           P-VALUE\n         STC   R2,SPBNST+1             INSERT NEW PBN\n         SLL   R2,1                    GET DISP IN PBTAB2\n         LH    R7,PBTAB2(R2)           LOAD NEW P VALUE\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BOR   R4                      YES, RETURN\n         B     CLEARRG                 CLEAR REGISTERS RETURN DIRECT\n*\n***********************************************************************\n*\n*        PLPRST - PARAMETERLESS PROCEDURE STATEMENT HANDLING\n*\n***********************************************************************\n*\n* CALL   BAL   R4,PLPRST\n*\n*        CHECKS THAT OPERAND IS A PARAMETERLESS PROCEDURE\n*\nPLPRST   ST    R4,STRETURN             SAVE RETURN ADDR\n         BAL   R4,DECOMP               DECOMPOSE OPERAND\n         TM    1(R9),X'C0'             PROCEDURE IDENTIFIER ?\n         BZ    PLPRST4                 NO, ERROR\n         LH    R4,OPDADR\n         SRL   R4,12                   GET NUMBER OF PARAMETERS\n         LTR   R4,R4                   NUMBER ZERO ?\n         BZ    PLPRST1                 YES, BRANCH\nPLPRST0  BAL   R4,SERR1                ERROR\n         DC    H'187'\n*\n         B     PLPRST3\n*\nPLPRST4  BAL   R4,SERR3                ERROR\n         DC    H'183'\n*\n         B     PLPRST3\n*\nPLPRST1  TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    PLPRST3                 YES, BRANCH\n         BAL   R4,OPDREC               OPERAND RECOGNIZER\n         TM    3(R9),REGADRM           OPERAND IN ADR\n         BZ    PLPRST3                 NO\n         SH    R7,ONEENTRY             RELEASE STACK\n         XI    RII,RIIADRM             ADR NOT OCCUPIED\nPLPRST3  L     R4,STRETURN             LOAD RETURN ADDR\n         BR    R4\n*\n***********************************************************************\n*\n*        SUBROUTINE - LOAD VPLACE, WPLACE\n*\n***********************************************************************\n*\n* CALL   BAL   R4,LDVWPLC\n*\nLDVWPLC  ST    R4,LDRET\n         BAL   R4,OPDREC               ERAND RECOGNIZER\n         TM    0(R9),X'20'             ADDR OR VALUE ?\n         BO    LDVW1                   ADDR\n         TM    0(R9),X'40'             VALUE IN REG ?\n         BO    LDVW3                   NO\n         SR    R4,R4\n         IC    R4,3(,R9)               GET REG NUMBER\n         SRL   R4,4\n         SLL   R4,1                    DOUBLE IT\n         TM    1(R9),X'01'             VALUE INTEGER ?\n         BZ    LDVW4                   NO\n         SLL   R4,1                    YES, 4 TIMES REG NUMBER\n         ST    R9,RUTI(R4)             INTRODUCE CORRECT R9 ADDR\n         B     LDVW3\n*\nLDVW4    ST    R9,RUTR(R4)             INTRODUCE CORRECT R9 ADDR\nLDVW3    BAL   R4,CLEARRG              CLEAR REGISTERS\n         BAL   R4,ROUTINE1             USE ROUTINE 1 TO LOAD VW-PLACE\n         B     LDVWR\n*\nLDVW1    CLI   2(R9),X'00'             FUNCTION VALUE IN FSA\n         BNE   LDVW1A\n         ST    R9,RUTI+32              INTRODUCE CORRECT R9 ADDR\n         CLI   0(R8),XFCOMMA           SOURCE OPERATOR COMMA\n         BE    LDVW3                   YES\nLDVW1A   TM    0(R9),X'40'             ADDR IN STACK ?\n         BO    LDVW2                   YES\n         MVI   VPLACE,X'88'            ADDR IN REG ADDR\n         MVC   WPLACE(2),ZEROHW\n         B     LDVWR\n*\nLDVW2    MVI   VPLACE,X'AA'            ADDR\n         MVC   WPLACE(2),3(R9)         IN STACK\nLDVWR    L     R4,LDRET\n         BR    R4\n*\nLDRET    DC    F'0'\n*\n***********************************************************************\n*\n*        SUBROUTINES FOR MOVING STACK POINTERS\n*\n***********************************************************************\n*\n*        ENTRY FOR MOVING OPERATOR STACK PTR\n*\nMOVEOPTK LA    R10,1(R10)\n         B     MOVERET\n*\n*        ENTRY FOR MOVING OPDSTACK POINTER\n*\nMOVEOPDK SH    R9,KH5\nMOVERET  CR    R10,R9\n         BNL   STACKOFL\n         BR    R4\n*\n***********************************************************************\n*\n*        TARITHM\n*\n***********************************************************************\n*\n* CALL   BAL   R4,TARITHM\n*\n*        RETURN TO RETURN IF OPERAND INTEGER OR REAL\n*        ELSE RETURN TO RETURN+4 AFTER ERROR MESSAGE 163 IS\n*        GIVEN\n*        CHECK FOR ARRAY OR PROCEDURE IDENTIFIER\n*\nAPIMASK  EQU   X'10'\n*\n*        TEST IF OPERAND IS ARITHMETIC\n*\nTARITHM  TM    0(R9),APIMASK           API IN STACK\n         BOR   R4                      YES, RETURN NO ERROR\n         TM    1(R9),X'03'             OPERAND ARITHMETIC\n         BM    PROGARR                 YES, CONTINUE CHECK\n         ST    R4,SAVTRREI             SAVE RETURN\n         BAL   R4,SERR2\n         DC    H'163'                  ERROR 163\n*\n         L     R4,SAVTRREI\n         B     4(R4)                   RETURN ERROR MESSAGE 163 GIVEN\n*\nPROGARR  LA    R1,4(R4)\n         ST    R1,SAVTRREI             ERROR RETURN FROM ARRTEST\n         B     ARRTESTA                CHECK FOR PROCEDURE OR ARRAY\n*\n***********************************************************************\n*\n*        LATRES\n*\n***********************************************************************\n*\n* CALL   BAL   R4,LATRES\n*\n*        RESERVE ONE ENTRY IN LABEL ADDR TABLE (LAT)\n*        CHECK IF OVERFLOW\n*\nLATRES   LH    R1,LN                   GET CURRENT LN\n         LA    R1,4(,R1)               ADD ONE ENTRY\n         STH   R1,LN                   STORE NEW LN\n*\n*        CHECK IF LAT OVERFLOW\n*\nLATOVFLO TM    LN,X'F0'                LAT FULL ?\n         BZR   R4                      NO\n         ST    R4,LDRET                SAVE RETURN ADDR\n         BAL   R4,SERR1                GENERATE ERROR PATTERN\n         DC    H'216'\n*\n         LA    R1,LATBEG               RESET POINTER\n         STH   R1,LN                   TO FIRST ENTRY\n         L     R4,LDRET\n         BR    R4\n*\n***********************************************************************\n*\n*        ARRAY AND PROCEDURE TEST\n*\n***********************************************************************\n*\n* CALL   BAL   R4,ARRTEST1\n*\nARRTEST1 ST    R4,SAVTRREI             SAVE RETURN\n*\n*        ENTRY POINT FROM TARITHM\n*\nARRTESTA TM    0(R9),APIMASK           OPERAND API ?\n         BOR   R4                      YES, RETURN\n         TM    1(R9),X'C0'             PROCEDURE ?\n         BNM   ARRTESTT\n         TM    1(R9),X'40'             STANDARD PROCEDURE\n         BZ    PROCTES1                YES, ERROR\nARRTESTT TM    0(R9),X'C0'             IDENTIFIER FROM ITAB ?\n         BNOR  R4                      NO, RETURN\n         TM    1(R9),X'04'\n         BZ    PROCTEST                NO, ARRAY CONTINUE TEST\n         BAL   R4,SERR3\n         DC    H'196'\n*\nARRTEST3 L     R4,SAVTRREI             RESTORE RETURN\n         BR    R4\n*\nPROCTEST TM    1(R9),X'C0'             PROCEDURE ?\n         BZR   R4                      NO, RETURN\n         TM    3(R9),X'F0'             PARAMETERLESS ?\n         BZR   R4                      YES, RETURN\nPROCTES1 BAL   R4,SERR1                ERROR 187\n         DC    H'187'\n*\n         B     ARRTEST3\n*\nARRTEST2 ST    R4,RETARR2\n         LA    R9,5(,R9)\n         BCTR  R10,0\n         BAL   R4,ARRTEST1\n         LA    R10,1(,R10)\n         SH    R9,KH5\n         L     R4,RETARR2\n         B     ARRTEST1\n*\nRETARR2  DC    F'0'\n*\n***********************************************************************\n*\n*        OPERAND TEST\n*\n***********************************************************************\n*\n* CALL   BAL   R4,OPDTEST\n*\n*        GIVE ERROR MESSAGE 162 IF OPERAND IS MISSING\n*        STACK ALL PURPOSE IDENTIFIER\n*        RETURN VIA R4 IF NO ERROR RETURN VIA R3\n*\nOPDTEST  TM    COMPFLGS,OPERAND        OPERAND PRESENT ?\n         BOR   R3                      YES, RETURN\n         ST    R4,STRETURN\n         BAL   R4,SERR4                ERROR 162\n         DC    H'162'\n*\n         L     R4,STRETURN\n         OI    COMPFLGS,OPERAND        OPERAND SWITCH ON\n         B     STACKAPI                STACK API RETURN DIRECT\n*\nERR166   ST    R4,RETADR               STORE RETURN ADDR\n         TM    COMPFLGS,OPERAND        OPDT ?\n         BZ    BYB2                    NO, BRANCH\n         LA    R9,5(,R9)               CLOPD\n         NI    COMPFLGS,255-OPERAND    OPDFL=FALSE\nBYB2     BAL   R4,SERR1                ERROR 166\n         DC    H'166'\n*\n         L     R4,RETADR               LOAD RETURN ADDR\n         BR    R4                      RETURN\n*\n         TITLE 'IEX50 - COMPILATION PHASE, DECISION MATRIXES'\n*\n*        DECISION MATRICIES\n*\n*        START OF DECISION AREA\n*\n***********************************************************************\n*\n*        PROGRAM CONTEXT COLUMN VECTOR\n*\n***********************************************************************\n*\nDECAREA  DC    X'0A0A0A0A0A0A09120703030B000002020A0A0A0A0A0A080404'\n         DC    X'121212120512060A0A0A0A0A121201120C0D0E0F1110000000'\n*\n***********************************************************************\n*\n*        PROGRAM CONTEXT ROW VECTOR\n*\n***********************************************************************\n*\n         DC    X'ABABABABABABABABABAB853926131313ABABABABABAB72ABAB'\n         DC    X'ABABAB98ABABABABABABABAB00AB4C5FABABABABABAB000030'\n*\n***********************************************************************\n*\n*        PROGRAM CONTEXT MATRIX\n*\n***********************************************************************\n*\n         DC    X'00010454545454545454545454545454540354'\n         DC    X'0001040407074B0707074B191810545453544B'\n         DC    X'00011D1D06084B290C404B191C54541054544B'\n         DC    X'00011A1A06084B290C404B171C17171754544B'\n         DC    X'00011A1A064B11290C404B121C12121254544B'\n         DC    X'00011A1A06084B290C404B121C12121254544B'\n         DC    X'1B1E1A1A1B131429151616141C14141454544B'\n         DC    X'5454545454545454555454541C545454545454'\n         DC    X'00011D1D06084B290C404B1A1C54515454544B'\n         DC    X'1F1E1F1F1F1F1F1F1F1F1F1F1C1F1F1F545416'\n*\n***********************************************************************\n*\n*        STATEMENT CONTEXT COLUMN VECTOR\n*\n***********************************************************************\n*\nADRSTC   DC    X'090909090909010D030F0F0C0F0F0F0F0A0A0A0A0A0A060F0F'\n         DC    X'0708070B000F0C0A0A0A0A0A05020F040E0C0C0C0F0F000000'\n*\n***********************************************************************\n*\n*        STATEMENT CONTEXT ROW VECTOR\n*\n***********************************************************************\n*\n         DC    X'D0D0D0D0D0D0D0B03040D0D0D0D0D0D0D0D0D0D0D0D0D00060'\n         DC    X'8090A0D0D0D0D0D0D0D0D0D0D0D0D0D02050D0C07010000033'\n*\n***********************************************************************\n*\n*        STATEMENT CONTEXT MATRIX\n*\n***********************************************************************\n*\n         DC    X'22384B294B4B4B4B4B4B4B4B3E4B1C1B'\n         DC    X'22384B294B3B544B4B4B4B4B1B543B1B'\n         DC    X'224039294B394B4B4B21214B1B4B1C1B'\n         DC    X'22404B2926264B4B4B214B4B1B4B1C1B'\n         DC    X'5454543454345454545454541B543654'\n         DC    X'22403D294B3D4B4B4B21214B1B4B1C1B'\n         DC    X'4B4B4B294B4B284B4B4B4B1B1B4B1C1B'\n         DC    X'22404B294B2B4B2B4B214B2B1B4B1C1B'\n         DC    X'22404B294B4B4B4B2D214B1B1B4B1C1B'\n         DC    X'22404B294B2F4B4B4B214B2F1B4B1C1B'\n         DC    X'22404B294B314B4B4B2121311B4B1C1B'\n         DC    X'22404B2933334B4B4B214B4B1B4B1C1B'\n         DC    X'22404B294B4B544B4B214B4B1B241C1B'\n         DC    X'224B4B4B4B4B4B4B4B4B4B4B474B1C47'\n*\n***********************************************************************\n*\n*        EXPRESSION CONTEXT COLUMN VECTOR\n*\n***********************************************************************\n*\nADREXC   DC    X'0B0B0C0C0C0D050F070F0F0F0F0F0F0F0E0E0E0E0E0E0F0F0F'\n         DC    X'0F0F0F0F08090A00020304010F060F0F0F0F0F0F0F0F000000'\n*\n***********************************************************************\n*\n*        EXPRESSION CONTEXT ROW VECTOR\n*\n***********************************************************************\n*\n         DC    X'A0A0B0B0B0C050E0E0E0E0E0E0E0E0E0D0D0D0D0D0D0E0E0E0'\n         DC    X'E0E0E0E06070800020304010E060E0E0E0E090E0E0E000003F'\n*\n***********************************************************************\n*\n*        EXPRESSION CONTEXT MATRIX\n*\n***********************************************************************\n*\n         DC    X'4B4D4D4D4D404D29494D4D424343434D'\n         DC    X'414C434343404C29494C4C424343434C'\n         DC    X'414C4C4343404C29494C4C424343434C'\n         DC    X'414C4C4C43404C29494C4C424343434C'\n         DC    X'414C4C4C4C404C29494C4C424343434C'\n         DC    X'4143434343404429501B1B424343431B'\n         DC    X'4143434343404B29414E56424343431B'\n         DC    X'4143434343404B29494B57424343431B'\n         DC    X'4143434343404F29414F48424343434F'\n         DC    X'4B3F3F3F3F403F29493F3F3F3F433F3F'\n         DC    X'4B454545454045294945454543434545'\n         DC    X'4B454545454045294945454545434545'\n         DC    X'4B454545454045294945454545454545'\n         DC    X'4B454545454045294945454243434A45'\n         DC    X'4143434343404629464B464243434346'\n*\n         TITLE 'IEX50 - COMPILATION PHASE, WORKAREA DSECT'\n*\n*        THIS MODULE HAD ITS OWN INLINE VERSION OF THE WORKAREA\n*        WHICH HAD ITS OWN VARIABLES APPENDED ONTO THE END LIKE\n*        IEX40. THE INLINE VERSION HAS BEEN DELETED AND HAVE\n*        INSTEAD INSERTED A COPY WORKAREA. THIS WILL NEED TO HAVE\n*        ADDITIONAL VARIABLES APPENDED AS THEY ARE DISCOVERED BY\n*        DISASSEMBLY AND PICKED UP FROM IEX40\n*\nWORKAREA DSECT\n*\n         COPY  WORKAREA\n         COPY  WAEXT\n         ORG   SAVEAREA\n         COPY  FSAREA                  COPY RUNTIME DSECT\n*                                      FOR OP CODE GENERATION OFFSETS\n         COPY  IEX50002                IEX50002 (RECOVERED)\n         COPY  IEX5000C                IEX50003 (RECOVERED) INIT\n         COPY  IEX50003                IEX50003 CONTINUATION\n         COPY  IEX50004                IEX50004\n         COPY  IEX50005                IEX50005\n         COPY  IEX50006                IEX50006\n*\n*        CHARACTER EQUATES\n*\n         IEXCHAR\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n         END\n./ ADD NAME=IEX5000C 0201-12230-12230-1200-00815-00815-00000-LEVEL\n         TITLE 'IEX50003 - CP0,4,7,8,16,25,36,38,41'\n*\n***********************************************************************\n*\n*        THIS SOURCE FOR THE START OF IEX50003 WAS RECOVERED BY\n*        DISASSMBLY OF THE LOAD MODULE\n*\n***********************************************************************\n*\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP0\n*\n***********************************************************************\n*\n         USING CP0,R12\nCP0      TM    COMPFLGS,OPERAND\n         BZ    CP0D\n         CLI   0(R10),X'25'\n         BE    CP0C\n         BAL   R4,SERR4\n         DC    H'164'                  ERROR 164\n*\nCP0A     LA    R9,5(,R9)\nCP0B     BAL   R4,MOVEOPTK\n         MVC   0(1,R10),0(R8)\n         CLI   0(R8),X'0C'\n         BER   R5\n         BAL   R4,PBNHDL\n         BR    R5\n*\nCP0C     BAL   R4,SERR1\n         DC    H'173'                  ERROR 173\n*\n         B     CP0A\n*\nCP0D     CLI   0(R8),X'0D'\n         BNE   CP0B\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    CP0B                    YES, BRANCH\n         BAL   R4,CLEARRG\n         MVC   CP0E+1(1),1(R8)\n         LA    R2,CP0E\n         BAL   R14,GENTXTS\n         DC    H'8'                    LENGTH OF TXT\n*\n         B     CP0B\n*\nCP0E     MVI   SAVOUTA+1,X'00'         *** GENERATED TEXT ***\n         BAL   R15,PROLOG(R13,0)       *** GENERATED TEXT ***\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP1\n*\n***********************************************************************\n*\n         USING CP1,R12\nCP1      TM    COMPFLGS,OPERAND\n         BZ    CP1A\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    CP1B                    YES, BRANCH\n         CLI   1(R9),X'08'\n         BNE   CP1A\n         BAL   R4,CLEARRG\n         MVC   WORKPL(2),3(R9)\n         LH    R1,WORKPL\n         A     R1,LATAB\n         ST    R6,0(,R1)\nCP1B     CLI   0(R10),X'0D'\n         BL    CP1C\n         CLI   0(R10),X'0F'\n         BNL   CP1C\n         BAL   R4,MOVEOPTK\n         MVI   0(R10),X'0B'\nCP1C     LA    R9,5(,R9)\n         BR    R5\n*\nCP1A     L     R12,SCPTAB+4*84         R12 -> CP84\n         BR    R12\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP3\n*\n***********************************************************************\n*\n         USING CP3,R12\nCP3      TM    COMPFLGS,OPERAND\n         BO    CP3A\n         TM    COMPFLGS,PROC\n         BO    CP3B\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\n         B     TERMNTE(FSA)            *** GENERATED TEXT ***\n*\nCP3B     B     CPEND\n*\nCP3A     L     R12,SCPTAB+4*84         R12 -> CP84\n         BR    R12\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP4\n*\n***********************************************************************\n*\n         USING  CP4,R12\nCP4      TM     COMPFLGS,OPERAND\n         BZ     CP4A\n         BAL    R4,SERR4\n         DC     H'164'                 ERROR 164\n*\n         LA     R9,5(R9)\nCP4A     BAL    R4,MOVEOPTK\n         MVC    0(1,R10),0(R8)\n         CLI    0(R8),X'09'\n         BE     CP4B\n         SH     R9,KH5\n         BAL    R4,MOVEOPDK\n         CLI    SPBNST+1,0\n         BE     CP4C\n         BAL    R4,LATRES\n         STH    R1,CP4D+2              UPDATE GENERATED CODE\n         MVC    3(2,R9),CP4D+2\n         BAL    R2,GENTXT6             GENERATE 6 BYTES\nCP4D     L      R15,0(R12)             *** GENERATED CODE ***\n         BR     R15                    *** GENERATED CODE ***\n*\nCP4C     CLI    0(R8),X'0A'\n         BER    R5                     RETURN TO SUBSTART\n         BAL    R4,PBNHDL\n         BAL    R4,CP4E\n         MVC    5(5,R9),STRDNAME\n         LA     R9,5(R9)\n         BAL    R4,DECOMP\n         MVC    0(5,R9),STRDNAME\n         SH     R9,KH5\n         MVC    HALFW,KH15\n         L      R15,LATAB\n         AH     R15,OPDLN\n         ST     R6,0(R15)\n         TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?\n         BO     CP4F                   YES, BRANCH\n         CLI    0(R8),XFLBRAC\n         BE     CP4G\nCP4F     NI     COMPFLGS,255-OPERAND   TURN OFF OPERAND FLAG\nCP4H     CLI    0(R8),XFDELTA\n         BE     COMP\n         BAL    R4,CP4E\n         B      CP4H\n*\nCP4G     BAL    R4,CP4E\n         MVC    CP4I(2),STRDNAME\n         BAL    R2,GENTXT2             GENERATE 4 BYTES\nCP4I     DC     X'0000'                *** GENERATED CODE ***\n         MVI    CBVTAB+45,X'00'\n         TM     STRDNAME+1,X'20'\n         BZ     CP4J\n         MVI    CBVTAB+45,X'80'\n         MVC    CBVTAB+46(2),STRDNAME\n         TM     STRDNAME+1,X'08'\n         BZ     CP4J\n         MVI    CBVTAB+45,X'C0'\nCP4J     MVC    CBVTAB(45),CBVTAB+3\n         LH     R15,HALFW\n         BCTR   R15,R0\n         STH    R15,HALFW\n         CLI    0(R8),XFCOMMA\n         BE     CP4G\n         LH     R15,HALFW\n         LTR    R15,R15\n         BZ     CP4K\n         MVI    CBVTAB+45,X'00'\n         B      CP4J\n*\nCP4K     LH     R15,HALFW\n         LA     R15,1(,R15)\n         STH    R15,HALFW\n         SH     R15,KH15\n         BP     CP4F\n         TM     CBVTAB,X'80'\n         BZ     CP4L\n         LH     R15,OPDPBN\n         SLL    R15,3\n         STH    R15,CP4ZA\n         STH    R15,CP4ZB\n         SR     R15,R15\n         TM     6(R9),X'03'\n         BZ     CP4M\n         LA     R15,1(,R15)\nCP4M     AH     R15,HALFW\n         SLL    R15,3\n         LA     R15,16(,R15)\n         STH    R15,CP4N+2\n         STH    R15,CP4ZC\n         STH    R15,CP4P+2\n         LA     R15,4(,R15)\n         STH    R15,CP4Q+2\n         LA     R2,CP4R\n         BAL    R14,GENTXTS\n         DC     H'12'                  GENERATE 12 BYTES\n*\n         TM     CBVTAB,X'40'\n         BZ     CP4S\n         LA     R2,CP4P\n         BAL    R14,GENTXTS\n         DC     H'8'                   GENERATE 8 BYTES\n*\n         B      CP4L\n*\nCP4S     MVC    CP4ZF(2),CBVTAB+1\n         LA     R2,CP4T\n         BAL    R14,GENTXTS\n         DC     H'8'                   GENERATE 8 BYTES\n*\nCP4L     MVC    CBVTAB(45),CBVTAB+3\n         B      CP4K\nCP4E     ST     R4,STRETURN\n         MVC    STRDNAME+3(2),ZEROHW\nCP4V     CLI    1(R8),XFZETA\n         BL     CP4U\n         BH     CP4W\n         BAL    R4,JBUFFER\n         B      CP4V\n*\nCP4W     MVC    STRDNAME(5),1(R8)\n         LA     R8,5(,R8)\n         B      CP4V\n*\nCP4U     LA     R8,1(,R8)\n         L      R15,STRETURN\n         BR     R15\n*\nCP4B     L      R11,STC\n         BR     R5                     RETURN TO SUBSTART\n*\nCP4P     ST     R8,0(R10)              *** GENERATED CODE ***\nCP4Q     ST     R9,0(R10)              *** GENERATED CODE ***\nCP4R     BAL    R15,CAP1(R13)          *** GENERATED CODE ***\nCP4ZA    DC     X'0000'                *** GENERATED CODE ***\nCP4ZB    DC     X'0000'                *** GENERATED CODE ***\nCP4N     L      R8,0(R10)              *** GENERATED CODE ***\nCP4T     BAL    R15,VALUCALL(R13)      *** GENERATED CODE ***\nCP4ZC    DC     X'0000'                *** GENERATED CODE ***\nCP4ZF    DC     X'0000'                *** GENERATED CODE ***\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP7\n*\n***********************************************************************\n*\n         USING  CP7,R12\nCP7      BAL    R4,MOVEOPTK\n         MVI    0(R10),X'0B'\n         B      COMP\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP8\n*\n***********************************************************************\n*\n         USING  CP8,R12\nCP8      TM     COMPFLGS,OPERAND\n         BO     CP8A\nCP8B     BAL    R4,MOVEOPTK\n         MVI    0(R10),XFRBRAC\n         LA     R11,614(,R11)\n         TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?\n         BOR    R5                     YES, RETURN TO SUBSTART\n         BAL    R4,CLEARRG\n         BR     R5                     RETURN TO SUBSTART\n*\nCP8A     BAL    R4,SERR3\n         DC     H'177'                 ERROR 177\n*\n         LA     R9,5(,R9)\n         B      CP8B\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP16\n*\n***********************************************************************\n*\n         USING  CP16,R12\nCP16     TM     COMPFLGS,OPERAND\n         BZ     CP16A\n         BAL    R4,PLPRST\n         LA     R9,5(R9)\n         NI     COMPFLGS,255-OPERAND   TURN OFF OPERAND\nCP16A    CLI    0(R8),XFEND\n         BNE    CP16B\n         BCT    R10,SPECTEST\nCP16B    TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?\n         BO     CP16C                  YES, BRANCH\n         CLI    0(R10),X'0D'\n         BE     CP16D\n         TM     6(R9),X'80'\n         BZ     CP16E\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\n         B      232(R13)               *** GENERATED CODE ***\n*\nCP16C    CLI    0(R10),X'0D'\n         BE     CP16F\n         CLI    1(R8),XFPLUS\n         BE     CP16G\n         TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?\n         BO     CP16G                  YES, BRANCH\n         BAL    R4,DECOMP\n         LH     R4,OPDLN\n         L      R15,LATAB\n         ST     R6,0(R4,R15)\nCP16G    LA     R9,5(R9)\n         LA     R1,4\nCP16H    CLI    0(R10),X'0F'\n         BNE    CP16I\n         LA     R1,4(R1)\nCP16I    SLL    R1,12\n         IC     R1,3(R9)\n         SRL    R1,4\n         LA     R9,5(R9)\nCP16F    LH     R15,SPBNST\n         SLL    R15,2\n         STH    R1,PBTAB3+2(R15)\n         BAL    R4,PBNHDL\n         BCT    R10,SPECTEST\nCP16D    BAL    R2,GENTXT4             GENERATE 4 BYTES\n         BAL    R15,EPILOGB(FSA)       *** GENERATED CODE ***\n         LH     R1,ZEROHW\n         B      CP16F\n*\nCP16E    LA     R1,20\n         LA     R9,5(R9)\n         B      CP16H\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP24\n*\n***********************************************************************\n*\n         USING  CP24,R12\nCP24     TM     COMPFLGS,OPERAND\n         BZ     CP24A\n         BAL    R4,SERR3\n         DC     H'177'                 ERROR 177\n*\n         LA     R9,5(,R9)\nCP24A    BAL    R4,SCHDL\n         BR     R5                     RETURN TO SUBSTART\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP25\n*\n***********************************************************************\n*\n         USING  CP25,R12\nCP25     TM     COMPFLGS,OPERAND\n         BZ     CP25A\n         BAL    R4,PLPRST\n         LA     R9,5(,R9)\nCP25A    BAL    R4,MOVEOPTK\n         MVC    0(1,R10),0(R8)\n         BAL    R4,SCHDL\n         BR     R5                     RETURN TO SUBSTART\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP36\n*\n***********************************************************************\n*\n         USING  CP36,R12\nCP36     LA     R4,CP36A\n         BAL    R3,OPDTEST\n         BAL    R4,TARITHM\n         B      CP36B                  +00\n*\nCP36A    LA     R9,5(,R9)              +04\n         BAL    R4,MOVEOPTK\n         MVC    0(1,R10),0(R8)\n         BR     R5                     RETURN TO SUBSTART\n*\nCP36B    TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?\n         BO     CP36A                  YES, BRANCH\n         BAL    R4,OPDREC\n         TM     1(R9),X'01'\n         BO     CP36C\n         BAL    R4,TRREIN\n         MVC    CP36D+2(2),8(R9)\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP36D    ST     R14,0(R10)             *** GENERATED CODE ***\n         B      CP36E\n*\nCP36F    SR     R14,R14\n         IC     R14,3(R9)\n         SRL    R14,4\n         BAL    R4,ROUTINE9\n         BAL    R4,ROUTINE8\nCP36E    AH     R7,ONEENTRY\n         AH     R7,ONEENTRY\n         STH    R7,WORKPL\n         BAL    R4,MAXCH\n         B      CP36A\n*\nCP36C    LA     R3,CP36F\n         BAL    R4,ROUTIN15\n         TM     0(R9),X'A0'\n         BZ     CP36E\n         NC     CP36G+2(2),CLEARDIS    UPDATE GENERATED CODE\n         OC     CP36G+2(2),8(R9)\n         MVC    CP36G+4(2),WPLACE\n         MVZ    CP36G+4(1),VPLACE\n         BAL    R2,GENTXT6             GENERATE 6 BYTES\nCP36G    MVC    0(4,R10),0             *** GENERATED CODE ***\n         B      CP36E\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP38\n*\n***********************************************************************\n*\n         USING  CP38,R12\nCP38     LA     R4,CP38A\n         BAL    R3,OPDTEST\n         BAL    R4,TARITHM\n         B      CP38B\nCP38B    TM     20(R9),X'10'\n         BO     CP38A\n         TM     21(R9),X'08'\n         BZ     CP38C\n         CLI    0(R8),XFRSQBR\n         BNE    CP38F\n         TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?\n         BZ     CP38D                  NO, BRANCH\n         B      CP38E\n*\nCP38G    MVI    20(R9),X'A0'\n         NI     21(R9),X'03'\n         OI     21(R9),X'30'\nCP38H    LA     R9,20(R9)\n         OI     COMPFLGS,OPERAND\n         SH     R10,KH2\n         CLC    1(1,R10),99(R11)\n         BE     SPECTEST\n         LA     R11,324(,R11)\n         CLC    1(1,R10),99(R11)\n         BE     SPECTEST\n         SH     R11,KH614\n         B      SPECTEST\n*\nCP38F    BAL    R4,SERR1\n         DC     H'180'                 ERROR 180\n*\n         MVC    20(5,R9),API\nCP38C    TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?\n         BZ     CP38J                  NO, BRANCH\nCP38A    NI     COMPFLGS,255-NLOAD\n         CLI    0(R8),XFRSQBR\n         BNE    CP38K\n         TM     21(R9),X'30'\n         BM     CP38L\n         CLC    18(1,R9),17(R9)\n         BNE    CP38M\n         TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?\n         BZ     CP38N                  NO, BRANCH\n         B      CP38G\n*\nCP38M    TM     20(R9),X'10'\n         BO     CP38H\n         BAL    R4,SERR1\n         DC     H'179'                 ERROR 179\n*\n         B      CP38G\n*\nCP38K    LA     R9,5(,R9)\n         SR     R1,R1\n         IC     R1,13(,R9)\n         LA     R1,1(,R1)\n         STC    R1,13(,R9)\n         TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?\n         BOR    R5                     YES, RETURN TO SUBSTART\n         CLI    14(R9),X'01'\n         BNER   R5                     NO, BRANCH TO SUBSTART\n         MVC    WORKPL(2),3(R9)\n         LH     R0,WORKPL\n         SLL    R0,15(R1)\n         LTR    R0,R0\n         BNMR   R5                     NO, BRANCH TO SUBSTART\n         OI     COMPFLGS,SUBSCOPT\n         BR     R5                     RETURN TO SUBSTART\n*\nCP38J    TM     COMPFLGS,SUBSCOPT\n         BO     CP38O\n         BAL    R4,CP38P\nCP38O    TM     21(R9),X'30'\n         LA     R9,20(R9)\n         BM     CP38Q\n         BAL    R4,ROUTINE1\n         B      CP38R\n*\nCP38Q    BAL    R4,ROUTINE3\n         AH     R7,ONEENTRY\n         MVI    RII,X'01'\n         ST     R9,RUTI+32\n         MVI    0(R9),X'A8'\nCP38R    SH     R9,KH20\n         SR     R1,R1\n         IC     R1,16(R9)\n         LA     R1,4(R1)\n         STC    R1,16(R9)\n         TM     COMPFLGS,SUBSCOPT\n         BO     CP38A\n         AH     R1,WPLACE\n         STH    R1,CP38S+2             UPDATE GENERATED CODE\n         MVN    CP38S+1(1),VPLACE\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP38S    M      R14,0                  *** GENERATED CODE ***\n         TM     10(R9),X'40'\n         BO     CP38T\n         MVZ    CP38U+1(1),13(R9)\n         BAL    R2,GENTXT2             GENERATE 2 BYTES\nCP38U    AR     R0,R15                 *** GENERATED CODE ***\n         B      CP38A\n*\nCP38T    MVC    CP38V+2(2),13(R9)\n         MVC    CP38W+2(2),13(R9)\n         LA     R2,CP38V\n         BAL    R14,GENTXTS\n         DC     H'8'                   GENERATE 8 BYTES\n*\n         B      CP38A\n*\nCP38D    BAL    R4,CP38P\n         BAL    R4,CLEARRG\n         TM     21(R9),X'30'\n         BM     CP38X\n         SR     R1,R1\n         IC     R1,22(R9)\n         SLL    R1,3\n         STH    R1,CP38AA+2            UPDATE GENERATED CODE\n         MVC    CP38AB+2(2),23(R9)\n         NI     CP38AB+2,X'0F'\n         LA     R2,CP38AA\n         BAL    R14,GENTXTS\n         DC     H'12'                  GENERATE 12 BYTES\n*\n         AH     R7,ONEENTRY\n         OI     RII,X'01'\nCP38E    MVC    20(2,R9),CP38YA\n         STH    R7,SPBNST+2\n         OI     SPBNST+2,X'80'\n         MVC    22(3,R9),SPBNST+1\n         B      CP38H\n*\nCP38X    LR     R1,R7\n         AH     R1,ONEENTRY\n         STH    R1,CP38AC+2            UPDATE GENERATED CODE\n         STH    R1,CP38AD+2\n         STH    R1,WORKPL\n         BAL    R4,MAXCH\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP38AC   ST     R15,0(R10)             *** GENERATED CODE ***\n         LA     R9,20(R9)\n         BAL    R4,OPDREC\n         SH     R9,KH20\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP38AD   L      R15,0(R10)             *** GENERATED CODE ***\n         LA     R2,CP38AE\n         BAL    R14,GENTXTS\n         DC     H'4'                   GENERATE 4 BYTES\n*\n         B      CP38E\n*\nCP38L    TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?\n         BO     CP38G                  YES, BRANCH\n         MVC    CP38AF+1(1),18(R9)\n         LA     R2,CP38AF\n         BAL    R14,GENTXTS\n         DC     H'8'                   GENERATE 8 BYTES\n*\n         SH     R7,ONEENTRY\n         MVI    RII,X'00'\nCP38N    LH     R1,WPLACE\n         LA     R1,8(R1)\n         STH    R1,CP38AG+2            UPDATE GENERATED CODE\n         LA     R1,4(R1)\n         STH    R1,CP38AI+2\n         MVZ    VPLACE(1),13(R9)\n         TM     10(R9),X'40'\n         BZ     CP38AHA\n         MVZ    VPLACE(1),CP38AH+1\nCP38AHA  MVC    CP38AG+1(1),VPLACE     UPDATE GENERATED CODE\n         MVC    CP38AI+1(1),VPLACE\n         BO     CP38AL\n         TM     CP38AG+1,X'80'\n         BO     CP38AK\n         BAL    R4,ROUTINE8\n         AH     R7,ONEENTRY\n         SR     R14,R14\n         IC     R14,13(R9)\n         SRL    R14,4\n         TM     RII,X'01'\n         BZ     CP38AM\n         BAL    R4,ROUTINE9\n         B      CP38AL\n*\nCP38AM   OI     RII,X'01'\n         LA     R14,128(R14)\n         STC    R14,CP38AN+1\n         TM     COMPFLGS+2,NOTEST\n         BZ     CP38AO\n         STC    R14,CP38AP+1\n         BAL    R2,GENTXT2             GENERATE 2 BYTES\nCP38AP   LR     R0,R0                  *** GENERATED CODE ***\nCP38AO   MVI    CP38YB+1,X'12'         UPDATE GENERATED CODE\n         MVZ    13(1,R9),CP38AN+1\nCP38AK   LA     R1,20(R9)\n         ST     R1,RUTI+32\nCP38AL   LA     R2,CP38AG\n         TM     COMPFLGS+2,NOTEST\n         BO     CP38BA\n         BAL    R14,GENTXTS\nCP38YB   DC     H'16'                  GENERATE 16 BYTES\n*\nCP38BA   MVI    CP38YB+1,X'10'\n         MVC    20(5,R9),10(R9)\n         B      CP38H\n*\nCP38P    ST     R4,CP38YD\n         BAL    R4,OPDREC\n         TM     1(R9),X'01'\n         BO     CP38YE\n         BAL    R4,TRREIN\n         BAL    R2,GENTXT2             GENERATE 2 BYTES\n         LR     R15,R14                *** GENERATED CODE ***\nCP38YF   L      R4,CP38YD\n         BR     R4\n*\nCP38YE   LA     R3,CP38YG\n         BAL    R4,ROUTIN15\n         MVC    CP38YH+2(2),WPLACE\n         MVN    CP38YH+1(1),VPLACE\n         BAL    R2,GENTXT4\nCP38YH   L      R15,0                  *** GENERATED CODE ***\n         B      CP38YF\n*\nCP38YG   BAL    R4,ROUTINE8\n         MVN    CP38AH+1(1),VPLACE\n         BAL    R2,GENTXT2             GENERATE 2 BYTES\nCP38AH   LR     R15,R0                 *** GENERATED CODE ***\n         B      CP38YF\n*\nCP38V    A      R15,0(R10)             *** GENERATED CODE ***\nCP38W    ST     R15,0(R10)             *** GENERATED CODE ***\nCP38AA   L      R9,0(R11)              *** GENERATED CODE ***\nCP38AB   L      R8,0(R12)              *** GENERATED CODE ***\nCP38AE   BAL    R14,244(R13)           *** GENERATED CODE ***\nCP38AG   C      R15,0                  *** GENERATED CODE ***\n         BL     524(R13)               *** GENERATED CODE ***\nCP38AI   C      R15,0                  *** GENERATED CODE ***\n         BNL    524(R13)               *** GENERATED CODE ***\nCP38AN   LR     R0,R0                  *** GENERATED CODE ***\nCP38AF   CLI    0(R8),0                *** GENERATED CODE ***\n         BNE    536(R13)               *** GENERATED CODE ***\nCP38YA   DC     X'A038'\nCP38YD   DC     F'0'                   R4 SAVEAREA\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP41\n*\n***********************************************************************\n*\n         USING  CP41,R12\nCP41     LA     R4,CP41A\n         BAL    R3,OPDTEST\n         TM     1(R9),X'04'\n         BZ     CP41B\nCP41A    MVC    CP41C+1(1),0(R10)\n         BAL    R4,MOVEOPTK\n         MVC    0(1,R10),99(R11)\n         L      R11,DECAADD\n         LA     R11,290(,R11)\n         SH     R9,KH15\n         BAL    R4,MOVEOPTK\n         MVC    0(1,R10),0(R8)\n         TM     15(R9),X'10'\n         BO     CP41D\n         TM     16(R9),X'08'\n         BZ     CP41D\n         LA     R1,6\nCP41E    LA     R2,CP41Z-1(R1)\nCP41C    CLI    0(R2),0                UPDATED INSTRUCTION\n         BER    R5                     ZERO, BRANCH TO SUBSTART\n         BCT    R1,CP41E\n         BAL    R4,SERR1\n         DC     H'181'                 ERROR 181\n*\n         MVC    15(5,R9),API\n         BR     R5                     RETURN TO SUBSTART\n*\nCP41G    MVC    0(5,R9),API\n         B      CP41A\n*\nCP41B    BAL    R4,SERR3\n         DC     H'184'                 ERROR 184\n*\n         B      CP41G\n*\nCP41D    MVI    5(R9),X'00'\n         MVC    6(9,R9),5(R9)\n         MVI    13(R9),X'01'\n         SR     R1,R1\n         IC     R1,18(,R9)\n         SRL    R1,4\n         LA     R1,1(,R1)\n         STC    R1,12(R9)\n         NI     18(R9),X'0F'\n         TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?\n         BOR    R5                     YES, RETURN TO SUBSTART\n         MVI    11(R9),X'10'\n         TM     16(R9),X'30'\n         BNM    CP41H\n         AH     R7,ONEENTRY\n         LA     R9,15(,R9)\n         BAL    R4,OPDREC\n         SH     R9,KH15\n         SH     R7,ONEENTRY\n         SH     R7,ONEENTRY\nCP41H    TM     RII,X'01'\n         BO     CP41I\n         LA     R14,8\n         AH     R7,ONEENTRY\n         OI     RII,X'01'\n         B      CP41J\n*\nCP41I    BAL    R4,ROUTINE7\nCP41J    LA     R2,5(R9)\n         SLL    R14,2\n         ST     R2,RUTI(R14)\n         SLL    R14,2\n         STC    R14,CP41K+1            UPDATE GENERATED INSTRUCTION\n         STH    R7,SPBNST+2\n         MVZ    SPBNST+2(1),CP41K+1    UPDATE GENERATED INSTRUCTION\n         MVC    7(3,R9),SPBNST+1\n         MVC    5(2,R9),CP41L\n         NC     6(1,R9),16(R9)\n         OI     6(R9),X'30'\n         TM     16(R9),X'30'\n         BM     CP41M\n         LA     R3,CBVTAB+39\n         LR     R1,R8\n         S      R1,SOURCEB\n         STH    R1,NUMBBL+1\nCP41P    LA     R3,9(R3)\n         C      R3,SUTABCA\n         BNH    CP41N\n         ST     R9,CP41Q\n         LA     R9,15(,R9)\n         BAL    R4,ROUTINE1\n         LA     R1,4\n         AH     R1,WPLACE\n         STH    R1,WPLACE\n         B      CP41S\n*\nCP41N    CLC    1(3,R3),NUMBBL\n         BNE    CP41P\n         MVC    0(5,R9),4(R3)\n         MVI    14(R9),X'01'\n         TM     3(R9),X'80'\n         BZ     CP41R\n         OI     COMPFLGS,SUBSCOPT\nCP41R    MVC    WORKPL+1(3),0(R9)\n         L      R1,WORKPL\n         TM     0(R1),X'40'\n         BO     CP41U\n         IC     R1,3(R1)\n         SRA    R1,4\n         STC    R1,CP41V+1\n         MVZ    CP41V+1(1),CP41K+1     UPDATE GENERATED INSTRUCTION\n         BAL    R2,GENTXT2             GENERATE 2 BYTES\nCP41V    LR     R0,R0                  *** GENERATED CODE ***\n         BR     R5                     RETURN TO SUBSTART\n*\nCP41U    ST     R9,CP41Q\n         LR     R9,R1\n         BAL    R4,ROUTINE1\nCP41S    L      R9,CP41Q\n         MVC    CP41K+2(2),WPLACE\n         MVZ    CP41K+2(1),VPLACE\n         B      CP41X\n*\nCP41M    AH     R7,ONEENTRY\n         MVC    CP41K+2(2),CP41W       UPDATE GENERATED CODE\nCP41X    BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP41K    L      R0,0                   *** GENERATED CODE ***\n         BR     R5                     RETURN TO SUBSTART\n*\nCP41Z    DC     X'1E1F2E170629'\nCP41Q    DC     F'0'                   SAVE AREA FOR R9\nCP41W    DC     X'8004'                CODE UPDATES\nCP41L    DC     X'A003'                CODE UPDATES\n*\n***********************************************************************\n*\n*        END OF SOURCE RECOVERED FROM DISASMBLY\n*\n***********************************************************************\n*\n./ ADD NAME=IEX50002 0201-12230-12230-1200-01218-01218-00000-LEVEL\n         TITLE  'IEX50002 - CP6, CP40, CP43, CP45, CP47, CP49, CP81'\n*\n***********************************************************************\n*\n*        THIS SOURCE FOR IEX50002 WAS RECOVERED BY DISASSEMBLY OF\n*        THE CSECT IEX50002 IN LOAD MODULE IEX50\n*\n***********************************************************************\n*\nIEX50000 CSECT\n*\n*        NOTE -\n*        ALL THE CP PROGRAMS IN THIS CSECT IEX50002 ESTABLISH\n*        ADDRESSABILITY FOR BASE (R12) FROM THE FIRST CP IN THE\n*        CSECT WHICH IS CP6\n*        ALL SUBSEQUENT CPS OTHER THAN CP6 RESET BASE BACK TO\n*        CP6 BY LOADING R12. THIS IS ONLY DONE IN IEX50002, NO\n*        OTHER MODULES USE THIS TECHNIQUE\n*        ROUTINES AND DATA AREAS ARE SHARED ACROSS ALL THE CPS\n*        IN THIS CSECT WITH BRANCHES INTO AND OUT OF THE CPS\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP6\n*\n***********************************************************************\n*\n         CNOP   0,8\n         USING  CP6,R12\nCP6      TM     COMPFLGS,OPERAND\n         BZ     CP6A\n         BAL    R4,SERR4\n         DC     H'164'                 ERROR 164\n*\n         LA     R9,5(,R9)\nCP6A     BAL    R4,MOVEOPTK\n         MVC    0(1,R10),0(R8)\n         LA     R11,290(R11)\nCP6B     CLI    0(R10),X'18'\n         BNER   R5                     \u00ac=, RETURN TO SUBSTART\n         SH     R9,KH10\n         BAL    R4,MOVEOPDK\n         SR     R1,R1\n         IC     R1,CFSN\n         STC    R1,0(R9)\n         LA     R1,1(R1)\n         STC    R1,CFSN\n         IC     R1,SYSIN+95(R1)\n         STC    R1,1(R9)\n         BR     R5                     RETURN TO SUBSTART\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP40\n*\n***********************************************************************\n*\nCP40     L      R12,SCPTAB+4*6         R12 -> CP6\n         LA     R4,CP40A\n         BAL    R3,OPDTEST\n         TM     0(R9),X'08'\n         BO     CP40B\n         TM     1(R9),X'C0'\n         BZ     CP40C\n         TM     0(R9),X'10'\n         BO     CP40C\nCP40B    BAL    R4,SERR1\n         DC     H'190'                 ERROR 190\n*\nCP40E    MVC    0(5,R9),API\nCP40C    BAL    R4,TARITHM\n         B      CP40A                  +00 NO ERROR\n         B      CP40E                  +04 ERROR 163\n*\nCP40A    BAL    R4,MOVEOPTK\n         MVI    0(R10),X'2D'\n         TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?\n         BOR    R5                     YES, RETURN TO SUBSTART\n         TM     1(R9),X'30'\n         BNM    CP40F\n         TM     1(R9),X'20'\n         BO     CP40F\n         BAL    R4,ROUTINE1\n         LH     R1,WPLACE\n         LA     R1,4(R1)\n         STH    R1,CP40G+2\n         MVZ    CP40G+2(1),VPLACE\n         LA     R2,CP40G\n         BAL    R14,GENTXTS\n         DC     H'8'                   GENERATE 8 BYTES\n*\n         BAL    R4,OPDREC\n         MVC    2(1,R9),SPBNST+1\nCP40F    BAL    R4,CLEARRG\n         BAL    R4,CP40H\n         MVC    7(2,R9),9(R9)\nCP40I    BAL    R4,CP40H\n         AH     R7,ONEENTRY\n         STH    R7,WORKPL\n         MVC    11(2,R9),WORKPL\n         TM     6(R9),X'0C'\n         BZ     CP40J\nCP40K    L      R1,AOPTABE\n         CLC    0(1,R1),5(R9)\n         BH     CP40M\n         BE     CP40L\n         BAL    R4,NXTOPT\n         B      CP40K\n*\nCP40L    OI     6(R9),X'02'\n         MVI    WA2_B,X'00'\n         MVC    WA2_C,ZEROHW\n         BAL    R14,CP40Q\nCP40M    TM     6(R9),X'08'\n         BO     CP40R\n         B      CP40S\n*\nCP40R    AH     R7,ONEENTRY\n         STH    R7,WORKPL\n         TM     6(R9),X'F0'\n         BZ     CP40T\n         BO     CP40U\n         AH     R7,ONEENTRY\nCP40U    STH    R7,WORKPL+2\nCP40V    MVC    13(4,R9),WORKPL\n         BO     CP40W\n         AH     R7,ONEENTRY\nCP40S    TM     6(R9),X'02'\n         BZ     CP40W\n         AH     R7,ONEENTRY\n         STH    R7,WORKPL\n         MVC    17(2,R9),WORKPL\n         BAL    R14,CP40X\nCP40W    ST     R6,WA2_A+2\n         B      CP40J\n*\nCP40T    EX     R0,CP40V\n         MVI    18(R9),0\nCP40J    STH    R7,WORKPL\n         BAL    R4,MAXCH\n         BR     R5\n*\nCP40G    TM     0(R10),X'08'           *** GENERATED CODE ***\n         BO     548(R13)               *** GENERATED CODE ***\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP43\n*\n***********************************************************************\n*\nCP43     L      R12,SCPTAB+4*6         R12 -> CP6\n         LA     R4,CP43A\n         BAL    R3,OPDTEST\n         BAL    R4,TARITHM\n         B      CP43B                  +00\n         B      CP43A                  +04 ERROR\n*\nCP43B    TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?\n         BO     CP43A                  YES, BRANCH\n         LR     R1,R10\n         BCTR   R1,R0\n         CLI    0(R1),X'18'\n         BNE    CP43C\n         TM     11(R9),X'F2'\n         BZ     CP43D\nCP43C    L      R1,CP43E\n         L      R12,SCPTAB+4*20        R12 -> CP20\n         MVI    0(R10),X'16'\n         BR     R1\n*\nDJH1E43  LA     R10,1(R10)             ENTRY FROM CP20 VIA ADCON\n         MVI    0(R10),X'2D'\n         TM     0(R9),X'80'\n         BO     CP43F\n         AH     R7,ONEENTRY\nCP43F    CLI    0(R8),X'1C'\n         BE     CP43G\n         CLI    0(R8),X'19'\n         BE     CP43H\n         CLI    0(R8),X'1B'\n         BE     CP43P\n         OI     6(R9),X'01'\n         MVC    CP43I+2(2),7(R9)\n         BAL    R2,GENTXT4\nCP43I    L      R15,0(R12)             *** GENERATED CODE ***\n         TM     6(R9),X'F0'\n         BZ     CP43J\n         BAL    R14,CP43K\n         MVC    CP43L1+2(2),11(R9)\n         LA     R2,CP43L\n         BAL    R14,GENTXTS\n         DC     H'12'                  GENERATE 12 BYTES\n*\n         TM     6(R9),X'02'\n         BZ     CP43M\n         BAL    R14,CP40X\nCP43M    ST     R6,WA2_A+2\n         B      CP43N\n*\nCP43K    TM     6(R9),X'0A'\n         BNOR   R14\n         MVC    CP43Q+2(2),13(R9)\n         BAL    R2,GENTXT6\n         SR     R14,R14                *** GENERATED CODE ***\nCP43Q    ST     R14,0(R10)             *** GENERATED CODE ***\n         BR     R14\n*\nCP43J    LA     R14,CP43R\nCP43S    TM     6(R9),X'08'\n         BZR    R14\n         BAL    R2,GENTXT4\n         LA     R0,1                   *** GENERATED CODE ***\n         B      CP43K\n*\nCP43R    BAL    R2,GENTXT2\n         BALR   R15,R15                *** GENERATED CODE ***\n         B      CP43N\n*\nCP43H    TM     6(R9),X'F0'\n         BNO    CP43N\n         MVC    CP43T+2(2),11(R9)\n         LA     R2,CP43U\n         BAL    R14,GENTXTS\n         DC     H'10'                  GENERATE 10 BYTES\n*\n         MVI    GPBN+1,X'FF'\n         B      CP43N\n*\nCP43U    BALR   R14,R0                 *** GENERATED CODE ***\n         LA     R14,8(R14)             *** GENERATED CODE ***\nCP43T    ST     R14,0(R10)             *** GENERATED CODE ***\n*\nCP43P    BAL    R4,CP40H\n         A      R1,LATAB\n         MVC    0(4,R1),WA2_A+2\n         MVC    CP43V+2(2),11(R9)\n         MVC    CP43V+4(2),9(R9)\n         OI     CP43V+4,X'C0'\n         OI     CP43V+2,X'A0'\n         BAL    R2,GENTXT6             GENERATE 6 BYTES\nCP43V    MVC    0(4,R10),0(R12)        *** GENERATED CODE ***\n         BAL    R14,CP43K\n         B      CP43N\n*\nCP43G    TM     6(R9),X'01'\n         BO     CP43W\n         CLC    LN(2),9(R9)\n         BNE    CP43N\n         LH     R1,LN\n         SH     R1,KH8\n         STH    R1,LN\n         B      CP43N\n*\nCP43W    TM     6(R9),X'F0'\n         LA     R10,1(R10)\n         LA     R14,CP43X\n         BZ     CP43S\n         BAL    R14,CP43K\n         BAL    R4,CP43Y\n         STH    R1,CP43Z+4\n         OI     CP43Z+4,X'C0'\n         MVC    CP43Z+2(2),11(R9)\n         OI     CP43Z+2,X'A0'\n         BAL    R2,GENTXT6             GENERATE 6 BYTES\nCP43Z    MVC    0(4,R10),0(R12)        *** GENERATED CODE ***\n         B      CP49_X\n*\nCP43D    TM     11(R9),X'08'\n         BZ     CP43C\n         MVC    5(5,R9),0(R9)\n         LA     R9,5(R9)\n         B      CP43F\n*\nCP43L    BALR   R14,R0                 *** GENERATED CODE ***\n         LA     R14,10(R14)            *** GENERATED CODE ***\nCP43L1   ST     R14,0(R10)             *** GENERATED CODE ***\n         BR     R15\n*\nCP43E    DC     A(BIC2)                INTERNAL ENTRY TO CP20\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP45\n*\n***********************************************************************\n*\nCP45     L      R12,SCPTAB+4*6         R12 -> CP6\n         LA     R4,CP45A\n         BAL    R3,OPDTEST\n         BAL    R4,TARITHM\n         B      CP45B                  +00\n         B      CP45A                  +04 ERROR\n*\nCP45B    TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?\n         BO     CP45A                  YES, BRANCH\n         BAL    R4,OPDREC\n         TM     11(R9),X'F0'\n         BZ     CP45A\n         TM     1(R9),X'02'\n         BO     CP45C\n         BAL    R4,CP45D\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\n         L      R14,0                  *** GENERATED CODE ***\n         MVI    CP45F+1,X'EE'\n         BAL    R2,GENTXT2             GENERATE 2 BYTES\nCP45F    LTR    R14,R0                 *** GENERATED CODE ***\nCP45G    MVC    CP45H+2(2),20(R9)\n         TM     11(R9),X'F0'\n         BM     CP45K\n         LA     R9,5(R9)\n         BAL    R4,CP40H\n         SH     R9,KH5\n         MVC    CP45I+2(2),14(R9)\n         MVC    CP45J+2(2),16(R9)\n         OI     CP45J+2,X'A0'\n         LA     R2,CP45L\n         BAL    R14,GENTXTS            GENERATE 28 BYTES\n         DC     H'28'\n*\nCP45M    TM     1(R9),X'02'\n         BO     CP45N\n         TM     6(R9),X'02'\n         BZ     CP45P\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\n         BAL    R8,288(R13,0)          *** GENERATED CODE ***\nCP45N    TM     6(R9),X'02'\n         BZ     CP45Q\n         TM     11(R9),X'F0'\n         BM     CP45R\nCP45S    BAL    R4,CP45T\n         BAL    R2,GENTXTP4            GENERATE 4 BYTES\nCP45U    AD     R0,0                   *** GENERATED CODE ***\n         MVC    CP45V+2(2),CP45U+2\n         BAL    R2,GENTXTP4            GENERATE 4 BYTES\nCP45V    STD    R0,0                   *** GENERATED CODE ***\nCP45W    TM     11(R9),X'F0'\n         BM     CP45X\n         MVC    CP45XA+2(2),16(R9)     UPDATE GENERATED CODE\n         BAL    R2,GENTXT6             GENERATE 6 BYTES\nCP45XA   L      R15,0(R10)             *** GENERATED CODE ***\n         BR     R15\n*\n         MVC    WORKPL(2),14(R9)\n         BAL    R4,CP45XB\n         MVI    GPBN+1,X'FF'\n         B      CP45A\n*\nCP45Q    BAL    R2,GENTXT4             GENERATE 4 BYTES\n         BAL    R8,332(R13,0)          *** GENERATED CODE ***\nCP45P    TM     11(R9),X'F0'\n         BM     CP45XC\nCP45XD   BAL    R4,CP45T\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP45XF   A      R14,0                  *** GENERATED CODE ***\n         MVC    CP45XG+2(2),CP45XF+2\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP45XG   ST     R14,0                  *** GENERATED CODE ***\n         B      CP45W\n*\nCP45C    BAL    R4,CP45D\n         BAL    R2,GENTXTP4            GENERATE 4 BYTES\n         LD     R0,0                   *** GENERATED CODE ***\n         MVI    CP45XH+1,0\n         BAL    R2,GENTXTP2            GENERATE 2 BYTES\nCP45XH   LTDR   R0,R0                  *** GENERATED CODE ***\n         B      CP45G\n*\nCP45K    TM     11(R9),X'20'\n         BO     CP45XI\n         BAL    R2,GENTXT6             GENERATE 6 BYTES\n         BZ     528(R13)               *** GENERATED CODE ***\n         BALR   R15,R0                 *** GENERATED CODE ***\n         LA     R2,CP45XJ\n         BAL    R14,GENTXTS            GENERATE 8 BYTES\n         DC     H'8'\n*\n         B      CP45M\n*\nCP45XI   LA     R2,CP45L\n         BAL    R14,GENTXTS            GENERATE 18 BYTES\n         DC     H'18'\n*\n         B      CP45M\n*\nCP45R    MVC    CP45XK+2(2),18(R9)\n         BAL    R2,GENTXTP4            GENERATE 4 BYTES\nCP45XK   STD    R0,0(R10)              *** GENERATED CODE ***\n         B      CP45A\n*\nCP45XC   MVC    CP45XL+2(2),18(R9)\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP45XL   ST     R14,0(R10)             *** GENERATED CODE ***\n         B      CP45A\n*\nCP45L    BALR   R15,R0                 *** GENERATED CODE ***\n         BNZ    8(R15)                 *** GENERATED CODE ***\n         SR     R15,R15                *** GENERATED CODE ***\n         BCTR   R15,R0                 *** GENERATED CODE ***\nCP45XJ   SLL    R15,1                  *** GENERATED CODE ***\nCP45H    ST     R15,0(R10)             *** GENERATED CODE ***\nCP45I    L      R15,0(R12)             *** GENERATED CODE ***\nCP45J    XI     0(R10),X'80'           *** GENERATED CODE ***\n         BMR    R15                    *** GENERATED CODE ***\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP47\n*\n***********************************************************************\n*\nCP47     L      R12,SCPTAB+4*6         R12 -> CP6\n         LA     R4,CP47A\n         BAL    R3,OPDTEST\n         BAL    R4,TARITHM\n         B      CP47B                  +00\n         B      CP47A                  +04 ERROR\n*\nCP47B    TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?\n         BO     CP47A                  YES, BRANCH\n         TM     16(R9),X'F0'\n         BZ     CP47C\n         BAL    R4,OPDREC\n         CLI    0(R8),X'1C'\n         BNE    CP47D\n         TM     16(R9),X'02'\n         BO     CP47D\n         MVC    CP47E+2(2),25(R9)      UPDATE GENERATED CODE\n         OI     CP47E+2,X'A0'\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP47E    XI     0(R10),X'E0'           *** GENERATED CODE ***\nCP47D    TM     16(R9),X'F0'\n         BM     CP47F\n         LA     R9,5(R9)\n         TM     6(R9),X'02'\n         BO     CP47G\n         BAL    R4,CP45T\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\n         L      R14,0                  *** GENERATED CODE ***\nCP45X    SH     R9,KH5\n         TM     1(R9),X'02'\n         BO     CP47GA\n         BAL    R4,CP45D\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\n         C      R14,0                  *** GENERATED CODE ***\n         B      CP47H\n*\n         BAL    R2,GENTXT2             GENERATE 2 BYTES\n         CR     R14,R0                 *** GENERATED CODE ***\nCP47H    MVC    CP47I+2(2),25(R9)\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP47I    IC     R8,0(R10)              *** GENERATED CODE ***\n         LA     R9,5(R9)\n         B      CP47J\n*\nCP47GA   TM     0(R9),X'40'\n         BO     CP47K\n         BAL    R4,CP45D\n         BAL    R2,GENTXTP4            GENERATE 4 BYTES\n         LD     R2,0                   *** GENERATED CODE ***\n         B      CP47L\n*\n         BAL    R2,GENTXTP2            GENERATE 2 BYTES\n         LDR    R2,R0                  *** GENERATED CODE ***\nCP47L    BAL    R2,GENTXT4             GENERATE 4 BYTES\n         BAL    R8,288(R13)            *** GENERATED CODE ***\n         BAL    R2,GENTXTP2            GENERATE 2 BYTES\n         CDR    R0,R2                  *** GENERATED CODE ***\n         B      CP47H\n*\nCP47G    BAL    R4,CP45T\n         BAL    R2,GENTXTP4            GENERATE 4 BYTES\n         LD     R6,0                   *** GENERATED CODE ***\n         SH     R9,KH5\n         TM     1(R9),X'02'\n         BO     CP47M\n         BAL    R4,TRINRE\nCP47M    BAL    R4,CP45D\n         BAL    R2,GENTXTP4            GENERATE 4 BYTES\n         CD     R6,0                   *** GENERATED CODE ***\n         B      CP47H\n*\n         BAL    R2,GENTXTP2            GENERATE 4 BYTES\n         CDR    R6,R0                  *** GENERATED CODE ***\n         B      CP47H\n*\nCP47F    MVC    CP47N+2(2),25(R9)\n         LH     R1,ONEENTRY\n         AH     R1,CP47N+2\n         STH    R1,CP47N+2\n         TM     1(R9),X'02'\n         BO     CP47P\n         TM     11(R9),X'02'\n         BZ     CP47P\n         BAL    R4,TRINRE\nCP47P    BAL    R4,CP45D\n         B      CP47Q\n*\n         DC     X'0000'\nCP47R    DC     X'0000'\n         NOP    0\n         B      CP47S\n*\n         DC     X'0000'\n*\nCP47S    TM     1(R9),X'02'\n         MVZ    CP47N+1(1),3(R9)\n         BO     CP47T\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP47N    ST     R0,0(R10)              *** GENERATED CODE ***\nCP47U    MVI    0(R9),X'C0'\n         MVC    3(2,R9),CP47N+2\n         MVC    2(1,R9),SPBNST+1\n         MVI    GPBN+1,X'FF'\n         LA     R9,5(R9)\n         TM     6(R9),X'02'\n         BO     CP47V\n         BAL    R4,CP45T\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\n         L      R14,0                  *** GENERATED CODE ***\nCP47W    LA     R1,12\n         TM     GPBN+1,X'FF'\n         BO     CP47Y\n         LA     R1,4(R1)\n         MVI    GPBN+1,X'FF'\nCP47Y    LA     R2,CP47ZB\n         STH    R1,CP47ZA+2\n         MVC    CP47ZC+2(2),16(R9)\n         BAL    R14,GENTXTS            GENERATE 14 BYTES\n         DC     H'14'\n*\n         TM     6(R9),X'02'\n         BO     CP47ZD\n         MVC    CP47ZE+2(2),18(R9)\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP47ZE   L      R14,0(R10)             *** GENERATED CODE ***\n         B      CP45XD\n*\nCP47ZD   MVC    CP47ZF+2(2),18(R9)\nCP47ZG   BAL    R2,GENTXTP4            GENERATE 4 BYTES\nCP47ZF   LD     R0,0(R10)              *** GENERATED CODE ***\n         B      CP45S\n*\nCP47V    BAL    R4,CP45T\n         BAL    R2,GENTXTP4            GENERATE 4 BYTES\n         LD     R0,0                   *** GENERATED CODE ***\n         B      CP47W\n*\nCP47T    MVC    CP47ZH+1(3),CP47N+1\n         BAL    R2,GENTXTP4            GENERATE 4 BYTES\nCP47ZH   STD    R0,0(R10)              *** GENERATED CODE ***\n         B      CP47U\n*\nCP47Q    LH     R1,ONEENTRY\n         BCTR   R1,R0\n         STC    R1,CP47ZI+1\n         MVC    CP47ZI+4(2),CP47R\n         MVC    CP47ZI+2(2),CP47N+2\n         OI     CP47ZI+2,X'A0'\n         BAL    R2,GENTXT6             GENERATE 6 BYTES\nCP47ZI   MVC    0(1,R10),0             *** GENERATED CODE ***\n         B      CP47U\n*\nCP47K    TM     11(R9),X'02'\n         BO     CP47ZJ\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\n         BAL    R8,288(R13)            *** GENERATED CODE ***\nCP47ZJ   BAL    R4,CP45D\n         BAL    R2,GENTXTP4            GENERATE 4 BYTES\n         CD     R0,0                   *** GENERATED CODE ***\n         B      CP47H\n*\nCP47ZB   BALR   R15,R0                 *** GENERATED CODE ***\n         LA     R15,12(R15)            *** GENERATED CODE ***\nCP47ZC   ST     R15,0(R10)             *** GENERATED CODE ***\nCP47ZA   B      0(R15)                 *** GENERATED CODE ***\n*\nCP47C    LA     R9,5(R9)\n         MVI    CP47ZK+1,X'70'\n         MVI    CP47ZL+1,X'E7'\n         BAL    R4,CP45D\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP47ZK   L      R0,0                   *** GENERATED CODE ***\n         B      CP47ZM\n*\nCP47ZM   BAL    R2,GENTXT2             GENERATE 2 BYTES\nCP47ZL   LTR    R14,R0                 *** GENERATED CODE ***\n         TM     COMPFLGS+2,NOTEST\n         BO     CP47ZN\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\n         BZ     528(R13)               *** GENERATED CODE ***\nCP47ZN   TM     11(R9),X'02'\n         BZ     CP47ZP\n         MVC    CP47ZQ+2(2),18(R9)\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP47ZQ   ST     R14,0(R10)             *** GENERATED CODE ***\nCP47ZP   SH     R9,KH5\n         BAL    R4,CP45D\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\n         A      R14,0                  *** GENERATED CODE ***\n         B      CP47ZR\n*\n         BAL    R2,GENTXT2             GENERATE 2 BYTES\n         AR     R14,R0                 *** GENERATED CODE ***\nCP47ZR   LA     R9,10(R9)\n         BAL    R4,CP45D\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\n         S      R14,0                  *** GENERATED CODE ***\n         B      CP47ZS\n*\n         BAL    R2,GENTXT2             GENERATE 2 BYTES\n         SR     R14,R0                 *** GENERATED CODE ***\nCP47ZS   MVC    CP47ZT+1(1),CP47ZL+1\n         BAL    R2,GENTXT6             GENERATE 6 BYTES\n         SRDA   R14,32                 *** GENERATED CODE ***\nCP47ZT   DR     R14,R0                 *** GENERATED CODE ***\n         BAL    R2,GENTXT2             GENERATE 2 BYTES\n         LR     R0,R15                 *** GENERATED CODE ***\n         CLI    0(R8),X'1C'\n         BE     CP43X\n         OI     6(R9),X'01'\n         MVC    CP47ZU+2(2),7(R9)\n         BAL    R2,GENTXT6             GENERATE 6 BYTES\nCP47ZU   L      R15,0(R12)             *** GENERATED CODE ***\n         BALR   R15,R15                *** GENERATED CODE ***\n         B      CP47ZW\n*\nCP43X    BAL    R4,CP43Y\n         STH    R1,CP47ZV+2\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP47ZV   L      R15,0(R12)             *** GENERATED CODE ***\n         MVC    WORKPL(2),7(R9)\n         BAL    R4,CP45XB\n         MVC    CP47YA+2(2),11(R9)\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP47YA   ST     R15,0(R10)             *** GENERATED CODE ***\n         TM     6(R9),X'08'\n         BZ     CP47ZW\n         BAL    R4,ROUTINE7\n         STH    R7,SPBNST+2\n         MVC    17(3,R9),SPBNST+1\n         MVC    15(2,R9),CP47YB\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\n         LTR    R0,R0                  *** GENERATED CODE ***\n         BNPR   R15                    *** GENERATED CODE ***\n         TM     6(R9),X'02'\n         MVI    CP47YC,X'10'\n         BO     CP47YD\nCP47YE   BAL    R4,CP40H\n         BAL    R4,CP47YF\nCP47YG   LA     R1,15(R9)\n         ST     R1,RUTI\n         B      CP47ZW\n*\nCP47YH   BAL    R4,CP40H\n         STH    R1,CP47YI+2            UPDATE GENERATED CODE\n         BAL    R2,GENTXT6             GENERATE 6 BYTES\nCP47YI   L      R15,0(R12)             *** GENERATED CODE ***\n         BR     R15                    *** GENERATED CODE ***\n*\n         BAL    R4,CP40H\n         BAL    R4,CP47YF\n         B      CP47YJ\n*\nCP47YK   L      R1,LATAB\n         AH     R1,CP47YI+2\n         ST     R6,0(R1)\n         B      CP47YG\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP49\n*\n***********************************************************************\n*\nCP49     L      R12,SCPTAB+4*6         R12 -> CP6\n         LA     R4,CP49A\n         BAL    R3,OPDTEST\n         BAL    R4,ARRTEST1\n         TM     1(R9),X'03'\n         BO     CP49B\n         BAL    R4,SERR2\n         DC     H'182'                 ERROR 182\n*\n         B      CP49A\n*\nCP49B    TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?\n         BO     CP49A                  YES, BRANCH\n         BAL    R4,OPDREC\n         BAL    R4,CP45D\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\n         TM     0,X'01'                *** GENERATED CODE ***\nCP47J    LA     R9,5(R9)\n         TM     6(R9),X'02'\n         BZ     CP49C\n         MVC    CP49D+2(2),17(R9)\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP49D    L      R15,0(R10)             *** GENERATED CODE ***\n         CLI    0(R10),X'1B'\n         BE     CP49E\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\n         EX     R8,274(R13)            *** GENERATED CODE ***\n         B      CP49F\n*\nCP49E    BAL    R2,GENTXT2             GENERATE 2 BYTES\n         BOR    R15                    *** GENERATED CODE ***\nCP49F    CLI    0(R8),X'1C'\n         BNE    CP49H\n         BAL    R4,CP43Y\n         STH    R1,CP49G+2\n         BAL    R2,GENTXT6             GENERATE 6 BYTES\nCP49G    L      R15,0(R12)             *** GENERATED CODE ***\n         BR     R15                    *** GENERATED CODE ***\n*\n         B      CP49_X\n*\nCP49H    BAL    R14,CP40X\nCP49I    ST     R6,WA2_A+2\n         OI     6(R9),X'01'\n         B      CP47ZW\n*\nCP49C    CLI    0(R8),X'1C'\n         BE     CP49J\n         MVC    CP49K+2(2),7(R9)\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP49K    L      R15,0(R12)             *** GENERATED CODE ***\n         CLI    0(R10),X'1B'\n         BE     CP49L\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\n         EX     R8,274(R13)            *** GENERATED CODE ***\n         B      CP49M\n*\nCP49L    BAL    R2,GENTXT2             GENERATE 2 BYTES\n         BOR    R15                    *** GENERATED CODE ***\nCP49M    B      CP49I\n*\nCP49J    BAL    R4,CP43Y\n         STH    R1,CP49N+2\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP49N    L      R15,0(R12)             *** GENERATED CODE ***\n         CLI    0(R10),X'1B'\n         BE     CP49P\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\n         EX     R8,274(R13)            *** GENERATED CODE ***\n         B      CP49_X\n*\nCP49P    BAL    R2,GENTXT2             GENERATE 2 BYTES\n         BER    R15                    *** GENERATED CODE ***\nCP49_X   MVC    WORKPL(2),7(R9)\n         BAL    R4,CP45XB\n         TM     6(R9),X'02'\n         BZ     CP47ZW\n         MVI    CP47YC,X'00'\n         B      CP47YD\n*\nCP49Q    MVC    CP49R+2(2),17(R9)\n         LA     R2,CP49S\n         TM     WA2_B,X'01'\n         BO     CP49T\n         MVI    CP49U+3,X'08'          UPDATE GENERATED CODE\n         BAL    R14,GENTXTS            GENERATE 10 BYTES\n         DC     H'10'\n*\n         B      CP47ZW\n*\nCP49T    BAL    R4,CP40H\n         STH    R1,CP49V+2\n         MVI    CP49U+3,X'0E'\n         BAL    R14,GENTXTS            GENERATE 16 BYTES\n         DC     H'16'\n*\n         B      CP47YJ\n*\nCP49W    BAL    R4,CP47YF\n         B      CP47ZW\n*\nCP49S    BALR   R14,R0                 *** GENERATED CODE ***\nCP49U    LA     R14,0(R14)             *** GENERATED CODE ***\nCP49R    ST     R14,0(R10)             *** GENERATED CODE ***\nCP49V    L      R15,0(R12)             *** GENERATED CODE ***\n         BR     R15                    *** GENERATED CODE ***\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP81\n*\n***********************************************************************\n*\nCP81     L      R12,SCPTAB+4*6         R12 -> CP6\n         TM     COMPFLGS,OPERAND\n         BO     CP81A\nCP81B    TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?\n         BZ     CP81C                  NO, BRANCH\nCP81D    BCTR   R10,R0\n         SR     R1,R1\n         TM     6(R9),X'02'\n         BZ     CP81E\n         MVC    WORKPL(2),23(R9)\n         LH     R1,WORKPL\nCP81E    LA     R9,20(R1,R9)\n         MVI    GPBN+1,X'FF'\n         BR     R5                     RETURN TO SUBSTART\n*\nCP81A    BAL    R4,PLPRST\n         LA     R9,5(R9)\n         B      CP81B\n*\nCP81C    MVC    WORKPL(2),11(R9)\n         LH     R7,WORKPL\n         SH     R7,ONEENTRY\n         TM     0(R9),X'20'\n         BZ     CP81F\n         SH     R7,ONEENTRY\nCP81F    TM     6(R9),X'02'\n         BZ     CP81G\n         LA     R1,CBVTAB+39           ### CHECK ###\n         L      R2,SUTABCA\nCP81H    CR     R1,R2\n         BE     CP81I\n         CLC    0(1,R2),5(R9)\n         BL     CP81I\n         SH     R2,KH9\n         B      CP81H\n*\nCP81I    ST     R2,SUTABCA\n         MVI    CP81J+1,X'0A'\n         TM     6(R9),X'F0'\n         BNZ    CP81K\n         MVI    CP81J+1,X'1A'\nCP81K    MVC    WORKPL(2),23(R9)\n         LH     R14,WORKPL\n         LA     R14,20(R14,R9)\n         TM     6(R9),X'04'\n         BO     CP81G\nCP81L    SH     R14,KH5\n         TM     2(R14),X'FF'\n         BZ     CP81G\n         TM     CP81J+1,X'70'\n         BNO    CP81M\n         LA     R14,25(R9)\nCP81M    TM     0(R14),X'40'\n         BZ     CP81N\n         MVC    CP81J+2(2),3(R14)\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP81J    L      R0,0(R10)              *** GENERATED CODE ***\nCP81N    LH     R1,CP81J\n         LA     R1,16(R1)\n         STH    R1,CP81J\n         B      CP81L\n*\nCP81G    MVI    CII+1,X'07'\n         MVC    RII(2),ZEROHW\n         TM     6(R9),X'08'\n         BO     CP81P\n         TM     6(R9),X'05'\n         BZ     CP81D\nCP81Q    MVC    CP81R+2(2),11(R9)\n         BAL    R2,GENTXT6             GENERATE 6 BYTES\nCP81R    L      R15,0(R10)             *** GENERATED CODE ***\n         BR     R15                    *** GENERATED CODE ***\n*\n         BAL    R4,CP43Y\n         BAL    R4,CP81S\n         B      CP81D\n*\nCP81P    TM     6(R9),X'F0'\n         BNZ    CP81Q\n         TM     15(R9),X'40'\n         BZ     CP81T\n         MVC    CP81U+2(2),18(R9)\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP81U    L      R0,0(R10)              *** GENERATED CODE ***\nCP81T    MVC    CP81UA+2(2),9(R9)\n         BAL    R2,GENTXT6             GENERATE 6 BYTES\nCP81UA   L      R15,0(R12)             *** GENERATED CODE ***\n         BCTR   R0,R15                 *** GENERATED CODE ***\n         B      CP81Q\n*\nCP47YB   DC     X'8031'\nCP43A    LA     R9,5(R9)\n         B      CP43N\n*\nCP47A    LA     R9,5(R9)\nCP49A    LA     R9,5(R9)\nCP47ZW   BCTR   R10,R0\nCP43N    CLI    0(R8),X'25'\n         BNE    CP81WA\n         MVI    GPBN+1,X'FF'\n         BR     R5                     RETURN\n*\nCP81WA   CLI    0(R8),X'1C'\n         BNE    CP81WB\n         MVI    GPBN+1,X'FF'\n         SH     R11,KH290\n         BCTR   R10,R0\nCP45A    BCTR   R10,R0\nCP81WB   LA     R10,1(R10)\n         MVC    0(1,R10),0(R8)\n         BR     R5\n*\nCP47YF   MVC    WORKPL(2),9(R9)\nCP45XB   LH     R1,WORKPL\nCP81S    A      R1,LATAB\n         ST     R6,0(R1)\n         BR     R4\nCP40H    ST     R4,CP81SA\n         BAL    R4,LATRES\n         MVC    9(2,R9),LN\n         L      R4,CP81SA\n         BR     R4\n*\nCP43Y    MVC    WORKPL(2),7(R9)\n         LH     R1,WORKPL\n         LA     R1,4(R1)\n         BR     R4\n*\nCP40X    MVC    CP81WE+2(2),17(R9)\n         MVC    CP81WE+4(2),7(R9)\n         OI     CP81WE+2,X'A0'\n         OI     CP81WE+4,X'C0'\n         BAL    R2,GENTXT6             GENERATE 6 BYTES\nCP81WE   MVC    0(4,R10),0(R12)        *** GENERATED CODE ***\n         BR     R14\n*\nCP45T    LA     R9,5(R9)\n         ST     R4,CP81SA\n         TM     0(R9),X'20'\n         BO     CP81WF\n         BAL    R4,ROUTINE1\n         B      CP81WG\n*\nCP81WF   BAL    R4,ROUTINE3\n         AH     R7,ONEENTRY\nCP81WG   SH     R9,KH5\nCP81WH   L      R4,CP81SA\n         MVC    6(2,R4),WPLACE\n         MVZ    6(1,R4),VPLACE\n         BR     R4\n*\nCP81SA   DC     F'0'                    SAVEAREA FOR R4\n*\nCP45D    ST     R4,CP81SA\n         LA     R4,CP81WH\n         BAL    R3,ROUTIN15\n         L      R4,CP81SA\n         LA     R4,12(R4)\n         MVN    5(1,R4),VPLACE\n         TM     1(R9),X'02'\n         BO     ROUTIN12\n         B      ROUTINE8\n*\nCP81WI   BAL    R4,NXTOPT\nCP47YD   MVI    GPBN+1,X'FF'\n         L      R2,AOPTABE\n         CLC    5(1,R9),0(R2)\n         BE     CP81WJ\n         OI     20(R9),X'01'\n         B      CP81WK\n*\nCP81WJ   MVZ    2(1,R2),CP81WL\n         LA     R1,CBVTAB+39\nCP81WM   LA     R1,9(R1)\n         C      R1,SUTABCA\n         BH     CP81WN\n         CLC    11(3,R2),1(R1)\n         BNE    CP81WM\n         CLC    0(1,R2),0(R1)\n         BNE    CP81WP\nCP81WQ   MVN    CP81WL(1),10(R2)\n         SR     R3,R3\n         IC     R3,CP81WL\n         L      R4,CP81WR\n         SRL    R4,0(R3)\n         STH    R4,WORKPL\n         OC     7(2,R1),WORKPL\n         SLL    R3,2\n         LA     R3,20(R3)\n         AH     R3,2(R2)\n         STH    R3,2(R2)\n         BAL    R3,CP81WS\n         DC     H'7'\n*\n         AR     R1,R11\n*\nCP47YC   DC     X'0040'\n         CLC    ZEROHW(2),5(R2)\n         BE     CP81WI\n         TM     25(R9),X'02'\n         BZ     CP81WT\n         BAL    R3,CP81WS\n*\n         DC     X'0004'\n         AR     R1,R11\n*\n         DC     X'8080'\n*\n         B      CP81WI\n*\nCP81WT   OI     25(R9),X'02'\n         TM     10(R2),X'80'\n         BZ     CP81WU\n         BAL    R2,GENTXT2             GENERATE 2 BYTES\n         SR     R8,R8                  *** GENERATED CODE ***\n         L      R2,CP81WV\nCP81WU   BAL    R3,CP81WS\n*\n         DC     X'0004'\n*\n         LR     R1,R11\n*\n         DC     X'8080'\n*\n         B      CP81WI\n*\nCP81WN   LA     R3,SUTABC+L'SUTABC\n         CR     R1,R3\n         BNL    CP81WI\n         ST     R1,SUTABCA\n         MVC    1(3,R1),11(R2)\n         MVC    7(2,R1),ZEROHW\n         LA     R3,4\n         AH     R3,2(R2)\n         STH    R3,WA2_B+2\n         MVC    WA2_B+1(1),1(R2)\nCP81YA   MVC    0(1,R1),5(R9)\nCP81WK   STM    R1,R2,CP81WV\n         CLC    WA2_C,KH5\n         BE     CP81YB\n         TM     25(R9),X'02'\n         BZ     CP81YC\n         BAL    R4,ROUTINE1\n         MVC    CP81YD+2(2),WPLACE\n         MVZ    CP81YD+2(1),VPLACE\n         MVZ    CP81YE+1(1),CP47YC\n         LA     R2,CP81YF\n         BAL    R14,GENTXTS            GENERATE CODE\n         DC     H'8'                   GENERATE 8 BYTES\n*\n         TM     6(R9),X'08'\n         BZ     CP81YC\n         MVI    WA2_B,X'01'\n         MVC    CP81YG+2(2),13(R9)\n         LA     R2,CP81YH\n         BAL    R14,GENTXTS            GENERATE CODE\n         DC     H'10'                  GENERATE 10 BYTES\n*\nCP81YC   TM     6(R9),X'04'\n         BO     CP81YI\nCP81YB   TM     20(R9),X'01'\n         BO     CP81YJ\n         TM     CP47YC,X'70'\n         BO     CP81YI\n         BAL    R4,ROUTINE7\n         SLL    R14,4\n         STC    R14,CP47YC\n         B      CP81YK\n*\nCP81YL   AH     R7,ONEENTRY\nCP81YK   BAL    R14,CP40Q\n         STH    R7,SPBNST+2\n         MVC    27(3,R9),SPBNST+1\n         MVZ    28(1,R9),CP47YC\n         LA     R3,4(R7)\n         STH    R3,CP81YM+2\n         LA     R7,8(R7)\n         SH     R7,ONEENTRY\n         SR     R3,R3\n         IC     R3,CP47YC\n         SRL    R3,2\n         LA     R4,25(R9)\n         ST     R4,RUTI(R3)\n         LM     R1,R2,CP81WV\n         LA     R3,RUTI+1(R3)\n         MVC    4(3,R1),0(R3)\n         MVC    CP81YNA+1(1),CP47YC\n         LR     R3,R1\n         LA     R1,WA2_B+1\n         BAL    R4,CP81YN\nCP81YNA  L      R0,0\n         LR     R1,R3\n         B      CP81WQ\n*\nCP81YI   SR     R14,R14\n         IC     R14,CP47YC\n         SRL    R14,4\n         BAL    R4,ROUTINE9\n         TM     20(R9),X'01'\n         BZ     CP81YL\nCP81YJ   TM     6(R9),X'F0'\n         BNZ    CP49Q\n         TM     WA2_B,X'01'\n         BO     CP47YH\n         B      CP47YE\n*\nCP81YF   LR     R15,R8\nCP81YD   M      R14,0\nCP81YE   AR     R0,R15\nCP81YH   LR     R15,R8\nCP81YG   M      R14,0(R10)\nCP81YM   ST     R15,0(R10)\nCP81WP   MVC    WORKPL(4),3(R1)\n         L      R3,WORKPL\n         MVC    WA2_B+1(3),2(R3)\n         B      CP81YA\n*\nCP40Q    BAL    R4,MOVEOPDK\n         MVC    0(20,R9),5(R9)\n         LH     R3,WA2_C\n         LA     R3,5(R3)\n         STH    R3,WA2_C\n         MVC    20(5,R9),CP81YQ\n         BR     R14\n*\nCP81YN   STM    R2,R4,CP81WV\n         ST     R9,CP81YR+2\n         LR     R9,R1\n         SH     R9,KH2\n         BAL    R4,ROUTINE1\n         L      R2,CP81YS+2\n         MVC    2(2,R2),WPLACE\n         MVZ    2(1,R2),VPLACE\n         BAL    R14,GENTXTS            GENERATE CODE\n         DC     H'4'                   GENERATE 4 BYTES\n*\n         LM     R2,R4,CP81WV\n         L      R9,CP81YR+2\n         B      4(R4)\n*\nCP81WS   LR     R1,R2\n         AH     R1,0(R3)\n         CLC    ZEROHW(2),1(R1)\n         BE     6(R3)\n         MVC    CP81YT+1(1),5(R3)\n         MVC    CP81YU(2),3(R3)\n         OI     CP81YU+1,X'0F'\nCP81YT   TM     10(R2),X'00'\n         BO     CP81YV\n         MVC    CP81YU(1),2(R3)\nCP81YV   CLC    366(2,R5),1(R1)\n         BE     CP81YW\n         BAL    R4,CP81YN\n         L      R15,0\n         LA     R1,1(R2)\n         BAL    R4,CP81YN\n         M      R14,0\n         BAL    R2,GENTXT2             GENERATE 2 BYTES\nCP81YU   AR     R0,R15                 *** GENERATED CODE ***\n         LM     R2,R3,CP81WV\n         B      6(R3)\n*\nCP81YW   LA     R1,1(R2)\n         MVC    CP81ZA(2),CP81YU\n         OI     CP81ZA,X'40'\n         NI     CP81ZA+1,X'F0'\n         BAL    R4,CP81YN\nCP81ZA   L      R0,0\n         B      6(R3)\n*\nCP47YJ   MVC    WORKPL(2),23(R9)\n         LH     R1,WORKPL\n         LA     R1,15(R1,R9)\nCP81ZB   TM     0(R1),X'02'\n         BZ     CP81ZC\n         ST     R1,CP81WV\n         MVC    WORKPL(2),3(R1)\n         NI     WORKPL,X'0F'\n         LH     R2,WORKPL\n         STH    R2,CP81ZD+2\n         STH    R2,CP81ZE+2\n         LA     R4,8(R2)\n         SH     R4,ONEENTRY\n         STH    R4,WORKPL\n         BAL    R4,MAXCH\n         LA     R2,4(R2)\n         TM     0(R1),X'40'\n         BO     CP81ZF\n         STH    R2,CP81ZG+2\n         MVZ    CP81ZG+1(1),3(R1)\n         BAL    R2,GENTXT4             GENERATE 4 BYTES\nCP81ZG   A      R0,0(R10)              *** GENERATED CODE ***\n         B      CP81ZH\n*\nCP81ZF   STH    R2,CP81ZI+2\n         LA     R2,CP81ZD\n         BAL    R14,GENTXTS            GENERATE CODE\n         DC     H'12'                  GENERATE 12 BYTES\n*\nCP81ZH   L      R1,CP81WV\nCP81ZC   SH     R1,KH5\n         TM     2(R1),X'FF'\n         BNZ    CP81ZB\n         TM     6(R9),X'F0'\n         BZ     CP47YK\n         B      CP49W\n*\n         DC     0F'0'\nCP81ZD   L      R14,0(R10)             *** GENERATED CODE ***\nCP81ZI   A      R14,0(R10)             *** GENERATED CODE ***\nCP81ZE   ST     R14,0(R10)             *** GENERATED CODE ***\nCP81WR   DC     X'00008000'\nCP81WV   BNZ    594(,R4)               *** GENERATED CODE ***\n         SR     R15,R15                *** GENERATED CODE ***\nCP81YS   ST     R15,CP47ZG+2\nCP81YR   L      R6,CP6B\nWA2_A    MVC    0(4,R6),220(R12)\nWA2_B    B      614(,R4)\nCP81WL   DC     X'00'\nCP81YQ   DC     X'80'                  *\n         DC     X'31'                  |\n         DC     X'00'                  |\nWA2_C    DC     H'0'                   V\n*\n***********************************************************************\n*\n*        END OF IEX50002\n*\n***********************************************************************\n*\n./ ADD NAME=IEX50003 0201-12230-12230-1200-00582-00582-00000-LEVEL\n    TITLE 'IEX50003 - CP51, CP52, CP54, CP56, CP59, CP62, CP85, CP34'\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP51\n*\n***********************************************************************\n*\n*   UPPER BOUND HANDLING\n*        CONTEXT              STATEMENT\n*        SOURCE OPERATOR      COMMA, RIGHT BRACKET\n*        STACK OPERATOR\n*        OPERANDS             UPPER BOUNDARY\n*                             LOWER BOUNDARY IN STACK\n*                             ARRAY IDENTIFIER\n*\n*        BIT PATTERNS\n*\nBOOTYPEM EQU   X'03'                   BOOLEAN TYPE MASK\nREALTYPM EQU   X'02'                   REAL TYPE\n*\n         USING CP51,R12\nCP51     LA    R4,EQD2                 RETURN IF OPERAND MISSING\n         BAL   R3,OPDTEST              OPERAND TEST\n         BAL   R4,TARITHM              OPERAND ARITHMETIC ?\n         B     EQD1                    +00 ARITHMETIC\n*\nEQD2     LA    R9,5(,R9)               +04 CLOPD\nEQD3     CLI   0(R8),XFRSQBR           RIGHT SQUARE BRACKET ?\n         BE    EQD4                    YES, BRANCH\n         BCTR  R10,R5                  CLOPT SUBSTART\nEQD4     LA    R9,10(,R9)              CLEAR TWO OPERANDS\n         SH    R10,KH2                 CLEAR TWO OPERATORS\n         MVC   KONSUM,0(R9)            R9,= R9+C(R9)\n         AH    R9,KONSUM               REMOVE STACKED ARRAY IDENTIFIER\nETB3     LA    R9,5(,R9)               CLOPD\n         NI    COMPFLGS,255-OPERAND    RESET OPERAND\nETE3     CLI   1(R8),XFZETA            R8+1 = ZETA ?\n         MVC   GREGN(2),ZEROHW         CLEAR COUNTER\n         BL    ETF2                    LOW, OPERATOR\n         BH    ETF4                    HIGH, OPERAND\n         BAL   R4,JBUFFER              ZETA, CHANGE BUFFER\n         B     ETE3\n*\nETF2     LA    R8,1(,R8)               INCR R8\n         CLI   0(R8),XFCOMMA           COMMA ?\n         BNE   COMP                    NO, BRANCH\nETH2     BR    R5                      RETURN TO SUBSTART\n*\nETF4     BAL   R4,SERR1\n         DC    H'191'                  ERROR 191\n         BR    R5                      RETURN TO SUBSTART\n*\nEQD1     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    EQD2                    YES, BRANCH\n         BAL   R4,OPDREC               OPERAND RECOGNIZER\n         TM    1(R9),X'01'             OPERAND INTEGER\n         BO    EQG1                    YES\n         BAL   R4,TRREIN               GENERATE A CALL TO CONVERSION\n*                                      REAL INTEGER\n         AH    R7,ONEENTRY             RESERVE PLACE FOR OPERAND\n         STH   R7,WORKPL\n         BAL   R4,MAXCH                CHECK MAX\n         STH   R7,EQF2+2               INSERT DISPL IN STORE INSTRUCT\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nEQF2     ST    R14,0(CDSA,0)           *** GENERATED CODE ***\n         MVC   0(2,R9),INTEGTYP        INTERNAL NAME, INTEGER IN STACK\n         STH   R7,SPBNST+2\n         MVC   2(3,R9),SPBNST+1\nEQG1     BAL   R4,MOVEOPDK             RESERVE ONE OPDK ENTRY\n         MVC   0(5,R9),10(R9)          MOVE LOWER BOUNDRY\n         MVI   10(R9),X'C0'            ITAB IDENTIFIER\n         MVI   11(R9),X'31'            INTEGER VARIABLE\n         MVC   12(1,R9),SPBNST+1       CURRENT PBN AND LAST\n         MVC   13(2,R9),USPEI2         ENTRY IN SMF TO OPERAND\n         MVC   0(2,R10),FORMINUS       FOR.= AND - TO OPERATOR STACK\n         BAL   R4,MOVEOPTK             RESERVE ONE OPTK ENTRY\n         ST    R8,HHSOURCE             SAVE SOURCE POINTER\n         LA    R8,HTRICK               SET R8 TO HTRICK\n         LA    R11,324(,R11)           SWITCH TO EXPRESSION CONTEXT\n         L     R1,ADDHZB1\n         L     R12,SCPTAB+4*69         R12 -> CP69\n         BR    R1                      BRANCH TO CP 69\n*\n*        RETURN FROM CP20 AFTER ASSIGNMENT OF UPPER-LOWER\n*        BOUNDRY+1 TO SMF\n*\nDERE2    L     R8,HHSOURCE             RESET R8\n         TM    COMPFLGS+2,NOTEST\n         BO    ERE2                    NO ARRAY BOUND TEST GENERATED\n*                                      TEST FOR ARRAY BOUNDRY ERROR\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\n         BNH   ARRAYBD(,FSA)           *** GENERATED CODE ***\nERE2     LH    R1,USPEI2               COMPUTE AND\n         LA    R1,4(,R1)               STORE NEXT ENTRY IN\n         STH   R1,USPEI2               SMF IN USPEI2\n         CLI   0(R8),XFCOMMA           MORE BOUND PAIRS LEFT IN ARRAY?\n         BNE   ERE3                    NO\n         MVC   0(2,R9),INTEGTYP        OPERAND INTEGER VALUE\n         AH    R7,ONEENTRY\n         STH   R7,SPBNST+2             CURRENT PBN AND NEXT OBJECT\n         MVC   2(3,R9),SPBNST+1        TIME STACK DISPLACEMENT TO\n         SH    R7,ONEENTRY             OPERAND IN STACK\n         BR    R5                      SCAN TO NEXT OPERATOR\n*\n*        LAST BOUND PAIR IN THIS ARRAY\n*\nERE3     LA    R9,5(,R9)               REMOVE ONE OPERAND\n         MVI   ERJ4+3,X'01'            DETERMINE AND INSERT\n         TM    1(R9),BOOTYPEM          Z=8,4 OR 1 INTO\n         BO    ERJ41                   LOAD\n         MVC   ERJ4+2(2),ONEENTRY      GPRA\n         TM    1(R9),REALTYPM          INSTRUCTION\n         BO    ERJ41\n         MVI   ERJ4+3,X'04'            UPDATE GENERATED CODE\nERJ41    BAL   R2,GENTXT6              GENERATE 6 BYTES\n*                                      *** GENERATED CODE ***\n         SR    GPRC,GPRC               CLEAR REG\nERJ4     LA    GPRA,0(0,0)             LOAD GPRA INSTRUCTION\n*                                      *** GENERATED CODE ***\n         SR    R1,R1                   CALCULATE\n         IC    R1,USPEI4+1             LENGTH OF SMF P-PART\n         STC   R1,ESE4+1               NUMBER OF SUBSCRIPTS TO CODE\n         LA    R1,1(,R1)\n         SLL   R1,2                    INSERT\n         BCTR  R1,0                    IN CODE FOR COPY OF\n         STC   R1,ESF4+1               SMF\nESB1     LH    R1,USPEI2\n         STH   R1,ESD1+2               DISP IN SMF TO INSTRUCTION\n         SH    R1,KH4                  NEXT ENTRY IN SMF\n         STH   R1,USPEI2               CALCULATED DOWNWARDS\n         STH   R1,ESK1+2               INSERT IN CODE\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nESD1     ST    GPRA,0(CDSA,0)          *** GEN CODE *** STORE OF P(4)\n         LH    R1,USPEI4               REDUCE DIMENSION\n         BCTR  R1,0                    COUNT\n         LTR   R1,R1                   CODE FOR LAST ENTRY P(1) GEN ?\n         BL    ESC2                    YES\n         STH   R1,USPEI4               STORE DIMENSION VALUE\n         STH   R7,ESH1+2               INSERT DISPL OF LOWER BOUND\n         SH    R7,ONEENTRY             RELEASE OBJECT TIME STACK\n         LA    R2,ESE1                 GENERATE CODE FOR\n         BAL   R14,GENTXTS             DETERMINE OF SMF\n         DC    H'12'                   GENERATE 12 BYTES\n*\n         B     ESB1                    CONTINUE TO NEXT ENTRY IN SMF\n*\nESC2     LA    R9,5(,R9)               REMOVE ARRAY IDENTIFIER\n         BCTR  R10,0                   REMOVE ARRAY OPERATOR\n         MVC   USPEI4(2),0(R9)         NUMBER OF PREVIOUSLY\n*                                      STACKED ARRAY IDENT TO WORKAR\nESE21    LH    R14,USPEI2\nESE22    STH   R14,ESE3+2              SMF DISPL FOR LAST ELEMENT+1\n         SH    R14,KH4\n         STH   R14,ESJ2+2              SMF DISPL FOR FIRST ELEMENT\n         SH    R14,KH4\n         STH   R14,ESC3+2              SMF DISPL FOR ZERO ELEMENT\n         SH    R14,KH4                 SMF DISPL FOR START OF SMF\n         STH   R14,ESE5+8              TO CODE\n         STH   R14,ESE5+2\n         MVZ   ESE5+2(1),ESE5+4\n         MVC   ESE4+2(2),ESE5+2\n         LA    R2,ESE2                 GENERATE CODE FOR RESERVATION\n         BAL   R14,GENTXTS             OF MAIN STORAGE FOR ARRAY\n         DC    Y(ESE4-ESE2+4)          LENGTH OF GENERATED CODE\n*                                      STACKED ARRAY IDENT TO WORKAREA\n         LH    R1,USPEI4               ANY ARRAY IDENT WITH SAME\n         SH    R1,KH5                  DIMENSIONS LEFT IN STACK ?\n         BM    ETB3                    NO\n         STH   R1,USPEI4               SAVE NUMBER OF ARRAYS LEFT\n         LA    R9,5(,R9)               CLEAR OPERAND\n         NC    ESF4+4(2),CLEARDIS      SMF+16 OF ORIGINAL ARRAY\n         OC    ESF4+4(2),ESD1+2        INSERTED AS DISPLACEMENT\n         MVC   WORKPL(2),3(R9)\n         NI    WORKPL,X'0F'\n         LH    R1,WORKPL\n         LA    R14,16(,R1)\n         STH   R14,ESF4+2              NEW SMF DISP +16\n         OI    ESF4+2,CDSA*16          REGISTER CDSA TO CODE\n         BAL   R2,GENTXT6              GENERATE 6 BYTES\nESF4     MVC   0(0,CDSA),0(CDSA)       *** GENERATED CODE ***\n         SH    R14,KH4                 NEW USPEI4 TO R1=SMF-DISP+12\n         B     ESE22\n*\n*        CODE FOR RESERVATION OF MAIN STORAGE FOR ARRAY\n*\nESE2     LR    0,GPRA               *  *** GENERATED CODE ***\n         BAL   ADR,GETMSTO(FSA)     |  CALL GETMAIN ROUTINE IN FSA\nESJ2     ST    1,0(CDSA,0)          |\n         LR    R14,1                |\n         SR    1,GPRC               |\nESC3     ST    1,0(CDSA,0)          |\n         AR    R14,GPRA             |\nESE3     ST    R14,0(CDSA,0)        |\nESE5     MVC   0(4,CDSA),12(CDSA)   |  MOVE CHAINING ADDR\n         LA    ADR,0(0)             |  STORE DISPL OF LAST SMF\n         ST    ADR,12(CDSA)         |  IN DSA\nESE4     MVI   0(CDSA),0            |  NUMBER OF SUBSCRIPTS TO SMF\nESE1     LR    GPRB,GPRA            |  CODE FOR DETERMINE OF\nESH1     M     GPRB-1,0(CDSA,0)     |  SMF\n         AR    GPRC,GPRB            |\nESK1     M     GPRA-1,0(CDSA,0)     V\n*\n*        CONSTANTS AND VARIABLES\n*\nFORMINUS DC    X'2D01'                 FOR := AND - OPERATORS\nHTRICK   DC    X'00'                   +\n         DC    X'C801000004'           1 AS INTEGER CONSTANT\n         DC    X'1C'                   DO\nHHSOURCE DC    F'0'                    SAVE AREA FOR R8\nADDHZB1  DC    A(DHZB1)                ADDR IN CP 69\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM  - CP52\n*\n***********************************************************************\n*\n*   ARRAY DECLARATION, BEGINNING\n*        CONTEXT              STATEMENT\n*        SOURCE OPERATOR      LEFT BRACKET, COMMA\n*        STACK OPERATOR       ARRAY\n*        OPERAND              ARRAY IDENTIFIER\n*\n         USING CP52,R12\nCP52     CLI   0(R8),XFCOMMA           COMMA ?\n         BNE   EWF1                    NO,LAST ARRAY IDENTIFIER\n         LH    R14,GREGN\n         LA    R14,5(R14)              COUNT ARRAY IDENTIFIERS\n         STH   R14,GREGN\n         BR    R5                      RETURN TO SUBSTART\n*\nEWF1     BAL   R4,MOVEOPTK             RESERVE ONE OPTK ENTRY\n         MVI   0(R10),X'2C'            OPTH (SPEC BRACKET)\n         SH    R9,KH10                 R9 IS DECREASED BY TEN\n         CR    R10,R9                  CHECK OVERFLOW\n         BNL   STACKOFL\n         MVC   5(5,R9),10(R9)          MOVE ARRAY IDENTIFIER\n         MVC   10(2,R9),GREGN          NUMBER OF ARRAY IDENTIFIERS-1\n*                                      TO OPERAND STACK\n*\n*        CALCULATE AND SAVE NUMBER OF SUBSCRIPTS IN USPE14\n*\n         SR    R1,R1\n         IC    R1,8(R9)\n         SRL   R1,4\n         LA    R1,1(R1)\n         STH   R1,USPEI4\n*\n*        CALCULATE AND SAVE SMF DISPL +16 IN USPE12\n*\n         MVC   USPEI2(2),8(R9)\n         NI    USPEI2,X'0F'\n         LH    R1,USPEI2\n         LA    R1,16(R1)\n         STH   R1,USPEI2\n         MVC   0(2,R9),INTEGTYP        OPERAND INTEGER VALUE IN STACK\n         AH    R7,ONEENTRY             NEXT OBJECT TIME ENTRY\n         STH   R7,SPBNST+2             CURRENT PBN AND\n         MVC   2(3,R9),SPBNST+1        DISPL TO OPERAND STACK\n         SH    R7,ONEENTRY             RELEASE OBJECT TIME STACK\n         BR    R5                      SCAN TO NEXT OPERATOR (SUBSTART)\n*\n*        CONSTANTS AND VARIABLES\n*\nINTEGTYP DC    X'4031'                 INTEGER TYPE VARIABLE\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP54\n*\n***********************************************************************\n*\n*   ARRAY DECLARATION, TERMINATION\n*        CONTEXT              STATEMENT\n*        SOURCE OPERATOR      DELTA\n*        STACK OPERATOR       ARRAY\n*        OPERAND              NONE\n*\n         USING CP54,R12\nCP54     TM    COMPFLGS,OPERAND         OPDT\n         BO    FAC2                     YES, BRANCH\nFAE2     BCTR  R10,0                    CLOPT\n         BAL   R4,SCHDL                 SEMICOLON HANDLING\n         SH    R11,KH290                SWITCH TO PROGRAM CONTEXT\n         BR    R5                       RETURN TO SUBSTART\n*\nFAC2     BAL   R4,SERR4\n         DC    H'164'                   ERROR 164\n         LA    R9,5(,R9)                CLOPD\n         B     FAE2\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP56\n*\n***********************************************************************\n*\n*   DESIGNATIONAL EXPRESSIONS\n*        CONTEXT              STATEMENT\n*        SOURCE OPERATOR      (\n*        STACK OPERATOR       GOTO, SWITCH =\n*        OPERAND              NONE\n*\n         USING CP56,R12\nCP56     TM    COMPFLGS,OPERAND        OPDT\n         BO    FEB2\nFEC1     LA    R11,324(,R11)           CSW(EXP)\n         BAL   R4,MOVEOPTK             OPTH(SOURCE)\n         MVC   0(1,R10),0(R8)\n         BR    R5                      RETURN TO SUBSTART\n*\nFEB2     BAL   R4,SERR4\n         DC    H'164'                  ERROR 164\n         LA    R9,5(,R9)               CLOPD\n         NI    COMPFLGS,255-OPERAND    RESET OPERAND\n         B     FEC1\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP59\n*\n***********************************************************************\n*\n*   SWITCH LIST HANDLING\n*        CONTEXT              STATEMENT\n*        SOURCE OPERATOR      COMMA, DELTA\n*        STACK OPERATOR       SWITCH =\n*        OPERANDS             DESIGNATIONAL OPERAND (NTH PARAMETER)\n*                             PARAMETERCOUNT AND PRPOINT (N-1 ENTRIES)\n*                             SWITCH IDENTIFIER\n*                             LABEL OPERAND\n*\n         USING CP59,R12\nCP59     LA    R4,FKJ2                 RETURN IF OPERAND MISSING\n         BAL   R3,OPDTEST              OPERAND TEST\n         TM    1(R9),X'08'             OPERAND A LABEL ?\n         BZ    FKC2                    NO, BRANCH TO ERROR 175\n         TM    0(R9),APIMASK\n         BO    FKJ2\n         TM    1(R9),X'04'             SWITCH IDENTIFIER ?\n         BO    FKC2                    YES, ERROR\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    FKJ2                    YES, BRANCH\n         BAL   R4,OPDREC               OPERAND RECOGNIZER\n         TM    3(R9),ADR*16            DESIGNATIONAL EXPRESSION ?\n         BO    FKH2                    YES, BRANCH\n*\n*        GENERATE LLC (LOAD LABEL COMMON)\n*\n         MVN   FKG15+2(1),3(R9)\n         MVC   FKG15+3(1),4(R9)\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nFKG15    L     ADR,0(LAT)              *** GENERATED CODE ***\n         SR    R15,R15\n         IC    R15,2(,R9)\n         CH    R15,SPBNST              CURRENT BLOCK ?\n         BNE   FKG14                   NO\n         BAL   R2,GENTXT2              GENERATE 2 BYTES\n*                                      LOAD GDSA WITH CDSA\n         LR    GDSA,CDSA               *** GENERATED CODE ***\n         B     FKH1\n*\nFKG14    SLL   R15,3\n         STH   R15,FKG16+2\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nFKG16    L     GDSA,0(PBT)             *** GENERATED CODE ***\nFKH1     BAL   R2,GENTXT4              GENERATE 4 BYTES\n*                                      GENERATE BRANCH TO CSWE ROUTINE\n         B     CSWE2(FSA)              *** GENERATED CODE ***\n*\n         ST    R6,WORKPL               NEXT THUNK ADDR\n         MVC   2(3,R9),WORKPL+1        TO OPERAND STCK\nFKJ2     IC    R15,6(,R9)\n         LA    R15,5(,R15)             UPDATE SLSWE\n         STC   R15,1(,R9)               STORE IN STACK\n         MVI   0(R9),0\n         CLI   0(R8),XFDELTA           OPERATOR DELTA ?\n         BNER  R5                      NO, BRANCH TO SUBSTART\nFKF3     SR    R15,R15\n         IC    R15,1(,R9)              R15 = NR OF ELEMENTS * 5\n         LA    R15,5(R15,R9)           R15 POINTS AT SWITCH ID\n         ST    R15,WORKPL\n         ST    R15,STENTRY\n         MVC   HALFW,3(R15)            GET\n         LH    R14,HALFW                   LABEL\n         N     R14,HEXFFF                        NUMBER\n         A     R14,LATAB               GET LAT ENTRY OF SWITCH\n         ST    R6,0(,R14)              STORE PRPOINT IN LAT\nFKF41    SR    R1,R1\n         IC    R1,3(,R15)              GET\n         SRL   R1,4                        ELEMENT\n         LA    R1,1(,R1)                            COUNT\n         STH   R1,FKF42+2              STORE IN GENERATED CODE\n         TM    3(R14),X'02'            LIST ON WORD BOUNDRY ?\n         BZ    FKF42A                  YES\n         BAL   R2,GENTXT2              GENERATE 2 BYTES\n         NOPR  0                       *** GENERATED CODE ***\n         ST    R6,0(R14)               ADJUST LAT ENTRY\nFKF42A   BAL   R2,GENTXT4              GENERATE 4 BYTES\n*                                      GENERATE ELEMENT COUNT\nFKF42    DC    H'0',H'0'               *** GENERATED CODE ***\n         MVC   HALFW,0(R9)             INITIALIZE PARAM COUNT\n*\n*        GENERATE ONE THUNK ADDR\n*\nFKF45    L     R15,STENTRY\n         SH    R15,KH5\n         ST    R15,STENTRY\n         ST    R6,FKF48                SAVE PRPOINT\n         MVC   FKF46+1(3),2(R15)\n         CNOP  0,4\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nFKF46    DC    F'0'                    *** GENERATED CODE ***\n         L     R2,FKF48\n         BAL   R14,GENRLD              GENERATE RLD RECORD\n         DC    H'4'\n         DC    H'1'\n         DC    H'1'\n*\n         LH    R15,HALFW               DECREASE\n         SH    R15,KH5                          PARAM\n         STH   R15,HALFW                              COUNT\n         BP    FKF45                   COUNT \u00ac ZERO, BRANCH\n         L     R15,WORKPL\n         LA    R9,15(,R15)             CLEAR OPERAND STACK\n         MVC   HALFW,8(R15)            GET\n         LH    R15,HALFW                   LAT\n         A     R15,LATAB                       ENTRY\n         ST    R6,0(R15)               STORE PRPOINT IN LAT\n         BCTR  R10,0                   CLOPT\n         BAL   R4,SCHDL                SEMIC COUNTER HANDLING\n         L     R11,DECAADD             SWITCH TO PROGRAM CONTEXT\n         BR    R5                      RETURN TO SUBSTART\n*\nFKH2     SH    R7,ONEENTRY\n         MVI   RII,0                   REGISTER ADR FREE\n         B     FKH1\n*\nFKB25    BAL   R4,STACKAPI             INTRODUCE API\n         B     FKJ2\n*\nFKC2     BAL   R4,SERR2\n         DC    H'175'                  ERROR 175\n         LA    R9,5(R9)                PREPARE FOR INSERTING API\n         B     FKB25\n*\n*        WORKAREAS\n*\nSTENTRY  DC    F'0'                    WORK AREA\nFKF48    DC    F'0'\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP62\n*\n***********************************************************************\n*\n*   GOTO STATEMENT\n*        CONTEXT              STATEMENT\n*        SOURCE OPERATOR      EPSILON, ETA, ;, END, ELSE\n*        STACK OPERATOR       GOTO\n*        OPERAND              DESIGNATIONAL OPERAND\n*\n         USING CP62,R12\nCP62     LA    R4,FXJ1                 RETURN IF OPERAND MISSING\n         BAL   R3,OPDTEST              OPERAND TEST\n         TM    1(R9),X'08'             OPD LABEL ?\n         BZ    FXC2                    NO, BRANCH\n         TM    1(R9),X'04'\n         BO    FXC2\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    FXJ1                    YES, BRANCH\n         BAL   R4,OPDREC\n         TM    3(R9),ADR*16            DESIGNATIONAL EXPRESSION ?\n         BO    FXE4                    YES, BRANCH\n         CLC   SPBNST+1(1),2(R9)       CURRENT PBN ?\n         BNE   FXG3                    NO, BRANCH\n         MVN   FXH15+2(1),3(R9)\n         MVC   FXH15+3(1),4(R9)\n         BAL   R2,GENTXT6              GENERATE 6 BYTES\n*                                      GENERATE BRANCH TO LABEL\nFXH15    L     BRR,0(LAT)              *** GENERATED CODE ***\n         BR    BRR                     *** GENERATED CODE ***\n         B     FXJ1\n*\n*        GENERATE LLC (LOAD LABEL COMMON)\n*\nFXG3     MVN   FXG35+2(1),3(R9)\n         MVC   FXG35+3(1),4(R9)\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nFXG35    L     ADR,0(LAT)              *** GENERATED CODE ***\n         SR    R15,R15\n         IC    R15,2(R9)\n         SLL   R15,3\n         STH   R15,FXG36+2\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nFXG36    L     GDSA,0(PBT)             *** GENERATED CODE ***\n         B     FXH2\n*\nFXJ1     LA    R9,5(,R9)               CLOPD\n         NI    COMPFLGS,255-OPERAND    RESET OPERAND\n         MVI   GPBN+1,X'FF'            GDSA UNDEFINED\n         BCT   R10,COMP                CLOPT AND COMP\nFXC2     TM    0(R9),APIMASK           ALL PURPOUSE IDENTIFIER\n         BO    FXJ1                    YES\n         BAL   R4,SERR2\n         DC    H'175'                  ERROR 175\n*\n         B     FXJ1\n*\nFXE4     SH    R7,ONEENTRY             RELEASE STACK\n         XI    RII,RIIADRM             REG ADR FREE\n*\n*        GENERATE UNCONDITIONAL JUMP TO COMMON LABEL 'UJTCL'\n*\nFXH2     BAL   R2,GENTXT4              GENERATE 4 BYTES\n         B     RETPROG(FSA)            *** GENERATED CODE ***\n         B     FXJ1\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP85\n*\n***********************************************************************\n*\n*   BEGIN OF SWITCH LIST\n*        CONTEXT              PROGRAM\n*        SOURCE OPERATOR       =\n*        STACK OPERATOR       SWITCH\n*        OPERANDS             NR OF SWITCH EL * 5 AND PRPOINT\n*                             SWITCH IDENTIFIER\n*                             LABEL OPERAND\n*\n         USING CP85,R12\nCP85     BAL   R4,MOVEOPDK             RESERVE ONE MORE OPDK ENTRY\n         MVC   0(2,R9),ZEROHW          INITIAL ZERO TO SLSWE\n         ST    R6,WORKPL\n         MVC   2(3,R9),WORKPL+1        FIRST THUNKADDR TO STACK\n         L     R11,STC                 SWITCH TO STATEMENT CONTEXT\n         MVC   13(2,R9),LN             STORE LN IN R9\n         MVI   0(R10),X'2E'            'SWITCH.=' REPLACES 'SWITCH'\n         BR    R5                      RETURN TO SUBSTART\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP34\n*\n***********************************************************************\n*\n*   IF IN STATEMENT CONTEXT\n*        CONTEXT              STATEMENT\n*        SOURCE OPERATOR      IF\n*        STACK OPERATOR       GOTO, SWITCH =, PROCEDURE BRACKET,LEFT\n*                             BRACKET  ST PROC BRACKET, FOR =, STEP,\n*                             UNTIL, WHILE,  , ARRAY DECL BRACKET,\n*                             SE (SEE MATRIX)\n*        OPERAND              NONE\n*\n         USING CP34,R12\nCP34     TM    COMPFLGS,OPERAND        OPDT\n         BZ    CKD1                    OFF, BRANCH\n         BAL   R4,SERR4\n         DC    H'164'                  ERROR 164\n*\n         LA    R9,5(,R9)               CLOPD\nCKD1     BAL   R4,MOVEOPTK             OPTH(SOURCE)\n         MVC   0(1,R10),0(R8)\n         LA    R11,324(,R11)           CSW(EXP)\n         CLI   0(R10),X'1D'\n         BNER  R5                      NO, RETURN TO SUBSTART\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BOR   R5                      YES, RETURN TO SUBSTART\n         BAL   R4,CLEARRG\n         BR    R5                      RETURN TO SUBSTART\n*\n***********************************************************************\n*\n*        END OF IEX50003\n*\n***********************************************************************\n*\n./ ADD NAME=IEX50004 0201-12230-12230-1200-01476-01476-00000-LEVEL\n         TITLE 'IEX50 - COMPILATION PHASE - CP12'\n*\n*        CP12, CP19, CP20, CP21, CP22, CP23, CP33, CP57, CP61\n*        CP64, CP71, CP83, CP84\n*\n*        DEFINITIONS WITHIN CSECT IEX50004\n*\nNOASSIGN EQU   X'08'\nINREGBIT EQU   X'40'\nENTIER   EQU   X'140'                  OFFSET INTO FSA FOR ENTIER RTN\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP12\n*\n***********************************************************************\n*\n*        ASSIGNMENT\n*        CONTEXT              PROGRAM\n*        SOURCE OPERATOR      =\n*        STACK OPERATOR       BEGIN, ;, THENS, ELSES, DO\n*        OPERAND              LEFT SIDE VARIABLE\n*\n         USING CP12,R12\nCP12     TM    COMPFLGS,OPERAND        OPDT ?\n         BZ    AWC2                    NO, BRANCH\n*\n*        ENTRY FROM CP21\n*\nAWD1     TM    0(R9),X'08'             ASSIGMENT POSSIBLE ?\n         BO    AWD2                    NO, BRANCH TO AWD2\n         TM    0(R9),INREGBIT          OPD IN REGISTER ?\n         BZ    AWJ1                    YES, BRANCH\n         TM    1(R9),X'C0'             OPD TYPE PROCEDURE IDENT ?\n         BO    AWF2                    YES, BRANCH\n         TM    1(R9),X'20'             OPD CALLED BY NAME ?\n         BO    AWJ1                    NO, BRANCH IF NOT\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    AWJ1                    YES, BRANCH\n*\n*        GENERATE ASSIGNMENT CONTROL\n*\n         BAL   R4,ROUTINE1             LOAD VPLACE,WPLACE\n         LH    R1,WPLACE\n         LA    R1,4(,R1)\n         STH   R1,AWE45+2\n         MVZ   AWE45+2(1),VPLACE       INSERT REG INTO CODE\n         LA    R2,AWE45\n         BAL   R14,GENTXTS\n         DC    H'8'                    GENERATE 8 BYTES\n*\n         BAL   R4,OPDREC\n         MVC   2(1,R9),SPBNST+1        CURRENT BLOCK, NEVER FCTVA\n*                                      ALWAYS ADDR, NEVER VALUE\nAWJ1     BAL   R4,MOVEOPTK             OPTH(SOURCE)\n         MVC   0(1,R10),0(R8)\n         BR    R5\n*\nAWC2     BAL   R4,SERR3\n         DC    H'176'                  ERROR 176\n*\n*        ENTRY FROM CP21\n*\nAWC4     BAL   R4,STACKAPI\n         B     AWJ1\n*\nAWD2     BAL   R4,SERR1\n         DC    H'190'                  ERROR 190\n*\n         LA    R9,5(R9)                TO PREPARE STACKAPI\n         B     AWC4                    BRANCH\n*\n*        CHANGE INT NAME TO OBJECT STACK NAME\n*\nAWF2     MVI   0(R9),X'C0'\n         NI    1(R9),X'03'\n         OI    1(R9),X'30'\n         MVI   3(R9),X'00'\n         MVI   4(R9),X'18'             DISPL IS 24\n         B     AWJ1\n*\nAWE45    TM    0(CDSA),X'08'           *** GENERATED CODE ***\n         BO    OERR22(FSA)             *** GENERATED CODE ***\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP19\n*\n***********************************************************************\n*\n*        IF IN ASSIGNMENT STATEMENT\n*        CONTEXT              PROGRAM\n*        SOURCE OPERATOR      IF\n*        STACK OPERATOR        =\n*        OPERAND              NONE\n*\n         USING CP19,R12\nCP19     LA    R11,290(,R11)           CSW(STC)\n         B     COMP                    COMPARE\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP20\n*\n***********************************************************************\n*\n*        ASSIGNMENT\n*        CONTEXT              PROGRAM\n*        SOURCE OPERATOR      ;, EPSILON, ETA, END, ELSE\n*        STACK OPERATOR        =\n*        OPERAND              RIGHT SIDE OPERAND\n*\n         USING CP20,R12\nCP20     LA    R4,BIG2\n         BAL   R3,OPDTEST\n         BAL   R4,ARRTEST1\n         TM    1(R9),X'03'             OPD BOOL, REAL OR INTEGER ?\n         BZ    BIE3                    NO, ERROR\nBIC2     TM    1(R9),X'04'\n         BO    BIE32\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    BIE4                    YES, BRANCH\n         TM    0(R9),INREGBIT          OPD IN REGISTER ?\n         BZ    BID4                    YES, BRANCH\n         BAL   R4,OPDREC               OPERAND RECOGNIZER\n         B     BID4\n*\n*        ENTRY FROM CP69\n*\nBIG2     BCTR  R10,0                   CLEAR OPERATOR\n         CLI   0(R10),X'18'            'FOR' ?\n         BNE   BIJ2                    NO, BRANCH\n         LA    R9,5(,R9)               RELEASE OPERAND\n         L     R1,AJMPCP43             R1 -> CP43 ENTRY POINT\n         L     R12,SCPTAB+4*6          R12 -> CP6 FOR ADRESSABILITY\n         BR    R1                      BRANCH TO CP 43\n*\nBIJ2     CLI   0(R10),X'2C'            ARRAY BRACKET ?\n         BNE   BIK2                    NO, BRANCH\n         LA    R9,5(,R9)               CLEAR OPERAND\n         L     R1,ADERE2               R1 -> CP51 ENTRY POINT\n         L     R12,SCPTAB+4*51         R12 -> CP51\n         BR    R1                      BRANCH TO CP51 ENTRY POINT\n*\nBIK2     CLI   0(R10),XFASSIGN         OPERATOR IS 'ASSIGN' ?\n         BE    BIK1                    YES, BRANCH\nBIK5     NI    COMPFLGS,255-OPERAND    RESET OPERAND\n         LA    R9,10(,R9)              CLEAR OPERAND TWICE\n         B     COMP                    BRANCH TO COMP\n*\n*        RESTORE R7, RII, RIR, CII, CIR\n*\nBIK1     LH    R7,STRDP\n         MVC   CII(8),STRDCIRI\n         MVC   5(5,R9),0(R9)           MOVE LAST OPD TO NEXT LAST SPOT\n         LA    R9,5(,R9)               CLEAR OPERAND\n         TM    RII,RIIADRM             ADR OCCUPIED ?\n         BZ    BIK3                    NO\n         C     R9,RUTI+32\n         BNE   BIK3\n         MVI   RII,0                   RELEASE 'ADR' IN REG USE TABLE\nBIK3     TM    0(R9),X'20'\n         BZ    BIC2\n         TM    0(R9),X'40'\n         BO    BIC2\n         MVI   RII,X'01'\n         ST    R9,RUTI+32\n         B     BIC2\n*\nBID4     TM    5(R9),NOASSIGN          TEST NO ASSIGNMENT BIT\n         BO    BIE31                   ERROR IF NO ASSIGNMENT BIT\nBIE4     TM    1(R9),X'03'             TEST TYPE BITS\n         BZ    BIE3                    ERROR IF ZEROES IN TYPE FIELD\n         BM    BIAE2                   BRANCH MIXED (=NOT BOOLEAN)\n         TM    6(R9),X'03'             NEXT LAST OPD BOOLEAN ?\n         BNO   BIE34                   BRANCH IF NOT BOOLEAN\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    BIG2                    YES, BRANCH\n*\n*        GENERATE BOOLEAN ASSIGN\n*\nBIG5     TM    0(R9),X'C0'\n         BNO   BIBG1\n         TM    1(R9),X'30'             TEST IF RIGHT OPD BOOL CONST\n         BNZ   BIBG1                   BRANCH IF NOT A CONSTANT\n*\n*        GENERATE ASSIGN, RIGHT OPD BOOL CON\n*\nBIAH16   BAL   R4,SAVECIRI\n         LA    R9,5(,R9)\n         TM    0(R9),X'20'\n         BO    BIAH161\n         BAL   R4,ROUTINE1\nBIAH162  SH    R9,KH5\n         MVC   BIAH18+2(2),WPLACE\n         MVZ   BIAH18+2(1),VPLACE\n         NI    4(R9),X'01'\n         MVC   BIAH18+1(1),4(R9)       INSERT CONSTANT TO CODE\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nBIAH18   MVI   0(0),X'00'              *** GENERATED CODE ***\n         B     BIG2\n*\nBIAH161  BAL   R4,ROUTINE3\n         B     BIAH162\n*\nBIAE2    TM    6(R9),X'03'             LAST OPD NONBOOLEAN\n         BM    BIBA1                   BR IF MIXED, ERROR OTHERWISE\n         TM    5(R9),APIMASK           BLO AN API ?\n         BO    BIG2                    YES, BRANCH\nBIE33    BAL   R4,SERR1\n         DC    H'193'                  ERROR 193\n*\n         B     BIG2\n*\nBIE34    TM    0(R9),APIMASK           LO AN API ?\n         BO    BIG2                    YES, BRANCH\n         B     BIE33\n*\nBIE31    TM    5(R9),APIMASK           BLO AN API ?\n         BO    BIG2                    YES, BRANCH\nBIE3     BAL   R4,SERR1\n         DC    H'192'                  ERROR 192\n*\n         B     BIG2\n*\nBIE32    TM    0(R9),APIMASK           LO AN API ?\n         BO    BIG2                    YES, BRANCH\n         B     BIE3\n*\nBIBA1    TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    BIG2                    YES, BRANCH\n         TM    6(R9),X'02'             NEXT LAST OPD 'REAL' ?\n         BZ    BICA1                   NO, BRANCH\n         TM    1(R9),X'02'             LAST OPERAND 'REAL' ?\n         BO    BIBG1                   YES, BRANCH\n         BAL   R4,TRINRE               GENERATE INTEGER REAL CONVERSION\n*\n*        GENERATE 'ASSIGN REAL'\n*\nBIBG1    BAL   R4,SAVECIRI\n         L     R1,ADHEB2               R1 -> DHEB2 ENTRY IN CP69\n         L     R12,SCPTAB+4*69         R12 -> CP69\n         BR    R1                      BRANCH TO DHEB2 IN CP69\n*\nBICA1    TM    1(R9),X'02'             LAST (RIGHT) OPERAND 'REAL'\n         BZ    BICF1                   NO, BRANCH\n         BAL   R4,TRREIN               GENERATE REAL INTEGER CONVERSION\n         BAL   R4,ROUTINE7             GET NEXT FREE REGISTER\n         SLA   R14,2\n         ST    R9,RUTI(R14)            R9 TO REG USAGE TABLE\n         SLA   R14,2\n         LA    R14,14(R14)\n         STC   R14,BICA15+1            REG NUMBER TO INSTRUCTION\n         BAL   R2,GENTXT2              GENERATE 2 BYTES\nBICA15   LR    0,0                     *** GENERATED CODE ***\n         MVI   0(R9),X'88'\n         MVI   1(R9),X'31'\n         MVC   2(1,R9),SPBNST+1\n         STH   R7,HALFW\n         MVC   3(2,R9),HALFW\n         MVZ   3(1,R9),BICA15+1\n*\n*        GENERATE 'ASSIGN INTEGER'\n*\nBICF1    BAL   R4,SAVECIRI\n         L     R1,ADHZB1               R1 -> DHZB1 ENTRY IN CP69\n         L     R12,SCPTAB+4*69         R12 -> CP69\n         BR    R1                      BRANCH TO DHZB1 ENTRY IN CP69\n*\n*        RELEASE OBJECT T STACK ENTRY AND REG\n*\nRELOSREG TM    0(R9),X'C0'\n         BOR   R4                      RETURN IF IDENT FROM ITAB\n         SH    R7,ONEENTRY             RELEASE ONE OBJ T STACK ENTRY\n         TM    0(R9),INREGBIT\n         BOR   R4                      RETURN IF OPD NOT 'IN REG'\n         NI    RII,X'FE'               RELEASE 'ADR' IN REG USE TABLE\n         BR    R4\n*\n*        SAVE R7, CII, CIR, RII, RIR\n*\nSAVECIRI STH   R7,STRDP\n         MVC   STRDCIRI(8),CII\n         BR    R4\n*\nSTRDP    DC    H'0'\nSTRDCIRI DC    8C' '\n*\nADHEB2   DC    A(DHEB2)                ENTRY TO CP69\nADHZB1   DC    A(DHZB1)\nADERE2   DC    A(DERE2)                ENTRY TO CP51, BASE CP51\nAJMPCP43 DC    A(DJH1E43)              ENTRY TO CP43, BASE CP6\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP21\n*\n***********************************************************************\n*\n*        MULTIPLE ASSIGNMENT\n*        CONTEXT              PROGRAM\n*        SOURCE OPERATOR       =\n*        STACK OPERATOR        =\n*        OPERAND              LEFT SIDE VARIABLE\n*\n         USING CP21,R12\nCP21     TM    COMPFLGS,OPERAND        OPERAND ON ?\n         BZ    BKB2                    NO, BRANCH\n         IC    R0,1(,R9)               LOAD R0,R9+1\n         IC    R1,6(,R9)               LOAD R1,R9+6\n         N     R0,TYPETEST             CLEAR FIRST 3O BITS OF GPR0\n         N     R1,TYPETEST             CLEAR FIRST 3O BITS OF GPR1\n         L     R12,SCPTAB+4*12         R12 -> CP12\n         SR    R0,R1                   SUBTRACT\n         BZ    AWD1-CP12(R12)          ZERO, BRANCH TO AWD1 IN CP12\n         TM    0(R9),APIMASK           LO AN API ?\n         BOR   R5                      YES, BRANCH TO SUBSTART\n         TM    5(R9),APIMASK           BLO AN API ?\n         BOR   R5                      YES, BRANCH TO SUBSTART\n         BAL   R4,SERR1\n         DC    H'172'                  ERROR 172\n*\n         B     AWC4-CP12(R12)          BRANCH TO AWC4 IN CP12\n*\nBKB2     BAL   R4,SERR4\n         DC    H'162'                  ERROR 162\n*\n         BR    R5                      RETURN TO SUBSTART\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP22\n*\n***********************************************************************\n*\n*        ARITHM OR BOOL EXPRESSION IN ASSIGNMENT STATEMENT\n*        CONTEXT              PROGRAM\n*        SOURCE OPERATOR      (, ARITHM OP, BOOL OP, REL OP\n*        STACK OPERATOR        =\n*        OPERAND              ARRAY OR PROCEDURE IDENTIFIER OR\n*                             ARITHMETIC OR BOOLEAN OPERAND OR NONE\n*\n         USING CP22,R12\nCP22     L     R11,EXC                 CSW(EXP)\n         B     COMP                    COMPARE\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP23\n*\n***********************************************************************\n*\n*        PARAMETERLESS PROCEDURE STATEMENT OR STATEMENT END\n*        CONTEXT              PROGRAM\n*        SOURCE OPERATOR      ;, EPSILON, ETA, END\n*        STACK OPERATOR       ;\n*        OPERAND              PROCEDURE IDENTIFIER OR NONE\n*\n         USING CP23,R12\nCP23     TM    COMPFLGS,OPERAND        OPDT\n         BZ    BOD1                    OFF, BRANCH\n         BAL   R4,PLPRST\n         LA    R9,5(,R9)\n         NI    COMPFLGS,255-OPERAND    RESET OPERAND\nBOD1     CLI   0(R8),XFSCOLON          SOURCE SEMICOLON ?\n         BNE   BOE1                    NO, BRANCH\n         BAL   R4,SCHDL                YES, ENTER SEMICOLON HANDLING\n         BR    R5                      RETURN TO SUBSTART\n*\nBOE1     BCT   R10,COMP                CLOPT AND COMP\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP33\n*\n***********************************************************************\n*\n*        ARITHMETIC OR BOOLEAN EXPRESSIONS IN STATEMENT CONTEXT\n*        CONTEXT              STATEMENT\n*        SOURCE OPERATOR      ARITHM OR BOOLEAN OR RELATIONAL OPERATOR\n*        STACK OPERATOR       PROCEDURE BRACKET, LEFT BRACKET,\n*                             ST PROC BRACKET,FOR =, STEP, UNTIL,\n*                             WHILE,  , ARRAY DECL BRACKET\n*        OPERAND              ARITHMETIC OR BOOLEAN OPERAND\n*\n         USING CP33,R12\nCP33     LA    R11,324(,R11)           CSW(EXP)\n         B     COMP                    COMPARE\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP57\n*\n***********************************************************************\n*\n*        PROCEDURE CALL\n*        CONTEXT              STATEMENT\n*        SOURCE OPERATOR      , OR )\n*        STACK OPERATOR       PROCEDURE BRACKET\n*        OPERANDS             ACTUAL PARAMETER\n*                             PARAMETER COUNT AND PRPOINTER AT CALL\n*                             PAR CHAR AND PRPOINTER AT NEXT THUNK ADR\n*                             LABEL NUMBER\n*                             PROCEDURE IDENTIFIER\n*\n*        COMPUTE FOR LATER REFERENCE (FROM SLPAR IN STACK)\n*        STACK ADDR WHICH POINTS TO ENTRY CONTAINING LN\n*        (=ONE ENTRY AFTER PROCEDURE IDENTIFIER ENTRY)\n*        STORE SLPAR (NUMBER OF PARAMETERS TIMES FIVE)\n*\n         USING CP57,R12\nCP57     TM    COMPFLGS,OPERAND        OPDTEST\n         BZ    FGAB2                   FALSE\n         MVC   STACKST(2),5(R9)\n         LH    R15,STACKST\n         LA    R15,10(R15,R9)\n         ST    R15,STACKST\n         MVC   STSLPAR(2),5(R9)        MOVE SLPAR\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    FGAG1                   YES, BRANCH\n         OI    PROCWPS,X'80'           NO PARAMETERLESS PROC CHECK\n         BAL   R4,OPDREC               OPERAND RECOGNIZER\n         XI    PROCWPS,X'80'           SWITCH OFF\n*\n*        LOAD ACTUAL PARAMETER ADDR LAPA\n*\nFGCA1    TM    0(R9),X'20'             OPD REPRESENTS ADDR ?\n         BO    FGCB3                   YES\n         BAL   R4,CLEARRG              STORE REGS IN OBJ TIME STACK\n         BAL   R4,DECOMP               DECOMPOSE OPERAND\n         LH    R15,OPDPBN              GET\n         SLA   R15,3                       PBN\n         STH   R15,FGCD35+2                   TIMES EIGHT TO GEN CODE\n         LH    R15,OPDLN               LN\n         STH   R15,FGCD34+2               TO GENERATED\n         STH   R15,FGCF34+2                            CODE\n         TM    1(R9),X'08'             OPERAND LABEL OR SWITCH ?\n         BO    FGCD3                   YES\n         TM    1(R9),X'C0'             OPERAND PROCEDURE ?\n         BZ    FGCF21                  NO PROCEDURE\n         TM    0(R9),X'80'\n         BO    FGCE3\nFGCF21   BAL   R4,ROUTINE1             FIND DISPL AND REG\n         MVC   FGCF25+2(2),WPLACE      INSERT DISPLACEMENT IN CODE\n         MVZ   FGCF25+2(1),VPLACE      INSERT REG IN CODE\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nFGCF25   LA    ADR,0(0)                *** GENERATED CODE ***\n         TM    0(R9),X'C0'             IDENTIFIER FROM ITAB ?\n         BO    FGAF1                   YES\n         SH    R7,ONEENTRY             RELEASE STACK ENTRY\n         B     FGAF1                   EXIT FROM LAPA\n*\nFGCB3    BAL   R4,ROUTINE3             LOAD REG ADR\n         B     FGAF1                   EXIT FROM LAPA\n*\n*        LABEL OR SWITCH IDENTIFIER\n*\nFGCD3    BAL   R2,GENTXT4              GENERATE 4 BYTES\nFGCD34   L     ADR,0(LAT)              *** GENERATED CODE ***\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nFGCD35   L     GDSA,0(PBT)             *** GENERATED CODE ***\n         B     FGAF1                   EXIT FROM LAPA\n*\n*        PROCEDURE IDENTIFIER\n*\nFGCE3    TM    1(R9),X'40'             STANDARD PROCEDURE ?\n         BZ    FGCF4                   YES\n         TM    3(R9),X'F0'             PARAMETERLESS PROCEDURE ?\n         BZ    FGCF33                  YES\n         MVC   FGCF35+1(1),2(R9)\n         LA    R2,FGCF34\n         BAL   R14,GENTXTS\n         DC    H'12'                   GENERATE 12 BYTES\n*\n         B     FGAF1                   EXIT FROM LAPA\n*\nFGCF33   TM    1(R9),X'20'             CALLED BY VALUE ?\n         BZ    FGAF1                   NO\n         B     FGCF21                  YES\n*\nFGCF34   L     ADR,0(LAT)              *** GENERATED CODE ***\nFGCF35   MVI   PROLPBN(FSA),X'00'      *** GENERATED CODE ***\n         STM   PBT,LAT,PROLREG(FSA)    *** GENERATED CODE ***\n*\n*        STANDARD PROCEDURE IDENTIFIER\n*\nFGCF4    TM    4(R9),X'80'             ABS, SIGN, LENGTH, OR ENT ?\n         BO    FGCF41                  YES, NO LAT ENTRY\n         IC    R15,4(R9)               GET\n         N     R15,FGXFC                   ENTRY\n         A     R15,LATAB                         IN LAT\n         NI    0(R15),X'7F'            INSERT ZERO BIT\n         OI    IOTAB+16,X'01'          ALL DATASETS MAY BE NEEDED\nFGCF41   LA    R15,2\n         NR    R15,R6                  PRPOINT ON HALFWORD BOUNDARY ?\n         BNZ   FGCF42                  YES\n         BAL   R2,GENTXT2              GENERATE 2 BYTES\n         LR    R1,R1                   *** GENERATED CODE ***\n*                                      GENERATED NO OP CODE\nFGCF42   MVC   FGCF45(4),1(R9)         INSERT 1ST PART OF STD PROC ID\n         LA    R2,FGCF44\n         BAL   R14,GENTXTS\n         DC    H'22'                   GENERATE 22 BYTES\n*\n         B     FGAF1                   EXIT FROM LAPA\n*\n         CNOP  2,4\nFGCF44   BALR  BRR,0                   *** GENERATED CODE ***\n         L     ADR,8(BRR)              *** GENERATED CODE ***\n         B     12(BRR)                 *** GENERATED CODE ***\n*\nFGCF45   DC    F'0'                    *** GENERATED CODE ***\n         MVI   PROLPBN(FSA),X'00'      *** GENERATED CODE ***\n         STM   PBT,LAT,PROLREG(FSA)    *** GENERATED CODE ***\n*\n*        GENERATE CALL OF CAP2\n*\nFGAF1    BAL   R2,GENTXT4              GENERATE 4 BYTES\n         B     CAP2(FSA)               *** GENERATED CODE ***\n         MVI   GPBN+1,X'FF'            GDSA IS NOT CONTROLLED\nFGAG1    MVC   5(2,R9),0(R9)           PAR CHAR OF LO INTO NEXT L OPD\n         ST    R6,WORKPL               NEXT THUNK ADDR\n         MVC   2(3,R9),WORKPL+1        TO LAST OPD\n         LH    R15,STSLPAR             UPDATE SLPAR\n         LA    R15,5(R15)\n         STH   R15,STSLPAR\n         MVC   0(2,R9),STSLPAR         SLPAR TO LAST OPERAND\n*\nFGBA1    CLI   0(R8),XFRBRAC           RIGHT BRACKET IN SOURCE ?\n         BNER  R5                      NO, BRANCH TO SUBSTART\n         L     R15,STACKST             GET ADDR OF PROCED ID - 5\n         TM    5(R15),X'10'            PROCEDURE IDENTIFIER API ?\n         BO    FGBD1                   YES, NO PARAMETER NR CHECK\n         SR    R4,R4\n         IC    R4,8(R15)               GET NUMBER OF PARM IN PROC IDENT\n         SRL   R4,4\n         LH    R0,STSLPAR              GET NUMBER OF PARAMS TIMES FIVE\n         SRDA  R0,32\n         LH    R2,KH5\n         DR    R0,R2                   CALC NUMBER OF PARAMETERS\n         STH   R1,FGOUTPAR+6           NUMBER TO GENERATED CODE\n         CR    R1,R4                   PARAMETER COUNT COMPARE\n         BE    FGBD1                   CORRECT NUMBER\n         TM    6(R15),X'30'            PROCEDURE FORMAL PARAMETER ?\n         BM    FGBD1                   YES, NO ERROR\n         BAL   R4,SERR1\n         DC    H'187'                  ERROR 187\n*\nFGBD1    L     R9,STACKST              CLEAR R9 FROM ALL PARAM ENTRY\n         LA    R9,5(R9)\n         NI    3(R9),X'0F'             CLEAR PARAMETER COUNT\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    FGBH1                   YES, BRANCH\n         L     R15,STACKST             GET\n         MVC   HALFW(2),3(R15)         ADDR OF\n         LH    R4,HALFW                            LAT\n         A     R4,LATAB                                ENTRY\n         ST    R6,0(R4)                VALUE OF PRPOINT TO LAT ENTRY\n*\n*        GENERATE PROCEDURE CALL\n*\nFGBD11   TM    1(R9),FORMPM            PROCEDURE FORMAL ?\n         BNM   FGBD11A                 NO\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\n         MVI   PROLPBN-1(FSA),X'FF'    *** GENERATED CODE ***\n*\n*        SET SW IN FSA TO DETECT WHEN ACT PROCEDURE IS\n*        PARAMETERLESS\n*\nFGBD11A  OI    PROCWPS,X'80'           SET SWITCH IN OPERAND RECOGNIT\n         BAL   R4,OPDREC\n         XI    PROCWPS,X'80'           SWITCH OFF\n         NI    1(R9),X'3F'             CLEAR PROCEDURE BITS\n         TM    1(R9),FORMPM            FORMAL PARAMETER ?\n         BNM   FGBG1                   NO\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\n*                                      GENERATE CALL PROCEDURE FORMAL\n         BAL   BRR,PROLOGFP(FSA)       *** GENERATED CODE ***\nFGBG1    SR    R15,R15\n         STH   R15,PARCOUNT            INITIALIZE PARAMETER COUNT\nFGBG12   LH    R15,PARCOUNT\n         CH    R15,STSLPAR             ALL PARAMS BEEN PROCESSED ?\n         BE    FGBH1                   YES, BRANCH\n*\n*        GENERATE ONE ENTRY IN PARAMETER LIST\n*\nFGBG13   LA    R15,5(R15)\n         STH   R15,PARCOUNT\n         L     R4,STACKST              FIND PARAMETERS IN STACK\n         SR    R4,R15\n         MVC   FGOUTPAR+4(2),0(R4)     CHARACTER BYTES TO GENER CODE\n         MVC   FGOUTPAR+1(3),2(R4)     ADDR OF THUNK TO GENER CODE\n         ST    R6,THUNKADR             SAVE PRPOINT FOR RLD RECORD\n         LA    R2,FGOUTPAR\n         BAL   R14,GENTXTS\n         DC    H'8'                    GENERATE 8 BYTES\n         L     R2,THUNKADR\n         BAL   R14,GENRLD              GENERATE RLD RECORD\n         DC    H'4'\n         DC    H'1'\n         DC    H'1'\n         MVI   FGOUTPAR+7,0            ZERO TO NEXT PARM NUMBER FIELD\n         B     FGBG12\n*\n*        CHECK FOR THE PRESENCE OF 'FOR', 'IF' OR 'GOTO'\n*        IMMEDIATELY AFTER PROCEDURE CALLS\n*        CALLED BY CP57 AND CP61\n*\n         DROP  R12\nFGBG20   LR    R0,R12\n         BALR  R12,0\n         USING *,R12\n         ST    R0,FGBG29               SAVE OLD BASE REG\n         ST    R4,FGBG28\n         CLI   1(R8),XFZETA            SOURCE BUFFER EMPTY?\n         BNE   FGBG22                  NO\n         BAL   R4,JBUFFER\nFGBG22   CLI   1(R8),XFFOR             NEXT OPERATOR 'FOR' ?\n         BE    FGBG27                  YES\n         CLI   1(R8),XFIF              NEXT OPERATOR 'IF' ?\n         BE    FGBG27                  YES\n         CLI   1(R8),XFGOTO            NEXT OPERATOR 'GOTO' ?\n         BE    FGBG27                  YES\nFGBG25   L     R4,FGBG28\n         L     R12,FGBG29              RESTORE OLD BASE REG\n         BCTR  R10,R4                  CLOPT AND RETURN\nFGBG27   LA    R8,1(,R8)               INCREASE SOURCE PTR\n         BAL   R4,SERR3\n         DC    H'194'                  ERROR 194\n*\n         BCT   R8,FGBG25               DECREASE SOURCE PTR\n*\nFGBG28   DC    F'0'\nFGBG29   DC    F'0'\n         DROP  R12\n*\n*        RE-ESTABLISH BASE REG FOR CONTINUATION OF CP57\n*\n         USING CP57,R12\nFGBH1    BAL   R4,FGBG20               CHECK NEXT OPERATOR\n         CLI   0(R10),X'30'            PROG CONTEXT OP IN STACK ?\n         BNE   FGBG4                   NO, BRANCH\n         NI    COMPFLGS,255-OPERAND    RESET OPERAND\n         L     R11,DECAADD             SWITCH TO PROGRAM CONTEXT\n         TM    3(R9),REGADRM           OPERAND IN ADR ?\n         BZ    FGBH1A                  NO\n         SH    R7,ONEENTRY             RELEASE STACK\n         XI    RII,RIIADRM             ADR NOT OCCUPIED\nFGBH1A   LA    R9,5(R9)                RELEASE PROCEDURE IDENT\nFGBK5    BCT   R10,SPECTEST            CLOPT, BRANCH TO SPECIAL TEST\nFGBG4    CLI   0(R10),X'33'            STMT CONTEXT OP IN STACK ?\n         BE    FGBK5                   YES\n         L     R11,EXC                 SWITCH TO EXPRESSION CONTEXT\n         BCT   R10,SPECTEST            CLOPT, BRANCH TO SPECIAL TEST\nFGAB2    BAL   R4,SERR3\n         DC    H'176'                  ERROR 176\n*\n         BAL   R4,STACKAPI             INSERT API\n         OI    COMPFLGS,OPERAND        SET OPERAND ON\n         B     CP57\n*\n*        CONSTANTS AND WORKAREAS\n*\n         DC    0F'0'\nFGXFC    DC    X'000000FC'             TO EXTRACT LN FROM OPERAND\nFGOUTPAR DC    F'0'                    *** GENERATED CODE ***\n         DC    F'0'                    *** GENERATED CODE ***\nSTACKST  DC    F'0'                    PTR TO R9 ENTRY NEXT TO PROC\nSTSLPAR  DC    H'0'                    NUMBER OF PARAMETERS TIMES FIVE\nPARCOUNT DC    H'0'                    TEMPORARY STORAGE TO COUNT PARMS\nTHUNKADR DC    F'0'                    TEMPORARY STORAGE\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP61\n*\n***********************************************************************\n*\n*        CALL OF STANDARD PROCEDURES\n*        CONTEXT              STATEMENT\n*        SOURCE OPERATOR      , OR )\n*        STACK OPERATOR       STANDARD PROCEDURE BRACKET\n*        OPERANDS             ACTUAL PARAMETER\n*                             PARAMETER COUNT AND PRPOINTER AT CALL\n*                             PROCEDURE IDENTIFIER\n*\n         USING CP61,R12\nCP61     LA    R4,FOC2                 OPERAND\n         BAL   R3,OPDTEST                      TEST\nFOC2     BAL   R4,MOVEOPDK\n         MVC   0(5,R9),5(R9)           COPY PARAMETER ENTRY\n         SR    R1,R1\n         IC    R1,10(R9)                            -\n         LA    R1,4(R1)                INCR PARAMETER COUNTER\n         STC   R1,10(R9)\n         TM    15(R9),X'10'            PROCEDURE IDENTIFIER API\n         BO    FOF4                    YES, NO CHECKING\n         MVC   FOE2PCH(2),17(R9)       GET\n         LH    R2,FOE2PCH                  PAR CHAR\n         SRL   R2,0(R1)                             FROM\n         STC   R2,FOE2PCH                                PROCED IDENT\n         BAL   R4,FQA2                 TEST TYPE\nFOH2     TM    16(R9),X'03'            STAND FUNCTION HANDLED ?\n         BNZ   FTB2                    YES\nFOB4     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    FOD4                    YES, BRANCH\n         BAL   R4,ADRTRANS             GENERATE ADDR TRANSFER\nFOC4     BAL   R4,FRA3                 CONSTRUCT FLAGS\nFOD4     TM    18(R9),X'0F'            SPECIAL ACTIONS REQUIRED ?\n         BNZ   FSB1                    YES\nFOF4     LA    R9,10(R9)               RELEASE TWO ENTRIES IN OPDSTACK\n         CLI   0(R8),XFCOMMA           SOURCE A COMMA ?\n         BER   R5                      YES, BRANCH TO SUBSTART\nFPA21    SR    R1,R1\n         IC    R1,0(R9)                GET NUMBER OF PARAMETERS HANDLED\n         TM    9(R9),X'03'             HOW MANY INDICATED IN PROC ID ?\n         BZ    FPA23                   ONE\n         BM    FPA22                   TWO\n         SH    R1,KH4                  THREE\nFPA22    SH    R1,KH4\nFPA23    SH    R1,KH4\n         BNZ   FPA1                    ERROR IF NUMBER DOES NOT CHECK\nFPB2     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    FPG2                    YES, BRANCH\n         BAL   R4,LOADR1               GENERATE CALL OF STAND PROCEDURE\nFPG2     L     R3,FGBGADR\n         BALR  R4,R3                   CHECK NEXT OPERATOR\n         CLI   0(R10),X'30'            CHECK CONTEXT OPERATOR\n         BNE   FPC5                    NOT PROGRAM CONTEXT\n         L     R11,DECAADD             SWITCH TO PROGRAM CONTEXT\n         NI    COMPFLGS,255-OPERAND    RESET OPERAND\n         LA    R9,10(R9)               CLEAR TWO OPERANDS\nFPG3     BCT   R10,SPECTEST            CLOPT, BRANCH TO SPECIAL TEST\nFPC5     TM    6(R9),X'03'             STANDARD FUNCTION HANDLED ?\n         BNZ   FPD5                    YES\nFPD4     BAL   R4,SERR3                NO, ERROR\n         DC    H'168'                  ERROR 168\n*\nFPD5     CLI   0(R10),X'33'            STATEMENT CONTEXT ?\n         BE    FPE4                    YES\n         L     R11,EXC                 NO, SWITCH TO EXPR CONTEXT\nFPE4     LA    R9,10(R9)               CLOPD TWICE\n         BAL   R4,STACKAPI             INTRODUCE API\n         B     FPG3\n*\n*        SUBROUTINE FOR TYPE TEST OF CURR PAR\n*\nFQA2     ST    R4,LOADR1R\n         TM    0(R9),X'10'             CHECK IF OPERAND IS API\n         BO    FOH2                    YES\n         TM    1(R9),X'08'             PAR LABEL ?\n         BO    FQJ1                    YES\n         TM    FOE2PCH,X'03'           STRING OR PROCEDURE ?\n         BZ    FQD3                    YES\n         TM    1(R9),X'04'             PARAMETER ARRAY IDENTIFIER ?\n         BO    FQA2A                   YES, BYPASS NEXT TEST\n         BAL   R4,ARRTEST1             TEST FOR PROCEDURE IDENTIFIER\nFQA2A    XC    FOE2PCH(1),1(R9)        COMP ACT PAR WITH CHAR FROM PRI\n         TM    FOE2PCH,X'07'           TEST ARRAY AND TYPE BITS\n         L     R4,LOADR1R\n         BZR   R4                      RETURN IF ZEROES\n         BO    FQJ1                    ERROR IF ONESS\n         TM    FOE2PCH,X'08'           CALL BY NAME INDIC IN CHAR\n         BO    FQJ1                    YES, BRANCH TO ERROR\n         TM    FOE2PCH,X'03'           TEST TYPE BITS\n         BNO   FQJ1                    ERROR IF ZEROES OR MIXED\n         TM    1(R9),X'03'             TEST TYPE OF PAR\n         BNM   FQJ1                    ERROR IF NOT ARITHM TYPE\n         BR    R4                      RETURN\n*\nFQD3     TM    FOE2PCH,X'0C'           STRING INDIC BY PROCEDURE ID ?\n         BNZ   FQE3                    NO\n         TM    0(R9),X'01'             PAR STRING ?\n         BZ    FQJ1                    NO, ERROR\n         BR    R4                      RETURN\n*\nFQE3     TM    1(R9),X'C0'             PAR PROCEDURE  ?\n         BZ    FQJ1                    NO, ERROR\n         BO    FQF3                    IF PROCEDURE\n         TM    1(R9),X'80'             PAR STAND PROCEDURE ?\n         BO    FQJ1                    YES, ERROR\nFQF3     TM    1(R9),X'30'             PAR FORMAL PARAMETER ?\n         BNM   FQG3                    NO\n         TM    1(R9),X'20'             YES, IS IT CALLED BY VALUE\n         BO    FQJ1                    ERROR IF YES\nFQG3     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    FOF4                    YES, BRANCH\n         TM    1(R9),X'10'             FORMAL PAR CALLED BY NAME ?\n         BO    FQH4                    YES\n         TM    3(R9),X'E0'             MORE THAN ONE PARAMETER ?\n         BNZ   FQJ1                    YES, ERROR\n         TM    3(R9),X'10'             DOES IT HAVE ONE PARAMETER\n         BZ    FQJ1                    ERROR IF NOT\n         MVC   FQG35+1(1),2(R9)        PBN TO GENERATED CODE\n         MVN   FQG36+4(1),8(R9)\n         MVC   FQG36+5(1),9(R9)        MOVE LABEL NUMBER\n         BAL   R4,GETPARP\n         STH   R15,FQG36+2             STORE DISP IN GENERATED CODE\n         OI    FQG36+2,X'A0'           REG CDSA TO GENERATED CODE\n         LA    R2,FQG35\n         BAL   R14,GENTXTS\n         DC    H'14'                   GENERATE 14 BYTES\n         B     FOF4\n*\nFQG35    MVI   PROLPBN(FSA),X'0'       *** GENERATED CODE ***\n         STM   PBT,LAT,PROLREG(FSA)    *** GENERATED CODE ***\nFQG36    MVC   0(4,CDSA),0(LAT)        *** GENERATED CODE ***\n*\nFQH4     NI    1(R9),X'3F'             REMOVE PROCEDURE BITS FOR OPDREC\n         BAL   R4,ADRTRANS             ADDRESS TRANSFER (CALL ACT PAR)\n         B     FOF4\n*\nFPA1     BAL   R4,SERR1                ERROR PATTERN ENTRIES\n         DC    H'187'                  ERROR 187\n*\n         B     FPG2\n*\nFQJ1     BAL   R4,SERR1\n         DC    H'188'                  ERROR 188\n*\n         B     FOH2\n*\n*        CONSTRUCT FLAGS\n*\nFRA3     TM    FOE2PCH,X'08'           PROCEDURE SPECIFY 'NAME' ?\n         BZ    FOD4                    NO\n         TM    1(R9),X'04'             CURRENT PARAMETER ARRAY ?\n         BO    FOD4                    YES\n         TM    1(R9),X'30'             FORMAL PAR\n         BNM   FRF3                    NO\n         TM    1(R9),X'20'             YES, CALLED BY NAME ?\n         BO    FRF3                    NO\n         LA    R9,5(,R9)               ADJUST R9 FOR ROUT 1\n         BAL   R4,ROUTINE1             GET ADDR OF FORMAL PARAMETER\n         SH    R9,KH5                  RESTORE R9\n         LH    R1,WPLACE               GET ADDR OF\n         LA    R1,4(,R1)                           CHAR BYTES\n         STH   R1,FRE24+2                                     TO GEN C\n         MVZ   FRE24+2(1),VPLACE\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\n*                                      GENERATE 'NO ASSIGNMENT TEST'\nFRE24    TM    0(0),X'08'              *** GENERATED CODE ***\n         TM    18(R9),X'02'            PROCEDURE IDENTIFIER SYSACT ?\n         BO    FRG2                    YES\n         BAL   R2,GENTXT4              NO, GENERATE BR TO OBJ T ERROR\n         BO    OERR22(FSA)             *** GENERATED CODE ***\n         MVC   2(1,R9),SPBNST+1        CURR PBN TO PARAMETER\n         B     FOD4\n*\nFRG2     BAL   R4,GETPARP              GET DISP IN OBJ TIME STACK\n         STH   R15,FRG25+2             STORE IT IN GENERATED CODE\n         OI    FRG25+2,X'A0'           INSERT REG NUMBER\n         LA    R2,FRG24                GEN INSERTION OF NO-ASS-FLAG\n         BAL   R14,GENTXTS             IF PROC ID IS SYSACT\n         DC    H'10'                   GENERATE 10 BYTES\n*\n         B     FOD4\n*\nFRG24    BALR  R14,0                   *** GENERATED CODE ***\n         BZ    8(R14)                  *** GENERATED CODE ***\nFRG25    MVI   0(CDSA),X'40'           *** GENERATED CODE ***\n*\nFRF3     TM    0(R9),X'08'             NO ASSIGNM FLAG IN PARAMETER ?\n         BZ    FOD4                    NO\n         TM    18(R9),X'02'            PROCEDURE ID SYSACT ?\n         BZ    FRH3                    NO, ERROR\n         BAL   R4,GETPARP              DISP IN OBJ T ST\n         STH   R15,FRG45+2                              TO GENER CODE\n         OI    FRG45+2,X'A0'           INSERT REG NUMBER\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\n*                                      GENER INSERTION OF NO-ASS-FLAG\nFRG45    MVI   0(CDSA),X'40'           *** GENERATED CODE ***\n         B     FOD4\n*\nFRH3     BAL   R4,SERR1                ERROR PATTERN ENTRY\n         DC    H'188'                  ERROR 188\n*\n         B     FOF4\n*\n*        SPECIAL ACTIONS, I/O PROCEDURES\n*\nFSB1     TM    18(R9),X'0C'            INPUT OR OUTPUT ?\n         BZ    FSB3                    NEITHER, BRANCH\n         CLI   10(R9),X'04'            CURRENT PARAMETER THE FIRST ?\n         BNE   FOF4                    NO\n         BAL   R14,FSSUBR              TEST RANGE OF DATASETNR ETC\n*\n*        MAKE INSERTION IN I/O TAB\n*\nFSD2     TM    18(R9),X'08'            INPUT ?\n         BZ    FSD4                    NO\n         TM    1(R9),X'FC'             INTEGER CONST, 1ST TEST ?\n         BNZ   FSD3                    NO\n         TM    0(R9),X'C0'             INTEGER CONST, 2ND TEST\n         BNO   FSD3                    NO\n         CLI   9(R9),X'04'             DSN = 1 ?\n         BE    FRH3                    YES, ERROR\nFSD3     OI    0(R2),X'80'             NO, INDICATE INPUT\nFSD4     TM    18(R9),X'04'            OUTPUT ?\n         BZ    FSD6                    NO\n         TM    1(R9),X'FC'             INTEGER CONST, 1ST TEST ?\n         BNZ   FSD5                    NO\n         TM    0(R9),X'C0'             INTEGER CONST, 2ND TEST\n         BNO   FSD5                    NO\n         CLI   9(R9),X'00'             DSN = 0 ?\n         BE    FRH3                    YES, ERROR\nFSD5     OI    0(R2),X'40'             NO, INDICATE OUTPUT\nFSD6     B     FOF4\n*\nFSB3     TM    18(R9),X'01'            PUT/GET ?\n         BZ    FSB3A                   NO\n         OI    IOTAB+17,X'FF'          YES\nFSB3A    TM    18(R9),X'02'            SYSACT ?\n         BZ    FOF4                    NO\n*\n*        SPECIAL ACTIONS - SYSACT\n*\nFSF3     CLI   10(R9),X'08'            TEST PARAMETER COUNT\n         BH    FOF4                    BRANCH IF THIRD PARAMETER\n         BL    FSG4                    BRANCH IF FIRST PARAMETER\n         TM    1(R9),X'FC'             INTEGER CONST, 1ST TEST\n         BNZ   FSF3A                   NO\n         TM    0(R9),X'C0'             INTEGER CONST, 2ND TEST\n         BO    FSJ2                    YES\nFSF3A    MVI   SYSACTF,X'08'           INDICATE UNDETERMINED FUNCTION\nFSFJ35   SR    R15,R15                 GET\n         IC    R15,11(R9)                  ENTRY\n         SRA   R15,2                              IN\n         LA    R15,IOTAB(R15)                        I/O TAB\n         OC    0(1,R15),SYSACTF        INSERT SYSACT BIT\n         B     FOF4\n*\nFSJ2     BAL   R14,FSSUBR              INTEGER CONST TEST ETC\n         CLI   4(R9),X'00'             SYSACT FUNCTION ZERO?\n         BE    FSE1                    YES, ERROR\n         MVI   SYSACTF,X'20'\n         CLI   4(R9),X'10'             FUNCTION = 4 ?\n         BE    FSAA                    YES\n         CLI   4(R9),X'34'             NO, FUNCTION = 13 ?\n         BNE   FSBB                    NO\n*\n*        FUNCTION IS 4 OR 13\n*\nFSAA     CLI   11(R9),X'04'            DSN = 0 OR 1 ?\n         BNH   FRH3                    YES, ERROR\n         B     FSFJ35                  NO, OK\n*\nFSBB     CLI   4(R9),X'20'             FUNCTION = 8 ?\n         BE    FSBB1                   YES\n         MVI   SYSACTF,X'04'           NO, INDICATE OTHER FUNCTION\n         B     FSFJ35\n*\nFSBB1    CLI   11(R9),X'00'            DSN = 0 ?\n         BE    FRH3                    YES, ERROR\n         MVI   SYSACTF,X'10'           NO, OK\n         B     FSFJ35\n*\n*        HANDLE FIRST SYSACT PARAMETER\n*\nFSG4     BAL   R14,FSSUBR              CHECK OF INTEGER CONST ETC\n         MVC   11(1,R9),OPDADR+1       STORE DATASETNUMBER IN PTR+1\n         B     FOF4\n*\n*        CHECK PARAMETER\n*\nFSSUBR   TM    1(R9),X'FC'             INTEGER CONST, 1ST TEST\n         BNZ   FSSUBR1                 NO, BRANCH\n         TM    0(R9),X'C0'             INTEGER CONST, 2ND TEST\n         BNO   FSSUBR1                 NO, BRANCH\n         TM    2(R9),X'FF'             CONST IN CONST POOL ZERO ?\n         BNZ   FSE1                    ERROR IF NOT CONSTPOOL ZERO\n         BAL   R4,DECOMP               DECOMPOSE OPERAND\n         LH    R15,OPDADR              GET DISP IN CONST POOL ZERO\n         SRA   R15,6\n         BZ    FSSUBR2                 CONST < 16, BRANCH\nFSE1     BAL   R4,SERR1                ERROR IF NOT\n         DC    H'189'                  ERROR 189\n*\n         B     FOF4\n*\nFSSUBR1  MVI   OPDADR+1,X'40'          4*16 INTO OPDADR+1\nFSSUBR2  MVI   OPDADR,0                ZERO TO OPDADR FIRST BYTE\n         LH    R15,OPDADR\n         SRA   R15,2\n         LA    R2,IOTAB(R15)           ADDR OF IOTAB ENTRY\n         BR    R14                     RETURN\n*\n*        PROCESS ACTUAL PARAMETER FOR STANDARD FUNCTION PROCEDURE\n*\nFTB2     CLI   0(R8),XFRBRAC           SOURCE RIGHT BRACKET ?\n         BE    FTC2                    YES, BRANCH\n         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE\n         B     FOF4\n*\nFTC2     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    FOF4                    YES\n         BCTR  R10,0                   NO, CLEAR ONE OPERATOR\n         CLI   0(R10),X'33'            TEST CONTEXT OPERATOR\n         BL    FTD3                    PRC OPT, BRANCH\n         BE    FTE1                    STC OPT, BRANCH\n         L     R11,EXC                 SWITCH TO EXPR CONTEXT\nFTE1     BCTR  R10,0                   CLOPT\n         TM    19(R9),X'80'            ABS, SIGN, LENGTH, ENTIER ?\n         BZ    FUB2                    NO\n         BAL   R4,OPDREC               EXAMINE PARAMETER\n         CLI   19(R9),X'E0'            PROCEDURE ID 'LENGTH' ?\n         BE    FTG1                    YES\n         CLI   19(R9),X'F0'            PROCURE 'ENTIER' ?\n         BE    FUD1                    YES\nFTH2     TM    1(R9),X'02'             PARAMETER OF TYPE REAL ?\n         BO    FUB2                    YES\n         BAL   R4,TRINRE               NO, GENERATE INTEGER REAL CONV\n         B     FUB2\n*\nFTD3     L     R11,DECAADD             SWITCH TO PROGRAM CONTEXT\n         MVC   HALFW,13(R9)\n         LH    R7,HALFW                RESTORE OBJ TIME STACK PTR\n         NI    COMPFLGS,255-OPERAND    RESET OPERAND\n         LA    R9,20(R9)               CLEAR FOUR OPERANDS\n         BCT   R10,SPECTEST            CLOPT, BRANCH TO SPECIAL TEST\n*\n*        GENERATE CODE FOR 'LENGTH'\n*\nFTG1     BAL   R4,ROUTIN15             LOAD VW-PLACE\n         MVC   FTG12+4(2),WPLACE       ADDR OF STRING TO GEN CODE\n         MVZ   FTG12+4(1),VPLACE\n         BAL   R4,ROUTINE7             FIND NEXT GPR\n         LR    R15,R14\n         SLL   R14,4                   STORE\n         STC   R14,FTG13+1                   REG NR\n         STC   R14,FTG13+5                          IN\n         STC   R14,FTG13+7                             GENER CODE\n         OR    R15,R14\n         STC   R15,FUOTRG              SAVE REG NUMBER USED\n         LA    R2,FTG12\n         BAL   R14,GENTXTS\n         DC    H'14'                   GENERATE 14 BYTES\n*\n         B     FUF1\n*\nFTG12    MVC   HW(2,FSA),0(0)          *** GENERATED CODE ***\nFTG13    LH    0,HW(0,FSA)             *** GENERATED CODE ***\n         BCTR  0,0                     *** GENERATED CODE ***\n         BCTR  0,0                     *** GENERATED CODE ***\n*\n*        GENERATE CODE FOR 'SIGN'\n*\nFTG3     LA    R3,FTG35                RETURN ADDR IF VALUE IN REG\n         BAL   R4,ROUTIN15             LOAD VW-PLACE IF NOT VAL IN REG\n         BAL   R4,ROUTIN11             FIND NEXT FPR\n         LR    R15,R14                 REG\n         SLL   R15,4                       NR\n         STC   R15,FTG31+1                    TO\n         OR    R15,R14                          GENER\n         STC   R15,FTG33+1                             CODE\n         BAL   R4,ROUTIN12             REG NOT OCCUPIED\n         MVC   FTG31+2(2),WPLACE\n         MVZ   FTG31+2(1),VPLACE       ADDR TO GENER CODE\n         BAL   R2,GENTXTP4             GENERATE 4 BYTES\nFTG31    LD    0,0(0)                  *** GENERATED CODE ***\nFTG32    BAL   R2,GENTXTP2             GENERATE 2 BYTES\nFTG33    LTDR  0,0                     *** GENERATED CODE ***\n         B     FTH4\n*\nFTG35    MVC   FTG33+1(1),VPLACE       REG NUMBER TO GENER CODE\n         BAL   R4,ROUTIN12             REG NOT OCCUPIED\n         B     FTG32\n*\nFTH4     BAL   R4,ROUTINE7             FIND NEXT GPR\n         LR    R15,R14\n         SLL   R14,4\n         OR    R15,R14\n         STC   R15,FUOTRG              SAVER REG NUMBER\n         STC   R14,FTH42+3             REG\n         STC   R14,FTH43+1                 NUMBER TO\n         STC   R14,FTH43+7                           GENER CODE\n         LA    R2,FTH42\n         BAL   R14,GENTXTS\n         DC    H'18'                   GENERATE 18 BYTES\n*\n         B     FUF1\n*\nFTH42    BALR  BRR,0                   *** GENERATED CODE ***\n         LA    0,1                     *** GENERATED CODE ***\n         BP    16(,BRR)                *** GENERATED CODE ***\nFTH43    BCTR  0,0                     *** GENERATED CODE ***\n         BZ    16(,BRR)                *** GENERATED CODE ***\n         BCTR  0,0                     *** GENERATED CODE ***\n*\nFUB2     CLI   19(R9),X'80'            PROCEDURE ID 'ABS' ?\n         BE    FUB3                    YES\n         CLI   19(R9),X'C0'            'SIGN' ?\n         BE    FTG3                    YES\n         B     FUD2\n*\n*        GENERATE CALL OF 'ENTIER'\n*\nFUD1     TM    1(R9),X'03'             OPERAND INTEGER ?\n         BNM   FUD12\n         TM    1(R9),X'01'\n         BO    FUD14                   YES\nFUD12    LA    R3,FUD13                RETURN ADDR IF VALUE IN REG\n         BAL   R4,ROUTIN15             LOAD VW-PLACE IF NOT VAL IN REG\n         TM    RIR+1,X'01'             FPR0 FREE ?\n         BZ    FUD10                   YES\n         BAL   R4,ROUTIN14             NO, CLEAR IT\n         NI    RIR+1,X'FE'             SET FPR0 NOT OCCUPIED\nFUD10    MVC   FUD15+2(2),WPLACE\n         MVZ   FUD15+2(1),VPLACE       ADDR OF VALUE TO GEN CODE\n         BAL   R2,GENTXTP4             GENERATE 4 BYTES\nFUD15    LD    0,0(0,0)                *** GENERATED CODE ***\nFUD11    BAL   R4,ROUTINE7             INDICATE NEXT GPR\n         LR    R15,R14\n         SLL   R14,4\n         STC   R14,FUD16+1             REG NUMBER TO GEN CODE\n         OI    FUD16+1,X'0E'           REG R14 TO GEN CODE\n         OR    R15,R14\n         STC   R15,FUOTRG              SAVE REG NUMBER USED\n         TM    RII,X'01'               ADR FREE ?\n         BZ    FUD17                   YES\n         BAL   R4,ROUTIN10             NO, CLEAR IT\nFUD17    BAL   R2,GENTXT6              GENERATE 6 BYTES\n         BAL   ADR,ENTIER(FSA)         *** GENERATED CODE ***\nFUD16    LR    0,R14                   *** GENERATED CODE ***\n         B     FUF1\n*\nFUD13    TM    3(R9),X'F0'             VALUE IN FPR0 ?\n         BZ    FUD18                   YES\n         TM    RIR+1,X'01'             NO, FPR0 FREE ?\n         BZ    *+12                    YES\n         BAL   R4,ROUTIN14             NO, CLEAR IT\n         NI    RIR+1,X'FE'             SET FPR0 NOT OCCUPIED\n         MVN   FUD19+1(1),VPLACE       REG NUMBER TO GENER CODE\n         BAL   R2,GENTXTP2\nFUD19    LDR   0,0                     *** GENERATED CODE ***\n         BAL   R4,ROUTIN12             REG NOT OCCUPIED\n         B     FUD11\n*\nFUD18    NI    RIR+1,X'FE'             SET FPR0 NOT OCCUPIED\n         B     FUD11\n*\nFUD14    MVC   15(5,R9),0(R9)          PARAMETER IS INSERTED AS RESULT\n         TM    0(R9),X'40'             VALUE OR ADDR IN REG\n         BO    FUG3                    NO\n         SR    R4,R4\n         IC    R4,3(R9)                GET\n         SRL   R4,4                        REG NUMBER\n         SLL   R4,2                    4 TIMES REG NUMBER\n         LA    R9,15(,R9)              ADJUST R9\n         ST    R9,RUTI(R4)             INTRODUCE CORRECT R9 ADDR\n         B     SPECTEST                BRANCH TO SPECIAL TEST\n*\n*        GENERATE CODE FOR 'ABS'\n*\nFUB3     LA    R3,FUB4                 RETURN ADDR IF VALUE IN REG\n         BAL   R4,ROUTIN15             LOAD VW-PLACE IF NOT VAL IN REG\n         BAL   R4,ROUTIN11             FIND NEXT FPR\n         LR    R15,R14\n         SLL   R15,4\n         STC   R15,FUB31+1             REG NUMBER TO GEN CODE\n         OR    R15,R14                 SAVE REG NUMBER\n         STC   R15,FUOTRG              IN TWO HALF BYTES\n         MVC   FUB31+2(2),WPLACE       ADDR OF VALUE TO GENER CODE\n         MVZ   FUB31+2(1),VPLACE\n         BAL   R2,GENTXTP4             GENERATE 4 BYTES\nFUB31    LD    0,0(0)                  *** GENERATED CODE ***\n         MVC   FUB41+1(1),FUOTRG       REG NUMBER TO NEXT GENER INSTR\n         B     FUB42\n*\nFUB4     IC    R15,VPLACE              REG NUMBER TO GENER CODE\n         STC   R15,FUB41+1\n         STC   R15,FUOTRG              SAVE BYTE\nFUB42    BAL   R2,GENTXTP2             GENERATE 2 BYTES\nFUB41    LPDR  0,0                     *** GENERATED CODE ***\n         B     FUF2\n*\n*        GENERATE CALL FOR REMAINING FUNCTIONS\n*\nFUD2     BAL   R4,ADRTRANS             GENERATE ADDR TRANSFER\n         LA    R9,10(R9)               ADJUST R9 FOR SUBROUTINE\n         BAL   R4,LOADR1               GEN LOAD OF PARREG AND FNC CALL\n         SH    R9,KH10                 RESTORE R9\n         MVI   FUOTRG,X'00'            INDICATE FPR0\n         OI    RIR+1,X'01'             INDICATE FPR0 OCCUPIED\n         MVI   CIR+1,X'00'\n*\n*        A FLOATING POINT REG IS USED\n*\nFUF2     SR    R15,R15                 GET\n         IC    R15,FUOTRG              GET REG NUMBER USED\n         SRL   R15,4\n         SLL   R15,1                   MULT BY 2\n         LA    R1,15(,R9)              ADDR OF OPERAND\n         ST    R1,RUTR(R15)            TO RUTR\n*\n*        REPLACE PROCEDURE ID BY RESULT\n*\nFUG2     MVC   HALFW,13(R9)            RESTORE OBJ TIME ST POINTER\n         LH    R7,HALFW\n         AH    R7,ONEENTRY             ADD SIZE OF ONE ENTRY\n         STH   R7,FUOTSC+4             OBJ T STACK DISP TO GEN CODE\n         MVZ   FUOTSC+4(1),FUOTRG      INSERT REGISTER NUMBER\n         MVC   FUOTSC+3(1),SPBNST+1    CURRENT PBN\n         MVC   15(5,R9),FUOTSC+1       INSERT OPERAND INTO STACK\n         MVI   FUOTSC+2,X'32'          RESTORE TYPE 'REAL'\nFUG3     LA    R9,15(R9)               CLEAR THREE OPERANDS\n         B     SPECTEST                BRANCH TO SPECIAL TEST\n*\n*        A GENERAL REGISTER IS USED\n*\nFUF1     MVI   FUOTSC+2,X'31'          INSERT TYPE 'INTEGER'\n         SR    R15,R15                 GET\n         IC    R15,FUOTRG                  REG\n         SRL   R15,4                           NR\n         SLL   R15,2                   MULTIPLY BY 4\n         LA    R1,15(,R9)              GET ADDR OF OPERAND\n         ST    R1,RUTI(R15)            STORE ADDR IN RUTI\n         B     FUG2\n*\n*        GEN LOAD PARREG AND STAND PROC CALL\n*\nLOADR1   ST    R4,LOADR1R              SAVE RETURN ADDR\n         TM    FUOTFP,X'80'            FPR0 USED BUT NOT CLEARED ?\n         BZ    LOADR2                  NO\n         NI    FUOTFP,X'7F'            RESET INDICATOR\n         BAL   R4,CLEARRG              SAVE ALL REGS\nLOADR2   MVC   HALFW,3(R9)             GET\n         LH    R7,HALFW                    ADDR OF\n         LH    R15,ONEENTRY                        PARAMETER\n         AR    R15,R7                                        LIST\n         STH   R15,FPB21+2             ADDR TO GENERATED CODE\n         NI    9(R9),X'FC'             LAT DISP TO GENERATED CODE\n         MVC   FPB22+3(1),9(R9)\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nFPB21    LA    R1,0(CDSA)              *** GENERATED CODE ***\n         BAL   R2,GENTXT6              GENERATE 6 BYTES\nFPB22    L     ENTRY,0(LAT)            *** GENERATED CODE ***\n         BALR  R14,ENTRY               *** GENERATED CODE ***\n         L     R4,LOADR1R\n         BR    R4\n*\n*        GENERATE TRANSFER OF PARAM ADDR\n*\nADRTRANS ST    R4,LOADR1R              SAVE RETURN ADDR\n         BAL   R4,GETPARP              GET DISP IN OBJ T STACK FOR PAR\n         STH   R15,ADRTR2+2            DISP\n         STH   R15,ADRTR4+2                 TO\n         STH   R15,ADRTR6+2                    GENERATED\n         STH   R15,ADRTR8+2                              CODE\n         TM    16(R9),X'02'            STANDARD FUNCTION HANDLED ?\n         BZ    ADRTR0                  NO\n         TM    1(R9),X'02'             YES, PARAMETER OF TYPE REAL ?\n         BO    ADRTR0                  YES\n         BAL   R4,OPDREC               NO, GENERATE CONVERSION\n         BAL   R4,TRINRE\nADRTR0   BAL   R4,LDVWPLC              LOAD VWPLACE\n         TM    0(R9),X'20'             ADDR OR VALUE ?\n         BO    ADRTR3                  ADDR\n         MVC   ADRTR1+2(2),WPLACE      MOVE ADDR OF VALUE TO GEN CODE\n         MVZ   ADRTR1+2(1),VPLACE\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nADRTR1   LA    R14,0(0)                *** GENERATED CODE ***\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nADRTR2   ST    R14,0(CDSA)             *** GENERATED CODE ***\n         B     ADRTR7\n*\nADRTR3   OI    FUOTFP,X'80'            INDICATE ADDR FROM ADR\nADRTR31  CLI   VPLACE,X'AA'            ADDR IN STACK ?\n         BE    ADRTR5                  YES\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nADRTR4   ST    ADR,0(CDSA)             *** GENERATED CODE ***\n         BAL   R4,RELADR               RELEASE REG ADR\n         B     ADRTR61\n*\nADRTR5   MVC   ADRTR6+4(2),WPLACE      DISP IN STACK TO GENER CODE\n         OI    ADRTR6+4,X'A0'          REG CDSA TO GENERATED CODE\n         OI    ADRTR6+2,X'A0'\n         SH    R7,ONEENTRY             RELEASE STACK\n         BAL   R2,GENTXT6              GENERATE 6 BYTES\nADRTR6   MVC   0(4,0),0(0)             *** GENERATED CODE ***\nADRTR61  BAL   R4,CLEARRG              RESTORE ALL REGISTERS USED\nADRTR7   TM    16(R9),X'03'            STAND FUNCTION HANDLED ?\n         BNZ   ADRTR9                  YES, CONV ALREADY MADE IF NEC\n         TM    FOE2PCH,X'03'           CONVERSION NECESSARY ?\n         BZ    ADRTR9                  NO\n         OI    ADRTR8+2,X'A0'          REG CDSA TO GENERATED CODE\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nADRTR8   OI    0(0),X'80'              *** GENERATED CODE ***\nADRTR9   L     R4,LOADR1R              LOAD RETURN ADDR\n         BR    R4\n*\n*        RELEASE OF REGISTER ADR\n*\nRELADR   SH    R7,ONEENTRY             RELEASE STACK\n         XI    RII,RIIADRM             ADR NOT OCCUPIED\n         BR    R4\n*\n*        COMPUTE OBJ TIME ST DISP FOR PARAMETER\n*\nGETPARP  MVC   HALFW,13(R9)            GET STORED P-VALUE\n         SR    R15,R15\n         IC    R15,10(R9)              GET NR OF PARAMS TIMES FOUR\n         AH    R15,HALFW               ADD TO STORED P\n         AH    R15,ONEENTRY            ADD SIZE OF ONE ENTRY\n         SH    R15,KH4                 SUBTRACT SIZE OF ONE PAR ENTRY\n         BR    R4\n*\n*        CONSTANTS AND AREAS\n*\nFOE2PCH  DC    H'0'                    SAVE PARAM CHAR FROM PROC ID\nSYSACTF  DC    H'0'                    TEMPORARY STORE OF SYSACT FUNCT\nFUOTSC   DC    X'0088'                 AREA TO BUILD\n         DC    X'3200'                                OPD REPR\n         DC    X'0000'                                         RESULT\nFUOTRG   DC    X'00'                   REGISTER NUMBER USED\nFUOTFP   DC    X'00'                   TO IND ADDR FROM ADR IF ST FUNC\nFGBGADR  DC    A(FGBG20)\nLOADR1R  DC    F'0'                    TO SAVE RETURN ADDR\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP64\n*\n***********************************************************************\n*\n*        OPENING BRACKET\n*        CONTEXT              PROGRAM, STATEMENT, EXPRESSION\n*        SOURCE OPERATOR      (\n*        STACK OPERATOR       ANY\n*        OPERAND              NONE OR PROCEDURE IDENTIFIER\n*\n         USING CP64,R12\nCP64     TM    COMPFLGS,OPERAND        OPERAND ON ?\n         BO    GDAE1                   YES, BRANCH\n         C     R11,DECAADD             TEST CONTEXT\n         BNE   GDAB3                   NOT PROGRAM CONTEXT, BRANCH\n         BAL   R4,SERR3                ERROR\n         DC    H'176'                  ERROR 176\n*\n         BAL   R4,STACKAPI             API TO OPERAND STACK\nGDAE1    BAL   R4,MOVEOPTK             CURRENT CONTEXT OPERATOR TO R10\n         MVC   0(1,R10),99(R11)\n         C     R11,DECAADD             PROGRAM CONTEXT ?\n         BE    GDAG1                   YES\n         TM    0(R9),X'10'             PROC API ?\n         BO    GDAG1                   YES\n         TM    1(R9),X'03'             'TYPE' PROCEDURE ?\n         BNZ   GDAG1                   YES\n         BAL   R4,SERR3                NO, ERROR\n         DC    H'168'                  ERROR 168\n*\n         B     GDAH11\n*\nGDAG1    L     R11,STC                 SWITCH TO STATEMENT CONTEXT\nGDAH1    TM    1(R9),X'C0'             OPERAND PROCEDURE IDENTIFIER ?\n         BNZ   GDAJ1                   YES\n         BAL   R4,SERR3                NO, ERROR\n         DC    H'183'                  ERROR 183\n*\nGDAH11   BAL   R4,MOVEOPDK             GET ONE R9 ENTRY\n         B     GDBC2\n*\nGDAJ1    BAL   R4,MOVEOPDK             GET ONE R9 ENTRY\n         TM    6(R9),X'40'             STANDARD PROCEDURE ?\n         BZ    GDCA1                   YES\nGDBA1    TM    5(R9),X'10'             PROC API ?\n         BO    GDBA3                   YES\n         TM    8(R9),X'F0'             NUMBER OF PARAMETERS ZERO ?\n         BNZ   GDBA2                   NO\n         TM    6(R9),X'30'             IS PROCED FORMAL PARAMETER\n         BNM   GDBA1A                  NO, ERROR\n         TM    6(R9),X'10'             CALLED BY NAME\n         BO    GDBA3                   YES, OK\nGDBA1A   BAL   R4,SERR1\n         DC    H'187'                  ERROR 187\n*\nGDBB15   EQU   *\nGDBC2    MVC   5(5,R9),API             API REPLACES NEXT LAST ST ENTRY\nGDBA3    BAL   R4,MOVEOPDK             INCR OPERAND STACK\nGDBA4    BAL   R4,LATRES               RESERVE ONE LAT ENTRY\nGDBB4    MVC   8(2,R9),LN              LN TO R9\n         MVC   0(2,R9),ZEROHW          SET PARAM NUMBER TO ZERO\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    GDBH4                   YES, BRANCH\n         BAL   R4,CLEARRG              STORE ALL REGS USED\n         MVC   GDBG45+2(2),LN          GENERATE BRANCH PAST THUNKS\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nGDBG45   L     ADR,0(LAT)              *** GENERATED CODE ***\n         BAL   R2,GENTXT2              GENERATE 2 BYTES\n         BR    ADR                     *** GENERATED CODE ***\nGDBH4    ST    R6,WORKPL\n         MVC   2(3,R9),WORKPL+1        PRPOINT TO R9\n         MVI   1(R10),XFDELTA          PROCEDURE BRACKET TO R10\nGDBH42   BAL   R4,MOVEOPTK             INCREASE R10\n         BR    R5                      BRANCH TO SUBSTART\n*\nGDBA2    TM    5(R9),X'C0'             OPND IN REG OR OBJ TIME ST ?\n         BM    GDBA3                   YES (NOT FORMAL PARAMETER)\n         TM    6(R9),X'30'             OPND FORMAL PARAMETER ?\n         BNM   GDBA3                   NO\n         TM    6(R9),X'20'             YES, CALLED BY VALUE ?\n         BZ    GDBA3                   NO\nGDBB2    BAL   R4,SERR1                YES, ERROR\n         DC    H'174'                  ERROR 174\n*\n         B     GDBB15\n*\n*        OPERAND IS STANDARD PROCEDURE ID\n*\nGDCA1    TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    GDCG1                   YES, BRANCH\n         TM    9(R9),X'80'             ABS, SIGN, LENGTH, ENTIER ?\n         BO    GDCC1                   YES\n         IC    R15,9(R9)               MOVE 0-BIT\n         N     R15,HEXFC                          INTO\n         A     R15,LATAB                               CORR\n         NI    0(R15),X'7F'                                 LAT ENTRY\nGDCC1    STH   R7,HALFW                STORE P-VALUE IN R9\n         MVC   3(2,R9),HALFW\n         AH    R7,ONEENTRY             RESERVE SPACE FOR PARAM-LIST\n         LA    R7,8(R7)\n         STH   R7,WORKPL               CHECK FOR P-OVERFLOW\n         BAL   R4,MAXCH\nGDCG1    MVC   0(2,R9),ZEROHW          ZERO PARAM COUNT FIELD\n         MVI   1(R10),X'2A'            STAND PROCEDURE BRACKET TO R10\n         B     GDBH42\n*\nGDAB3    L     R11,EXC                 SWITCH TO EXPR CONTEXT\n         BAL   R4,MOVEOPTK             SOURCE OPERATOR TO STACK\n         MVC   0(1,R10),0(R8)\n         BR    R5                      BRANCH TO SUBSTART\n*\n*        CONSTANT\n*\n         DC    0F'0'\nHEXFC    DC    X'000000FC'             EXTRACT DISP IN LAT\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP71\n*\n***********************************************************************\n*\n*        STATEMENT END\n*        CONTEXT              STATEMENT\n*        SOURCE OPERATOR      EPSILON, ETA, END, ELSE, ;, S.E. STC\n*                             (SEE MATRIX)\n*        STACK OPERATOR       S.E. STC (SEE MATRIX)\n*        OPERAND              NOT DECISIVE\n*\n         USING CP71,R12\nCP71     L     R11,DECAADD             SWITCH TO PROGRAM CONTEXT\n         B     COMP                    GOTO COMP\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP84\n*\n***********************************************************************\n*\n*        NOT PERMITTED OPERATOR PAIR\n*        SOURCE AND STACK OPERATOR     SEE MATRIXES\n*        OPERAND                       NONE OR ONE\n*\n         USING CP84,R12\nCP84     BAL   R4,SERR1                TERMINATING ERROR\n         DC    H'173'                  ERROR 173\n*\n         B     CPERR1                  BRANCH TO TERMINATION\n*\n***********************************************************************\n*\n*        END OF IEX50004\n*\n***********************************************************************\n*\n./ ADD NAME=IEX50005 0201-12230-12230-1200-01490-01490-00000-LEVEL\n         TITLE 'IEX50 - COMPILATION PHASE - CP17'\n*\n*        CP17, CP18, CP26, CP27, CP28, CP29, CP30, CP31, CP63,\n*        CP65, CP66, CP67, CP68, CP70, CP72, CP73, CP74, CP75,\n*        CP76, CP77, CP78, CP79, CP80, CP86, CP87\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP17\n*\n***********************************************************************\n*\n*        IF STATEMENT WITH ALTERNATIVE\n*        CONTEXT              PROGRAM\n*        SOURCE OPERATOR      ELSE\n*        STACK OPERATOR       THENS\n*        OPERANDS             CASE I)   LABEL NUMBER\n*                             CASE II)  PROCEDURE IDENTIFIER\n*                                       LABEL NUMBER\n*\n         USING CP17,R12\nCP17     TM    COMPFLGS,OPERAND        OPERAND ON ?\n         BZ    BCB2                    NO, BRANCH\n         BAL   R4,PLPRST               BRANCH TO PLPRST HANDLE\n         LA    R9,5(,R9)               CLOPD\nBCB2     MVI   0(R10),X'28'            STACK 'ELSES'\n         MVI   GPBN+1,X'FF'            DESTROY GLOBAL PBN\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BOR   R5                      YES, RETURN TO SUBSTART\n         BAL   R4,LATRES               RESERVE LABEL\n         MVC   BCD2+2(2),LN            INTR LABEL NO AS DISPLACEMENT\n         BAL   R2,GENTXT6              GENERATE 6 BYTES\nBCD2     L     BRR,0(LAT,0)            *** GENERATED CODE ***\n         BR    BRR                     *** GENERATED CODE ***\n         L     R1,LATAB                LOAD ADDR OF LAT\n         MVC   WORKPL(2),3(R9)         LOAD LABEL NUMBER\n         LH    R2,WORKPL\n         ST    R6,0(R1,R2)             STORE PRPOINTER INTO LAT\n         MVC   3(2,R9),LN              KEEP NEW LABEL\n         BR    R5                      RETURN TO SUBSTART\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP83\n*\n***********************************************************************\n*\n*        CODE PROCEDURE DECLARATION (IN CALLING PROGRAM)\n*        CONTEXT              PROGRAM\n*        SOURCE OPERATOR      GAMMA\n*        STACK OPERATOR       PI, PHI, BETA\n*        OPERANDS             LABEL NUMBER\n*                             PROCEDURE IDENTIFIER\n*\n         USING CP83,R12\nCP83     BAL   R4,DECOMP               DECOMPOSE OPERAND\n         LH    R4,OPDLN                GET ADDR OF LAT ENTRY\n         L     R15,LATAB\n         ST    R6,0(R4,R15)            STORE PRPOINT IN LAT\n         MVC   KOC15,1(R8)             PROCEDURE NAME TO GENER CODE\n         LH    R15,SPBNST              GET CURRENT PBN\n         SLL   R15,3                   DISP IN PBTAB TO GENER CODE\n         STH   R15,KOC16\n         LA    R2,KOC14\n         BAL   R14,GENTXTS\n         DC    H'14'                   GENERATE 14 BYTES\n*\n         OI    IOTAB+16,X'01'          ALL DATASETS MAY BE NEEDED\nKOG1     LA    R8,8(,R8)               INCREASE SOURCE BY 8\n         BR    R5                      RETURN TO SUBSTART\n*\nKOC14    BAL   ADR,LOADPP(FSA)         *** GENERATED CODE ***\nKOC15    DC    CL8' '                  *** GENERATED CODE ***\nKOC16    DC    H'0'                    *** GENERATED CODE ***\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP18\n*\n***********************************************************************\n*\n*        END OF CONDITIONAL STATEMENT\n*        CONTEXT              PROGRAM\n*        SOURCE OPERATOR      SEMICOLON,EPSILON, ETA, END\n*        STACK  OPERATOR      ELSES\n*        OPERANDS             CASE I)   LABEL NUMBER\n*                             CASE II)  PROCEDURE IDENTIFIER\n*                                       LABEL NUMBER\n         USING CP18,R12\nCP18     TM    COMPFLGS,OPERAND        OPERAND ON ?\n         BZ    BEB2                    NO, BRANCH\n         BAL   R4,PLPRST               BRANCH TO PLPRST HANDLE\n         LA    R9,5(,R9)               CLOPD\n         NI    COMPFLGS,255-OPERAND    RESET OPERAND\nBEB2     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    BEE2                    YES, BRANCH\n         MVC   WORKPL(2),3(R9)         LOAD LABEL NUMBER\n         LH    R2,WORKPL\n         L     R1,LATAB                LOAD ADDR OF LATAB\n         ST    R6,0(R1,R2)             STORE PRPOINTER IN TO LAT\nBEE2     LA    R9,5(,R9)               CLOPD\n         MVI   GPBN+1,X'FF'            DESTROY GLOBAL DSA\n         BCT   R10,COMP                CLOPT AND COMPARE\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP26\n*\n***********************************************************************\n*\n*        ERRONEOUS CASE\n*        CONTEXT              PROGRAM\n*        SOURCE OPERATOR      ARRAY, SWITCH, PHI, PI\n*        STACK OPERATOR       .=, SEMICOLON,THENS, ELSES\n*        OPERANDS\n*\n         USING CP26,R12\nCP26     BAL   R4,ERR166               OPDT AND ERR 166/7\nBUE2     BCTR  R10,0                   RELEASE ONE OPERATOR\n         CLI   1(R10),X'1C'            'DO' ?\n         BE    BUE3                    YES, BRANCH\n         BL    BUG3                    BRANCH IF '= OR '\nBUC3     LA    R9,5(,R9)               RELEASE ONE OPERAND\nBUG4     B     COMP                    BRANCH TO COMPARE\n*\nBUE3     SR    R0,R0                   CLEAR 4 OPERANDS +\n         TM    6(R9),X'02'\n         LA    R9,20(,R9)\n         BZ    COMP\n         MVC   WORKPL(2),3(R9)\n         LH    R0,WORKPL\n         AR    R9,R0\n         B     COMP\n*\nBUG3     CLI   1(R10),XFSCOLON         SEMICOLON ?\n         BE    COMP                    YES, BRANCH\n         B     BUC3                    ASSIGMENT, BRANCH\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP27\n*\n***********************************************************************\n*\n*        ERRONEOUS CASE\n*        CONTEXT              PROGRAM, STATEMENT\n*        SOURCE OPERATOR      SEE MATRICES\n*        STACK OPERATOR       SEE MATRICES\n*        OPERANDS             VARIABLE NUMBER OF OPERANDS ACCORDING TO\n*                             THE OPERATOR\n*\n         USING CP27,R12\nCP27     TM    COMPFLGS,OPERAND        OPERAND ON ?\n         BZ    BWB2                    NO, BRANCH\n         BAL   R4,SERR3\n         DC    H'195'                  ERROR 195\n*\n         LA    R9,5(,R9)               RELEASE ONE OPERAND\n         NI    COMPFLGS,255-OPERAND    RESET OPERAND\nBNE2     BCTR  R10,0                   RELEASE ONE OPERATOR\n         SR    R1,R1\n         IC    R1,1(,R10)              LOAD OPERATOR IN R1\n         SLL   R1,2                    MULTIPLY BY FOUR\n         B     LISTE-24(R1)\nLISTE    B     COMP                    LEFT BRACKET\n         B     BWF4C                   COLON\n         B     BWH3                    BRACKET\n         B     BWJ3                    ARRAY\n         B     BWJ41                   SWITCH\n         B     BWJ41                   SEMICOLON\n         B     BWJ41                   BEGIN\n         B     BWJ41                   BETHA\n         B     BWJ41                   PHI\n         B     BWJ41\n         B     BWJ41                   EQUAL\n         B     BWJ41                   LESS\n         B     BWJ41                   GREATER\n         B     BWJ41                   NOTEQUAL\n         B     BWJ41                   NOTGREATER\n         B     BWJ41                   NOLLESS\n         B     BWF4                    ASSIGMENT\n         B     COMP                    GOTO\n         B     BWK7                    FOR\n         B     BWK5                    STEP\n         B     BWK4                    UNTIL\n         B     BWK5                    WHILE\n         B     BWJ41                   DO\n         B     COMP                    IF\n         B     BWF4                    THEN\n         B     BWJ41                   ELSE\n         B     BWJ41                   NOT\n         B     BWJ41                   IMPLICATION\n         B     BWJ41                   OR\n         B     BWJ41                   AND\n         B     BWJ41                   EQUIVALENT\n         B     BWJ41                   ALPHA\n         B     COMP                    IFS\n         B     BWJ41                   THENS\n         B     BWJ41                   ELSES\n         B     BWG3                    PARENT IN PROCEDURE\n         B     BWG4                    PARENT IN STANDARD FUNCTION\n         B     BWJ41                   MONODIC MINUS\n         B     BWF4B                   BRACKET  RECL\n         B     BWK6                    FOR.=\n         B     BWK3                    SWITCH.=\n*\nBWK4     LA    R9,5(,R9)               CLOPT\nBWK5     BCTR  R10,0                   CLOPT\nBWK6     BCTR  R10,0                   CLOPT\nBWK8     LA    R10,1(R10)              RESERVE ONE PLACE IN STACK\n         MVI   0(R10),X'1C'            STACK 'DO'\n         B     COMP                    BRANCH TO COMPARE\n*\nBWK7     BAL   R4,STACKAPI             STACK API\n         B     BWK8\n*\nBWF4     LA    R9,5(,R9)               RELEASE ONE OPERAND\n         B     COMP                    BRANCH TO COMPARE\n*\nBWH3     LA    R9,15(0,R9)             RELEASE THREE OPERANDS\n         B     BWG31                   BRANCH\n*\nBWJ4     CLI   0(R8),XFSCOLON          SEMICOLON IN SOURCE ?\n         BE    BWJ41\n         B     COMP\n*\nBWG4     LA    R9,20(,R9)              RELEASE FOUR OPERANDS\n         B     BWG31                   BRANCH\n*\nBWG3     SR    R0,R0                   RELEASE\n         IC    R0,0(R9)                        N\n         SLL   R0,8                              +\n         IC    R0,1(R9)                            2\n         LA    R9,10(R0,R9)                          OPERANDS\nBWG31    TM    0(R10),X'30'            CHECK IF IN STACK CONT OPT\n         BNO   COMP                    NO, BRANCH\n         BCTR  R10,0                   RELEASE ONE OPERATOR\n         L     R11,DECAADD             LOAD R11 WITH PROG CONT MA\n         CLI   1(R10),X'30'            CHECK IF PROG CONT OPT\n         BE    COMP                    BRANCH IF PCO TO COMPARE\n         L     R11,STC                 LOAD R11 WITH STAT CONT MA\n         CLI   1(R10),X'33'            CHECK IF STAT CONT OPT\n         BE    COMP                    BRANCH IF STC TO COMPARE\n         L     R11,EXC                 LOAD R11 WITH EXP CONT MAT\n         B     COMP                    BRANCH TO COMPARE\n*\nBWK3     SR    R1,R1\n         IC    R1,1(R9)                NO OF SWITCH ELEMENT OPERANDS\n         LA    R9,20(R9,R1)            CLEAR OPERANDS\n         B     COMP                    BRANCH TO COMPARE\n*\nBWF4C    BCTR  R10,0                   COLON\nBWF4B    BCTR  R10,0                   ARRAY BRACKET\n         LA    R9,15(R9)               RELEASE 3 OPERANDS\nBWJ3     AH    R9,GREGN                CLEAR NUMBER OF ARRAY IDENT\n         MVC   GREGN(2),ZEROHW         CLEAR COUNTER\n         B     COMP\n*\nBWB2     BAL   R4,SERR3                ERROR PATTERN ENTRY\n         DC    H'194'                  ERROR 194\n*\n         B     BNE2\n*\nBWJ41    L     R12,SCPTAB+4*84         R12 -> CP84\n         BR    R12                     BRANCH TO CP84\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP28\n*\n***********************************************************************\n*\n*   ERRONEOUS CASE - DECLARATION IN WRONG  POSITION\n*        CONTEXT              PROGRAM\n*        SOURCE OPERATOR      S\n*        STACK OPERATOR       SEE PROGRAM CONTEXT  MATRIX\n*        OPERANDS             VARIABLE NUMBER OF OPERANDS ACCORDING TO\n*                             THE OPERATOR\n*\n         USING CP28,R12\nCP28     BAL   R4,ERR166\n         BAL   R4,SCHDL                SEMICOLON HANDLING\n         CLI   0(R10),XFCOLON          STACK OPERATOR COLON ?\n         BE    BYF1                    YES\n         CLI   0(R10),X'2C'            ARRAY BRACKET IN STACK\n         BE    BYF1+2                  YES\n         CLI   0(R10),X'0A'            SWITCH  IN STACK\n         BE    BYF2                    YES\n         BR    R5                      RETURN TO SUBSTART\n*\nBYF1     BCTR  R10,0                   RELEASE COLON\n         SH    R10,KH2                 RELEASE BRACKET AND ARRAY\n         LA    R9,15(R9)               RELEASE 3 OPERANDS\n         AH    R9,GREGN                CLEAR NUMBER OF ARRAY IDENT\n         MVC   GREGN(2),ZEROHW         CLEAR COUNTER\n         BR    R5                      RETURN TO SUBSTART\n*\nBYF2     LA    R9,10(R9)               CLEAR TWO OPERANDS\n         BCTR  R10,R5                  CLEAR SWITCH, SUBSTART\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP29\n*\n***********************************************************************\n*\n*        ERRONEOUS CASE  - BEGIN OF DECLARATION\n*        CONTEXT              PROGRAM\n*        SOURCE OPERATOR      ARRAY,SWITCH,PI,PHI\n*        STACK OPERATOR       BEGIN, DO\n*        OPERANDS             NONE OR ONE\n*\n         USING CP29,R12\nCP29     BAL   R4,ERR166\nCAF1     L     R12,SCPTAB+4*4          R12 -> CP4\n         BR    R12                     BRANCH TO CP4\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP30\n*\n***********************************************************************\n*\n*        ERRONEOUS CASE  - LABEL IN INCORRECT POSITION\n*        CONTEXT              PROGRAM\n*        SOURCE OPERATOR      LABEL OPERATOR\n*        STACK OPERATOR       SEE PROGRAM CONTEXT MATRIX\n*        OPERANDS             LABEL IDENTIFIER\n*\n         USING CP30,R12\nCP30     TM    COMPFLGS,OPERAND        OPERAND ON ?\n         BZ    BKQB1                   NO, BRANCH\n         BAL   R4,SERR2\n         DC    H'169'                  ERRO 169\n*\n         LA    R9,5(,R9)               RELEASE ONE OPERAND\n         BR    R5                      BRANCH TO SUBSTART\n*\nBKQB1    L     R12,SCPTAB+4*84         R12 -> CP84\n         BR    R12                     BRANCH TO CP84\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP31\n*\n***********************************************************************\n*\n*        ERRONEOUS CASE  - INCORRECT CONBINATION OF OPERATORS IN\n*                          PROGRAM CONTEXT\n*        SOURCE OPERATOR      SEE PROGRAM CONTEXT MATRIX\n*        STACK  OPERATOR      SEE PROGRAM CONTEXT MATRIX\n*        OPERANDS             NONE OR ONE\n*\n         USING CP31,R12\nCP31     LA    R11,614(,R11)           SWITCH TO EXPRESSION CONTEXT\n         TM    COMPFLGS,OPERAND        OPERAND ON ?\n         BZ    CEB2                    NO, BRANCH\n         BAL   R4,SERR4\n         DC    H'161'                  ERROR 161\n*\n         B     COMP                    BRANCH TO COMPARE\n*\nCEB2     BAL   R4,SERR4\n         DC    H'160'                  ERROR 160\n*\n         B     COMP                    BRANCH TO COMPARE\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP63\n*\n***********************************************************************\n*\n*        MONADIC MINUS SIGN\n*        CONTEXT              EXPRESSION\n*        SOURCE OPERATOR      ALL EXCEPT 'NOT',C,1),'IF','POWER'\n*        STACK OPERATOR       MONADIC MINUS\n*        OPERANDS             ARITHMETIC OPERAND\n*\n         USING CP63,R12\nCP63     LA    R4,GBD4                 LOAD RETURN ADD FOR ERROR\n         BAL   R3,OPDTEST              OPDT AND ERROR NUMBER 162\n         BAL   R4,ARRTEST1             ARRAY AND PROC TEST\n         TM    1(R9),X'03'             OPERAND ARITHMETIC ?\n         BM    GAD1                    YES, BRANCH\n         TM    0(R9),APIMASK           OPERAND API ?\n         BZ    GAC2                    NO, BRANCH\nGBD4     BCT   R10,COMP                RELEASE 1 OPT AND COMPARE\nGAD1     TM    COMPFLGS,COMPMODE+SUBSCOPT  SYNTAX OR SUBSC OPTIMIZED ?\n         BNZ   GBD4                    NO, BRANCH\n         BAL   R4,OPDREC               OPERAND RECOGNIZER\n         TM    1(R9),X'02'             OPERAND REAL ?\n         BZ    GBE1                    NO, INTEGER, BRANCH\n         TM    0(R9),X'20'             OPERAND A VALUE ?\n         BO    GAH3                    AN ADDR, BRANCH\n         TM    0(R9),X'40'             OPERAND IN A REGISTER ?\n         BO    GAH2                    NO, IN STORAGE, BRANCH\n         IC    R14,3(R9)               INSERT\nGBC5     STC   R14,GAJ1+1              REGISTER\n         SRL   R14,4                   INTO\n         STC   R14,WORKPL              GENERATED\n         MVN   GAJ1+1(1),WORKPL\n         BAL   R2,GENTXTP2             GENERATE 2 BYTES\nGAJ1     LCDR  0,0                     *** GENERATED CODE ***\nGAJ11    OI    0(R9),X'08'             INSERT NO ASSIGMENT BIT\n         BCT   R10,COMP                DELEASE OPERATOR AND COMP\nGAH2     TM    0(R9),X'80'             LO IN A REG BEFORE ?\n         BO    GAH3                    NO, BRANCH\n         SH    R7,ONEENTRY             RELEASE 1 OBJ STACK ENTRY\nGAH3     BAL   R4,ROUTIN11             RESERVE A FLOATING POINT REG\n         SH    R9,KH5                  INCREASE OPERAND STACK\n         TM    5(R9),X'20'             LO A VALUE ?\n         BZ    GBC2                    YES, BRANCH\n         BAL   R4,ROUTINE2             CALL ROUTINE NUMBER 2\nGBC4     LA    R9,5(,R9)               DECREASE OPERAND STACK\n         SLL   R14,4\n         B     GBC5                    BRANCH\n*\nGBC2     BAL   R4,ROUTINE4             GENERATE LOADING INTO FPR\n         B     GBC4                    BRANCH\n*\nGBE1     TM    0(R9),X'20'             OPERAND A VALUE ?\n         BO    GBF3                    ADDR, BRANCH\n         TM    0(R9),X'40'             OPERAND IN A REGISTER ?\n         BO    GBF2                    IN STORAGE, BRANCH\n         IC    R14,3(R9)               INSERT\nGBG11    STC   R14,GBG1+1              REGISTER\n         SRL   R14,4                   INTO\n         STC   R14,WORKPL              GENERATED\n         MVN   GBG1+1(1),WORKPL        CODE\n         BAL   R2,GENTXT2              GENERATE 2 BYTES\nGBG1     LCR   0,0                     *** GENERATED CODE ***\n         B     GAJ11\n*\nGBF2     TM    0(R9),X'80'             LO IN A REG BEFORE ?\n         BO    GBF3                    DECREASE\n         SH    R7,ONEENTRY             RELEASE 1 OBJ STACK ENTRY\nGBF3     BAL   R4,ROUTINE7             RESERVE GENERAL PURPOSE REG\n         SH    R9,KH5                  INCREASE OPERAND STACK\n         TM    5(R9),X'20'             LO A VALUE ?\n         BO    GBH5                    AN ADDR, BRANCH\n         BAL   R4,ROUTINE5             GENERATE LOADING INTO GPR\nGBK4     LA    R9,5(,R9)               DECREASE OPERAND STACK\n         SLL   R14,4                   SHIFT REGISTER NUMBER\n         B     GBG11                   BRANCH\n*\nGBH5     BAL   R4,ROUTINE6             GENERATE LOADING INTO GPR\n         B     GBK4                    BRANCH\n*\nGAC2     BAL   R4,SERR2\n         DC    H'163'                  ERROR 163\n*\nGAC4     MVC   0(5,R9),API             MOVE API\n         BCT   R10,COMP                RELEASE OPERATOR AND COMP\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP65\n*\n***********************************************************************\n*\n*        HANDLING OF 'NOT' AND 'IF'\n*        CONTEXT              EXPRESSION\n*        SOURCE OPERATOR      CASE I 'NOT'\n*                             CASE II 'IF'\n*\n*        STACK OPERATOR       CASE I  ALL EXCEPT  'NOT',ARITHMETICAL\n*                                     OPERATORS,RELATIONAL OPERATORS\n*        CASE II 'IF','IFS'\n*\n*        OPERANDS             NONE\n*\n         USING CP65,R12\nCP65     TM    COMPFLGS,OPERAND        OPERAND ON ?\n         BZ    GFC2                    NO, BRANCH\n         BAL   R4,SERR4\n         DC    H'164'                  ERROR 164\n*\n         LA    R9,5(,R9)               RELEASE ONE OPERAND\nGFC2     BAL   R4,MOVEOPTK             INCREASE OPT STACK POINTER\n         MVC   0(1,R10),0(R8)          INSERT SOURCE INTO STACK\n         BR    R5                      RETURN TO SUBSTART\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP66\n*\n***********************************************************************\n*\n*        HANDLING OF PLUS AND MINUS\n*        CONTEXT              EXPRESSION\n*        SOURCE OPERATOR      +,-\n*        STACK  OPERATOR      ALL EXCEPT ARITHMETIC  OPERATORS\n*        OPERANDS             NONE OR ONE ARITHMETIC OPERAND.\n*\n         USING CP66,R12\nCP66     BAL   R4,MOVEOPTK                   INCREASE OPT STACK POINTER\n         TM    COMPFLGS,OPERAND              OPDT\n         BZ    GHC2                          BRANCH IF FALSE\n         MVC   0(1,R10),0(R8)                INSERT SOURCE INTO STACK\n         BR    R5                            BRANCH TO SNOT\nGHC2     CLI   0(R8),XFMINUS                 MINUS IN SOURCE ?\n         BNE   GHC3                          NO, BRANCH\n         MVI   0(R10),X'2B'                  STACK MONADIC MINUS\n         BR    R5                            BRANCH TO SUBSTART\n*\nGHC3     MVI   SWVAL,X'FF'                   SET SWITCH TO ONE\n         BCTR  R10,0                         DECREASE OPT STACK POINTER\nGHC4     CLI   1(R8),XFZETA                  END OF SOURCE BUFFER ?\n         BL    GHC5                          BRANCH IF OPERATOR\n         BHR   R5                            OPERAND, BR TO SUBSTART\n         BAL   R4,JBUFFER\n         B     GHC4\n*\nGHC5     CLI   1(R8),XFLBRAC                 LEFT BRACKET IN SOURCE ?\n         BER   R5                            YES, BRANCH TO SUBSTART\n         BAL   R4,SERR4                      ERROR PATTERN ENTRY\n         DC    H'160'                        ERROR 160\n*\n         BR    R5                            BRANCH TO SUBSTART\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP67\n*\n***********************************************************************\n*\n*        STACKING OF ARITHMETIC, RELATIONAL OR BOOLEAN OPERATORS\n*        CONTEXT              EXPRESSION\n*        SOURCE OPERATOR      SEE EXPRESSION CONTEXT  MATRIX\n*        STACK  OPERATOR      SEE EXPRESSION CONTEXT  MATRIX\n*        OPERANDS             ONE OPERAND\n*\n         USING CP67,R12\nCP67     TM    COMPFLGS,OPERAND        OPERAND ON ?\n         BZ    GJC2                    NO, BRANCH\n         BAL   R4,MOVEOPTK             INCREASE OPT STACK POINTER\n         MVC   0(1,R10),0(R8)          INSERT SOURCE INTO STACK\n         CLI   0(R10),XFPOWER          OPT POWER ?\n         BNER  R5                      NO, RETURN TO SUBSTART\n         MVI   SWVAL,0                 SET SWITCH TO ZERO\n         BR    R5                      RETURN TO SUBSTART\n*\nGJC2     BAL   R4,SERR4                ERROR PATTERN ENTRY\n         DC    H'162'                  ERROR 162\n*\n         BR    R5                      RETURN TO SUBSTART\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP68\n*\n***********************************************************************\n*\n*        OPENING AND CLOSING PARENTHESIS\n*        CONTEXT              EXPRESSION\n*        SOURCE OPERATOR      )\n*        STACK OPERATOR       (\n*        OPERANDS             ONE\n*\n         USING CP68,R12\nCP68     LA    R4,GLF2                 LOAD RETURN ADDR\n         BAL   R3,OPDTEST              OPDT AND ERROR 162\nGLF2     BCT   R10,SPECTEST            RELEASE OPT AND SPECIAL TEST\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP70\n*\n***********************************************************************\n*\n*        CONTEXT SWITCH,EXPRESSION CONTEXT\n*        CONTEXT              EXPRESSION\n*        SOURCE OPERATOR      ),'ELSE' ALL OPERATORS NOT SPECIFIED IN\n*                             EXPRESSION CONTEXT\n*        STACK OPERATOR       ALL OPERATORS NOT SPECIFIED IN\n*                             EXPRESSION CONTEXT\n*        OPERANDS             NOT TREATED\n*\n         USING CP70,R12\nCP70     SH    R11,KH324               SWITCH TO STMT  CONTEXT\n         B     COMP                    BRANCH TO COMPARE\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP72\n*\n***********************************************************************\n*\n*        NESTED CONDITIONAL EXPRESSIONS\n*        CONTEXT              EXPRESSION\n*        SOURCE OPERATOR      'ELSE'\n*        STACK OPERATOR       'ELSE'\n*        OPERANDS             NOT TR\n*\n         USING CP72,R12\nCP72     BCTR  R10,0                   DECREASE OPT STACK POINTER\n         CLI   0(R10),XFASSIGN         OPT ASSIGMENT ?\n         BE    JAF2                    YES, BRANCH\n         CLI   0(R10),XFGOTO           OPT GOTO ?\nJAF2     LA    R10,1(,R10)             INCR OPT STACK POINTER\n         L     R12,SCPTAB+4*75         R12 -> CP75\n         BNE   0(R12)                  NOT ASSIGMENT, BRANCH\n         L     R12,SCPTAB+4*79         R12 -> CP79\n         BR    R12                     BRANCH TO CP79\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP73\n*\n***********************************************************************\n*\n*        ERRONEOUS CASE - THE OPENING PARENTHESIS IS MISSING IN\n*                         A CONDITIONAL EXPRESSION\n*        CONTEXT              EXPRESSION\n*        SOURCE OPERATOR      'IF'\n*        STACK OPERATOR       SEE EXPRESSION CONTEXT MATRIX\n*        OPERANDS             NONE OR ONE\n*\n         USING CP73,R12\nCP73     TM    COMPFLGS,OPERAND        OPERAND ON ?\n         BZ    JGB2                    NO, BRANCH\n         BAL   R4,SERR4                ERROR PATTERN ENTRY\n         DC    H'161'                  ERROR 161\n*\n         LA    R9,5(,R9)               RELEASE ONE OPERAND\nJGE1     BAL   R4,MOVEOPTK             INCR OPT POINTER\n         MVI   0(R10),XFLBRAC          INSERT '(' INTO STACK\n         BAL   R4,MOVEOPTK             INCR OPT POINTER\n         MVC   0(1,R10),0(R8)          INSERT SOURCE INTO STACK\n         BR    R5                      BRANCH TO SUBSTART\n*\nJGB2     BAL   R4,SERR4                ERROR PATTERN ENTRY\n         DC    H'160'                  ERROR 160\n*\n         B     JGE1\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP74\n*\n***********************************************************************\n*\n*        ERRONEOUS CASE - CONBINATION OF TWO RELATIONAL OPERATORS\n*        CONTEXT              EXPRESSION\n*        SOURCE OPERATORS     RELATIONAL OPERATOR\n*        STACK OPERATORS      RELATIONAL OPERATOR\n*        OPERANDS             NONE OR ONE\n*\n         USING CP74,R12\nCP74     TM    COMPFLGS,OPERAND        OPERAND ON ?\n         BZ    JIB2                    NO, BRANCH\n         BAL   R4,SERR4                ERROR PATTERN ENTRY\n         DC    H'161'                  ERROR 161\n*\nJIF2     BAL   R4,MOVEOPTK             INCR OPT POINTER\n         MVI   0(R10),XFASTER          INSERT * INTO STACK\n         BR    R5                      BRANCH TO SUBSTART\n*\nJIB2     BAL   R4,SERR4                ERROR PATTERN ENTRY\n         DC    H'160'                  ERROR 160\n*\n         BAL   R4,STACKAPI             STACK ALL PURPOSE IDENT\n         B     JIF2\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP74\n*\n***********************************************************************\n*\n*        ERRONEOUS CASE - NOT PERMITED OPERATOR PAIR WHERE THE STACK\n*                         OPERATOR IS ASSUMED TO BE THE CORRECT ONE\n*        CONTEXT              PROGRAM, STATEMENT, EXPRESSION\n*        SOURCE OPERATOR      SEE CONTEXT MATRICES\n*        STACK OPERATOR       SEE CONTEXT MATRICES\n*        OPERANDS             NONE OR ONE\n*\n         USING CP75,R12\nCP75     TM    COMPFLGS,OPERAND        OPERAND ON ?\n         BZ    JKB2                    NO, BRANCH\n         BAL   R4,SERR3                ERROR PATTERN ENTRY\n         DC    H'195'                  ERROR 195\n*\n         LA    R9,5(,R9)               RELEASE ONE OPERAND\n         BR    R5                      BRANCH TO SUBSTART\n*\nJKB2     BAL   R4,SERR3                ERROR PATTERN ENTRY\n         DC    H'194'                  ERROR 194\n*\n         BR    R5                      BRANCH TO SUBSTART\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP76\n*\n***********************************************************************\n*\n*        BOOLEAN OPERATIONS\n*        CONTEXT              EXPRESSION\n*        SOURCE OPERATOR      SEE EXPRESSION CONTEXT MATRIX\n*        STACK  OPERATOR      SEE EXPRESSION CONTEXT MATRIX\n*        OPERAND              TWO OPERANDS\n*\n         USING CP76,R12\nCP76     LA    R4,JRF41\n         BAL   R3,OPDTEST              OPDT AND ERROR 162\n         BAL   R4,ARRTEST2\n         TM    6(R9),X'03'             BLO BOOLEAN ?\n         BNO   JMC2                    NO, BRANCH\n         TM    1(R9),X'03'             LO BOOLEAN ?\n         BNO   JMC3                    NO, BRANCH\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    JRF41                   YES, BRANCH\n         BAL   R4,OPDREC               OPERAND RECOGNIZER (LO)\n         LA    R9,5(,R9)               DECREASE OPERAND POINTER\n         BAL   R4,OPDREC               OPERAND RECOGNIZER (BLO)\n         SH    R9,KH5                  INCREASE OPERAND POINTER\n         TM    5(R9),X'A0'             BLO A VALUE OR IN STACK ?\n         BNZ   JOB1                    NO, BRANCH\n         MVC   YPLACE(2),8(R9)         Y = DISP(BLO)\n         OI    YPLACE,X'A0'            X = CDSA\nJNE1     TM    0(R9),X'20'             LO A VALUE ?\n         BO    JNE5                    NO, BRANCH\n         TM    0(R9),X'80'             LO IN STACK ?\n         BO    JNF2                    NO, BRANCH\n         MVC   WPLACE(2),3(R9)         W = DISP(LO)\n         OI    WPLACE,X'A0'            V = CDSA\nJRB3     MVC   JRC3+2(2),YPLACE        PREPARE INSTRUCTION\n         MVC   JRC3+4(2),WPLACE\n         TM    0(R10),X'02'            OPT 'IMPL' OR 'EQUIV' ?\n         BZ    JRC4                    YES, BRANCH\n         TM    0(R10),X'01'            OPT AND ?\n         BO    JRC2                    YES, BRANCH\nJRC22    MVI   JRC3,X'D6'              PREPARE INSTRUCTION\nJRC21    BAL   R2,GENTXT6              GENERATE 6 BYTES\nJRC3     OC    0(1,0),0(0)             *** GENERATED CODE ***\nJRF4     NI    YPLACE,X'0F'            CLEAR REGISTER NUMBER\n         LH    R7,YPLACE               LOAD VALUE OF OBJ ST POINT\n         OI    5(R9),X'08'             INSERT NO-ASSIGNMENT BIT\nJRF41    LA    R9,5(,R9)               CLOPD\nJRG4     BCT   R10,COMP                CLOPT AND COMPARE\nJRC2     MVI   JRC3,X'D4'              INSERT OPER CODE INTO CODE\n         B     JRC21\n*\nJRC4     MVC   JRC41+2(2),JRC3+2       PREPARE INSTRUCTION\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nJRC41    XI    0(0),X'01'              *** GENERATED CODE ***\n         CLI   0(R10),X'21'            OPT EQUIV ?\n         BE    JRC22                   YES, BRANCH\n         MVI   JRC3,X'D7'              INSERT OPER-CODE INTO CODE\n         B     JRC21\n*\nJNF2     TM    2(R9),X'FF'             LO A CONSTANT ?\n         BNZ   JNF4                    NO, BRANCH\nJSB3     MVC   JSE3+1(1),4(R9)         PREPARE INTRUCTION\n         NI    JSE3+1,X'01'\n         MVC   JSE3+2(2),YPLACE\n         TM    0(R10),X'02'            WHICH OPT\n         BZ    JSE4                    EQU OR IMPL, BRANCH\n         TM    0(R10),X'01'            OPT AND ?\n         BO    JSE2                    YES, BRANCH\nJSE22    MVI   JSE3,X'96'              PREPARE INSTRUCTION\nJSE21    BAL   R2,GENTXT4              GENERATE 4 BYTES\nJSE3     OI    0(0),X'00'              *** GENERATED CODE ***\n         B     JRF4\n*\nJSE2     MVI   JSE3,X'94'              PREPARE INSTRUCTION\n         B     JSE21\n*\nJSE4     MVC   JSE41+2(2),JSE3+2       PREPARE INSTRUCTION\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nJSE41    XI    0(0),X'01'              *** GENERATED CODE ***\n         CLI   0(R10),X'21'            OPT EQUIV ?\n         BE    JSE22                   YES, BRANCH\n         MVI   JSE3,X'97'              PREPARE INSTRUCTION\n         B     JSE21\n*\nJNF4     BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1\nJNF41    MVZ   WPLACE(1),VPLACE        PREPARE W-V-PLACE\n         B     JRB3\n*\nJNE5     BAL   R4,ROUTINE3             CALL ROUTINE NUMBER 3\n         B     JNF41\n*\nJOB1     TM    0(R9),X'A0'             LO A VALUE AND IN STACK ?\n         BNZ   JOC2                    NO, BRANCH\n         MVC   YPLACE(2),3(R9)         Y= DISPL(LO)\n         OI    YPLACE,X'A0'            X=CDSA\n         CLI   0(R10),X'21'            OPT IMPL ?\n         BNE   JOE2                    NO, BRANCH\n         AH    R7,ONEENTRY             RESERVE OBJECT STACK ENTRY\n         STH   R7,WORKPL               CHECK MAX\n         BAL   R4,MAXCH\n         MVC   JOG1+4(2),YPLACE        PREPARE INSTRUCTION\n         MVC   JOG1+2(2),WORKPL\n         OI    JOG1+2,X'A0'\n         BAL   R2,GENTXT6              GENERATE 6 BYTES\nJOG1     MVC   0(1,CDSA),0(0)          *** GENERATED CODE ***\n         MVC   3(2,R9),WORKPL          ADJUST OPERAND\n         B     JPB1\n*\nJOE2     MVC   WORKPL(5),0(R9)         CHANGE LO AND BLO\n         MVC   0(5,R9),5(R9)\n         MVC   5(5,R9),WORKPL\n         B     JNE1\n*\nJOC2     AH    R7,ONEENTRY             INCREASE P\n         STH   R7,WORKPL               CHECK MAX\n         BAL   R4,MAXCH\n         STH   R7,YPLACE               Y = DISPL\n         OI    YPLACE,X'A0'            X = CDSA\nJPB1     TM    5(R9),X'20'             BLO A VALUE ?\n         BO    JQB2                    AN ADDR, BRANCH\n         TM    7(R9),X'FF'             BLO A CONSTANT ?\n         BNZ   JQB2                    NO, BRANCH\n         MVC   JQE1+1(1),9(R9)         PREPARE INSTRUCTION\n         NI    JQE1+1,X'01'\n         MVC   JQE1+2(2),YPLACE\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nJQE1     MVI   0(CDSA),X'00'           *** GENERATED CODE ***\n         OI    6(R9),X'30'             ADJUST R9 ENTRY OF BLO\nJQE2     NI    5(R9),X'5F'\n         MVC   7(1,R9),SPBNST+1\n         MVC   8(2,R9),YPLACE\n         NI    8(R9),X'0F'\n         B     JNE1\n*\nJMC2     BCTR  R10,0                   DECR OPT ST POINTER\n         BAL   R4,SERR2                ERROR PATTERN ENTRY\n         DC    H'182'                  ERROR 182\n*\n         LA    R10,1(,R10)             INCR OPT ST POINT\nJMC31    MVC   5(5,R9),API             INSERT ALL PURPOSE IDENT\n         B     JRF41\n*\nJMC3     BAL   R4,SERR2                ERROR PATTERN ENTRY\n         DC    H'182'                  ERROR 182\n*\n         B     JMC31\n*\nJQB2     LA    R9,5(,R9)               INCREASE R9\n         TM    0(R9),X'20'             BLO A VALUE ?\n         BO    JQB4\n         BAL   R4,ROUTINE1             LOAD W-V-PLACE FOR VALUE\nJQD3     SH    R9,KH5                  INCREASE OPERAND ST POINTER\n         MVC   JQE3+2(2),YPLACE        PREPARE INSTRUCTION\n         MVC   JQE3+4(2),WPLACE\n         MVZ   JQE3+4(1),VPLACE\n         BAL   R2,GENTXT6              GENERATE 6 BYTES\nJQE3     MVC   0(1,0),0(0)             *** GENERATED CODE ***\n         B     JQE2\n*\nJQB4     BAL   R4,ROUTINE3\n         OI    0(R9),X'40'             ADJUST OPERAND\n         B     JQD3\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP77\n*\n***********************************************************************\n*\n*        LOGICAL OPERATION NOT\n*        CONTEXT              EXPRESSION\n*        SOURCE OPERATOR      ALL EXCEPT 'NOT',(,(/,'IF',ARITHMETIC\n*                             AND RELATIONAL OPERATORS\n*        STACK OPERATOR       'NOT'\n*        OPERANDS             ONE BOOLEAN\n*\n         USING CP77,R12\nCP77     LA    R4,JWB2                 LOAD RETURN ADDR\n         BAL   R3,OPDTEST              OPDT AND ERROR 162\n         BAL   R4,ARRTEST1             ARRAY AND PROC TEST\n         TM    1(R9),X'03'             OPERAND BOOLEAN ?\n         BO    JWD1                    YES, BRANCH\n         BAL   R4,SERR2                ERROR PATTERN ENTRY\n         DC    H'182'                  ERROR 182\n*\nJWC4     MVC   0(5,R9),API             INTRODUCE API\nJWK3     BCT   R10,COMP                RELEASE OPERATOR AND COMP\nJWD1     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    JWK3                    YES, BRANCH\n         BAL   R4,OPDREC               OPERAND RECOGNIZER\n         TM    0(R9),X'20'             OPERAND A VALUE ?\n         BO    JWF2                    AN ADDR, BRANCH\n         TM    2(R9),X'FF'             OPERAND A VARIABLE ?\n         BZ    JWH1                    CONSTANT, BRANCH\n         TM    0(R9),X'80'             OPERAND IN OBJ STACK ?\n         BO    JWG3                    NO, BRANCH\nJWH21    MVC   JWH2+2(2),3(R9)         PREPARE INSTRUCTION\n         OI    JWH2+2,X'A0'            INTRODUCE CDSA\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nJWH2     XI    0(CDSA),X'01'           *** GENERATED CODE ***\nJWH3     OI    0(R9),X'08'             INSERT NO ASSIGMENT BIT\nJWB2     BCT   R10,COMP                RELEASE OPERATOR AND COMP\nJWG3     BAL   R4,ROUTINE1             LOAD W-V-PLACE FOR VALUE\nJWG31    AH    R7,ONEENTRY             RESERVE OBJECT STACK ENTRY\n         STH   R7,WORKPL               STORE P INTO WORKPL\n         BAL   R4,MAXCH                CHECK MAXIMUM\n         NI    0(R9),X'5F'             ADJUST OPERAND\n         MVC   3(2,R9),WORKPL          INSERT OBJ STACK DISPLACEMENT\n         MVC   2(1,R9),SPBNST+1        INSERT BLOCK NUMBER\n         MVC   JWJ3+2(2),WORKPL        PREPARE INSTRUCTION\n         OI    JWJ3+2,X'A0'            INSERT CDSA\n         MVC   JWJ3+4(2),WPLACE        INSERT W-PLACE\n         MVZ   JWJ3+4(1),VPLACE        INSERT V-PLACE\n         BAL   R2,GENTXT6              GENERATE 6 BYTES\nJWJ3     MVC   0(1,CDSA),0(0)          *** GENERATED CODE ***\n         B     JWH21\n*\nJWH1     AH    R7,ONEENTRY             INCREASE P\n         STH   R7,WORKPL               STORE P INTO WORKPL\n         BAL   R4,MAXCH                CHECK MAXIMUM\n         MVC   JWK1+2(2),WORKPL        PREPARE INSTRUCTION\n         OI    JWK1+2,X'A0'            INSERT CDSA\nJWK11    MVI   JWK1+1,X'00'            INSERT FALSE\n         TM    4(R9),X'01'             CONSTANT TRUE ?\n         BO    JWK12                   YES, BRANCH\n         MVI   JWK1+1,X'01'            INSERT TRUE\nJWK12    BAL   R2,GENTXT4              GENERATE 4 BYTES\nJWK1     MVI   0(CDSA),X'00'           *** GENERATED CODE ***\n         MVC   3(2,R9),WORKPL          INSERT OBJ DISPLACEMENT\n         NI    0(R9),X'5F'             ADJUST OPERAND\n         OI    1(R9),X'30'             SET OPERAND AS VARIABLE\n         MVC   2(1,R9),SPBNST+1        INSERT BLOCK NUMBER\n         B     JWH3\n*\nJWF2     BAL   R4,ROUTINE3             LOAD V-W-PLACE FOR ADDR\n         OI    0(R9),X'40'             ADJUST OPERAND\n         B     JWG31\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP78\n*\n***********************************************************************\n*\n*        IF CLAUSE\n*        CONTEXT              EXPRESSION\n*        SOURCE OPERATOR      'THEN'\n*        STACK OPERATOR       'IF','IFS'\n*        OPERANDS             BOOLEAN OPERANDS\n*\n         USING CP78,R12\nCP78     LA    R4,JZB1\n         BAL   R3,OPDTEST              OPDT AND ERROR 162\n         BAL   R4,ARRTEST1\n         TM    1(R9),X'03'             OPERAND BOOLEAN ?\n         BO    JYD1                    YES, BRANCH\n         BAL   R4,SERR2                ERROR PATTERN ENTRY\n         DC    H'182'                  ERROR NR 182\n*\nJZB1     CLI   0(R10),X'26'            OPERATOR IFS\n         MVC   0(1,R10),0(R8)          INSERT SOURCE INTO STACK\n         BNER  R5                      NO, BRANCH TO SUBSTART\n         MVI   0(R10),X'27'            INSERT THENS INTO STACK\n         SH    R11,KH614               SWITCH TO PROGRAM CONTEXT\n         BR    R5                      BRANCH TO SUBSTART\n*\nJYD1     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    JZB1                    YES, BRANCH\n         BAL   R4,OPDREC               OPERAND RECOGNIZER\n         TM    0(R9),X'20'             OPERAND A VALUE ?\n         BO    JYF2                    AN ADDR, BRANCH\n         TM    0(R9),X'80'             OPERAND IN OBJECT STACK ?\n         BO    JYH12                   NO, BRANCH\n         SH    R7,ONEENTRY             RELEASE OBJ STACK ENTRY\nJYH12    BAL   R4,ROUTINE1             LOAD V-W-PLACE FOR VALUE\nJYH11    MVC   JYH1+2(2),WPLACE        INTRODUCE DISPLACEMENT\n         MVZ   JYH1+2(1),VPLACE        INSERT V-PLACE INTO CODE\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nJYH1     TM    0(0),X'FF'              *** GENERATED CODE ***\n         BAL   R4,LATRES               RESERVE LABEL\n         MVC   3(2,R9),LN              INSERT LABEL INTO OPERAND\n         MVC   JYJ3+2(2),LN            INSERT LABEL INTO CODE\n         BAL   R2,GENTXT6              GENERATE 6 BYTES\nJYJ3     L     BRR,0(LAT,0)            *** GENERATED CODE ***\n         BZR   BRR                     *** GENERATED CODE ***\n         B     JZB1\n*\nJYF2     BAL   R4,ROUTINE3             LOAD W-V-PLACE FOR ADDR\n         B     JYH11\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP78\n*\n***********************************************************************\n*\n*        END OF CONDITIONAL EXPRESSION\n*        CONTEXT              EXPRESSION\n*        SOURCE OPERATOR      SEE EXPTESSION CONTEXT  MATRIX\n*        STACK OPERATOR       'ELSE'\n*        OPERANDS             TWO OPERANDS AND ONE LABEL\n*\n         USING CP79,R12\nCP79     LA    R4,KBB2                 LOAD RETURN ADDR\n         BAL   R3,OPDTEST              OPDT AND ERROR 162\n         BAL   R4,ARRTEST1\n         TM    1(R9),X'03'             LO BOOLEAN ?\n         BO    KBD1                    YES, BRANCH\n         BM    KCB11\n         TM    1(R9),X'08'             LO A LABEL ?\n         BZ    KFB2                    NO, BRANCH\n         TM    6(R9),X'08'             BLD A LABEL ?\n         BZ    KBD2                    NO, BRANCH\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    KBD31                   YES, BRANCH\n         BAL   R4,OPDREC\n         TM    1(R9),X'40'\n         BO    KBD2\n         TM    3(R9),X'80'\n         BO    KBH1                    YES, BRANCH\nKFE1     MVC   KFE11+2(2),3(R9)        PREPARE INSTRUCTION\n         OI    RII,X'01'\n         SR    R15,R15                 PREPARE INSTRUCTION\n         IC    R15,2(R9)\n         SLL   R15,3\n         STH   R15,WORKPL\n         MVC   KFE12+2(2),WORKPL\n         LA    R2,KFE11\n         BAL   R14,GENTXTS\n         DC    H'8'                    GENERATE 8 BYTES\n*\n         B     KBH1\n*\nKFE11    L     ADR,0(LAT,0)            *** GENERATED CODE ***\nKFE12    L     GDSA,0(PBT,0)           *** GENERATED CODE ***\n*\nKFB2     BAL   R4,SERR1\n         DC    H'178'                  ERROR 178\n*\n         B     KBD3\n*\nKBB2     LA    R9,10(,R9)              CLEAR TWO OPERANDS\nKBD4     MVC   0(5,R9),API             INTRODUCE API\nKBJ4     BCT   R10,COMP                CLOPT AND COMPARE\nKBD1     TM    6(R9),X'03'             BLO BOOLEAN ?\n         BO    KBE1                    YES, BRANCH\n         TM    0(R9),APIMASK           LO AN API ?\n         BO    KBD3                    YES, BRANCH\nKBD2     BAL   R4,SERR1\n         DC    H'165'                  ERROR 165\n*\nKBD3     LA    R9,10(,R9)              CLEAR TWO OPERANDS\n         B     KBD4\n*\nKBE1     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    KBD31                   YES, BRANCH\n         BAL   R4,OPDREC               OPERAND RECOGNIZER\n         TM    0(R9),X'20'\n         BO    KBF4\n         TM    0(R9),X'80'             LO IN STACK ?\n         BO    KBF3                    NO, BRANCH\n         CLC   3(2,R9),8(R9)           LO AND BLO IN=PLACE ?\n         BNE   KBG2                    NO, BRANCH\nKBH1     MVC   WORKPL(2),8(R9)         LOAD LAST P\n         NI    WORKPL,X'0F'\n         LH    R7,WORKPL\nKBH11    MVC   WORKPL(2),13(R9)        TRANSFER PRPOINT TO LAT\n         LH    R15,WORKPL              ENTRY INDICATED BY R9+13\n         L     R14,LATAB\n         ST    R6,0(R14,R15)\nKBD31    MVC   10(5,R9),5(R9)          C(R9+10)=C(R9+5)\n         LA    R9,10(,R9)              CLEAR TWO OPERANDS\n         MVI   GPBN+1,X'FF'\n         OI    0(R9),X'08'\n         BCT   R10,COMP                CLOPT AND COMPARE\nKBG2     MVC   KBG21+4(2),3(R9)        PREPARE INSTRUCTION\n         OI    KBG21+4,X'A0'\nKBG22    MVC   KBG21+2(2),8(R9)\n         OI    KBG21+2,X'A0'\n         BAL   R2,GENTXT6              GENERATE 6 BYTES\nKBG21    MVC   0(1,CDSA),0(CDSA)       *** GENERATED CODE ***\n         B     KBH1\n*\nKBF3     TM    2(R9),X'FF'             LO A CONSTANT ?\n         BZ    KBG3                    YES, BRANCH\n         BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1\nKBH3     MVC   KBG21+4(2),WPLACE       PREPARE INSTRUCTION\n         MVZ   KBG21+4(1),VPLACE\n         B     KBG22\n*\nKBF4     BAL   R4,ROUTINE3             CALL ROUTINE NUMBER 3\n         B     KBH3\n*\nKBG3     MVC   KBG31+1(1),4(R9)        PREPARE INSTRUCTION\n         NI    KBG31+1,X'01'\n         MVC   KBG31+2(2),8(R9)\n         OI    KBG31+2,X'A0'\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nKBG31    MVI   0(CDSA),X'00'           *** GENERATED CODE ***\n         B     KBH1\n*\nKCB11    TM    5(R9),X'40'\n         BZ    KCB1\n         MVZ   8(1,R9),10(R9)\n         SR    R14,R14\n         LA    R15,1\n         XI    5(R9),X'C0'\n         IC    R14,8(R9)\n         SRL   R14,4\n         TM    6(R9),X'02'\n         BZ    KCB12\n         STC   R14,CIR+1\n         SRL   R14,1\n         SLL   R15,0(R14)\n         STC   R15,KCE112+1            SET OR MASK\nKCE112   OI    RIR+1,X'00'\n         B     KCB1\n*\nKCB12    SLL   R15,0(R14)\n         STC   R15,KCB13+1\nKCB13    OI    RII+1,X'00'\n         STC   R14,CII+1\nKCB1     TM    6(R9),X'03'             BLO REAL OR INTEGER ?\n         BNM   KBD21                   NO, BRANCH\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    KBD31                   YES, BRANCH\nKCE1     BAL   R4,OPDREC               OPERAND RECOGNIZER\n         TM    1(R9),X'02'             LO REAL ?\n         BZ    KEB1                    YES, BRANCH\n         TM    6(R9),X'02'             BLO REAL ?\n         BZ    KDB1                    INTEGER, BRANCH\n         LA    R4,KCF4\n         BAL   R3,ROUTIN15             CALL ROUTINE NUMBER 15\nKCE11    MVC   WORKPL(2),ZEROHW\n         MVZ   WORKPL(1),8(R9)         CHECK IF LO AND BLO ARE\n         MVZ   WORKPL+1(1),3(R9)       LOADED IN THE SAME FPR\n         CLC   WORKPL(1),WORKPL+1\n         BNE   KCF2                    NO, BRANCH\n         SR    R14,R14                 INTRODUCE R9 ADD IN RUTR\n         IC    R14,WORKPL\n         SRL   R14,3\nKCG11    LA    R9,10(0,R9)\n         ST    R9,RUTR(R14)\n         SH    R9,KH10\n         B     KBH1\n*\nKCF2     SR    R14,R14                 LOAD FPR NUMBER OF LO\n         IC    R14,WORKPL+1\n         SRL   R14,5                   PREPARE MASK TO SET RIR\n         LA    R15,1\n         SLL   R15,0(R14)\n         STC   R15,KCF21+1\n         XI    KCF21+1,X'FF'\nKCF21    NI    RIR+1,X'00'\n         SLL   R14,1                         PREPARE INSTRUCTION\n         STC   R14,KCG2+1\n         OC    KCG2+1(1),WORKPL\n         BAL   R2,GENTXTP2             GENERATE 2 BYTES\nKCG2     LDR   0,0                     *** GENERATED CODE ***\nKCH21    SR    R14,R14\n         IC    R14,8(R9)               SET TO ONE RIR\n         SRL   R14,5\n         LA    R15,1\n         SLL   R15,0(R14)\n         STC   R15,KCH2+1\nKCH2     OI    RIR+1,X'00'\n         SLL   R14,1                   SET CIR\n         STC   R14,CIR+1\n         SLL   R14,1\n         B     KCG11\n*\nKCE4     BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1\nKCF4     MVZ   KCH4+1(1),8(R9)         PREPARE INSTRUCTION\n         MVN   KCH4+1(1),VPLACE\n         MVC   KCH4+2(2),WPLACE\n         BAL   R2,GENTXTP4             GENERATE 4 BYTES\nKCH4     LD    0,0(0,0)                *** GENERATED CODE ***\n         B     KCH21\n*\nKDB1     LA    R4,KDC41\n         BAL   R3,ROUTIN15\n         TM    3(R9),X'F0'             LO IN FPR0 ?\n         BNZ   KDE31                   NO, BRANCH\nKDG11    BAL   R2,GENTXT6              GENERATE 6 BYTES\n         BALR  BRR,0                   *** GENERATED CODE ***\n         B     10(,BRR)                *** GENERATED CODE ***\n         MVC   WORKPL(2),13(R9)\n         LH    R15,WORKPL\n         L     R14,LATAB\n         ST    R6,0(R14,R15)\n         LA    R9,5(,R9)\n         NI    RIR+1,X'FE'\n         BAL   R4,TRINRE\n         LA    R9,5(,R9)\n         ST    R9,RUTR\n         SH    R9,KH10\n         B     KBD31\n*\nKDE31    SR    R14,R14                 PREPARE INSTRUCTION\n         IC    R14,3(R9)\n         SRL   R14,4\n         STC   R14,KDF3+1\n         SRL   R14,1\n         LA    R15,1\n         SLL   R15,0(R14)\n         STC   R15,WORKPL\n         XI    WORKPL,X'FF'\n         NC    RIR+1(1),WORKPL\n         BAL   R2,GENTXTP2             GENERATE 2 BYTES\nKDF3     LDR   0,0                     *** GENERATED CODE ***\n         B     KDG11\n*\nKDC41    MVC   KDC4+2(2),WPLACE        PREPARE INSTRUCTION\n         MVN   KDC4+1(1),VPLACE\n         BAL   R2,GENTXTP4             GENERATE 4 BYTES\nKDC4     LD    0,0(0,0)                *** GENERATED CODE ***\n         AH    R7,ONEENTRY\n         B     KDG11\n*\nKEB1     TM    6(R9),X'01'             BLO INTEGER ?\n         BZ    KEC2                    NO, BRANCH\n         LA    R4,KEF31\n         BAL   R3,ROUTIN15             CALL ROUTINE NUMBER 15\n         MVC   WORKPL(2),ZEROHW\n         MVZ   WORKPL(1),8(R9)\n         MVZ   WORKPL+1(1),3(R9)\n         CLC   WORKPL(1),WORKPL+1      LO AND BLO ARE IN THE SAME GPR ?\n         BNE   KEF2                    NO, BRANCH\n         SR    R14,R14                 INTRODUCE R9 ADD IN RUTI\n         IC    R14,WORKPL\n         SRL   R14,2\nKEG1     LA    R9,10(0,R9)\n         ST    R9,RUTI\n         SH    R9,KH10\n         B     KBH1\n*\nKEF2     SR    R14,R14                 LOAD GPR NR OF LO\n         IC    R14,WORKPL+1\n         SRL   R14,4                   PREPARE MASK TO SET RII\n         LA    R15,1                   TO ZERO\n         SLL   R15,0(R14)\n         STC   R15,KEF21+1\n         XI    KEF21+1,X'FF'\nKEF21    NI    RII+1,X'00'\n         STC   R14,KEG21+1\n         OC    KEG21+1(1),WORKPL\n         BAL   R2,GENTXT2              GENERATE 2 BYTES\nKEG21    LR    0,0                     *** GENERATED CODE ***\nKEH21    SR    R14,R14                 SET TO ONE RII\n         IC    R14,8(R9)\n         SRL   R14,4\n         LA    R15,1\n         SLL   R15,0(R14)\n         STC   R15,KEH2+1\nKEH2     OI    RII+1,X'00'\n         STC   R14,CII+1               SET CII\n         SLL   R14,2\n         B     KEG1\n*\nKEF31    MVZ   KEG3+1(1),8(R9)         PREPARE INSTRUCTION\n         MVN   KEG3+1(1),VPLACE\n         MVC   KEG3+2(2),WPLACE\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nKEG3     L     0,0(0,0)                *** GENERATED CODE ***\n         B     KEH21\n*\nKEC2     NI    RIR+1,X'FE'\n         BAL   R4,TRINRE\n         B     KCE11\n*\nKBD21    TM    5(R9),APIMASK           BLO AN API ?\n         BO    KBD2+6                  YES, BRANCH\n         B     KBD2\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP80\n*\n***********************************************************************\n*\n*        BEGIN OF CONDITIONAL EXPRESSION\n*        CONTEXT              EXPRESSION\n*        SOURCE OPERATOR      'IF'\n*        STACK OPERATOR       (\n*        OPERANDS             NONE\n*\n         USING CP80,R12\nCP80     TM    COMPFLGS,OPERAND        OPERAND ON ?\n         BZ    KIB2                    NO, BRANCH\n         BAL   R4,SERR4                ERROR PATTERN ENTRY\n         DC    H'164'                  ERROR 164\n*\n         LA    R9,5(,R9)               CLOPD\nKIF2     BAL   R4,MOVEOPTK             RESERVE OPERATOR STACK FNT\n         MVC   0(1,R10),0(R8)          INSERT SOURCE INTO STACK\n         BR    R5                      BRANCH TO SUBSTART\n*\nKIB2     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    KIF2                    YES, BRANCH\n         BAL   R4,CLEARRG              CLEAR REGISTERS\n         B     KIF2                    BRANCH\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP86\n*\n***********************************************************************\n*\n*        ERRONEOUS CASE - WRONG CONDITIONAL EXPRESSION  OR STATEMENT\n*        CONTEXT              EXPRESSION\n*        SOURCE OPERATOR      'ELSE'\n*        STACK OPERATOR       'IF','IFS'\n*        OPERANDS             NONE OR ONE\n*\n         USING CP86,R12\nCP86     TM    COMPFLGS,OPERAND        OPERAND ON ?\n         BZ    KUB2                    NO, BRANCH\n         BAL   R4,SERR4                ERROR PATTERN ENTRY\n         DC    H'161'                  ERROR 161\n*\nKUE1     CLI   0(R10),X'1D'            OPERATOR STACK 'IF' ?\n         BNE   KUE2                    NO, BRANCH\n         MVC   0(1,R10),0(R8)          INSERT SOURCE INTO STACK\n         BAL   R4,STACKAPI\n         BR    R5                      BRANCH TO SUBSTART\n*\nKUB2     BAL   R4,SERR4                ERROR PATTERN ENTRY\n         DC    H'160'                  ERROR 160\n*\n         SH    R9,KH5                  RESERVE OPERAND STACK ENT\n         B     KUE1\n*\nKUE2     SH    R11,KH614               CSW(PC)\n         MVI   0(R10),X'27'            INSERT THENS INTO STACK\n         BR    R5                      BRANCH TO SUBSTART\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP87\n*\n***********************************************************************\n*\n*        FIRST ALTERNATIVE IN CONDITIONAL  EXPRESSION\n*        CONTEXT              EXPRESSION\n*        SOURCE OPERATOR      'ELSE'\n*        STACK OPERATOR       'THEN'\n*        OPERANDS             ONE OPERAND AND ONE LABEL\n*\n         USING CP87,R12\nCP87     LA    R4,KWJ3                 LOAD RETURN ADDR\n         BAL   R3,OPDTEST              OPDT AND ERROR 162\n         BAL   R4,ARRTEST1\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    KWJ3                    YES, BRANCH\n         BAL   R4,OPDREC               CALL OPERAND RECOGNITION\n         TM    1(R9),X'03'             LO BOOLEAN ?\n         BO    KWE1                    YES, BRANCH\n         BM    KXB1\n         TM    1(R9),X'08'             LO LABEL ?\n         BZ    KYB2\n         TM    1(R9),X'04'\n         BO    KYB2\n         TM    3(R9),X'80'\n         BO    KWG13\n         TM    RII,X'01'               ADR OCCUPIED ?\n         BZ    KYF1                    NO, BRANCH\n         BAL   R4,ROUTIN10             STADR\nKYF1     MVC   KYF11+2(2),3(R9)        PREPARE INSTRUCTION\n         SR    R15,R15                 PREPARE INSTRUCTION\n         IC    R15,2(,R9)\n         SLL   R15,3\n         STH   R15,WORKPL\n         MVC   KYF12+2(2),WORKPL\n         LA    R2,KYF11\n         BAL   R14,GENTXTS\n         DC    H'8'                    GENERATE 8 BYTES\n*\n         AH    R7,ONEENTRY\n         STH   R7,WORKPL\n         MVC   3(2,R9),WORKPL\n         OI    3(R9),X'80'\n         NI    0(R9),X'0F'\n         OI    0(R9),X'A0'\nKWG13    MVI   RII,X'00'\n         B     KWG12\n*\nKYF11    L     ADR,0(LAT,0)            *** GENERATED CODE ***\nKYF12    L     GDSA,0(PBT,0)           *** GENERATED CODE ***\n*\nKYB2     BAL   R4,SERR1\n         DC    H'178'                  ERROR 178\n*\n         MVC   0(5,R9),API\n         B     KWJ3\n*\nKWJ3     MVC   0(1,R10),0(R8)          C(R10)=C(R8)\n         MVI   GPBN+1,X'FF'\n         BR    R5                      RETURN TO SUBSTART\n*\nKWE1     TM    0(R9),X'20'             LO A VALUE ?\n         BO    KWE3                    NO, BRANCH\n         TM    0(R9),X'80'             LO IN OBJECT STACK ?\n         BO    KWF2                    NO, BRANCH\nKWG12    SH    R7,ONEENTRY\nKWG1     BAL   R4,LATRES\n         MVC   KWH1+2(2),LN            PREPARE INSTRUCTION\n         BAL   R2,GENTXT6              GENERATE 6 BYTES\nKWH1     L     BRR,0(LAT,0)            *** GENERATED CODE ***\n         BR    BRR                     *** GENERATED CODE ***\n         MVC   WORKPL(2),8(R9)         TRANSFER PRPOINT TO LAT ENTRY\n         LH    R15,WORKPL              INDICATED BY R9+8\n         L     R14,LATAB\n         ST    R6,0(R15,R14)\n         MVC   8(2,R9),LN              TRANSFER LNR TO R9+5 ENTRY\n         B     KWJ3\n*\nKWF2     TM    2(R9),X'FF'             LO A CONSTANT?\n         BZ    KWF21                   YES, BRANCH\n         BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1\nKWG2     AH    R7,ONEENTRY             INCREASE P\n         STH   R7,WORKPL\n         BAL   R4,MAXCH                CHECK MAXIMUM\n         MVC   KWH2+2(2),WORKPL        PREPARE INSTRUCTION\n         OI    KWH2+2,X'A0'\n         MVC   KWH2+4(2),WPLACE\n         MVZ   KWH2+4(1),VPLACE\n         BAL   R2,GENTXT6              GENERATE 6 BYTES\nKWH2     MVC   0(1,CDSA),0(0)          *** GENERATED CODE ***\nKWF23    MVC   3(2,R9),WORKPL          ADJUST R9 ENTRY\n         NI    0(R9),X'5F'\n         MVC   2(1,R9),SPBNST+1\n         B     KWG12\n*\nKWF21    AH    R7,ONEENTRY             INCREASE P\n         STH   R7,WORKPL\n         BAL   R4,MAXCH                CHECK MAX\n         NI    4(R9),X'01'\n         MVC   KWF22+2(2),WORKPL       PREPARE INSTRUCTION\n         OI    KWF22+2,X'A0'\n         MVC   KWF22+1(1),4(R9)\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nKWF22    MVI   0(CDSA),X'00'           *** GENERATED CODE ***\n         OI    1(R9),X'30'             ADJUST R9 ENTRY\n         B     KWF23\n*\nKWE3     BAL   R4,ROUTINE3             CALL ROUTINE NUMBER 3\n         XI    0(R9),X'60'\n         B     KWG2\n*\nKXB1     TM    1(R9),X'02'             LO REAL ?\n         BZ    KXB3                    INTEGER, BRANCH\n         TM    0(R9),X'20'             LO A VALUE ?\n         BO    KXC2                    NO, BRANCH\n         TM    0(R9),X'40'             LO IN A FPR ?\n         BZ    KXH22\n         TM    0(R9),X'80'             LO IN A FPR BEFORE ?\n         BO    KXC2                    NO, BRANCH\n         SH    R7,ONEENTRY             REDUCE O\nKXC2     BAL   R4,ROUTIN11             BRANCH TO ROUTINE 11\n         SH    R9,KH5                  REDUCE R9\n         TM    5(R9),X'20'             LO A VALUE ?\n         BZ    KXG2                    YES, BRANCH\n         BAL   R4,ROUTINE2             LOAD LO INTO A FPR\nKXH2     LA    R9,5(,R9)               INCREACE R9\nKXH22    BAL   R4,ROUTIN12             CALL ROUTINE NUMBER 12\nKWG11    MVC   5(1,R9),3(R9)\n         B     KWG1\n*\nKXG2     BAL   R4,ROUTINE4             LOAD FOR\n         B     KXH2\n*\nKXB3     TM    0(R9),X'20'             LO A VALUE ?\n         BO    KXC4                    NO, BRANCH\n         TM    0(R9),X'40'             LO IN A GPR ?\n         BZ    KXH21\n         TM    0(R9),X'80'             LO IN A GPR ?\n         BO    KXC4                    NO, BRANCH\n         SH    R7,ONEENTRY             REDUCE P\nKXC4     BAL   R4,ROUTINE7             BRANCH TO ROUTINE 11\n         SH    R9,KH5                  REDUCE R9\n         TM    5(R9),X'20'             LO A VALUE ?\n         BZ    KXG4                    YES, BRANCH\n         BAL   R4,ROUTINE6             LOAD LO INTO GPR\nKXH23    LA    R9,5(,R9)\nKXH21    BAL   R4,ROUTINE8\n         B     KWG11\n*\nKXG4     BAL   R4,ROUTINE5             LOAD LO IN GPR\n         B     KXH23\n*\n***********************************************************************\n*\n*        END OF IEX50005\n*\n***********************************************************************\n*\n./ ADD NAME=IEX50006 0201-12230-12230-1200-01131-01131-00000-LEVEL\n         TITLE 'IEX50 - COMPILATION PHASE - CP69'\n*\n***********************************************************************\n*\n*        COMPILER PROGRAM - CP69\n*\n***********************************************************************\n*\n*        ARITHMETIC AND RELATIONAL OPERATIONS\n*        CONTEXT              EXPRESSION\n*        SOURCE OPERATOR      SEE EXPRESSION CONTEXT  MATRIX\n*        STACK OPERATOR       SEE EXPRESSION CONTEXT  MATRIX\n*        OPERANDS             TWO OPERANDS\n*\n         USING CP69,R12\nCP69     TM    COMPFLGS,OPERAND        OPERAND ON ?\n         BZ    GNB2                    NO, BRANCH\n         BAL   R4,ARRTEST2\n         TM    1(R9),X'03'             LO ARITHMETIC ?\n         BNM   GND2                    NO, BRANCH\n         TM    6(R9),X'03'             BLO ARITHMETIC ?\n         BNM   GND22                   NO, BRANCH\n         TM    COMPFLGS,COMPMODE+SUBSCOPT  SYNTAX + SUBSCRIPT OPT ?\n         BNZ   GOE11                   NO, BRANCH\n         BAL   R4,OPDREC               OPERAND RECOGNIZER LO\n         LA    R9,5(,R9)               INCREASE R9\n         BAL   R4,OPDREC               OPERAND RECOGNIZER BLO\n         SH    R9,KH5                  DECREASE R9\n         TM    1(R9),X'02'             LO REAL ?\n         BZ    GOB3                    INTEGER, BRANCH\n         TM    6(R9),X'02'             BLO REAL ?\n         BZ    HQB1                    INTEGER, BRANCH\nHEB1     CLI   0(R10),XFPOWER          OPT POWER ?\n         BE    HOB1                    YES, BRANCH\nDHEB2    TM    5(R9),X'20'             BLO A VALUE ?\n         BO    HFB1                    NO, BRANCH\n         TM    5(R9),X'40'             BLO IN A FPR ?\n         BO    HEC3                    NO, BRANCH\nHEE31    MVZ   UPLACE(1),8(R9)         U=R(BLO)\n         LA    R9,5(,R9)\n         BAL   R4,CLFPR\n         SH    R9,KH5\n         CLI   0(R10),X'10'\n         BL    HEF2\n         SH    R7,ONEENTRY\nHEF2     LA    R4,HLD1\n         BAL   R3,ROUTIN15             CALL ROUTINE NUMBER 15\n         MVN   UPLACE(1),VPLACE\n         BAL   R4,CLFPR\n         BAL   R4,ROUTIN12             CALL ROUTINE NUMBER 12\n         B     HKD1\n*\nHEC3     TM    5(R9),X'80'             BLO IN A REGISTER ?\n         BO    HFB1\n         SH    R7,ONEENTRY             REDUCE P\nHFB1     TM    0(R9),X'20'             LO A VALUE ?\n         BO    HGD1                    AN ADDR, BRANCH\n         TM    0(R9),X'40'             LO IN A FPR ?\n         BO    HGB1                    NO, BRANCH\n         CLI   0(R10),XFSLASH          OPT / ?\n         BNE   HFD2                    NO, BRANCH\n         TM    RIR+1,X'0F'\n         BO    HFB11\n         BAL   R4,ROUTIN11             CALL ROUTINE NUMBER 11\n         SH    R7,ONEENTRY\n         BAL   R4,CLFPR\n         SLL   R3,1\n         SLL   R14,4\n         OR    R3,R14\n         SRL   R14,4\n         STC   R3,HFB12+1\n         STC   R3,UPLACE\n         TM    5(R9),X'20'\n         BO    HFB13\n         BAL   R4,ROUTINE4             CALL ROUTINE NUMBER 4\nHFB14    BAL   R2,GENTXTP2             GENERATE 2 BYTES\nHFB12    DDR   0,0                     *** GENERATED CODE ***\n         B     GOE2\n*\nCLFPR    SR    R3,R3\n         IC    R3,3(R9)\n         SRL   R3,5\n         LA    R15,1\n         SLL   R15,0(R3)\n         STC   R15,HEE3+1\n         XI    HEE3+1,X'FF'\nHEE3     NI    RIR+1,X'00'\n         BR    R4\n*\nHFB13    BAL   R4,ROUTINE2             CALL ROUTINE NUMBER 2\n         B     HFB14\n*\nHFB11    SR    R14,R14                 STORE LO\n         IC    R14,3(R9)\n         STC   R14,UPLACE              U=R(BLO)\n         SRL   R14,4\n         BAL   R4,ROUTIN13             CALL ROUTINE NUMBER 13\n         TM    5(R9),X'20'             BLO A VALUE ?\n         BO    HFF2                    AN ADDR, BRANCH\n         BAL   R4,ROUTINE4             CALL ROUTINE NUMBER 4\nHFG2     BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1\n         B     HLD1\n*\nHFF2     BAL   R4,ROUTINE2             CALL ROUTINE NUMBER 2\n         B     HFG2\n*\nHFD2     MVZ   UPLACE(1),3(R9)         V=R(LO)\n         CLI   0(R10),XFASSIGN         OPT .= ?\n         BNE   HFD3                    NO, BRANCH\n         BAL   R4,ROUTIN12             CALL ROUTINE NUMBER 12\n         LA    R9,5(,R9)               INCREASE R9\n         BAL   R4,ROUTIN15             CALL ROUTINE NUMBER 15\nHFC51    SH    R9,KH5                  DECREASE R9\n         B     HLD1\n*\nHFD3     MVC   KONSUM(5),0(R9)\n         MVC   0(5,R9),5(R9)\n         MVC   5(5,R9),KONSUM\n         TM    0(R10),X'10'            OPT ARITHMETIC ?\n         BO    HFE4                    RELATIONAL, BRANCH\nHFH3     MVI   SWREL,X'FF'             SWREL=FF\nHGG11    TM    0(R9),X'20'             LO A VALUE ?\n         LA    R4,HLD1\n         BO    HFJ3                    AN ADDR, BRANCH\n         B     ROUTINE1\n*\nHFJ3     B     ROUTINE3\n*\nHFE4     BAL   R4,ROUTIN12             CALL ROUTINE NUMBER 12\n         B     HFH3\n*\nHGB1     TM    0(R9),X'80'             LO IN A REGISTER ?\n         BO    HGD1                    NO, BRANCH\n         SH    R7,ONEENTRY\nHGD1     CLI   0(R10),XFASSIGN         OPT .= ?\n         BE    HGD2                    YES, BRANCH\n         BAL   R4,ROUTIN11             CALL ROUTINE NUMBER 11\n         TM    5(R9),X'20'             IS BLO A VALUE\n         BZ    HGG1                    YES, BRANCH\n         BAL   R4,ROUTINE2             CALL ROUTINE NUMBER 2\nHGH1     SLL   R14,4                   1=R(BLO)\n         STC   R14,UPLACE\n         CLI   0(R10),X'10'            OPT ARITHMETIC ?\n         BL    HGG11                   YES, BRANCH\n         BAL   R4,ROUTIN12             CALL ROUTINE NUMBER 12\n         B     HGG11\n*\nHGG1     BAL   R4,ROUTINE4             ROUTINE NR.4\n         B     HGH1\n*\nHGD2     TM    5(R9),X'20'             BLO A VALUE ?\n         BO    HJB1                    AN ADDR, BRANCH\n         TM    0(R9),X'20'             LO A VALUE ?\n         BO    HGB2                    AN ADDR, BRANCH\n         BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1\n         MVC   HJH11+2(2),8(R9)        PREPARE INSTRUCTION\n         CLC   SPBNST+1(1),7(R9)       DSA OF BLO CDSA  ?\n         BNE   HGB4                    NO, BRANCH\n         OI    HJH11+2,X'A0'           PREPARE INSTRUCTION\n         B     HJH1\n*\nHGB4     CLI   GPBN+1,X'FF'            GDSA DESTROYED ?\n         BE    HGB41                   YES, BRANCH\n         CLC   GPBN(1),7(R9)           DSA OF BLO IN GPBN ?\n         BNE   HGB5                    NO, BRANCH\nHGC4     OI    HJH11+2,X'90'           PREPARE INSTRUCTION\n         B     HJH1\n*\nHGB41    MVI   GPBN+1,0                SFT TO ZERO\nHGB5     SR    R1,R1                   PREPARE INSTRUCTION\n         IC    R1,7(R9)\n         SLL   R1,3\n         STH   R1,WORKPL\n         CLI   VPLACE,X'99'            DSA OF LO IN GDSA ?\n         BE    HGE5                    YES, BRANCH\n         MVC   HGA5+2(2),WORKPL\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nHGA5     L     GDSA,0(PBT,0)           *** GENERATED CODE ***\n         MVC   GPBN(1),7(R9)           STORE NEW GDSA\n         B     HGC4\n*\nHGE5     MVC   HGF5+2(2),WORKPL\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nHGF5     L     R14,0(PBT,0)            *** GENERATED CODE ***\n         OI    HJH11+2,X'E0'           PREPARE INSTRUCTION\n         B     HJH1\n*\nHGB2     BAL   R4,ROUTINE3             CALL ROUTINE NUMBER 3\n         MVC   HJH11+4(2),WPLACE\n         MVZ   HJH11+4(1),VPLACE\n         LA    R9,5(0,R9)              INCREASE R9\n         BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1\n         SH    R9,KH5                  DECREASE R9\n         MVC   HJH11+2(2),WPLACE\n         MVZ   HJH11+2(1),VPLACE\n         B     HJH111\n*\nHJB1     LA    R9,5(0,R9)              INCREASE R9\n         BAL   R4,ROUTINE3             CALL ROUTINE NUMBER 3\n         MVC   HJH11+2(2),WPLACE\n         MVZ   HJH11+2(1),VPLACE\n         SH    R9,KH5                  DECREASE R9\n         TM    0(R9),X'20'             LO A VALUE ?\n         BO    HJC1                    AN ADDR, BRANCH\n         BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1\nHJH1     MVC   HJH11+4(2),WPLACE\n         MVZ   HJH11+4(1),VPLACE\nHJH111   MVI   HJH11+1,0\n         TM    1(R9),X'03'\n         BO    HJH13\n         MVI   HJH11+1,X'03'\n         TM    1(R9),X'01'\n         BO    HJH13\n         LH    R14,ONEENTRY\n         BCTR  R14,0\n         STC   R14,HJH11+1\nHJH13    BAL   R2,GENTXT6              GENERATE 6 BYTES\nHJH11    MVC   0(8,0),0(0)             *** GENERATED CODE ***\nHLE21    L     R1,ABIG2                R1 -> ABIG2 ENTRY IN CP20\n         MVI   SWREL,X'00'\n         L     R12,SCPTAB+4*20         R12 -> CP20 FOR ADDRESSABILITY\n         BR    R1                      BRANCH TO CP20\n*\nABIG2    DC    A(BIG2)\n*\nHJC1     MVC   HJC11+2(2),3(R9)\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nHJC11    L     R14,0(CDSA,0)           *** GENERATED CODE ***\n         MVI   VPLACE,X'E0'\n         B     HJH1\n*\nHKD1     MVC   HKH4+1(1),UPLACE\n         MVI   HKH4,X'2A'\n         CLI   0(R10),XFMINUS          OPT MINUS ?\n         BL    HKH41                   OPT PLUS, BRANCH\n         BE    HKF2                    OPT MINUS, BRANCH\n         MVI   HKH4,X'2C'\n         CLI   0(R10),XFSLASH          OPT REAL DIVISION ?\n         BL    HKH41                   OPT MULTIPLICATION, BRANCH\n         BE    HKD2                    OPT DIVISION, BRANCH\n         TM    0(R10),X'10'            OPT RELATIONAL ?\n         BO    HKA2                    YES, BRANCH\nHKG22    CLI   0(R10),X'04'\n         BE    GOE112\nHKG2     BAL   R4,SERR2\n         DC    H'194'                  ERROR 194\n*\nGOE1     LA    R9,5(,R9)\nGOEZ     STH   R7,WORKPL\n         MVN   3(1,R9),WORKPL\n         MVC   4(1,R9),WORKPL+1\n         OI    0(R9),X'08'\nGOF1     BCT   R10,COMP                CLOP AND COMPARE\nHKA2     MVI   HKH4,X'29'              PREPARE INSTRUCTIONS\nHKH41    BAL   R2,GENTXTP2             GENERATE 2 BYTES\nHKH4     ADR   0,0                     *** GENERATED CODE ***\n         CLI   0(R10),XFEQUAL\n         BL    GOE2\nIMB1     AH    R7,ONEENTRY\n         STH   R7,WORKPL               CHECK MAX\n         BAL   R4,MAXCH\n         MVC   8(2,R9),WORKPL\n         MVC   IMD2+2(2),WORKPL        PREPARE INSTRUCTION\n         OI    IMD2+2,X'A0'\n         NI    IMH4+1,X'0F'\n         TM    SWREL,X'FF'\n         BO    INE2\n         CLI   0(R10),XFLT             OPT < ?\n         BL    IME4                    =, BRANCH\n         BE    IMG4                    YES, BRANCH\n         CLI   0(R10),X'13'\n         BE    IMH41                   BRANCH ON NOT EQUAL\n         BL    IMC4                    BRANCH ON GREATER\n         CLI   0(R10),X'15'\n         BE    IMD4                    BRANCH ON NOT LOW\n         BH    HKG2                    BRANCH ON ERROR\nIMF4     OI    IMH4+1,X'D0'            PREPARE INSTRUCTION\nIMH51    MVC   IMH5+2(2),IMD2+2\n         LA    R2,IMD2\n         BAL   R14,GENTXTS\n         DC    H'14'                   GENERATE 14 BYTES\n         OI    6(R9),X'03'             ADJUST R9 ENTRY OF BLO\n         OI    5(R9),X'40'\n         NI    5(R9),X'5F'\n         B     GOE1                    RETURN\n*\nIMD2     MVI   0(CDSA),X'01'           *** GENERATED CODE ***\n         BALR  BRR,0                   *** GENERATED CODE ***\nIMH4     NOP   8(0,BRR)                *** GENERATED CODE ***\nIMH5     MVI   0(CDSA),X'00'           *** GENERATED CODE ***\nHKD2     MVI   HKH4,X'2D'\n         B     HKH41\n*\nHKF2     MVI   HKH4,X'2B'\n         B     HKH41\n*\nIMC4     OI    IMH4+1,X'20'            SET BRANCH CONDITION IN GEN INST\n         B     IMH51\n*\nIMD4     OI    IMH4+1,X'B0'            SET BRANCH CONDITION IN GEN INST\n         B     IMH51\n*\nIME4     OI    IMH4+1,X'80'            SET BRANCH CONDITION IN GEN INST\n         B     IMH51\n*\nIMG4     OI    IMH4+1,X'40'            SET BRANCH CONDITION IN GEN INST\n         B     IMH51\n*\nIMH41    OI    IMH4+1,X'70'            SET BRANCH CONDITION IN GEN INST\n         B     IMH51\n*\nINE2     MVI   SWREL,0                 ZERO SWREL\n         CLI   0(R10),XFLT             WHICH OPT\n         BL    IME4                    =, BRANCH\n         BE    IMC4                    <, BRANCH\n         CLI   0(R10),X'13'\n         BE    IMH41                   BRANCH ON NOT EQUAL\n         BL    IMG4                    BRANCH ON GREATER\n         CLI   0(R10),X'15'\n         BE    IMF4                    BRANCH ON NOT LOW\n         BH    HKG2                    BRANCH ON ERROR\n         B     IMD4                    PREPARE INSTRUCTION\n*\nGNB2     BAL   R4,SERR4\n         DC    H'162'                  ERROR 162\n*\n         OI    COMPFLGS,OPERAND        SET OPERAND ON\nGNE3     MVC   0(5,R9),API             INSTRUCTION API\n         BCT   R10,COMP                CLOPT AND COMPARE\nGND2     TM    0(R9),APIMASK           LO AN API ?\n         BZ    GND21                   LO IS NOT AN API, BRANCH\nGND3     LA    R9,5(,R9)               INCREASE R9\n         B     GNE3\n*\nGND21    BAL   R4,SERR2\n         DC    H'163'                  ERROR 163\n*\n         B     GND3\n*\nGND22    TM    5(R9),APIMASK           BLO AN API ?\n         BO    GND3                    YES, BRANCH\n         BCTR  R10,0                   REDUCE R10\n         BAL   R4,SERR2\n         DC    H'163'                  ERROR  163\n         LA    R10,1(,R10)             INCREASE R10\n         B     GND3\n*\nGOE11    CLI   0(R10),X'04'            OPT IN STACK INT# DIV ?\n         BNE   GOE111                  NO, BRANCH\n         TM    1(R9),X'02'             LO REAL ?\n         BO    GOE112\n         TM    6(R9),X'02'             BLO REAL ?\n         BO    GOE112                  YES, BRANCH\nGOE111   TM    0(R10),X'10'            OPT RELATIONAL ?\n         BZ    GOE1                    NO, BRANCH\n         OI    6(R9),X'03'             ADJUST R9 ENTRY OF BLO\n         B     GOE1\n*\nGOE2     SR    R14,R14\n         NI    UPLACE,X'F0'\n         IC    R14,UPLACE\n         SRL   R14,3\n         LA    R9,5(,R9)\n         ST    R9,RUTR(R14)\n         SRL   R14,1\n         STH   R14,CIR\n         SRL   R14,1\n         LA    R15,1\n         SLL   R15,0(R14)\n         STC   R15,HEF21+1\nHEF21    OI    RIR+1,X'00'\n         B     GOEZ\n*\nHLD1     MVC   HLJ4+1(1),UPLACE        PREPARE INSTRUCTION\n         MVN   HLJ4+1(1),VPLACE\n         MVC   HLJ4+2(2),WPLACE\n         MVI   HLJ4,X'6A'\n         CLI   0(R10),XFMINUS          OPT MINUS ?\n         BL    HLJ41                   +, BRANCH\n         BE    HLF2                    MINUS, BRANCH\n         MVI   HLJ4,X'6C'\n         CLI   0(R10),X'03'            DIVISION ?\n         BL    HLJ41\n         BE    HLB2                    YES, BRANCH\n         TM    0(R10),X'10'            A RELATIONAL OPT ?\n         BZ    HKG22\n         MVI   HLJ4,X'60'\n         CLI   0(R10),XFASSIGN         OPT .= ?\n         BE    HLJ41                   YES, BRANCH\nHLA2     MVI   HLJ4,X'69'              PREPARE INSTRUCTION\nHLJ41    BAL   R2,GENTXTP4             GENERATE 4 BYTES\nHLJ4     AD    0,0(0,0)                *** GENERATED CODE ***\n         CLI   0(R10),XFMINUS          OPT MINUS ?\n         BE    HLF3                    YES, BRANCH\n         CLI   0(R10),XFASSIGN         OPT ASSIGNMENT?\n         BE    HLE21                   YES, BRANCH\n         TM    0(R10),X'10'            OPT RELATIONAL ?\n         BO    IMB1                    NO, BRANCH\n         MVI   SWREL,0\n         B     GOE2\n*\nGOE112   BAL   R4,SERR3\n         DC    H'185'\n*\n         B     GOE1\n*\nHLF3     TM    SWREL,X'FF'\n         BZ    GOE2\n         MVI   SWREL,X'00'              SET TO ZERO SWREL\n         MVC   HLH3+1(1),UPLACE         PREPARE INSTRUCTION\n         SR    R14,R14\n         IC    R14,UPLACE\n         SRL   R14,4\n         STC   R14,WORKPL\n         MVN   HLH3+1(1),WORKPL\n         BAL   R2,GENTXTP2              GENERATE 2 BYTES\nHLH3     LCDR  0,0                      *** GENERATED CODE ***\n         B     GOE2\n*\nHLB2     MVI   HLJ4,X'6D'\n         B     HLJ41\n*\nHLF2     MVI   HLJ4,X'6B'\n         B     HLJ41\n*\nGOB3     TM    6(R9),X'02'             BLO REAL ?\n         BO    HTB1                    YES, BRANCH\n         CLI   0(R10),XFASTER          OPT * ?\n         BL    DHZB1\n         BE    IPB1                    YES, BRANCH\n         TM    0(R10),X'10'            OPT RELATIONAL ?\n         BO    DHZB1\n         CLI   0(R10),X'04'            OPT INTEGER DIV ?\n         BE    ISB1                    YES, BRANCH\n         BH    IUB1                    OPT IS POWER, BRANCH\nHWB1     BAL   R4,TRINRE               CALL CONVERT ROUTINE\n         MVC   HYG2+2(2),3(R9)\n         LA    R9,5(,R9)               INCREASE R9\n         BAL   R4,TRINRE\n         BAL   R2,GENTXTP4             GENERATE 4 BYTES\nHYG2     DD    0,0(CDSA,0)             *** GENERATED CODE ***\n         SH    R7,ONEENTRY             REDUCE P\n         B     GOEZ\n*\nDHZB1    TM    5(R9),X'20'             BLO A VALUE ?\n         BO    IAB1                    AN ADDR, BRANCH\n         TM    5(R9),X'40'             BLO IN A REGISTER ?\n         BO    HZC2                    IN STORAGE, BRANCH\n         MVZ   UPLACE(1),8(R9)         V=R(BLO)\n         TM    0(R10),X'10'            OPT RELATIONAL ?\n         BZ    HZF1                    ARITHMETIC, BRANCH\n         BAL   R4,ROUTINE8             CALL ROUTINE NUMBER 8\nHZF1     LA    R4,IFC3\n         BAL   R3,ROUTIN15             CALL ROUTINE NUMBER 15\n         MVN   UPLACE(1),VPLACE        PREPARE INSTRUCTION\n         BAL   R4,ROUTINE8             RELILO\n         B     IEC3\n*\nHZC2     TM    5(R9),X'80'             BLO IN A REGISTER ?\n         BO    IAB1                    NO, BRANCH\n         SH    R7,ONEENTRY             REDUCE P\nIAB1     TM    0(R9),X'20'             LO A VALUE ?\n         BO    IAD3                    AN ADDR, BRANCH\n         TM    0(R9),X'40'             LO IN A REGISTER ?\n         BO    IAC2                    IN STORAGE, BRANCH\n         MVZ   UPLACE(1),3(R9)         U=R(LO)\n         CLI   0(R10),XFASSIGN         OPT.= ?\n         BNE   IAE1                    NO, BRANCH\n         BAL   R4,ROUTINE8             CALL ROUTINE NUMBER 8\n         LA    R9,5(,R9)               INCREASE R9\n         BAL   R4,ROUTIN15             CALL ROUTINE NUMBER 15\nIAE21    SH    R9,KH5                  REDUCE R9\n         B     IFC3\n*\nIAE1     MVC   KONSUM(5),0(R9)         INTERCHANGE PLACES\n         MVC   0(5,R9),5(R9)\n         MVC   5(5,R9),KONSUM\n         TM    0(R10),X'10'            OPT ARITHMETIC ?\n         BO    IAG2                    RELATIONAL, BRANCH\n         SR    R14,R14                 INTRODUCE R9 ADD IN RUM\n         LA    R9,5(,R9)\n         IC    R14,3(R9)\n         SRL   R14,4\n         SLL   R14,2\n         ST    R9,RUTI(R14)\n         SH    R9,KH5                  DECREASE R9\nIAJ1     MVI   SWREL,X'FF'             SWREL= ONE\nIAF3     TM    0(R9),X'20'             LO A VALUE ?\n         LA    R4,IFC3\n         BO    IAK1                    AN ADDR, BRANCH\n         B     ROUTINE1                BRANCH TO ROUTINE NUMBER 1\n*\nIAK1     B     ROUTINE3                BRANCH TO ROUTINE NUMBER 3\n*\nIAG2     BAL   R4,ROUTINE8             CALL ROUTINE NUMBER 8\n         B     IAJ1\n*\nIAC2     TM    0(R9),X'80'             LO IN A REGISTER ?\n         BO    IAD3                    NO, BRANCH\n         SH    R7,ONEENTRY             REDUCE P\nIAD3     CLI   0(R10),XFASSIGN         OPT.= ?\n         BE    HGD2                    YES, BRANCH\n         BAL   R4,ROUTINE7             CALL ROUTINE NUMBER 7\n         TM    5(R9),X'20'             BLO A VALUE ?\n         BO    IAG3                    AN ADDR, BRANCH\n         BAL   R4,ROUTINE5             CALL ROUTINE NUMBER 5\nIAH3     SLL   R14,4                   U=R(BLO)\n         STC   R14,UPLACE\n         TM    0(R10),XFEQUAL\n         BZ    IAF3\n         BAL   R4,ROUTINE8             CALL ROUTINE NUMBER 8\n         B     IAF3\n*\nIAG3     BAL   R4,ROUTINE6             CALL ROUTINE NUMBER 6\n         B     IAH3\n*\nIEC3     MVC   IED3+1(1),UPLACE        PREPARE INSTRUCTION\n         MVI   IED3,X'1A'\n         CLI   0(R10),XFMINUS          OPT MINUS ?\n         BL    IED31                   OPT PLUS, BRANCH\n         BH    IED4                    OPT RELATIONAL, BRANCH\n         MVI   IED3,X'1B'              PREPARE INSTRUCTION\nIED31    BAL   R2,GENTXT2              GENERATE 2 BYTES\nIED3     SR    0,0                     *** GENERATED CODE ***\n         CLI   0(R10),X'10'\n         BL    GOE1\n         B     IMB1\n*\nIED4     MVI   IED3,X'19'\n         B     IED31\n*\nIFC3     MVC   IFD3+1(1),UPLACE        PREPARE INSTRUCTION\n         MVN   IFD3+1(1),VPLACE\n         MVC   IFD3+2(2),WPLACE\n         MVI   IFD3,X'5A'\n         CLI   0(R10),XFMINUS          WHICH OPT\n         BL    IFD31                   +, BRANCH\n         BH    IFD4                    RELATIONAL, BRANCH\n         MVI   IFD3,X'5B'              PREPARE  INSTRUCTION\nIFD31    BAL   R2,GENTXT4              GENERATE 4 BYTES\nIFD3     S     0,0(0,0)                *** GENERATED CODE ***\n         CLI   0(R10),XFMINUS          WHICH OPERATOR\n         BL    IFG3+2                  +, BRANCH\n         BH    IFD41                   RELATIONAL, BRANCH\n         CLI   SWREL,X'FF'             SWREL = ONE\n         BNE   IFG3+2\n         IC    R14,UPLACE              PREPARE INSTRUCTION\n         SRL   R14,4\n         STC   R14,IFG3+1\n         MVZ   IFG3+1(1),UPLACE\n         BAL   R2,GENTXT2              GENERATE 2 BYTES\nIFG3     LCR   0,0                     *** GENERATED CODE ***\n         MVI   SWREL,0\n         B     GOE1\n*\nIFD4     MVI   IFD3,X'59'\n         CLI   0(R10),XFASSIGN         OPT.= ?\n         BNE   IFD31                   NO, BRANCH\n         MVI   IFD3,X'50'              PREPARE INSTRUCTION\n         B     IFD31\n*\nIFD41    CLI   0(R10),XFASSIGN         OPT.= ?\n         BE    HLE21                   YES, BRANCH\n         B     IMB1                    BRANCH TO RELATIONAL ROUTINE\n*\n*        INTEGER-INTEGER MULTIPLICATION\n*\nIPB1     TM    5(R9),X'20'             BLO A VALUE ?\n         BO    IRD1                    AN ADDR, BRANCH\n         TM    5(R9),X'40'             BLO A IN A REGISTER ?\n         BO    IRB1                    IN STORAGE, BRANCH\n         SR    R1,R1                   BLO IN AN ODD REG ?\n         IC    R1,8(,R9)\n         STC   R1,UPLACE\n         SRL   R1,4\n         SH    R7,ONEENTRY             DECREASE P\n         TM    UPLACE,X'10'\n         BZ    IPD2                    BLO IN EVEN GPR, BRANCH\n         LA    R2,1                    CLEAR RII OF BLO\n         SLL   R2,0(R1)\n         STC   R2,IPH11+1\n         XI    IPH11+1,X'FF'\nIPH11    NI    RII+1,0\n         BCTR  R1,0                    V=R(BLO-1)\n         NI    UPLACE,X'E0'\n         SRL   R2,1                    NEXT EVEN GPR FREE ?\n         STC   R2,IPH1+1\nIPH1     TM    RII+1,0\n         BO    IPH31\nIPJ1     LA    R4,IQE2\n         BAL   R3,ROUTIN15             CALL ROUTINE NUMBER 15\nIQC1     BAL   R4,ROUTINE8             CALL ROUTINE NUMBER 8\nIQD11    MVZ   IQD1+1(1),UPLACE        PREPARE INSTRUCTION\n         SR    R2,R2\n         IC    R2,3(R9)\n         SRL   R2,4\nIQC12    LA    R1,1\n         SLL   R1,0(R2)\n         STC   R1,IQC13+1\n         XI    IQC13+1,X'FF'\nIQC13    NI    RII+1,0\n         MVN   IQD1+1(1),VPLACE\n         BAL   R2,GENTXT2              GENERATE 2 BYTES\nIQD1     MR    0,0                     *** GENERATED CODE  ***\nIQE11    MVZ   IQE1+1(1),UPLACE        PREPARE INSTRUCTION\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nIQE1     SLDA  0,32                    *** GENERATED CODE  ***\nIQB1     SR    R1,R1                   SET NEW CII\n         IC    R1,UPLACE\n         SRL   R1,4\n         STC   R1,CII+1\n         SLL   R1,4\n         STC   R1,8(R9)\n         SRL   R1,4\n         LA    R2,1                    SET TO ONE RII OF BLO\n         SLL   R2,0(R1)\n         STC   R2,IQC14+1\nIQC14    OI    RII+1,0\n         AH    R7,ONEENTRY\n         SLL   R1,2\n         LA    R9,5(,R9)\n         ST    R9,RUTI(R1)\n         B     GOEZ\n*\nIQE2     MVZ   IQE21+1(1),UPLACE       PREPARE INSTRUCTION\n         MVN   IQE21+1(1),VPLACE\n         MVC   IQE21+2(2),WPLACE\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nIQE21    M     0,0(0,0)                *** GENERATED CODE  ***\n         B     IQE11\n*\nIPH31    TM    0(R9),X'20'             LO AN ADDR ?\n         BO    IPH4                    YES, BRANCH\n         TM    0(R9),X'40'\n         BO    IPH4\nIPH3     MVZ   WORKPL(1),3(R9)         LO IN THAT GPR ?\n         NI    WORKPL,X'F0'\n         NI    UPLACE,X'F0'\n         CLC   UPLACE(1),WORKPL\n         BNE   IPH4                    BRANCH IF NOT IN THAT GPR\n         SH    R7,ONEENTRY             INCREASE P\n         B     IQD11\n*\nIPH4     LA    R1,2(,R1)               NEXT EVEN FREE\n         CH    R1,KH8                  NEXT EVEN GPR8 ?\n         BE    IPH41                   YES, BRANCH\n         SLL   R2,2\nIPH43    STC   R2,IPH42+1\nIPH42    TM    RII+1,0\n         BZ    IPD3                    BRANCH IN FREE\n         TM    0(R9),X'20'             LO A VALUE ?\n         BO    IPH44\n         TM    0(R9),X'40'\n         BO    IPH44\n         SR    R3,R3                   LO IN THAT GPR ?\n         IC    R3,3(0,R9)\n         SRL   R3,4\n         CR    R3,R1\n         BE    IPD3                    YES, BRANCH\nIPH44    LR    R14,R1\n         ST    R2,RETADR+56            SAVE CONTENTS OF R2 ACROSS RTN9\n         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9\n         L     R2,RETADR+56\n         LR    R1,R14\nIPD3     LA    R1,1(,R1)               NEXT ODD FREE ?\n         SLL   R2,1\nIPD33    STC   R2,IPD31+1\nIPD31    TM    RII+1,0\n         BZ    IPE3\n         LR    R14,R1\n         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9\n         LR    R1,R14\n         XI    IPD31+1,X'FF'           CLEAR RII OF LAST CLEARED\n         NC    RII+1(1),IPD31+1\nIPE3     SLL   R1,4                    PREPARE INSTRUCTION\n         STC   R1,UPLACE\n         MVC   IPE31+1(1),UPLACE\n         NI    UPLACE,X'E0'\n         IC    R2,8(,R9)\n         SRL   R2,4\n         STC   R2,WORKPL\n         MVN   IPE31+1(1),WORKPL\n         BAL   R2,GENTXT2              GENERATE 2 BYTES\nIPE31    LR    0,0                     *** GENERATED CODE ***\n         B     IPJ1\n*\nIPH41    SR    R1,R1\n         LA    R2,1\n         B     IPH43\n*\nIPD2     SR    R2,R2                   LO IN NEXT GPR ?\n         LA    R1,1(0,R1)\n         TM    0(R9),X'20'\n         BO    IPD21\n         TM    0(R9),X'40'\n         BO    IPD21\n         IC    R2,3(,R9)\n         SRL   R2,4\n         CR    R1,R2\n         BE    IQC11                   YES,  BRANCH\nIPD21    LA    R2,1\n         SLL   R2,0(R1)\n         B     IPD33\n*\nIRB1     TM    5(R9),X'80'             BLO IN A GPR ?\n         BO    IRD1\n         SH    R7,ONEENTRY\nIRD1     TM    CII+1,X'01'             LAST OCCUPIED REG ODD ?\n         BO    IRD11                   YES, BRANCH\n         TM    CII+1,X'06'             LAST OCCUPIED R6 ?\n         BO    IRD12                   YES, BRANCH\n         SR    R1,R1\n         IC    R1,CII+1                NEXT EVEN REG FREE ?\n         LA    R1,2(,R1)\nIRD14    LA    R2,1\n         STC   R1,CII+1\n         SLL   R2,0(R1)\n         LR    R14,R1\n         STC   R2,IRD13+1\nIRD13    TM    RII+1,0\n         BZ    IRF1                    FREE, BRANCH\n         ST    R2,RETADR+52\n         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9\n         L     R2,RETADR+52\n         LR    R1,R14\nIRF1     SLL   R2,1                    NEXT ODD FREE ?\n         OC    RII+1(0),IRD13+1\n         SLL   R14,4\n         STC   R14,UPLACE\n         STC   R2,IRF11+1\n         LA    R1,1(,R1)\n         LR    R14,R1\nIRF11    TM    RII+1,0\n         BZ    IRG1                    BRANCH IF FREE\n         XI    IRF11+1,X'FF'\n         NC    RII+1(1),IRF11+1\n         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9\nIRG1     TM    5(R9),X'20'             BLO A VALUE ?\n         BO    IRA1                    AN ADDR, BRANCH\n         BAL   R4,ROUTINE5             CALL ROUTINE NUMBER 5\n         B     IPJ1\n*\nIRA1     BAL   R4,ROUTINE6             CALL ROUTINE NUMBER 6\n         B     IPJ1\n*\nIRD12    SR    R1,R1\n         B     IRD14\n*\nIRD11    TM    CII+1,X'07'             LAST OCCUPIED R7 ?\n         BO    IRD12\n         SR    R1,R1\n         IC    R1,CII+1\n         LA    R1,1(,R1)               INCR\n         B     IRD14\n*\nIQC11    BCTR  R2,0\n         STC   R2,VPLACE\n         SH    R7,ONEENTRY\n         B     IQD11\n*\n*        INTEGER-INTEGER DIVISION\n*\nISB1     TM    5(R9),X'20'             BLO A VALUE ?\n         BO    ISB4                    AN ADDR, BRANCH\n         TM    5(R9),X'40'             BLO IN A GPR ?\n         BO    ISC2                    IN STORAGE, BRANCH\n         SR    R14,R14                 CLEAR RII OF BLO\n         IC    R14,8(R9)\n         SRL   R14,4\n         LA    R2,1\n         SLL   R2,0(R14)\n         STC   R2,ISE3+1\n         XI    ISE3+1,X'FF'\nISE3     NI    RII+1,X'00'\n         SH    R7,ONEENTRY\n         TM    8(R9),X'10'             BLO IN AN EVEN GPR ?\n         BO    ISG4                    ODD, BRANCH\nISH11    SLL   R2,1                    NEXT ODD FREE ?\n         LA    R14,1(,R14)\n         STC   R2,ISH1+1\nISH1     TM    RII+1,0\n         BO    ISH2                    OCCUPIED, BRANCH\nISJ11    MVZ   ISJ1+1(1),8(R9)         PREPARE INSTRUCTION\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nISJ1     SRDA  0,32                    *** GENERATED CODE ***\n         LA    R4,ITF21\n         BAL   R3,ROUTIN15             CALL ROUTINE NUMBER 5\n         BAL   R4,ROUTINE8             CALL ROUTINE NUMBER 8\n         MVZ   ITE1+1(1),8(R9)         PREPARE INSTRUCTION\n         MVN   ITE1+1(1),VPLACE\n         BAL   R2,GENTXT2              GENERATE 2 BYTES\nITE1     DR    0,0                     *** GENERATED CODE ***\nITZZ     MVZ   UPLACE(1),8(R9)\n         OI    UPLACE,X'10'\n         B     IQB1\n*\nITF21    MVZ   ITF2+1(1),8(R9)         PREPARE INSTRUCTION\n         MVN   ITF2+1(1),VPLACE\n         MVC   ITF2+2(2),WPLACE\n         BAL   R2,GENTXT4              GENERATE 4 BYTES\nITF2     D     0,0(0,0)                *** GENERATED CODE ***\n         B     ITZZ\n*\nISH2     TM    0(R9),X'20'             LO A VALUE ?\n         BO    ISH3                    AN ADDR, BRANCH\n         TM    0(R9),X'40'             LO IN A GPR ?\n         BO    ISH3\n         SR    R3,R3                   LO IN THAT GPR ?\n         IC    R3,3(R9)\n         SRL   R3,4\n         STC   R3,VPLACE\n         CR    R3,R14\n         BNE   ISH3                    NO THERE, BRANCH\n         MVN   ISJ2+1(1),VPLACE        PREPARE INSTRUCTION\n         BAL   R2,GENTXT2              GENERATE 2 BYTES\nISJ2     LR    R14,0                   *** GENERATED CODE ***\n         NI    3(R9),X'0F'             ADJUST R9 ENTRY\n         OI    3(R9),X'E0'\n         B     ISJ11\n*\nISH3     BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 8\n         B     ISJ11\n*\nISG4     LA    R14,1(,R14)             NEXT EVEN FREE ?\n         TM    CII+1,X'07'             NEXT EVEN GPR7\n         BO    ISG401                  YES\n         SLL   R2,1\n         STC   R2,ISG41+1\nISG41    TM    RII+1,0\n         BZ    ISH4                    BRANCH IF FREE\n         ST    R2,RETADR\n         BAL   R4,ROUTINE9             STOPINT\n         XI    ISG41+1,X'FF'\n         NC    RII+1(1),ISG41+1\nISH4     SLL   R14,4                   PREPARE INSTRUCTION\n         STC   R14,ISH41+1\n         IC    R1,8(R9)\n         SRL   R1,4\n         STC   R1,WORKPL\n         MVN   ISH41+1(1),WORKPL\n         BAL   R2,GENTXT2              GENERATE 2 BYTES\nISH41    LR    0,0                     *** GENERATED CODE ***\n         L     R2,RETADR\n         MVZ   8(1,R9),ISH41+1         ADJUST R9 ENTRY\n         SRL   R14,4\n         B     ISH11\n*\nISC2     TM    5(R9),X'80'             BLO IN A REG ?\n         BO    ISB4                    NO, BRANCH\n         SH    R7,ONEENTRY             REDUCE P\nISB4     TM    CII+1,X'01'             LAST OCCUPIED EVEN ?\n         BO    ISD5                    ODD, BRANCH\n         TM    CII+1,X'06'             LAST OCCUPIEN R6 ?\n         BO    ISD51                   YES, BRANCH\n         SR    R1,R1\n         IC    R1,CII+1\n         LA    R1,2(,R1)\nISD52    LA    R2,1\n         SLL   R2,0(R1)\n         STC   R2,ISE4+1\n         LR    R14,R1\nISE4     TM    RII+1,0\n         BZ    ISF4                    BRANCH IF FREE\n         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9\nISF4     TM    5(R9),X'20'             BLO A VALUE ?\n         BO    ISF41                   AN ADDR, BRANCH\n         BAL   R4,ROUTINE5             CALL ROUTINE NUMBER 5\nISF42    SR    R2,R2\n         IC    R2,ISE4+1\n         B     ISH11\n*\nISF41    BAL   R4,ROUTINE6             LOAD BLO\n         B     ISF42\n*\nISD51    SR    R1,R1                   CLEAR R1\n         B     ISD52\n*\nISD5     TM    CII+1,X'07'             LAST OCCUPIED R7 ?\n         BO    ISD51                   YES, BRANCH\n         LH    R1,CII\n         LA    R1,1(,R1)\n         B     ISD52\n*\nISG401   SR    R14,R14                 CLEAR R14\n         LA    R2,1\n         STC   R2,ISG41+1\n         B     ISG41\n*\nHQB1     BAL   R4,I1B13\n         B     HEB1\n*\nHTB1     CLI   0(R10),XFPOWER          OPT POWER ?\n         BE    I1B1\nHTB11    BAL   R4,TRINRE               CONVERTION ROUTINE\n         B     DHEB2\n*\n*        INTEGER-INTEGER POWER\n*\nIUB1     TM    0(R9),X'C0'\n         BNO   IUB2\n         TM    1(R9),X'30'\n         BNZ   IUB2                    NOT CONSTANT, BRANCH\n         TM    SWVAL,X'FF'\n         BO    IUB2\n         TM    RII+1,X'01'             R0 FREE ?\n         BZ    IUC1                    YES, BRANCH\n         SR    R14,R14                 R14=0\n         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9\nIUC1     TM    RII+1,X'02'             R1 FREE ?\n         BZ    IUC11                   YES, BRANCH\n         LA    R14,1\n         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9\n         NI    RII+1,X'FD'\nIUC11    AH    R7,ONEENTRY             INCREASE P\n         STH   R7,IUG2+2               PREPARE INSTRUCTION\n         AH    R7,ONEENTRY             INCREASE P\n         STH   R7,WORKPL               CHECK MAX\n         BAL   R4,MAXCH\n         SH    R7,ONEENTRY\n         LA    R9,5(,R9)\n         LA    R4,IUH21\n         BAL   R3,ROUTIN15             CALL ROUTINE NUMBER 15\n         SR    R14,R14                 STORE BLO\n         SH    R7,ONEENTRY\n         IC    R14,3(,R9)\n         SRL   R14,4\n         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9\n         BAL   R4,ROUTINE8             CALL ROUTINE NUMBER 8\n         MVC   WPLACE(2),3(R9)\n         MVI   VPLACE,X'AA'            V=CDSA\nIUH21    MVC   IUH2+2(2),WPLACE        PREPARE INSTRUCTION\n         MVN   IUH2+1(1),VPLACE\n         SH    R9,KH5\n         LA    R2,IUG2\n         BAL   R14,GENTXTS\n         DC    H'8'                    GENERATE 8 BYTES\n*\n         BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1\n         MVC   IUH2+6(2),WPLACE\n         MVN   IUH2+5(1),VPLACE\n         LA    R2,IUH2+4\n         BAL   R14,GENTXTS\n         DC    H'14'                   GENERATE 14 BYTES\n*\n         OI    RII+1,X'01'             SET TO ONE RII OF GPR0\n         MVI   CII+1,0\n         STH   R7,WORKPL               ADJUST R9 ENTRY\n         MVC   8(2,R9),WORKPL\n         LA    R9,5(0,R9)\n         ST    R9,RUTI                 INTRODUCE R9 ADD IN RUT\n         MVC   2(1,R9),SPBNST+1        ADJUST R9 ENTRY\n         OI    1(R9),X'30'\n         NI    0(R9),X'90'\n         OI    0(R9),X'88'\n         L     R14,LATAB\n         NI    96(R14),X'7F'\n         BCT   R10,COMP\nIUG2     LA    R1,R7(CDSA,0)           *** GENERATED CODE ***\nIUH2     LA    R14,0(0,0)              *** GENERATED CODE ***\n         LA    BRR,0(0,0)              *** GENERATED CODE ***\n         STM   R14,BRR,0(R1)           *** GENERATED CODE ***\n         L     ENTRY,96(LAT,0)         *** GENERATED CODE ***\n         BALR  R14,ENTRY               *** GENERATED CODE ***\n*\nIUB2     LA    R4,I1B1\n         TM    0(R9),X'20'\n         BO    I1B13\n         TM    0(R9),X'40'\n         BO    I1B13\n         TM    5(R9),X'20'\n         BO    I1B13\n         TM    5(R9),X'40'\n         BO    I1B13\n         SR    R14,R14\n         IC    R14,8(R9)\n         SRL   R14,4\n         LA    R15,1\n         SLL   R15,0(R14)\n         STC   R15,IUB3+1\n         XI    IUB3+1,X'FF'\nIUB3     NI    RII+1,0\n         SR    R14,R14\n         TM    CII+1,X'07'\n         BO    IUB13\n         LH    R14,CII\n         LA    R14,1(,R14)\nIUB13    STH   R14,CII\n         BAL   R4,I1B13\n*\n*        REAL-INTEGER POWER\n*\nI1B1     BAL   R3,HOB11\n         LA    R4,I1C11\n         BAL   R3,ROUTIN15             CALL ROUTINE NUMBER 15\n         SR    R14,R14\n         IC    R14,3(,R9)\n         SRL   R14,4\n         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9\n         BAL   R4,ROUTINE8             CALL ROUTINE NUMBER 8\n         MVC   WPLACE(2),3(R9)         PREPARE INSTRUCTION\n         MVI   VPLACE,X'AA'\nI1C11    BAL   R3,HOD1\n         L     R14,LATAB\n         NI    100(R14),X'7F'\n         BAL   R2,GENTXT6              GENERATE 6 BYTES\n         L     ENTRY,100(LAT,0)        *** GENERATED CODE ***\n         BALR  R14,ENTRY               *** GENERATED CODE ***\n         BCT   R10,COMP\n*\n*        REAL-REAL POWER\n*\nHOB1     BAL   R3,HOB11\n         LA    R4,HOC31\n         BAL   R3,ROUTIN15             CALL ROUTINE NUMBER 15\n         SR    R14,R14\n         IC    R14,3(,R9)\n         SRL   R14,4\n         STC   R14,CIR+1\n         BAL   R4,ROUTIN13             CALL ROUTINE NUMBER 13\n         BAL   R4,ROUTIN12             CALL ROUTINE NUMBER 12\n         MVC   WPLACE(2),3(R9)         PREPARE INSTRUCTION\n         MVI   VPLACE,X'AA'\nHOC31    BAL   R3,HOD1\n         L     R14,LATAB\n         NI    104(R14),X'7F'\n         BAL   R2,GENTXT6              GENERATE 6 BYTES\n         L     ENTRY,104(LAT,0)        *** GENERATED CODE ***\n         BALR  R14,ENTRY               *** GENERATED CODE ***\n         BCT   R10,COMP\nHOB11    TM    RIR+1,X'01'             FPR0 FREE ?\n         ST    R3,RETADR+52\n         BZ    HOB21                   YES, BRANCH\n         BAL   R4,ROUTIN14             CALL ROUTINE NUMBER 14\nHOB21    TM    RIR+1,X'02'             FPR2 FREE ?\n         BZ    HOB2\n         LA    R14,2\n         BAL   R4,ROUTIN13             CALL ROUTINE NUMBER 13\n         NI    RIR+1,X'FD'\nHOB2     TM    RII+1,X'02'             GPR1 FREE ?\n         BZ    HOB3                    YES, BRANCH\n         LA    R14,1\n         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9\n         NI    RII+1,X'FD'\nHOB3     AH    R7,ONEENTRY             INCREASE P\n         STH   R7,HOB4+2               PREPARE INSTRUCTION\n         AH    R7,ONEENTRY             INCREASE P\n         STH   R7,WORKPL               CHECK MAX\n         BAL   R4,MAXCH\n         SH    R7,ONEENTRY             REDUCE P\n         LA    R9,5(,R9)\n         LA    R4,HOC11\n         BAL   R3,ROUTIN15\n         SH    R7,ONEENTRY\n         SR    R14,R14\n         IC    R14,3(,R9)\n         SRL   R14,4\n         BAL   R4,ROUTIN13             CALL ROUTINE NUMBER 13\n         SRL   R14,1\n         LA    R15,1\n         SLL   R15,0(R14)\n         STC   R15,WORKPL\n         XI    WORKPL,X'FF'\n         NC    RIR+1(1),WORKPL\n         MVC   WPLACE(2),3(R9)         W = DISPL\n         MVI   VPLACE,X'AA'            V = CDSA\nHOC11    MVC   HOB5+2(2),WPLACE        PREPARE INSTRUCTION\n         MVN   HOB5+1(1),VPLACE\n         SH    R9,KH5\n         LA    R2,HOB4\n         BAL   R14,GENTXTS\n         DC    H'8'                    GENERATE 8 BYTES\n*\n         L     R3,RETADR+52\n         BR    R3\n*\nHOD1     MVC   HOB5+6(2),WPLACE\n         ST    R3,RETADR+52\n         MVN   HOB5+5(1),VPLACE\n         LA    R2,HOB4+8\n         BAL   R14,GENTXTS\n         DC    H'8'                    GENERATE 8 BYTES\n         OI    RIR+1,X'01'             SET TO ONE RIR OF FPR0\n         MVI   CIR+1,0\n         STH   R7,WORKPL               ADJUST R9 ENTRY\n         MVC   8(2,R9),WORKPL\n         LA    R9,5(,R9)\n         ST    R9,RUTR                 INTRODUCE R9 ADD IN RUTR\n         MVC   2(1,R9),SPBNST+1        USE R9 ENTRY\n         OI    1(R9),X'30'\n         NI    0(R9),X'90'\n         OI    0(R9),X'88'\n         L     R3,RETADR+52\n         BR    R3\n*\nHOB4     LA    R1,7(CDSA,0)            *** GENERATED CODE ***\nHOB5     LA    R14,0(0,0)              *** GENERATED CODE ***\n         LA    BRR,0(0,0)              *** GENERATED CODE ***\n         STM   R14,BRR,0(R1)           *** GENERATED CODE ***\nI1B13    ST    R4,RET69\n         TM    0(R9),X'20'\n         BO    I1B14\n         TM    0(R9),X'C0'\n         BO    I1B15\nI1B14    TM    5(R9),X'20'\n         BO    I1B16\n         TM    5(R9),X'C0'\n         BO    I1B15\nI1B16    STH   R7,RET691\n         MVC   WORKPL(2),8(R9)\n         NI    WORKPL,X'0F'\n         LH    R7,WORKPL\n         LA    R9,5(,R9)\n         BAL   R4,TRINRE\n         LH    R7,RET691\n         B     I1B17\n*\nI1B15    LA    R9,5(,R9)\n         BAL   R4,TRINRE\nI1B17    SH    R9,KH5\n         L     R4,RET69\n         BR    R4\n*\nRET69    DC    F'0'\nRET691   DC    H'0'\n*\n***********************************************************************\n*\n*        END OF IEX50006\n*\n***********************************************************************\n*\n./ ADD NAME=IEX51    0201-12230-12230-1200-01113-01113-00000-LEVEL\nX51      TITLE 'IEX51 - TERMINATION OF COMPILATION, ALGOL F'\n*\n*        FUNCTION/OPERATION -\n*        THE TABLES NEEDED AT OBJECT TIME ARE PREPARED AND\n*        INCLUDED IN THE OBJECT MODULE. THEY ARE PROGRAM BLOCK\n*        TABLE, LABEL ADDRESS TABLE, AND DATASET TABLE. ESD\n*        RECORDS FOR THE REQUIRED LIBRARY ROUTINES ARE GENERATED.\n*        THE INFORMATION REQUIRED TO START THE EXECUTION,\n*        INCLUDING THE END STMT, IS GENERATED. A TABLE CONTAINING\n*        THE DSA SIZES FOR THE PROGRAM BLOCKS IS PREPARED AND\n*        TOGETHER WITH THE OBJECT MODULE SIZE OUTPUT TO\n*        SYSPRINT\n*\n*        CSECT IEX60000 -\n*        THE ERROR PATTERNS GENERATED DURING COMPILATION PHASE\n*        ARE HANDLED AND THE CORRESPONDING DIAGNOSTIC MESSAGES\n*        ARE GENERATED\n*\n*        CSECT IEX51002 -\n*        ALL AREAS RESERVED ARE RELEASED AND THE DCBS\n*        NOT CLOSED EARLIER ARE CLOSED, THE ORIGINAL PICA IS\n*        RESTORED, THE RETURN CODE IS FOUND. CONTROL IS\n*        RETURNED TO COMPILER DIRECTORY IEX00\n*\n*        ENTRY POINTS -\n*        IEX51000 - NORMAL END OF COMPILATION\n*                   XCTL EP=IEX51000 THE MODULE IS\n*                   NORMALLY ENTERED FROM IEX40\n*        IEX51ER1 - ABNORMAL END OF COMPILATION\n*                   XCTL EP=IEX51ER1 IS USED BY IEX40\n*                   AND IEX50\n*        IEX51ER2 - ABNORMAL END OF COMPILATION\n*                   XCTL EP=IEX51ER2 IS USED BY IEX40\n*        IEX51002 - ABNORMAL END OF COMPILATION\n*                   XCTL EP=IEX51002 IS USED BY IEX00,\n*                   IEX21, AND IEX31\n*\n*        INPUT - N/A\n*\n*        OUTPUT -\n*        PART OF THE OBJECT MODULE IS GENERATED AND OUTPUT ON\n*        SYSLIN AND/OR SYSPUNCH\n*        STORAGE REQUIREMENTS AND DIAGNOSTIC MESSAGES ARE\n*        OUTPUT ON SYSPRINT\n*\n*        EXTERNAL ROUTINES -\n*        THE PRINT ROUTINE IN IEX00 IS USED\n*\n*        EXIT - NORMAL-\n*        CONTROL IS GIVEN TO COMPILER DIRECTORY, IEX00, BY MEANS\n*        OF THE RETURN MACRO INSTRUCTION\n*\n*        EXIT - ERROR -\n*        AFTER PROGRAM INTERRUPTS AND I/O ERRORS THE MODULE GETS\n*        CONTROL BACK AND EXITS NORMALLY\n*\n*        TABLES/WORKAREAS -\n*        THE MESSAGE TEXTS WITH CORRESPONDING ADDRESS TABLE ARE\n*        IN THE LOAD MODULE IEX51M\n*        THE ERROR MESSAGE EDITING ROUTINE, CSECT IEX60000, ALSO\n*        USES THE FOLLOWING TABLES -\n*        WINTEBC  - TRANSLATION OF INTERNAL CHARACTERS TO EBCDIC\n*        WSYMBSRC - TRANSLATION OF SOURCE OPERATORS\n*        WSYMBSTK - TRANSLATION OF INTERNAL SYMBOLS TO EBCDIC\n*        WORDSEBC - TRANSLATION OF COMPOUND SYMBOLS IF SOURCE IN\n*                   EBCDIC\n*        WORDSISO - TRANSLATION OF COMPOUND SYMBOLS IF SOURCE IN\n*                   ISOCODE\n*        WEBCDIC  - TRANSLATION EBCDIC-EBCDIC\n*        A WORKAREA OF 270 BYTES, WAREA, IS USED FOR BUILDING\n*        THE MESSAGES\n*\n*        FOR THE EXTERNAL REFERENCES TO THE LIBRARY ROUTINES ONE\n*        OF THE TABLES SHRTAB AND LNGTAB, CONTAINING THE MODULE\n*        NAMES, IS USED. THE GENERATE ROUTINE USES THREE TABLES,\n*        ESDT, TXTT, AND RLDT, FOR GENERATION OF THE DIFFERENT\n*        TYPES OF OBJECT RECORDS.\n*\n*        THE PART OF COMMON WORKAREA STARTING AT SYSUT1 IS\n*        INITIALIZED BY THE LOAD MODULE IEX40 AND IS USED BY THIS\n*        AND THE PRECEDING LOAD MODULE\n*\n*        ATTRIBUTES - NONE\n*\n*        NOTES -\n*        CHARACTER CODE DEPENDENCE -\n*\n*        CSECT IEX51000 -\n*        THE OPERATION OF THE ROUTINES GENERATE AND PRINT\n*        STORAGE REQUIREMENTS DEPENDS UPON AN INTERNAL\n*        REPRESENTATION OF THE EXTERNAL CHARACTER SET WHICH IS\n*        EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME.\n*\n*        CSECT IEX60000 -\n*        FOR THE BUILDING OF A MESSAGE (CODE PART BETWEEN COT03\n*        AND COT12) THE FOLLOWING APPLIES -\n*        IN CASE NO SOURCE INFORMATION IS TO BE INSERTED\n*        (COT31), OR IF THE INFORMATION IS EBCDIC-CHARACTERS\n*        (COT07), THE OPERATION OF CSECT IEX60000 DEPENDS UPON AN\n*        INTERNAL REPRESENTATION OF THE EXTERNAL CHARACTER SET\n*        WHICH IS EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME.\n*        IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL\n*        CHARACTERS (COT33) THE OPERATION OF CSECT IEX60000\n*        DEPENDS UPON A TRANSLATION FROM THE INTERNAL\n*        REPRESENTATION TO THE EBCDIC CHARACTER SET BY MEANS OF\n*        THE TABLE 'WINTEBC'.\n*        IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL\n*        ALGOL SYMBOLS (COT10) THE OPERATION OF CSECT IEX60000\n*        DEPENDS UPON A TRANSLATION FROM THE INTERNAL\n*        REPRESENTATION TO THE EBCDIC CHARACTER SET BY MEANS OF\n*        THE TABLES 'WSYMBSTK'/'WSYMBSRC' AND 'WORDSISO'/\n*        'WORDSEBC'.\n*\n*        FOR THE OUTPUT OF A MESSAGE (CODE PART BETWEEN COT12\n*        AND COT21) THE FOLLOWING APPLIES -\n*        WHEN A MESSAGE HAS BEEN BUILT IN EBCDIC, AN EBCDIC-\n*        EBCDIC TRANSLATION IS PERFORMED BEFORE OUTPUT BY MEANS\n*        OF THE TABLE 'WEBCDIC'. THUS THE OUTPUT MAY BE MODIFIED\n*        BY MAKING CHANGES IN THIS TABLE.\n*\n*        THE OPERATION OF THE OTHER PARTS DOES NOT DEPEND UPON A\n*        PARTICULAR INTERNAL REPRESENTATION OF THE EXTERNAL\n*        CHARACTER SET.\n*\n*        THIS MODULE WILL BE LINKED TOGETHER WITH THE MODULE\n*        IEX51M TO FORM THE MODULE IEX51\n*\n*        THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN\n*        CONNECTION WITH THE OTHER MODULES OF THE ALGOL COMPILER\n*        IN PARTICULAR IT REQUIRES THE COMMON WORKAREA\n*\nIEX51000 CSECT\n*\n*        DEFINITIONS\n*\nRASLGT   EQU   2048                    LENGTH OF RETURN ADDR STACK\nLPGCF    EQU   28                      LENGTH OF PUT/GET CONTROL FIELD\n*\n*        ENTRY POINTS\n*\n         ENTRY IEX51ER1\n         ENTRY IEX51ER2\n*\n         IEXENTRY 'IEX51000 LEVEL 2.1 &SYSDATE &SYSTIME'\n*\n         USING IEX51000,R10\n         USING WORKAREA,R13\n*\n         LR    R10,R15\n         SR    R8,R8\n*\n*        TEST MODE\n*\nTRM1     LA    R2,IEX51ER1             GIVE DIRECTORY\n         ST    R2,ERET                 RETURN ADDR\n         OI    COMPFLGS+2,NOSC         INDICATE NO SC AVAILABLE\n         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    TRM10                   YES, BYPASS ALL CODE GENERATION\n         TM    COMPFLGS+1,NLOAD+NDECK  NOLOAD AND NODECK SPECIFIED ?\n         BO    TRM10                   YES, NO CODE GENERATION\n*\n*        GENERATE LAT, TXT RECORDS\n*\nTRM8     ST    R6,PRPTAR               SET\n         TM    PRPTAR+3,X'02'          PRPOINTER\n         BZ    TRM4                    TO\n         LA    R2,ZEROHW               FULL WORD BOUNDARY\n         BAL   R14,GENTXTS\n         DC    H'2'                    GENERATE 2 BYTES\n*\nTRM4     ST    R6,ALAT                 SAVE PRPOINTER AT LAT-BEGIN\n         L     R2,LATAB                GET ADDR OF LAT\n         LH    R3,LN                   GET DISPLACEMENT OF LAST LABEL\n         LA    R3,4(,R3)               LENGTH OF LAT\n         STH   R3,TRM39                STORE LENGTH IN TRM39\n         BAL   R14,GENTXTS             GENERATE TXT RECORDS\nTRM39    DC    H'0'                    LENGTH OF LAT\n*\n*        RLD RECORDS FOR LAT\n*\nTRM40    LH    R3,TRM39                GET LENGTH OF LAT\n         LA    R4,LATBEG+4             GET LENGTH OF 1ST PART\n         SR    R3,R4                   GET LENGTH OF LAST PART\n         BNP   TRM42                   \u00ac> ZERO, BRANCH\n         STH   R3,TRM41                STORE LENGTH OF LAST PART\n         L     R2,ALAT                 GET PRPOINTER AT LAT BEGIN\n         LA    R2,LATBEG+4(,R2)        PRPOINTER AT LAST PART\n         BAL   R14,GENRLD              GENERATE RLD RECORD\nTRM41    DC    H'0'                    LENGTH OF LAST PART\n         DC    H'1'\n         DC    H'1'\n*\n*        ESD RECORDS FOR LAT\n*\nTRM42    L     R5,LATAB                GET ADDR OF LAT\n         LA    R7,LATNR                GET NO OF ENTRIES FOR ST FUNCTS\n         LA    R9,SHRTAB               ADDR TABLE FOR SHORT PREC\n         TM    COMPFLGS,LNG            LONG PRECISION  ?\n         BZ    TRM44                   NO, BRANCH\n         LA    R9,LNGTAB               LONG, CHANGE ADDR\nTRM44    CLI   0(R5),0                 ROUTINE USED ?\n         BNE   TRM45                   NO\n         MVC   TRM43+3(5),0(R9)        YES, MOVE NAME TO ESD CALL\n         BAL   R2,GENESD               GENERATE ESD RECORD\nTRM43    DC    CL8'IHI     '\n         DC    X'02'\n*\nTRM45    LA    R5,4(,R5)               STEP\n         LA    R9,5(,R9)               ADDRS\n         BCT   R7,TRM44                HANDLE NEXT ENTRY IF ANY\n*\n*        RLD RECORDS FOR ESD ENTRIES IN LAT\n*\nTRM46    L     R11,ALAT                GET PRPOINTER AT LAT BEGIN\n         L     R5,LATAB                GET ADDR OF LAT\n         LA    R7,LATNR                GET NO OF ENTRIES FOR ST FUNCS\n         LA    R9,1                    INIT REG FOR R ESID FOR RLDCALL\n*\nTRM49    CLI   0(R5),0                 ROUTINE USED ?\n         BNE   TRM48                   NO\n         LA    R9,1(,R9)               YES, GET ESID FOR R\n         STH   R9,TRM47                GIVE TO RLD-CALL\n         LR    R2,R11\n         BAL   R14,GENRLD              GENERATE RLD RECORD\n         DC    H'4'                    LENGTH OF ADDR TABLE\nTRM47    DC    H'0'                    ESID OF RELOC FACTOR R\n         DC    H'1'                    ESID OF POSITION IDENTIFIER P\n*\nTRM48    LA    R11,4(,R11)             STEP\n         LA    R5,4(,R5)               ADDRS\n         BCT   R7,TRM49                HANDLE NEXT ENTRY IF ANY\n*\n*        GENERATE PBTAB, 4TH VERSION, TXT RECORDS\n*\nTRM2     ST    R6,APBT                 STORE PRPOINTER\n         LA    R3,PBTAB3+4             GET START\n         L     R4,APBTAB4              ADDRS\n         ST    R8,0(,R4)               SET ZEROES\n         LH    R2,PBN                  GET NUMBER OF PROGRAM BLOCKS\n         LA    R4,4(,R4)               STEP ADDR\n         MVC   0(4,R4),PIDENT          INSERT PROGRAM IDENTIFICATION\nTRM5     ST    R8,4(,R4)               INSERT ZEROES\n         LA    R4,8(,R4)               STEP ADDR\n         L     R11,0(,R3)              TAKE PBTAB3 ENTRY\n         LH    R5,ONEENTRY             ADD\n         SLL   R5,16                   SIZE OF\n         AR    R11,R5                  ONE ENTRY\n         ST    R11,0(,R4)              IN DSA\n         LA    R3,4(,R3)               STEP ADDR\n         BCT   R2,TRM5                 MOVE NEXT IF ANY\n         LA    R4,4(,R4)\n         LH    R2,KBN                  GET NUMBER\n         LTR   R2,R2                   OF LAST CONST BLOCK\n         BZ    TRM7                    NO MORE BLOCK THAN NR ZERO\n         SH    R2,PBN                  GET NO OF CONST BLKS EXCEPT 0\n         LH    R3,KH4096               GET LENGTH OF CONST BLOCK\n         LR    R5,R3\n         ST    R8,4(,R4)               INSERT ZEROES\nTRM6     ST    R3,0(,R4)               STORE DISP OF CONST BLOCK\n         LA    R4,8(,R4)               STEP ADDR\n         AR    R3,R5                   INCREASE DISPLACEMENT\n         BCT   R2,TRM6                 STORE NEXT IF ANY\n*\nTRM7     L     R2,APBTAB4              GET ADDR OF PBTAB4\n         LR    R5,R4                   COMPUTE\n         SR    R5,R2                   LENGTH OF\n         STH   R5,TRM7AA               PBTAB4\n         BAL   R14,GENTXTS             GENERATE TXT RECORDS\nTRM7AA   DC    H'0'                    LENGTH OF PBTAB4\n*\n*        RLD RECODS FOR PBTAB4\n*\nTRM52    L     R7,APBT                 GET PRPOINTER AT PBTAB4 BEGIN\n         B     TRM53                   GENERATE RLD RECORD\n*\nTRM70    NI    TRM71+1,X'0F'           CHANGE BRANCH CONDITION\n         LH    R5,KBN                  GET NUMBER OF LAST CONST BLOCK\n         CR    R8,R5                   ZERO ?\n         BE    TRM10                   YES\n         LH    R2,PBN                  NO, GET NUMBER OF\n         SR    R5,R2                   CONST BLKS EXC 0\n         SLL   R2,3                    GET PRPOINTER\n         LA    R7,8(R2,R7)             AT SECOND CONST BLK\nTRM53    LR    R2,R7\n         BAL   R14,GENRLD\n         DC    H'4'\n         DC    H'1'\n         DC    H'1'\n*\nTRM71    B     TRM70                   BRANCH AFTER FIRST RECORD\n         LA    R7,8(,R7)               STEP ADDR\n         BCT   R5,TRM53                HANDLE NEXT ENTRY IF ANY\n*\n*        CONSTRUCT DATASET TABLE\n*\nTRM10    LA    R2,DSTAB                GET ADDR OF DSTAB\n         ST    R6,DSTABPRP             STORE PRPOINTER\n         LA    R7,IOTAB                GET ADDR OF IOTAB\n         LA    R5,15                   LOAD MAX DS NUMBER\n         TM    16(R7),X'FF'            UNDET DS NO OCCURRED ?\n         BNZ   TRM12A                  YES, MDSN=15\n         LA    R3,15                   DETERMINE\n         LA    R11,1\nTRM11    LA    R4,0(R3,R7)\n         CLI   0(R4),0\n         BNE   TRM11A                  MAX\n         BCTR  R3,0                    DS\n         CR    R3,R11\n         BNE   TRM11\nTRM11A   LR    R5,R3                   NUMBER USED\n         STH   R3,MDSN                 USED\nTRM12A   BCTR  R5,0                    GET MAX DS NUMBER MINUS ONE\nTRM12    LA    R3,36                   CALC\n         MH    R3,MDSN                 LGT OF DSTAB\n         LA    R3,40(,R3)              WITHOUT PGCF\n         STH   R3,DSTABLGT\n         LA    R3,0(R3,R6)             STORE\n         ST    R3,0(,R2)               PGCF-POINTER\n         SR    R11,R11                 LOAD DS NO FOR ERROR PATTERN\n         TM    0(R7),X'70'             CORRECT SPEC FOR SYSIN\n         LA    R14,TRM19               GET RETURN ADDR FOR ERROR RTN\n         BNZ   ERR188                  NO, GENERATE ERROR PATTERN\n         MVC   4(DSTABLEL,R2),DSTABLE  YES, INSERT STANDARD DSTABLE\n         LA    R11,1                   LOAD DS NR FOR ERROR PATTERN\n         TM    1(R7),X'A0'             CORRECT SPEC FOR SYSPRINT\n         BNZ   ERR188                  NO, GENERATE ERROR PATTERN\n         MVC   40(DSTABLEL,R2),DSTABLE YES, INSERT STANDARD DSTABLE\n         MVI   66(R2),X'02'            CHANGE DS FIELD\n         MVI   74(R2),X'02'\nTRM19    LR    R3,R5                   GET MAX DS NUMBER MINUS ONE\n         LTR   R3,R3                   ZERO ?\n         BZ    TRM22                   YES, BYPASS MANIP ON BYTES 2-15\n         NI    16(R7),X'EF'            RESET SYSACT8 BIT\n         TM    16(R7),X'01'            PRE COMP PROCEDURE ?\n         BZ    TRM192                  NO\n         LA    R4,76(,R2)              GET ADDR OF DS2 IN DSTAB\nTRM191   MVC   0(DSTABLEL,R4),DSTABLE  MOVE STANDARD DSTABLE\n         MVI   26(R4),X'42'            CHANGE DS FIELD\n         MVI   34(R4),X'42'\n         LA    R4,DSTABLEL(,R4)        NEXT DS NUMBER IN DSTAB\n         BCT   R3,TRM191\n         B     TRM22\n*\nTRM192   TM    16(R7),X'FF'            BYTE 16 ZERO ?\n         BZ    TRM15                   YES\nTRM14    LA    R4,1(R3,R7)             NO, OR\n         TM    0(R4),X'10'                    BYTE 16\n         BO    TRM14A                                 INTO BYTES NOT\n         OC    0(1,R4),16(R7)          CONTAINING\nTRM14A   BCT   R3,TRM14                           SYSACT8 INDICATION\nTRM15    LR    R3,R5                   GET MAX DS NUMBER MINUS ONE\nTRM16    LA    R4,1(R3,R7)             INDICATE\n         TM    0(R4),X'C0'                      SYSACT4/13\n         BNO   TRM16A                                   IN BYTES\n         OI    0(R4),X'20'             WITH INPUT AND OUTPUT INDIC\nTRM16A   BCT   R3,TRM16\n         LR    R3,R5                   GET MAX DS NR MINUS ONE\nTRM17    LA    R4,1(R3,R7)\n         LA    R11,1(,R3)              LOAD DS NUMBER FOR ERROR PATTERN\n         TM    0(R4),X'10'             SYSACT8 INDICATED ?\n         BZ    TRM18                   NO\n         TM    0(R4),X'A0'             YES, INPUT OR SYSACT4/13 IND ?\n         BZ    TRM17A                  NO\n         LA    R14,TRM18               YES, GENERATE ERROR PATTERN\n         B     ERR188\n*\nTRM17A   NI    0(R4),X'F7'             RESET UNDET SYSACT BIT\nTRM18    BCT   R3,TRM17                EXAMINE NEXT BYTE IF ANY\n         LR    R3,R5                   GET MAX DS NR MINUS ONE\n         LA    R4,76(,R2)              GET ADDR OF DS2 IN DSTAB\n         LA    R1,2(,R7)               GET ADDR OF 2ND BYTE IN IOTAB\nTRM20    MVC   0(DSTABLEL,R4),DSTABLE  MOVE STANDARD MASK\n         TM    0(R1),X'28'             SYSACT4/13 OR UND SA IND ?\n         BNZ   TRM21                   YES\n         TM    0(R1),X'40'             NO, OUTPUT INDICATED ?\n         BZ    TRM211\n         MVI   26(R4),X'02'            YES, CHANGE DS FIELD\n         MVI   34(R4),X'02'\n         B     TRM211\n*\nTRM21    TM    0(R1),X'40'             OUTPUT INDICATED ?\n         BO    TRM21A                  YES\n         MVI   26(R4),X'40'            NO, CHANGE DS FIELD\n         MVI   34(R4),X'40'\n         B     TRM211\n*\nTRM21A   MVI   26(R4),X'42'            CHANGE DS FIELD\n         MVI   34(R4),X'42'\nTRM211   LA    R4,36(,R4)              NEXT DS NUMBER IN DSTAB\n         LA    R1,1(,R1)               NEXT BYTE IN IOTAB\n         BCT   R3,TRM20\nTRM22    TM    17(R7),X'FF'            BYTE 17 ZERO ?\n         BZ    TRM27                   YES\n         LH    R3,DSTABLGT             NO, GET ADDR OF PGCFIELD\n         LA    R3,0(R3,R2)\n         MVI   0(R3),0                 INSERT ZEROES IN PGCF\n         MVC   1(27,R3),0(R3)\n         LA    R4,2048                 INITIATE BE-FIELD\n         ST    R4,16(,R3)\n         B     TRM23\n*\nTRM27    MVI   0(R2),X'80'             INDICATE NO PUT/GET\n*\n*        GENERATE DSTABLE, TXT RECORDS\n*\nTRM23    TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?\n         BO    TRM37                   YES, BYPASS CODE GENERATION\n         TM    COMPFLGS+1,NLOAD+NDECK  NOLOAD AND NODECK SPECIFIED ?\n         BO    TRM37                   YES, NO CODE GENERATION\n         TM    COMPFLGS,PROC           PROCEDURE COMPILATION ?\n         BO    TRM24                   YES\n         LH    R3,DSTABLGT             GET LEN OF DSTAB WITHOUT PGCF\n         CLI   0(R2),X'80'             THERE A PGCF ?\n         BE    TRM23A                  NO\n         LA    R3,LPGCF(,R3)           YES, ADD PGCF LENGTH\nTRM23A   STH   R3,TRM23B               STORE LENGTH IN CALLING SEQ\n         BAL   R14,GENTXTS             GENERATE TXT RECORDS\nTRM23B   DC    H'0'                    LENGTH OF DSTAB\n*\n*        RLD RECORD FOR PGCF ADDR IN DSTAB\n*\nTRM32    L     R2,DSTABPRP             GET PRPOINTER AT DSTAB BEGIN\n         BAL   R14,GENRLD              GENERATE RLD RECORD\n         DC    H'4'                    LENGTH OF ADDR\nTRM32ID  DC    H'1'                    ESD ID\n         DC    H'1'\n*\n*        GENERATE TXT RECORDS ADDR TABLE\n*\nTRM24    MVC   ASTART(3),PRPT+1        GET PRPOINTER AT FIRST INSTR\n         TM    COMPFLGS,LNG            LONG PRECISION ?\n         BZ    TRM24A                  NO, SHORT, BRANCH\n         MVI   SW,0                    LONG, CHANGE MASK\nTRM24A   ST    R6,ADRPRP               STORE PRPOINTER AT ADR TABLE\n         LA    R2,APBT                 GET ADDR OF TEXT\n         BAL   R14,GENTXTS\n         DC    H'12'                   LENGTH OF TEXT\n*\n*        ESD RECORD FOR FSA ADDR\n*\nTRM28    TM    COMPFLGS,PROC           PROCEDURE COMPILATION ?\n         BO    TRM54                   YES\n         BAL   R2,GENESD               GENERATE ESD RECORD\nTRM29    DC    C'IHIFSAIN'\n         DC    X'0200'\n*\n*        RLD RECORDS FOR ADDR TABLE\n*\nTRM54    L     R2,ADRPRP               GET PRPOINTER AT ADDR TABLE\n         BAL   R14,GENRLD              GENERATE RLD RECORDS\n         DC    H'12'\n         DC    H'1'\n         DC    H'1'\n*\n*        ESD RECORD, LD ENTRY, FOR ENTRY INFO\n*\nTRM25    TM    COMPFLGS,PROC           PROCEDURE COMPILATION ?\n         BO    TRM35                   YES, BYPASS NEXT TWO RECORDS\n         MVC   TRM26(3),ADRPRP+1       MOVE PRPOINTER TO CALL\n         BAL   R2,GENESD\n         DC    CL8'IHIENTIF'           NAME\n         DC    X'01'\nTRM26    DC    X'000000'               PRPOINTER\n         DC    C' '\n         DC    X'000001'\n*\n*        ESD RECORD, LD ENTRY, FOR DSTAB\n*\nTRM56    MVC   TRM57(3),DSTABPRP+1     MOVE PRPOINTER TO CALL\n         BAL   R2,GENESD\n         DC    CL8'IHIDSTAB'           NAME\n         DC    X'01'\nTRM57    DC    X'000000'               PRPOINTER\n         DC    C' '\n         DC    X'000001'\n*\n*        GENERATE END RECORD\n*\nTRM35    TIME\n*\n         ST    R1,SV                   USE A SAVEAREA AS A WORKAREA\n         UNPK  ENDRECD,SV+1(3)         DATE OF COMPILE\n         ST    R6,ENDRECL              STORE LENGTH OF CSECT IN ENDREC\n         TM    COMPFLGS,PROC           PROCEDURE COMPILATION ?\n         BO    TRM34                   YES, BRANCH\n         MVC   ENDRECN,TRM29           MOVE IN ENTRY POINT ESD NAME\n         B     TRM33\n*\nTRM34    MVC   ENDRECA,ADRPRP+1        ADDR TABLE IS ENTRY POINT\n         MVC   ENDRECID,TRM32ID        GET ESD ID FOR ENTRY POINT\nTRM33    MVC   ENDRECK,PIDENT          INSERT PROGRAM IDENT\n         AP    CARDCNT,KP1             INCR SEQUENCE NUMBER\n         UNPK  ENDRECC,CARDCNT         CONVERT TO CHARACTER\n         OI    ENDRECC+3,X'F0'         MAKE PRINTABLE\n         TM    COMPFLGS+1,NLOAD        NOLOAD ?\n         BO    TRM50A                  YES, BRANCH\n         L     R1,ALINDCB              R1 -> SYSLIN DCB\n\n         PUT   (R1)                    PUT FOR SYSLIN\n\n         MVC   0(L'ENDREC,R1),ENDREC\nTRM50A   TM    COMPFLGS+1,NDECK        NODECK ?\n         BO    TRM51                   YES, BRANCH\n         L     R1,APCHDCB              R1 -> SYSPUNCH DCB\n\n         PUT   (R1)                    PUT FOR SYSPUNCH\n\n         MVC   0(L'ENDREC,R1),ENDREC\n*\n*        PRINT STORAGE REQUIREMENTS\n*\nTRM51    MVI   LINCNT+1,255            FORCE HEADINGS TO BE PRINTED\n         MVI   PAGEHD1C+1,C' '         BLANK FIRST HEADING LINE\n         MVC   PAGEHD1C+2(109),PAGEHD1C+1\n         MVC   PAGEHD2D(L'PAGEHD2D),PAGEHD1D  BLANK SEC HEADING LINE\n         MVC   PAGEHD3D(L'PAGEHD3D),PAGEHD1D  BLANK 3RD HEADING LINE\n         MVC   PAGEHD1D+35(L'HEAD1),HEAD1\n         CVD   R6,DEC                  CONVERT LENGTH OF OBJECT MODULE\n         BAL   R14,EDNR                EDIT TO PRINTABLE FORMAT\n         MVC   KOBJSZB,EDAREA+2        MOVE OBJ SIZE INTO MSG\n         BAL   R14,PRINTT              OBTAIN OUTPUT BUFFER\n         MVC   0(KOBJSZL,R1),KOBJSZ    MOVE MSG INTO BUFFER\n         BAL   R14,PRINTT              OBTAIN OUTPUT BUFFER\n         MVC   0(L'KDSA,R1),KDSA       SECOND PRINT LINE\n         BAL   R14,PRINTT              OBTAIN OUTPUT BUFFER\n         LA    R2,5                    GET NO OF ENTRIES IN ONE LINE\nTRM60    MVC   0(L'KPBN,R1),KPBN       BUILD THIRD PRINT LINE\n         LA    R1,L'KPBN+7(,R1)        BUMP BUFFER POINTER\n         BCT   R2,TRM60                LOOP 5 TIMES\n         BAL   R14,PRINTT\n         L     R3,APBTAB4              INITIATE\n         LH    R8,PBN                           REGISTERS\n         SR    R4,R4                                      FOR TABLE\nTRM62    LA    R2,5                    INITIATE FOR EACH PRINT LINE\nTRM61    LA    R4,1(,R4)                                 ENTRY\n         CVD   R4,DEC                  CONVERT\n         UNPK  BLNR,DEC+6(2)                   AND MOVE\n         OI    BLNR+2,X'F0'                             BLOCK\n         MVC   0(L'BLNR,R1),BLNR                              NUMBER\n         LA    R3,8(,R3)               GET PBTAB ENTRY\n         LH    R11,4(,R3)              GET DSA SIZE\n         CVD   R11,DEC                 CONVERT TO DECIMAL\n         BAL   R14,EDNR                EDIT\n         MVC   6(5,R1),EDAREA+3        MOVE IN VALUE\nTRM65    BCTR  R8,0\n         LTR   R8,R8                   ALL PBTAB ENTRIES HANDLED ?\n         BZ    TRM37                   YES\n         LA    R1,18(,R1)              MAKE NEXT ENTRY\n         BCT   R2,TRM61                IF LINE NOT FULL\n         BAL   R14,PRINTT              OBTAIN PRINT BUFFER\n         B     TRM62\n*\n*        OBTAIN OUTPUT BUFFER\n*\n*        ON RETURN R1 -> BUFFER\n*\nPRINTT   STM   R14,R15,SV              SAVE R14 AND R15\n         L     R15,PRTRTADD\n         BALR  R14,R15                 CALL PRINT ROUTINE\n         LM    R14,R15,SV              RESTORE REGS\n         BR    R14\n*\n*        EDIT DECIMAL NUMBER\n*\nEDNR     MVC   EDAREA,EDPTRN           MOVE PATTERN\n         ED    EDAREA,DEC+4            EDIT\n         BR    R14\n*\n*        DIRECTORY RETURN BEFORE FREEMAIN\n*\nIEX51ER1 EQU   *\nTRM37    L     R2,FREEMSIZ             GET INFO FOR AREA RELEASE\n         L     R1,FREEMADR\n*\n         FREEMAIN R,LV=(2),A=(1)       RELEASE AREA\n*\n         BALR  R15,0                   LOAD NEW BASE REGISTER\n*\nIEX51ER2 EQU   *                       TERMINATION\n         USING *,R15\n*\nTRM38    L     R2,=A(IEX60000)         R2 -> IEX60000\n         L     R14,=A(IEX51002)        LOAD RETURN ADDR\n         LA    R1,ERRINFO              ADDR INFO FOR ERROR ED ROUT\n         BR    R2                      GOTO ERROR MESSAGE EDITING\n*\n*        LTORG\n*\n         LTORG\n*\n         DROP  R15\n*\n*        GENERATE A PATTERN FOR ERROR MSG 188\n*\nERR188   SR    R9,R9\n         LA    R9,10\n         CR    R11,R9                  DS NUMBER 9 OR LOWER\n         BL    ER1                     YES\n         SR    R11,R9                  NO, SUBTRACT 10\n         STC   R11,EP188+11            STORE\n         TR    EP188+11(1),NRTRA       CONVERT TO CHARACTER\n         MVI   EP188+10,C'1'           INSERT FIRST DIGIT\n         LA    R9,13                   GET L'ENTRY\n         B     ER2\n*\nER1      STC   R11,EP188+10            STORE NUMBER\n         TR    EP188+10(1),NRTRA       CONVERT IT\n         MVI   EP188+11,C'.'           INSERT PERIOD\n         LA    R9,12                   GET LENGTH OF ENTRY\nER2      STC   R9,EP188                INSERT LENGTH OF ENTRY\n         OI    EP188,X'80'             PUT A TAG FOR BLANK SC\n         BCTR  R9,0                    DECREASE BY ONE\n         STC   R9,ER3+1                STORE LENGTH IN MOVE INSTR\n         L     R11,NEXTERR             GET NEXT ENTRY IN POOL\nER3      MVC   0(0,R11),EP188          MOVE PATTERN\n         LA    R11,1(R9,R11)           UPDATE PTR TO NEXT FREE ENTRY\n         ST    R11,NEXTERR\n         C     R11,ENDPOOL             POOL FULL ?\n         BH    ER4                     YES\n         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE\n         BR    R14                     RETURN\n*\nER4      MVC   0(4,R11),EP0            MOVE PATTERN EP0\n         LA    R11,4(,R11)             UPDATE PTR\n         ST    R11,NEXTERR             STORE IT\n         B     TRM37                   TERMINATE COMPILATION\n*\n*        CONSTANTS AND AREAS\n*\nPRPTAR   DC    A(0)                    AREA TO HANDLE PRPOINTER\nDSTABPRP DC    A(0)                    PRPOINTER AT DSTAB BEGIN\nAFSAPRP  DC    A(0)                    PRPOINTER AT AFSA\nADRPRP   DC    A(0)                    PRPOINTER AT APBT\nMDSN     DC    H'15'                   MAX DS NUMBER\nKH4096   DC    H'4096'                 LENGTH OF CONSTANT BLOCK\n*\n*        GENERATE MODEL DATASET TABLE ENTRY\n*\n         DSTABLE  DSECT=NO\n*\nDSTABLGT DC    H'0'                    LENGTH OF DSTAB WITHOUT PGCF\n*\n*        END RECORD\n*\n         DC    0F'0'\nENDREC   DC    CL80' '             *   IMAGE FOR END RECORD\n         ORG   ENDREC              |   COLS\n         DC    X'02'               |   1\n         DC    C'END'              |   2-4\n         DC    C' '                |   5\nENDRECA  DC    C'   '              |   6-8   ENTRY ADDR\n         DC    C'      '           |   9-14\nENDRECID DC    C'  '               |   15-16 ESDID OF ENTRY POINT\nENDRECN  DC    C'        '         |   17-24\n         DC    C'    '             |   25-28\nENDRECL  DC    C'    '             |   29-32 CSECT LENGTH\n         DC    C'1'                |   33    NUMBER OF IDR ITEMS\n         DC    C'360SAL531 '       |   34-43 TRANSLATOR PRODUCT IDR\n         DC    C'0201'             |   44-47 VERSION AND RELEASE NUMBER\nENDRECD  DC    C'99999'            |   48-52 PROCESSING DATE\n         ORG   ENDREC+72           |\nENDRECK  DC    CL4' '              |   73-76 DECK ID\nENDRECC  DC    CL4' '              V   77-80 RECORD COUNT\n         ORG   ,\n*\nAPBT     DC    A(0)                    ADDR OF PBT\nALAT     DC    A(0)                    ADDR OF LAT\nSW       DC    X'20'                   SWITCH FOR LONG/SHORT PREC\nASTART   DC    AL3(0)                  ADDR OF FIRST INSTRUCTION\n*\nHEAD1    DC    C'STORAGE REQUIREMENTS (DECIMAL)'\n*\nKOBJSZ   DC    C'OBJECT MODULE SIZE'\nKOBJSZB  DC    CL6' '\n         DC    C' BYTES'\nKOBJSZL  EQU   *-KOBJSZ                L'OBJECT SIZE MESSAGE\n*\nKDSA     DC    C'DATA STORAGE AREA SIZES'\nKPBN     DC    C'PBN   BYTES'\nDEC      DC    D'0'                    FOR CONVERSION OF NUMBERS\nEDPTRN   DC    X'4020202020202020'     PATTERN FOR EDITING\nEDAREA   DC    CL8' '                  EDITING OF NUMBERS\nBLNR     DC    CL3' '                  FOR CONVERSION OF BLOCK NUMBER\nSV       DC    2F'0'                   SAVE AREA\n*\nEP188    DC    X'00BC0000'             ERROR PATTERN FOR MESSAGE 188\n         DC    C'DSN = 00.'\n*\nEP0      DC    X'04000000'             ERROR PATTERN FOR MESSAGE 0\n*\nNRTRA    DC    C'0123456789'           TRANSLATION OF DS NUMBER\n*\nERRINFO  DC    V(IEX51M00)             ADDR OF MESSAGE TEXTS\n         DC    V(IEX51M01)             ADDR OF ADDR TABLE\n         DC    H'12'                   MODIFICATION NUMBER\n*\n         DC    0F'0'\n*\n*        LIBRARY ROUTINES - SHORT\n*\nSHRTAB   DC    C'SYSCT'\n         DC    C'SSQ  '\n         DC    C'SSCS '\n         DC    C'SSCC '\n         DC    C'SAT  '\n         DC    C'SLO  '\n         DC    C'SEX  '\n         DC    C'ISYMB'\n         DC    C'IDEIR'\n         DC    C'IDEII'\n         DC    C'IBOOL'\n         DC    C'IARRY'\n         DC    C'IARRT'\n         DC    C'IBARR'\n         DC    C'OSYMB'\n         DC    C'SOREL'\n         DC    C'OINTG'\n         DC    C'OBOOL'\n         DC    C'OARRY'\n         DC    C'OTARR'\n         DC    C'OBARR'\n         DC    C'OSTRG'\n         DC    C'GPRPT'\n         DC    C'GPRGT'\n         DC    C'FII  '\n         DC    C'FRI  '\n         DC    C'FRR  '\n*\n*        LIBRARY ROUTINES - LONG\n*\nLNGTAB   DC    C'SYSCT'\n         DC    C'LSQ  '\n         DC    C'LSCS '\n         DC    C'LSCC '\n         DC    C'LAT  '\n         DC    C'LLO  '\n         DC    C'LEX  '\n         DC    C'ISYMB'\n         DC    C'IDEIR'\n         DC    C'IDEII'\n         DC    C'IBOOL'\n         DC    C'IARRY'\n         DC    C'IARRT'\n         DC    C'IBARR'\n         DC    C'OSYMB'\n         DC    C'LOREL'\n         DC    C'OINTG'\n         DC    C'OBOOL'\n         DC    C'OARRY'\n         DC    C'OTARR'\n         DC    C'OBARR'\n         DC    C'OSTRG'\n         DC    C'GPRPT'\n         DC    C'GPRGT'\n         DC    C'FII  '\n         DC    C'FDI  '\n         DC    C'FDD  '\n*\n***********************************************************************\n*\n*        S U B R O U T I N E   G E N E R A T E\n*\n***********************************************************************\n*\n*        REGISTER DEFINITIONS\n*\n*        R1                            OUTPUT RECORD POINTER\n*        R2                            ADDR OF DATA\n*        R3                            TYPE OF RECORD TO BE GENERATED\n*        R4                            RETURN REGISTER\n*        R14                           LENGTH OF DATA FROM CALL\n*        R15                           LENGTH WITHIN RECORD\n*\n*        BIT PATTERNS\n*\nSDENTRY  EQU   X'00'                   SD ENTRY IDENTIFICATION\nLDENTRY  EQU   X'01'                   LD ENTRY IDENTIFICATION\nRLDFLAG  EQU   B'00001100'             FLAG USED IN RLD ENTRY\n*\n*        GENERATE ESD RECORDS\n*\nGENESD   LA    R14,16                  LENGTH ALWAYS 16\n         LA    R3,ESDT                 INDICATE ESD CALL\n         B     GEN1\n*\n*        GENERATE TXT RECORDS\n*\nGENTXTS  LA    R4,2(,R14)              COMPUTE RETURN ADDR\n         LH    R14,0(,R14)             LOAD LENGTH GIVEN IN CALL\nGEN2     LA    R3,TXTT                 INDICATE TXT CALL\n         B     GEN1                    CONTINUE COMMON PART\n*\n*        GENERATE RLD RECORDS\n*\nGENRLD   LA    R4,6(,R14)              COMPUTE RETURN ADDR\n         LA    R3,RLDT                 INDICATE RLD CALL\n         MVC   RANDP(4),2(R14)         INSERT NEW R AND P\n         LH    R14,0(,R14)             LOAD LENGTH GIVEN IN CALL\n         SLL   R14,1                   DOUBLE LENGTH\nGEN1     L     R1,SAVOUTA              LOAD ADDR OF OUT RECORD\n         CLC   1(3,R1),1(R3)           RECORD RIGHT TYPE ?\n         BNE   GEN3                    NO, CALL FOR NEW\n         CLC   10(2,R1),12(R3)         RECORD FILLED ?\n         BNL   GEN3                    YES, CALL FOR NEW\nGEN6     LA    R15,56\n         LH    R0,10(,R1)              R0=LENGTH OF DATA IN REC\n         SR    R15,R0                  R15=EMPTY POS LEFT IN RECORD\n         CR    R15,R14                 ENOUGH SPACE LEFT ?\n         BL    *+6                     NO\n         LR    R15,R14                 YES, R15=LENGTH FROM CALL\n         AR    R15,R0\n         STH   R15,10(,R1)             INSERT NEW LENGTH INTO RECORD\n         SR    R15,R0\n         AR    R1,R0                   START ADDR WITHIN RECORD\n         SR    R14,R15                 REMAINING LENGTH\n         B     14(,R3)                 TO DIFFERENT MOVE ROUTINES\n*\nGEN4     LTR   R14,R14                 MORE INFORMATION MUST BE MOVED ?\n         BH    GEN3                    YES\n         BR    R4                      NO, RETURN\n*\n*        CALL FOR NEW OUTPUT RECORD\n*\nGEN3     ST    R14,SAVELT              SAVE LENGTH\n         TM    COMPFLGS+1,NLOAD+NDECK  DECK AND LOAD SPECIFIED ?\n         BZ    BOTH                    YES\n         TM    COMPFLGS+1,NDECK        ONLY DECK ?\n         L     R1,APCHDCB              R1 -> SYSPUNCH DCB\n         BZ    PUT1                    YES\nPUT1A    L     R1,ALINDCB              R1 -> SYSLIN DCB\n*\nPUT1     PUT   (R1)                    PUT FOR SYSLIN AND SYSPUNCH IF\n*\n         ST    R1,SAVOUTA              ONLY SYSPUNCH SPECIFIED\n         L     R14,SAVELT              RESTORE LENGTH\n         B     PUNCHOUT\n*\nBOTH     L     R14,OUTAREA2            COPY SYSLIN BUFFER TO SYSPUNCH\n         L     R1,SAVOUTA\n         MVC   0(80,R14),0(R1)         BUFFER\nPUT2     L     R1,APCHDCB              R1 -> SYSPUNCH DCB\n*\n         PUT   (R1)                    PUT FOR SYSPUNCH WHEN BOTH HAS\n*\n         ST    R1,OUTAREA2             BEEN SPECIFIED\n         B     PUT1A                   GOTO PUT SYSLIN\n*\nPUNCHOUT MVC   0(4,R1),0(R3)           INSERT FIRST 4 BYTES\n         MVI   4(R1),C' '              INSERT ONE BLANK\n         MVC   5(67,R1),4(R1)          BLANK OUTPUT RECORD\n         MVC   72(4,R1),PIDENT         INSERT PROGRAM IDENT\n         AP    CARDCNT,KP1             INCR SEQUENCE NUMBER\n         UNPK  76(4,R1),CARDCNT        CONVERT TO CHARACTER\n         OI    79(R1),X'F0'            MAKE PRINTABLE\n         MVC   10(2,R1),4(R3)          INSERT INITIAL LENGTH\n         MVC   14(6,R1),6(R3)          INSERT ESID + R AND P\n         CLC   TXTT+1(3),1(R3)         TXT RECORD PROCESSED ?\n         BNE   GEN6                    NO\n         ST    R6,4(R1)                YES, INSERT R6\n         MVI   4(R1),C' '\n         B     GEN6\n*\n*        ESD RECORD\n*\n         DC    0H'0'\nESDT     DC    X'02'                   RECORD CODE\n         DC    C'ESD'                  IDENTIFICATION\n         DC    H'0'                    INITIAL LENGTH 0\n         DC    C'      '\n         DC    H'48'                   MAXIMUM LENTH IN RECORD\n*\n*        MOVE ESD INFORMATION TO OUTAREA\n*\nGEN7     MVC   16(16,R1),0(R2)         MOVE DATA TO OUTAREA\n         CLI   8(R2),LDENTRY           LD ENTRY MOVED ?\n         BE    16(R2)                  YES, RETURN TO CALLING ROUTINE\n         MVC   25(L'ESDCON,R1),ESDCON  CHANGE LAST PART OF ENTRY\n         LH    R3,ESID\n         LA    R3,1(,R3)               INCR ESD ID\n         STH   R3,ESID                 STORE NEW ESID NUMBER\n         SR    R1,R0\n         CLI   14(R1),C' '             FIRST SD OR ER ENTRY ?\n         BNE   10(R2)                  NO, RETURN TO CALLING ROUTINE\n         STH   R3,14(R1)               YES, INSERT ESID NUMBER\n         B     10(R2)                  RETURN TO CALLING ROUTINE\n*\n*        TXT RECORD\n*\n         DC    0H'0'\nTXTT     DC    X'02'                   RECORD CODE\n         DC    C'TXT'                  IDENTIFICATION\n         DC    H'0'                    INITIAL LENGTH 0\n         DC    H'1'                    ESID\n         DC    C'    '\n         DC    H'56'                   MAXIMUM LENGTH\n*\n*        MOVE TXT INFORMATION OUTAREA\n*\nGEN8     BCTR  R15,0                   DECR LENGTH\n         STC   R15,*+5                 INSERT PROPER LENGTH TO MOVE\n         MVC   16(0,R1),0(R2)          MOVE DATA TO OUTAREA\n         LA    R6,1(R15,R6)            INCREASE PROGRAM POINTER\n         LA    R2,1(R15,R2)            MODIFY DATA ADDR\n         B     GEN4                    OUT OF MOVE TXT ROUTINE\n*\n*        RLD RECORD\n*\n         DC    0H'0'\nRLDT     DC    X'02'                   RECORD CODE\n         DC    C'RLD'                  IDENTIFICATION\n         DC    H'0'\n         DC    C'  '\nRANDP    DC    C'    '                 R AND P\n         DC    H'56'                   MAXIMUM LENGTH IN RECORD\n*\n*        MOVE RLD INFORMATION TO OUTAREA\n*\nGEN9     AR    R15,R1                  INDICATE LAST ENTRY\nGEN5     MVC   16(4,R1),RANDP          INSERT R AND P\n         ST    R2,20(,R1)              MOVE PROGRAM POINTER VALUE\n         MVI   20(R1),RLDFLAG          FLAG TO OUTAREA\n         LA    R1,8(,R1)               NEXT ENTRY\n         LA    R2,4(,R2)               NEXT PROGRAM POINTER VALUE\n         CR    R1,R15                  LAST COLUMN FILLED ?\n         BL    GEN5                    NO, CONTINUE\n         B     GEN4                    OUT OF MOVE RLD ROUTINE\n*\n*        VARIABLES AND CONSTANTS\n*\nSAVELT   DC    F'0'                    SAVE AREA FOR LENGTH\nESID     DC    H'1'                    ESID VARIABLE 1 AT START\nESDCON   DC    X'00000040404040'       ESD CONSTANT 7 BYTES\nKP1      DC    PL1'1'                  INCREMENT CARD COUNTER\n*\n         TITLE 'IEX51 - TERMINATION OF COMPILATION, ERROR MSG EDITING'\n*\n         COPY  IEX60000\n*\n         TITLE 'IEX51 - TERMINATION OF COMPILATION'\n*\nIEX51002 CSECT\n*\n         BALR  R2,0\n         USING *,R2\n*\n         OI    COMPFLGS+1,TERM         INDICATE THIS ROUTINE IS ENTERED\n         LA    R0,CLOSEDCB             PROVIDE DIRECTORY\n         ST    R0,ERET                 RETURN ADDR\n*\n*        FREE THE STORAGE OF THE ERROR POOL AND SOURCE PROG\n*        BUFFER 1\n*\n         TM    COMPFLGS+1,NOBUF        GETMAIN FOR BUFFERS ISSUED ?\n         BO    CLOSEDCB                NO, BRANCH\n         L     R0,POOLS                SIZE OF ERROR POOL\n         A     R0,SRCE1S               SIZE OF SOURCE PROG BUFFER 1\n         L     R1,ERRPOOL              ADDR OF ERROR POOL\n*\n         FREEMAIN R,LV=(0),A=(1)\n*\n*        CLOSE THE DCBS AND FREE THE BUFFER POOLS\n*\nCLOSEDCB BALR  R2,0\n         USING *,R2\n         LA    R0,SPIE                 PROVIDE NEW DIR RETURN ADDR\n         ST    R0,ERET\n         LM    R3,R12,DCBTABLE         LOAD DCB ADDRS\n         USING IHADCB,R8               R8 -> SYSPRINT DCB\n         TM    DCBOFLGS,DCBOFOPN       SYSPRINT OPEN ?\n         DROP  R8\n         BO    CLOSEB                  YES, BRANCH\n         OI    SWITCH+1,X'F0'\n*\nCLOSEB   CLOSE ((3),,(8),,(9),,(11),,(12))\n*\n         TM    COMPFLGS+1,NLOAD\n         BO    FRPPCH                  IF NOLOAD OPTION\n         LR    R1,R3                   R1 -> SYSLIN DCB\n*\n         FREEPOOL (1)                  FREE SYSLIN BUFFERS\n*\nFRPPCH   TM    COMPFLGS+1,NDECK\n         BO    FRPPRT                  IF NODECK OPTION\n         LR    R1,R9                   R1 -> SYSPUNCH DCB\n*\n         FREEPOOL (1)                  FREE SYSPUNCH BUFFERS\n*\nFRPPRT   LR    R1,R8                   R1 -> SYSIN DCB\nSWITCH   NOP   SPIE\n*\n         FREEPOOL (1)                  FREE SYSIN BUFFERS\n*\n*        EXECUTE SPIE MACRO\n*\nSPIE     BALR  R2,0\n         USING *,R2\n         L     R4,PICAADD\n*\n         SPIE  MF=(E,(R4))\n*\n*\n*        FIND THE RETURN CODE AND RETURN TO IEX00\n*\nRTNCODE  TM    COMPFLGS,TERR\n         BZ    NOTERM                  IF NO TERMINAL ERROR\n         LA    R15,16\n         B     RETURNN\n*\nNOTERM   TM    COMPFLGS,SERR\n         BZ    NOSER                   IF NO SERIOUS ERROR\n         LA    R15,8\n         B     RETURNN\n*\nNOSER    SR    R15,R15\n         TM    COMPFLGS,WERR\n         BZ    RETURNN\n         LA    R15,4\nRETURNN  L     R13,SAVEAREA+4\n*\n         RETURN (14,12),RC=(15)\n*\n         LTORG\n*\n*        DCB\n*\n         PRINT NOGEN\n*\n         DCBD  DSORG=(PS),DEVD=(DA)\n*\n         PRINT GEN\n*\nWORKAREA DSECT\n*\n         COPY  WORKAREA\n*\n*        AREA USED BY COMPILATION PHASE\n*\n         ORG   SYSUT1\n*\nRETADR   DS    17F                     SAVE AREA\nPLACE14  DS    F                          -''-\nRUTI     DS    9F                      GPR CONTROL\nRUTR     DS    4F                      FLREG CONTROL\nGPROLN   DS    H                       LABEL NR OF OBJ PRG ENTRY POINT\nKONSUM   DS    H                       WORKPLACE\nWORKPL   DS    F                       WORKPLACE\nIBUF1    EQU   SRCE1ADD                ADDR OF FIRST SOURCE BUFFER\nIBUF2    DS    A                         -''  SECOND    -''-\nSOURCEB  DS    A                         -''  CURRENT   -''-\nRSRCB    DS    A                         -''  READ      -''-\nOPBUF1   DS    A                       ADDR OF FIRST OPTAB BUFFER\nOPBUF2   DS    A                         -''-  SECOND    -''-\nOPBUFB   DS    A                         -''-  CURRENT   -''-\nROPTB    DS    A                         -''-  READ      -''-\nAOPTABE  DS    A                       ADDR OF CURRENT OPTAB ENTRY\nLATAB    DS    A                       ADDR OF LABEL ADDR TABLE\nAPBTAB4  EQU   LATAB                   ADDR OF PBTAB4\nSUTABCA  DS    A                       ADDR OF LAST USED SUTAB ENTRY\nSTRETURN DS    F                       RETURN ADDR\nFREEMADR DS    A                       ADDR FOR FREEMAIN IN 50000\nFREEMSIZ DS    F                       SIZE          -''-\n*\nPBTAB3   DS    1024C                   PROGRAM BLOCK TABLE, 3RD VERS\n*\nIOTAB    DC    18X'00'                 LIST OF DATASETS\nCII      DC    H'0'                    REGISTER CONTROL\nCIR      DC    H'0'                         -''-\nRII      DC    H'0'                         -''-\nRIR      DC    H'0'                         -''-\nOPDPBN   DC    H'0'                    PROGRAM BLOCK NR (BYTE 2 OF OPD\nOPDADR   DC    H'0'                    BYTES 3 AND 4 OF OPERAND\nOPDLN    DC    H'0'                    LABEL NUMBER TIMES FOUR\nZEROHW   DC    H'0'                    ZEROES\nCFSN     DC    X'00'                   CURRENT FS NUMBER\nMAXFSN   DC    X'FF'                   MAX FS NUMBER\nCLEARDIS DC    X'F000'                 FOR CLEARING OF DISPLACEMT PART\nONEENTRY DC    H'4'                    SHORT, FOR INCR OF OT STACK PTR\n         ORG   ONEENTRY\n         DC    H'8'                    LONG            -''-\nPRECMASK DC    X'10'                   SHORT, TO MODIFY INSTRUCTIONS\n         ORG   PRECMASK\n         DC    X'00'                   LONG            -''-\nNUMBBL   DC    X'00'                   RECORD COUNTER\n         DS    H\nSPBNST   DC    H'0'                    CURRENT PBN\n         DS    H                                   AND DISPLACEMENT\nGPBN     DC    H'255'                  GLOBAL DSA CONTROL\nMAXOVERF DC    H'4092'                 SHORT, TO CHECK OT STACK OVERFL\n         ORG   MAXOVERF\n         DC    H'4088'                 LONG            -''-\nHALFW    DS    H                       WORKPLACE\nUSPEI2   DS    H                       FOR ARRAY DECLA-\nUSPEI4   DS    H                                       RATION HANDLING\nWPLACE   DS    H                       FOR INSTRUCTION GENERATION\nXPLACE   DS    H\nYPLACE   DS    H\nUPLACE   DS    H\nVPLACE   DS    C                                   -''-\nSTRDNAME DS    5C                      TO STORE OPERAND\nCBVTAB   DS    48C                     CALLED-BY-VALUE TABLE\nSUTABC   DS    768C\n         ORG   SUTABC\nDSTAB    DS    608C                    DATASET TABLE\n*\n*        REGISTER EQUATES\n*\n         IEZREGS\n*\n*        CHARACTER EQUATES\n*\n         IEXCHAR\n*\n         END\n./ ADD NAME=IEX51M   0201-12230-12230-1200-00239-00239-00000-LEVEL\nX51M     TITLE 'IEX51M - ERROR MESSAGE TEXT POOL 3, ALGOL F'\n*\n*        FUNCTION/OPERATION -\n*        THIS MODULE CONTAINS MESSAGE TEXTS FOR ALL ERRORS THAT\n*        MAY BE DETECTED BY IEX00, IEX50, AND IEX51, AND THE\n*        CORRESPONDING ADDRESS TABLE\n*\n*        ENTRY POINT - N/A\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        EXITS - NORMAL - N/A\n*\n*        EXITS - ERROR - N/A\n*\n*        TABLES/WORKAREAS - N/A\n*\n*        ATTRIBUTES - N/A\n*\n*        NOTES -\n*        AT SYSTEM GENERATION THIS MODULE WILL BE LINKED\n*        TOGETHER WITH THE MODULE IEX51 TO FORM THE MODULE IEX51\n*\nIEX51M00 CSECT\n*\n         ENTRY IEX51M01\n*\n*        ERROR MESSAGE POOL 3\n*\nWEMPOOL3 EQU   *\n*\nW160     DC    X'280500081244001B00001B45001C000C1C'\n         DC    CL24'SSEQUENCE   NOT ALLOWED.'\n*\nW161     DC    X'300500081244001B00081B450024000C24'\n         DC    CL32'SSEQUENCE  OPERAND  NOT ALLOWED.'\n*\nW162     DC    X'2F0500171244002A00042A45002F00002F'\n         DC    CL31'SOPERAND MISSING BETWEEN  AND .'\n*\nW163     DC    X'3B0300110C44001E001D1E'\n         DC    CL49'SOPERAND FOLLOWING  MUST BE OF ARITHMETICAL TYPE.'\n*\nW164     DC    X'3205001A1244002D00042D450032000032'\n         DC    CL34'SNO OPERAND ALLOWED BETWEEN  AND .'\n*\nW165     DC    X'3500'\n         DC    CL52'SEXPRESSIONS BEFORE AND AFTER ''ELSE'''\n         DC    C'NOT COMPATIBLE.'\n*\nW166     DC    X'2100'\n         DC    CL32'SDECLARATOR IN ILLEGAL POSITION.'\n*\nW167     DC    X'3202440009002909'\n         DC    CL43'S AND OPERAND PRECEDING DECLARATOR ILLEGAL.'\n*\nW168     DC    X'330300110C44001E00151E'\n         DC    CL41'SOPERAND PRECEDING  CANNOT POSSESS VALUE.'\n*\nW169     DC    X'2403000F0C44001C00081C'\n         DC    CL26'SLABEL FOLLOWING  ILLEGAL.'\n*\nW172     DC    X'2400'\n         DC    CL35'SDIFFERENT TYPES IN LEFT PART LIST.'\n*\nW173     DC    X'3C00'\n         DC    CL59'TCOMPILATION UNSUCCESSFUL DUE TO COMPILER OR MACHINX\n               E ERROR.'\n*\nW174     DC    X'3C00'\n         DC    CL59'SPARAMETERS NOT ALLOWED FOR TYPE PROCEDURE CALLED BX\n               Y VALUE.'\n*\nW175     DC    X'360300120C44001E00181E'\n         DC    CL44'SOPERAND FOLLOWING  MUST BE LABEL OR SWITCH.'\n*\nW176     DC    X'230300160C440023000023'\n         DC    CL25'SOPERAND MISSING BEFORE .'\n*\nW177     DC    X'2703001A0C440027000027'\n         DC    CL29'SOPERAND NOT ALLOWED BEFORE .'\n*\nW178     DC    X'3700'\n         DC    CL54'SILLEGAL OPERAND IN EXPRESSION BEFORE OR AFTER ''ELX\n               SE''.'\n*\nW179     DC    X'6100'\n         DC    CL96'SNUMBER OF SUBSCRIPT EXPRESSIONS DIFFERS FROM DIMENX\n               SION IN ARRAY       DECLARATION FOR VARIABLE.'\n*\nW180     DC    X'1C00'\n         DC    CL27'SINVALID SWITCH DESIGNATOR.'\n*\nW181     DC    X'2800'\n         DC    CL39'SSWITCH DESIGNATOR IN ILLEGAL POSITION.'\n*\nW182     DC    X'2E0300110C44001E00101E'\n         DC    CL36'SOPERAND FOLLOWING  MUST BE BOOLEAN.'\n*\nW183     DC    X'3D0300110C44001E001F1E'\n         DC    CL51'SOPERAND PRECEDING  MUST BE A PROCEDURE IDENTIFIER.X\n               '\n*\nW184     DC    X'440300110C44001E00261E'\n         DC    CL58'SOPERAND PRECEDING  MUST BE AN ARRAY OR SWITCH IDENX\n               TIFIER.'\n*\nW185     DC    X'440300160C440023002123'\n         DC    CL58'SREAL OPERAND PRECEDING  NOT ALLOWED FOR INTEGER DIX\n               VISION.'\n*\nW186     DC    X'3B00'\n         DC    CL58'TSYNTACTICAL STRUCTURE TOO COMPLICATED. INTERNAL OVX\n               ERFLOW.'\n*\nW187     DC    X'2800'\n         DC    CL39'SINCORRECT NUMBER OF ACTUAL PARAMETERS.'\n*\nW188     DC    X'3902003009800004'\n         DC    CL50'SINVALID ACTUAL PARAMETER FOR STANDARD PROCEDURE. '\n*\nW189     DC    X'3D00'\n         DC    CL60'SDATA SET NUMBER OR FUNCTION OF SYSACT OUT OF ALLOWX\n               ED RANGE.'\n*\nW190     DC    X'1A00'\n         DC    CL25'SASSIGNMENT NOT POSSIBLE.'\n*\nW191     DC    X'2E0300200C44002D00012D'\n         DC    CL36'SNO OPERAND ALLOWED BETWEEN ) AND  .'\n*\nW192     DC    X'2D00'\n         DC    CL44'SINVALID RIGHT PART IN ASSIGNMENT STATEMENT.'\n*\nW193     DC    X'2D00'\n         DC    CL44'SINCOMPATIBLE TYPES IN ASSIGNMENT STATEMENT.'\n*\nW194     DC    X'1502440009000C09'\n         DC    CL14'S NOT ALLOWED.'\n*\nW195     DC    X'290300100C44001D000C1D'\n         DC    CL31'SSEQUENCE OPERAND  NOT ALLOWED.'\n*\nW196     DC    X'3303001A0C440027000C27'\n         DC    CL41'SARRAY IDENTIFIER PRECEDING  NOT ALLOWED.'\n*\n*        DIRECTORY MESSAGES\n*\nW209     EQU   *\nW197     DC    X'460400360FF00000840046000046'\n         DC    CL57'TCOMPILATION UNSUCCESSFUL DUE TO PROGRAM INTERRUPT.X\n                PSW .'\n*\nW210     EQU   *\nW198     DC    X'300300270C840030000030'\n         DC    CL38'TUNRECOVERABLE I/O ERROR ON DATA SET .'\n*\nW211     EQU   *\nW199     DC    CL56'PROGRAM INTERRUPT IN ERROR MESSAGE EDITING ROUTINE.X\n                PSW '\n*\n*        MESSAGES USED BY MORE THAN ONE PHASE\n*\nW212     EQU   *\nW200     DC    X'1200'\n         DC    CL17'TTOO MANY ERRORS.'\n*\nW213     EQU   *\nW201     DC    X'2800'\n         DC    CL39'TINTERNAL OVERFLOW OF IDENTIFIER TABLE.'\n*\nW214     EQU   *\nW202     DC    X'3903002D0C84003A00003A'\n         DC    CL48'SDATA STORAGE AREA EXCEEDED, PROGRAM BLOCK NO. .'\n*\nW215     EQU   *\nW203     DC    X'1A00'\n         DC    CL25'TSOURCE PROGRAM TOO LONG.'\n*\nW216     EQU   *\nW204     DC    X'2600'\n         DC    CL37'STOO MANY LABELS. LABEL NUMBER RESET.'\n*\n         DC    0F'0'\n*\n*        ADDRESS TABLE FOR WEMPOOL3\n*\nIEX51M01 EQU   *-640\n         DC    A(W160)\n         DC    A(W161)\n         DC    A(W162)\n         DC    A(W163)\n         DC    A(W164)\n         DC    A(W165)\n         DC    A(W166)\n         DC    A(W167)\n         DC    A(W168)\n         DC    A(W169)\n         DC    A(0)\n         DC    A(0)\n         DC    A(W172)\n         DC    A(W173)\n         DC    A(W174)\n         DC    A(W175)\n         DC    A(W176)\n         DC    A(W177)\n         DC    A(W178)\n         DC    A(W179)\n         DC    A(W180)\n         DC    A(W181)\n         DC    A(W182)\n         DC    A(W183)\n         DC    A(W184)\n         DC    A(W185)\n         DC    A(W186)\n         DC    A(W187)\n         DC    A(W188)\n         DC    A(W189)\n         DC    A(W190)\n         DC    A(W191)\n         DC    A(W192)\n         DC    A(W193)\n         DC    A(W194)\n         DC    A(W195)\n         DC    A(W196)\n         DC    A(W197)\n         DC    A(W198)\n         DC    A(W199)\n         DC    A(W200)\n         DC    A(W201)\n         DC    A(W202)\n         DC    A(W203)\n         DC    A(W204)\n*\n         END\n./ ADD NAME=IEX60000 0201-12230-12230-1200-00629-00629-00000-LEVEL\n         TITLE 'IEX60000 - ERROR MESSAGE PROCESSING, ALGOL F'\n*\n*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER\n*\nIEX60000 CSECT\n*\n         USING IEX60000,R2\n*\n*        REGISTER DEFINITIONS\n*\n*        R1                            POINTS TO PARAMETER LIST\n*        R1                            RETURNS ADDR OF PRINT BUFFER\n*        R2                            BASE REGISTER FOR COTEMER\n*        R4                            BASE REGISTER FOR MESSAGE POOL\n*        R5                            POINTER TO ENTRY IN ERROR POOL\n*        R6                            POINTER TO INSERTION CODE\n*        R7                            POINTER TO ENTRY IN MSG POOL\n*        R14                           PTR TO MESSAGE TEXT WORKAREA\n*\n*        INITIALIZATION\n*\n         USING WORKAREA,R13            BASEREG FOR WORKAREA DSECT\n         MVC   AWEMPOOL(10),0(R1)      GET ADDRS AND MOD NUMBER\nCOT00    LA    R9,WDIRET1              STORE RETURN ADDR\n         ST    R9,ERET                 IN WORKAREA\n         STM   R14,R15,SVAR1           SAVE RETURN ADDR AND BASE\n         TM    COMPFLGS+2,PRT+PRTNO    SYSPRINT DOWN/NOT OPENED ?\n         BNZ   COT18                   YES, GIVE CONSOLE MESSAGE\n         L     R5,ERRPOOL              ADDR ERROR POOL\n         CL    R5,NEXTERR              ERROR POOL EMPTY ?\n         BE    COT28                   YES\n         CLC   PAGEHEAD+39(L'HEADD1),HEADD1  HEADINGS ALREADY SET ?\n         BE    COT01                   YES, BYPASS HEADINGS\n         MVI   LINCNT+1,255            FORCE HEADINGS TO BE PRINTED\n         MVI   PAGEHD1C+1,C' '         BLANK FIRST HEADING LINE\n         MVC   PAGEHD1C+2(109),PAGEHD1C+1\n         MVC   PAGEHD2D(L'PAGEHD2D),PAGEHD1D  BLANK 2ND HEADING LINE\n         MVC   PAGEHD3D(L'PAGEHD3D),PAGEHD1D  BLANK 3RD HEADING LINE\n         MVC   PAGEHD1D+39(L'HEADD1),HEADD1   MOVE IN HEADD1\n         MVC   PAGEHD2D(L'HEADD2),HEADD2      MOVE IN HEADD2\n*\n*        HANDLING OF THE ENTRIES IN ERROR POOL\n*\nCOT01    L     R4,AWEMPOOL             ADDR ERROR MESSAGE POOL\n         SR    R7,R7\n         IC    R7,1(,R5)               GET ERROR MSG NUMBER\n         LA    R10,200\n         CR    R7,R10                  DIRECTORY MESSAGE ?\n         BL    COT36                   NO\n         LH    R10,MODNUMB             YES, MODIFY NUMBER\n         SR    R7,R10\nCOT36    SLL   R7,2                    GET IT FOUR TIMES\n         L     R9,AWADDTAB             ADDR ADDR TABLE\n         AR    R7,R9                   GET CORRECT ENTRY\n         L     R7,0(,R7)               LOAD ADDR TO ENTRY IN ERMSG POOL\n*\n*        GET LENGTH OF INSERT CODE PART\n*\nCOT02    LA    R6,2(,R7)               POINT TO FIRST INSERTION CODE\n         SR    R9,R9\n         IC    R9,1(,R7)               GET NUMBER OF INSERTION CODES\n         LR    R10,R9\n         LR    R12,R9\n         LA    R12,1(,R12)             SET INSERTION CODE COUNTER\n         SLL   R9,1                    DOUBLE IT\n         AR    R9,R10                  GET IT 3 TIMES\n*\n*        HANDLE SEVERITY CODE\n*\nCOT03    LA    R10,2(R9,R7)            GET ADDR TO BYTE BEFORE TEXT\n         MVC   WAREA+9(1),0(R10)       INSERT SEVERITY CODE\n         CLI   0(R10),C'W'\n         BNE   COT03A\n         OI    COMPFLGS,WERR           SET WARNING MESSAGE\n         B     COT04\n*\nCOT03A   CLI   0(R10),C'S'\n         BNE   COT03B\n         OI    COMPFLGS,SERR           SET SEVERE ERROR\n         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE\n         B     COT04\n*\nCOT03B   OI    COMPFLGS,TERR           SET BIT FOR TERMINATING ERROR\n*\n*        INSERTION OF MSG NUMBER AND SEMICOLON COUNTER\n*\nCOT04    SR    R10,R10                 CLEAR REG\n         IC    R10,1(R5)               GET ERROR MSG NUMBER\n         CVD   R10,WDEC+8\n         UNPK  WAREA+3(3),WDEC+8(8)    CONVERT TO PRINTABLE DECIMAL\n         OI    WAREA+5,X'F0'           MAKE CHAR PRINTABLE\n         TM    0(R5),X'80'             BLANKS FOR SC ?\n         BZ    COT26                   NO\n         MVC   WAREA+12(5),BLANKS      YES, MOVE BLANKS\n         NI    0(R5),X'7F'             REMOVE TAG\n         B     COT31\n*\nCOT26    LH    R10,2(,R5)              GET SEMICOLON COUNTER\n         CVD   R10,WDEC+8\n         UNPK  WAREA+12(5),WDEC+8(8)   CONVERT TO READABLE DECIMAL\n         OI    WAREA+16,X'F0'          MAKE CHAR PRINTABLE\n*\n*        INSERTION OF FIXED MESSAGE\n*\nCOT31    LA    R14,WAREA+20            POINT TO FIRST TEXTBYTE IN WAREA\n         CLI   1(R7),0                 ANY INSERTION CODE ?\n         BNE   COT05                   YES\n         LA    R10,3(,R7)              GET ADDR OF MSG TXT\n         SR    R11,R11\n         IC    R11,0(,R7)              GET L'ENTRY\n         AR    R11,R7                  GET NEXT ENTRY\n         SR    R11,R10                 GET L'MSG TXT\n         EX    R11,WMOVE1              MOVE MSG TXT TO WORKAREA\n         LA    R14,1(R11,R14)          UPDATE WAREA POINTER\nCOT05    BCT   R12,COT06               GOTO INS CODE TREATMENT IF ANY\n         B     COT12                   ALL INS CODES TREATED\n*\n*        INSERTION CODE TREATMENT\n*\n*        TEST ACTION PART OF INSERT CODE\n*\nCOT06    LA    R9,15                   LOAD REG TO ZERO HIGHORDER BITS\n         SR    R10,R10\n         SR    R11,R11\n         TM    0(R6),X'F0'\n         BO    COT37                   GOTO 'INSERT BLANKS'\n         BZ    COT30                   GOTO 'INSERT MESSAGE TEXT'\n         TM    0(R6),X'80'\n         BO    COT07                   GOTO 'UNALTERED TEXT'\n         TM    0(R6),X'40'\n         BO    COT10                   GOTO 'ALGOL SYMBOL'\n         TM    0(R6),X'20'\n         BO    COT33                   GOTO 'INTERNAL CHARACTERS'\n*\n*        INSERTION OF BLANKS AT END OF PRTLIN\n*\nCOT37    LA    R3,WAREA+90             CALC FREE SPACE ON 1ST PRT LINE\n         SR    R3,R14\n         BNP   COT09                   BYPASS BLANKING IF LINE FULL\nCOT38    MVI   0(R14),C' '             INSERT BLANK\n         LA    R14,1(,R14)             STEP WAREA POINTER\n         BCT   R3,COT38                BRANCH IF 1ST PRT LINE NOT FULL\n         B     COT09                   GOTO NEXT INS CODE\n*\n*        INSERTION OF MESSAGE TEXT PART\n*\nCOT30    IC    R10,2(,R6)\n         LA    R10,0(R10,R7)           GET ADDR OF TEXT PART\n         IC    R11,1(,R6)              GET L'TEXT PART\nCOT08    EX    R11,WMOVE1              MOVE TO WORKAREA\nCOT35    LA    R14,1(R11,R14)          UPDATE WORKAREA POINTER\nCOT09    LA    R6,3(,R6)               UPDATE INS CODE POINTER\n         B     COT05                   GOTO NEXT INS CODE\n*\n*        UNALTERED TEXT\n*\nCOT07    IC    R11,0(,R5)              GET LENGTH OF SOURCE TEXT\n         LA    R10,5\n         SR    R11,R10\n         BM    COT09                   NO MOVE IF NO SOURCE TEXT\n         LA    R10,4(,R5)              GET ADDR OF SOURCE TEXT\n         B     COT08                   MOVE TEXT, GOTO NEXT INS CODE\n*\n*        ALGOL SYMBOL\n*\nCOT10    TM    COMPFLGS+2,SET60        60 CHARACTER SET USED ?\n         BO    COT32                   YES, BRANCH\n         LA    R11,WORDSISO            USE ISO TABLE\n         B     COT32A\n*\nCOT32    LA    R11,WORDSEBC            USE EBCDIC TABLE\nCOT32A   LA    R3,WSYMBSTK             TABLE FOR STACK OPERATOR\n         IC    R10,0(,R6)              GET ONE BYTE ALGOL SYMBOL\n         NR    R10,R9\n         IC    R10,0(R10,R5)\n         STC   R10,WDEC\n         TM    WDEC,X'80'              SOURCE OPERATOR ?\n         BZ    COT32B                  NO\n         LA    R3,WSYMBSRC             YES, CHANGE TABLE\n         NI    WDEC,X'7F'              REMOVE TAG\n         IC    R10,WDEC\nCOT32B   SLL   R10,1                   MULTIPLY BY 2\n         LH    R10,0(R10,R3)           CONVERT TO EBCDIC OR DISPLACEMT\n         LA    R9,256                  TEST KIND OF SYMBOL\n         CLR   R10,R9\n         BL    COT11                   ONE CHARACTER SYMBOL\n         LA    R10,0(R10,R11)          ADDR WORDS ENTRY\n         SR    R11,R11\n         IC    R11,0(,R10)             GET LENGTH OF SYMBOL\n         LA    R10,1(,R10)             GET ADDR OF SYMBOL\n         B     COT08                   MOVE SYMB, GOTO NEXT INS CODE\n*\nCOT11    SR    R11,R11                 GET LENGTH-1 OF ONE-CHAR SYMBOL\n         STC   R10,0(,R14)             MOVE SYMBOL TO MSG AREA\n         B     COT35                   GOTO NEXT INS CODE\n*\n*        INTERNAL CHARACTERS\n*\nCOT33    LA    R9,5\n         IC    R11,0(,R5)              GET NUMBER OF INT CHARACTERS-1\n         SR    R11,R9\n         STC   R11,COT34+1             STORE IT IN TRANSLATE INSTR\n         LA    R10,4(,R5)              GET ADDR OF SOURCE TEXT\n         EX    R11,WMOVE1\nCOT34    TR    0(0,R14),TRINTEXT       TRANSLATE\n         B     COT35                   UPDATE PTR, GOTO NEXT INS CODE\n*\n*        TRANSLATION AND OUTPUT OF MESSAGE\n*\nCOT12    TM    SWTO,X'80'              MESSAGE TO CONSOLE ?\n         BO    COT25                   YES\n*\n*        MESSAGE TO SYSPRINT\n*\nCOT16    LR    R11,R14\n         LA    R9,WAREA+20             GET L'MESSAGE TEXT\n         SR    R11,R9\n         LA    R9,70                   GET L'TEXT ON FIRST LINE\n         SR    R11,R9                  SUBTRACT IT\n         LA    R9,89                   GET L'PRINTLINE\n         LA    R10,WAREA               GET ADDR OF ERROR MESSAGE\n         BAL   R15,COT27               OBTAIN OUTPUT BUFFER, BLANK IT\n         LTR   R11,R11                 L'MSG TXT > 70 ?\n         BNL   COT17                   YES\n         ALR   R9,R11                  OBTAIN PRTLINE LENGTH IF < 90\nCOT17    EX    R9,WMOVE3               MOVE FIRST PART OF ERROR MSG\nCOT20    LA    R10,1(R9,R10)           INCREASE ADDR IN WORKAREA\n         LTR   R11,R11                 MORE TEXT TO BE MOVED ?\n         BNH   COT21                   NO\n         LA    R9,70                   YES, GET L'NEXT PRTLINE\n         SR    R11,R9                  SUBTRACT IT FROM REMAIN TXTLGT\n         BAL   R15,COT27               OBTAIN OUTPUT BUFFER, BLANK IT\n         LTR   R11,R11                 LENGTH > 70 ?\n         BNL   COT19                   YES\n         ALR   R9,R11                  OBTAIN LENGTH IF LESS THAN 70\nCOT19    LA    R15,1                   MODIFY LENGTH FOR MOVE INSTR\n         SR    R9,R15\n         EX    R9,WMOVE4               MOVE TEXT TO OUTPUT BUFFER\n         B     COT20                   PUT OUT NEXT TEXTLINE IF ANY\n*\n*        MESSAGE TO WTP\n*\nCOT25    LA    R11,40(,R11)            GET LENGTH FOR MOVE INSTRUCTION\n         EX    R11,EXMVC\n*\nCOT24    WTO   '                                                       X\n                      ',ROUTCDE=11,DESC=7   ISSUE WTP\n*\nEXMVC    MVC   COT24+8(0),WAREA        MOVE MESSAGE\n*\n         B     WDIRET2                 TERMINATE\n*\n*        OBTAIN OUTPUT BUFFER\n*\nCOT27    STM   R14,R15,SVAR2           SAVE REGS FOR CALL OF PRINT RTN\n         L     R15,PRTRTADD            LOAD ADDR OF PRINT ROUTINE\n         BALR  R14,R15                 CALL PRINT ROUTINE\n         LM    R14,R15,SVAR2           RESTORE REGS\n         BR    R15\n*\n*        GOTO NEXT MESSAGE OR TERMINATE\n*\nCOT21    SR    R9,R9\n         IC    R9,0(,R5)               GET L'TREATED ENTRY\n         AR    R5,R9                   POINT TO NEXT ENTRY\n         L     R9,NEXTERR              GET ADDR OF FIRST FREE ENTRY\n         CR    R5,R9                   NEXT ENTRY = FIRST FREE ?\n         BL    COT01                   NO, HANDLE NEXT ENTRY\n         LA    R10,WDIRET2             LOAD NEW RETURN ADDR\n         ST    R10,ERET\n         L     R10,ERRPOOL             YES, POOL EXHAUSTED, ZERO PTR\n         ST    R10,NEXTERR\n         TM    COMPFLGS,TERR           TERMINATING ERROR ?\nCOT28    LM    R14,R15,SVAR1           LOAD RETURN ADDR AND BASE\n         BO    COT29                   YES\n         BR    R14                     RETURN\n*\nCOT29    XCTL  EP=IEX51002             BRANCH TO TERMINATION\n*\n*        ACTION TO BE PERFORMED AFTER I/O ERROR OR PROGRAM\n*        INTERRUPTION\n*\nWDIRET1  TM    COMPFLGS+2,PRT          SYSPRINT ERROR ?\n         BZ    COT18A                  NO\nCOT18    OI    SWTO,X'80'              YES, SET SWITCH ON\n         B     LAST\n*\nCOT18A   TM    COMPFLGS+1,ERR          PROGRAM INTERRUPT ?\n         BZ    LAST                    NO\n         LA    R7,211                  YES, GET MESSAGE NUMBER\n         LH    R10,MODNUMB             MODIFY IT\n         SR    R7,R10\n         SLL   R7,2                    GET ENTRY IN ADDR TABLE\n         L     R9,AWADDTAB\n         AR    R7,R9                   GET ADDR OF MESSAGE\n         L     R7,0(,R7)\n         BAL   R15,COT27               GET PRINT BUFFER\n         MVC   0(20,R1),CPI            MOVE MSG CODE ETC\n         MVC   20(51,R1),0(R7)         MOVE MSG TEXT\n         BAL   R15,COT27               GET PRINT BUFFER\n         L     R9,NEXTERR              GET ADDR OF PSW\n         LA    R10,16\n         SR    R9,R10\n         MVC   20(16,R1),0(R9)         MOVE PSW\n         MVI   37(R1),C'.'             INSERT PERIOD\n*\nWDIRET2  OI    COMPFLGS+1,NSRCE        SET BIT FOR TERMINATING ERROR\n         B     COT29                   BRANCH TO TERMINATION\n*\n*        HANDLE LAST ERROR PATTERN\n*\nLAST     L     R5,NEXTERR              GET ADDR OF FIRST FREE ENTRY\n         LA    R10,12                  GET ADDR OF LAST PATTERN\n         SR    R5,R10\n         B     COT01                   GOTO NORMAL TREATMENT\n*\n*        WORKAREAS AND MOVE INSTRUCTIONS\n*\n         CNOP  0,4\nWMOVE1   MVC   0(0,R14),0(R10)\nWMOVE3   MVC   0(0,R1),0(R10)\nWMOVE4   MVC   20(0,R1),0(R10)\n*\nWDEC     DC    2D'0'\nWAREA    DC    C'IEX000I  0  00000   '\n         DC    250C' '\n*\n*        HEADINGS AND MESSAGE 211 (PART OF)\n*\nHEADD1   DC    C'DIAGNOSTICS'\nHEADD2   DC    C'CODE    SEV  SC     MESSAGE'\n*\nCPI      DC    C'IEX211I  T          ' FIRST PART OF MESSAGE 211\n*\n*        ADDRESSES AND CONSTANT\n*\nAWEMPOOL DC    F'0'                    ADDR OF MESSAGE TEXTS\nAWADDTAB DC    F'0'                    ADDR OF ADDR TABLE\nMODNUMB  DC    H'0'                    MODIFICATION NUMBER\n*\n*        VARIOUS\n*\nSWTO     DC    X'00'                   SWITCH FOR OUTPUT ON CONSOLE\nSVAR2    DC    2F'0'                   TO SAVE LINKREGS FOR PRINT RTN\nSVAR1    DC    2F'0'                   TO SAVE RETURN ADDR AND BASE\nBLANKS   DC    CL5' '\n*\n*        TABLES FOR CONVERSION AND TRANSLATION\n*\n*        TRANSLATE INTERNAL CHARS TO EBCDIC\n*\nTRINTEXT DC    C'+-*/##(:'             00 -> 07\n         DC    C'\u00dd##;####'             08 -> 0F\n         DC    C'=<>#####'             10 -> 17\n         DC    C'########'             18 -> 1F\n         DC    C'\u00ac#|&&#,):'            20 -> 27\n         DC    C'\u00a8## #.''#'            28 -> 2F\n         DC    C'01234567'             30 -> 37\n         DC    C'89####.'''            38 -> 3F\n         DC    C'ABCDEFGH'             40 -> 47\n         DC    C'IJKLMNOP'             48 -> 4F\n         DC    C'QRSTUVWX'             50 -> 57\n         DC    C'YZ$_#@'               58 -> 5D\n*\n*\n*        CONVERSION OF SOURCE OPERATORS\n*\n         DC    0F'0'\nWSYMBSRC DC    X'00'                   00        PLUS\n         DC    C'+'\n         DC    X'00'                   01        MINUS\n         DC    C'-'\n         DC    X'00'                   02        MULTIPLY\n         DC    C'*'\n         DC    X'00'                   03        DIVIDE\n         DC    C'/'\n         DC    H'256'                  04        INTEGER DIVIDE\n         DC    H'260'                  05        'POWER'\n         DC    X'00'                   06        LEFT PARENTHESIS\n         DC    C'('\n         DC    H'268'                  07        COLON\n         DC    H'271'                  08        LEFT BRACKET\n         DC    H'274'                  09        'ARRAY'\n         DC    H'282'                  0A        'SWITCH'\n         DC    H'291'                  0B        SEMICOLON\n         DC    H'294'                  0C        'BEGIN'\n         DC    H'294'                  0D        'BEGIN'\n         DC    H'469'                  0E        'PROCEDURE'\n         DC    H'469'                  0F        'PROCEDURE'\n         DC    H'302'                  10        'EQUAL'\n         DC    H'310'                  11        'LESS'\n         DC    H'317'                  12        'GREATER'\n         DC    H'327'                  13        'NOTEQUAL'\n         DC    H'338'                  14        'NOTGREATER\n         DC    H'351'                  15        'NOTLESS'\n         DC    H'361'                  16        COLON EQUAL\n         DC    H'364'                  17        'GOTO'\n         DC    H'371'                  18        'FOR'\n         DC    H'377'                  19        'STEP'\n         DC    H'384'                  1A        'UNTIL'\n         DC    H'392'                  1B        'WHILE'\n         DC    H'400'                  1C        'DO'\n         DC    H'405'                  1D        'IF'\n         DC    H'410'                  1E        'THEN'\n         DC    H'417'                  1F        'ELSE'\n         DC    H'424'                  20        'NOT'\n         DC    H'430'                  21        'IMPL'\n         DC    H'437'                  22        'OR'\n         DC    H'442'                  23        'AND'\n         DC    H'448'                  24        'EQUIV'\n         DC    X'00'                   25        COMMA\n         DC    C','\n         DC    X'00'                   26        RIGHT PARENTHESIS\n         DC    C')'\n         DC    H'268'                  27        COLON\n         DC    H'456'                  28        RIGHT SUBSCRIPT BRACK\n         DC    H'291'                  29        DELTA\n         DC    H'459'                  2A        'END'\n         DC    H'291'                  2B        ETA\n         DC    H'459'                  2C        'END'\n         DC    X'00'                   2D        OMEGA\n         DC    C' '\n         DC    H'481'                  2E        'CODE'\n*\n*        CONVERSION OF STACK OPERATORS\n*\nWSYMBSTK DC    X'00'                   00        PLUS\n         DC    C'+'\n         DC    X'00'                   01        MINUS\n         DC    C'-'\n         DC    X'00'                   02        MULTIPLY\n         DC    C'*'\n         DC    X'00'                   03        DIVIDE\n         DC    C'/'\n         DC    H'256'                  04        INTEGER DIVIDE\n         DC    H'260'                  05        'POWER'\n         DC    X'00'                   06        LEFT PARENTHESIS\n         DC    C'('\n         DC    H'268'                  07        COLON\n         DC    H'271'                  08        LEFT BRACKET\n         DC    H'274'                  09        'ARRAY'\n         DC    H'282'                  0A        'SWITCH'\n         DC    H'291'                  0B        SEMICOLON\n         DC    H'294'                  0C        'BEGIN'\n         DC    H'294'                  0D        'BEGIN'\n         DC    H'469'                  0E        'PROCEDURE'\n         DC    H'469'                  0F        'PROCEDURE'\n         DC    H'302'                  10        'EQUAL'\n         DC    H'310'                  11        'LESS'\n         DC    H'317'                  12        'GREATER'\n         DC    H'327'                  13        'NOTEQUAL'\n         DC    H'338'                  14        'NOTGREATER\n         DC    H'351'                  15        'NOTLESS'\n         DC    H'361'                  16        COLON EQUAL\n         DC    H'364'                  17        'GOTO'\n         DC    H'371'                  18        'FOR'\n         DC    H'377'                  19        'STEP'\n         DC    H'384'                  1A        'UNTIL'\n         DC    H'392'                  1B        'WHILE'\n         DC    H'400'                  1C        'DO'\n         DC    H'405'                  1D        'IF'\n         DC    H'410'                  1E        'THEN'\n         DC    H'417'                  1F        'ELSE'\n         DC    H'424'                  20        'NOT'\n         DC    H'430'                  21        'IMPL'\n         DC    H'437'                  22        'OR'\n         DC    H'442'                  23        'AND'\n         DC    H'448'                  24        'EQUIV'\n         DC    X'00'                   25        ALPHA\n         DC    C' '\n         DC    H'405'                  26        IFS\n         DC    H'410'                  27        THENS\n         DC    H'417'                  28        ELSES\n         DC    X'00'                   29        LEFT PARENTHESIS\n         DC    C'('\n         DC    X'00'                   2A        LEFT PARENTHESIS\n         DC    C'('\n         DC    X'00'                   2B        MONADIC MINUS\n         DC    C'-'\n         DC    H'271'                  2C        LEFT SUBSCRIPT BRACKET\n         DC    H'361'                  2D        COLON EQUAL\n         DC    H'361'                  2E        COLON EQUAL\n*\n*        COMPOUND ALGOL SYMBOLS, EBCDIC\n*\n         DC    0F'0'\nWORDSEBC EQU   *-256\n         DC    X'02'                   256       INTEGER DIVIDE\n         DC    C'''/'''\n         DC    X'01'                   260       POWER\n         DC    C'**     '\n         DC    X'00'                   268       COLON\n         DC    C': '\n         DC    X'01'                   271       LEFT BRACKET\n         DC    C'(/'\n         DC    X'06'                   274       'ARRAY'\n         DC    C'''ARRAY'''\n         DC    X'07'                   282       'SWITCH'\n         DC    C'''SWITCH'''\n         DC    X'00'                   291       SEMICOLON\n         DC    C'; '\n         DC    X'06'                   294       'BEGIN'\n         DC    C'''BEGIN'''\n         DC    X'00'                   302       EQUAL\n         DC    C'=      '\n         DC    X'00'                   310       LESSTHAN\n         DC    C'<     '\n         DC    X'00'                   317       GREATER THAN\n         DC    C'>        '\n         DC    X'01'                   327       NOT EQUAL\n         DC    C'\u00ac=        '\n         DC    X'01'                   338       LESS THAN OR EQU\n         DC    C'<=          '\n         DC    X'01'                   351       GR THAN OR EQU\n         DC    C'>=       '\n         DC    X'01'                   361       COLON EQUAL\n         DC    C':='\n         DC    X'05'                   364       'GOTO'\n         DC    C'''GOTO'''\n         DC    X'04'                   371       'FOR'\n         DC    C'''FOR'''\n         DC    X'03'                   377       'STEP'\n         DC    C'''STEP'''\n         DC    X'06'                   384       'UNTIL'\n         DC    C'''UNTIL'''\n         DC    X'06'                   392       'WHILE'\n         DC    C'''WHILE'''\n         DC    X'03'                   400       'DO'\n         DC    C'''DO'''\n         DC    X'03'                   405       'IF'\n         DC    C'''IF'''\n         DC    X'05'                   410       'THEN'\n         DC    C'''THEN'''\n         DC    X'05'                   417       'ELSE'\n         DC    C'''ELSE'''\n         DC    X'00'                   424       NOT\n         DC    C'\u00ac    '\n         DC    X'05'                   430       'IMPL'\n         DC    C'''IMPL'''\n         DC    X'00'                   437       OR\n         DC    C'|   '\n         DC    X'00'                   442       AND\n         DC    C'&&    '\n         DC    X'06'                   448       'EQUIV'\n         DC    C'''EQUIV'''\n         DC    X'01'                   456       RIGHT BRACKET\n         DC    C'/)'\n         DC    X'04'                   459       'END'\n         DC    C'''END'''\n         DC    X'02'                   465       LEFT STRINGQUOTE\n         DC    C'''('''\n         DC    X'0A'                   469       'PROCEDURE'\n         DC    C'''PROCEDURE'''\n         DC    X'05'                   481       'CODE'\n         DC    C'''CODE'''\n*\n         DS    0F\nWORDSISO EQU   *-256               LIST OF COMPOUND ALGOL SYMBOLS, ISO\n         DC    X'02'                   256       INTEGER DIVIDE\n         DC    C'''/'''\n         DC    X'06'                   260       'POWER'\n         DC    C'''POWER'''\n         DC    X'01'                   268       COLON\n         DC    C'..'\n         DC    X'01'                   271       LEFT BRACKET\n         DC    C'(/'\n         DC    X'06'                   274       'ARRAY'\n         DC    C'''ARRAY'''\n         DC    X'07'                   282       'SWITCH'\n         DC    C'''SWITCH'''\n         DC    X'01'                   291       SEMICOLON\n         DC    C'.,'\n         DC    X'06'                   294       'BEGIN'\n         DC    C'''BEGIN'''\n         DC    X'06'                   302       'EQUAL'\n         DC    C'''EQUAL'''\n         DC    X'05'                   310       'LESS'\n         DC    C'''LESS'''\n         DC    X'08'                   317       'GREATER'\n         DC    C'''GREATER'''\n         DC    X'09'                   327       'NOTEQUAL'\n         DC    C'''NOTEQUAL'''\n         DC    X'0B'                   338       'NOTGREATER'\n         DC    C'''NOTGREATER'''\n         DC    X'08'                   351       'NOTLESS'\n         DC    C'''NOTLESS'''\n         DC    X'01'                   361       COLON EQUAL\n         DC    C'.='\n         DC    X'05'                   364       'GOTO'\n         DC    C'''GOTO'''\n         DC    X'04'                   371       'FOR'\n         DC    C'''FOR'''\n         DC    X'03'                   377       'STEP'\n         DC    C'''STEP'''\n         DC    X'06'                   384       'UNTIL'\n         DC    C'''UNTIL'''\n         DC    X'06'                   392       'WHILE'\n         DC    C'''WHILE'''\n         DC    X'03'                   400       'DO'\n         DC    C'''DO'''\n         DC    X'03'                   405       'IF'\n         DC    C'''IF'''\n         DC    X'05'                   410       'THEN'\n         DC    C'''THEN'''\n         DC    X'05'                   417       'ELSE'\n         DC    C'''ELSE'''\n         DC    X'04'                   424       'NOT'\n         DC    C'''NOT'''\n         DC    X'05'                   430       'IMPL'\n         DC    C'''IMPL'''\n         DC    X'03'                   437       'OR'\n         DC    C'''OR'''\n         DC    X'04'                   442       'AND'\n         DC    C'''AND'''\n         DC    X'06'                   448       'EQUIV'\n         DC    C'''EQUIV'''\n         DC    X'01'                   456       RIGHT BRACKET\n         DC    C'/)'\n         DC    X'04'                   459       'END'\n         DC    C'''END'''\n         DC    X'02'                   465       LEFT STRINGQUOTE\n         DC    C'''('''\n         DC    X'0A'                   469       'PROCEDURE'\n         DC    C'''PROCEDURE'''\n         DC    X'05'                   481       'CODE'\n         DC    C'''CODE'''\n*\n*        END OF IEX60000\n*\n./ ADD NAME=OPTIONS  0201-12230-12230-1200-00059-00059-00000-LEVEL\nX01      TITLE 'ALGOL F COMPILER OPTIONS GENERATION'\n*\n*        COMPILER OPTIONS FOR THE ALGOL F COMPILER ARE SPECIFIED\n*        IN THE STAGE 1 SYSGEN MACRO ALGOL\n*\n*        THE OUTPUT FROM STAGE 1 SYSGEN IS AN ASSEMBLY STEP\n*        INVOKING MACRO SGIEX001 WITH THE APPROPRIATE MACRO\n*        PARAMETERS PASSED TO IT FROM THE GLOBAL VARIABLES SET BY\n*        THE STAGE 1 ALGOL MACRO\n*\n*        REFER TO THE MVT 21.8 SYSTEM GENERATION MANUAL FOR ALGOL\n*        MACRO SPECIFICATIONS\n*\n*        THE STAGE 2 PROCESS FOR ALGOL IS THE ASSEMBLY OF\n*        SGIEX001 TO GENERATE CSECT IEX00001 WHICH IS LATER LINK\n*        EDITED WITH IEX00000 TO PRODUCE THE LOAD MODULE ALGOL\n*        WHICH IS THE POINT OF INVOCATION FOR THE COMPILER\n*\n*        TO AVOID THE COMPLEXITY OF RUNNING A STAGE 1 SYSGEN AND\n*        EDITING OUT ONLY THE STAGE 2 STEPS TO GENERATE THE\n*        ALGOL COMPILER OPTIONS, THE 2 MACROS HAVE BEEN COMBINED\n*        INTO AN ASSEMBLY. A SEPARATE LINK EDIT JOB SUBSEQUENTLY\n*        BUILDS ALL THE COMPILER LOAD MODULES.\n*\n**********************************************************************\n*                                                                    *\n*        SYSGEN GLOBAL FLAGS UTILIZED BY THE MACROS                  *\n*                                                                    *\n**********************************************************************\n*\n         GBLB &SGALGOB(5)\n         GBLA &SGALGOA(1)\n         GBLB &SGQUITB\n*\n**********************************************************************\n*                                                                    *\n*        ALGOL - REFER TO MVT RELEASE 21.8 SYSGEN MANUAL             *\n*                                                                    *\n*        GC28-6554-13 OS SYSTEM GENERATION RELEASE 21.8              *\n*                                                                    *\n**********************************************************************\n*\n         ALGOL SIZE=262144,                                            X\n               PUNCH=NODECK,                                           X\n               TYPERUN=LOAD,                                           X\n               SORCODE=EBCDIC,                                         X\n               SORLIST=SOURCE,                                         X\n               PRECISN=SHORT\n\n*\n**********************************************************************\n*                                                                    *\n*        SGIEX001 - STAGE 2 MACRO TO ASSEMBLE OPTIONS CSECT IEX00001 *\n*                                                                    *\n**********************************************************************\n*\n         SGIEX001 &SGALGOB(5),&SGALGOB(4),&SGALGOB(2),&SGALGOB(1),     X\n               &SGALGOB(3),&SGALGOA(1)\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AL21SCTL": {"ttr": 61700, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x135\\x05K\\x05K\\x00\\x00\\xc3\\xd6\\xd4\\xd7\\xc1\\xe2\\xd1@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T13:35:00", "lines": 1355, "newlines": 1355, "modlines": 0, "user": "COMPASJ"}, "text": "./ ADD NAME=AIEX00   0201-12230-12230-1200-00010-00010-00000-LEVEL\n//T1X00    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX00\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX00    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX00\n./ ADD NAME=AIEX10   0201-12230-12230-1200-00010-00010-00000-LEVEL\n//T1X10    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX10\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX10    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX10\n./ ADD NAME=AIEX11   0201-12230-12230-1200-00010-00010-00000-LEVEL\n//T1X11    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX11\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX11    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX11\n./ ADD NAME=AIEX20   0201-12230-12230-1200-00010-00010-00000-LEVEL\n//T1X20    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX20\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX20    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX20\n./ ADD NAME=AIEX21   0201-12230-12230-1200-00010-00010-00000-LEVEL\n//T1X21    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX21\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX21    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX21\n./ ADD NAME=AIEX21M  0201-12230-12230-1200-00010-00010-00000-LEVEL\n//T121M   JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX21M\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX21M   EXEC ASMALGF,PROJECT=ALGOLF,M=IEX21M\n./ ADD NAME=AIEX30   0201-12230-12230-1200-00010-00010-00000-LEVEL\n//T1X30    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX30\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX30    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX30\n./ ADD NAME=AIEX31   0201-12230-12230-1200-00010-00010-00000-LEVEL\n//T1X31    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX31\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX31    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX31\n./ ADD NAME=AIEX31M  0201-12230-12230-1200-00010-00010-00000-LEVEL\n//T131M   JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX31M\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX31M   EXEC ASMALGF,PROJECT=ALGOLF,M=IEX31M\n./ ADD NAME=AIEX40   0201-12230-12230-1200-00010-00010-00000-LEVEL\n//T1X40    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX40\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX40    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX40\n./ ADD NAME=AIEX50   0201-12230-12230-1200-00010-00010-00000-LEVEL\n//T1X50    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F COMPILER MODULE IEX50\n//*\n//*********************************************************************\n//*\n//IEX50    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX50\n//\n./ ADD NAME=AIEX51   0201-12230-12230-1200-00010-00010-00000-LEVEL\n//T1X51    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX51\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX51    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX51\n./ ADD NAME=AIEX51M  0201-12230-12230-1200-00010-00010-00000-LEVEL\n//T151M   JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX51M\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX51M   EXEC ASMALGF,PROJECT=ALGOLF,M=IEX51M\n./ ADD NAME=AIHIERM  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1ERM   JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIERM\n//*\n//*********************************************************************\n//*\n//IHIERM   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIERM\n./ ADD NAME=AIHIERR  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1ERR   JOB ALGOLF,TJA1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIERR\n//*\n//*********************************************************************\n//*\n//IHIERR   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIERR\n./ ADD NAME=AIHIFDD  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1FDD   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIFDD\n//*\n//*********************************************************************\n//*\n//IHIFDD   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIFDD\n./ ADD NAME=AIHIFDI  0201-12230-12230-1200-00008-00008-00000-LEVEL\n//T1FDI   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIFDI\n//*\n//*********************************************************************\n//IHIFDI   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIFDI\n./ ADD NAME=AIHIFII  0201-12230-12230-1200-00008-00008-00000-LEVEL\n//T1FII   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIFII\n//*\n//*********************************************************************\n//IHIFII   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIFII\n./ ADD NAME=AIHIFRI  0201-12230-12230-1200-00008-00008-00000-LEVEL\n//T1FRI   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIFRI\n//*\n//*********************************************************************\n//IHIFRI   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIFRI\n./ ADD NAME=AIHIFRR  0201-12230-12230-1200-00008-00008-00000-LEVEL\n//T1FRR   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIFRR\n//*\n//*********************************************************************\n//IHIFRR   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIFRR\n./ ADD NAME=AIHIFSA  0201-12230-12230-1200-00008-00008-00000-LEVEL\n//T1FSA    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIFSA\n//*\n//*********************************************************************\n//IHIFSA   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIFSA\n./ ADD NAME=AIHIGPR  0201-12230-12230-1200-00008-00008-00000-LEVEL\n//T1GPR   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F LIBRARY MODULE IHIGPR\n//*\n//*********************************************************************\n//IHIGPR   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIGPR\n./ ADD NAME=AIHIIAR  0201-12230-12230-1200-00008-00008-00000-LEVEL\n//T1IAR   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIIAR\n//*\n//*********************************************************************\n//IHIIAR   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIIAR\n./ ADD NAME=AIHIIBA  0201-12230-12230-1200-00008-00008-00000-LEVEL\n//T1IBA   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIIBA\n//*\n//*********************************************************************\n//IHIIBA   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIIBA\n./ ADD NAME=AIHIIBO  0201-12230-12230-1200-00008-00008-00000-LEVEL\n//T1IBO   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIIBO\n//*\n//*********************************************************************\n//IHIIBO   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIIBO\n./ ADD NAME=AIHIIDE  0201-12230-12230-1200-00008-00008-00000-LEVEL\n//T1IDE   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIIDE\n//*\n//*********************************************************************\n//IHIIDE   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIIDE\n./ ADD NAME=AIHIIOR  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1IOR   JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIIOR\n//*\n//*********************************************************************\n//*\n//IHIIOR   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIIOR\n./ ADD NAME=AIHIISY  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1ISY   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIISY\n//*\n//*********************************************************************\n//*\n//IHIISY   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIISY\n./ ADD NAME=AIHILAT  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1LAT   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHILAT\n//*\n//*********************************************************************\n//*\n//IHILAT   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHILAT\n./ ADD NAME=AIHILEX  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1LEX   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHILEX\n//*\n//*********************************************************************\n//*\n//IHILEX   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHILEX\n./ ADD NAME=AIHILLO  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1LLO   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHILLO\n//*\n//*********************************************************************\n//*\n//IHILLO   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHILLO\n./ ADD NAME=AIHILOR  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1LOR   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHILOR\n//*\n//*********************************************************************\n//*\n//IHILOR   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHILOR\n./ ADD NAME=AIHILSC  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1LSC   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHILSC\n//*\n//*********************************************************************\n//*\n//IHILSC   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHILSC\n./ ADD NAME=AIHILSQ  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1LSQ   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHILSQ\n//*\n//*********************************************************************\n//*\n//IHILSQ   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHILSQ\n./ ADD NAME=AIHIOAR  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1OAR   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIOAR\n//*\n//*********************************************************************\n//*\n//IHIOAR   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIOAR\n./ ADD NAME=AIHIOBA  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1OBA   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIOBA\n//*\n//*********************************************************************\n//*\n//IHIOBA   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIOBA\n./ ADD NAME=AIHIOBO  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1OBO   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIOBO\n//*\n//*********************************************************************\n//*\n//IHIOBO   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIOBO\n./ ADD NAME=AIHIOIN  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1OIN   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIOIN\n//*\n//*********************************************************************\n//*\n//IHIOIN   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIOIN\n./ ADD NAME=AIHIOST  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1OST    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIOST\n//*\n//*********************************************************************\n//*\n//IHIOST   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIOST\n./ ADD NAME=AIHIOSY  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1OSY   JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIOSY\n//*\n//*********************************************************************\n//*\n//IHIOSY   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIOSY\n./ ADD NAME=AIHIOTA  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1OTA   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIOTA\n//*\n//*********************************************************************\n//*\n//IHIOTA   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIOTA\n./ ADD NAME=AIHIPTT  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1PTT   JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIPTT\n//*\n//*********************************************************************\n//*\n//IHIPTT   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIPTT\n./ ADD NAME=AIHISAT  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1SAT   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHISAT\n//*\n//*********************************************************************\n//*\n//IHISAT   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHISAT\n./ ADD NAME=AIHISEX  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1SEX   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHISEX\n//*\n//*********************************************************************\n//*\n//IHISEX   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHISEX\n./ ADD NAME=AIHISLO  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1SLO   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHISLO\n//*\n//*********************************************************************\n//*\n//IHISLO   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHISLO\n./ ADD NAME=AIHISOR  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1SOR   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHISOR\n//*\n//*********************************************************************\n//*\n//IHISOR   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHISOR\n./ ADD NAME=AIHISSC  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1SSC   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHISSC\n//*\n//*********************************************************************\n//*\n//IHISSC   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHISSC\n./ ADD NAME=AIHISSQ  0201-12230-12230-1200-00009-00009-00000-LEVEL\n//T1SSQ   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHISSQ\n//*\n//*********************************************************************\n//*\n//IHISSQ   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHISSQ\n./ ADD NAME=AIHISYS  0201-12230-12230-1200-00008-00008-00000-LEVEL\n//T1SYS    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHISYS\n//*\n//*********************************************************************\n//IHISYS   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHISYS\n./ ADD NAME=AOPTION  0201-12230-12230-1200-00010-00010-00000-LEVEL\n//T1OPT    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER OPTIONS MODULE\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//OPTIONS  EXEC ASMALGF,PROJECT=ALGOLF,M=OPTIONS\n./ ADD NAME=BLDCALL  0201-12230-12230-1200-00194-00194-00000-LEVEL\n//T1ALL    JOB ALGOL,T1,CLASS=S,MSGCLASS=Z\n//*\n//*********************************************************************\n//*                                                                   *\n//*       SUBMIT JOBSTREAM TO ASSEMBLE AND LINK THE ALGOL F COMPILER  *\n//*                                                                   *\n//*********************************************************************\n//*\n//SUBMIT  EXEC PGM=IEBGENER\n//SYSPRINT DD  DUMMY\n//SYSIN    DD  DUMMY\n//*\n//*         ALLOCOBJ MUST BE FIRST TO RE-CREATE THE OBJECT DATASET\n//*\n//SYSUT1   DD  DATA,DLM='ZZ'\n//T1OBJ   JOB ALGOLF,T1,CLASS=S,MSGCLASS=Z\n//*\n//*********************************************************************\n//*\n//*   ALLOCATE THE OBJECT LIBRARY FOR THE ALGOL F COMPILER\n//*\n//*********************************************************************\n//*\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD DUMMY\n//DEV000    DD UNIT=3350,VOL=SER=DEV000,DISP=SHR\n//SYSIN     DD *\n SCRATCH DSNAME=SYSD.ALGOLF.OBJ,VOL=3350=DEV000\n UNCATLG DSNAME=SYSD.ALGOLF.OBJ\n/*\n//ALLOC    EXEC PGM=IEFBR14\n//OBJ       DD DSN=SYSD.ALGOLF.OBJ,\n//             UNIT=3350,VOL=SER=DEV000,\n//             SPACE=(CYL,(5,5,5)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//             DISP=(,CATLG)\n//\n//T1OPT    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER OPTIONS MODULE\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//OPTIONS  EXEC ASMALGF,PROJECT=ALGOLF,M=OPTIONS,SOUT='A'\n//\n//T1X00    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX00\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX00    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX00,SOUT='A'\n//\n//T1X10    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX10\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX10    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX10,SOUT='A'\n//\n//T1X11    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX11\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX11    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX11,SOUT='A'\n//\n//T1X20    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX20\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX20    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX20,SOUT='A'\n//\n//T1X21    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX21\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX21    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX21,SOUT='A'\n//\n//T121M   JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX21M\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX21M   EXEC ASMALGF,PROJECT=ALGOLF,M=IEX21M,SOUT='A'\n//\n//T1X30    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX30\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX30    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX30,SOUT='A'\n//\n//T1X31    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX31\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX31    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX31,SOUT='A'\n//\n//T131M   JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX31M\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX31M   EXEC ASMALGF,PROJECT=ALGOLF,M=IEX31M,SOUT='A'\n//\n//T1X40    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX40\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX40    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX40,SOUT='A'\n//\n//T1X50    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F COMPILER MODULE IEX50\n//*\n//*********************************************************************\n//*\n//IEX50    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX50,SOUT='A'\n//\n//T1X51    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX51\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX51    EXEC ASMALGF,PROJECT=ALGOLF,M=IEX51,SOUT='A'\n//\n//T151M   JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        ASSEMBLE ALGOL F COMPILER MODULE IEX51M\n//*\n//*********************************************************************\n//*\n//*********************************************************************\n//IEX51M   EXEC ASMALGF,PROJECT=ALGOLF,M=IEX51M,SOUT='A'\n//\nZZ\n//SYSUT2   DD  SYSOUT=(A,INTRDR),\n//             DCB=(RECFM=F,BLKSIZE=80,LRECL=80)\n//\n./ ADD NAME=BLDRTALL 0201-12230-12230-1200-00352-00352-00000-LEVEL\n//T1ALL    JOB ALGOL,T1,CLASS=S,MSGCLASS=Z\n//*\n//*********************************************************************\n//*                                                                   *\n//*       SUBMIT JOBSTREAM TO ASSEMBLE AND LINK THE ALGOL F           *\n//*              RESIDENT LIBRARY                                     *\n//*                                                                   *\n//*********************************************************************\n//*\n//SUBMIT  EXEC PGM=IEBGENER\n//SYSPRINT DD  DUMMY\n//SYSIN    DD  DUMMY\n//SYSUT1   DD  DATA,DLM='ZZ'\n//T1OBJ   JOB ALGOLF,T1,CLASS=S,MSGCLASS=Z\n//*\n//*********************************************************************\n//*\n//*   ALLOCATE THE OBJECT LIBRARY FOR THE ALGOL F RESIDENT LIBRARY\n//*\n//*********************************************************************\n//*\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD DUMMY\n//DEV000    DD UNIT=3350,VOL=SER=DEV000,DISP=SHR\n//SYSIN     DD *\n SCRATCH DSNAME=SYSD.ALGOLFRT.OBJ,VOL=3350=DEV000\n UNCATLG DSNAME=SYSD.ALGOLFRT.OBJ\n/*\n//ALLOC    EXEC PGM=IEFBR14\n//OBJ       DD DSN=SYSD.ALGOLFRT.OBJ,\n//             UNIT=3350,VOL=SER=DEV000,\n//             SPACE=(CYL,(2,1,5)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//             DISP=(,CATLG)\n//\n//T1BLD   JOB ALGOLF,T1,CLASS=S,MSGCLASS=Z\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIERM\n//*\n//*********************************************************************\n//*\n//IHIERM   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIERM,SOUT='A'\n//*1ERR   JOB ALGOLF,TJA1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIERR\n//*\n//*********************************************************************\n//*\n//IHIERR   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIERR,SOUT='A'\n//*1FDD   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIFDD\n//*\n//*********************************************************************\n//*\n//IHIFDD   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIFDD,SOUT='A'\n//*1FDI   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIFDI\n//*\n//*********************************************************************\n//IHIFDI   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIFDI,SOUT='A'\n//*1FII   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIFII\n//*\n//*********************************************************************\n//IHIFII   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIFII,SOUT='A'\n//*1FRI   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIFRI\n//*\n//*********************************************************************\n//IHIFRI   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIFRI,SOUT='A'\n//*1FRR   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIFRR\n//*\n//*********************************************************************\n//IHIFRR   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIFRR,SOUT='A'\n//*1FSA    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIFSA\n//*\n//*********************************************************************\n//IHIFSA   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIFSA,SOUT='A'\n//*1GPR   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F LIBRARY MODULE IHIGPR\n//*\n//*********************************************************************\n//IHIGPR   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIGPR,SOUT='A'\n//*1IAR   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIIAR\n//*\n//*********************************************************************\n//IHIIAR   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIIAR,SOUT='A'\n//*1IBA   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIIBA\n//*\n//*********************************************************************\n//IHIIBA   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIIBA,SOUT='A'\n//*1IBO   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIIBO\n//*\n//*********************************************************************\n//IHIIBO   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIIBO,SOUT='A'\n//*1IDE   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIIDE\n//*\n//*********************************************************************\n//IHIIDE   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIIDE,SOUT='A'\n//*1IOR   JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIIOR\n//*\n//*********************************************************************\n//*\n//IHIIOR   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIIOR,SOUT='A'\n//*1ISY   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIISY\n//*\n//*********************************************************************\n//*\n//IHIISY   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIISY,SOUT='A'\n//*1LAT   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHILAT\n//*\n//*********************************************************************\n//*\n//IHILAT   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHILAT,SOUT='A'\n//*1LEX   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHILEX\n//*\n//*********************************************************************\n//*\n//IHILEX   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHILEX,SOUT='A'\n//*1LLO   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHILLO\n//*\n//*********************************************************************\n//*\n//IHILLO   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHILLO,SOUT='A'\n//*1LOR   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHILOR\n//*\n//*********************************************************************\n//*\n//IHILOR   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHILOR,SOUT='A'\n//*1LSC   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHILSC\n//*\n//*********************************************************************\n//*\n//IHILSC   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHILSC,SOUT='A'\n//*1LSQ   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHILSQ\n//*\n//*********************************************************************\n//*\n//IHILSQ   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHILSQ,SOUT='A'\n//*1OAR   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIOAR\n//*\n//*********************************************************************\n//*\n//IHIOAR   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIOAR,SOUT='A'\n//*1OBA   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIOBA\n//*\n//*********************************************************************\n//*\n//IHIOBA   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIOBA,SOUT='A'\n//*1OBO   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIOBO\n//*\n//*********************************************************************\n//*\n//IHIOBO   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIOBO,SOUT='A'\n//*1OIN   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIOIN\n//*\n//*********************************************************************\n//*\n//IHIOIN   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIOIN,SOUT='A'\n//*1OST    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIOST\n//*\n//*********************************************************************\n//*\n//IHIOST   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIOST,SOUT='A'\n//*1OSY   JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIOSY\n//*\n//*********************************************************************\n//*\n//IHIOSY   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIOSY,SOUT='A'\n//*1OTA   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIOTA\n//*\n//*********************************************************************\n//*\n//IHIOTA   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIOTA,SOUT='A'\n//*1PTT   JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHIPTT\n//*\n//*********************************************************************\n//*\n//IHIPTT   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHIPTT,SOUT='A'\n//*1SAT   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHISAT\n//*\n//*********************************************************************\n//*\n//IHISAT   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHISAT,SOUT='A'\n//*1SEX   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHISEX\n//*\n//*********************************************************************\n//*\n//IHISEX   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHISEX,SOUT='A'\n//*1SLO   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHISLO\n//*\n//*********************************************************************\n//*\n//IHISLO   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHISLO,SOUT='A'\n//*1SOR   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHISOR\n//*\n//*********************************************************************\n//*\n//IHISOR   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHISOR,SOUT='A'\n//*1SSC   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHISSC\n//*\n//*********************************************************************\n//*\n//IHISSC   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHISSC,SOUT='A'\n//*1SSQ   JOB ALGOLFRT,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHISSQ\n//*\n//*********************************************************************\n//*\n//IHISSQ   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHISSQ,SOUT='A'\n//*1SYS    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        BUILD ALGOL F RUN TIME LIBRARY MODULE IHISYS\n//*\n//*********************************************************************\n//IHISYS   EXEC ASMXC,PROJECT=ALGOLFRT,M=IHISYS,SOUT='A'\nZZ\n//SYSUT2   DD  SYSOUT=(A,INTRDR),\n//             DCB=(RECFM=F,BLKSIZE=80,LRECL=80)\n//\n./ ADD NAME=LINKC    0201-12230-12230-1200-00110-00110-00000-LEVEL\n//T1LNK    JOB ALGOLF,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*\n//*        DELETE THE LOAD LIBRARY FOR THE ALGOL F COMPILER\n//*\n//*********************************************************************\n//*\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD DUMMY\n//DEV000    DD UNIT=3350,VOL=SER=DEV000,DISP=OLD\n//SYSIN     DD *\n       SCRATCH DSNAME=SYSD.ALGOLF.LOADLIB,VOL=3350=DEV000\n       UNCATLG DSNAME=SYSD.ALGOLF.LOADLIB\n/*\n//*\n//********************************************************************\n//*\n//*        GENERATE LINKAGE EDITOR BANNER\n//*\n//********************************************************************\n//*\n//GENER   EXEC PGM=IEBGENER\n//SYSPRINT  DD DUMMY\n//SYSIN     DD DUMMY\n//SYSUT2    DD SYSOUT=A,DCB=(RECFM=FA,BLKSIZE=80,LRECL=80)\n//SYSUT1    DD *\n1\\\\\\LINKEDITRELEASELVL2.1LINK EDIT ALGOL F COMPILER\n/*\n//*\n//*********************************************************************\n//*\n//*        LINK EDIT ALGOL F COMPILER\n//*\n//*********************************************************************\n//*\n//ALGOLF  EXEC PGM=IEWL,PARM='LIST,LET,MAP,NCAL',REGION=1024K\n//SYSPRINT DD  SYSOUT=A\n//SYSUT1   DD  UNIT=VIO,SPACE=(TRK,(30,10))\n//OBJECT   DD  DSN=SYSD.ALGOLF.OBJ,DISP=SHR\n//SYSLMOD  DD  DSN=SYSD.ALGOLF.LOADLIB,\n//             UNIT=3350,VOL=SER=DEV000,\n//             SPACE=(CYL,(3,5,5)),\n//             DISP=(,CATLG)\n//SYSLIN   DD  *\n         INCLUDE OBJECT(OPTIONS)\n         INCLUDE OBJECT(IEX00)\n         ENTRY   IEX00000\n         ALIAS   ALGOL\n         IDENTIFY IEX00000('360SAL531 V02 M01 ALGOL F COMPILER')\n         IDENTIFY IEX00001('360SAL531 V02 M01 ALGOL F COMPILER')\n         NAME    IEX00(R)\n         INCLUDE OBJECT(IEX10)\n         ALIAS   IEX10000\n         ENTRY   IEX10000\n         IDENTIFY IEX10000('360SAL531 V02 M01 ALGOL F COMPILER')\n         IDENTIFY IEX10001('360SAL531 V02 M01 ALGOL F COMPILER')\n         NAME    IEX10(R)\n         INCLUDE OBJECT(IEX11)\n         ALIAS   IEX11000\n         ENTRY   IEX11000\n         IDENTIFY IEX11000('360SAL531 V02 M01 ALGOL F COMPILER')\n         NAME    IEX11(R)\n         INCLUDE OBJECT(IEX20)\n         ALIAS   IEX20000\n         ENTRY   IEX20000\n         IDENTIFY IEX20000('360SAL531 V02 M01 ALGOL F COMPILER')\n         NAME    IEX20(R)\n         INCLUDE OBJECT(IEX21)\n         INCLUDE OBJECT(IEX21M)\n         ENTRY   IEX21000\n         ALIAS   IEX21000\n         IDENTIFY IEX21000('360SAL531 V02 M01 ALGOL F COMPILER')\n         IDENTIFY IEX21M00('360SAL531 V02 M01 ALGOL F COMPILER')\n         IDENTIFY IEX60000('360SAL531 V02 M01 ALGOL F COMPILER')\n         NAME    IEX21(R)\n         INCLUDE OBJECT(IEX30)\n         ALIAS   IEX30000\n         ENTRY   IEX30000\n         IDENTIFY IEX30000('360SAL531 V02 M01 ALGOL F COMPILER')\n         NAME    IEX30(R)\n         INCLUDE OBJECT(IEX31)\n         INCLUDE OBJECT(IEX31M)\n         ENTRY   IEX31000\n         ALIAS   IEX31000\n         IDENTIFY IEX31000('360SAL531 V02 M01 ALGOL F COMPILER')\n         IDENTIFY IEX31M00('360SAL531 V02 M01 ALGOL F COMPILER')\n         IDENTIFY IEX60000('360SAL531 V02 M01 ALGOL F COMPILER')\n         NAME    IEX31(R)\n         INCLUDE OBJECT(IEX40)\n         ALIAS   IEX40000\n         ENTRY   IEX40000\n         IDENTIFY IEX40000('360SAL531 V02 M01 ALGOL F COMPILER')\n         NAME    IEX40(R)\n         INCLUDE OBJECT(IEX50)\n         ALIAS   IEX50000\n         ENTRY   IEX50000\n         IDENTIFY IEX50000('360SAL531 V02 M01 ALGOL F COMPILER')\n         NAME    IEX50(R)\n         INCLUDE OBJECT(IEX51)\n         INCLUDE OBJECT(IEX51M)\n         ENTRY   IEX51000\n         ALIAS   IEX51000,IEX51002,IEX51ER1,IEX51ER2\n         IDENTIFY IEX51000('360SAL531 V02 M01 ALGOL F COMPILER')\n         IDENTIFY IEX51002('360SAL531 V02 M01 ALGOL F COMPILER')\n         IDENTIFY IEX51M00('360SAL531 V02 M01 ALGOL F COMPILER')\n         IDENTIFY IEX60000('360SAL531 V02 M01 ALGOL F COMPILER')\n         NAME    IEX51(R)\n/*\n//\n./ ADD NAME=LINKRT   0201-12230-12230-1200-00192-00192-00000-LEVEL\n//T1RTL    JOB ALGOL,T1,CLASS=S,MSGCLASS=C\n//*\n//*********************************************************************\n//*                                                                   *\n//*        ALLOCATE THE LOAD LIBRARY FOR THE ALGOL F RUN TIME LIBRARY *\n//*                                                                   *\n//*********************************************************************\n//*\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD DUMMY\n//DEV000    DD UNIT=3350,VOL=SER=DEV000,DISP=SHR\n//SYSIN     DD *\n        SCRATCH DSNAME=SYSD.ALGOLFRT.LOADLIB,VOL=3350=DEV000\n        UNCATLG DSNAME=SYSD.ALGOLFRT.LOADLIB\n//*\n//*\n//********************************************************************\n//*\n//*        GENERATE LINKAGE EDITOR BANNER\n//*\n//********************************************************************\n//*\n//GENER   EXEC PGM=IEBGENER\n//SYSPRINT  DD DUMMY\n//SYSIN     DD DUMMY\n//SYSUT2    DD SYSOUT=A,DCB=(RECFM=FA,BLKSIZE=80,LRECL=80)\n//SYSUT1    DD *\n1\\\\\\LINKEDITRELEASELVL2.1LINK EDIT ALGOL F LIBRARY\n/*\n//*\n//*********************************************************************\n//*\n//*        LINK EDIT ALGOL F RUN TIME LIBRARY\n//*\n//*********************************************************************\n//*\n//ALGOLRT EXEC PGM=IEWL,PARM='LIST,LET,MAP,NCAL',REGION=1024K\n//SYSPRINT DD  SYSOUT=A\n//SYSUT1   DD  UNIT=VIO,SPACE=(TRK,(30,10))\n//OBJECT   DD  DSN=SYSD.ALGOLFRT.OBJ,DISP=SHR\n//SYSLMOD  DD  DSN=SYSD.ALGOLFRT.LOADLIB,\n//             UNIT=3350,VOL=SER=DEV000,\n//             SPACE=(CYL,(3,5,32)),\n//             DISP=(,CATLG)\n//SYSLIN   DD  *\n         INCLUDE  OBJECT(IHIERR)\n         INCLUDE  OBJECT(IHIERM)\n         IDENTIFY IHIERROR('360SLM532 V02 M01 ALGOL F LIBRARY')\n         IDENTIFY IHIERMSG('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ENTRY    IHIERROR\n         ALIAS    IHIERROR\n         NAME     IHIERR(R)             LOADED DYNAMICALLY FROM LINKLIB\n         INCLUDE  OBJECT(IHIFDD)\n         IDENTIFY IHIFDDXP('360SLM532 V02 M01 ALGOL F LIBRARY')\n         NAME     IHIFDD(R)\n         INCLUDE  OBJECT(IHIFDI)\n         IDENTIFY IHIFDIXP('360SLM532 V02 M01 ALGOL F LIBRARY')\n         NAME     IHIFDI(R)\n         INCLUDE  OBJECT(IHIFII)\n         IDENTIFY IHIFIIXP('360SLM532 V02 M01 ALGOL F LIBRARY')\n         NAME     IHIFII(R)\n         INCLUDE  OBJECT(IHIFRI)\n         IDENTIFY IHIFRIXP('360SLM532 V02 M01 ALGOL F LIBRARY')\n         NAME     IHIFRI(R)\n         INCLUDE  OBJECT(IHIFRR)\n         IDENTIFY IHIFRRXP('360SLM532 V02 M01 ALGOL F LIBRARY')\n         NAME     IHIFRR(R)\n         INCLUDE  OBJECT(IHIFSA)\n         IDENTIFY IHIFSARA('360SLM532 V02 M01 ALGOL F LIBRARY')\n         IDENTIFY IHIFSARB('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHIFSAIN\n         NAME     IHIFSA(R)\n         INCLUDE  OBJECT(IHIGPR)\n         IDENTIFY IHIGPRTN('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHIGPRCL\n         ALIAS    IHIGPRGT\n         ALIAS    IHIGPRPT\n         NAME     IHIGPR(R)\n         INCLUDE  OBJECT(IHIIAR)\n         IDENTIFY IHIIARTN('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHIIARRT\n         ALIAS    IHIIARRY\n         NAME     IHIIAR(R)\n         INCLUDE  OBJECT(IHIIBA)\n         IDENTIFY IHIIBARR('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHIIBARR\n         NAME     IHIIBA(R)\n         INCLUDE  OBJECT(IHIIBO)\n         IDENTIFY IHIIBOOL('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHIIBOAR\n         ALIAS    IHIIBOOL\n         NAME     IHIIBO(R)\n         INCLUDE  OBJECT(IHIIDE)\n         IDENTIFY IHIIDECM('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHIIDEAI\n         ALIAS    IHIIDEII\n         ALIAS    IHIIDEIR\n         NAME     IHIIDE(R)\n         INCLUDE  OBJECT(IHIIOR)\n         IDENTIFY IHIIORTN('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHIIOREN\n         ALIAS    IHIIOREV\n         ALIAS    IHIIORNX\n         ALIAS    IHIIOROP\n         NAME     IHIIOR(R)\n         INCLUDE  OBJECT(IHIISY)\n         IDENTIFY IHIISYMB('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHIISYMB\n         NAME     IHIISY(R)\n         INCLUDE  OBJECT(IHILAT)\n         IDENTIFY IHILATAN('360SLM532 V02 M01 ALGOL F LIBRARY')\n         NAME     IHILAT(R)\n         INCLUDE  OBJECT(IHILEX)\n         IDENTIFY IHILEXPT('360SLM532 V02 M01 ALGOL F LIBRARY')\n         NAME     IHILEX(R)\n         INCLUDE  OBJECT(IHILLO)\n         IDENTIFY IHILLOGM('360SLM532 V02 M01 ALGOL F LIBRARY')\n         NAME     IHILLO(R)\n         INCLUDE  OBJECT(IHILOR)\n         IDENTIFY IHILOREA('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHILORAR\n         ALIAS    IHILOREL\n         NAME     IHILOR(R)\n         INCLUDE  OBJECT(IHILSC)\n         IDENTIFY IHILSCSN('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHILSCC\n         ALIAS    IHILSCS\n         NAME     IHILSC(R)\n         INCLUDE  OBJECT(IHILSQ)\n         IDENTIFY IHILSQRT('360SLM532 V02 M01 ALGOL F LIBRARY')\n         NAME     IHILSQ(R)\n         INCLUDE  OBJECT(IHIOAR)\n         IDENTIFY IHIOARRY('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHIOARRY\n         NAME     IHIOAR(R)\n         INCLUDE  OBJECT(IHIOBA)\n         IDENTIFY IHIOBARR('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHIOBARR\n         NAME     IHIOAR(R)\n         INCLUDE  OBJECT(IHIOBO)\n         IDENTIFY IHIOBOOL('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHIOBOAR\n         ALIAS    IHIOBOOL\n         NAME     IHIOBO(R)\n         INCLUDE  OBJECT(IHIOIN)\n         IDENTIFY IHIOINTE('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHIOINAR\n         ALIAS    IHIOINTG\n         NAME     IHIOIN(R)\n         INCLUDE  OBJECT(IHIOST)\n         IDENTIFY IHIOSTRG('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHIOSTRG\n         NAME     IHIOST(R)\n         INCLUDE  OBJECT(IHIOSY)\n         IDENTIFY IHIOSYMB('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHIOSYMB\n         NAME     IHIOSY(R)\n         INCLUDE  OBJECT(IHIOTA)\n         IDENTIFY IHIOTARR('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHIOTARR\n         NAME     IHIOTA(R)\n         INCLUDE  OBJECT(IHIPTT)\n         IDENTIFY IHIPTTAB('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHIPTTAB\n         NAME     IHIPTT(R)\n         INCLUDE  OBJECT(IHISAT)\n         IDENTIFY IHISATAN('360SLM532 V02 M01 ALGOL F LIBRARY')\n         NAME     IHISAT(R)\n         INCLUDE  OBJECT(IHISEX)\n         IDENTIFY IHISEXPT('360SLM532 V02 M01 ALGOL F LIBRARY')\n         NAME     IHISEX(R)\n         INCLUDE  OBJECT(IHISLO)\n         NAME     IHISLO(R)\n         INCLUDE  OBJECT(IHISOR)\n         IDENTIFY IHISOREA('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHISORAR\n         ALIAS    IHISOREL\n         NAME     IHISOR(R)\n         INCLUDE  OBJECT(IHISSC)\n         IDENTIFY IHISSCSN('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHISSCS\n         ALIAS    IHISSCC\n         NAME     IHISSC(R)\n         INCLUDE  OBJECT(IHISSQ)\n         IDENTIFY IHISSQRT('360SLM532 V02 M01 ALGOL F LIBRARY')\n         NAME     IHISSQ(R)\n         INCLUDE  OBJECT(IHISYS)\n         IDENTIFY IHISYSCT('360SLM532 V02 M01 ALGOL F LIBRARY')\n         ALIAS    IHISYSCT\n         NAME     IHISYS(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AL21SMAC": {"ttr": 62214, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x01\\x12$\\x8f\\x01\\x12$\\x8f\\x135\\x04\\xcf\\x04\\xcf\\x00\\x00\\xc3\\xd6\\xd4\\xd7\\xd4\\xc1\\xc3@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "2012-09-04T00:00:00", "modifydate": "2012-09-04T13:35:00", "lines": 1231, "newlines": 1231, "modlines": 0, "user": "COMPMAC"}, "text": "./ ADD NAME=ALGOL    0201-12230-12230-1200-00056-00056-00000-LEVEL\n         MACRO\n         ALGOL &PUNCH=NODECK,&TYPERUN=LOAD,&SORCODE=EBCDIC,            C\n               &SORLIST=SOURCE,                                        C\n               &SIZE=45056,&PRECISN=SHORT\n.*\n.*       COMPONENT ID - 360S-AL-531 ALGOL F COMPILER\n.*\n.*       SYSTEM GENERATION OPTIONS MACRO FOR THE COMPILER\n.*\n         GBLB  &SGALGOB(5)\n         GBLA  &SGALGOA(1)\n.*\n         AIF  ('&PUNCH' NE 'NODECK' AND '&PUNCH' NE 'DECK').E2\n         MNOTE *,'   PUNCH OPTION IS &PUNCH'\n&SGALGOB(1)  SETB  ('&PUNCH' EQ 'NODECK')\n.A2      ANOP\n         AIF ('&TYPERUN' NE 'LOAD' AND '&TYPERUN' NE 'NOLOAD').E3\n         MNOTE *,'   TYPERUN OPTION IS &TYPERUN'\n&SGALGOB(2)  SETB  ('&TYPERUN' EQ 'NOLOAD')\n.A3      ANOP\n         AIF ('&SORCODE' NE 'EBCDIC' AND '&SORCODE' NE 'ISO').E4\n         MNOTE *,'   SORCODE OPTION IS &SORCODE'\n&SGALGOB(3)  SETB  ('&SORCODE' EQ 'ISO')\n.A4      ANOP\n         AIF ('&SORLIST' NE 'SOURCE' AND '&SORLIST' NE 'NOSOURCE').E5\n         MNOTE *,'   SORLIST OPTION IS &SORLIST'\n&SGALGOB(4)  SETB  ('&SORLIST' EQ 'NOSOURCE')\n.A5      ANOP\n         AIF (&SIZE LT 45056 OR &SIZE GT 999999 OR T'&SIZE NE 'N').E6\n         MNOTE *,'   SIZE SPECIFIED IS &SIZE BYTES OF MAIN STORAGE'\n&SGALGOA(1)  SETA  &SIZE\n.A6      ANOP\n         AIF ('&PRECISN' NE 'SHORT' AND '&PRECISN' NE 'LONG').E7\n         MNOTE *,'   PRECISN OPTION IS &PRECISN'\n&SGALGOB(5)  SETB  ('&PRECISN' EQ 'LONG')\n.A7      ANOP\n         MEXIT\n.E2      MNOTE 8,'* * * IEIALG102 PUNCH VALUE &PUNCH INVALID'\n.*\n         AGO   .A2\n.E3      MNOTE 8,'* * * IEIALG103 TYPERUN VALUE &TYPERUN INVALID'\n.*\n         AGO   .A3\n.E4      MNOTE 8,'* * * IEIALG104 SORCODE VALUE &SORCODE INVALID'\n.*\n         AGO   .A4\n.E5      MNOTE 8,'* * * IEIALG105 SORLIST VALUE &SORLIST INVALID'\n.*\n         AGO   .A5\n.E6      MNOTE 8,'* * * IEIALG106 SIZE VALUE &SIZE INVALID'\n.*\n         AGO   .A6\n.E7      MNOTE 8,'* * * IEIALG107 PRECISN VALUE &PRECISN INVALID'\n.*\n         AGO   .A7\n         MEND\n./ ADD NAME=IEXCGEN  0201-12230-12230-1200-00345-00345-00000-LEVEL\n         MACRO\n&LABEL   IEXCGEN &GENTYPE,&STRING\n.*\n.*       COMPONENT ID - 360S-AL-531 ALGOL F COMPILER\n.*\n.*       LEVEL 2.1 -\n.*       THIS IS A NEW MACRO REQUIRED AS PART OF THE\n.*       REFURBISHMENT OF THE LAST IBM RELEASE OF\n.*       THE ALGOL F COMPILER\n.*\n.*\n.*       FUNCTION -\n.*       IEXCGEN CONVERTS THE EBCDIC STRING PROVIDED IN THE\n.*       &STRING PARAMETER INTO THE INTERNAL CODE USED BY THE\n.*       ALGOL F COMPILER FOR SOURCE PROGRAM SCANNING\n.*\n.*       THE GENTYPE PARAMETER ACCEPTS EQU TO GENERATE THE\n.*       CONVERTED STRING AS AN EQUATE OR IT ACCEPTS DC TO\n.*       GENERATE THE CONVERTED STRING INTO A DC OF A HEX\n.*       STRING\n.*\n.*       NOTES -\n.*       1. THIS MACRO WAS DESIGNED TO EXECUTE IN THE\n.*          OS/360 ASSEMBLER IEUASM ENVIRONMENT SO THAT THE\n.*          ALGOL F SOURCE CODE CAN BE BUILT TO MATCH\n.*          THE OS/360 GENERATED ALGOL F OBJECT MODULES\n.*          USE OF THE VARIOUS ENHANCEMENTS PROVIDED BY\n.*          HLASM WAS THEREFORE PRECLUDED\n.*\n.*\n.*       DECLARE LCLS\n.*\n         LCLA  &I                      OUTER LOOP VARIABLE\n         LCLA  &J                      INNER LOOP VARIABLE\n         LCLA  &OUT                    OUTPUT CHAR POINTER\n         LCLA  &TABLEN                 NUMBER OF CHARS IN TRANSLATE TAB\n         LCLA  &STRLEN                 STRING LENGTH\n         LCLB  &SUPCHAR                FLAG TO SUPRESS NEXT SPEC CHAR\n         LCLC  &CEB(91)                TABLE OF EBCDIC CHARACTERS\n         LCLC  &CIC(91)                INTERNAL CODE EQUIVALENT OF\n.*                                     THE EBCDIC CHARACTER\n         LCLC  &X(40)                  RESULT OF TRANSLATION TO\n.*                                     INTERNAL CODE\n         LCLC  &BAD                    DISPLAY AN INVALID CHAR\n         AIF   ('&GENTYPE' EQ 'EQU').GENOK\n.*\n.*       VALIDATE GENTYPE\n.*\n         AIF   ('&GENTYPE' EQ 'DC').GENOK\n.*\n.*       GENTYPE INVALID\n.*\n         MNOTE 12,'ERROR - GENTYPE REQUESTED &GENTYPE NOT DC OR EQU'\n         AGO   .EXIT\n.*\n.*       VALIDATE STRING\n.*\n.GENOK   ANOP\n         AIF   ('&STRING' NE '').STROK1\n         MNOTE 12,'ERROR - NULL STRING FOR CONVERSION'\n         AGO   .EXIT\n.STROK1  ANOP\n&STRLEN  SETA  K'&STRING\n         AIF   ('&STRING'(1,1) EQ '''').STROK2\n         AIF   ('&STRING'(1,&STRLEN) EQ '''').STROK2\n         MNOTE 12,'ERROR - STRING NOT ENCLOSED IN QUOTES'\n         AGO   .EXIT\n.STROK2  ANOP\n.*\n.*       INITIALIZE STRINGS WITH EBCDIC CHAR AND TRANSLATED\n.*       ALGOL F INTERNAL HEX VALUE\n.*\n.*       CHARACTERS A - Z\n.*\n&CEB(1)  SETC  'A'\n&CIC(1)  SETC  '40'\n&CEB(2)  SETC  'B'\n&CIC(2)  SETC  '41'\n&CEB(3)  SETC  'C'\n&CIC(3)  SETC  '42'\n&CEB(4)  SETC  'D'\n&CIC(4)  SETC  '43'\n&CEB(5)  SETC  'E'\n&CIC(5)  SETC  '44'\n&CEB(6)  SETC  'F'\n&CIC(6)  SETC  '45'\n&CEB(7)  SETC  'G'\n&CIC(7)  SETC  '46'\n&CEB(8)  SETC  'H'\n&CIC(8)  SETC  '47'\n&CEB(9)  SETC  'I'\n&CIC(9)  SETC  '48'\n&CEB(10) SETC  'J'\n&CIC(10) SETC  '49'\n&CEB(11) SETC  'K'\n&CIC(11) SETC  '4A'\n&CEB(12) SETC  'L'\n&CIC(12) SETC  '4B'\n&CEB(13) SETC  'M'\n&CIC(13) SETC  '4C'\n&CEB(14) SETC  'N'\n&CIC(14) SETC  '4D'\n&CEB(15) SETC  'O'\n&CIC(15) SETC  '4E'\n&CEB(16) SETC  'P'\n&CIC(16) SETC  '4F'\n&CEB(17) SETC  'Q'\n&CIC(17) SETC  '50'\n&CEB(18) SETC  'R'\n&CIC(18) SETC  '51'\n&CEB(19) SETC  'S'\n&CIC(19) SETC  '52'\n&CEB(20) SETC  'T'\n&CIC(20) SETC  '53'\n&CEB(21) SETC  'U'\n&CIC(21) SETC  '54'\n&CEB(22) SETC  'V'\n&CIC(22) SETC  '55'\n&CEB(23) SETC  'W'\n&CIC(23) SETC  '56'\n&CEB(24) SETC  'X'\n&CIC(24) SETC  '57'\n&CEB(25) SETC  'Y'\n&CIC(25) SETC  '58'\n&CEB(26) SETC  'Z'\n&CIC(26) SETC  '59'\n&CEB(27) SETC  '~'                     UNRECOGNIZED CHAR\n&CIC(27) SETC  '2C'\n.*\n.*       NUMERIC 0 - 9\n.*\n&CEB(28) SETC  '0'\n&CIC(28) SETC  '30'\n&CEB(29) SETC  '1'\n&CIC(29) SETC  '31'\n&CEB(30) SETC  '2'\n&CIC(30) SETC  '32'\n&CEB(31) SETC  '3'\n&CIC(31) SETC  '33'\n&CEB(32) SETC  '4'\n&CIC(32) SETC  '34'\n&CEB(33) SETC  '5'\n&CIC(33) SETC  '35'\n&CEB(34) SETC  '6'\n&CIC(34) SETC  '36'\n&CEB(35) SETC  '7'\n&CIC(35) SETC  '37'\n&CEB(36) SETC  '8'\n&CIC(36) SETC  '38'\n&CEB(37) SETC  '9'\n&CIC(37) SETC  '39'\n.*\n.*       SPECIAL CHARS\n.*\n&CEB(38) SETC  ' '\n&CIC(38) SETC  '2B'\n&CEB(39) SETC  '.'\n&CIC(39) SETC  '2D'\n&CEB(40) SETC  '<'\n&CIC(40) SETC  '11'\n&CEB(41) SETC  '('\n&CIC(41) SETC  '06'\n&CEB(42) SETC  '+'\n&CIC(42) SETC  '00'\n&CEB(43) SETC  '|'\n&CIC(43) SETC  '22'\n&CEB(44) SETC  '&&'                    DO NOT CHANGE THIS CHARS POS\n&CIC(44) SETC  '23'                    IN THE TAB SEE LOOPS BELOW\n&CEB(45) SETC  '!'\n&CIC(45) SETC  '2C'                    ##\n&CEB(46) SETC  '$'\n&CIC(46) SETC  '5A'                    ##\n&CEB(47) SETC  '*'\n&CIC(47) SETC  '02'\n&CEB(48) SETC  ')'\n&CIC(48) SETC  '26'\n&CEB(49) SETC  ';'\n&CIC(49) SETC  '0B'\n&CEB(50) SETC  '\u00ac'\n&CIC(50) SETC  '20'\n&CEB(51) SETC  '-'\n&CIC(51) SETC  '01'\n&CEB(52) SETC  '/'\n&CIC(52) SETC  '03'\n&CEB(53) SETC  ','\n&CIC(53) SETC  '25'\n&CEB(54) SETC  '%'\n&CIC(54) SETC  '2C'\n&CEB(55) SETC  '_'\n&CIC(55) SETC  '5B'\n&CEB(56) SETC  '>'\n&CIC(56) SETC  '12'\n&CEB(57) SETC  '\u00dd'\n&CIC(57) SETC  '08'\n&CEB(58) SETC  ':'\n&CIC(58) SETC  '07'\n&CEB(59) SETC  '#'\n&CIC(59) SETC  '5C'\n&CEB(60) SETC  '@'\n&CIC(60) SETC  '5D'\n&CEB(61) SETC  ''''                    DO NOT CHANGE THIS CHARS POS\n&CIC(61) SETC  '2E'                    IN THE TAB SEE LOOPS BELOW\n&CEB(62) SETC  '='\n&CIC(62) SETC  '10'\n&CEB(63) SETC  '\"'\n&CIC(63) SETC  '0C'\n&CEB(64) SETC  '\u00a8'\n&CIC(64) SETC  '28'\n.*\n.*       LOWER CASE CHARACTERS A - Z\n.*\n&CEB(65) SETC  'a'\n&CIC(65) SETC  '40'\n&CEB(66) SETC  'b'\n&CIC(66) SETC  '41'\n&CEB(67) SETC  'c'\n&CIC(67) SETC  '42'\n&CEB(68) SETC  'd'\n&CIC(68) SETC  '43'\n&CEB(69) SETC  'e'\n&CIC(69) SETC  '44'\n&CEB(70) SETC  'f'\n&CIC(70) SETC  '45'\n&CEB(71) SETC  'g'\n&CIC(71) SETC  '46'\n&CEB(72) SETC  'h'\n&CIC(72) SETC  '47'\n&CEB(73) SETC  'i'\n&CIC(73) SETC  '48'\n&CEB(74) SETC  'j'\n&CIC(74) SETC  '49'\n&CEB(75) SETC  'k'\n&CIC(75) SETC  '4A'\n&CEB(76) SETC  'l'\n&CIC(76) SETC  '4B'\n&CEB(77) SETC  'm'\n&CIC(77) SETC  '4C'\n&CEB(78) SETC  'n'\n&CIC(78) SETC  '4D'\n&CEB(79) SETC  'o'\n&CIC(79) SETC  '4E'\n&CEB(80) SETC  'p'\n&CIC(80) SETC  '4F'\n&CEB(81) SETC  'q'\n&CIC(81) SETC  '50'\n&CEB(82) SETC  'r'\n&CIC(82) SETC  '51'\n&CEB(83) SETC  's'\n&CIC(83) SETC  '52'\n&CEB(84) SETC  't'\n&CIC(84) SETC  '53'\n&CEB(85) SETC  'u'\n&CIC(85) SETC  '54'\n&CEB(86) SETC  'v'\n&CIC(86) SETC  '55'\n&CEB(87) SETC  'w'\n&CIC(87) SETC  '56'\n&CEB(88) SETC  'x'\n&CIC(88) SETC  '57'\n&CEB(89) SETC  'y'\n&CIC(89) SETC  '58'\n&CEB(90) SETC  'z'\n&CIC(90) SETC  '59'\n.*\n&TABLEN  SETA  90                      MAXIMUM CHARS IN TAB\n.*\n.*       INITIALIZE LOOP VARIABLES\n.*\n&STRLEN  SETA  &STRLEN-1               ALLOW FOR ENCLOSING QUOTES\n&I       SETA  1                       BYPASS FIRST QUOTE\n&OUT     SETA  1                       OUTPUT CHAR POINTER\n.*\n.*       OUTER LOOP THROUGH STRING TO PROCESS EACH CHAR\n.*\n.LOOP    ANOP\n&I       SETA  &I+1                    SELECT NEXT CHAR\n&J       SETA  0                       INIT INNER LOOP VARIABLE\n.*\n.*       INNER LOOP THROUGH TABLE TO OBTAIN TRANSLATED VALUE\n.*\n.INLOOP  ANOP\n&J       SETA  &J+1\n         AIF   (&J LE &TABLEN).TESTC  SEARCHED THE TABLE ?\n&BAD     SETC  '&STRING'(&I,1)\n         MNOTE 12,'ERROR - INVALID CHARACTER FOR TRANSLATION |&BAD| '\n         AGO   .EXIT\n.TESTC   ANOP\n.*       MNOTE *,'I VALUE = &I'       DEBUGGING\n.*       MNOTE *,'J VALUE = &J'\n         AIF   ('&STRING'(&I,1) NE '&CEB(&J)'(1,1)).INLOOP\n.*\n.*       FOUND A MATCH\n.*\n.*       IS THE CHAR A QUOTE OR AMPERSAND ?\n.*       USE VALUE IN COMPARE TABLE TO AVOID ASSEMBLER SPECIAL CHAR\n.*       ISSUES\n.*\n         AIF   (&J EQ 44 OR &J EQ 61).SCHAR  FOR SPEC CHAR GOTO SCHAR\n&SUPCHAR SETB  0                       TURN OFF SUPRESS CHAR FLAG\n         AGO   .ASSIGN                 AND ASSIGN TRANSLATED VALUE\n.SCHAR   ANOP                          EITHER A QUOTE OR AMPERSAND\n         AIF   (&SUPCHAR).SCHARA       SPECIAL CHAR FOUND PREV ? SCHARA\n&SUPCHAR SETB  1                       SUPRESS NEXT SPECIAL CHAR\n         AGO   .ASSIGN                 ASSIGN THIS ONE\n.SCHARA  ANOP\n&SUPCHAR SETB  0                       TURN OFF SUPRESS CHAR\n         AGO   .SCHARB                 DO NOT ASSIGN CHAR\n.ASSIGN  ANOP\n&X(&OUT) SETC  '&CIC(&J)'              MOVE TRANSLATED HEX CHARS\n&OUT     SETA  &OUT+1                  INCREMENT OUTPUT COUNTER\n.SCHARB  ANOP\n         AIF   (&I LT &STRLEN).LOOP    PROCESS NEXT CHAR\n.*\n.*       ALL CHARS PROCESSED\n.*\n.*       GENERATE REQUESTED TRANSLATED HEX STRING\n.*\n         AIF   ('&GENTYPE' EQ 'EQU').GENEQU\n.*\n.*       DC REQUESTED\n.*\n.*       NOTE ONLY TWO CONTINUATION RECORDS ALLOWED FOR IEUASM AND\n.*       IFOX00\n.*\n&LABEL   DC    X'&X(1).&X(2).&X(3).&X(4).&X(5).&X(6).&X(7).&X(8).&X(9).C\n               &X(10).&X(11).&X(12).&X(13).&X(14).&X(15).&X(16).&X(17).C\n               &X(18).&X(19).&X(20).&X(21).&X(22).&X(23).&X(24)'\n         AIF   ('&X(25)' EQ '').EXIT    NO NEED FOR ADDITIONAL DC\n         DC    X'&X(25).&X(26).&X(27).&X(28).&X(29).&X(30).&X(31).&X(32C\n               ).&X(33).&X(34).&X(35).&X(36).&X(37).&X(38).&X(39)'\n         AGO   .EXIT\n.*\n.*       EQU REQUESTED\n.*\n.GENEQU  ANOP\n.*       EQUATES LIMITED TO 24 CHARS\n&LABEL   EQU   X'&X(1).&X(2).&X(3).&X(4).&X(5).&X(6).&X(7).&X(8).&X(9).C\n               &X(10).&X(11).&X(12).&X(13).&X(14).&X(15).&X(16).&X(17).C\n               &X(18).&X(19).&X(20).&X(21).&X(22).&X(23).&X(24)'\n         AGO   .EXIT\n.*\n.*       EXIT MACRO\n.*\n.EXIT    ANOP\n         MEND\n./ ADD NAME=IEXCHAR  0201-12230-12230-1200-00126-00126-00000-LEVEL\n         MACRO\n&LABEL   IEXCHAR\n.*\n.*       COMPONENT ID - 360S-AL-531 ALGOL F COMPILER\n.*\n.*       LEVEL 2.1 -\n.*       THIS IS A NEW MACRO REQUIRED AS PART OF THE\n.*       REFURBISHMENT OF THE LAST IBM RELEASE OF\n.*       THE ALGOL F COMPILER\n.*\n.*       FUNCTION -\n.*       IEXCHAR GENERATES EQUATES FOR ALL THE CHARACTERS USED\n.*       IN THE TEXT SCANNING ROUTINES AFTER THE TEXT HAS BEEN\n.*       TRANSLATED TO ALGOL INTERNAL CODE\n.*\n.*       NOTES -\n.*       1. THIS MACRO WAS DESIGNED TO EXECUTE IN THE\n.*          OS/360 ASSEMBLER IEUASM ENVIRONMENT SO THAT THE\n.*          ALGOL F SOURCE CODE CAN BE BUILT TO MATCH\n.*          THE OS/360 GENERATED ALGOL F OBJECT MODULES\n.*          USE OF THE VARIOUS ENHANCEMENTS PROVIDED BY\n.*          HLASM WAS THEREFORE PRECLUDED\n.*\n.*       DECLARE LCLS\n.*\n         LCLC  &XF                     PREFIX TO ASSIGNED NAME\n&XF      SETC  'XF'\n.*\n.*       GENERATE EQUATES FOR THE INTERNAL CHARACTER SET AND\n.*       CONTROL CODES\n.*\n*\n*        CHARACTER A - Z\n*\n&XF.A    IEXCGEN EQU,'A'\n&XF.B    IEXCGEN EQU,'B'\n&XF.C    IEXCGEN EQU,'C'\n&XF.D    IEXCGEN EQU,'D'\n&XF.E    IEXCGEN EQU,'E'\n&XF.F    IEXCGEN EQU,'F'\n&XF.G    IEXCGEN EQU,'G'\n&XF.H    IEXCGEN EQU,'H'\n&XF.I    IEXCGEN EQU,'I'\n&XF.J    IEXCGEN EQU,'J'\n&XF.K    IEXCGEN EQU,'K'\n&XF.L    IEXCGEN EQU,'L'\n&XF.M    IEXCGEN EQU,'M'\n&XF.N    IEXCGEN EQU,'N'\n&XF.O    IEXCGEN EQU,'O'\n&XF.P    IEXCGEN EQU,'P'\n&XF.Q    IEXCGEN EQU,'Q'\n&XF.R    IEXCGEN EQU,'R'\n&XF.S    IEXCGEN EQU,'S'\n&XF.T    IEXCGEN EQU,'T'\n&XF.U    IEXCGEN EQU,'U'\n&XF.V    IEXCGEN EQU,'V'\n&XF.W    IEXCGEN EQU,'W'\n&XF.X    IEXCGEN EQU,'X'\n&XF.Y    IEXCGEN EQU,'Y'\n&XF.Z    IEXCGEN EQU,'Z'\n*\n*        NATIONAL CHARACTERS\n*\n&XF.DOLLAR IEXCGEN EQU,'$'\n&XF.UNDER  IEXCGEN EQU,'_'\n&XF.HASH   IEXCGEN EQU,'#'\n&XF.AT     IEXCGEN EQU,'@'\n*\n*        NUMERIC 0 - 9\n*\n&XF.0    IEXCGEN EQU,'0'\n&XF.1    IEXCGEN EQU,'1'\n&XF.2    IEXCGEN EQU,'2'\n&XF.3    IEXCGEN EQU,'3'\n&XF.4    IEXCGEN EQU,'4'\n&XF.5    IEXCGEN EQU,'5'\n&XF.6    IEXCGEN EQU,'6'\n&XF.7    IEXCGEN EQU,'7'\n&XF.8    IEXCGEN EQU,'8'\n&XF.9    IEXCGEN EQU,'9'\n*\n*        SPECIAL CHARS\n*\n&XF.PLUS   IEXCGEN EQU,'+'\n&XF.MINUS  IEXCGEN EQU,'-'\n&XF.ASTER  IEXCGEN EQU,'*'\n&XF.SLASH  IEXCGEN EQU,'/'\n&XF.LBRAC  IEXCGEN EQU,'('\n&XF.COLON  IEXCGEN EQU,':'\n&XF.LSQBR  IEXCGEN EQU,'\u00dd'\n&XF.SCOLON IEXCGEN EQU,';'\n&XF.EQUAL  IEXCGEN EQU,'='\n&XF.LT     IEXCGEN EQU,'<'\n&XF.GT     IEXCGEN EQU,'>'\n&XF.NOT    IEXCGEN EQU,'\u00ac'\n&XF.OR     IEXCGEN EQU,'|'\n&XF.AMPER  IEXCGEN EQU,'&&'\n&XF.COMMA  IEXCGEN EQU,','\n&XF.RBRAC  IEXCGEN EQU,')'\n&XF.RSQBR  IEXCGEN EQU,'\u00a8'\n&XF.BLANK  IEXCGEN EQU,' '\n&XF.PERIOD IEXCGEN EQU,'.'\n&XF.QUOTE  IEXCGEN EQU,''''\n*\n&XF.DQUOTE IEXCGEN EQU,'\"'\n*\n&XF.EXCLM  IEXCGEN EQU,'!'\n&XF.PERCT  IEXCGEN EQU,'%'\n*\n*        INTERNAL CONTROL CODES\n*\n&XF.POWER  EQU   X'05'\n&XF.ASSIGN EQU   X'16'\n&XF.GOTO   EQU   X'17'\n&XF.FOR    EQU   X'18'\n&XF.IF     EQU   X'1D'\n&XF.LABEL  EQU   X'27'\n&XF.DELTA  EQU   X'29'\n&XF.END    EQU   X'2C'\n&XF.ZETA   EQU   X'2F'\n&XF.DECPT  EQU   X'3E'\n.*\n.*       EXIT MACRO\n.*\n.EXIT    ANOP\n         MEND\n./ ADD NAME=IEXENTRY 0201-12230-12230-1200-00055-00055-00000-LEVEL\n         MACRO\n&NAME    IEXENTRY  &REG=R15,&ID\n.*\n.*       IEXENTRY\n.*\n.*       COMPONENT ID - 360S-AL-531 ALGOL F COMPILER\n.*\n.*       GENERATE A MODULE EYE CATCHER OF THE SAME FORMAT AS THE\n.*       SAVE MACRO BUT DO NOT SAVE REGISTERS AS THE ALGOL COMPILER\n.*       OFTEN DOES NOT PROVIDE FOR THE SAVING OF REGS IN THE\n.*       STANDARD MANNER AND FOR STANDARD MODULE ENTRY\n.*       THE BRANCH REGISTER MAY BE SET TO ANOTHER REGISTER IF\n.*       R15 IS NOT THE ENTRY POINT REGISTER BY USE OF THE\n.*       REG PARAMETER\n.*\n         LCLA  &A,&B,&C\n         LCLC  &E,&F,&G,&H\n         AIF   ('&ID' EQ '').NULLID\n         AIF   ('&ID' EQ '*').SPECID\n         AIF   ('&ID'(1,1) NE '''').NOQUOTE\n&B       SETA  1\n&C       SETA  2\n.NOQUOTE ANOP\n&A       SETA  ((K'&ID+2)/2)*2+4-&C\n*\n&NAME    B     &A.(,&REG)          BRANCH AROUND ID\n&A       SETA  K'&ID-&C\n         DC    AL1(&A)             LENGTH OF IDENTIFIER\n&E       SETC  '&ID'(&B+1,&A)\n         DC    CL&A'&E'                          IDENTIFIER\n         AGO   .CONTA\n.NULLID  ANOP\n&NAME    DS    0H\n         AGO   .CONTA\n.SPECID  AIF   ('&NAME' EQ '').CSECTN\n&E       SETC  '&NAME'\n&A       SETA  1\n.CONTQ   AIF   ('&E'(1,&A) EQ '&E').LEAVE\n&A       SETA  &A+1\n         AGO   .CONTQ\n.LEAVE   ANOP\n&B       SETA  ((&A+2)/2)*2+4\n*\n&NAME    B     &B.(,&REG)          BRANCH AROUND ID\n         DC    AL1(&A)\n         DC    CL&A'&E'            IDENTIFIER\n         AGO   .CONTA\n.CSECTN  AIF   ('&SYSECT' EQ '').E4\n&E       SETC  '&SYSECT'\n&A       SETA  1\n         AGO   .CONTQ\n.E4      IHBERMAC 78,360                    CSECT NAME NULL\n.CONTA   ANOP\n         MEXIT\n         MEND\n./ ADD NAME=SGIEX001 0201-12230-12230-1200-00328-00328-00000-LEVEL\n         MACRO\n         SGIEX001 &PRC,&LST,&TRN,&PUN,&SCD,&SZE\n.*\n.*       COMPONENT ID - 360S-AL-531 ALGOL F COMPILER\n.*\n.*       SYSTEM GENERATION OPTIONS MACRO\n.*\n         GBLB  &SGALGOB(5)\n         GBLA  &SGALGOA(1)\n.*\n         TITLE 'IEX00001 - COMPILER COMMON WORKAREA, ALGOL F'\n*\n*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER\n*\n*        FUNCTION/OPERATION -\n*        THIS MODULE IS A COLLECTION OF DATA AND WORKING STORAGE\n*        WHICH MUST BE READILY ACCESSIBLE TO MORE THAN ONE\n*        COMPILER PHASE\n*\n*        R13 -> THIS MODULE DURING THE ENTIRE COMPILATION\n*\n*        ENTRY POINTS - N/A\n*\n*        INPUT - N/A\n*\n*        OUTPUT - N/A\n*\n*        EXTERNAL ROUTINES - N/A\n*\n*        EXITS - NORMAL - N/A\n*\n*        EXITS - ERROR - N/A\n*\n*        TABLES/WORK AREAS -\n*        THE FOLLOWING AREAS ARE PERMANENTLY ASSIGNED DURING THE\n*        WHOLE COMPILATION -\n*        1. SAVEAREA, REGISTER SAVEAREA IN THE STANDARD FORMAT\n*        2. DCBTABLE, DCB ADDRS FOR ALL DATASETS USED\n*        3. STARTING AT EODUT1, END OF DATA EXIT ADDRESSES FOR\n*           SYSUT1, SYSUT2, SYSUT3 AND SYSIN\n*        4. COMPFLGS, FOUR BYTES WITH VARIOUS SWITCHES AND\n*           INDICATORS FOR CONTROLLING THE PROGRAM FLOW\n*\n*           ALLOCATION OF THE BIT POSITIONS IN COMPFLGS -\n*\n*           PURPOSE                   POSITION\n*                                     BYTE 1    BYTE 2    BYTE 3\n*                                     01234567  01234567  01234567\n*\n*           COMPMODE (SYNTAX CHECK)   X\n*           SUBSCRIPT OPTIMIZATION     X\n*           WARNING ERROR               X\n*           SERIOUS ERROR                X\n*           TERMINATING ERROR             X\n*           PROCEDURE/PROGRAM              X\n*           LONG/SHORT PRECISION            X\n*           OPERAND                          X\n*\n*           NOSOURCE/SOURCE                     X\n*           NOLOAD/LOAD                          X\n*           NODECK/DECK                           X\n*           ISO/EBCDIC                             X\n*           PROGRAM INTERRUPT                       X\n*           TERMINATING PHASE ENTERED                X\n*           NO BUFFERS ASSIGNED                       X\n*           NO COMPILATION POSSIBLE                    X\n*\n*           SYSPRINT DOWN                                 X\n*           WHOLE SOURCE PROG IN CORE                      X\n*           NO OPTAB                                        X\n*           SYSPRINT NOT OPENED                              X\n*           ERROR UNRELATED TO SEMICOLON NR                   X\n*           NOTEST/TEST (SC COUNT IN CODE, NOT SYSGEN OPT)     X\n*           60 CHARACTER SET                                    X\n*           (RESERVED)                                           X\n*\n*        5. STARTING AT SIZE, MISC CONTROL INFORMATION\n*        6. STARTING AT ERRPOOL, ADDR POINTERS TO THE ERROR\n*           POOL AND THE SOURCE PROGRAM BUFFER 1\n*        7. STARTING AT INBLKS, A TABLE OF THE LENGTHS OF I/O\n*           BUFFERS AND OTHER AREAS\n*        8. PAGEHEAD, THREE HEADLINES TO BE PRINTED AT THE TOP\n*           OF EVERY PAGE\n*\n*        THE FOLLOWING AREAS ARE USED ONLY DURING CERTAIN PHASES\n*        OF THE COMPILATION, AS INDICATED IN THE ASSEMBLY\n*        LISTING. FOR THIS REASON, SOME OF THEM OVERLAY EACH\n*        OTHER, AND ANY SPACE NOT RESERVED DURING A CERTAIN PHASE\n*        MAY BE USED AS WORKING SPACE BY THAT PHASE\n*\n*        9.  PRELPOOL, A PRELIMINARY ERROR POOL USED DURING THE\n*            FIRST PART OF THE INITIALIZATION PHASE\n*        10. DCB FOR SYSIN\n*        11. PBTAB2, PBTAB1, FSTAB, TABLES USED BY CERTAIN\n*            PHASES\n*        12. DCB FOR SYSUT1\n*        13. SPTAB, GPTAB, TABLES USED BY SCAN I/II AND SCAN\n*            III\n*\n*        THE REMAINING SPACE UP TO 4K IS USED AS WORKING\n*        STORAGE\n*\n*        NOTES -\n*        THIS MODULE IS ASSEMBLED AT SYSTEM GENERATION TIME THE\n*        OPTION SWITCHES IN COMPFLGS ARE INITIALIZED TO REFLECT\n*        THE DESIRED DEFAULT OPTIONS. THE ASSEMBLED MODULE IS\n*        LINKAGE EDITED WITH THE MODULE IEX00000 TO FORM THE\n*        RESIDENT PART OF THE COMPILER DIRECTORY\n*\n*        THIS MODULE IS MAPPED BY THE DSECT WORKAREA. ANY CHANGES\n*        MUST ALSO BE REFLECTED IN THE WORKAREA DSECT\n*\nIEX00001 CSECT\n*\n         EXTRN IEX00SYN,IEX00ED1,IEX00EDI\n*\nSAVEAREA DC    18F'0'\n*\n*        DCB ADDRS\n*\nDCBTABLE DC    0F'0'\nALINDCB  DC    V(IEX00LIN)         SYSLIN\n         DC    A(0)                NOT USED\n         DC    A(0)                   ..\n         DC    A(0)                   ..\nASYSDCB  DC    A(SYSIN)            SYSIN DCB RESIDENT IN THIS MODULE\nAPRTDCB  DC    V(IEX00PRT)         SYSPRINT\nAPCHDCB  DC    V(IEX00PCH)         SYSPUNCH\nAUT1DCB  DC    A(SYSUT1)           SYSUT1 DCB RESIDENT IN THIS MODULE\nAUT2DCB  DC    V(IEX00UT2)         SYSUT2\nAUT3DCB  DC    V(IEX00UT3)         SYSUT3\n*\n*        END OF DATA EXIT ADDRS\n*\nEODUT1   DC    A(0)                SYSUT1\nEODUT2   DC    A(0)                SYSUT2\nEODUT3   DC    A(0)                SYSUT3\nEODIN    DC    A(0)                SYSIN\n*\n*        OPTION SWITCHES IN COMPFLGS SET BY SYSGEN OPTIONS\n*\nCOMPFLGS DC    BL2'&PRC.0&LST&TRN&PUN&SCD.0010',BL2'0'\n*\n*        OPTION SWITCHES IN COMPFLGS\n*\nPGR      EQU   X'FB'\nPROC     EQU   X'04'\n*\nSHRT     EQU   X'FD'\nLNG      EQU   X'02'\n*\nOPERAND  EQU   X'01'\nCOMPMODE EQU   X'80'\n*\n*        ERROR SEVERITY INDICATORS IN COMPFLGS\n*\nWERR     EQU   X'20'                   WARNING ERROR\nSERR     EQU   X'10'                   SERIOUS ERROR\nTERR     EQU   X'08'                   TERMINATING ERROR\n*\n*        OPTION SWITCHES IN COMPFLGS+1\n*\nSRCE     EQU   X'7F'\nNSRCE    EQU   X'80'\n*\nLOAD     EQU   X'BF'\nNLOAD    EQU   X'40'\n*\nDECK     EQU   X'DF'\nNDECK    EQU   X'20'\n*\nEBCDIC   EQU   X'EF'\nISO      EQU   X'10'\n*\n*        TERMINATION SWITCHES IN COMPFLGS+1\n*\nERR      EQU   X'08'     PROG INTERRUPTION HAS OCCURED IN COMPILER\nTERM     EQU   X'04'     LAST PHASE HAS BEEN ENTERED\nNOBUF    EQU   X'02'     ERROR POOL IS IN WORKAREA, NO SCE PROG BUFF 1\nNOGO     EQU   X'01'     COMPILATION IS IMPOSSIBLE, DO NOT START SCAN 1\nNOBUNOGO EQU   X'03'     NOBUF AND NOGO\n*\n*        SWITCES IN COMPFLGS+2\n*\nPRT      EQU   X'80'                   SYSPRINT IS DOWN\nSPIC     EQU   X'40'                   SOURCE PROG IN STORAGE\nNOPT     EQU   X'20'                   NO OPTAB\nPRTNO    EQU   X'10'                   SYSPRINT NOT OPENED\nNOSC     EQU   X'08'                   SEMICOLON COUNTER NOT VALID\nNOTEST   EQU   X'04'\nTEST     EQU   X'FB'                   EMBED SC COUNT IN CODE (DEFAULT)\nSET60    EQU   X'02'                   60 CHARACTER SET IS TO BE USED\n*\n*        MISCELLANEOUS CONTROL INFORMATION\n*\nSIZE     DC    F'&SZE'             AVAILABLE MAIN STORAGE - NOT USED\nPICAADD  DC    V(IEX00PIC)         ADDR OF PICA OF THE COMPILER\nHDING    DC    F'0'                ADDR OF HEADING INFO OF THE INVOKER\nERET     DC    F'0'                RETURN ADDR FOR PROGRAM\n*                                  AND I/O ERRORS\nPAGECNT  DC    PL4'0'              PAGE COUNT\nLINCNT   DC    H'0'                COUNTER OF LINES PER PAGE\nMAXLINES DC    H'56'               MAX NUMBER OF PRINT LINES PER PAGE\nSEMCNT   DC    H'0'                SEMICOLON COUNTER\nPBN      DC    H'50'               HIGHEST PROGRAM BLOCK NUMBER\nKBN      DC    H'0'                HIGHEST CONSTANT POOL NUMBER\nLATNR    EQU   28                  NR OF LIBRARY STAND FUNCTIONS\nLATBEG   EQU   4*(LATNR-1)\nLN       DC    AL2(LATBEG)         LAST USED DISPLACEMENT IN LAT\nPRPT     DC    F'0'                PROGRAM POINTER\nSAVOUTA  DC    F'0'\nOUTAREA2 DC    F'0'                SYSPUNCH SAVE AREA\nPIDENT   DC    CL4' '              PROGRAM IDENTIFICATION\nCARDCNT  DC    PL4'0'              OBJECT PROGRAM DECK SEQ NUMBER\nPRTRTADD DC    V(IEX00PRI)         ADDR OF PRINT ROUTINE\n*\n*        ADDRS OF AREAS WHICH ARE USED BY MORE THAN A SINGLE PHASE\n*\nERRPOOL  DC    A(PRELPOOL)         FIRST BYTE OF PRELIMINARY ERROR POOL\nNEXTERR  DC    A(PRELPOOL)         NEXT FREE PLACE IN ERROR POOL\nENDPOOL  DC    A(0)                LAST BYTE OF ERROR POOL-23\nSRCE1ADD DC    A(0)                SOURCE PROGRAM BUFFER 1\nSRCE1END DC    A(0)                ADDR OF LAST BYTE+1\nSULTSTRT DC    F'0'                IDENT OF LAST ITAB RECORD\n*\n*        TABLE OF THE LENGTHS OF VARIABLE SIZE AREAS\n*\nINBLKS   DC    H'3200'             MAX BLKSIZE FOR SYSIN    - NOT USED\nPRTBLKS  DC    H'3640'             MAX BLKSIZE SYSPRINT     - NOT USED\nLINBLKS  DC    H'3200'             MAX BLKSIZE FOR SYSLIN   - NOT USED\nPCHBLKS  DC    H'3200'             MAX BLKSIZE FOR SYSPUNCH - NOT USED\nPOOLS    DC    F'2000'             SIZE OF ERROR POOL\nSRCE1S   DC    F'2000'             SIZE OF SOURCE PROG BUFFERS 1 AND 2\nSRCE3S   EQU   SRCE1S              SIZE OF SOURCE PROG BUFFERS 3 AND 4\nITAB10S  DC    F'32736'            SIZE OF ITAB FOR PHASE 10\nITAB20S  DC    F'162000'           SIZE OF ITAB FOR PHASE 20\nITAB30S  DC    F'58000'            SIZE OF ITAB FOR PHASE 30\nCRIDTABS DC    F'3600'             SIZE OF CRIDTAB FOR PHASE 30\nSUTAB30S DC    F'1400'             SIZE OF SUTAB BUFFER OF PHASE 30\nLVTAB30S DC    F'1600'             SIZE OF LVTAB BUFFER FOR PHASE 30\nOPTABS   DC    F'1792'             SIZE OF OPTAB BUFFERS 1 AND 2\nSUTAB40S DC    F'25600'            SIZE OF SUTAB IN PHASE 40\nLVTAB40S DC    F'56000'            SIZE OF LVTAB IN PHASE 40\nOOSTACKS DC    F'6144'             SIZE OF OPERATOR/OPERAND STACK\n*\n*        AREA FOR HEADING INFORMATION TO APPEAR AT THE TOP OF\n*        EACH NEW PAGE\n*\nPAGEHEAD EQU   *\nPAGEHD1  DC    CL121' '                 FIRST HEADLINE\n         ORG   PAGEHD1\nPAGEHD1C DC    C' '                     ASA CNTL\n         DC    CL10' '                  SPACER\nPAGEHD1D DC    CL100' '                 PAGE TEXT HEADING\n         ORG   PAGEHD1+113\nPAGEHD1P DC    CL4'PAGE'                PAGE\nPAGENUMB DC    CL4' '                   PAGE COUNTER\n         ORG\n*\nPAGEHD2  DC    CL121' '                 SECOND HEADLINE\n         ORG   PAGEHD2\nPAGEHD2C DC    C' '                     ASA CNTL\n         DC    CL10' '                  SPACER\nPAGEHD2D DC    CL100' '                 PAGE TEXT HEADING\n         ORG\n*\nPAGEHD3  DC    CL121' '                 THIRD HEADLINE\n         ORG   PAGEHD3\nPAGEHD3C DC    C' '                     ASA CNTL\n         DC    CL10' '                  SPACER\nPAGEHD3D DC    CL100' '                 PAGE TEXT HEADING\n         ORG\n*\n*        END OF STANDARD COMMON AREA\n*\nSTANDX   EQU   *\n*\n*        THE FOLLOWING AREAS ARE NEEDED BY SOME BUT NOT ALL\n*        PHASES AND PARTLY OVERLAY EACH OTHER\n*\n*                              NAME OR PURPOSE        NEEDED BY PHASES\n*\n         DC    0F'0'\nPRELPOOL DC    236C' ',20C'X'  PRELIMINARY ERROR POOL     IEX10\n         ORG   PRELPOOL+414\n*\n*        DCB FOR SYSIN\n*\n         PRINT NOGEN\n*\nSYSIN    DCB   DDNAME=SYSIN,                                           X\n               DSORG=PS,                                               X\n               MACRF=(GM),                                             X\n               RECFM=FB,                                               X\n               LRECL=80,                                               X\n               BFTEK=S,                                                X\n               SYNAD=IEX00SYN,                                         X\n               EODAD=IEX00EDI\n*\n         PRINT GEN\n*\n         ORG   PRELPOOL\nPBTAB2   DS    CL510          PROGR. BLOCK TABLE 2          20-50\n         DS    0F\nPBTAB1   DS    CL255          PROGR. BLOCK TABLE 1          11-20\n         ORG   PBTAB1\nFSTAB    DS    CL255          FOR STATEMENT TABLE           30-40\n*                             DCB FOR SYSUT1                11-30\n*\nSYSUT1   DCB   DDNAME=SYSUT1,                                          X\n               DSORG=PS,                                               X\n               MACRF=(R,W),                                            X\n               RECFM=F,                                                X\n               SYNAD=IEX00SYN,                                         X\n               EODAD=IEX00ED1\n*\n         DS    0F\nSPTAB    DS    CL255          SCOPE TABLE                   11-30\n         DS    0F\nGPTAB    EQU   *-3            GROUP TABLE                   11-30\n         DS    CL1510\n*\n*        END OF SYMLIB PART OF COMMON WORK AREA\n*\n         ORG   STANDX+2863\n         DC    C'0'\n*\n         MEND\n./ ADD NAME=WAEXT    0201-12230-12230-1200-00069-00069-00000-LEVEL\n*\n*        AREA USED BY COMPILATION PHASE\n*\n         ORG   SYSUT1\n*\nRETADR   DS    17F                      SAVE AREA\nPLACE14  DS    F                           -''-\nRUTI     DS    9F                       GPR CONTROL\nRUTR     DS    4F                       FLREG CONTROL\nGPROLN   DS    H                        LABEL NR OF OBJ PRG ENTRY POINT\nKONSUM   DS    H                        WORKPLACE\nWORKPL   DS    F                        WORKPLACE\nIBUF1    EQU   SRCE1ADD                 ADDR OF FIRST SOURCE BUFFER\nIBUF2    DS    A                          -''  SECOND    -''-\nSOURCEB  DS    A                          -''  CURRENT   -''-\nRSRCB    DS    A                          -''  READ      -''-\nOPBUF1   DS    A                        ADDR OF FIRST OPTAB BUFFER\nOPBUF2   DS    A                          -''-  SECOND    -''-\nOPBUFB   DS    A                          -''-  CURRENT   -''-\nROPTB    DS    A                          -''-  READ      -''-\nAOPTABE  DS    A                        ADDR OF CURRENT OPTAB ENTRY\nLATAB    DS    A                        ADDR OF LABEL ADDR TABLE\nAPBTAB4  EQU   LATAB                    ADDRESS OF PBTAB4\nSUTABCA  DS    A                        ADDR OF LAST USED SUTAB ENTRY\nSTRETURN DS    F                        RETURN ADDRESS\nFREEMADR DS    A                        ADDR FOR FREEMAIN IN 50000\nFREEMSIZ DS    F                        SIZE          -''-\n         SPACE\nPBTAB3   DS    1024C                    PROGRAM BLOCK TABLE, 3RD VERS\n         SPACE\nIOTAB    DC    18X'00'                  LIST OF DATA SETS\nCII      DC    H'0'                     REGISTER CONTROL\nCIR      DC    H'0'                          -''-\nRII      DC    H'0'                          -''-\nRIR      DC    H'0'                          -''-\nOPDPBN   DC    H'0'                     PROGRAM BLOCK NO (BYTE 2 OF OPD\nOPDADR   DC    H'0'                     BYTES 3 AND 4 OF OPERAND\nOPDLN    DC    H'0'                     LABEL NUMBER TIMES FOUR\nZEROHW   DC    H'0'                     ZEROES\nCFSN     DC    X'00'                    CURRENT FS NUMBER\nMAXFSN   DC    X'FF'                    MAX FS NUMBER\nCLEARDIS DC    X'F000'                  FOR CLEARING OF DISPLACEM PART\nONEENTRY DC    H'4'                     SHORT, FOR INCR OF OT STACK PTR\n         ORG   ONEENTRY\n         DC    H'8'                     LONG            -''-\nPRECMASK DC    X'10'                    SHORT, TO MODIFY INSTRUCTIONS\n         ORG   PRECMASK\n         DC    X'00'                    LONG            -''-\nNUMBBL   DC    X'00'                    RECORD COUNTER\n         DS    H\nSPBNST   DC    H'0'                     CURRENT PBN\n         DS    H                                    AND DISPLACEMENT\nGPBN     DC    H'255'                   GLOBAL DSA CONTROL\nMAXOVERF DC    H'4092'                  SHORT, TO CHECK OT STACK OVERFL\n         ORG   MAXOVERF\n         DC    H'4088'                  LONG            -''-\nHALFW    DS    H                        WORKPLACE\nUSPEI2   DS    H                        FOR ARRAY DECLA-\nUSPEI4   DS    H                                        RATION HANDLING\nWPLACE   DS    H                        FOR INSTRUCTION GENERATION\nXPLACE   DS    H\nYPLACE   DS    H\nUPLACE   DS    H\nVPLACE   DS    C                                    -''-\nSTRDNAME DS    5C                       TO STORE OPERAND\nCBVTAB   DS    CL48                     CALLED-BY-VALUE TABLE\nSUTABC   DS    CL768                    FOR SUBSCRIPT OPTIMIZATION\n         ORG   SUTABC\nDSTAB    DS    CL608                    DATA SET TABLE\n./ ADD NAME=WORKAREA 0201-12230-12230-1200-00245-00245-00000-LEVEL\n*\n*        WORKAREA - MAPPING CSECT IEX00001\n*\n*        ANY CHANGES MADE TO IEX00001 MUST BE REFLECTED IN THIS DSECT\n*\nSAVEAREA DC    18F'0'\n*\n*        DCB ADDRS\n*\nDCBTABLE DC    0F'0'\nALINDCB  DC    A(0)\n         DC    A(0)\n         DC    A(0)\n         DC    A(0)\nASYSDCB  DC    A(0)\nAPRTDCB  DC    A(0)\nAPCHDCB  DC    A(0)\nAUT1DCB  DC    A(0)\nAUT2DCB  DC    A(0)\nAUT3DCB  DC    A(0)\n*\n*        END OF DATA EXIT ADDRS\n*\nEODUT1   DC    A(0)                    SYSUT1\nEODUT2   DC    A(0)                    SYSUT2\nEODUT3   DC    A(0)                    SYSUT3\nEODIN    DC    A(0)                    SYSIN\n*\n*        OPTION SWITCHES IN COMPFLGS\n*\n*        ALLOCATION OF THE BIT POSITIONS IN COMPFLGS -\n*\n*        PURPOSE                   POSITION\n*                                  BYTE 1    BYTE 2    BYTE 3\n*                                  01234567  01234567  01234567\n*\n*        COMPMODE (SYNTAX CHECK)   X\n*        SUBSCRIPT OPTIMIZATION     X\n*        WARNING ERROR               X\n*        SERIOUS ERROR                X\n*        TERMINATING ERROR             X\n*        PROCEDURE/PROGRAM              X\n*        LONG/SHORT PRECISION            X\n*        OPERAND                          X\n*\n*        NOSOURCE/SOURCE                     X\n*        NOLOAD/LOAD                          X\n*        NODECK/DECK                           X\n*        ISO/EBCDIC                             X\n*        PROGRAM INTERRUPT                       X\n*        TERMINATING PHASE ENTERED                X\n*        NO BUFFERS ASSIGNED                       X\n*        NO COMPILATION POSSIBLE                    X\n*\n*        SYSPRINT DOWN                                 X\n*        WHOLE SOURCE PROG IN CORE                      X\n*        NO OPTAB                                        X\n*        SYSPRINT NOT OPENED                              X\n*        ERROR UNRELATED TO SEMICOLON NR                   X\n*        NOTEST/TEST (SC COUNT IN CODE, NOT SYSGEN OPT)     X\n*        60 CHARACTER SET                                    X\n*        (RESERVED)                                           X\n*\nCOMPFLGS DC    X'00220000'             PARAMETERS AND SWITCHES\n*\n*        OPTION SWITCHES IN COMPFLGS\n*\nCOMPMODE EQU   X'80'                   SYNTAX CHECK MODE\nSUBSCOPT EQU   X'40'                   SUBSCRIPT OPTIMIZATION\nPGR      EQU   X'FB'\nPROC     EQU   X'04'                   PRECOMPILED PROCEDURE\n*\nSHRT     EQU   X'FD'\nLNG      EQU   X'02'\nOPERAND  EQU   X'01'\n*\n*        ERROR SEVERITY INDICATORS IN COMPFLGS\n*\nWERR     EQU   X'20'                   WARNING ERROR\nSERR     EQU   X'10'                   SERIOUS ERROR\nTERR     EQU   X'08'                   TERMINATING ERROR\n*\n*        OPTION SWITCHES IN COMPFLGS+1\n*\nSRCE     EQU   X'7F'\nNSRCE    EQU   X'80'\n*\nLOAD     EQU   X'BF'\nNLOAD    EQU   X'40'\n*\nDECK     EQU   X'DF'\nNDECK    EQU   X'20'\n*\nEBCDIC   EQU   X'EF'\nISO      EQU   X'10'\n*\n*        TERMINATION SWITCHES IN COMPFLGS+1\n*\nERR      EQU   X'08'                   PROGRAM INTERRUPT HAS\n*                                      OCCURED IN COMPILER\nTERM     EQU   X'04'                   LAST PHASE HAS BEEN ENTERED\nNOBUF    EQU   X'02'                   ERROR POOL IS IN WORKAREA\n*                                      NO SCE PROG BUFF 1\nNOGO     EQU   X'01'                   COMPILATION NOT POSSIBLE\n*                                      DO NOT START SCAN 1\nNOBUNOGO EQU   X'03'                   NOBUF AND NOGO\n*\n*        SWITCHES IN COMPFLGS+2\n*\nPRT      EQU   X'80'                   SYSPRINT NOT AVAILABLE\nSPIC     EQU   X'40'                   SOURCE PROGRAM IN STORAGE\nNOPT     EQU   X'20'                   NO SUBSCRIPT OPTIMIZATION\nPRTNO    EQU   X'10'                   SYSPRINT NOT OPENED\nNOSC     EQU   X'08'                   SEMICOLON COUNTER NOT VALID\n*\nNOTEST   EQU   X'04'\nTEST     EQU   X'FB'                   EMBED SC COUNT IN CODE (DEFAULT)\n*\nSET60    EQU   X'02'                   60 CHARACTER SET IS TO BE USED\n*\n*        MISCELLANEOUS CONTROL INFORMATION\n*\nSIZE     DC    F'45056'            AVAILABLE MAIN STORAGE - NOT USED\nPICAADD  DC    A(0)                ADDR OF PICA OF THE INVOKER\nHDING    DC    F'0'                ADDR OF HEADING INFO OF THE INVOKER\nERET     DC    F'0'                RETURN ADDR FOR PROGRAM\n*                                  AND I/O ERRORS\nPAGECNT  DC    PL4'0'              PAGE COUNT\nLINCNT   DC    H'0'                COUNTER OF LINES PER PAGE\nMAXLINES DC    H'56'               MAX NUMBER OF PRINT LINES PER PAGE\nSEMCNT   DC    H'0'                SEMICOLON COUNTER\nPBN      DC    H'50'               HIGHEST PROGRAM BLOCK NUMBER\nKBN      DC    H'0'                HIGHEST CONSTANT POOL NUMBER\nLATNR    EQU   28                  NR OF LIBRARY STAND FUNCTIONS\nLATBEG   EQU   4*(LATNR-1)\nLN       DC    AL2(LATBEG)         LAST USED DISPLACEMENT IN LAT\nPRPT     DC    F'0'                PROGRAM POINTER\nSAVOUTA  DC    F'0'\nOUTAREA2 DS    F                   SYSPUNCH SAVE AREA\nPIDENT   DC    CL4' '              PROGRAM IDENTIFICATION\nCARDCNT  DC    PL4'0'              OBJECT PROGRAM DECK SEQUENCE NUMBER\nPRTRTADD DC    A(0)                ADDR OF PRINT ROUTINE\n*\n*        ADDRS OF AREAS WHICH ARE USED BY MORE THAN A SINGLE PHASE\n*\nERRPOOL  DC    A(PRELPOOL)         FIRST BYTE OF PRELIMINARY ERROR POOL\nNEXTERR  DC    A(PRELPOOL)         NEXT FREE PLACE IN ERROR POOL\nENDPOOL  DS    F                   LAST BYTE OF ERROR POOL-23\nSRCE1ADD DS    F                   SOURCE PROGRAM BUFFER 1\nSRCE1END DS    F                   ADDR OF LAST BYTE+1\nSULTSTRT DS    F                   ID OF LAST ITAB RECORD\n*\n*\n*        TABLE OF THE LENGTHS OF VARIABLE SIZE AREAS\n*\nINBLKS   DS    H                   MAX BLKSIZE FOR SYSIN    - NOT USED\nPRTBLKS  DS    H                   MAX BLKSIZE SYSPRINT     - NOT USED\nLINBLKS  DS    H                   MAX BLKSIZE FOR SYSLIN   - NOT USED\nPCHBLKS  DS    H                   MAX BLKSIZE FOR SYSPUNCH - NOT USED\nPOOLS    DS    F                   SIZE OF ERROR POOL\nSRCE1S   DS    F                   SIZE OF SOURCE PROG BUFFERS 1 AND 2\nSRCE3S   EQU   SRCE1S              SIZE OF SOURCE PROG BUFFERS 3 AND 4\nITAB10S  DS    F                   SIZE OF ITAB FOR PHASE 10\nITAB20S  DS    F                   SIZE OF ITAB FOR PHASE 20\nITAB30S  DS    F                   SIZE OF ITAB FOR PHASE 30\nCRIDTABS DS    F                   SIZE OF CRIDTAB FOR PHASE 30\nSUTAB30S DS    F                   SIZE OF SUTAB BUFFER OF PHASE 30\nLVTAB30S DS    F                   SIZE OF LVTAB BUFFER FOR PHASE 30\nOPTABS   DS    F                   SIZE OF OPTAB BUFFERS 1 AND 2\nSUTAB40S DS    F                   SIZE OF SUTAB IN PHASE 40\nLVTAB40S DS    F                   SIZE OF LVTAB IN PHASE 40\nOOSTACKS DS    F                   SIZE OF OPERATOR/OPERAND STACK\n*\n*        AREA FOR HEADING INFORMATION TO APPEAR AT THE TOP OF\n*        EACH NEW PAGE\n*\nPAGEHEAD EQU   *\nPAGEHD1  DC    CL121' '                 FIRST HEADLINE\n         ORG   PAGEHD1\nPAGEHD1C DC    C'1'                     ASA CNTL\n         DC    CL10' '                  SPACER\nPAGEHD1D DC    CL100' '                 PAGE TEXT HEADING\n         ORG   PAGEHD1+113\nPAGEHD1P DC    CL4'PAGE'                PAGE\nPAGENUMB DC    CL4' '                   PAGE COUNTER\n         ORG\n*\nPAGEHD2  DC    CL121' '                 SECOND HEADLINE\n         ORG   PAGEHD2\nPAGEHD2C DC    C' '                     ASA CNTL\n         DC    CL10' '                  SPACER\nPAGEHD2D DC    CL100' '                 PAGE TEXT HEADING\n         ORG\n*\nPAGEHD3  DC    CL121' '                 THIRD HEADLINE\n         ORG   PAGEHD3\nPAGEHD3C DC    C' '                     ASA CNTL\n         DC    CL10' '                  SPACER\nPAGEHD3D DC    CL100' '                 PAGE TEXT HEADING\n         ORG\n*\n*\n*        END OF STANDARD COMMON AREA\n*\nSTANDX   EQU   *\n*\n*        THE FOLLOWING AREAS ARE NEEDED BY SOME BUT NOT ALL\n*        PHASES AND PARTLY OVERLAY EACH OTHER\n*\n*                             NAME OR PURPOSE          NEEDED BY PHASES\n*\n         DC    0F'0'\nPRELPOOL DC    236C' ',20C'X' PRELIMINARY ERROR POOL     IEX10\n         ORG   PRELPOOL+414\n*                             DCB FOR SYSIN                 11\nSYSIN    DCB   DDNAME=SYSIN,                                           X\n               DSORG=PS,                                               X\n               MACRF=(GM),                                             X\n               RECFM=FB,                                               X\n               LRECL=80,                                               X\n               BFTEK=S\n*              SYNAD=SYNAD    (ASSEMBLED IN IEX00001)\n*              EODAD=EODADIN  (INSERTED BY IEX11)\n         ORG   PRELPOOL\nPBTAB2   DS    CL510          PROGR. BLOCK TABLE 2          20-50\n         DS    0F\nPBTAB1   DS    CL255          PROGR. BLOCK TABLE 1          11-20\n         ORG   PBTAB1\nFSTAB    DS    CL255          FOR STATEMENT TABLE           30-40\n*                             DCB FOR SYSUT1                11-30\nSYSUT1   DCB   DDNAME=SYSUT1,                                          X\n               DSORG=PS,                                               X\n               MACRF=(R,W),                                            X\n               RECFM=F\n*              SYNAD=SYNAD,   (ASSEMBLED IN IEX00001)\n*              EODAD=EODAD1\n*\n         DS    0F\nSPTAB    DS    CL255          SCOPE TABLE                   11-30\n         DS    0F\nGPTAB    EQU   *-3            GROUP TABLE                   11-30\n         DS    CL1510\n*\n*        END OF SYMLIB PART OF COMMON WORK AREA\n*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT876/FILE876.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT876", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}