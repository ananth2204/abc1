./ ADD NAME=IHIERM   0201-12230-12230-1200-00283-00283-00000-LEVEL
MSG      TITLE 'IHIERMSG, RUNTIME ERROR MESSAGES, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION - THIS CONTROL SECTION CONTAINS ALL
*        THE MESSAGES USED BY THE ERROR ROUTINE
*
*        ENTRY POINTS - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXITS - N/A
*
*        TABLES/WORK AREAS -
*        THIS CONTROL SECTION IS MADE UP OF TABLES
*
IHIERMSG CSECT
*
         ENTRY IHIERM01
*
FLAGIDS  EQU   X'03'                   INSERT DSNAME INTO MSG
FLAGIPS  EQU   X'01'                   INSERT PSW INTO MSG
FLAGMC   EQU   X'04'                   MSG CONTINUATION
*
         DC    A(MESS0)                MESSAGE NUMBER 0-43 MUST BE
         DC    A(MESS1)                KEPT TOGETHER
         DC    A(MESS2)
         DC    A(MESS3)
         DC    A(MESS4)
         DC    A(MESS5)
         DC    A(MESS6)
         DC    A(MESS7)
         DC    A(MESS8)
         DC    A(MESS9)
         DC    A(MESS10)
         DC    A(MESS11)
         DC    A(MESS12)
         DC    A(MESS13)
         DC    A(MESS14)
         DC    A(MESS15)
         DC    A(MESS16)
         DC    A(MESS17)
         DC    A(MESS18)
         DC    A(MESS19)
         DC    A(MESS20)
         DC    A(MESS21)
         DC    A(MESS22)
         DC    A(MESS23)
         DC    A(MESS24)
         DC    A(MESS25)
         DC    A(MESS26)
         DC    A(MESS27)
         DC    A(MESS28)
         DC    A(MESS29)
         DC    A(MESS30)
         DC    A(MESS31)
         DC    A(MESS32)
         DC    A(MESS33)
         DC    A(MESS34)
         DC    A(MESS35)
         DC    A(MESS36)
         DC    A(MESS37)
         DC    A(MESS38)
         DC    A(MESS39)
         DC    A(MESS40)
         DC    A(MESS41)
         DC    A(MESS42)
         DC    A(MESS43)
*
IHIERM01 DC    C'IHI0  I  SC=       '
*
MESS0    DC    AL1(L'MESS0T)
         DC    AL1(0)                  FLAGS
MESS0T   DC    C'DATASET NUMBER OUT OF RANGE'
*
MESS1    DC    AL1(L'MESS1T)
         DC    AL1(FLAGIDS)            FLAGS
MESS1T   DC    C'DSN=       REAL NUMBER TO BE CONVERTED OUT OF INTEGER X
               RANGE'
*
MESS2    DC    AL1(L'MESS2T)
         DC    AL1(FLAGIDS)            FLAGS
MESS2T   DC    C'DSN=       INCOMPATIBLE ACTIONS ON DATASET'
*
MESS3    DC    AL1(L'MESS3T)
         DC    AL1(FLAGIDS)            FLAGS
MESS3T   DC    C'DSN=       INPUT BEYOND LAST OUTPUT'
*
MESS4    DC    AL1(L'MESS3T)
         DC    AL1(0)                  FLAGS
MESS4T   DC    C'TOO MANY REPOSITIONINGS IN DATASETS. INTERNAL OVERFLOWX
               '
*
MESS5    DC    AL1(L'MESS5T)
         DC    AL1(FLAGIDS)            FLAGS
MESS5T   DC    C'DSN=       INPUT REQUEST BEYOND END OF DATASET'
*
MESS6    DC    AL1(L'MESS6T)
         DC    AL1(FLAGIDS+FLAGMC)     FLAGS
MESS6T   DC    C'DSN=       EXPONENT PART OF INPUT NUMBER CONSISTS OF MX
               ORE THAN'
         DC    AL1(L'MESS6T1)
         DC    AL1(0)                  FLAGS
MESS6T1  DC    C'TWO SIGNIFICANT DIGITS'
*
MESS7    DC    AL1(L'MESS7T)
         DC    AL1(FLAGIDS+FLAGMC)     FLAGS
MESS7T   DC    C'DSN=       **NO CONTROL CHARACTER SPECIFIED IN RECORD C
               FORMAT OF '
         DC    AL1(L'MESS7T1)
         DC    AL1(0)                  FLAGS
MESS7T1  DC    C'DATASET. SPLITTING INTO SECTIONS IMPOSSIBLE'
*
MESS8    DC    AL1(L'MESS8T)
         DC    AL1(FLAGIDS)            FLAGS
MESS8T   DC    C'DSN=       SOURCE IN PROCEDURE OUTSYMBOL DOES NOT MATCX
               H STRING'
*
MESS9    DC    AL1(L'MESS9T)
         DC    AL1(FLAGIDS)            FLAGS
MESS9T   DC    C'DSN=       UNDEFINED FUNCTION NUMBER IN SYSACT PROCEDUX
               RE'
*
MESS10   DC    AL1(L'MESS10T)
         DC    AL1(FLAGIDS)            FLAGS
MESS10T  DC    C'DSN=       DATASET CLOSED'
*
MESS11   DC    AL1(L'MESS11T)
         DC    AL1(FLAGIDS)            FLAGS
MESS11T  DC    C'DSN=       DATASET OPEN'
*
MESS12   DC    AL1(L'MESS12T)
         DC    AL1(FLAGIDS)            FLAGS
MESS12T  DC    C'DSN=       QUANTITY IN SYSACT PROCEDURE MUST BE A VARIX
               ABLE'
*
MESS13   DC    AL1(L'MESS13T)
         DC    AL1(FLAGIDS)            FLAGS
MESS13T  DC    C'DSN=       QUANTITY IN SYSACT PROCEDURE OUT OF RANGE'
*
MESS14   DC    AL1(L'MESS14T)
         DC    AL1(FLAGIDS)            FLAGS
MESS14T  DC    C'DSN=       BACKWARD REPOSITIONING NOT DEFINED'
*
MESS15   DC    AL1(L'MESS15T)
         DC    AL1(0)                  FLAGS
MESS15T  DC    C'UPPER BOUND LESS THAN LOWER BOUND IN ARRAY DECLARATIONX
               '
*
MESS16   DC    AL1(L'MESS16T)
         DC    AL1(0)                  FLAGS
MESS16T  DC    C'VALUE OF SUBSCRIPT EXPRESSION NOT WITHIN DECLARED BOUNX
               DS'
*
MESS17   DC    AL1(L'MESS17T)
         DC    AL1(0)                  FLAGS
MESS17T  DC    C'ENDLESS LOOP IN FOR STATEMENT'
*
MESS18   DC    AL1(L'MESS18T)
         DC    AL1(0)                  FLAGS
MESS18T  DC    C'STORAGE REQUEST FOR ARRAY EXCEEDS LIMIT'
*
MESS19   DC    AL1(L'MESS19T)
         DC    AL1(0)                  FLAGS
MESS19T  DC    C'UNEQUAL NUMBER OF DIMENSIONS FOR ACTUAL AND FORMAL PARC
               AMETER'
*
MESS20   DC    AL1(L'MESS20T)
         DC    AL1(0)                  FLAGS
MESS20T  DC    C'ACTUAL AND CORRESPONDING FORMAL PARAMETER OF DIFFERENTX
                TYPE OR KIND'
*
MESS21   DC    AL1(L'MESS21T)
         DC    AL1(FLAGMC)             FLAGS
MESS21T  DC    C'UNEQUAL NUMBER OF PARAMETERS IN PROCEDURE DECLARATION X
               AND PROCEDURE'
         DC    AL1(L'MESS21T1)
         DC    AL1(0)                  FLAGS
MESS21T1 DC    C'STATEMENT/FUNCTION DESIGNATOR'
*
MESS22   DC    AL1(L'MESS22T)
         DC    AL1(0)                  FLAGS
MESS22T  DC    C'ASSIGNMENT TO FORMAL PARAMETER NOT POSSIBLE'
*
MESS23   DC    AL1(L'MESS23T)
         DC    AL1(0)                  FLAGS
MESS23T  DC    C'ARGUMENT OF SQRT LESS THAN ZERO'
*
MESS24   DC    AL1(L'MESS24T)
         DC    AL1(0)                  FLAGS
MESS24T  DC    C'ARGUMENT OF EXP GREATER THAN 174.673'
*
MESS25   DC    AL1(L'MESS25T)
         DC    AL1(0)                  FLAGS
MESS25T  DC    C'ARGUMENT OF LN NOT GREATER THAN ZERO'
*
MESS26   DC    AL1(L'MESS26T)
         DC    AL1(0)                  FLAGS
MESS26T  DC    C'ABS VALUE OF ARGUMENT OF SIN OR COS NOT LESS THAN PI*2X
               **18'
*
MESS27   DC    AL1(L'MESS27T)
         DC    AL1(0)                  FLAGS
MESS27T  DC    C'ABS VALUE OF ARGUMENT OF SIN OR COS NOT LESS THAN PI*2X
               **50'
*
MESS28   DC    AL1(L'MESS28T)
         DC    AL1(FLAGIPS)            FLAGS
MESS28T  DC    C'PSW=                   FIXED POINT OVERFLOW INTERRUPT'
*
MESS29   DC    AL1(L'MESS29T)
         DC    AL1(FLAGIPS)            FLAGS
MESS29T  DC    C'PSW=                   FLOATING POINT EXPONENT OVERFLOX
               W INTERRUPT'
*
MESS30   DC    AL1(L'MESS30T)
         DC    AL1(FLAGIPS)            FLAGS
MESS30T  DC    C'PSW=                   DIVISION BY ZERO, FIXED POINT'
*
MESS31   DC    AL1(L'MESS31T)
         DC    AL1(FLAGIPS)            FLAGS
MESS31T  DC    C'PSW=                   DIVISION BY ZERO, FLOATING POINX
               T'
*
MESS32   DC    AL1(L'MESS32T)
         DC    AL1(FLAGIDS)            FLAGS
MESS32T  DC    C'DSN=       UNRECOVERABLE I/O ERROR'
*
MESS33   DC    AL1(L'MESS33T)
         DC    AL1(FLAGIPS)            FLAGS
MESS33T  DC    C'PSW=                   PROGRAM INTERRUPT'
*
MESS34   DC    AL1(L'MESS34T)
         DC    AL1(0)                  FLAGS
MESS34T  DC    C'VALUE OF SWITCH DESIGNATOR NOT DEFINED IN DECLARATION X
               OF SWITCH'
*
MESS35   DC    AL1(L'MESS35T)
         DC    AL1(0)                  FLAGS
MESS35T  DC    C'BASE NOT GREATER THAN ZERO'
*
MESS36   DC    AL1(L'MESS36T)
         DC    AL1(FLAGMC)             FLAGS
MESS36T  DC    C'TOO MANY NESTED BLOCKS AND CALLS OF PROCEDURES, SWITCHC
               ES'
         DC    AL1(L'MESS36T1)
         DC    AL1(0)                  FLAGS
MESS36T1 DC    C'AND PARAMETERS. INTERNAL OVERFLOW'
*
MESS37   DC    AL1(L'MESS37T)
         DC    AL1(FLAGIDS)            FLAGS
MESS37T  DC    C'DSN=       **BLOCKSIZE NOT A MULTIPLE OF LOGICAL RECORX
               D LENGTH'
*
MESS38   DC    AL1(L'MESS38T)
         DC    AL1(FLAGIDS)            FLAGS
MESS38T  DC    C'DSN=       TOO LONG RECORD'
*
MESS39   DC    AL1(L'MESS39T)
         DC    AL1(0)                  FLAGS
MESS39T  DC    C'GET/PUT IDENTIFICATION OUT OF RANGE'
*
MESS40   DC    AL1(L'MESS40T)
         DC    AL1(0)                  FLAGS
MESS40T  DC    C'REAL NUMBER TO BE CONVERTED OUT OF INTEGER RANGE'
*
MESS41   DC    AL1(L'MESS41T)
         DC    AL1(FLAGIDS)            FLAGS
MESS41T  DC    C'DSN=       DD CARD INCORRECT OR MISSING'
*
MESS42   DC    AL1(L'MESS42T)
         DC    AL1(0)                  FLAGS
MESS42T  DC    C'INVALID OPTION PARAMETER'
*
MESS43   DC    AL1(L'MESS43T)
         DC    AL1(0)                  FLAGS
MESS43T  DC    C'ILLEGAL CALL OF GET/PUT OR LIST PROCEDURE'
*
         END
./ ADD NAME=IHIERR   0201-12230-12230-1200-00511-00511-00000-LEVEL
ERR      TITLE 'IHIERROR, RUNTIME ERROR ROUTINE, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        IF AN ERROR OCCURS DURING EXECUTION OF AN ALGOL PROGRAM
*        THIS ROUTINE IS CALLED BY IHIFSARA
*        A MESSAGE IS GIVEN SPECIFYING THE ERROR. IF DUMP IS
*        SPECIFIED THE ROUTINE EDITS AND PRINTS THE DATA STORAGE
*        AREAS CONTAINING THE VALUES OF THE IDENTIFIERS
*
*        ENTRY POINT - IHIERROR
*
*        OUTPUT-
*        ERROR MESSAGES AND ALGOL DUMPS ARE PRINTED ON THE
*        PRINTER AS 90 CHARACTER RECORDS WITH CONTROL CHARACTER
*        IN SOME CASES A MESSAGE IS ISSUED TO THE CONSOLE
*
*        EXTERNAL ROUTINES -
*        IHIIORCL - FOR CLOSING DATASET NUMBER 1 (PRINTER)
*        IHIIOROP - FOR OPENING DATASET NUMBER 1
*        FRDSA    - ROUTINE IN IHIFSARA WHICH ISSUES FREEMAIN FOR
*                   THE CURRENT DATA STORAGE AREAS
*
*        EXIT - NORMAL - TO TERMINATION ROUTINE IN IHIFSARA
*
*        EXIT - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        THE CONTROL SECTION NAMED IHIGERMSG CONTAINS ALL
*        MESSAGES TO BE PRINTED
*
IHIERROR CSECT
*
         USING DSTABLE,R5
*
***********************************************************************
*
*        REGISTER USAGE
*
***********************************************************************
*
CDSA     EQU   10                      ADDRESS OF CURRENT DSA
PBT      EQU   11
*
*        MESSAGE FORMAT FLAGS
*
FLAGIDS  EQU   X'03'                   INSERT DSNAME INTO MSG
FLAGIPS  EQU   X'01'                   INSERT PSW INTO MSG
FLAGMC   EQU   X'04'                   MSG CONTINUATION
*
         SAVE  (14,12),,'IHIERROR LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15
         USING IHIERROR,R7
         MVC   VFRDSA(20),0(R1)        STORE EXTERNAL ADDR PARAMETERS
         LR    R12,R13                 R12 -> FSA
         LA    R13,SAVEAREA            R13 -> SAVEAREA
*
***********************************************************************
*
*        TEST IF ERROR MESSAGE NUMBER IS 32 OR 41 FOR DATASET 1
*
***********************************************************************
*
         BCT   R6,B1
         TM    DSF+1,DS11              DS11 = 0 ?
         BZ    B1                      YES
         CLI   FSAERCOD(R12),X'80'     I/O ERROR (32) ?
         BE    IOERR                   YES, EXECUTE WTO INSTRUCTION
         CLI   FSAERCOD(R12),X'A4'     DD CARD ? (41)
         BNE   B1                      YES, EXECUTE WTO INSTRUCTION
*
         WTO   'IHI041I SYSPRINT DD STMT INCORRECT OR MISSING',        X
               ROUTCDE=11,DESC=7
*
         B     SETOPTSW
*
IOERR    WTO   'IHI032I SYSPRINT UNRECOVERABLE I/O ERROR',             X
               ROUTCDE=11,DESC=7
*
SETOPTSW OI    OPTSW(R12),X'02'        SET SWITCH IN FSA
         NI    DTSW(R12),X'7F'         REMOVE DUMP SWITCH
         B     SPDAFREE
*
***********************************************************************
*
*        EDIT AND PRINT ERROR MESSAGE
*
***********************************************************************
*
B1       LA    R8,1(,R6)               SAVE DSNR FOR EDITING IF NEEDED
         L     R5,ADSTAB(R12)          R5 -> ADSTAB IN FSA
         LA    R5,DSTABLEL+4(,R5)      R5 -> DSTABLE ENTRY FOR DS NO 1
         LA    R6,1                    SET DSNR TO 1
         OI    DSF+1,DS15              FLAG CLOSE FROM IHIERR
         L     R15,VIORCP              CLOSE ALL DATASETS
         BALR  R14,R15
SETDS11  OI    DSF+1,DS11              DS11=1 TO INDICATE IHIERR-ROUT
         OI    DSF,DS2+DS3+DS6         DS2, DS3, DS6 = 1
         NI    DSF,255-DS0-DS1         DS0, DS1 = 0
         L     R15,VIOROP              R15 -> IHIIOROP
         BALR  R14,R15                 OPEN SYSPRINT
         MVI   BUFFER,C' '             PRINT ONE BLANK LINE TO PREVENT
         MVC   BUFFER+1(L'BUFFER-1),BUFFER  OVERPRINTING
         BAL   R3,OUTPUT
         SR    R2,R2
         IC    R2,FSAERCOD(R12)        GET ADDR OF ERROR MESSAGE
         L     R6,VERMSG               R6 -> IHIERMSG MODULE
         L     R6,0(R2,R6)             R6 -> MSG TEXT BLOCK
         SRL   R2,2                    CONVERT MESSAGE NUMBER TO
         CVD   R2,WORKD                DECIMAL FOR PRINTING
         L     R3,VERM01               R3 -> 'IHI0XXI SC=   ' STRING
         UNPK  4(2,R3),WORKD           MOVE IN MSG NUMBER
         OI    5(R3),X'F0'             MAKE PRINTABLE
         LH    R2,SCRCS(,R12)          CONVERT SEMICOLON COUNTER TO
         CVD   R2,WORKD                DECIMAL FOR PRINTING
         MVC   12(L'SCPATTN,R3),SCPATTN  MOVE IN EDIT PATTERN
         ED    12(L'SCPATTN,R3),WORKD+5  FORMAT SEMICOLON COUNT
         TM    1(R6),FLAGIDS           DSNAME TO BE INSERTED ?
         BNO   NOT1617A                NO, BRANCH
         STC   R8,DSNUMBER             YES, STORE DATASET NUMBER
         CLI   DSNUMBER,16             DSN = 16 ?
         BNE   DSN17                   NO, BRANCH
         MVC   2(6,R6),=C'SYSUT2'      SYSUT2
         B     PSWDSN
*
DSN17    BL    NOT1617
         MVC   2(6,R6),=C'SYSUT1'      SYSUT1
         B     PSWDSN
*
TAKEDSN  CVD   R8,WORKD                CONVERT DATASET NUMBER TO
         UNPK  6(2,R6),WORKD           DECIMAL FOR PRINTING
         OI    7(R6),X'F0'             MAKE PRINTABLE
         B     PSWDSN
*
TAKEPSW  UNPK  7(9,R6),PGOPSW(5,R12)   UNPACK OLD PSW FOR PRINTING
         TR    7(8,R6),TRTABLE-240
         MVI   15(R6),C' '
         UNPK  16(9,R6),PGOPSW+4(5,R12)
         MVI   24(R6),C' '
         TR    16(8,R6),TRTABLE-240
         B     PSWDSN
*
NOT1617  TM    1(R6),FLAGIDS           INSERT DATASET NUMBER ?
         BO    TAKEDSN                 YES, BRANCH
NOT1617A BM    TAKEPSW
*
PSWDSN   MVC   BUFFER(19),0(R3)        MOVE MESSAGE INTO BUFFER
         SR    R2,R2
LINE2    IC    R2,0(R6)                GET L'MSG TEXT
         BCTR  R2,0                    DECR FOR EXE
         EX    R2,EXMVC                MOVE MSG TEXT
         TM    1(R6),FLAGMC            MSG HAS CONTINUATION ?
         BZ    ENDLINE                 NO, BRANCH
         BAL   R3,OUTPUT
         LA    R6,3(R2,R6)             R6 -> NEXT LINE OF MESSAGE
         B     LINE2                   LOOP FOR CONTINUATION LINE
*
EXMVC    MVC   BUFFER+19(0),2(R6)      EXE MVC
*
ENDLINE  OI    FLAG,X'04'
         BAL   R3,OUTPUT
         MVI   SPACE,C'0'              SET ASA SKIP CHARACTER
         MVI   SCOUNT+3,X'01'          INSERT NEW STEP LENGTH FOR S
*
***********************************************************************
*
*        GO THROUGH THE RETURN ADDR STACK
*        IF A BLOCK OR PROCEDURE ENTRY IS FOUND THE DATA STORAGE
*        AREAS ARE EDITED AND FSA IS CALLED FOR ISSUEING
*        FREEMAIN
*
***********************************************************************
*
SPDAFREE L     R1,VSPDAP               FREEMAIN FOR SPDA AREAS
         L     R2,0(,R1)
MORESPDA LTR   R1,R2
         BZ    MORERAS
         L     R2,0(,R1)
*
         FREEMAIN R,LV=64,A=(R1)
*
         B     MORESPDA                LOOP AROUND
*
MORERAS  L     R14,RASPT(R12)          TEST IF MORE ENTRIES IN RAS
MORERASA C     R14,RASSTART(R12)
         BNH   ENDOFR
         CLI   0(R14),X'00'            PROCEDURE OR BLOCK ENTRY ?
         BE    PRENTRY
         TM    DTSW(R12),X'80'         DUMP SPECIFIED ?
         BZ    RELDSA
         B     EDIT
*
PRENTRY  LA    R2,8                    GET PRECEDING ENTRY IN RAS
         SR    R14,R2
         ST    R14,RASPT(R12)          NEW ADDR TO RASTP IN FSA
         B     MORERASA
*
RELDSA   LR    R13,R12                 RELEASE CURRENT DATA STORAGE
         L     CDSA,0(,R14)            AREA
         L     PBT,16(,CDSA)
         L     R1,VFRDSA
         BALR  R15,R1
         LR    R12,R13
         LA    R13,SAVEAREA
         B     MORERAS
*
ENDOFR   LR    R13,R12
*
         RETURN (14,12)                TO TERMINATION ROUTINE IN FSA
*
***********************************************************************
*
*        PRINT CURRENT DATA STORAGE AREAS IF DUMP IS SPECIFIED
*
***********************************************************************
*
*        BLOCK NUMBER AND TYPE OF BLOCK MOVED INTO TEXT
*
***********************************************************************
*
EDIT     L     CDSA,0(,R14)            POINTER TO CURRENT DSA
         L     PBT,16(,CDSA)           ADDR OF PBTAB
         MVC   ERM02M(4),4(PBT)        NAME OF LOAD MODULE
         AH    PBT,8(,CDSA)            TYPE OF BLOCK
         SR    R2,R2
         IC    R2,6(,PBT)
         SLL   R2,2
         LA    R6,ERM02BK(R2)
         MVC   ERM02TP,0(R6)           MOVE IN BLOCK TYPE TEXT
         LH    R2,8(CDSA)              CONVERT BLOCK NUMBER TO DECIMAL
         SRL   R2,3                    FOR PRINTING
         CVD   R2,WORKD
         MVC   ERM02BN,BNPATTN
         ED    ERM02BN,WORKD+6
         OI    FLAG,X'04'              SET SKIP FLAG
         MVC   BUFFER(ERM02L),IHIERM02  MOVE MSG INTO BUFFER
         BAL   R3,OUTPUT
*
***********************************************************************
*
*        EDIT THE FORMAL PARAMETERS IF PROCEDURE BLOCK
*
***********************************************************************
*
         SR    R1,R1
         LA    R9,24(,CDSA)            FIRST BYTE TO BE EDITED
         TM    6(PBT),X'FF'            TEST FOR FORMAL PARAMETERS
         BZ    NOFPARAM
         MVC   BUFFER+9(L'KFORMAL),KFORMAL  HANDLING FORMAL PARAMETERS
         SR    R5,R5
         IC    R5,7(,PBT)              PARAMETERS BY EIGHT
         SLL   R5,3                    MULTIPLY NUMBER OF FORMAL
         TM    6(PBT),X'08'
         BZ    NOTYPE
         LA    R5,8(,R5)               ADD EIGHT IF TYPE PROCEDURE
NOTYPE   AR    R5,R9                   END OF FORMAL PARAMETERS IN R5
         BAL   R4,TRANSDAT             PRINT FORMAL PARAMETERS
NFPARM   OI    FLAG,X'04'              SET SKIP FLAG
         BAL   R3,OUTPUT               LAST PARAMETERS
NOFPARAM LH    R2,4(,PBT)              GET END OF OBJECT TIME STACK
         LA    R5,0(R2,CDSA)
         CR    R9,R5
         BNL   ARRAYS
*
***********************************************************************
*
*        EDIT OBJECT TIME STACK
*
***********************************************************************
*
         MVC   BUFFER+9(L'IHIERM05),IHIERM05
         NI    FLAG,X'7D'              BUFFER AND ARRAY FLAG
         LTR   R1,R1                   ANY FORMAL PARAMETER PRINTED
         BNZ   NOTZERO
         B     MULT32A
*
MULT32   SRDL  R0,27
MULT32A  OI    FLAG,X'80'              BUFFER FLAG
         LA    R4,NFPARM
         B     TRANSDAT
*
NOTZERO  SLDL  R0,27                   TEST IF END OF LINE
         LTR   R1,R1
         BZ    MULT32                  YES, BRANCH TO MULT32
         SRDL  R0,27
         CR    R9,R5                   TEST IF ANY DATA TO BE PRINTED
         BNL   NFPARM
         BAL   R3,OUTPUT               YES, PRINT HEADING
         STC   R1,IF16                 TEST IF TIME FOR ONE STEP
         NI    IF16,X'0F'
         BNZ   LABAA
         LA    R8,1(,R8)
LABAA    BAL   R4,INSETDA
         B     NFPARM
*
***********************************************************************
*
*        CONVERSION OF DATA FOR PRINTING AND EDITING OF THE OUTPUT
*
***********************************************************************
*
TRANSDAT CR    R9,R5                   TEST IF MORE DATA IS TO BE
         BNLR  R4                      EDITED
         SLDL  R0,27
         LTR   R1,R1                   PRINT BUFFER IF END OF LINE
         BZ    SETDISP
         SLDL  R0,1
         LTR   R1,R1                   IF INDEX MULTIPLE OF 16 THEN
         BNZ   SHIFTB                  MAKE ONE EXTRA SPACE
         LA    R8,1(,R8)
SHIFTB   SRDL  R0,28
TRANS    UNPK  0(9,R8),0(5,R9)         UNPACK HEXADECIMAL DATA FOR
         MVI   8(R8),C' '              PRINTING
         TR    0(8,R8),TRTABLE-240
         LA    R1,4(R1)
         LA    R8,10(R8)
         LA    R9,4(R9)
         B     TRANSDAT
*
***********************************************************************
*
*        DISPLACEMENT FOR DATA EDITED
*
***********************************************************************
*
SETDISP  SRDL  R0,27
         BAL   R3,OUTPUT
         TM    FLAG,X'02'              CHECK IF EDITING ARRAYS TO GET
         BO    ADDR                    RIGHT DISPLACEMENT
INSETDA  LA    R3,24(,R1)
INSETD   ST    R3,WORKD                UNPACK HEXADECIMAL ADDR FOR
         UNPK  BUFFER(7),WORKD+1(4)    PRINTING
         OI    BUFFER+6,C' '
         TR    BUFFER(6),TRTABLE-240
         TM    FLAG,X'80'              PRINTING IS TO BE CONTINUED ?
         BZ    INSETDB                 AND NOT START AT THE
         LA    R8,BUFFER+9             BEGINNING OF A NEW LINE
INSETDB  OI    FLAG,X'80'
         B     TRANS
*
ADDR     LR    R3,R1                   DISPLACEMENT FOR ARRAY
         B     INSETD
*
***********************************************************************
*
*        EDITING OF DECLARED ARRAYS
*
***********************************************************************
*
ARRAYS   ICM   R2,B'1111',12(CDSA)     ANY DECLARED ARRAYS ?
         BZ    VALUE
MOREARRY OI    FLAG,X'02'
VARRSMF  L     R9,8(R2,CDSA)           STARTING ADDR OF ARRAY
         ST    R2,WORKD                UNPACK HEXADECIMAL DISPLACEMENT
         UNPK  ERM06SMF,WORKD+1(4)     OF SMF FOR PRINTING
         MVI   ERM06SMF+6,C' '
         TR    ERM06SMF(6),TRTABLE-240
         MVC   BUFFER+9(ERM06L),IHIERM06
         L     R5,12(R2,CDSA)          END ADDR OF ARRAY
         SR    R1,R1
         BAL   R4,TRANSDAT
         L     R2,0(R2,CDSA)           GET CHAINING ADDR
         LA    R2,0(,R2)
         OI    FLAG,X'04'              SET SKIP FLAG
         BAL   R3,OUTPUT               PRINT LAST LINE
         LTR   R2,R2
         BNZ   MOREARRY
*
***********************************************************************
*
*        EDITING OF VALUE ARRAYS
*
***********************************************************************
*
VALUE    LH    R2,10(CDSA)             TEST FOR VALUE ARRAYS
         LTR   R2,R2
         BZ    ENDVALAR
VALARRAY OI    FLAG,X'02'
         ST    R2,WORKD                UNPACK HEX DISPLACEMENT OF
         UNPK  ERM07SMF,WORKD+1(4)     SMF FOR PRINTING
         MVI   ERM07SMF+6,C' '
         TR    ERM07SMF(6),TRTABLE-240
         MVC   BUFFER+9(ERM07L),IHIERM07   TO BUFFER
         L     R9,0(R2,CDSA)           ADDR OF SMF
         L     R5,12(,R9)              END OF ARRAY
         L     R9,8(,R9)               BEGINNING OF ARRAY
         SR    R1,R1
         BAL   R4,TRANSDAT             PRINT DATA
         OI    FLAG,X'04'
         BAL   R3,OUTPUT               PRINT LAST LINE
         L     R9,0(R2,CDSA)           GET CHAINING DISPLACEMENT
         LH    R2,2(,R9)
         LTR   R2,R2
         BZ    ENDVALAR
         B     VALARRAY
*
ENDVALAR BAL   R3,OUTPUT               PRINT ONE EXTRA BLANK LINE
         OI    FLAG,X'04'
         NI    FLAG,X'FD'              RESET ARRAY FLAG
         B     RELDSA
*
***********************************************************************
*
*        PRINT THE MSG BUFFER BY USING THE IHIIORNX ROUTINE
*
***********************************************************************
*
OUTPUT   STM   R5,R8,40(R12)           SAVE REGS USED
         LA    R6,1                    SET THE DATASET NUMBER TO 1
         L     R5,ADSTAB(R12)          ENTRY OF DSN=1 IN DSTAB
         LA    R5,DSTABLEL+4(,R5)      R5 -> DSTABLE ENTRY FOR DSN 1
         L     R8,R
         OI    DSF,DS3                 SET DS3 = 1
         MVC   0(L'BUFFER,R8),BUFFER   MOVE BUFFER TO OUTPUT
         LR    R0,R14                  SAVE ADDR OF RETURN STACK PTR
         L     R15,VIORNX
         BALR  R14,R15                 CALL NEXT RECORD ROUTINE
         TM    FLAG,X'04'
         BZ    NOFLAG
         LH    R6,S                    INCREASE S-COUNTER IN DSTAB
SCOUNT   LA    R6,2(,R6)
         STH   R6,S
         L     R5,R                    SKIP LINES IF SKIP FLAG IS SET
         BCTR  R5,0                    AND NOT TIME FOR NEW PAGE
         CLI   0(R5),C'1'              SKIP TO NEW PAGE ?
         BE    RESFLAG                 YES, BRANCH
         MVC   0(1,R5),SPACE
RESFLAG  NI    FLAG,X'FB'              RESET SKIP FLAG
NOFLAG   LR    R14,R0                  RESTORE RETURN STACK PTR
         SR    R0,R0
         MVI   BUFFER,C' '             BLANK BUFFER AFTER PRINTING
         MVC   BUFFER+1(L'BUFFER-1),BUFFER
         LM    R5,R8,40(R12)
         BR    R3                      RETURN TO CALLER
*
SAVEAREA DC    18F'0'
*
WORKD    DC    D'0'
TRTABLE  DC    C'0123456789ABCDEF'     TRANSLATION TABLE
FLAG     DC    X'84'
SPACE    DC    C'-'                    ASA CNTL CHAR
IF16     DS    0C
DSNUMBER DC    X'00'
BUFFER   DC    CL90' '                 MESSAGE BUFFER
SCPATTN  DC    X'402020202020'         PATTERN FOR SEMICOLON COUNT
BNPATTN  DC    X'40202020'             PATTERN FOR BLOCK NUMBER
*
*        HEADINGS
*
IHIERM02 DC    C'MODULE = '
ERM02M   DC    CL8' '
         DC    C'  PROGRAM BLOCK NUMBER = '
ERM02BN  DC    C'    '
         DC    C' ('
ERM02TP  DC    CL16' '
ERM02L   EQU   *-IHIERM02              L'IHIERM02
*
ERM02BK  DC    CL16'BLOCK)          '  *
         DC    CL16'PROCEDURE)      '  |
         DC    CL16'TYPE PROCEDURE) '  V
*
KFORMAL  DC    C'FORMAL PARAMETERS'
*
IHIERM05 DC    C'DECLARED IDENTIFIERS AND OBJECT TIME STACK'
*
IHIERM06 DC    C'SMF DISPLACEMENT IN DSA = '
ERM06SMF DC    CL7' '
         DC    C'DECLARED ARRAY'
ERM06L   EQU   *-IHIERM06              L'IHIERM06
*
IHIERM07 DC    C'SMF DISPLACEMENT IN DSA = '
ERM07SMF DC    CL7' '
         DC    C'ARRAY CALLED BY VALUE'
ERM07L   EQU   *-IHIERM07              L'IHIERM07
*
***********************************************************************
*
*        EXTERNAL ADDRS

***********************************************************************
*
*        PASSED IN PARAMETER LIST FROM CALLER IHIFSA
*
VFRDSA   DC    A(0)      V(FRDSA)
VSPDAP   DC    A(0)      V(SPDAP)
VIOROP   DC    A(0)      V(IHIIOROP)
VIORCP   DC    A(0)      V(IHIIORCP)
VIORNX   DC    A(0)      V(IHIIORNX)
*
*        ADDRS IN IHIERMSG MODULE
*
VERMSG   DC    V(IHIERMSG)
VERM01   DC    V(IHIERM01)
*
FSARE    DSECT
*
         COPY  FSAREA
*
*        DATASET TABLE MAPPING DSECT
*
         DSTABLE DSECT=YES
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIFDD   0201-12230-12230-1200-00104-00104-00000-LEVEL
FDD        TITLE 'IHIFDDXP, POWER ROUTINE, REAL**REAL, LONG PRECISION, X
               ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION - SEE CODE
*
*        ENTRY POINT - IHIFDD - POWER FUNCTION, REAL**REAL, LONG
*                      LA   R1,PARMLIST
*                      BALR R14,R15
*                      DATA PASSED BY NAME
*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES -
*
*        IHILLO - LOGARITHM FUNCTION, LONG PRECISION
*        IHILEX - EXPONENTIAL FUNCTION, LONG PRECISION
*
*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0
*
*        EXIT - ERROR -
*        IF BASE IS ZERO AND EXPONENT NOT POSITIVE GOTO ERROR
*        ROUTINE VIA
*        B    FSAERR+35*4(R13)
*
*        TABLES/WORKAREAS - N/A
*
IHIFDDXP CSECT
*
*        FLOATING POINT REGISTERS
*
FPR0     EQU   0                       BASE NO, PASSING RESULT
FPR2     EQU   2                       EXPONENT IN COMPUTATION
*
*        GENERAL PURPOSE REGISTERS
*
*        R1                            PARAMETER LIST REF
*        R3                            INDEXING PARAMETER ADDR
*
         ENTRY IHIFDD
*
IHIFDD   SAVE  (14,12),,'IHIFDDXP LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R2,R15
         USING IHIFDDXP,R2
         LR    R3,R13                  CHAIN SAVE AREAS
         LA    R13,SAVEAREA
         ST    R3,4(,R13)
         ST    R13,8(,R3)
         L     R3,0(,R1)               PLIST OF BASE NO IN R3
         LD    FPR0,0(,R3)             BASE NO INTO FPR0
         L     R3,4(,R1)               PLIST OF EXPONENT IN R3
         LD    FPR2,0(,R3)             EXPONENT INTO FPR2
         LTDR  FPR0,FPR0               BASE NO +, - OR ZERO ?
         BZ    ERROR                   ZERO, BRANCH TO ERROR
         BM    ERRORM                  NEGATIVE, UNDEFINED ERROR
         LTDR  FPR2,FPR2               EXPONENT PLUS, MINUS, OR ZERO ?
         BZ    LOAD1                   ZERO, BRANCH TO LOAD1
         STD   FPR2,PARAM              STORE EXPONENT
         L     R15,VIHILLO             R15 -> IHILLO ROUTINE
         BALR  R14,R15                 CALL IHILLO ROUTINE
         LD    FPR2,PARAM              RELOAD FPR2 WITH EXPONENT
         MDR   FPR0,FPR2               MULT LOG OF BASE NO BY EXPONENT
         STD   FPR0,PARAM              STORE RESULT AS EXP RTN PARM
         LA    R1,ADCPAR               R1 -> EXP RTN PARM
         L     R15,VIHILEX             R15 -> IHILEX ROUTINE
         BALR  R14,R15                 CALL IHILEX ROUTINE
         B     EXIT                    EXIT WITH RESULT IN FPR0
*
LOAD1    LD    FPR0,KFPDONE            PLUS 1 AS RESULT IN FPR0
EXIT     L     R13,4(,R13)             R13 -> CALLERS SAVE AREA
*
         RETURN (14,12)                RESTORE CALLERS REGS AND RETURN
*
ERROR    LTDR  FPR2,FPR2               EXPONENT PLUS, MINUS, OR ZERO ?
         BP    EXIT                    EXPN IS POSITIVE, BRANCH TO EXIT
ERRORM   L     R13,4(R13)              R13 -> CALLERS SAVE AREA
         B     FSAERR+35*4(R13)        BASENO EQUAL ZERO AND EXPONENT
*                                      NO GREATER THAN ZERO, UNDERFINED
*
*        CONSTANTS AND ADCON AREAS
*
SAVEAREA DC    18F'0'                  SAVE AREA
PARAM    DC    D'0'                    PARAM FOR DATA IN DEXP MATH RTN
KFPDONE  DC    D'+1'                   CONSTANT ONE IN DOUBLE PREC FP
*
ADCPAR   DC    A(PARAM)                ADDR OF PARAMETER FOR EXP RTN
*
VIHILLO  DC    V(IHILLO)               LOG MATH LIBRARY ROUT
VIHILEX  DC    V(IHILEX)               EXP MATH LIBRARY ROUT
*
FSAERR   EQU   X'1CC'
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIFDI   0201-12230-12230-1200-00099-00099-00000-LEVEL
FDI      TITLE 'IHIFDIXP, POWER ROUTINE, REAL**INTEGER, LONG PRECISION,X
                ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION - SEE CODE
*
*        ENTRY POINT -
*        IHIFDI - POWER FUNCTION, REAL**INT, LONG
*        LA     R1,PARMLIST
*        BALR   R14,R15
*        DATA PASSED BY NAME
*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0
*
*        EXIT - ERROR -
*        IF BASE IS ZERO AND EXPONENT NOT POSITIVE GOTO ERROR
*        ROUTINE VIA
*        B    FSAERR+35*4(R13)
*
*        TABLES/WORKAREAS - N/A
*
IHIFDIXP CSECT
*
         ENTRY   IHIFDI
*
*        FLOATING POINT REGISTERS
*
FPR0     EQU   0                       BASE NO, PASSING RESULT
FPR2     EQU   2                       FACTOR, COMPUTING RESULT
*
*        GENERAL PURPOSE REGISTERS
*
*        R0                            TESTING FOR MINUS EXPN
*        R2                            EXPONENT IN COMPUTATION
*
IHIFDI   SAVE  (14,12),,'IHIFDIXP LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHIFDIXP,R15
         L     R3,0(,R1)               LOAD PLIST OF BASE NO IN R3
         LD    FPR0,0(,R3)             LOAD BASE NO INTO FPR0
         L     R3,4(0,R1)              LOAD PLIST OF EXPONENT IN R3
         L     R2,0(0,R3)              LOAD EXPONENT INTO R2
         LTDR  FPR0,FPR0               BASE NO +, - OR ZERO ?
         BZ    ERROR                   ZERO, BRANCH TO ERROR
         SR    R0,R0                   SET NEGATIVE EXPN SWITCH TO 0
         LTR   R2,R2                   EXPONENT +, - OR ZERO ?
         BP    PLUS                    +VE, BRANCH TO PLUS
         BZ    LOAD1                   ZERO, BRANCH TO LOAD1
         LCR   R2,R2                   MINUS, CONVERT TO 2S COMPLIMENT
         LA    R0,1                    SET EXP SW TO ONE FOR MINUS EXPN
PLUS     LD    FPR2,KFPDONE            LOAD FACTOR OF ONE IN FPR2
LOOP     SRDL  R2,1                    SHIFT LOW BIT R2 INTO R3
         LTR   R3,R3                   LOWORDER BIT OF R2 MAKE R3 NEG ?
         BNM   JUMP                    NO, BRANCH TO JUMP
         MDR   FPR2,FPR0               YES, MULTIPLY FPR2 BY FPR0
JUMP     LTR   R2,R2                   EXPONENT +, - OR ZERO ?
         BZ    NEXT                    EXPONENT ZERO, BRANCH TO NEXT
         MDR   FPR0,FPR0               MULT FPR0 NO BY DOUBLING ITSELF
         B     LOOP                    LOOP TO TEST NEXT EXPN BIT
*
NEXT     LTR   R0,R0                   R0 +, - OR ZERO ?
         BZ    SWAP                    EXPN ¬ MINUS, BRANCH TO SWAP
         LD    FPR0,KFPDONE            LOAD ONE IN FPR0 AS DIVIDEND
         DDR   FPR0,FPR2               DIV FPR0  BY FPR2 (RESULT)
         B     EXIT                    EXIT (RESULT IN FPR0)
*
SWAP     LDR   FPR0,FPR2               LOAD FPR2 INTO FPR0
         B     EXIT                    EXIT (RESULT IN FPR0)
*
LOAD1    LD    FPR0,KFPDONE            LOAD PLUS 1 AS RESULT IN FPR0
*
EXIT     RETURN (14,12)                RESTORE CALLERS REGS AND RETURN
*
ERROR    LTR   R2,R2                   EXPONENT +, - OR ZERO ?
         BP    EXIT                    EXPN IS POSITIVE, BRANCH TO EXIT
         B     FSAERR+35*4(13)         BASE NO = ZERO AND EXPONENT
*                                      ¬> ZERO, UNDEFINED
*
*        ADCONS AND CONSTANTS AREA
*
KFPDONE  DC    D'+1'                   CONSTANT ONE IN DOUBLE PREC FP
*
FSAERR   EQU   X'1CC'
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIFII   0201-12230-12230-1200-00107-00107-00000-LEVEL
FII      TITLE 'IHIFIIXP, POWER ROUTINE, INTEGER**INTEGER, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION - SEE CODE
*
*        ENTRY POINT -
*        IHIFII - POWER FUNCTION, INT**INT
*        LA     R1,PARMLIST
*        BALR   R14,R15
*        DATA PASSED BY NAME
*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXIT - NORMAL - RETURN VIA R14, RESULT IN R0
*
*        EXIT - ERROR -
*        IF BASE IS ZERO AND EXPONENT NOT POSITIVE GOTO ERROR
*        ROUTINE VIA
*        B    FSAERR+35*4(R13)
*
*        TABLES/WORKAREAS - N/A
*
IHIFIIXP CSECT
*
*        GENERAL PURPOSE REGISTERS
*
*        R0                            PASSING ON FINAL RESULT
*        R1                            PARAMETER LIST REF
*        R2                            MPY REG FOR FACTOR
*        R3                            FACTOR AND ANSWER
*        R4                            MPY REG FOR BASE NO
*        R5                            BASE NO IN COMPUTATION
*        R6                            EXPONENT IN COMPUTATION
*        R7                            INDEXING PARAMETER ADDR
*
IHIFII   SAVE  (14,12),,'IHIFIIXP LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHIFIIXP,R15
         L     R7,0(,R1)               LOAD PLIST OF BASE NO IN R7
         L     R5,0(,R7)               LOAD BASE NO INTO R5
         L     R7,4(,R1)               LOAD PLIST OF EXPONENT IN R7
         L     R6,0(,R7)               LOAD EXPONENT INTO R6
         LTR   R0,R5                   LOAD BASE NO INTO RESULT REG
*                                      BASE NO +, - OR ZERO ?
         BZ    ERROR                   ZERO, BRANCH TO ERROR
         LTR   R6,R6                   EXPONENT +, - OR ZERO ?
         BZ    LOAD1                   ZERO, BRANCH TO LOAD1
         BCTR  R5,0                    DECR VALUE OF BASE NO
         LTR   R5,R5                   BASE NO + - OR ZERO ?
         BZ    EXIT                    ZERO, BRANCH TO EXIT
         LA    R5,2(,R5)               INCR BY TWO VALUE OF BASE NO
         LTR   R5,R5                   BASE NO +, - OR ZERO ?
         BZ    TEST                    ZERO, BRANCH TO TEST
         LTR   R6,R6                   EXPONENT +, - OR ZERO ?
         BP    PLUS                    POSITIVE, BRANCH TO PLUS
         SR    R0,R0                   EXPN MINUS, RESULT = ZERO
         B     EXIT                    EXIT ROUTINE
*
PLUS     LR    R5,R0                   RELOAD ORG BASE NO FROM RESULT
         L     R3,KF1                  LOAD FACTOR OF ONE IN R3
LOOP     SRDL  R6,1                    SHIFT LOW BIT R6 INTO R7
         LTR   R7,R7                   LOWORDER BIT OF R6 MAKE R7 NEG ?
         BNM   JUMP                    NO, BRANCH TO JUMP
         MR    R2,R5                   MULTIPLY FACTOR REG BY R5
         SLDA  R2,32                   CHECK OVERFLOW
         SRDA  R2,32
JUMP     LTR   R6,R6                   EXPONENT +, - OR ZERO ?
         BZ    NEXT                    EXPONENT ZERO, BRANCH TO NEXT
         MR    R4,R5                   MULT BASE NO BY DOUBLING ITSELF
         SLDA  R4,32
         SRDA  R4,32
         B     LOOP                    LOOP TO TEST NEXT EXPN BIT
*
NEXT     LR    R0,R3                   LOAD FACTOR INTO RESULT
         B     EXIT                    EXIT
*
TEST     SRDL  R6,1                    SHIFT LOW BIT R6 INTO R7
         LTR   R7,R7                   LOWORDER BIT OF R6 MAKE R7 NEG ?
         BM    EXIT                    MINUS (EXPN ODD), GOTO EXIT
LOAD1    L     R0,KF1                  LOAD R0 WITH VALUE OF PLUS 1
EXIT     STM   R0,R1,20(R13)           UPDATE SAVEAREA WITH RESULT
*
         RETURN (14,12)                RESTORE CALLERS REGS AND RETURN
*
ERROR    LTR   R6,R6                   EXPONENT +, - OR ZERO ?
         BP    EXIT                    EXPN IS POSITIVE, BRANCH TO EXIT
         B     FSAERR+35*4(R13)
*
*        ADCONS AND CONSTANTS AREA
*
KF1      DC    F'1'                    INTERGER CONSTANT OF ONE
*
FSAERR   EQU   X'1CC'
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIFRI   0201-12230-12230-1200-00099-00099-00000-LEVEL
FRI   TITLE 'IHIFRIPXP, POWER ROUTINE, REAL**INTEGER, SHORT PRECISION, X
               ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION - SEE CODE
*
*        ENTRY POINT -
*        IHIFRI - POWER FUNCTION, REAL**INT, SHORT
*                 LA     R1,PARMLIST
*                 BALR   R14,R15
*                 DATA PASSED BY NAME
*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0
*
*        EXIT - ERROR -
*        IF BASE IS ZERO AND EXPONENT NOT POSITIVE GOTO ERROR
*        ROUTINE VIA
*        B    FSAERR+35*4(R13)
*
*        TABLES/WORKAREAS - N/A
*
IHIFRIXP CSECT
*
         ENTRY   IHIFRI
*
*        FLOATING POINT REGISTERS
*
FPR0     EQU   0                       REG FOR BASE NO, PASSING RESULT
FPR2     EQU   2                       REG FOR FACTOR, COMPUTING RESULT
*
*        GENERAL PURPOSE REGISTERS
*
*        R0                            REG FOR TESTING FOR MINUS EXPN
*        R2                            REG FOR EXPONENT IN COMPUTATION
*
IHIFRI   SAVE  (14,12),,'IHIFRIXP LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHIFRIXP,R15
         L     R3,0(,R1)               LOAD PLIST OF BASE NO IN R3
         LE    FPR0,0(,R3)             LOAD BASE NO INTO FPR0
         L     R3,4(,R1)               LOAD PLIST OF EXPONENT IN R3
         L     R2,0(,R3)               LOAD EXPONENT INTO R2
         LTER  FPR0,FPR0               BASE NO +, - OR ZERO ?
         BZ    ERROR                   ZERO, BRANCH TO ERROR
         SR    R0,R0                   SET NEGATIVE EXPN SWITCH TO 0
         LTR   R2,R2                   EXPONENT +, - OR ZERO ?
         BP    PLUS                    +VE, BRANCH TO PLUS
         BZ    LOAD1                   ZERO, BRANCH TO LOAD1
         LCR   R2,R2                   MINUS, CONVERT TO 2S COMPLIMENT
         LA    R0,1                    SET EXP SW TO ONE FOR MINUS EXPN
PLUS     LE    FPR2,KFPONE             LOAD FACTOR OF ONE IN FPR2
LOOP     SRDL  R2,1                    SHIFT LOW BIT R2 INTO R3
         LTR   R3,R3                   LOWORDER BIT OF R2 MAKE R3 NEG ?
         BNM   JUMP                    NO, BRANCH TO JUMP
         MER   FPR2,FPR0               YES, MULTIPLY FPR2 BY FPR0
JUMP     LTR   R2,R2                   EXPONENT +, -, OR ZERO ?
         BZ    NEXT                    EXPONENT ZERO, BRANCH TO NEXT
         MER   FPR0,FPR0               MULT BASE NO BY DOUBLING ITSELF
         B     LOOP                    LOOP TO TEST NEXT EXPN BIT
*
NEXT     LTR   R0,R0                   R0 +, - OR ZERO ?
         BZ    SWAP                    EXPN ¬ MINUS, BRANCH TO SWAP
         LE    FPR0,KFPONE             LOAD ONE IN FPR0 AS DIVIDEND
         DER   FPR0,FPR2               DIV BASE REG BY FPR2 (RESULT)
         B     EXIT                    EXIT (RESULT IN FPR0)
*
SWAP     LER   FPR0,FPR2               LOAD FPR2 INTO FPR0
         B     EXIT                    EXIT (RESULT IN FPR0)
*
LOAD1    LE    FPR0,KFPONE             LOAD PLUS 1 AS RESULT IN FPR0
*
EXIT     RETURN (14,12)                RESTORE CALLERS REGS AND RETURN
*
ERROR    LTR   R2,R2                   EXPONENT +, - ZERO ?
         BP    EXIT                    EXPN IS POSITIVE, BRANCH TO EXIT
         B     FSAERR+35*4(R13)        BASE NO = ZERO AND EXPONENT
*                                      ¬> ZERO, UNDEFINED
*
*        ADCONS AND CONSTANTS AREA
*
KFPONE   DC    E'1'                    CONSTANT ONE IN SINGLE PREC FP
*
FSAERR   EQU   X'1CC'
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIFRR   0201-12230-12230-1200-00105-00105-00000-LEVEL
FRR       TITLE 'IHIFRRXP, POWER ROUTINE, REAL**REAL, SHORT PRECISION, X
               ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION - SEE CODE
*
*        ENTRY POINT -
*        IHIFRR - POWER FUNCTION, REAL**REAL, SHORT
*                 LA     R1,PARMLIST
*                 BALR   R14,R15
*                 DATA PASSED BY NAME
*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES -
*        IHISLO - LOGARITHM FUNCTION, SHORT PRECISION
*        IHISEX - EXPONENTIAL FUNCTION, SHORT PRECISION
*
*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0
*
*        EXIT - ERROR -
*        IF BASE IS ZERO AND EXPONENT NOT POSITIVE GOTO ERROR
*        ROUTINE VIA
*        B    FSAERR+35*4(R13)
*
*        TABLES/WORKAREAS - N/A
*
IHIFRRXP CSECT
*
         ENTRY   IHIFRR
*
*        FLOATING POINT REGISTERS
*
FPR0     EQU   0                       BASE NO, PASSING RESULT
FPR2     EQU   2                       EXPONENT IN COMPUTATION
*
*        GENERAL PURPOSE REGISTERS
*
*        R1                            PARAMETER LIST REF
*        R2                            SECOND BASE ADDR
*        R3                            INDEXING PARAMETER ADDR
*
IHIFRR   SAVE  (14,12),,'IHIFRRXP LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R2,R15
         USING IHIFRRXP,R2
         LR    R3,R13                  CHAIN SAVE AREAS
         LA    R13,SAVEAREA
         ST    R3,4(,R13)
         ST    R13,8(,R3)
         L     R3,0(,R1)               LOAD PLIST OF BASE NO IN R3
         LE    FPR0,0(,R3)             LOAD BASE NO INTO FPR0
         L     R3,4(,R1)               LOAD PLIST OF EXPONENT IN R3
         LE    FPR2,0(,R3)             LOAD EXPONENT INTO FPR2
         LTER  FPR0,FPR0               BASE NO +, - OR ZERO ?
         BZ    ERROR                   ZERO, BRANCH TO ERROR
         BM    ERRORM                  NEGATIVE UNDEFINED, ERROR
         LTER  FPR2,FPR2               EXPONENT +, - OR ZERO ?
         BZ    LOAD1                   ZERO, BRANCH TO LOAD1
         STE   FPR2,PARAM              STORE EXPONENT IN PARAM
         L     R15,VIHISLO             R15 -> IHISLO ROUTINE
         BALR  R14,R15                 CALL IHISLO ROUTINE
         LE    FPR2,PARAM              RELOAD FPR2 WITH EXPONENT
         MER   FPR0,FPR2               MULT LOG OF BASE NO BY EXPONENT
         STE   FPR0,PARAM              STORE RESULT IN PARAM
         LA    R1,ADCPAR               R1 -> EXP RTN PARAM
         L     R15,VIHISEX             R15 -> IHISEX ROUTINE
         BALR  R14,R15                 CALL IHISEX ROUTINE
         B     EXIT                    EXIT (RESULT IN FPR0)
*
LOAD1    LE    FPR0,KFPONE             LOAD PLUS 1 AS RESULT IN FPR0
EXIT     L     R13,4(,R13)             R13 -> CALLERS SAVE AREA
*
         RETURN (14,12)                RESTORE CALLERS REGS AND RETURN
*
ERROR    LTER  FPR2,FPR2               EXPONENT +, - OR ZERO
         BP    EXIT                    EXPN IS POSITIVE, BRANCH TO EXIT
ERRORM   L     R13,4(,R13)             R13 -> CALLERS SAVE AREA
         B     FSAERR+35*4(R13)        BASE NO = ZERO AND EXPONENT
*                                      ¬> ZERO, UNDEFINED
*
*        CONSTANTS AND ADCON AREAS
*
SAVEAREA DC    18F'0'                  SAVE AREA
PARAM    DC    F'0'                    PARAM FOR DATA IN EXP MATH RTN
KFPONE   DC    E'1'                    CONSTANT ONE IN SINGLE PREC FP
*
ADCPAR   DC    A(PARAM)                ADDR OF PARAMETER FOR EXP RTN
*
VIHISLO  DC    V(IHISLO)               LOG MATH LIBRARY ROUTINE
VIHISEX  DC    V(IHISEX)               EXP MATH LIBRARY ROUTINE
*
FSAERR   EQU   X'1CC'
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIFSA   0201-12230-12230-1200-02271-02271-00000-LEVEL
FSA      TITLE 'IHIFSA, RUNTIME FIXED STORAGE AREA, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        FUNCTION/OPERATION -
*        IHIFSA IS A COLLECTION OF ABOUT 20 ROUTINES WHICH ARE
*        REQUIRED FOR THE EXECUTION OF ALGOL PROGRAMS. THE ENTRY
*        POINT AND PURPOSE OF EACH ROUTINE IS LISTED UNDER ENTRY
*        POINTS BELOW DETAILED INFORMATION ON THE FUNCTION,
*        CALLING SEQUENCE, TRANSMISSION OF PARAMETERS ETC CAN BE
*        FOUND IN THE COMMENTARY WHICH PRECEDES THE PROGRAM
*        LISTING FOR EACH ROUTINE
*
*        THE MODULE CONSISTS OF TWO CONTROL SECTIONS, IHIFSARA
*        AND IHIFSARB.
*        IHIFSARA CONTAINS THE ROUTINES, TABLES AND OTHER
*        INFORMATION USED DURING THE EXECUTION OF THE ALGOL
*        OBJECT PROGRAM
*        IHIFSARB CONTAINS MAINLY THE INITIALIZATION AND
*        TERMINATION ROUTINES WITH THEIR ASSOCIATED TABLES AND
*        WORK AREAS
*
*        R13 - BASE REGISTER FOR IHIFSARA
*        R7  - BASE REGISTER FOR IHIFSARB
*
*        ENTRY POINTS -
*        MOST OF THE ENTRY POINTS LISTED HERE ARE COLLECTED IN A
*        BRANCH LIST LOCATED AT BRLIST. THE ENTRY POINTS
*        CONTAINED IN THIS BRANCH LIST ARE MARKED WITH AN
*        ASTERISK AFTER THE NAME IN THE LISTING BELOW
*
*        CAP1*     - CALL ACTUAL PARAMETER
*                    PART 1. ENTER THUNK ROUTINE FROM A PROCEDURE
*        CAP2*     - CALL ACTUAL PARAMETER
*                    PART 2. RETURN FROM THE THUNK ROUTINE TO
*                    THE PROCEDURE
*        PROLOGP*  - ENTER A PROCEDURE WHEN IT IS CALLED VIA AN
*                    ACTUAL PARAMETER
*        PROLOG*   - ENTER A BLOCK OR A PROCEDURE
*        RETPROG*  - LEAVE A BLOCK OR PROCEDURE VIA A 'GO TO'
*                    STATEMENT
*        EPILOGP*  - RETURN FROM A PROCEDURE VIA THE 'END'
*                    STATEMENT
*        EPILOGB*  - LEAVE A BLOCK VIA THE 'END' STATEMENT
*        FRDSA     - FREE STORAGE FOR DSA AND ARRAYS
*                    SYNONYM FOR EPILOGB WHEN USED AS A SUBROUTINE
*                    BY THE ERROR ROUTINE IHGERROR
*        CSWE1*    - CALL SWITCH ELEMENT, PART 1
*        CSWE2*    - CALL SWITCH ELEMENT, PART 2
*        LOADPP*   - LOAD A PRECOMPILED PROCEDURE
*        SPDECL    - STANDARD PROCEDURE DECLARATION ROUTINE
*                    (ENTERED VIA THE PROLOG ROUTINE)
*        VALUCALL* - HANDLE FORMAL PARAMETERS CALLED BY VALUE
*        GETMSTO*  - GET MAIN STORAGE FOR ARRAYS
*        CNVIRD    - CONVERT INTEGER TO REAL
*        CNVRDI    - CONVERT REAL TO INTEGER
*        ENTIER    - EXECUTE ALGOL ENTIER FUNCTION
*        TRACE*    - STORE THE CURRENT SEMICOLON NUMBER
*        IHGFSAIN  - INITIALIZE FOR PROGRAM EXECUTION AND GIVE
*                    CONTROL TO THE OBJECT MODULE
*        TERMNTE*  - TERMINATE THE EXECUTION
*        PIEROUT   - PROGRAM INTERRUPT ROUTINE
*        FSAERR    - STORE ERROR NUMBER AND CALL THE ERROR
*                    ROUTINE IHIERROR
*
*        INPUT -
*        IF THE TRACE OPTION IS USED, THE TERMINATION ROUTINE MAY
*        READ A TABLE OF SEMICOLON NUMBERS, WHICH HAS BEEN
*        WRITTEN ON SYSUT1 BY THE TRACE ROUTINE
*
*        OUTPUT -
*        IF THE TRACE OPTION IS USED, THE TRACE ROUTINE MAY WRITE
*        A TABLE OF SEMICOLON NUMBERS ON SYSUT1. THIS TABLE IS
*        READ AND THEN WRITTEN ON SYSPRINT IN EDITED FORMAT BY
*        THE TERMINATION ROUTINE.
*        THE MESSAGE 'END OF ALGOL PROGRAM EXECUTION' IS WRITTEN
*        ON SYSPRINT AS THE FINAL OUTPUT FROM THE EXECUTION.
*
*        EXTERNAL ROUTINES -
*        IHIIOROP - OPEN A DATASET (USED ONLY FOR SYSPRINT)
*        IHIIORCL - CLOSE A DATASET (USED ONLY FOR SYSPRINT)
*        IHIIORCP - CLOSE ALL OPEN DATASETS (EXCEPT SYSUT1)
*        IHIIORNX - HANDLE THE NEXT I/O RECORD
*        IHIERROR - EDIT AND PRINT AN ERROR MESSAGE AND, IF
*                   REQUESTED, AN ALGOL STORAGE DUMP.
*                   (ENTERED BY CALL)
*
*        THE FOLLOWING TWO EXTERNAL TABLES ARE IN THE OBJECT
*        MODULE -
*        IHIENTIF - INFORMATION NEEDED FOR ENTERING THE OBJECT MODULE
*             FORMAT -
*             IHIENTIF DC A(PBTAB)  ADDR OF PROGRAM BLOCK TABLE
*                      DC A(LATAB)  ADDR OF LABEL ADDR TABLE
*                      DC X'02' OR X'00' FOR SHORT/LONG PREC
*                      DC AL3(ENTRYPOINT)  ADDR OF FIRST INSTRUCTION
*
*        IHIDSTAB - INFORMATION ABOUT THE STATUS OF EACH DATASET USED
*             FORMAT AND USE -
*             SEE THE DSECT DSTABLE AND THE LISTING OF
*             THE I/O SUBROUTINE MODULE IHIIORTN
*
*        EXITS - NORMAL -
*        THE TERMINATION ROUTINE IS ENTERED BY A BRANCH TO
*        TERMNTE, AND A FINAL RETURN IS BY A RETURN MACRO WITH
*        THE RETURN CODE ZERO IN R15
*
*        EXITS - ERRORS -
*        ON RETURN FROM THE ERROR ROUTINE IHIERROR, THE
*        TERMINATION ROUTINE IS ENTERED BY A BRANCH TO ALGTRMA,
*        AND A FINAL RETURN IS MADE BY A RETURN MACRO WITH THE
*        RETURN CODE 16 IN R15
*
*        TABLES/WORK AREAS -
*        THE LOWER PART OF IHIFSARA CONTAINS A BLOCK OF WORK
*        AREAS AND CONSTANTS WHICH ARE USED IN COMMON BY SEVERAL
*        ROUTINES.
*        THE MOST IMPORTANT ARE -
*        SAVE     - STANDARD SAVEAREA USED BY ALL FIRST LEVEL
*                   SUBROUTINES EXCEPT THOSE CONTAINED IN THIS MODULE
*        ASAVE    - SAVE AREA USED BY SOME ROUTINES IN THIS MODULE
*        FCTVALST - STORAGE FOR THE RESULT OF AN ALGOL FUNCTION
*        PROLPBN  - PROGRAM BLOCK NUMBER OF A BLOCK OR PROCEDURE
*                   TO BE ENTERED VIA THE PROLOG ROUTINE
*        PGOPSW   - THE OLD PSW IN CASE OF A PROGRAM INTERRUPT
*        SCRCS    - THE CURRENT SEMICOLON NUMBER
*        OPTSW    - FLAG BITS REPRESENTING EXECUTION TIME OPTIONS
*                   AND SWITCHES FOR CONTROLLING THE PROGRAM FLOW
*        FSAERCOD - ERROR NUMBER IDENTIFYING AN EXECUTION ERROR
*        IHIFSARS - FOUR POINTERS FOR CONTROLLING THE RETURN
*                   ADDR STACK
*        BRLIST   - A LIST OF ENTRY POINTS TO MOST OF THE ROUTINES
*                   MENTIONED UNDER 'ENTRY POINTS'. THE LIST CONSISTS
*                   MAINLY OF BRANCH INSTRUCTIONS
*        IHIFSAER - A LIST OF BAL INSTRUCTIONS, EACH
*                   CORRESPONDING TO ONE TYPE OF ERROR, THE
*                   NUMBER OF WHICH IS DETERMINED BY ITS POSITION
*                   IN THE LIST
*
*        OTHER WORK AREAS AND CONSTANTS OF GENERAL
*        INTEREST ARE -
*        PARMLIST - A LIST OF THE VALID EXECUTION OPTION
*                   PARAMETERS
*        TRBUF    - BUFFER POINTERS AND RECORD COUNTER FOR
*                   CONTROLLING THE OUTPUT OF TRACING
*                   INFORMATION ON SYSUT1
*        PIETAB   - A LIST OF 16 ADDR CONSTANTS EACH POINTING
*                   TO AN ENTRY IN IHIFSAER, WHICH CORRESPONDS
*                   TO A TYPE OF PROGRAM INTERRUPT
*        FPINST   - A LIST OF FLOATING POINT INSTRUCTIONS USED BY
*                   THE VALUCALL AND SPDECL ROUTINES
*        CNVINSTE - INSTRUCTIONS TO BE INSERTED INTO THE CONVERT
*                   ROUTINE FOR SHORT PRECISION
*        CNVINSTD - INSTRUCTIONS TO BE INSERTED INTO THE CONVERT
*                   ROUTINE FOR LONG PRECISION
*
*        ATTRIBUTES - THIS MODULE IS SERIALLY REUSABLE
*
*        NOTES -
*        THIS MODULE IS ONLY INTENDED TO BE USED WHEN LINKAGE
*        EDITED TOGETHER WITH AN OS/360 ALGOL OBJECT MODULE AND
*        WITH THE OS/360 ALGOL I/O ROUTINES. FOR REASONS OF
*        EFFICIENCY CERTAIN LOCAL CONVENTIONS ARE OBEYED IN THE
*        COMMUNICATION BETWEEN THESE MODULES
*        REGISTER SAVING AND RESTORING IS ONLY DONE WHEN
*        REQUIRED AND THEN GENERALLY IN A NON STANDARD FASHION
*
*        USE OF GENERAL REGISTERS WHEN COMMUNICATING WITH THE
*        OBJECT MODULE -
*        R8 (ADR)    MAY BE USED AS RETURN REGISTER AND
*                    PARAMETER POINTER
*        R10 (CDSA)  -> CURRENT ACTIVE DATA STORAGE AREA
*        R11 (PBT)   -> PROGRAM BLOCK TABLE IN THE OBJECT MODULE
*        R12 (LAT)   -> LABEL ADDR TABLE IN THE OBJECT MODULE
*        R13 (FSA)   SERVES BOTH AS THE STANDARD SAVE AREA
*                    REGISTER AND AS BASE REGISTER FOR THE
*                    CSECT IHIFSARA
*        R14         TRANSMIT INTEGER VALUES TO OR
*                    FROM CONVERT ROUTINES
*        R15         RETURN REGISTER AND PARAMETER POINTER
*        FP0         TRANSMIT REAL VALUES TO OR FROM CONVERT ROUTINES
*
*        USE OF GENERAL REGISTERS WHEN COMMUNICATING WITH THE
*        I/O ROUTINES -
*
*        R5      (DSN)    -> RELEVANT ENTRY IN THE DATASET TABLE
*        R6      (DSNR)      DATASET NUMBER
*        R12     (FSAA)      BASE ADDR OF IHIFSARA
*
*        PARAMETER VALUES AND OTHER INFORMATION ARE OFTEN
*        TRANSMITTED IMPLICITLY VIA THE COMMONLY ACCESSIBLE
*        WORKING STORAGE IN THE LOWER PART OF IHIFSARA AND (FOR
*        I/O ROUTINES) VIA THE DATASET TABLE IN THE OBJECT
*        MODULE
*
*        THE MODULE WORKS FOR EITHER SINGLE OR DOUBLE FLOATING
*        POINT PRECISION. IT SENSES THE PRECISION FOR WHICH THE
*        OBJECT MODULE WAS COMPILED AND INITIALIZES ITSELF
*        ACCORDINGLY. THE AREAS AFFECTED ARE THE LIST OF FLOATING
*        POINT INSTRUCTIONS AT FPINST AND THE BLOCK OF
*        INSTRUCTIONS STARTING AT CNVINST IN THE CONVERT
*        ROUTINES
*
*        THE OPERATION OF THIS MODULE DEPENDS UPON AN INTERNAL
*        REPRESENTATION OF THE EXTERNAL CHARACTER SET WHICH IS
*        EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME
*
IHIFSARA CSECT
*
*        REGISTERS FOR COMMUNICATION WITH THE OBJECT MODULE
*
*        R8                            ADDRESSING REGISTER
GDSA     EQU   9                       GLOBAL DSA
CDSA     EQU   10                      CURRENT DSA
PBT      EQU   11                      PROGRAM BLOCK TABLE
LAT      EQU   12                      LABEL ADDR TABLE
*        R13                           IHIFSARA BASE REGISTER
*
*        REGISTERS FOR COMMUNICATION WITH I/O SUBROUTINES
*
*        R5                            -> DATASET TABLE ENTRY
*        R6                            DATASET NUMBER
FSAA     EQU   12                      ALTERNATE FSA BASE REGISTER
*
*        REGISTERS USED BY TRACE AND TERMINATION ROUTINES
*
*        R4                            BYTE POINTER IN TRACE BUFFER
*        R5                            SEMICOLON NUMBER
*        R6                            LOWER TRACE LIMIT
*        R7                            UPPER TRACE LIMIT
*        R8                            TRACE BUFFER ADDR
*        R9                            ALTERNATE TRACE BUFFER ADDR
*        R10                           LENGTH OF TRACE BUFFER
*        R11                           NUMBER OF TRACE RECORDS
*
*        FLOATING POINT REGISTER
*
FPR0     EQU   0
*
*        BIT PATTERNS
*
BETABM   EQU   X'0C'                   MASK FOR BETA BLOCK FLAG IN PBT
CODEPRM  EQU   X'10'                   MASK FOR CODE PROCEDURE IN PBT
PIMASK   EQU   X'04'                   MASK FOR PI PROCEDURE IN PBT
RASLOADM EQU   X'FE'                   LOAD PROCEDURE ENTRY IN RAS
RASPARMM EQU   X'00'                   CAP OR CSWE ENTRY IN RAS
SHORTBIT EQU   X'10'                   FP OPCODE MODIFIER
*
*        SWITCHES IN OPTSW
*
DPSW     EQU   X'80'                   DUMP  OPTION SWITCH
TRSW     EQU   X'40'                   TRACE OPTION SWITCH
SHSW     EQU   X'20'                   SHORT PRECISION OPTION SWITCH
TERMSW   EQU   X'10'                   TERMINATION ROUTINE ENTERED
ERROR    EQU   X'08'                   ERROR ROUTINE ENTERED
UT1ERR   EQU   X'04'                   ERROR ON SYSUT1
PRNTERR  EQU   X'02'                   ERROR ON SYSPRINT
UCTRSW   EQU   X'41'                   UNCONDITIONAL TRACE OPTION
PPTRSW   EQU   X'01'                   TRACE PRECOMP PROCEDURES
*
*        ESD SYMBOLS
*
         ENTRY IHIFSAIN
*
         EXTRN IHIDSTAB
         EXTRN IHIENTIF
         EXTRN IHIIOROP,IHIIORCL,IHIIORNX,IHIIORCI,IHIIOREV
         EXTRN IHIIOROQ,IHIIOREN,IHIIORGP,IHIIORCP,IHIIORER
*
         COPY  FSAREA
*
         COPY  FSACONV
*
         ORG   FSAREA+ADSTAB
         DC    A(IHIDSTAB)
*
***********************************************************************
*
*        INSTRUCTIONS/DATA INSERTED INTO THE FSA AT BRLIST
*
***********************************************************************
*
         ORG   BRLIST
         USING IHIFSARA,R13
*
         B     CAP1A                   CAP1
         B     CAP2A                   CAP2
         B     PROLP                   PROLOGP
         B     PROL                    PROLOG
         B     RETPROGA                RETPROG
         B     EPILP                   EPILOGP
         B     EPILB                   EPILOGB
         B     EPIL3                   EPILPR3
         B     CSWE1A                  CSWE1
         B     CSWE2A                  CSWE2
         B     LOADPPA                 LOADPP
*
*        TRACE
*
         MVC   SCRCS(2,R13),0(R15)     INSERT SEMICOLON NUMBER
         B     2(R15)                  MODIFIED TO NOP IF TRACE
         B     TRACEA
         B     TERMN                   TERMNTE
         NOPR  R15                     BCR
         B     GETMAIN                 GETMSTO
         B     VALUCAL                 VALUCALL
*
*        COMMON I/O ROUTINES IHIIOR @ IORLST
*
         DC    A(ADRLST)
*
***********************************************************************
*
*        EXITS FOR EXECUTION ERRORS
*
***********************************************************************
*
*
*        ENTRY POINTS FOR ALL TYPES OF EXECUTION ERRORS
*
*        STORE THE ERROR NUMBER AND LINK TO THE ERROR
*        ROUTINE IHIFSAER
*        THE NUMBER OF EACH ERROR IS DETERMINED BY ITS POSITION
*        IN THE BRANCH LIST
*
*        CALLING SEQUENCE -
*        BC    ERRORCONDITION,FSAERR+4*ERRORNUMBER(R13)
*
         ORG   FSAERR+FSAREA
*
IHIFSAER BAL   R1,FSAERRL               0
         BAL   R1,FSAERRL               1
         BAL   R1,FSAERRL               2
         BAL   R1,FSAERRL               3
         BAL   R1,FSAERRL               4
         BAL   R1,FSAERRL               5
         BAL   R1,FSAERRL               6
         BAL   R1,FSAERRL               7
         BAL   R1,FSAERRL               8
         BAL   R1,FSAERRL               9
         BAL   R1,FSAERRL              10
         BAL   R1,FSAERRL              11
         BAL   R1,FSAERRL              12
         BAL   R1,FSAERRL              13
         BAL   R1,FSAERRL              14
         BAL   R1,FSAERRL              15
         BAL   R1,FSAERRL              16
         BAL   R1,FSAERRL              17
NOMAIN   EQU   *-FSAREA
         BAL   R1,FSAERRL              18
         BAL   R1,FSAERRL              19
ERROR20  EQU   *
OERR20   EQU   *-FSAREA
PARERR   EQU   *-FSAREA
         BAL   R1,FSAERRL              20
ERROR21  BAL   R1,FSAERRL              21
         BAL   R1,FSAERRL              22
         BAL   R1,FSAERRL              23
         BAL   R1,FSAERRL              24
         BAL   R1,FSAERRL              25
         BAL   R1,FSAERRL              26
ERROR27  BAL   R1,FSAERRL              27
ERROR28  BAL   R1,FSAERRL              28    0C8 FROM SPIE
ERROR29  BAL   R1,FSAERRL              29    0CC FROM SPIE
ERROR30  BAL   R1,FSAERRL              30    0C9 FROM SPIE
ERROR31  BAL   R1,FSAERRL              31
ERROR32  BAL   R1,FSAERRL              32
ERROR33  BAL   R1,FSAERRL              33    0CX FROM SPIE
ERROR34  EQU   *
SWDMERR  EQU   *-FSAREA
         BAL   R1,FSAERRL              34
ERROR35  BAL   R1,FSAERRL              35
ERROR36  EQU   *
RASOVERF EQU   *-FSAREA
         BAL   R1,FSAERRL              36
         BAL   R1,FSAERRL              37
         BAL   R1,FSAERRL              38
         BAL   R1,FSAERRL              39
         BAL   R1,FSAERRL              40
DDERROR  EQU   *-FSAREA
         BAL   R1,FSAERRL              41
INVOPT   EQU   *-FSAREA
         BAL   R1,FSAERRL              42
         BAL   R1,FSAERRL              43
*
*        LINK TO ERROR ROUTINE IHIFSAERR
*
FSAERRL  LA    R1,0(,R1)               ZERO HIORDER BYTE
         S     R1,=A(IHIFSAER+4)       ERRORNUMBER*4 IN R1
         STC   R1,FSAERCOD(R13)        SAVE ERROR CODE
         TM    OPTSW(R13),ERROR        TO PREVENT ENTERING
         BO    TERMAA                  ERROR ROUTINE
         OI    OPTSW(R13),ERROR        MORE THAN ONCE
*
         CALL  IHIERROR,                                               X
               (FRDSA,SPDAP,IHIIOROP,IHIIORCP,IHIIORNX)
*
         USING IHIFSARB,R7
*
*        ABNORMAL TERMINATION
*
TERMA    L     R7,=A(IHIFSARB)
         TM    OPTSW(R13),TERMSW
         BO    ALGTRMAA                IF ERROR IN TERM ROUTINE
         B     ALGTRMA
*
*        VERY ABNORMAL TERMINATION
*
TERMAA   L     R7,=A(IHIFSARB)
         B     ALGTRMAA
*
*        NORMAL TERMINATION
*
TERMN    L     R7,=A(IHIFSARB)
         B     ALGTRMN
*
         DROP  R7
         ORG
*
***********************************************************************
*
*        INSTRUCTIONS FOR SHORT OR LONG FLOATING POINT PRECISION
*
***********************************************************************
*
*        THE FOLLOWING INSTRUCTIONS ARE MODIFIED BY THE
*        INITIALIZATION ROUTINE FOR SHORT OR LONG PRECISION AS
*        REQUIRED
*
FPINST   EQU   *
*                                       USED BY VALUCALL
VALLD    LE    0,0(R1)
VALST    STE   0,0(R2)
*                                       USED BY SPDECL
LINSTR   LE    0,0(R2)
STINSTR  STE   0,FCTVALST(R13)
LTRINSTR LTER  0,0
         NOPR  0
FPINSTE  EQU   *
LPRINSTR LPER  0,0
*
FPINSTAD DC    A(FPINST,4,FPINSTE)
*
*        ONE OF THE FOLLOWING SETS OF INSTRUCTIONS IS INSERTED
*        INTO THE CONVERT ROUTINE BY THE INITIALIZATION ROUTINE
*        IN ORDER TO SET UP FOR LONG OR SHORT PRECISION AS
*        REQUIRED
*
*        SHORT PRECISION
*
CNVINSTE STD   FPR0,CNVBUF2
         MVC   CNVBUF2+1(3),CNVCNST1+1
         AD    FPR0,CNVBUF2
         BR    R8
*
         STE   FPR0,CNVBUF3
         LD    FPR0,CNVBUF3
         B     ENTIER1
*
         STE   FPR0,CNVBUF3
         LD    FPR0,CNVBUF3
*
*        LONG PRECISION
*
CNVINSTD BR    R8
*
         DC    14X'FF'
         B     ENTIER1
*
         DC    8X'FF'
         AD    FPR0,CNVCNST2
         B     ENTIER1
*
CNVINSTL EQU   *-CNVINSTD
*
***********************************************************************
*
*        GETMAIN ROUTINE
*
***********************************************************************
*
*        ISSUE A CONDITIONAL GETMAIN IN RESPONSE TO A REQUEST BY
*        THE OBJECT MODULE FOR STORAGE FOR AN ARRAY. IF STORAGE
*        IS NOT AVAILABLE, AN ERROR EXIT IS TAKEN
*
*        CALLING SEQUENCE - (ENTRY VIA BRLIST)
*
*        BAL   R8,GETMSTO(R13)         LENGTH OF AREA IN R0
*        ---                           RETURN WITH ADDR IN R1
*
GETMAIN  LR    R2,R0                   LENGTH VALUE
*
         GETMAIN EC,LV=(R2),A=STORAGE
*
         LTR   R15,R15
         BNZ   NOMAIN(R13)
         L     R1,STORAGE
         BR    R8                      RETURN TO CALLING PROG
*
STORAGE  DC    A(0)                    ADDR OF THE AREA
*
***********************************************************************
*
*        CALL ACTUAL PARAMETER ROUTINE
*
***********************************************************************
*
*
*        THIS ROUTINE IS AN INTERMEDIATE LINK BETWEEN A PROCEDURE
*        AND THE THUNK FOR AN ACTUAL PARAMETER TO THE PROCEDURE.
*        IT SEARCHES THE DSA CHAIN FOR THE DSA OF THE PROCEDURE
*        DECLARATION. THEN IT LOADS THE THUNK ADDR FROM THIS
*        DSA, LOADS CDSA WITH THE DSA ADDR OF THE ENCLOSING
*        BLOCK AND BRANCHES TO THE THUNK
*
*        CALLING SEQUENCE - (ENTRY VIA BRLIST)
*
*        BAL   R15,CAP1(R13)
*        DC    H'PBN1'                 PBN OF PROCEDURE
*        DS    H
*        L     R8,DISPL(CDSA)          LOAD ADDR OF THUNK
*        ---                           RETURN FROM THUNK VIA CAP2
*                                      WITH PARAM ADDR IN R8
*
CAP1A    EQU   *
CAPA     L     R14,RASPT(R13)          RAS POINTER FROM TOP
         ST    R15,12(,R14)            SAVE RETURN ADDR IN RAS
         LH    R1,0(,R15)              PBN OF PROCEDURE
         LA    R1,0(R1,PBT)            PROCEDURE ENTRY IN PBT
CAPI1    LA    R14,8(,R14)             RESERVE ONE ENTRY IN RAS
         C     R14,RASPB(R13)          CHECK FOR STACK OVERFLOW
         BNL   RASOVERF(R13)
         ST    CDSA,0(,R14)            SAVE DSA POINTER IN RAS
         AH    PBT,8(,CDSA)            ADDR OF CURRENT PBT ENTRY
         L     R2,0(,CDSA)             LAST GENERATION DSA POINTER
         ST    R2,0(,PBT)              IS STORED IN PBT ENTRY
         CR    R1,PBT                  RIGHT PROCEDURE REACHED
         EX    0,4(,R15)               LOAD ADDR OF THUNK
         L     CDSA,4(,CDSA)           LOAD DYNAMICALLY ENCLOSING DSA
         LM    PBT,LAT,16(CDSA)        PBT AND LAT CAN BE DIFFERENT
         ST    R14,RASPT(R13)          SAVE RAS TOP POINTER
         BZR   R8                      TO THUNK OF ACTUAL PARAM
*                                      IF RIGHT BLOCK REACHED
         SR    R2,R2                   ZERO TO RETURN ENTRY IN
         ST    R2,12(,R14)             RAS INSTEAD OF R15
         B     CAPI1
*
*        HANDLE THE TRANSFER FROM THE THUNK BACK TO THE PROCEDURE
*
*        RELOAD CDSA WITH THE ADDR OF THE DSA THAT WAS ACTIVE
*        WHEN CAP1 WAS ENTERED
*
*        CALLING SEQUENCE - (ENTRY VIA BRLIST)
*        B     CAP2(R13)
*
CAP2A    EQU   *
CAPB     EQU   *
         L     R14,RASPT(R13)          RAS POINTER FROM TOP
CAPI3    L     CDSA,0(,R14)            DSA POINTER FROM RAS
         LM    PBT,LAT,16(CDSA)        PBT AND LAT CAN BE DIFFERENT
         L     R15,4(R14)              RETURN ADDR FROM RAS
         SH    R14,EIGHT(R13)          RELEASE ONE ENTRY IN RAS
         LH    R1,8(CDSA)              PROGRAM BLOCK NUMBER TO REG
         ST    CDSA,0(R1,PBT)          CURRENT DSA POINTER TO PBT
         LTR   R15,R15                 CALLING BLOCK REACHED
         BZ    CAPI3                   NO CONTINUE
CAPI4    ST    R14,RASPT(R13)          SAVE RAS TOP POINTER
         B     8(,R15)                 RETURN TO CALLING SEQUENCE
*
***********************************************************************
*
*        PROLOGUE PROGRAM
*
***********************************************************************
*
*        THIS ROUTINE IS EXECUTED WHENEVER A BLOCK OR PROCEDURE
*        IS TO BE ENTERED
*
*        IT CREATES AND INITIALIZES A NEW DSA. FOR A PROCEDURE
*        WITH PARAMETERS IT MOVES THE PARAMETER LIST TO THE DSA
*        AND CHECKS IT AGAINST THE FORMAL PARAMETER LIST IN THE
*        PROCEDURE DECLARATION. THEN IT ENTERS THE BLOCK OR
*        PROCEDURE
*        THE ENTRY POINT PROLOGP IS USED ONLY WHEN THE PROCEDURE
*        IS CALLED VIA AN ACTUAL PARAMETER TO ANOTHER
*        PROCEDURE
*
*        CALLING SEQUENCE (ENTRY VIA BRLIST)
*        BAL   R15,PROLOG(R13)
*        MVI   PROLPBN(R13),PBN         PBN OF BLOCK TO BE ENTERED
*                                       PARAMETER LIST FOR PROCEDURE
*        DC    A(THUNK1)                ADDR OF THUNK FOR 1ST PARAM
*        DC    H'CH'                    CHARACTERISTICS OF 1ST PARAM
*        DC    H'N'                     NUMBER OF PARAMETERS
*         .
*         .
*         .
*        DC    A(THUNKN)                ADDR OF THUNK FOR LAST PARAM
*        DC    H'CH'
*        DC    H'0'
*
PROLP    MVI   PROLPBN-1(R13),X'00'
*
*        SET OFF SW SET BY GENERATE PROG TO DETECT ERROR
*        SEE BELOW
*
         LM    PBT,LAT,PROLREG(R13)    UPDATE PBT AND LAT
*
PROL     LH    R3,PROLPBN-1(R13)       CALLED PROGRAM BLOCK NUMBER
         SLL   R3,3                    CALCULATE PBT DISPLACEMENT
         LTR   R2,R3                   STANDARD PROCEDURE CALLED ?
         BZ    SPDECL(,R13)            YES, BRANCH
         BM    OERR21(R13)             ERROR, ACTUAL PROCEDURE
*
*        PARAMETER IS PARAMETERLESS WHILE FORMAL PROCEDURE IS
*        CALLED WITH PARAMETERS
*        PROLPBN-1 WAS SET TO X'FF' BY GENERATED PROG BEFORE CAP1
*        WAS CALLED
*
         AR    R3,PBT                  ADDR OF PBT ENTRY
         TM    6(R3),BETABM            PROCEDURE CALLED ?
         BZ    PROLOG1                 NO
         C     R8,ASTLOC(,R13)         COMP CONT OF ADDR WITH ADDR OF
*                                      FUNCTION VALUE STORAGE
         BE    OERR21(,R13)            EQUAL, BRANCH
         TM    6(R3),CODEPRM           CODE PROCDURE CALLED ?
         BO    PROLOG2                 YES.
PROLOG1  LH    R0,4(,R3)               LENGTH OF DSA TO REG 0
         LR    R4,R15                  SAVE R15 DURING GETMAIN
*
         GETMAIN R,LV=(0)              GETMAIN FOR DSA
*
         LR    R15,R4
         L     R0,0(R2,PBT)            LOAD POINTER OF LAST GENERATION
         ST    R0,0(,R1)               STORE IT IN DSA
         ST    CDSA,4(,R1)             STORE POINTER OF EMBRACING PB
         STH   R2,8(,R1)               STORE PBT DISPLACEMENT
         MVI   10(R1),0                ZEROS TO VALUE ARRAY AND
         MVC   11(5,R1),10(R1)         ARRAY POINTERS
         ST    R1,0(R2,PBT)            STORE CURR DSA POINTER IN PBT
         LR    CDSA,R1                 SET CDSA POINTER
         STM   PBT,LAT,16(CDSA)
         L     R14,RASPT(R13)          RAS-POINTER TOP
         LA    R14,8(R14)              RESERVE ONE ENTRY
         C     R14,RASPB(R13)          COMPARE WITH RAS-POINTER BOTTOM
         BNL   RASOVERF(R13)           STACK OVERFLOW
         ST    CDSA,0(,R14)
         MVI   0(R14),X'FF'
         ST    R14,RASPT(R13)          SAVE POINTER
         TM    6(R3),BETABM            PROCEDURE CALLED ?
         BZR   R15                     NO, USUAL BLOCK RETURN, EXIT 1
A4       CLI   7(R3),0                 ANY FORMAL PARAMETERS ?
         BE    F4                      ZERO, BRANCH
         CLC   7(1,R3),7(R15)          COMP NO OF FORM AND ACT PARAM
         BNE   OERR21(,R13)            ¬=, BRANCH
         SR    R2,R2
         IC    R2,7(,R3)               FETCH NUMBER OF PARAMETERS
         LR    R4,R2                   SAVE NUMBER IN R4
         SLL   R2,3                    CALCULATE LENGTH OF PARAMETER
         BCTR  R2,0                    ENTRY-1
         LA    R1,24(CDSA)             START OF PARAM IF PROC
         TM    6(R3),PIMASK            FUNCTION PROCEDURE CALLED
         BZ    PROLOG3                 YES
         EX    R2,PIMOVE
         B     LOOP
*
PIMOVE   MVC   24(1,CDSA),0(R15)       MOVE PROCEDURE PARAMETERS
PHIMOVE  MVC   32(1,CDSA),0(R15)       MOVE FUNCTION PARAMETERS
PROLOG3  EX    R2,PHIMOVE
         LA    R1,8(R1)                START OF PARAM. IF TYPE
LOOP     TM    0(R8),X'01'             FORM PAR 'STRING' ?
         BO    STRTST                  YES, GOTO STRINGTEST
         CLI   1(R8),X'D0'             FORM PAR 'PROC' WITHOUT TYP ?
         BE    PROTST                  YES, GOTO PROCEDURE TEST
         CLI   1(R8),X'1C'             FORM PAR 'SWITCH' ?
         BE    SWTTST                  YES, GOTO SWITCH TEST
         TM    1(R8),X'08'             FORM PAR 'LABEL' ?
         BO    LBLTST                  YES, GOTO LABEL TEST
         TM    1(R8),X'04'             FORM PAR 'ARRAY' ?
         BO    ARRTST                  YES, GOTO ARRAY TEST
         TM    1(R8),X'C0'             FORM PAR A TYP PROCEDURE ?
         BO    TPRTST                  YES, GOTO TYP PROCEDURE TEST
         TM    5(R15),X'04'            ACT PAR 'ARRAY' ?
         BO    OERR20(,R13)            YES, ERR 20
TYPTST   TM    1(R8),X'03'             TEST TYP
         BM    ARITST                  IF ARITHM TYP GOTO ARITH TEST
         TM    5(R15),X'03'            ACT PAR BOOL ?
         BO    ASSFLAG                 YES, SPECIAL ASSIGNMENT TEST
         B     OERR20(,R13)            NO, GOTO ERR 20
*
STRTST   TM    4(R15),X'01'            ACT PAR 'STRING' ?
         BO    EXIT                    YES, TEST NEXT PAR
         B     OERR20(,R13)            NO, BRANCH TO OBJEXT TIME ERR 20
*
PROTST   TM    5(R15),X'C0'            ACT PAR IS 'PROCEDURE' ?
         BZ    OERR20(,R13)            NO, ERR 20
         B     EXIT                    YES, TEST NEXT PAR
*
SWTTST   TM    5(R15),X'0C'            ACT PAR 'SWITCH' ?
         B     STRTST+4                BRANCH TO STRTST+4 TO TEST CC
*
LBLTST   TM    5(R15),X'08'            ACT PAR 'LABEL' ?
         BZ    OERR20(,R13)            NO, ERR 20
         TM    5(R15),X'04'            ACT PAR 'SWITCH' ?
         BO    OERR20(,R13)            YES, ERR 20
         B     EXIT                    TEST NEXT PAR
*
ARRTST   TM    5(R15),X'04'            ACT PAR 'ARRAY' ?
         BZ    OERR20(0,R13)           NO, ERR 20
         B     TYPTST                  YES, GOTO TYP TEST
*
TPRTST   TM    5(R15),X'C0'            ACT PAR 'PROCEDURE' ?
         BZ    OERR20(0,R13)           NO, ERR 20
         B     TYPTST                  YES, GOTO TYP TEST
*
ARITST   TM    5(R15),X'03'            ACTUAL PAR ARITHMETIC ?
         BNM   OERR20(R13)             NO
         TM    1(R8),X'10'             FORMAL PARAMETER CALLED BY NAME?
         BZ    PARAMPR                 NO
         TM    1(R8),X'02'             FORMAL PARAMETER REAL TYPE ?
         BZ    INTTST                  NO, INTEGER TYPE
         TM    5(R15),X'02'            ACTUAL PARAMETER REAL ?
         BZ    OERR20(R13)             NO, ERROR
         B     ASSFLAG2                SPECIAL ASSIGNMENT TEST
*
INTTST   TM    5(R15),X'01'            ACTUAL PARAMETER INTEGER ?
         BZ    OERR20(R13)             NO, ERROR
*
*        SPECIAL TEST IF ACTUAL PARAMETER IS FORMAL BY NAME AND
*        THEN MOVE THE ASGNMENT FLAG FR ACT PARAMETER ENT IN DSA
*        TO THE NEW PARAMETER ENT IN DSA OF BLK TO BE ENTERED
*
*        NOTE: THIS CODE IS EXTREMELY DEPENDENT ON CODE
*        GENERATED FOR FORMAL PARAMETERS CALLED BY NAME
*
ASSFLAG  TM    1(R8),X'10'             FORMAL PARM BY NAME ?
         BZ    PARAMPR                 NO
ASSFLAG2 TM    5(R15),X'10'            ACT IS TYPE CALLED BY NAME ?
         BZ    PARAMPR
         TM    5(R15),X'20'            IF NOT GOTO SPECIAL
         BO    PARAMPR                 PARAMETERLESS PR TEST
         L     R2,4(CDSA)              DSA OF CALLING SEQUENSE
         L     R2,16(,R2)              PBT ADDR OF CALLING SEQ
         L     R3,0(,R1)               ADDR OF THUNK OF ACT PARM
*                                      WHICH IS FORMAL
         MVC   ORI+5(1),11(R3)         MOVE DISPL OF PARAM FOUND
*                                      IN THUNK CODE TO OR INST
         IC    R3,4(,R3)               DISPLACEMENT OF
         N     R3,MASKFF               PROCEDURE IN PBT
         L     R3,0(R3,R2)             ADDR OF DSA OF PROCEDURE
         LA    R3,4(,R3)               ADDR CHARACTERISTIC PART
*                                      OF PARAMETER ENTRY
ORI      OC    4(1,R1),0(R3)           MOVE ASGNMENT BIT FROM
*                                      CALLING PARAMETER ENT IN
*                                      DSA TO NEW DSA ENT
*
*        TEST IF ACTUAL PARAMETER IS PARAMETERLESS PROCEDURE
*
PARAMPR  TM    5(R15),X'C0'            ACTUAL PARAMETER PROCEDURE ?
         BZ    EXIT                    NO
         TM    5(R15),X'30'
         BM    EXIT
         TM    1(R8),X'D0'             FORMAL PROC CALLED BY NAME ?
         BO    EXIT                    YES, EXIT
         TM    4(R15),X'C0'            PROCEDURE CALLED ?
         BO    OERR20(R13)
EXIT     LA    R15,8(,R15)             GET NEXT ACT PAR ADDR
         LA    R8,2(,R8)               GET NEXT FORM PAR ADDR
         LA    R1,8(,R1)               NEXT PARAMETER IN DSA
         BCT   R4,LOOP                 IF A NEXT PAR OCCURS GOTO LOOP
F4       ST    R15,4(,R14)             STORE RETURN ADDR IN RAS
         BR    R8                      EXIT 2
*
*        PRECOMPILED PROCEDURE CALLED
*
PROLOG2  L     R1,0(,R3)               ADDR OF PRECOMP PR CONST
         LM    PBT,LAT,0(R1)           LOAD NEW PBT AND LAT ADDRS
         CLC   7(1,R3),15(PBT)         PARAMETER DEFINITION IN CODE
*                                      PROCEDURE SAME AS IN LOADED
*                                      PRECOMPILED PROCEDURE ?
         BNE   OERR21(R13)             NO, ERROR 21
         L     R8,8(,R1)               PROCEDURE DECLAR ENTRY POINT
         MVI   PROLPBN(R13),1          PBN OF PROCEDURE IS 1
         B     PROLOG(R13)             CALL PRECOMPILED PROCEDURE
*
MASKFF   DC    X'000000FF'             MASK TO CLEAR 3 BYTES OF REG
*
***********************************************************************
*
*        VALUE CALL ROUTINE
*
***********************************************************************
*
*        SUBROUTINE FOR HANDLING FORMAL PARAMETERS
*
*        CALLED BY VALUE
*
*        USED FOR FORMAL PARAMETERS OF TYPE REAL, INTEGER OR
*        BOOLEAN, INCLUDING ARRAYS
*
*        CALLING SEQUENCE - (ENTRY VIA BRLIST)
*        CALL  ACTUAL PARAMETER
*        BAL   R15,VALUCALL(R13)
*        DC    H'DISPL'                FORMAL PARAMETER DISPLACEMENT
*        DC    XL2'  '                 CHARACTERISTIC OF PARAMETER
*        ---                           RETURN FROM VALUCALL
*
*        DISPL(CDSA) CONTAINS IF PARAMETER IS AN ARRAY ADDR OF
*        SMF OTHERWISE VALUE OF THE ACTUAL PARAMETER, CONVERTED
*        IF NECESSARY
*
VALUCAL  MVI   CONVFL,0                ZERO TO CONVERSION FLAG
         ST    R15,BRRSAVE             SAVE R15, R8
         ST    R8,ADRSAVE
         LH    R1,0(,R15)
VALUC10  LA    R14,0(R1,CDSA)
*
*        INSERT COMPONENT SIZE OF ORIGINAL
*
         MVI   CSIZORIG+1,X'01'        ONE TO COMP SIZE INCASE BOOLEAN
         TM    5(R14),X'03'            TEST ACTUAL PARAMETER TYPE
         BO    VALUC12                 BOOLEAN, BRANCH
         MVI   CSIZORIG+1,X'04'        FOUR TO COMPONENT SIZE
         TM    5(R14),X'01'            ACTUAL PAR INTEGER ?
         BO    VALUC00                 INTEGER, BRANCH
         TM    OPTSW(R13),X'20'        PRECISION ?
         BO    VALUC00                 SHORT PRECISION, BRANCH
         MVI   CSIZORIG+1,X'08'        LONG, EIGHT TO COMPONENT SIZE
*
VALUC00  TM    5(R14),X'02'            ACTUAL PARAMETER REAL
         BO    VALUC11                 YES, BRANCH
*
*        ACTUAL PARAMETER INTEGER
*
         TM    3(R15),X'01'            FORMAL PAR INTEGER ?
         BO    VALUC12                 YES, BRANCH
*
         MVI   CONVFL,X'01'            1 (= INTEGER TO REAL) TO FLAG
         B     VALUC12
*
*        ACTUAL PARAMETER REAL
*
VALUC11  TM    3(R15),X'02'            FORMAL PAR REAL ?
         BO    VALUC12                 YES, BRANCH
         MVI   CONVFL,X'03'            3 (=REAL TO INTEGER) TO FLG
VALUC12  MVC   CSIZCOPY+1(1),CSIZORIG+1  COPY COMPONENT SIZE
         TM    3(R15),X'04'            ARRAY ?
         BO    VALUC21                 YES, BRANCH
VALUC13  MVC   0(8,R14),0(R8)          MOVE CONT OF R8 TO CDSA
         LR    R1,R14                  ADDR OF FORMAL PARAM ENTRY
         LR    R2,R1                   STORE BACK AFTER CONVERSION
         LA    R5,4(,R15)              RETURN ADDR
VALUC14  TM    CONVFL,X'03'            CONVERSION NECESSARY ?
         BZR   R5                      NO, RETURN
         BO    VALUC15                 REAL INTEGER
*
*        CALL INTEGER REAL CONVERSION ROUTINE
*
         L     R14,0(,R1)
         BAL   R8,CNVIRD(R13)
         EX    0,VALST
         BR    R5                      RETURN
*
*        CALL REAL-INTEGER CONVERSION ROUTINE
*
VALUC15  EX    0,VALLD
         BAL   R8,CNVRDI(R13)
         ST    R14,0(,R2)
         BR    R5                      RETURN
*
*        HANDLE VALUE CALL OF ARRAY
*
VALUC21  MVC   SIZEARR(4),16(R8)       SIZE OF ORIGINAL ARRAY
         L     R15,8(,R8)
         S     R15,4(,R8)              DIFF (ADDRLOWCOMP - ADRZEROCOMP)
         ST    R15,DIFFLZ
*
         MVI   SMFFL,0                 ZERO TO SMF FLAG
*
         TM    OPTSW(R13),X'20'        PRECISION ?
         BO    VALUC31                 SHORT PRECISION, BRANCH
         TM    CONVFL,X'03'            LONG, TEST CONV FLAG
         BZ    VALUC31                 NO CONV NEEDED, BRANCH
         MVC   SMFFL(1),CONVFL         CONV FLAG TO SMF FLAG
         L     R15,SIZEARR
         L     R14,DIFFLZ
         LH    R1,CSIZCOPY
         BO    VALUC25
*
*        INCREMENT 'SIZE OF ARRAY', DIFF AND COMPONENT SIZE
*
         SLA   R15,1
         SLA   R14,1
         SLA   R1,1
         B     VALUC26
*
*        DECREMENT 'SIZE OF ARRAY', DIFF AND COMPONENT SIZE
*
VALUC25  SRA   R15,1
         SRA   R14,1
         SRA   R1,1
VALUC26  ST    R15,SIZEARR
         ST    R14,DIFFLZ
         STH   R1,CSIZCOPY
*
*        EXECUTE SUBROUTINE WITH GETMAIN
*
VALUC31  SR    R15,R15
         IC    R15,0(R8)               NUMBER OF SUBSCRIPTS
         LA    R15,5(R15)
         SLA   R15,2
         CLI   CSIZCOPY+1,X'08'        REAL ARRAY LONG ?
         BNE   VALUC32                 NO
         TM    0(R8),X'01'             SMF LENGTH DOUBLE WORDS
         BO    VALUC32                 YES
         LA    R15,4(,R15)             FORCE ARRAY TO DOUBLE WORD
VALUC32  STC   R15,SIZESMF+1           INSERT SIZE OF SMF
         LH    0,SIZESMF
         A     0,SIZEARR               NUMBER OF BYTES REQUESTED
         BAL   R8,GETMSTO(R13)
*
*        COPY SMF
*
         L     R8,ADRSAVE
VALUC33  MVC   0(1,R1),0(R8)
*
*        INSERT FIRST FOUR WORDS INTO SMF COPY
*
         MVC   2(2,R1),10(CDSA)        CHAIN DISPL FROM DSA
         L     R15,BRRSAVE
         LH    R2,0(,R15)              DISPL OF FORMAL PARAM ENTRY
         STH   R2,10(,CDSA)            CHAIN DISPL
         ST    R1,0(R2,CDSA)           ADDR OF VALUE ARRAY
*                                      TO FORMAL PARAMETER ENTRY
         LR    R15,R1
         AH    R15,SIZESMF
         ST    R15,8(,R1)
         S     R15,DIFFLZ
         ST    R15,4(,R1)
         A     R15,DIFFLZ
         A     R15,SIZEARR
         ST    R15,12(,R1)
*
*        COPY DOUBLE OR HALF P-VALUES INTO NEW SMF
*
         LA    R15,16(,R1)
         LA    R2,16(,R8)
*
VALUC35  L     R14,0(R2)
         TM    SMFFL,X'03'             TEST IF P-VALUES MUST CHANGE
         BZ    VALUC36
         SLL   R14,1
         BM    VALUC36                 BR IF FLAG=1 (INCREM IS OK)
         SRL   R14,2                   DECREMENT INSTEAD
VALUC36  ST    R14,0(,R15)
         LA    R15,4(,R15)
         LA    R2,4(,R2)
         C     R15,8(,R1)
         BL    VALUC35
*
*        COPY ARRAY
*
*        INITIALIZE COPYING
*
VALUC41  L     R3,SIZEARR              SIZE OF ARRAY
         L     R2,8(,R1)               ADDR OF COPY ARRAY
         L     R1,8(,R8)               ADDR OF ORIGINAL ARRAY
         TM    CONVFL,X'03'            CONVERSION NECESSARY ?
         BZ    VALUC61                 NO, MOVE ARRAY
VALUC51  BAL   R5,VALUC14              CONVERT ONE ELEMENT, STORE IT
         AH    R1,CSIZORIG             NEXT ELEMENT FROM ORIGINAL
         AH    R2,CSIZCOPY             NEXT ELEMENT FROM COPY
         SH    R3,CSIZCOPY
         BP    VALUC51                 CONTINUE IF ELEMENTS LEFT
VALUC52  L     R15,BRRSAVE
         B     4(,R15)                 RETURN
*
VALUC61  LA    R4,255                  MAX IN ONE MOVE
VALUC61A BCTR  R3,0                    SIZE-1
         CR    R3,R4
         BNH   VALUC62                 NOT MORE THAN 256 BYTES
         EX    R4,VALUC63              MOVE 256 BYTES
         SR    R3,R4                   REDUCE SIZE
         LA    R1,256(,R1)
         LA    R2,256(,R2)
         B     VALUC61A                CONTINUE
*
VALUC62  EX    R3,VALUC63              MOVE LAST PART OF ARRAY
         B     VALUC52                 RETURN
*
VALUC63  MVC   0(0,R2),0(R1)           ORIGINAL ARRAY TO COPY
*
*        WORK AREA
*
BRRSAVE  DC    F'0'                    STORAGE OF R15
ADRSAVE  DC    F'0'                    STORAGE OF R8
DIFFLZ   DC    F'0'                    DIFFERENCE BETWEEN LOW
*                                      AND ZERO COMPONENTS
SIZEARR  DC    F'0'                    SIZE OF ARRAY
SIZESMF  DC    H'0'                    SIZE OF SMF
CSIZORIG DC    H'0'                    COMPONENT SIZE, ORIGINAL
CSIZCOPY DC    H'0'                    COMPONENT SIZE, COPY
CONVFL   DC    X'00'                   CONVERSION FLAG
SMFFL    DC    X'00'                   ARRAY SIZE FLAG
*
***********************************************************************
*
*        RETURN PROGRAM
*
***********************************************************************
*
*        THIS ROUTINE IS ENTERED WHEN A BRANCH IS MADE OUT OF A
*        BLOCK OR PROCEDURE BY MEANS OF A 'GO TO' STATEMENT
*
*        IT SEARCHES RAS FOR AN ENTRY POINTING TO THE DSA OF THE
*        TARGET BLOCK. FOR EACH BLOCK THAT IS BYPASSED, THE
*        FREEDSA ROUTINE IS INVOKED TO RELEASE STORAGE FOR DSA
*        AND ARRAYS. CALLING SEQUENCE - (ENTRY VIA BRLIST)
*
*        B     RETPROG(R13)
*
RETPROGA BALR  R15,0                   SET RETURN REGISTER
         L     R14,RASPT(R13)          FETCH RAS TOP POINTER
RETPR1   CLI   0(R14),RASPARMM         RAS PARAMETER ENTRY ?
         BNE   PBNENTRY                NO
         SH    R14,EIGHT(,R13)         CLEAR PARAMETER ENTRY
         B     RETPR1                  TEST NEXT ENTRY
*
PBNENTRY IC    R1,0(R14)               SAVE FLAG
         MVI   0(R14),0                CLEAR FLAG
         L     CDSA,0(,R14)            UPDATE DSA REG
         C     GDSA,0(,R14)            COMPARE DSA ADDR
         STC   R1,0(,R14)              RESTORE FLAG
         ST    R14,RASPT(R13)          SAVE RAS POINTER
         BER   R8                      EQUAL, EXIT TO ADDR IN R8
         B     FREEDSA(R13)            FREE DSA SUBROUTINE IN EPILOG
*
***********************************************************************
*
*        EPILOGUE PROGRAM
*
***********************************************************************
*
*        THIS ROUTINE IS EXECUTED WHENEVER AN EXIT IS MADE FROM
*        A PROCEDURE (ENTRY POINT EPILOGP) OR BLOCK (ENTRY POINT
*        EPILOGB) VIA THE 'END' STATEMENT
*
*        CLEAR THE CORRESPONDING ENTRY FROM RAS AND FREES
*        THE STORAGE FOR DSA AND ARRAYS. IF THE EXIT WAS FROM A
*        PRECOMPILED PROCEDURE, THE PROCEDURE IS DELETED
*
*        CALLING SEQUENCE - (ENTRY VIA BRLIST)
*
*        B     EPILOGP(R13)
*
EPILP    MVC   FCTVALST(8,R13),24(CDSA) FUNCTION VALUE TO FSA
         LA    R8,FCTVALST(R13)         FUNCTION VALUE ADDR TO R8
         BAL   R15,FREEDSA(R13)         LEAVE BLOCK AND UPDATE REG
         L     R14,RASPT(R13)
         L     R15,12(,R14)             RETURN ADDR FROM RAS
         BR    R15                      RETURN
*
*        CALLING SEQUENCE - (ENTRY VIA BRLIST)
*
*        B     EPILOGB(R13)
*
EPILB    EQU   *
FREEDSA  EQU   EPILOGB                 LEAVE A BLOCK
FRDSA    EQU   *                       FREEMAIN UPDATE REG
         ST    R15,BRRST(R13)          SAVE RETURN ADDR
         L     R14,RASPT(R13)          FETCH RAS POINTER
         SH    R14,EIGHT(R13)          REDUCE RETURN ADDR STACK
         ST    R14,RASPT(R13)          SAVE RAS POINTER
         CLI   8(R14),RASLOADM         LOAD PROCEDURE ENTRY ?
         BNE   VTEST                   NO
         L     R1,RASPB(R13)           FETCH ADDR OF NAME OF
         LR    R0,R1                   PROCEDURE TO BE DELETED
         LA    R1,8(,R1)               CLEAR PRECOMPILED PROCEDURE
         ST    R1,RASPB(R13)           NAME FROM RAS
*
         DELETE  EPLOC=(0)
*
         B     FRDSA+4                 CONTINUE
*
*        VALUE ARRAY HANDLING
*
EPIL3    EQU   *
VTEST    ICM   R0,B'0011',10(CDSA)     TEST VALUE ARRAY FIELD
         BZ    ATEST                   ZERO, GOTO NEXT TEST
         LH    R2,10(,CDSA)            LOAD LAST VALUE ARRAY DISPL
         L     R1,0(R2,CDSA)           LOAD ADDR OF STOR MAP FCT
         L     R0,16(,R1)              LOAD LENGTH OF ARRAY
         LH    R2,2(,R1)               LOAD BEFORE LAST VALUE
*                                      ARRAY DISPLACEMENT
         STH   R2,10(,CDSA)            STORE BEFORE LAST VALUE
*                                      ARRAY DISPLACEMENT
         SR    R2,R2                   CLEAR A WORK REGISTER
         IC    R2,0(,R1)
         LA    R2,1(,R2)               CALCULATE LENGTH OF STORAGE
         SLL   R2,2                    MAPPING FUNCTION
         LA    R2,16(,R2)
         AR    R0,R2                   ADD ST MAP FUNCT LENGTH
*                                      AND ARRAY LENGTH
*                                      FREEMAIN FOR VAL ARRAY
         FREEMAIN R,LV=(0),A=(1)       INCL ST MAP FCT
*
         B     VTEST                   RETURN TO VALUE ARRAY TEST
*
*        ARRAY HANDLING
*
ATEST    SR    R2,R2                   CLEAR WORK REGISTER
         ICM   R2,B'0011',14(CDSA)     TEST LAST ARRAY DISPLACEMENT
         BZ    DSAHDL                  ZERO, GOTO DSAHDL
         LH    R3,2(R2,CDSA)           LOAD BEFORE LAST ARRAY DISPL
         STH   R3,14(,CDSA)            STORE BEFORELAST ARRAY DISPL
         L     R1,8(R2,CDSA)           LOAD ADDR OF LOWEST COMPON
         L     R0,16(R2,CDSA)          LOAD LENGTH OF ARRAY
*
         FREEMAIN R,LV=(0),A=(1)       FREEMAIN FOR ARRAY
*
         B     ATEST                   RETURN TO ARRAY TEST
*
*        DSA HANDLING
*
DSAHDL   LR    R1,CDSA                 LOAD DSA ADDR
         LH    R2,8(,CDSA)             LOAD PBT DISPL
         L     R3,0(,CDSA)             UPDATE DSA ADDR
         ST    R3,0(R2,PBT)            IN PBT
         LH    R0,4(R2,PBT)            LENGTH OF DSA TO R0
         L     CDSA,4(,CDSA)           RESET CDSA POINTER
         LM    PBT,LAT,16(CDSA)        UPDATE PBT AND LAT REGISTERS
*
         FREEMAIN R,LV=(0),A=(1)       FREEMAIN FOR DSA
*
         L     R15,BRRST(R13)          RESTORE RETURN ADDR
         BR    R15                     BRANCH
*
***********************************************************************
*
*        STANDARD PROCEDURE DECLARATION ROUTINE
*
***********************************************************************
*
*
*        ENTERED FROM THE PROLOG ROUTINE IF PBN IS ZERO, IE A
*        STANDARD PROCEDURE IS CALLED VIA AN ACTUAL PARAMETER TO
*        AN ANOTHER PROCEDURE
*
*        ON ENTRY, R15 CONTAINS THE ADDR OF THE PARAMETER
*        LIST, WHILE R8 CONTAINS THE INTERNAL NAME OF THE
*        STANDARD PROCEDURE.
*        THE ROUTINE BUILDS THE PARAMETER LIST AND EXECUTES THE
*        CALL IN THE SAME WAY AS WOULD NORMALLY BE DONE BY THE
*        GENERATED OBJECT CODE. SINCE THE ROUTINE MAY BE ENTERED
*        REPEATEDLY DURING THE EVALUATION OF THE ACTUAL
*        PARAMETERS, THE PARAMETER LIST AND OTHER INFORMATION IS
*        STORED IN A DYNAMIC AREA CALLED SPDA.
*
         DS    0H
SPDECL   EQU   *-FSAREA
*
*        TEST FOR AUXILIARY ROUTINE INPUT OR OUTPUT
*
         LTR   R8,R8
         BPR   R8                      TO ROUTINE INPUT OR OUTPUT
*
*        GET DYNAMIC STORAGE AREA
*
SPDECL00 LR    R2,R15                  SAVE R15 DURING GETMAIN
*
         GETMAIN R,LV=SPDALG
*
         LR    R15,R2
         MVC   0(4,R1),SPDAP           INSERT CHAIN ADDR
         ST    R1,SPDAP                STORE CURRENT AREA POINTER
         LR    R5,R1
         USING SPDA,R5
         ST    R8,PRID
         LR    R4,LAT                  R4 IS NOW LAT POINTER
         LR    R0,R8
         LR    R2,R0
         SRL   R2,12
         N     R0,=F'3'                NUMBER OF FORMAL PARAMETERS
         BNZ   *+8                     ZERO MEANS ONE PARAMETER
         LA    R0,1
         CH    R0,6(,R15)              COMPARE NUMBER OF ACTUAL PARAM
         BNE   ERROR21
*
*        INITIALIZE FOR CREATING PARAMETER LIST
*
         LA    R1,PARLIST
         LA    R3,PARAMS
         MVI   0(R1),0
         MVC   1(11,R1),0(R1)          RESET PARAMETER LIST
SPDECL02 STC   R2,FPTYPA
         STC   R2,FPTYP
         XC    FPTYP,5(R15)            COMPARE WITH ACTUAL PAR CHAR
         TM    FPTYP,X'07'
         BZ    SPDECL15                IDENTICAL TYPES
         BO    PARERR(R13)             NOT COMPATIBLE TYPES
*
*        TYPES ARE NOT IDENTICAL BUT MAY BE COMPATIBLE
*
         TM    FPTYPA,X'08'            TEST FOR VALUE OR NAME
         BO    PARERR(R13)             CALL BY NAME AND NOT SAME TYPE
         TM    FPTYP,X'03'             TEST IF REAL-INTEGER COMPATIBLE
         BNO   PARERR(R13)
         TM    5(R15),X'03'            TEST ACTUAL PARAMETER
         BNM   PARERR(R13)             IF NOT REAL OR INTEGER
         OI    0(R1),X'80'             SET TYPE CONVERSION FLAG
*
*        ACTIVATE THUNK TO GET ADDR OF ACTUAL PARAMETER
*
SPDECL15 STM   R15,R4,SPSAVE
         MVC   SPTHAD(4),0(R15)        THUNK ADDR TO FULLWORD LOCATION
         L     R3,RASPT(R13)
         LA    R3,8(,R3)               NEXT ENTRY IN RAS
         C     R3,RASPB(R13)
         BNL   RASOVERF(R13)           IF RAS FULL
         ST    R3,RASPT(R13)
         ST    CDSA,0(,R3)             DSA POINTER TO RAS
         LM    PBT,LAT,16(CDSA)
         LA    R2,SPDECL17-8
         ST    R2,4(R3)                ADDR USED BY CAP2
         L     R15,SPTHAD              ADDR OF THUNK
         BR    R15                     BRANCH TO THUNK
*
*        RETURN HERE VIA CAP2
*        R8 CONTAINS ADDR OF ACTUAL PARAM
*
SPDECL17 L     R5,SPDAP                RESTORE SPDA POINTER
         LM    R15,R4,SPSAVE           RESTORE REGISTERS
         C     R8,ASTLOC(R13)
         BNE   SPDECL19
         MVC   0(8,R3),0(R8)           SAVE PARAM VALUE IN SPDA
         LR    R8,R3
SPDECL19 O     R8,0(,R1)               COMBINE FLAGS AND PARAM ADDR
         ST    R8,0(,R1)               STORE PARAM ADDR IN PARLIST
         TM    PRID,X'03'              I/O PROCEDURE ?
         BNZ   SPDECL01                NO, BRANCH
*
*        I/O PROCEDURE
*
         TM    PRID+2,X'02'            SYSACT ?
         BZ    SPDECL01                NO, BRANCH
         CH    R0,=H'1'                TEST IF THIRD PARAM
         BNE   SPDECL01                BR IF NO
         TM    4(R15),X'08'            ASSIGNMENT POSSIBLE ?
         BZ    SPDECL01                YES, BRANCH
         OI    0(R1),X'40'             SET NO ASSIGNMENT FLAG
*
SPDECL01 LA    R1,4(,R1)               STEP PARLIST POINTER
         LA    R3,8(,R3)               STEP PARAMETER POINTER
         LA    R15,8(,R15)             STEP ACTUAL PARAMETER POINTER
         SRL   R2,4
         BCT   R0,SPDECL02             BRANCH IF MORE PARAMETERS
*
*        PARAMETER LIST COMPLETE - ACTIVATE THE PROCEDURE
*
         ST    R15,SPSAVE              SAVE RETURN ADDR
         LA    R1,PARLIST
         TM    PRID+3,X'80'            ABS/SIGN/LENGTH/ENTIER ?
         BO    SPDECL03                YES, BRANCH
         IC    R2,PRID+3
         N     R2,=X'000000FC'         GET DISPLACEMENT IN LAT
         L     R15,0(R2,R4)            LOAD ADDR OF PROCEDURE
         TM    PRID,X'03'              I/O PROCEDURE ?
         BNZ   SPDECL04                NO, BRANCH
*
*        I/O PROCEDURE EXIT
*
         BALR  R14,R15
         B     SPDECL18
*
SPDECL03 TM    PRID+3,X'50'
         BNM   SPDECL04                BR IF ABS OR ENTIER FUNCTION
         TM    PRID+3,X'20'
         BZ    SPDECL05                BR IF SIGN FUNCTION
*
*        LENGTH FUNCTION
*
         L     R1,0(R1)
         MVC   HW(2,R13),0(R1)
         LH    R0,HW(R13)              LENGTH OF ENTIRE STRING FIELD
         BCTR  R0,0                    REDUCE BY TWO TO GET
         BCTR  R0,0                    ACTUAL STRING LENGTH
         ST    R0,FCTVALST(R13)
         B     SPDECL13
*
*        SIGN FUNCTION
*
SPDECL05 L     R2,0(,R1)               LOAD PARAMETER ADDR
         SR    R0,R0                   INITIALIZE OUTPUT VALUE
         TM    0(R1),X'80'             TYPE CONVERSION ?
         BO    SPDECL06                YES, BRANCH
         EX    0,LINSTR                VALUE TO FPR0
         EX    0,LTRINSTR              TEST SIGN
         B     SPDECL07
*
SPDECL06 ICM   R0,B'1111',0(R2)        VALUE TO R0
SPDECL07 BZ    SPDECL08                TEST SIGN
         LA    R0,1                    FUNCTION VALUE=1
         BP    SPDECL08
         LCR   R0,R0                   FUNCTION VALUE=-1
SPDECL08 ST    R0,FCTVALST(,R13)
         B     SPDECL13
*
*        MATHEMATICAL FUNCTIONS (INCLUDING ABS, ENTIER)
*
SPDECL04 L     R2,0(,R1)
         TM    0(R1),X'80'             TYPE CONVERSION ?
         BZ    SPDECL09
         L     R14,0(,R2)              LOAD PARAMETER VALUE
         BAL   R8,CNVIRD(R13)
         EX    0,STINSTR
         MVC   0(4,R1),ASTLOC(R13)     CHANGE PARAMETER ADDR
         B     SPDECL10
*
SPDECL09 EX    0,LINSTR
SPDECL10 CLI   PRID+3,X'80'            ABS ?
         BNE   SPDECL11                NO, BRANCH
*
*        ABS FUNCTION
*
         EX    0,LPRINSTR              ABS VALUE TO FPR0
         B     SPDECL14
*
SPDECL11 CLI   PRID+3,X'F0'            ENTIER ?
         BNE   SPDECL12                NO, BRANCH
*
*        ENTIER FUNCTION
*
         BAL   R8,ENTIER(R13)
         ST    R14,FCTVALST(R13)
         B     SPDECL13
*
*        ALL OTHER FUNCTIONS
*
SPDECL12 BALR  R14,R15                 CALL SUBROUTINE
SPDECL14 EX    0,STINSTR
SPDECL13 L     R8,ASTLOC(R13)          ADDR OF FUNCTION VALUE
*
*        COMMON EXIT
*
SPDECL18 LR    R1,R5
         MVC   SPDAP(4),0(R1)          RESTORE PREV DA POINTER
         L     R2,SPSAVE               LOAD RETURN ADDR (PREV R15)
*
         FREEMAIN R,A=(1),LV=SPDALG
*
         LM    PBT,LAT,16(CDSA)
         BR    R2                      RETURN TO CALLING PROGRAM
*
         DROP  R5
*
*        CONSTANTS AND WORK AREAS
*
SPTHAD   DC    F'0'                    TEMP STORAGE FOR THUNK ADDR
SPDAP    DC    F'0'                    POINTER TO CURRENT DYNAMIC AREA
FPTYP    DC    X'00'                   TYPE OF FORMAL PARAMETER
FPTYPA   DC    X'00'                   SAVE AREA FOR FPTYP
*
*        DYNAMIC STORAGE AREA
*
SPDA     DSECT
         DS    F                       LINK TO LOWER DA
SPSAVE   DS    6F                      REGS R15, R0, R1, R2, R3, R4
PRID     DS    F                       PROCEDURE IDENTIFICATION
PARLIST  DS    3F                      PARAMETER LIST
PARAMS   DS    3D                      PARAMETER VALUES
SPDALG   EQU   *-SPDA
*
IHIFSARA CSECT
*
***********************************************************************
*
*        CALL SWITCH ELEMENT SUBROUTINE
*
***********************************************************************
*
*        THIS ROUTINE IS AN INTERMEDIATE LINK BETWEEN A SWITCH
*        DESIGNATOR AND A SWITCH LIST
*
*        IT SEARCHES THE DSA CHAIN FOR THE DSA OF THE SWITCH LIST
*        AND BRANCHES TO THE CALLED SWITCH LIST ENTRY
*        CALLING SEQUENCE - (ENTRY VIA BRLIST)
*        ADDR OF SWITCH LIST IN R8, ADDR OF DSA FOR
*        BLOCK IN WHICH SWITCH IS DECLARED IN REG GDSA AND THE
*        SWITCH ELEMENT NUMBER IN R15
*
*
*        BAL   R14,CSWE1(R13)
*        ---                           RETURN VIA CSWE2 WITH BRANCH
*                                      ADDR IN R8 AND ADDR OF
*                                      DSA IN GDSA
*
CSWE1A   LTR   R15,R15                 ELEMENT NUMBER POSITIVE ?
         BNH   SWDMERR(R13)            NO, DIMENSION ERROR
         CH    R15,2(,R8)              COMPARE NO WITH SWITCH LIST NO
         BH    SWDMERR(R13)            DIMENSION ERROR
         SLL   R15,2
         L     R3,RASPT(R13)           RAS POINTER FROM TOP
CSWEI1   LA    R3,8(R3)                RESERVE ONE ENTRY IN RAS
         C     R3,RASPB(R13)           STACK OVERFLOW ?
         BNL   RASOVERF(R13)
         ST    CDSA,0(,R3)             STORE CDSA IN RAS
         ST    R14,4(,R3)              SAVE RETURN ADDR IN STACK
         SR    R14,R14                 NOT CALLING BLOCK INDICATION
         CR    CDSA,GDSA               SWITCH BLOCK REACHED ?
         BNE   CSWEI2                  NO
         ST    R3,RASPT(R13)           SAVE RAS TOP POINTER
         L     R15,0(R15,R8)           ADDR OF SWITCH ELEMENT
         BR    R15
*
CSWEI2   LH    R1,8(,CDSA)             PROGRAM BLOCK DISPL TO REG
         L     R2,0(,CDSA)             LAST GENERATION DSA POINTER IS
         ST    R2,0(R1,PBT)            STORED IN PROGRAM BLOCK TABLE
         L     CDSA,4(,CDSA)           LOAD DYNAMICALLY ENCLOSING DSA
         LM    PBT,LAT,16(CDSA)        PBT AND LAT CAN BE DIFFERENT
         B     CSWEI1                  CONTINUE
*
*        THIS ROUTINE HANDLES THE TRANSFER FROM THE SWITCH LIST
*        BACK TO THE SWITCH DESIGNATOR
*
*        IT RELOADS CDSA WITH THE ADDR OF THE DSA THAT WAS
*        ACTIVE WHEN CSWEU WAS ENTERED
*
*        CALLING SEQUENCE - (ENTRY VIA BRLIST)
*        B     CSWE2(R13)
*
CSWE2A   L     R3,RASPT(R13)           RAS POINTER FROM TOP
CSWEI3   L     R14,4(,R3)              RETURN ADDR FROM STACK
         SH    R3,EIGHT(R13)           RELEASE ONE ENTRY IN RAS
         ST    R3,RASPT(R13)           SAVE RAS TOP POINTER
         LTR   R14,R14                 RETURN ADDR FOUND ?
         BNZR  R14                     YES, RETURN
         L     CDSA,0(R3)              NEW DSA POINTER FROM RAS
         LH    R1,8(,CDSA)             PROGRAM BLOCK DISPL TO REG
         ST    CDSA,0(R1,PBT)          CURRENT DSA POINTER TO PBT
         LM    PBT,LAT,16(CDSA)        PBT AND LAT CAN BE DIFFERENT
         B     CSWEI3                  CONTINUE
*
***********************************************************************
*
*        LOAD PRECOMPILED PROCEDURE
*
***********************************************************************
*
*        ENTERED FROM THE DECLARATION OF A 'CODE' PROCEDURE
*
*        SEARCH THE BOTTOM PART OF RAS FOR THE NAME OF THE
*        PROCEDURE. IF IT IS NOT FOUND, THE PRECOMPILED PROCEDURE
*        WITH THE SAME NAME IS LOADED AND ENTRIES ARE MADE IN
*        RAS FOR THE NAME AND FOR THE ENTRY POINT
*
*        THE ENTRY POINT ADDR IS STORED IN THE PROGRAM BLOCK TABLE
*
*        CALLING SEQUENCE - (ENTRY VIA BRLIST)
*
*        BAL   R8,LOADPP(R13)
*        DC    CL8(PPNAME)             NAME OF PRECOMPILED PROCEDURE
*        DC    H'PBN'                  PROG BLOCK NUMBER
*
LOADPPA  LM    R3,R4,RASEND(R13)       RASEND AND RASPB TO REG
         LA    R2,8                    SET TO 8
LOADPP2  CR    R3,R4
         BNH   LOADPP1                 BRANCH IF STACK EMPTY
         CLC   0(8,R4),0(R8)           PROCEDURE ALREADY LOADED ?
         LA    R4,8(,R4)               STEP TO NEXT PP NAME
         BNE   LOADPP2                 NO, NAME NOT FOUND
         L     R3,RASPT(R13)           RAS POINTER FROM TOP
         S     R4,RASPB(R13)
         SRL   R4,3                    NAME FOUND IN ENTRY NR R4
LOADPP3  SR    R3,R2
         CLI   8(R3),RASLOADM          LOAD PROCEDURE ENTRY ?
         BNE   LOADPP3                 NO, CONTINUE SEARCH
         BCT   R4,LOADPP3              LOOP TO FIND RIGHT ENTRY
         L     R0,12(,R3)              FETCH ADDR OF CONSTANTS
         B     LOADPP4
*
*        PROCEDURE MUST BE LOADED
*
LOADPP1  L     R3,RASPT(R13)
         L     R4,RASPB(R13)
         AR    R3,R2                   RESERVE ONE ENTRY FROM TOP
         SR    R4,R2                   RESERVE ONE ENTRY FROM BOTTOM
         CR    R3,R4                   STACK OVERFLOW ?
         BNL   RASOVERF(R13)
         ST    R4,RASPB(R13)           STORE UPDATED STACK POINTER
         ST    R3,RASPT(R13)
         MVC   0(8,R4),0(R8)           ENTER NAME IN STACK
         LR    R0,R4                   R0 -> NAME
*
         LOAD  EPLOC=(0)
*
         ST    CDSA,0(,R3)             SAVE CDSA IN RAS ENTRY
         MVI   0(R3),RASLOADM          INSERT LOAD PROCEDURE FLAG
         ST    R0,4(,R3)               STORE ADDR TO ENTRY CONSTANT
LOADPP4  LH    R3,8(,R8)               FETCH PBN CODE PROCEDURE
         ST    R0,0(R3,PBT)            ADDR OF PRECOMPILED PROCEDURE
*                                      CONSTANT TO CODE PROC.PBT ENTRY
*                                      CONSTANT A(PBT),A(LAT),A(ENTRY)
         B     10(,R8)                 RETURN TO DECLARATION END
*
***********************************************************************
*
*        TRACE ROUTINE
*
***********************************************************************
*
*        EXECUTED WHENEVER THE END OF AN ALGOL STATEMENT IS REACHED
*
*        IF ANY OF THE PARAMETERS TRACE, TRBEG OR TREND WAS
*        SPECIFIED. IT CHECKS IF THE SEMICOLON NUMBER IS WITHIN A
*        TRACE AREA AND, IF THIS IS THE CASE, STORES IT IN A
*        BUFFER FOR OUTPUT ON SYSUT1 WHEN THE BUFFER OVERFLOWS.
*        WHEN A DISCONTINUITY IS ENCOUNTERED (TRANSFER INTO A
*        TRACE AREA OR BETWEEN THE MAIN PROGRAM AND A PRECOMPILED
*        PROCEDURE), THE NAME OF THE ACTIVE MODULE IS ALSO
*        STORED IN THE BUFFER
*
*        THE FORMAT OF THE INFORMATION IN THE BUFFER IS -
*
*        DC    H'LENGTH'               POINTER TO NEXT FREE PLACE
*        DS    H                       NOT USED
*        DC    H'SC'                   SEMICOLON NUMBER
*         .
*         .
*        DC    H'0'                    FLAG FOR MODULE NAME
*        DC    CL4'NAME'               MODULE NAME (FIRST 4 CHAR)
*        DC    H'SC'                   SEMICOLON NUMBER
*         .
*         .
*
*        THE ROUTINE IS ENTERED VIA INSTRUCTIONS IN THE BRANCH
*        LIST AT BRLIST. THESE INSTRUCTIONS STORE THE SEMICOLON
*        NUMBER AND THEN EXECUTE A BRANCH EITHER TO THIS ROUTINE
*        OR, IF TRACE WAS NOT REQUESTED, DIRECTLY BACK TO THE
*        ALGOL PROGRAM.
*
*        CALLING SEQUENCE -
*
*        BAL   R15,TRACE(R13)
*        DC    H'SC'                   SEMICOLON NUMBER
*        ---                           (RETURN POINT)
*
TRACEA   STM   14,12,ASAVE+12(R13)     SAVE REGS IN SECOND SAVEAREA
         L     R3,=A(IHIFSARB)
         USING IHIFSARB,R3
         LR    R1,PBT
         LM    R6,R7,TRBEG             LOAD TRACE LIMITS
         LM    R8,R11,TRBUF            LOAD BUFFER PARAMETERS
         LH    R4,0(,R8)               LOAD BYTE POINTER
         LH    R2,TRL1                 LENGTH OF NORMAL TRACE ITEM
*
         CLC   4(4,R1),TRMPNAME        MAINP OR PRECOMP PROC ?
         BE    TRACE10                 MAINP
         TM    OPTSW(R13),PPTRSW       TRACE IN PRECOMP PROC ?
         BZ    TRACE6                  NO, PP TRACE
         TM    TRFLAG,X'03'            PP CALLED FROM TRACE AREA ?
         BM    TRACE0                  YES, TRACE REQUIRED
         B     TRACE6                  CONDITIONAL - NO PP TRACE
*
TRACE10  LH    R5,SCRCS(R13)           LOAD CURRENT SEMICOLON NUMBER
         CR    R7,R6                   TEST INTERVAL LIMITS
         BNH   TRACE13                 SINGLE INTERVAL
         CR    R5,R6                   CHECK SC AGAINST LIMITS
         BL    TRACE15                 OUTSIDE INTERVAL
         CR    R5,R7
         BH    TRACE15                 OUTSIDE INTERVAL
         B     TRACE16                 INSIDE INTERVAL
*
TRACE13  CR    R5,R7                   DOUBLE INTERVAL
         BH    TRACE14
TRACE16  MVI   TRFLAG1,1               INSIDE LOWER INTERVAL
         B     TRACE18
*
TRACE14  CR    R5,R6
         BL    TRACE15                 OUTSIDE BOTH INTERVALS
         MVI   TRFLAG1,2               INSIDE HIGHER INTERVAL
TRACE18  CLC   TRFLAG1,TRFLAG          BORDER BEEN CROSSED ?
         BE    TRACE0                  NO, SAME INTERVAL AS BEFORE
         MVC   TRFLAG,TRFLAG1
         B     TRACE5
*
TRACE15  MVI   TRFLAG,0                NO TRACE THIS TIME
         B     TRACE6
*
TRACE0   CLC   4(4,R1),TRPGID+2        PROGID CHANGED ?
         BE    TRACE1                  NO, BRANCH
TRACE5   MVC   TRPGID+2(4),4(R1)       STORE NEW PROGID
         LH    R2,TRL2                 LENGTH OF ITEM WITH PROGID
TRACE1   LR    R0,R2                   BUFFER FILLED ?
         AR    R0,R4
         CR    R0,R10
         BL    TRACE2                  STILL ROOM, BRANCH
         LTR   R11,R11                 IF NO RECORDS WRITTEN
         BZ    TRACE4                  BYPASS CHECK
*
         CHECK TRCHECK
*
TRACE4   WRITE TRCHECK,SF,,(R8),MF=E
*
         LR    R0,R8
         LR    R8,R9                   SWITCH BUFFERS
         LR    R9,R0
         LA    R4,4                    RESET POINTER
         LA    R11,1(,R11)             INCR RECORD COUNTER
*
TRACE2   CH    R2,TRL1                 TEST FOR NEW PROGID
         BE    TRACE3
*
         LR    R1,R8
         AR    R1,R4
         MVC   0(6,R1),TRPGID          PROGID TO BUFFER
         LA    R4,6(,R4)
*
TRACE3   LR    R1,R8
         AR    R1,R4
         MVC   0(2,R1),SCRCS(R13)      SEMICOLON COUNTER TO BUFFER
         LA    R4,2(,R4)
         STH   R4,0(,R8)
         STM   R8,R11,TRBUF
TRACE6   LM    R14,R12,ASAVE+12(R13)
         B     2(,R15)                 RETURN TO ALGOL PROGRAM
*
         CNOP  2,4
TRL1     DC    H'2'                    LENGTH OF SEMICOLON FIELD
TRL2     DC    H'8'                    LENGTH OF NEW NAME + SEMICOLON
TRPGID   DC    H'0'                    FLAG FOR PROGID
         DC    2H'0'                   FIRST FOUR BYTES OF PROG NAME
         DC    X'FFFF'                 INITIAL VALUE FOR TREND
TRBEG    DC    F'0'                    BEGINNING OF TRACE AREA
TREND    DC    F'0'                    END OF TRACE AREA
TRFLAG   DC    X'00'                   STATUS INDICATOR
*                                        00 - OUTSIDE BOTH TRACE AREAS
*                                        01 - INSIDE LOWER AREA
*                                        02 - INSIDE HIGHER AREA
TRFLAG1  DC    X'00'                   PREVIOUS VALUE OF TRFLAG
TRMPNAME DC    CL4' '                  NAME OF MAIN PROGRAM
*
         DROP  R3
*
***********************************************************************
*
*        PROGRAM INTERRUPT ROUTINE
*
***********************************************************************
*
*        USE INTERRUPT CODE TO LOAD ENTRY FROM PIETAB TO PASS
*        CONTROL TO FSA ERROR ROUTINE BY UPDATING THE OLD PSW
*        AND RETURNING FROM SPIE
*
         USING PIEROUT,R15
PIEROUT  L     R13,=A(IHIFSARA)
         MVC   PGOPSW(8,R13),4(R1)     MOVE BC MODE PSW TO PGOPSW
         IC    R2,PGOPSW+3(,R13)       LOAD INTERRUPTION CODE
         N     R2,PGCMASK              REMOVE IMPRECISE CODES (M/91)
         SLA   R2,2                    CONVERT INTERRUPT CODE
         LA    R2,PIETAB(R2)           FOR TABLE LOOKUP
PIEROUT2 MVC   9(3,R1),1(R2)           CHANGE RETURN ADDR IN OLD PSW
         BR    R14                     RETURN FROM SPIE RTN
*
         DROP  R15
*
         DC    0F'0'
PGCMASK  DC    X'0000000F'             MASK FOR INTERRUPT CODE
*
PIETAB   DC    A(ERROR33)              MOD/91 ONLY
         DC    A(ERROR33)              OPERATION        - 0C1
         DC    A(ERROR33)              PRIVILAGE        - 0C2
         DC    A(ERROR33)              EXECUTE          - 0C3
         DC    A(ERROR33)              PROTECTION       - 0C4
         DC    A(ERROR33)              ADDRESSING       - 0C5
         DC    A(ERROR33)              SPECIFICATION    - 0C6
         DC    A(ERROR33)              DATA             - 0C7
         DC    A(ERROR28)              FIXED PT OVFL    - 0C8
         DC    A(ERROR30)              FIXED PT DIVIDE  - 0C9
         DC    A(ERROR33)              DECIMAL OVFL     - 0CA
         DC    A(ERROR33)              DECIMAL DIVIDE   - 0CB
         DC    A(ERROR29)              EXPONENT OVFL    - 0CC
         DC    A(ERROR33)              EXPONENT UNDERFL - 0CD
         DC    A(ERROR33)              FP SIGNIFICANCE  - 0CE
         DC    A(ERROR31)              FP DIVIDE        - 0CF
*
***********************************************************************
*
*        ENTRY POINTS IN IHIIOR USED BY I/O ROUTINES
*
***********************************************************************
*
ADRLST   DC    A(IHIIORCI)
         DC    A(IHIIORCL)
         DC    A(IHIIOREV)
         DC    A(IHIIORNX)
         DC    A(IHIIOROP)
         DC    A(IHIIOROQ)
         DC    A(IHIIOREN)
         DC    A(IHIIORGP)
         DC    A(IHIIORER)
*
***********************************************************************
*
*        INITIAL ENTRY POINT
*
***********************************************************************
*
         DROP  R13
         USING IHIFSAIN,R15
*
IHIFSAIN SAVE  (14,12),,'IHIFSAIN LEVEL 2.1 &SYSDATE &SYSTIME'
*
         L     FSAA,=A(IHIFSARA)
         ST    R13,4(,FSAA)            LINK SAVE AREAS TOGETHER
         ST    FSAA,8(,R13)
         LR    R13,FSAA
         L     R7,=A(IHIFSARB)
         USING IHIFSARB,R7
         B     ALGIN                   TO INITIALIZATION ROUTINE
*
         DROP  R15
         DROP  R7
*
IHIFSARB CSECT
*
***********************************************************************
*
*        INITIALIZATION ROUTINE
*
***********************************************************************
*
*        THIS IS THE FIRST ROUTINE EXECUTED WHEN AN ALGOL
*        PROGRAM IS EXECUTED OR CALLED VIA A PROGRAM
*
*        PERFORM INITIALIZING FUNCTIONS AND TRANSFER CONTROL TO
*        THE ALGOL OBJECT PROGRAM
*
         USING IHIFSARA,R13
         USING IHIFSARB,R7
*
ALGIN    SPIE  PIEROUT,((1,9),12,15)   EXIT FOR RELEVANT PROG CHECKS
*
         ST    R1,FSAPICA(,R13)
*
*        GET STORAGE FOR RETURN ADDR STACK
*        INITIALIZE RAS POINTERS
*
         GETMAIN R,LV=2048
*
         SH    R1,EIGHT(,R13)
         ST    R1,RASPT(,R13)
         ST    R1,RASSTART(,R13)
         LA    R1,2056(,R1)
         ST    R1,RASPB(,R13)
         ST    R1,RASEND(,R13)
         SR    CDSA,CDSA
         L     R5,ADSTAB(R13)          INITIALIZE DS ENTRIES FOR
         L     R2,0(,R5)               S P K Q
         LA    R5,4(,R5)
         LTR   R2,R2                   THERE A PUT/GET CONTROL FILE ?
         BM    ALGIN01A
         LA    R1,2048                 YES
         ST    R1,16(,R2)              INSERT BE LENGTH
         ST    CDSA,24(,R2)            INITIALIZE S, TYP IN PGCF
ALGIN01A LA    R2,0(,R2)               CLEAR HIGH ORDER BYTE
ALGIN01  CR    R2,R5
         BE    ALGIN02
         MVC   20(6,R5),DSINIT
         LA    R5,36(,R5)
         B     ALGIN01
*
ALGIN02  STH   CDSA,TRPGID             INITIALIZE TRACE COUNTERS
         ST    CDSA,TRPGID+2
         STC   CDSA,TRFLAG
         MVI   TRPGID+6,X'FF'
         MVI   TRPGID+7,X'FF'
         STH   CDSA,SCRCS(R13)         INITIALIZE SEMICOLON COUNT
         ST    CDSA,ANOTTAB(R13)       RESET NOTE TABLE ADDR
         ST    CDSA,SPDAP              RESET SPECIAL DECL POINTER
*
*        EXECUTION TIME OPTIONS AND SET SWITCHES
*
*        TEST FOR SHORT/LONG PRECISION
*
         L     R2,=A(IHIENTIF)         GET S/L SWITCH
         MVC   OPTSW(1,R13),8(R2)      FROM THE OBJECT MODULE
         MVC   CNVINST(CNVINSTL),CNVINSTE  ASSUME SHORT
         LA    R2,SETSHORT
         TM    OPTSW(R13),SHSW
         BO    ALGIN4                  IF SHORT
         MVC   CNVINST(CNVINSTL),CNVINSTD    MODIFY CONVERT ROUTINE
         LA    R2,4(,R2)
ALGIN4   LM    R3,R5,FPINSTAD          MODIFY FLOATING POINT
ALGIN4A  EX    0,0(R2)                 INSTRUCTIONS
         BXLE  R3,R4,ALGIN4A
*
*        CHECK EXECUTION PARAMETERS DUMP AND TRACE
*
ALGIN0   OI    TRACE+7(R13),X'F0'      DEACTIVATE BRANCH TO TRACE RT
         MVC   TRPGID+2(4),TRPGID+1    RESET PROGID FOR TRACE
         MVC   TRBEG(8),TRPGID         INITIALIZE TRACE LIMITS
         L     R2,4(,R13)
         ICM   R2,B'1111',24(R2)       R2 -> PARAMETER LIST
         BZ    ALGIN1                  BRANCH IF NO PARAMETERS
         L     R2,0(,R2)               ADDR OF PARAMETER FIELD
         LA    R2,0(,R2)               RESET HIGH ORDER BYTE
         LH    R3,0(,R2)
         LTR   R3,R3                   LENGTH OF PARAMETER FIELD
         BZ    ALGIN1                  NO PARAMETERS
         AR    R3,R2                   END OF PARAMETER FIELD
         LA    R5,LASTPARM             END OF PARAMETER LIST
         SR    R6,R6
FNDCOMMA CLI   2(R2),C','
         BNE   FNDPAR
STEP1    LA    R2,1(,R2)
COMP1    CR    R2,R3
         BL    FNDCOMMA
         B     ALGIN2                  WHOLE PARM FIELD SCANNED
*
FNDPAR   LA    R4,PARMLIST
         USING PARMLIST,R4
NXTPAR   IC    R6,PARMLG               LENGTH OF PARAMETER
         EX    R6,COMPINST             COMPARE WITH ENTRY IN LIST
         BNE   NOTFOUND
         LA    R1,1(R2,R6)
         EX    0,PABRANCH
CHKCOMMA CLI   2(R1),C','              CHECK FOR COMMA AFTER PARAM
         BE    SETBIT
         CR    R1,R3                   IF NO COMMA CHECK FOR END OF
         BL    STEP1                   PARAMETER FIELD
SETBIT   LR    R2,R1
         EX    0,PARMSET
         B     COMP1
*
NOTFOUND CR    R4,R5                   CHECK FOR END OF LIST
         LA    R4,PARLG(,R4)
         BL    NXTPAR                  NEXT ENTRY IN LIST
         B     INVOPT(R13)             OPTION NOT FOUND IN LIST
*
COMPINST CLC   2(0,R2),PARM
         DROP  R4
*
*        EVALUATE TRBEG OR TREND PARAMETER
*
TRLIM1   LA    R8,TRBEG
         B     TRLIM2A
*
TRLIM2   LA    R8,TREND
TRLIM2A  CLI   2(R1),C'='
         BNE   INVOPT(R13)
         LA    R9,5(,R1)               END OF NUMBER FIELD
         SR    R10,R10                 RESET NUMBER ACCUMULATOR
TRLIM4   LA    R1,1(,R1)               STEP TO NEXT DIGIT
         CR    R1,R3
         BNL   TRLIM3                  BR IF END OF WHOLE PARAM FIELD
         CLI   2(R1),C','
         BE    TRLIM3                  BR IF END OF THIS PARAMETER
         CR    R1,R9
         BH    INVOPT(R13)             BR IF TOO MANY DIGITS
         CLI   2(R1),C'0'              CHECK FOR VALID DIGIT
         BL    INVOPT(R13)
         CLI   2(R1),C'9'
         BH    INVOPT(R13)
         MVN   TRLDIG+1(1),2(R1)       EXTRACT NEW DIGIT
         MH    R10,=H'10'
         AH    R10,TRLDIG              ACCUMULATE SUM
         B     TRLIM4
*
TRLIM3   ST    R10,0(,R8)              STORE AS TRBEG OR TREND
         B     SETBIT
*
TRLDIG   DC    H'0'                    TEMP STORAGE FOR DIGIT
*
*        PREPARE FOR PROGRAM TRACING
*
ALGIN2   EQU   *
         TM    DTSW(R13),TRSW          TRACE REQUESTED ?
         BZ    ALGIN1
*
         OPEN  (SYSUT1,(OUTIN))        OPEN SYSUT1 FOR USE BY TRACE
*
         LA    R3,SYSUT1
         USING IHADCB,R3
         TM    DCBOFLGS,DCBOFOPN       SYSUT1 OPENED ?
         BO    ALGIN3
         NI    DTSW(R13),255-TRSW      TRACE SWITCH OFF
         LA    R6,17                   SET DATASET NUMBER TO 17
         B     DDERROR(R13)
*
ALGIN3   NI    TRACE+7(R13),X'0F'      ACTIVATE BRANCH TO TRACE ROUT
         LH    R0,DCBBLKSI             GET BLOCK SIZE FROM DCB
         DROP  R3
         ST    R0,TRBUFL               STORE AS BUFFER LENGTH
         SLA   R0,1
*
         GETMAIN R,LV=(0)              GET TWO BUFFERS FOR SYSUT1
*
         ST    R1,TRBUF                ADDR OF FIRST BUFFER
         SR    R0,R0
         ST    R0,TRCNT                RESET RECORD COUNTER
         LA    R0,4                    SET BYTE POINTER
         STH   R0,0(,R1)
         A     R1,TRBUFL
         ST    R1,TRBUFA               ALTERNATE BUFFER
*
*        INITIALIZE REGISTERS AND ENTER OBJECT MODULE
*
ALGIN1   SR    CDSA,CDSA
         L     R15,=A(IHIENTIF)
         LM    PBT,LAT,0(R15)
         L     R2,16                   R2 -> CVT ADDR
         L     R2,0(,R2)
         L     R2,4(,R2)               R2 -> TCB
         L     R2,0(,R2)               R2 -> RB ADDR
         L     R2,12(,R2)              INSERT RB NAME INTO PBTAB
         MVC   4(4,PBT),8(R2)
         MVC   TRMPNAME,8(R2)
         L     R15,8(,R15)
         BR    R15                     ENTER ALGOL PROGRAM
*
*        DCB EXIT ROUTINE FOR SYSUT1
*
         USING IHADCB,R1
SYSUT1X  LH    R2,DCBBLKSI
         LTR   R2,R2                   BLKSIZE SPECIFIED ?
         BNZ   DCBEXIT1                YES, BRANCH
DCBEXIT2 LA    R2,TRBUFST              ELSE USE STANDARD SIZE
         STH   R2,DCBBLKSI
*
DCBEXIT3 RETURN
*
DCBEXIT1 CH    R2,TRBUFMIN             CHECK BLKSIZE
         BL    DCBEXIT2                IF TOO LOW OR TOO HIGH,
         CH    R2,TRBUFMAX             USE STANDARD SIZE
         BH    DCBEXIT2
         B     DCBEXIT3
*
         DROP  R1
*
TRBUFMIN DC    H'14'                   MINIMUM TRACE BUFFER SIZE
TRBUFMAX DC    H'32760'                MAXIMUM TRACE BUFFER SIZE
*
TRBUFST  EQU   2048                    STANDARD TRACE BUFFER SIZE
*
DSINIT   DC    X'000100500200'         INITIALIZE DSTAB
*
SETSHORT OI    0(R3),SHORTBIT          MODIFY FP INSTR FOR SHORT
         NI    0(R3),255-SHORTBIT      OR LONG PR
*
*        TABLE FOR DECODING OPTION PARAMETERS
*
PARMLIST DC    0H'0'
PARMLG   DC    AL1(3)                  (LENGTH - 1) OF KEYWORD
PARM     DC    CL5'DUMP'               OPTION KEYWORD
*
PABRANCH B     CHKCOMMA                EXIT TO EVALUATION ROUTINE
*
PARMSET  OI    DTSW(R13),DPSW          SET FLAG BIT
PARLG    EQU   *-PARMLG
         DC    AL1(4)
         DC    CL5'TRACE'
         B     CHKCOMMA
*
         OI    DTSW(R13),UCTRSW
         DC    AL1(4)
         DC    CL5'TRBEG'
         B     TRLIM1
*
         OI    DTSW(R13),TRSW
LASTPARM DC    AL1(4)
         DC    CL5'TREND'
         B     TRLIM2
*
         OI    DTSW(R13),TRSW
*
***********************************************************************
*
*        TERMINATION ROUTINE
*
***********************************************************************
*
*        THIS ROUTINE IS ENTERED EITHER FROM THE ALGOL PROGRAM
*        UPON PASSING THE FINAL 'END' STATEMENT (NORMAL
*        TERMINATION) OR FROM THE ERROR ROUTINE (ABNORMAL
*        TERMINATION).
*
*        IN EITHER CASE IT EDITS AND PRINTS THE TRACE INFORMATION
*        IF ANY, CLOSES ALL DATASETS AND RESTORES THE REGISTERS
*        AS THEY WERE AT THE TIME OF ENTRY TO THE ALGOL PROGRAM
*
*        RETURN IS TO OS OR THE CALLING PROGRAM
*        THE COMPLETION CODE IS SET TO ZERO (NORMAL) OR 16
*        (ABNORMAL TERMINATION)
*
ALGTRMA  MVI   COMPCODE+3,16           ENTRY IN CASE OF ERROR
         B     ALGTRM0
*
*        NORMAL ENTRY
*
ALGTRMN  MVI   COMPCODE+3,0
ALGTRM0  LR    FSAA,R13                PREPARE FOR
         L     R5,ADSTAB(,R13)         OUTPUT TO SYSPRINT
         LA    R5,DSTABLEL+4(,R5)      BY MEANS OF I/O ROUTINES
         LA    R6,1                    SET DSNR TO 1 FOR SYSPRINT
         USING DSTABLE,R5
         TM    COMPCODE+3,X'04'
         BO    ALGTRM00
         OI    DSF+1,DS15              FLAG CLOSE FROM IHIFSA
         L     R15,=V(IHIIORCP)        CLOSE ALL DATASETS USED
         BALR  R14,R15
ALGTRM00 OI    OPTSW(R13),TERMSW       FLAG TERM ROUTINE ENTERED
         TM    OPTSW(R13),PRNTERR
         BZ    ALGTRM16                IF SYSPRINT OK
*
         WTO   MF=(E,WTOTRM)           WRITE END EXEC MESSAGE
*
         B     ALGTRM10
*
ALGTRM16 OI    DSF+1,DS11              RE-OPEN SYSPRINT FOR
         OI    DSF,DS2+DS3+DS6         TRACE AND TERM OUTPUT
         TM    COMPCODE+3,X'04'
         BO    ALGTRM1A
         L     R15,=V(IHIIOROP)
         BALR  R14,R15
         B     ALGTRM1B
*
ALGTRM1A MVI   S+1,50
ALGTRM1B BAL   R14,BLANK
         OI    DSF,DS3
         L     R15,=V(IHIIORNX)
         BALR  R14,R15
ALGTRM1  TM    DTSW(R13),TRSW
         BZ    ALGTRM11                NO TRACE OPTION, BRANCH
         TM    OPTSW(R13),UT1ERR
         BO    ALGTRM18                IF SYSUT1 ERROR
         LM    R8,R11,TRBUF            LOAD BUFFER PARAMETERS
         LTR   R11,R11
         BZ    ALGTRM2                 NO RECORDS WRITTEN, BRANCH
*
         CHECK TRCHECK                 CHECK LAST RECORD WRITTEN
*
         LH    R4,0(,R8)
         CH    R4,=H'4'
         BNH   ALGTRM3                 CURRENT BUFFER EMPTY, BRANCH
*
         WRITE TRCHECK,SF,,(R8),MF=E   WRITE LAST RECORD
*
         CHECK TRCHECK
*
         LA    R11,1(,R11)
*
ALGTRM3  CLOSE (SYSUT1,REREAD),TYPE=T  CLOSE TEMPORARY
*
         READ  TRCHECK,SF,,(R8),MF=E   READ FIRST RECORD
*
*        PRINT TRACE HEADLINES
*
ALGTRM2  BAL   R14,TRHEAD
ALGTRM4  LTR   R11,R11
         BNZ   ALGTRM9                 IF RECORDS ON SYSUT1
         LR    R9,R8
         B     ALGTRM5
*
ALGTRM9  CHECK TRCHECK                 CHECK PREVIOUS READ
*
         LM    R8,R9,TRBUF
         LR    R1,R8                   SWITCH BUFFERS
         LR    R8,R9
         LR    R9,R1
         STM   R8,R9,TRBUF
         BCT   R11,ALGTRM6             DECR RECORD COUNTER
         B     ALGTRM5                 NO MORE RECORDS, BRANCH
*
ALGTRM6  READ  TRCHECK,SF,,(R8),MF=E
*
ALGTRM5  LH    R4,0(0,R9)              LOAD BYTE COUNT
         AR    R4,R9                   ADDR OF LAST BYTE PLUS ONE
         LA    R9,4(0,R9)              R9 IS NOW BYTE POINTER
         L     R2,R                    SYSPRINT BYTE POINTER
         B     ALGTRM7
*
ALGTRM8  CLC   0(2,R9),TRPGID          NEXT ITEM A PROGID ?
         BNE   ALGTRM12                NO, BRANCH
         MVC   PROGID(4),2(R9)         STORE PROGID
         LA    R9,6(0,R9)
         B     ALGTRM15
*
ALGTRM12 LA    R3,6(,R2)               ROOM FOR
         C     R3,RE                   ONE MORE OUTPUT ITEM ?
         BL    ALGTRM13                YES, BRANCH
ALGTRM15 OI    DSF,DS3
         L     R15,=V(IHIIORNX)
         BALR  R14,R15
         CLC   S(2),=H'1'              NEW PAGE ?
         BNE   ALGTRM14                NO, BRANCH
         BAL   R14,TRHEAD              PRINT PAGE HEADINGS
         B     ALGTRM15
*
ALGTRM14 L     R2,R
         BAL   R14,BLANK               INITIALIZE WITH BLANKS
         MVC   0(10,R2),PIDFIELD       PROGID AT START OF NEW LINE
         MVC   PROGID(4),PROGID-1      BLANKS TO RPOGID
         LA    R2,PIDLGTH(,R2)
ALGTRM13 LH    R3,0(,R9)
         LA    R9,2(,R9)               CONVERT SEMICOLON COUNTER
         CVD   R3,CONVBUF              PRINT AREA
         MVC   0(L'SCPATTN,R2),SCPATTN    MOVE IN PATTERN
         ED    0(L'SCPATTN,R2),CONVBUF+5  FORMAT SC COUNT
         LA    R2,6(,R2)               STEP OUTPUT BUFFER POINTER
         ST    R2,R
ALGTRM7  CR    R9,R4
         BL    ALGTRM8                 NOT END OF SYSUT1 REC, BRANCH
         LTR   R11,R11
         BNZ   ALGTRM9                 MORE RECORDS TO READ, BRANCH
         OI    DSF,DS3                 PRINT LAST LINE
         L     R15,=V(IHIIORNX)
         BALR  R14,R15
*
*        CLOSE SYSUT1 AND FREE BUFFER AREA
*
ALGTRM18 CLOSE (SYSUT1)
*
         LM    R8,R9,TRBUF             GET LOWER
         LR    R1,R8                   BUFFER ADDR
         CR    R8,R9
         BL    *+6
         LR    R1,R9
         L     R0,TRBUFL
         SLA   R0,1
*
         FREEMAIN R,LV=(0),A=(1)       FREE SYSUT1 BUFFER
*
*        PRINT EXECUTION END MESSAGE
*
ALGTRM11 L     R2,R                    BYTE POINTER
         MVC   0(TML,R2),TRMSG         MOVE TERMINATION MESSAGE
         LA    R2,TML(,R2)
         ST    R2,R                    UPDATE BYTE POINTER
         LA    R2,2                    LOOP COUNTER FOR BLANK LINES
ALGTRM19 BAL   R14,BLANK
         OI    DSF,DS3
         L     R15,=V(IHIIORNX)
         BALR  R14,R15
         BCT   R2,ALGTRM19             ONE EXTRA BLANK LINE
         OI    DSF+1,DS15              FLAG CLOSE FROM IHIFSA
         L     R15,=V(IHIIORCL)        CLOSE SYSPRINT
         BALR  R14,R15
*
*        FINAL CLEAN-UP
*
ALGTRM10 L     R1,RASSTART(R13)        FREE RETURN ADDR STACK
         LA    R1,8(,R1)
*
         FREEMAIN R,LV=2048,A=(1)
*
ALGTRM17 L     R2,FSAPICA(,R13)
*
         SPIE  MF=(E,(R2))             RESTORE PICA
*
ALGTRMAA L     R13,4(,R13)
         L     R15,COMPCODE            RETURN CODE INTO R15
*
         RETURN (14,12),RC=(15)        TO OS OR THE CALLING PROGRAM
*
*        ROUTINE FOR FILLING A SYSPRINT RECORD WITH BLANKS
*
BLANK    STM   R2,R3,BLANKS
         L     R2,R                    CURRENT BYTE POINTER
         L     R3,RE                   RECORD END POINTER
BLANKA   CR    R2,R3
         BNL   BLANKB                  RECORD END, BRANCH
         MVI   0(R2),C' '              INSERT ONE BLANK
         LA    R2,1(,R2)               STEP TO NEXT BYTE
         B     BLANKA                  LOOP TO PROCESS NEXT CHAR
*
BLANKB   ST    R2,R                    UPDATED BYTE POINTER
         LM    R2,R3,BLANKS
         BR    R14
*
BLANKS   DC    2F'0'
*
*        ROUTINE FOR PRINTING TRACE OUTPUT HEADING
*
TRHEAD   STM   R14,R12,ASAVE+12(R13)   USE SECOND SAVE AREA
         LM    R2,R4,TRHADR            COUNTER FOR HEADLINES
TRHEAD1  L     R1,R
         BAL   R14,BLANK               INITIALIZE WITH BLANKS
         EX    0,0(R4)                 MOVE TEXT, OR NOP
         OI    DSF,DS3
         L     R15,=V(IHIIORNX)
         BALR  R14,R15
         BXLE  R4,R2,TRHEAD1
         BAL   R14,BLANK               BLANK LINE AFTER HEADING
         LM    R14,R12,ASAVE+12(R13)
         BR    R14
*
TRHADR   DC    A(6,TRHEND,TRHLIST)
*
TRHLIST  NOP   0                       BLANK LINE
         NOPR  0
         MVC   0(L'TRHEADA,R1),TRHEADA
         NOP   0                       BLANK LINE
         NOPR  0
TRHEND   MVC   0(L'TRHEADB,R1),TRHEADB
*
TRHEADA  DC    C'  ALGOL PROGRAM TRACE'         FIRST HEADLINE
*
TRHEADB  DC    C'MODULE     SEMICOLON NUMBERS'  SECOND HEADLINE
*
SCPATTN  DC    X'402020202020'         FORMAT SEMICOLON COUNT VALUE
*
WTOTRM   WTO   'END OF ALGOL PROGRAM EXECUTION',ROUTCDE=11,DESC=7,MF=L
*
TRMSG    EQU    WTOTRM+4
TML      EQU   *-TRMSG-4
*
*        ERROR AND END OF DATA ROUTINE FOR SYSUT1
*
ENDUT1   OI    OPTSW(R13),UT1ERR       SYSUT1 ERROR SWITCH ON
         LA    R6,17                   DUMMY DS NUMBER FOR SYSUT1
         B     ERROR32
*
*        PARAMETER LIST USED BY BOTH READ AND WRITE MACROS FOR
*        SYSUT1
*
         WRITE TRCHECK,SF,SYSUT1,MF=L
*
*        PARAMETERS FOR TRACE BUFFER
*
TRBUF    DC    F'0'                    ADDR OF CURRENT BUFFER
TRBUFA   DC    F'0'                    ADDR OF ALTERNATE BUFFER
TRBUFL   DC    F'0'                    LENGTH OF BUFFER
TRCNT    DC    F'0'                    RECORD COUNTER
*
*        THE BYTE POINTER IS CONTAINED IN THE FIRST TWO BYTES OF
*        THE RECORD AND SERVES AS RECORD LENGTH FIELD
*
COMPCODE DC    F'0'                    COMPLETION CODE (0 OR 16)
*
*        WORK STORAGE FOR EDITING THE TRACE LISTING
*
PIDFIELD DC    CL2' '
PROGID   DC    CL4' '                  MODULE NAME
         DC    CL4' '
PIDLGTH  EQU   *-PIDFIELD
CONVBUF  DC    D'0'                    FOR CONVERTING SEMICOLON NUMBER
*
*        DCB FOR SYSUT1
*
SYSUT1   DCB   DSORG=PS,MACRF=(R,W),DDNAME=SYSUT1,RECFM=F,             X
               EODAD=ENDUT1,EXLST=EXLUT1,SYNAD=ENDUT1
*
EXLUT1   DC    X'85',AL3(SYSUT1X)
*
*        LTORG
*
*
*        DATASET TABLE ENTRY
*
         DSTABLE DSECT=YES
*
         PRINT NOGEN
*
         DCBD  DSORG=(BS),DEVD=(DA,TA)
*
         PRINT GEN
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIGPR   0201-12230-12230-1200-00906-00906-00000-LEVEL
GPR      TITLE 'IHIGPRTN, PUT/GET, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*
*        ACTION OF PUT -
*        TRANSFER DATA INDICATED BY A LIST PROCEDURE, WHICH IS THE
*        SECOND PARAMETER IN PUT, TO AN I/O BUFFER IN BINARY FORM
*        WRITE A RECORD, V-FORM, TO A DASD DATASET WITH A
*        DDNAME OF SYSUT2. ENTER REPOSITIONING INFORMATION IN
*        NOTTAB
*
*        ACTION OF GET -
*        RETRIEVE INFORMATION AFTER REPOSITIONING OF DATASET
*        STORED BY PUT AND ASSIGN DATA TO IDENTIFIER IN LIST
*        PROCEDURE
*
*        ENTRY POINTS -
*        IHIGPRPT - FROM GENERATED OBJECT MODULE
*                   DATA PASSED BY NAME
*                   LA   R1,PARMLIST
*                   BALR R14,R15
*
*        IHIGPROT - FROM IHIFSA
*                   PROCEDURE IS ACTUAL PARAMETER OF LIST DATA
*                   PASSED BY NAME R15 POINTS TO A THUNK FIELD
*
*        IHIGPRGT - FROM GENERATED OBJECT MODULE
*                   DATA PASSED BY NAME
*                   LA   R1,PARMLIST
*                   BALR R14,R15
*
*        IHIGPRIT - FROM IHIFSA
*                   PROCEDURE IS ACTUAL PARAMETER OF LIST DATA
*                   PASSED BY NAME R15 POINTS TO A THUNK FIELD
*
*        IHIGPRCL - FROM IHIIOR - CLOSE DATASET
*                   NO DATA PASSED
*                   BALR R14,R15
*
*        INPUT -
*        GET READS A RECORD STORED PREVIOUSLY BY PUT, DATA IN
*        BINARY FORM
*
*        OUTPUT - STORES DATA IN BINARY FORM
*
*        EXTERNAL ROUTINES -
*        IHIIOR - CONVERT REAL TO INTEGER - ENTRY NOTTAB - SYNAD
*
*        EXITS - NORMAL -
*                FOR ROUTINE PUT AND GET RELOAD REGISTERS AND BR14
*                FOR PROCEDURE OUTPUT AND INPUT SEE BELOW
*              - ERROR -
*                NO.10 DATASET CLOSED
*                NO.14 BACK WARD REPOSITIONING NOT DEFINED
*                NO.20 ACTUAL AND FORMAL PARAMETER OF DIFFERENT TYPE
*                NO.21 NUMBER OF PARAMETERS DOES NOT CORRESPOND
*                NO.36 TOO MANY NESTED BLOCKS PROCEDURES AND PARAMETERS
*                NO.38 GET/PUT BUFFER OVERFLOW
*                NO.39 GET/PUT IDENTIFICATION OUT OF RANGE
*                NO.41 DDCARD INCORRECT OR MISSING
*                NO.43 RECURSIVELY TRY OF PUT/GET OR OUTPUT/INPUT
*        ACTION - BRANCH TO IHIFSA
*                 LA  R13,IHIFSA
*                 B   FSAERR+XX*4(R13)  XX ERROR NO
*
*        TABLES/WORKAREAS - N/A
*
*        ATTRIBUTES - SERIALLY REUSABLE
*
*        NOTES -
*        THE LIST PROCEDURE HAS ONE FORMAL PARAMETER WHICH IS A
*        PROCEDURE AND WHICH ONLY IS DECLARED AND HAS NO
*        PROCEDURE BODY IN THE ALGOL PROGRAM, AT ACTUAL POSITION
*        THIS IS OUTPUT RESP. INPUT ADDR OF PUT/GET FIELD IN
*        DSTAB LOADED TO R5 R6=16 IS KEPT THROUGH THE
*        MODULE IN ORDER TO ADDR THIS FIELD
*
IHIGPRTN CSECT
*
         ENTRY IHIGPRPT
         ENTRY IHIGPROT
         ENTRY IHIGPRGT
         ENTRY IHIGPRIT
         ENTRY IHIGPROP
         ENTRY IHIGPRCL
*
*        FLOATING POINT REGISTER
*
FPR0     EQU   0
*
*        DISPLACEMENTS IN ADRLST IN IHIFSA
*
*                                      DISPLACEMENT FOR
CI       EQU   0                       IHIIORCI
CL       EQU   4                       IHIIORCL
EV       EQU   8                       IHIIOREV
NX       EQU   12                      IHIIORNX
OP       EQU   16                      IHIIOROP
OQ       EQU   20                      IHIIOROQ
EN       EQU   24                      IHIIOREN
GP       EQU   28                      IHIIORGP
ER       EQU   32                      IHIIORER
*
*        PUT/GET FLAGS
*
PG0      EQU   X'80'
PG1      EQU   X'40'
*
         USING IHIGPRPT,R15
*
IHIGPRPT IHIENTRY 'IHIGPRPT LEVEL 2.1 &SYSDATE &SYSTIME'
*
         ST    R13,SAVEPG+4            SAVE REGISTER INTERNALLY
         LA    R13,SAVEPG
*
         SAVE  (14,12)
*
         DROP  R15
         LR    R7,R15
         USING IHIGPRPT,R7
         ST    R13,SAVEPUT+4
         L     R12,SAVEPG+4            ADDR OF FSA
         LA    R13,SAVEPUT
         L     R5,ADSTAB(R12)          FIRST ENTRY IN DSTAB IS APGCF
         L     R5,0(,R5)               ADDR OF PGCF IN R5
         LA    R6,16                   SET DSN NUMBER TO 16 FOR SYSUT2
         USING PGCF,R5
         TM    RECPG,X'01'             TEST IF RECURSIVELY
         BO    ERROR43                 YES
         OI    RECPG,X'01'             SET FLAG BIT
         TM    PG,PG0                  DATASET OPEN ?
         BZ    PUT1                    DATASET NOT OPEN
*                                      DATASET WAS OPEN
         L     R8,ADCB                 LOAD REGISTER FOR ADDRESSING
         USING IHADCB,R8               DCB AND DECB
         TM    PG,PG1                  TEST LAST PROCEDURE
         BO    PUT2                    LAST PROCEDURE WAS GET
*
         CHECK DECB                    CHECK THE PREVIOUS WRITE
*
         NOTE  (R8)
*
         LA    R5,4(,R5)
         L     R15,IORLST(R12)
         L     R15,EN(,R15)            R15 -> IHIIOREN
         BALR  R14,R15                 CLEAR NOTTAB
         SH    R5,=H'4'
         B     PUT3
*
PUT2     L     R2,NOTEADR              LAST PROCEDURE WAS GET
         LA    R2,1(,R2)               INCREASE NOTEADR BY ONE
         ST    R2,NOTEADR
         LR    R1,R8
*
         POINT (1),NOTEADR             REPOSITION DATASET FOR WRITE
*
         NI    PG,X'BF'                PG1=0 INDICATE PUT IS EXECUTED
         B     PUT3
*
PUT1     L     R15,AOPENPG             CALL FOR ROUTINE OPEN DATASET
         BALR  R14,R15
         L     R8,ADCB
*
*        EVALUATE IDENTIFICATION NUMBER FIRST PARAMETER
*
PUT3     L     R1,SAVEPG+24            GET CALLERS R1
         ICM   R2,B'1111',0(R1)        CONVERSION IS NECESSARY ?
         BP    PUT4                    NO CONVERSION
         TM    OPTSW(R12),X'20'        CONVERSION TO INTEGER NECS
         BO    PUT31                   SHORT PRECISION
         LD    FPR0,0(,R2)             PARAMETER TO FPR0
         B     PUT31A
*
PUT31    LE    FPR0,0(,R2)
PUT31A   L     R15,IORLST(R12)
         L     R15,CI(R15)             R15 -> IHIIORCI
         BALR  R14,R15                 CALL CONVERSION ROUTINE
         B     PUT4A
*
PUT4     L     R0,0(,R2)               PARAMETER TO R0
PUT4A    LTR   R0,R0
         BM    ERROR39
         C     R0,TWOP16               TWOP16= 2**16
         BNL   ERROR39
*                                      GET/PUT IDENTIFICATION WITHIN
*                                      RANGE
         STH   R0,S                    STORE IDENTIFICATION IN PGCF
*
*        TEST IF S ALREADY USED AS IDENTIFICATION NUMBER
*
         L     R9,ANOTTAB(R12)
         LR    R10,R9
PUTNOT   LA    R10,8(,R10)
         C     R10,0(,R9)
         BE    PUT41                   NO ENTRY WITH S FOUND
         LR    R2,R6
         CH    R2,0(,R10)
         BNE   PUTNOT
         CLC   S(2),2(R10)
         BNE   PUTNOT
         MVI   0(R10),X'80'            AN ENTRY FOR S IN NOTTAB
*                                      INSERT INVALID FLAG
PUT41    L     R4,BB
         LA    R4,12(,R4)              INSERT CORRECT CHAR POINTER
         ST    R4,R
         MVI   TYP,0                   CLEAR TYP
*
         SAVE  (14,12)                 PUT'S REGISTER SAVED IN SAVEPUT
*
         L     R13,SAVEPUT+4           RESTORE PROGRAMS REGISTER
         LM    R14,R12,12(R13)
         L     R8,4(,R1)               ADDR TO LIST
*                                      PROCEDURE IN R8
         USING IHIGPRPT,R15
         L     R13,SAVEPG+4
         DROP  R15
         CNOP  0,4
         BAL   R15,PROLOG(R13)
*
         DC    A(THUNKOUT)
         DC    X'8880'                 TYPE INFORMATION FOR STAND PROC
         DC    H'1'
*
         USING *,R15
         LA    R13,SAVEPUT
         DROP  R15
         LM    R14,R12,12(R13)         RELOAD PUT'S REGISTER
         L     R4,R                    RECORD POINTER TO R4
         S     R4,BB                   R-BB
         L     R3,BB                   BUFFER BEGIN
         STH   R4,0(,R3)               BLOCK LENGTH TO BUFFER
         SH    R4,=H'4'                R-BB-4
         LA    R3,4(,R3)
         STH   R4,0(,R3)               RECORD LENGTH OT RECORD IN BUFF
         MVC   4(2,R3),S               STORE S IN RECORD
         MVC   6(1,R3),TYP
         L     R3,BB                   BUFFER BEGIN
         MVI   RECPG,0                 CLEAR FLAG BIT
*
         WRITE DECB,SF,(R8),(R3),MF=E        WRITE BUFFER
*
         L     R13,SAVEPUT+4
         LM    R14,R12,12(R13)
         USING IHIGPRPT,R15
         L     R13,SAVEPG+4
         BR    R14
*
SAVEPUT  DC    18F'0'
*
         DROP  R15
*
***********************************************************************
*
*        IHIGPROT - OUTPUT IS ACTUAL PROCEDURE TO LIST
*        EVALUATED BY THUNKOUT
*
***********************************************************************
*
*        REGISTER CONTENTS ON ENTRY POINT IHIGPROT
*
*        R13                           -> FSA
*        R15                           -> A THUNKFIELD
*        R8                            -> ENTRY POINT
*
*        REGISTER CONTENTS ON ENTRY POINT OUTPUTTH OUTPUT BUFFER
*
*        R15                           -> OUTPUTTH
*        R8                            -> VALUE TO BE TRANSFERED TO
*                                         OTHER GENERAL REG
         CNOP  0,8
         USING IHIGPROT,R8
*
IHIGPROT IHIENTRY 'IHIGPROT LEVEL 2.1 &SYSDATE &SYSTIME',REG=R8
*
         ST    R13,SAVEOI+4
         LA    R13,SAVEOI
*
         SAVE  (14,12)
*
         ST    R13,SAVOUTP+4
         DROP  R8
         LR    R7,R8                   FIXED STORAGE AREA ON ENTRY
         USING IHIGPROT,R7
         ST    R13,SAVOUTP+4
         L     R12,SAVEOI+4            R12 -> FSA
         LA    R13,SAVOUTP
         L     R5,ADSTAB(R12)
         L     R5,0(,R5)               R5 -> PGCF
         LA    R6,16                   SET DSNR TO 16 FOR SYSUT2
         USING PGCF,R5                 FOR DSECT ADDRESSING
         TM    RECOI,X'01'             TEST IF RECURSIVELY
         BO    ERROR43                 YES
         OI    RECOI,X'01'             SET FLAG BIT
         CLI   7(R15),X'01'            TEST NUMBER OF PARAMETER
         BNE   ERROR21
         TM    5(R15),X'03'            TEST TYP INFORMATION ABOUT FIRST
         BZ    ERROR20                 PARAMETER
         TM    5(R15),X'04'            TEST IF ARRAY
         BO    ERROR20                 ARRAY
         TM    5(R15),X'C0'
         BZ    OUTPUT01                NO
         TM    5(R15),X'40'
         BZ    ERROR20                 STANDARD PROC IDENTIFIER
         TM    4(R15),X'C0'
         BM    OUTPUT01
         BZ    OUTPUT01
         MVI   PARTST,X'01'            SET BIT FOR LATER TEST
OUTPUT01 TM    TYP,X'FF'               TEST TYP FIELD IN PGCF
         BZ    OUTPUT1                 NO TYP INFORMATION IN PGCF
         MVC   TYPC(1),5(R15)          PGCF CONTAIN TYP INFORMATION
         NI    TYPC,X'03'
         CLC   TYP(1),TYPC
         BNE   ERROR20
         B     OUTPUT2
*
OUTPUT1  MVC   TYP(1),5(R15)
         NI    TYP,X'03'
*
OUTPUT2  MVC   ADRTHUNK(4),0(R15)
*
         SAVE  (14,12)                 SAVE OUTPUT'S REGISTER IN
*                                      SAVEOUTP
         L     R13,SAVOUTP+4           RESTORE CALLING ROUTINES REGS
         LM    R14,R12,12(R13)
*
***********************************************************************
*
*        LINKING TO ROUTINE CALLING ACTUAL PARAMETER
*
         USING IHIGPROT,R8
         L     R13,SAVEOI+4
         CNOP  2,4
         MVC   *+12(2),8(R10)          MOVE PROGRAM BLOCK NUMBER
         BAL   R15,CAP1GP
         DROP  R8
         USING *,R15
*
         DC    H'0'
         DC    H'0'
         NOP   0
*
OUTPUTTH LA    R13,SAVOUTP
         DROP  R15
         LM    R14,R7,12(R13)          RESTORE OUTPUT'S REGISTER
         LM    R9,R12,56(R13)          EXCEPT R8
         B     OUTPUTAA                BRANCH OVER SAVEAREA
*
SAVOUTP  DC    18F'0'
*
***********************************************************************
*
OUTPUTAA TM    PARTST,X'01'
         BZ    OUTPUT25
         LA    R2,FCTVALST(R12)
         CR    R2,R8
         BNE   ERROR20
         MVI   PARTST,X'00'
OUTPUT25 SR    R9,R9
         TM    TYP,X'03'
         BM    OUTPUT3
         LA    R9,1(,R9)               BOOLEAN VALUE
         B     OUTPUT5
*
OUTPUT3  TM    TYP,X'01'
         BZ    OUTPUT4
OUTPUT3A LA    R9,4(,R9)               INTEGER VALUE
         B     OUTPUT5
*
OUTPUT4  TM    OPTSW(R12),X'20'        REAL VALUE TEST IF LONG/SHORT
         BO    OUTPUT3A                SHORT
         LA    R9,8(,R9)               LONG
*
OUTPUT5  L     R4,R                    INSERT VALUE TO RECORD BUFFER
         LR    R2,R4
         AR    R2,R9
         C     R2,BE
         BH    ERROR38
OUTPUT51 BCTR  R9,0
         EX    R9,OUTINMOV
         LA    R9,1(,R9)
         AR    R4,R9                   INCREASE CHARACTER POINTER
         ST    R4,R
         MVI   RECOI,X'00'             CLEAR FLAG BIT
         L     R13,SAVOUTP+4           RESTORE CALLING ROUTINES REGS
         LM    R14,R12,12(R13)
         USING IHIGPROT,R8
         L     R13,SAVEOI+4
         DROP  R8
         B     8(,R15)
*
*        THUNK OUT
*
*        LIST PROCEDURE INVOKE CALL ACTUAL PARAMETER IN IHIFSA
*        AND THIS CALL THUNKOUT, WHICH ASSIGNS OUTPUT AS ACTUAL
*        PROCEDURE TO LIST
*
PBT      EQU   11                      REGISTER
LAT      EQU   12
FSB      EQU   13                      ADDRESS OF FIXED STORAGE AREA
*
*        DISPLACEMENT IN FSA
*
         CNOP  2,4
THUNKOUT BALR  R15,0
         L     R8,8(,R15)
         B     12(R15)
*
         DC    A(IHIGPROT)             INFORMATION CHARACTERISE OUTPUT
*
         MVI   PROLPBN(FSB),X'00'
         STM   PBT,LAT,PROLREG(FSB)
         B     CAP2(0,FSB)
*
***********************************************************************
*
*        IHIGPRGT - GET ROUTINE
*
***********************************************************************
*
*        REGISTER CONTENTS ON ENTRY POINT IHIGPRGT
*
*        R15                           -> ENTRY POINT
*        R14                           -> RETURN
*        R13                           -> SAVE AREA IN FSA
*        R1                            -> PARAMETER LIST
*
         USING *,R15
*
IHIGPRGT IHIENTRY 'IHIGPRGT LEVEL 2.1 &SYSDATE &SYSTIME'
*
         ST    R13,SAVEPG+4
         LA    R13,SAVEPG
*
         SAVE  (14,12)
*
         DROP  R15
         LR    R7,R15
         USING IHIGPRGT,R7
         L     R12,SAVEPG+4            ADDR OF FIXED ST AREA
         ST    R13,SAVEGET+4
         LA    R13,SAVEGET
         L     R5,ADSTAB(R12)          FIRST ENTRY IN DSTAB IS APGCF
         L     R5,0(,R5)               R5 -> PGCF TO
         LA    R6,16                   SET DSNR TO 16 FOR SYSUT2
         USING PGCF,R5
         TM    RECPG,X'01'             TEST IF RECURSIVELY
         BO    ERROR43                 YES
         OI    RECPG,X'01'             SET FLAG BIT
         TM    PG,PG0                  DATASET OPEN ?
         BZ    ERROR10                 DATASET NOT OPEN
         L     R8,ADCB                 LOAD REGISTER FOR ADDRESSING
         USING IHADCB,R8               DCB AND DECB
         TM    PG,PG1                  TEST LAST PROCEDURE
         BO    GET1                    LAST PROCEDURE WAS GET
*
         CHECK DECB                    CHECK THE PREVIOUS WRITE
*
         NOTE  (R8)
*
         ST    R1,NOTEADR              INFORMATION ABOUT THE LAST
*                                      RECORD WRITTEN TO PGCF TO
*                                      HAVE FOR A LATER PUT
*                                      WHERE TO CONTINUE DATASET
         OI    PG,PG1                  PG1=1 INDICATING GET IS EXECUTED
         LA    R5,4(,R5)
         L     R15,IORLST(R12)
         L     R15,EN(R15)             R15 -> IHIIOREN
         BALR  R14,R15                 CLEAR NOTTAB
         SH    R5,=H'4'                RESTORE PGCF ADDR
*
*        EVALUATE IDENTIFICATION NUMBER FIRST PARAMETER
*
GET1     L     R1,SAVEPG+24            GET CALLERS R1
         ICM   R2,B'1111',0(R1)        CONVERSION REQUIRED ?
         BP    GET2                    NO CONVERSION
         TM    OPTSW(R12),X'20'        CONVERSION TO INTEGER NECESSARY?
         BO    GET11                   SHORT PROCSISION
         LD    FPR0,0(,R2)             LONG
         B     GET11A                  PARAMETER TO FPR0
*
GET11    LE    FPR0,0(,R2)
GET11A   L     R15,IORLST(R12)
         L     R15,CI(R15)
         BALR  R14,R15                 CALL CONVERSION ROUTINE
         B     GET2A
*
GET2     L     R0,0(,R2)
GET2A    LTR   R0,R0                   IDENTIFICATION NUMBERS IN R0
         BM    ERROR39
         C     R0,TWOP16
         BNL   ERROR39
         STH   R0,S                    GET/PUT IDENT WITHIN RANGE
         L     R4,BB
         LA    R4,12(,R4)              INSERT CORRECT CHARACTER POINTER
         ST    R4,R
*
*        EXAMINE NOTTAB TO FIND AN ENTRY FOR S
*
GET12    L     R9,ANOTTAB(R12)         R9 -> NOTTAB
         LR    R10,R9                  COPY TO R10
GET3     LA    R10,8(,R10)             INCR ADDR BY RIGHT
         C     R10,0(,R9)              COMPARE WITH NXE
         BE    ERROR14                 NO ENTRY FOR S FIND IN NOTTAB
         LR    R2,R6                   DATASET NUMBER TO R2
         CH    R2,0(,R10)              DATASET NUMBER = 16 ?
         BNE   GET3                    DATASET NUMBER ¬= 16 LOOP
         CLC   S(2),2(R10)             S IS EQUAL IN NOTTABENTRY ?
         BNE   GET3                    NO, NEXT ENTRY IN NOTTAB
*                                      FOUND AN ENTRY IN NOTTAB FOR S
         LA    R0,4(,R10)              ADDR OF NOTE INFORMATION
         LR    R1,R8                   DCB ADDR TO R1
*
         POINT (1),(0)
*
         L     R3,BB
*
         READ  DECB,SF,(R8),(R3),MF=E  READ A BLOCK TO BUFFER
*
         CHECK DECB                    CHECK THIS READ
*
         CLC   8(2,R3),S               TEST IDENTIFICATION NUMBER
         BNE   ERROR14
         MVC   TYP(1),10(R3)           TYP INFORMATION TO PGCF
         AH    R3,0(,R3)               BB+BL
         ST    R3,RE                   EFFECTIVE END OF RECORD CURRENT
         L     R1,SAVEPG+24
         L     R13,SAVEGET+4           RESTORE PROGRAMS REGISTER
         LM    R14,R12,12(R13)
         L     R8,4(,R1)               ADDR OF LIST PROCEDURE
         USING IHIGPRGT,R15
         L     R13,SAVEPG+4
         DROP  R15
         CNOP  0,4
         BAL   R15,PROLOG(R13)
*
         DC    A(THUNKIN)
         DC    X'8880'                 TYP INFORMATION FOR STANDARD
*                                      PROCEDURE
         DC    H'1'
*
         USING *,R15
         LA    R13,SAVEPG
         LM    R14,R12,12(R13)
         USING IHIGPRGT,R15
         L     R13,SAVEPG+4
         MVI   RECPG,X'00'             CLEAR FLAG BIT
         BR    R14
*
SAVEGET  DC    18F'0'
         DROP  R15
*
***********************************************************************
*
*        IHIGPRIT - INPUT IS ACTUAL PROCEDURE TO LIST
*        EVALUATED BY THUNKIN
*
***********************************************************************
*
*        REGISTER CONTENTS ON ENTRY POINT IHIGPRIT
*
*        R13                           R13 -> FSA
*        R8                            R8 -> ENTRY POINT IHIGPRIT
*        R15                           R15 -> A THUNKFIELD
*
*        REGISTER CONTENTS ON ENTRY POINT INPUTTH
*
*        R15                           -> INPUTTH
*        R8                            -> PARAMETER WHERE TO
*                                         STORE VALUE FROM BUFFER
         USING IHIGPRIT,R8
*
IHIGPRIT IHIENTRY 'IHIGPRIT LEVEL 2.1 &SYSDATE &SYSTIME',REG=R8
*
         ST    R13,SAVEOI+4
         LA    R13,SAVEOI
*
         SAVE  (14,12)
*
         ST    R13,SAVEIN+4
         LR    R7,R8                   FIXED STORAGE AREA ON ENTRY
         DROP  R8
         USING IHIGPRIT,R7
         L     R12,SAVEOI+4
         LA    R13,SAVEIN
         L     R5,ADSTAB(R12)
         L     R5,0(,R5)               R5 -> PGCF
         LA    R6,16                   DSNR = 16 FOR SYSUT2
         USING PGCF,R5                 DSECT ADDRESSABILITY
         TM    RECOI,X'01'             TEST IF RECURSIVELY
         BO    ERROR43                 YES
         OI    RECOI,X'01'             SET FLAG BIT
         CLI   7(R15),X'01'            TEST NUMBER OF PARAMETERS
         BNE   ERROR21                 NUMBER DOES NOT CORRESPOND
*                                      BETWEEN DECLARATION AND CALL
         TM    4(R15),X'08'            ASSIGNMENT POSSIBLE ?
         BO    ERROR20
         MVC   TYPC(1),5(R15)
         NI    TYPC,X'03'
         CLC   TYP(1),TYPC
         BNE   ERROR20                 PGCF
*
***********************************************************************
*
*        LINKING TO ROUTINE CALLING ACTUAL PARAMETER
*
         SAVE  (14,12)                 SAVE REGISTER IN SAVEIN
*
         L     R13,SAVEIN+4
         MVC   ADRTHUNK(4),0(R15)
         LM    R14,R12,12(R13)         RESTORE PROGRAMS REGISTER
         USING IHIGPRIT,R8
         L     R13,SAVEOI+4
         CNOP  2,4
         MVC   *+12(2),8(R10)          MOVE PROGRAM BLOCK NUMBER
         BAL   R15,CAP1GP
         DROP  R8
         USING *,R15
*
         DC    H'0'
         DC    H'0'
         NOP   0
*
INPUTTH  LA    R13,SAVEIN
         DROP  R15
         LM    R14,R7,12(R13)          RESTORE INPUT'S REGISTER EXCEPT
         LM    R9,R12,56(R13)          R8
         B     INPUTTAA                BRANCH OVER SAVEAREA
*
SAVEIN   DC    18F'0'
*
*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
*
INPUTTAA L     R3,BB
         AH    R3,0(,R3)
         C     R3,R
         BNH   ERROR38                 BUFFER OVERFLOW
         SR    R9,R9
         TM    TYP,X'03'
         BM    INPUT1
         LA    R9,1(,R9)               BOOLEAN VALUE
         B     INPUT3
*
INPUT1   TM    TYP,X'01'
         BZ    INPUT2
INPUT1AA LA    R9,4(,R9)               INTEGER VALUE
         B     INPUT3
*
INPUT2   TM    OPTSW(R12),X'20'        REAL VALUE TEST IF LONG/SHORT
         BO    INPUT1AA                SHORT
         LA    R9,8(,R9)               LONG
*
INPUT3   L     R4,R
INPUT31  BCTR  R9,0
         EX    R9,INOUTMOV
         LA    R9,1(,R9)
         AR    R4,R9                   INCREASE CHARACTER POINTER
         ST    R4,R
         MVI   RECOI,0                 CLEAR FLAG BIT
         L     R13,SAVEIN+4
         LM    R14,R12,12(R13)
         USING IHIGPRIT,R8
         L     R13,SAVEOI+4
         DROP  R8
         B     8(,R15)
*
*        THUNK IN
*
*        LIST PROCEDURE INVOKE CALL ACTUAL PARAMETER IN IHGFSA
*        AND THIS CALL THUNKIN, WHICH ASSIGN INPUT AS ACTUAL
*        PROCEDURE TO LIST
*
         CNOP  2,4
THUNKIN  BALR  R15,0
         L     R8,8(,R15)
         B     12(,R15)
*
         DC    A(IHIGPRIT)             INFORMATION CHARACTERISE OUTPUT
*
         MVI   PROLPBN(FSB),X'00'
         STM   PBT,LAT,PROLREG(FSB)
         B     CAP2(,FSB)
*
*        OPEN DATASET SYSUT2
*
*        RESERVE MAIN FOR ONE DCB AND ONE DECB, ONE I/O BUFFER
*        AND FOR NOTTAB IF NOT CREATED BEFORE
*
IHIGPROP SAVE  (14,12),,'IHIGPROP LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15
         USING IHIGPROP,R7
         USING IHADCB,R8
         ST    R13,SAVEOP+4
         LA    R13,SAVEOP
         LA    R2,IHIGPRCL
         L     R9,IORLST(R12)
         L     R9,GP(,R9)
         ST    R2,0(,R9)
         ICM   R2,B'1111',ANOTTAB(R12)  NOTTAB ALREADY GETMAINED ?
         BP    OPGP1                   YES, BRANCH
         LA    R0,1024
*
         GETMAIN R,LV=(0)              GET AREA FOR NOTTAB
*
         ST    R1,ANOTTAB(R12)         SAVE GETMAINED AREA ADDR
         LR    R2,R1                   ANOTTAB TO R2
         LR    R9,R1                   ANOTTAB TO R9
         LA    R9,8(,R9)
         ST    R9,0(,R2)               STORE POINTER NXE IN NOTTAB
         LA    R9,1016(,R9)
         ST    R9,4(,R2)               STORE POINTER NXEF IN NOTTAB
*
OPGP1    LA    R0,DCBAREAL             GET AREA FOR DCB AND DECB
*
         GETMAIN R,LV=(0)
*
         ST    R1,ADCB
         LR    R8,R1
*
*        TRANSFER DCBMODEL
*
         MVC   0(DCBMODLN,R8),DCBMODEL
         L     R1,IORLST(,R12)          INSERT SYNAD
         L     R1,ER(,R1)               ADDR TO
         ST    R1,DCBSYNAD              IHIIORER
*
         OPEN  ((R8),(OUTIN))           OPEN DATASET
*
         TM    DCBOFLGS,DCBOFOPN        OPEN SUCCESSFUL ?
         BO    OPGP2                    YES, BRANCH
         LR    R13,R12                  OPEN FAILED
         B     FSAERR+41*4(R12)
*
OPGP2    L     R0,BE                    BE=BUFFER LENGTH
*
         GETMAIN R,LV=(0)               GET AREA FOR RECORD BUFFER
*
         ST    R1,BB
         A     R1,BE                    BB+BE TO BE
         ST    R1,BE                    BE DEFINE BUFFER END
         OI    PG,PG0                   PG0=1 DATASET OPEN
         L     R13,SAVEOP+4
*
         RETURN (14,12)
*
*        OPEN EXIT ROUTINE
*
IHIGPRDX LH    R2,DCBBLKSI             DCBBLKSI = 0 ?
         LTR   R2,R2
         BZ    EXIT1                   BLKSIZE = 0
         ST    R2,BE                   BLKSIZE NOT ZERO
         B     EXIT1+8
*
EXIT1    L     R2,BE                   BE=2048 TO BLKSIZE
         STH   R2,DCBBLKSI
*
         RETURN
*
*        CLOSE DATASET SYSUT2
*
*        RELEASE DCB, DECB AND I/O BUFFER
*        CALLED FROM IHGIOR - CLOSEPE
*
IHIGPRCL SAVE  (14,12),,'IHIGPRCL LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15
         USING IHIGPRCL,R7
         ST    R13,SAVEOP+4
         LA    R13,SAVEOP
         L     R5,ADSTAB(,R12)
         L     R5,0(,R5)
         LA    R6,16
         L     R8,ADCB
*
         CLOSE ((R8))
*
         L     R1,BB                   BUFFER BEGIN ADDR TO R1
         L     R0,BE
         SR    R0,R1                   BUFFER LENGTH TO R0
*
*        FREEMAIN FOR RECORD BUFFER
*
         FREEMAIN  R,LV=(0),A=(1)
*
*        FREEMAIN FOR DCB AND DECB
*
         FREEMAIN  R,LV=DCBAREAL,A=ADCB
*
         L     R13,SAVEOP+4
*
         RETURN (14,12)
*
RECPG    DC    X'00'
RECOI    DC    X'00'
TYPC     DC    X'00'
PARTST   DC    X'00'
SAVEPG   DC    18F'0'
SAVEOI   DC    18F'0'
SAVEOP   DC    18F'0'
*
DCBMODEL DCB   DSORG=PS,MACRF=(RP,WP),DDNAME=SYSUT2,RECFM=V,NCP=1,     X
               EXLST=ADCBEXIT
DCBMODLN EQU   *-DCBMODEL              L'DCB
*
         DC    0F'0'
ADCBEXIT DC    X'85'
         DC    AL3(IHIGPRDX)
*
*        EXTERNAL ADDRESSES
*
AOPENPG  DC    A(IHIGPROP)
*
*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
*                                                                    *
*        THIS ROUTINE IS USED INSTEAD OF CAP1 IN FSA                 *
*                                                                    *
*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
*
CAP1GP   BALR  R8,0
         USING *,R8
         L     R3,RASPT(FSB)
         LA    R3,8(R3)
         C     R3,RASPB(FSB)
         BNL   ERROR36                 RASOVERFLOW
         ST    R10,0(,R3)
         ST    R15,4(,R3)
         ST    R3,RASPT(FSB)
         L     R8,ADRTHUNK
         DROP  R8
         BR    R8                      TO THUNK ROUTINE
*
TWOP16   DC    F'65536'                2**16
ADRTHUNK DC    A(0)
*
         LTORG
*
OUTINMOV MVC   0(1,R4),0(R8)
INOUTMOV MVC   0(1,R8),0(R4)
*                                      DATASET CLOSED
ERROR10  LR    R13,R12                 ADDR OF FSA TO R13
         B     FSAERR+10*4(R12)
*
ERROR14  LR    R13,R12                 ADDR OF FSA TO R13
*                                      NO ENTRY IN NOTTAB IE BACK-
         B     FSAERR+14*4(R12)        WARD REPOSITIONING NOT DEFINED
*
ERROR20  LR    R13,R12                 ADDR OF FSA TO R13
*                                      DIFFERENT TYPE OR KIND OF
         B     FSAERR+20*4(R12)        PARAMETER AT ACTUAL AND FORMAL
*
ERROR21  LR    R13,R12                 ADDR OF FSA TO R13
*                                      NUMBER OF PARAMETERS DOES NOT
         B     FSAERR+21*4(R12)        CORRESPOND BETWEEN DECLARATION
*                                      AND CALL
*                                      TOO MANY NESTED BLOCKS, PROCS
ERROR36  LR    R13,R12                 AND PARAMETER CALLS. INTERNAL
         B     FSAERR+36*4(R12)        (RETURN ADDRESS STACK) OVERFLOW
*
ERROR38  LR    R13,R12                 ADDR OF FSA TO R13
         B     FSAERR+38*4(R12)        GET/PUT BUFFER OVERFLOW
*
ERROR39  LR    R13,R12                 ADDRESS OF FSA TO R13
*                                      GET/PUT IDENTIFICATION OUT OF
         B     FSAERR+39*4(R12)        RANGE
*
*
ERROR43  LR    R13,R12                 RECURSIVELY USE OF PUT/GET
         B     FSAERR+43*4(R12)        OUTPUT/INPUT
*
PGCF     DSECT
ADCB     DS    A
R        DS    A
RE       DS    A
BB       DS    A
BE       DS    A
NOTEADR  DS    A
S        DS    H
TYP      DS    C
PG       DS    C
*
*        MAP DCB
*
         PRINT NOGEN
*
         DCBD  DSORG=BS,DEVD=(DA)
*
         PRINT GEN
*
*        MAP DECB
*
         READ  DECB,SF,MF=L
*
DCBAREAL EQU   *-IHADCB                 L'I/O CONTROL BLOCKS
*
FSAAREA  DSECT
         COPY  FSAREA
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIIAR   0201-12230-12230-1200-00102-00102-00000-LEVEL
IAR      TITLE 'IHIIARTN, INARRAY AND INTARRAY, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        ASSIGN NUMBERS TO ARRAY INDICATED BY SECOND ACTUAL
*        PARAMETER BY CALLING INREAL OR ININTEGER REPEATEDLY
*
*        ENTRY POINTS -
*        IHIIARRY - FROM GENERATED OBJECT MODULE
*                   INARRAY  LA R1,PARMLIST
*        IHIIARRT - FROM GENERATED OBJECT MODULE
*                   INTARRAY BALR R14,R15
*        DATA PASSED BY NAME
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES -
*        IHIIOR - EVALUATE DATA SET NUMBER
*        IHIIDE - INREAL OR ININTEGER
*
*        EXIT - NORMAL - RELOAD REGISTERS AND RETURN VIA R14
*
*        EXIT - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        R1                            -> PARAMETER LIST
*        R7                            TRANSFER DESTADR
*        R10                           TRANSFER FLAGBYTE
*        R12                           -> FSA
*
IHIIARTN CSECT
*
         ENTRY IHIIARRT
         ENTRY IHIIARRY
*
IHIIARRT SAVE  (14,12),,'IHIIARRT LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHIIARRT,R15
         LR    R12,R13                 R12 -> FSA
         LA    R9,IHIIARRY             R9 -> IHGIARRY
         DROP  R15
         USING IHIIARRY,R9
         LA    R13,ASAVE(,R13)         R13 -> SECOND SAVEAREA IN FSA
         LA    R10,4                   FLAGBYTE INTARRAY
         B     INAR1
*
IHIIARRY SAVE  (14,12),,'IHIIARRY LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R9,R15
         LR    R12,R13                 R12 -> FSA
         LA    R13,ASAVE(,R13)         R13 -> SECOND SAVEAREA IN FSA
         SR    R10,R10                 FLAGBYTE INARRAY
*
*        EVALUATE DATASET NUMBER
*
INAR1    L     R15,VIOREV
         BALR  R14,R15
*
*        EVALUATE DEST ADDRS
*
         L     R1,4(,R1)               R1 -> SECOND PARAMETER
         L     R8,12(,R1)              R8 -> DESTEND+1
         L     R7,8(,R1)               R7 -> STARTDEST
*
*        CALL ROUTINE INREAL - ININTEGER
*
INAR2    L     R15,VIDEAI              R15 -> IHIIDEAI
         BALR  R14,R15                 CALL IHIIDEAI
         LTR   R10,R10
         BP    INAR3
         TM    OPTSW(R12),X'20'        LONG OR SHORT PREC ?
         BO    INAR3
         LA    R7,8(,R7)               INCREASE  DEST ADDR INARRAY
         B     INAR3A
*
INAR3    LA    R7,4(,R7)               INCREASE  DEST ADDR INTARRAY
INAR3A   CR    R7,R8
         BL    INAR2
         LR    R13,R12
*
         RETURN (14,12)                RESTORE REGS AND RETURN
*
*        EXTERNAL ADDRS
*
VIOREV   DC    V(IHIIOREV)
VIDEAI   DC    V(IHIIDEAI)
*
FAS      DSECT
*
         COPY  FSAREA
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIIBA   0201-12230-12230-1200-00078-00078-00000-LEVEL
IBA       TITLE 'IHIIBARR, INBARRAY, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        ASSIGN BOOLEAN VALUE TO ARRAY INDICATED BY SECOND ACTUAL
*        PARAMETER BY CALLING INBOOLEAN REPEATEDLY
*
*        ENTRY POINT -
*        IHIIBARR - FROM GENERATED OBJECT MODULE
*                   LA   R1,PARMLIST
*                   BALR R14,R15
*                   DATA PASSED BY NAME
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES -
*        IHIIOR - EVALUATE DATA SET NUMBER
*        IHIIBO - INBOOLEAN
*
*        EXIT - NORMAL - RELOAD REGISTERS AND RETURN VIA R14
*
*        EXIT - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
IHIIBARR CSECT
*
*        R1                            -> PARAMETER LIST
*        R12   12                      -> FSA
*
         SAVE  (14,12),,'IHIIBARR LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15
         USING IHIIBARR,R7
         LR    R12,R13                 R12 -> FSA
         LA    R13,ASAVE(,R13)         R13 -> SECOND SAVEAREA IN FSA
*
*        EVALUTE DATASET NUMBER
*
         L     R15,VIOREV
         BALR  R14,R15
*
*        EVALUTE DESTINATION ADDR
*
         L     R1,4(,R1)
         L     R3,12(,R1)              R3 -> DESTEND+1
         L     R2,8(,R1)               R2 -> START DEST
*
*        CALL FOR ROUTINE INBOOLEAN
*
INBARRY1 L     R15,VIBOAR
         BALR  R14,R15
         LA    R2,1(,R2)               INCR ADEST
         CR    R2,R3
         BL    INBARRY1                MORE VALUE TO BE READ
         LR    R13,R12
*
         RETURN (14,12)
*
*        EXTERNAL ADDRS
*
VIOREV   DC    V(IHIIOREV)             EVALUATE DATASET NUMBER
VIBOAR   DC    V(IHIIBOAR)             INBOOLEAN
*
FAS      DSECT
*
         COPY  FSAREA
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIIBO   0201-12230-12230-1200-00238-00238-00000-LEVEL
BOO      TITLE 'IHIIBOOL, INBOOLEAN, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        SCAN INPUT BUFFER UNTIL A BOOLEAN VALUE IS FOUND
*        TRANSFER IF 'TRUE' 1 IF 'FALSE' 0 TO BOOLEAN IDENTIFIER,
*        THE SECOND PARAMETER
*
*        ENTRY POINTS -
*        IHIIBOOL - FROM GENERATED OBJECT MODULE
*                   LA   R1,PARMLIST
*                   BALR R14,R15
*                   DATA PASSED BY NAME
*        IHIIBOAR - FROM ARRAY MODULE IHIIBA
*                   L    R2,A(DESTINATION)
*                   BALR R14,R15
*                   DATA PASSED BY NAME
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES -
*        IHIIOR - EVALUATE DATASET NUMBER
*               - OPEN DATA SET
*               - CHANGE TO NEXT INPUT RECORD
*
*        EXITS - NORMAL - RELOAD REGISTERS AND EXIT VIA R14
*
*        EXITS - ERROR - INPUT REQUEST BEYOND END OF DATASET
*                        BRANCH TO IHIFSA
*                        L      R13,IHIFSA
*                        B      FSAERR+XX*4(R13) XX ERROR NO 5
*
*        TABLES/WORK AREAS - N/A
*
IHIIBOOL CSECT
*
         ENTRY IHIIBOAR
         USING DSTABLE,R5
*
*        R5                            -> DSTABLE ENTRY
*        R6                            =  DATASET NUMBER
*
*        DISPLACEMENTS IN ADRLST IN IHIFSA
*
CI       EQU   0             DISPLACEMENT FOR - IHIIORCI
CL       EQU   4                                IHIIORCL
EV       EQU   8                                IHIIOREV
NX       EQU   12                               IHIIORNX
OP       EQU   16                               IHIIOROP
OQ       EQU   20                               IHIIOROQ
*
         SAVE  (14,12),,'IHIIBOOL LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHIIBOOL,R15
         LA    R7,COMMON
         DROP  R15
         USING COMMON,R7
         LR    R12,R13                 R12 -> FSA
         ST    R13,SAVEAREA+4          CHAIN SAVE AREAS
         LA    R13,SAVEAREA
         ST    R13,8(,R12)
*
*        EVALUATE DATA SET NUMBER
*
         L     R15,IORLST(,R12)
         L     R15,EV(,R15)
         BALR  R14,R15
         B     INBOOL1
*
         DROP  R7
*
IHIIBOAR SAVE  (14,12),,'IHIIBOAR LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHIIBOAR,R15
         LA    R7,COMMON
         DROP  R15
         USING COMMON,R7
         LR    R12,R13                 R12 -> FSA
         ST    R13,SAVEAREA+4          CHAIN SAVE AREAS
         LA    R13,SAVEAREA
         ST    R13,8(,R12)
         ST    R2,ADEST                STORE DESTINATION ADDR
         B     INBOOLOP
*
COMMON   EQU   *                       COMMON CODE POINT
INBOOL1  L     R1,4(,R1)
         ST    R1,ADEST
INBOOLOP NI    DSF+1,255-DS10          SET DS10 = 0
         TM    Q,X'FF'                 DATASET SECTIONED ?
         BNZ   ERROR2                  INCOMPATIBLE ACTION ON DATASET
         CH    R6,=H'1'                DATASET NUMBER 1?
         BE    ERROR2                  INCOMPATIBLE ACTION ON DATASET
         TM    DSF,DS0                 DATASET OPEN ?
         BO    INBOOL2                 YES, BRANCH
         NI    DSF,255-DS6             NO, SET DS6 TO 0
         L     R15,IORLST(,R12)
         L     R15,OP(,R15)
         BALR  R14,R15                 CALL OPEN ROUTINE
         B     INBOOL3
*
INBOOL2  TM    DSF,DS2                 LAST I/O OUTPUT ?
         BO    ERROR3                  INPUT BEYOND LAST OUTPUT
         TM    DSF,DS6                 DS OPEN FOR OUTPUT ?
         BZ    INBOOL3                 NO, BRANCH
         TM    DSF,DS7                 EOD REACHED ?
         BO    ERROR5                  YES, BRANCH
         B     ERROR2
*
INBOOL3  L     R8,R                    CHARACTER POINTER IN R8
         BCTR  R8,0                    DECR CHARACTER PTR
         ST    R8,R
INBOOL4  MVI   FLAGS,0                 CLEAR FLAG BYTE
INBOOL5  LA    R10,MB                  MANTISSA BUFFER POINTER
         SR    R9,R9                   BLANK COUNTER CLEARED
         TM    DSF,DS7                 INPUT REQ BEYOND END OF DATA ?
         BO    ERROR5                  YES, BRANCH
INBOOL6  L     R3,RE
         BCTR  R3,0
         L     R8,R
         CR    R8,R3
         BNE   INBOOL7
         L     R15,IORLST(,R12)        RECORD END IS REACHED
         L     R15,NX(,R15)
         BALR  R14,R15                 CALL NEXTREC ROUTINE
         B     INBOOL3                 LOOP BACK
*
INBOOL7  LA    R8,1(,R8)               INCR R
         ST    R8,R                    SAVE R
         CLI   0(R8),C''''             QUOTE FOUND ?
         BE    INBOOL9                 YES, BRANCH
         TM    FLAGS,X'FF'
         BZ    INBOOL6                 NO QUOTE READ NEXT CHARACTER
         CLI   0(R8),C' '              QUOTE READ ALREADY ?
         BNE   INBOOL8                 CHARACTER IS NOT BLANK
         LA    R9,1(,R9)               CHARACTER IS BLANK INCR COUNTER
         SR    R4,R4
         IC    R4,K                    TEST IF BLANK DELIMITERS DENOTE
         CR    R4,R9                   BY K IS ALREADY FOUND
         BE    INBOOL4                 NEW SCAN LOOP K DELIMT FOUND
         BNE   INBOOL6                 K DELIMITERS NOT FOUND
INBOOL8  SR    R9,R9                   CLEAR BLANK COUNTER
         LA    R11,MB+5                END OF BUFFER ADDR
         CR    R10,R11
         BNL   INBOOL4                 NO VALID BOOLEAN VALUE FOUND
*                                      NEW SCAN LOOP
         MVC   0(1,R10),0(R8)          INSERT FOUND CHAR TO BUFFER
         LA    R10,1(,R10)             INCR R10
         B     INBOOL6                 EXAMINE NEXT CHARACTER
*
INBOOL9  SR    R9,R9
         TM    FLAGS,X'FF'
         BNZ   INBOOL10                QUOTE ALREADY FOUND
         OI    FLAGS,X'01'             FIRST QUOTE, SET FLAGS
         B     INBOOL6
*
INBOOL10 LA    R11,MB+4                FOUR CHARACTERS READ ?
         CR    R10,R11
         BL    INBOOL5
         BH    INBOOL11
         CLC   MB(L'KTRUE),KTRUE       TRUE ?
         BNE   INBOOL5                 NO, INVALID BOOLEAN VALUE FOUND
         L     R2,ADEST                YES, BOOLEAN VALUE TRUE FOUND
         MVI   0(R2),X'01'             CHARACTER TO DESTINATION
         B     INBOOL12
*
INBOOL11 CLC   MB(L'KFALSE),KFALSE     FALSE ?
         BNE   INBOOL5                 NO, INVALID BOOLEAN VALUE FOUND
         L     R2,ADEST                YES, BOOLEAN VALUE FALSE FOUND
         MVI   0(R2),X'00'             CHARACTER TO DESTINATION
*
*        RECOGNITION OF THE LAST DELIMITING CHARACTER
*
INBOOL12 SR    R9,R9
         SR    R1,R1
INBOOL13 LA    R8,1(,R8)               INCREASE CHARACTER POINTER
         C     R8,RE
         BNL   INBOOLNX                NEXT RECORD
         CLI   0(R8),C' '
         BNE   INBOOL14                CHARACTER IS NOT BLANK
         LA    R9,1(,R9)               CHARACTER IS BLANK  INCREASE R9
         SR    R4,R4                   TEST IF BLANK DELIMITERS DENOTE
         IC    R4,K                    BY K IS ALREADY FOUND
         CR    R4,R9
         BNE   INBOOL13                NOT K BLANK DELIMITERS READ
         LA    R1,1(,R1)               K BLANK DELIMITERS READ
         B     INBOOL13
*
INBOOL14 LTR   R1,R1                   CHARACTER NOT EQUAL BLANK FOUND
         BP    INBOOLAA                K OR MORE BLANKS FOUND
         LA    R8,1(,R8)               < K BLANKS FOUND
INBOOLAA C     R8,RE
         BE    INBOOLNX                RECORD END REACHED
         ST    R8,R                    STORE R TO DSTAB
INBOOLEX L     R13,SAVEAREA+4
*
         RETURN (14,12)                RESTORE CALLERS REGS AND RETURN
*
INBOOLNX L     R15,IORLST(,R12)        CALL NEXTREC ROUTINE
         L     R15,NX(,R15)
         BALR  R14,R15
         B     INBOOLEX
*
ERROR2   LR    R13,R12
         B     FSAERR+2*4(R13)         INCOMP ACTION ON DATASET
*
ERROR3   LR    R13,R12
         B     FSAERR+3*4(R13)         INPUT BEYOND LAST OUTPUT
*
ERROR5   LR    R13,R12                 INPUT REQUEST BEYOND END OF
         B     FSAERR+5*4(R13)         DATA SET
*
FLAGS    DC    X'00'                   FLAG BYTE FOR APOSTROPHE
MB       DC    CL6' '                  BUFFER
ADEST    DC    A(0)                    DESTINATION ADDR
*
KTRUE    DC    C'TRUE'                 BOOLEAN VALUE TRUE
KFALSE   DC    C'FALSE'                BOOLEAN VALUE FALSE
*
SAVEAREA DC    18F'0'                  SAVE AREA
*
         LTORG
*
         DSTABLE  DSECT=YES
*
FAS      DSECT
*
         COPY  FSAREA
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIIDE   0201-12230-12230-1200-00520-00520-00000-LEVEL
IDE      TITLE 'IHIIDECM, INREAL, ININTEGER, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        SCAN INPUT BUFFER UNTIL A VALID NUMBER IS FOUND TRANSFER
*        TO BINARY AND STORE INTO SECOND PARAMETER
*
*        ENTRY POINTS -
*        IHIIDEIR - FROM - GENERATED OBJECT MODULE - INREAL
*        IHIIDEII - FROM - GENERATED OBJECT MODULE - ININTEGER
*                   LA   R1,PARMLIST
*                   BALR R14,R15
*                   DATA PASSED BY NAME
*        IHIIDEAI - FROM - ARRAY MODULE IHIIAR
*                   L    R7,A(DESTINATION)
*                   L    R10,FLAG
*                   BALR R14,R15
*                   DATA PASSED BY NAME
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES -
*        IHIIOR - EVALUATE DATASET NUMBER
*               - OPEN DATASET
*               - CHANGE TO NEXT INPUT RECORD
*               - CONVERT REAL TO INTEGER
*        IHIFSA - CNVIRD, INTEGER TO REAL
*        IHIPTT - POWER OF TEN TABLE
*
*        TABLE/WORK AREAS -
*        IPTAB - TO EVALUATE CHARACTER FROM INPUT BUFFER WHEN
*                SCANNING AND TO BRANCH TO CORRESPONDING SUBPROGRAM
*        MB    - MANTISSA BUFFER FOR INTERMEDIATE STORING OF VALID
*                DIGITS
*
*        EXITS - NORMAL - RELOAD REGISTERS AND RETURN VIA R14
*
*        EXITS - ERROR - INPUT REQUEST BEYOND END OF DATASET NO 5
*                      - EXP PART OF INPUT NUMBER CONSISTS OF
*                        MORE THAN 2 DIGITS NO 6
*                        BRANCH TO FSA
*                        LA     R13,IHIFSA
*                        B      FSAERR+XX*4(R13) XX CORRESPONDING
*                                                   ERROR NUMBER
*
*        NOTES - LINKING TO IHIIDEAI DEVIATES FROM STANDARD SEE
*        ABOVE
*
IHIIDECM CSECT
*
         ENTRY IHIIDEIR
         ENTRY IHIIDEII
         ENTRY IHIIDEAI
*
*        REGISTER CONTENTS ON ENTRY POINT IHGIDEAI
*
*        R7                            DESTINATION ADDR
*        R10                           FLAG BYTE
*
*        FLOATING POINT REGISTERS
*
FPR0     EQU   0
*
*        OTHER GENERAL REGISTERS
*
*        R5                            -> DSTABLE ENTRY
*        R6                            DATASET NUMBER
*        R13                           BASE REGISTER FOR
*        R7                            -> DESTINATION
*        R4                            CHARACTER POINTER
*        R0                            INTEGER NUMBER
*        R8                            MANTISSA BUFFER POINTER
*        R9                            EXPONENT BUFFER POINTER
*        R10                           DECIMAL POINT POINTER
*        R11                           EXPONENT LESS EIGHT
*        R15                           -> POWERTEN TABLE LESS EIGHT
*
         USING DSTABLE,R5
*
*        DISPLACEMENTS IN ADRLST IN IHIFSA
*
CI       EQU   0             DISPLACEMENT FOR - IHIIORCI
CL       EQU   4                                IHIIORCL
EV       EQU   8                                IHIIOREV
NX       EQU   12                               IHIIORNX
OP       EQU   16                               IHIIOROP
OQ       EQU   20                               IHIIOROQ
*
IHIIDEAI SAVE  (14,12),,'IHIIDEAI LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHIIDEAI,R15
         LR    R3,R13                  CHAIN SAVE AREAS
         LA    R13,SAVEAREA
         ST    R3,4(,R13)
         ST    R13,8(,R3)
         LA    R3,COMMON
         DROP  R15
         USING COMMON,R3
         STC   R10,FKT                 STORE FLAG BYTE
         B     LADDRA
*
         DROP  R3
*
IHIIDEII SAVE  (14,12),,'IHIIDEII LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHIIDEII,R15
         LR    R12,R13
         LA    R13,SAVEAREA            CHAIN SAVE AREAS
         ST    R12,4(,R13)
         ST    R13,8(,R12)
         LA    R3,COMMON
         DROP  R15
         USING COMMON,R3
         MVI   FKT,X'04'               FLAG BYTE: ININTEGER
         B     COMMON
*
         DROP  R3
*
IHIIDEIR SAVE  (14,12),,'IHIIDEIR LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHIIDEIR,R15
         LR    R12,R13
         LA    R13,SAVEAREA            CHAIN SAVE AREAS
         ST    R12,4(,R13)
         ST    R13,8(,R12)
         LA    R3,COMMON
         DROP  R15
         USING COMMON,R3
         MVI   FKT,X'00'               FLAG BYTE: INREAL
         B     COMMON
*
*        EVALUATE DATASET NUMBER (EVDSN)
*
COMMON   L     R15,IORLST(,R12)
         L     R15,EV(,R15)
         BALR  R14,R15
*
LADDR    L     R7,4(,R1)               R7 -> DESTINATION ADDR
LADDRA   NI    DSF+1,255-DS10          SET DS10 = 0
         TM    Q,X'FF'                 DATASET SECTIONED ?
         BNZ   ERROR2                  YES, INCOMPATIBLE ACTION
         CH    R6,=H'1'                DATASET NO = 1 ?
         BE    ERROR2                  YES, INCOMPATIBLE ACTION
         TM    DSF,DS0                 DATASET OPEN ?
         BO    DSOPEN                  YES, BRANCH
         L     R15,IORLST(,R12)        NO, SETUP FOR OPEN REQUEST
         L     R15,OP(,R15)
         B     REQOPEN                 DCB IS CLOSED, BRANCH TO OPEN IT
*
DSOPEN   TM    DSF,DS2                 LAST I/O OUTPUT ?
         BZ    DSOPENA                 NO, BRANCH
         B     ERROR3                  INPUT BEYOND LAST OUTPUT
*
DSOPENA  TM    DSF,DS6                 OPEN FOR OUTPUT ?
         BZ    SCAN                    NO, BRANCH
         TM    DSF,DS7
         BO    ERROR5                  END OF DATA REACHED
         B     ERROR2
REQOPEN  NI    DSF,255-DS6             SET DS6 = 0
         BALR  R14,R15                 OPEN DATASET
SCAN     L     R4,R                    CHARACTER POINTER
         LA    R8,MB+1                 MANTISSA BUFFER POINTER
         LA    R9,MB+19                EXPONENT BUFFER POINTER
         MVC   MB+1(L'MB-1),MB         CLEAR BUFFER
SCAN1    BCTR  R4,0                    DECREASE CHARACTER POINTER
SCAN2    MVI   SM,C'+'                 MANTISSA SIGN INITIALLY PLUS
SCAN2A   MVI   F,0                     CLEAR FLAG BYTE F
         MVI   SE,C'+'                 EXPONENT SIGN INITIALLY PLUS
SCAN3    LA    R4,1(,R4)
         C     R4,RE
         BNE   SCAN5                   R IS NOT EQUAL RECORD END(RE)
SCAN4    TM    F,X'82'                 RECORD END IS REACHED (R=RE) ?
         BNZ   DELIMIT                 A VALID NUMBER HAS BEEN READ
         L     R15,IORLST(,R12)
         L     R15,NX(,R15)            REQUEST NEXT RECORD
         BALR  R14,R15                 RECORD CHANGE IS PERFORMED
         L     R4,R
         TM    DSF,DS7                 END OF FILE ?
         BO    ERROR5                  YES, END OF DATA REACHED
         B     SCAN1                   NEXT RECORD IS TO BE SCANNED
*
SCAN5    SR    R2,R2
         TRT   0(256,R4),IPTAB         EVALUATE NEXT CHARACTER
         SR    R15,R15                 CLEAR BLANK COUNTER (CB)
         B     *(R2)
BRANCH   B     BLANK                   +04
         B     OTHERS                  +08
         B     DIGIT                   +12
         B     SIGN                    +16
         B     DECPT                   +20
         B     APOSTR                  +24
*
BLANK    LA    R15,1(,R15)             INCR CB
         LA    R4,1(,R4)               INCREASE R
         C     R4,RE
         BE    SCAN4                   RECORD END IS REACHED
         CLI   0(R4),C' '
         BE    BLANK                   NEXT CHARACTER ALSO BLANK
         SR    R2,R2
         IC    R2,K
         CR    R15,R2
         BL    SCAN5                   < K BLANKS, EVAL NEXT CHARACTER
         BCTR  R4,0                    K BLANKS READ, DECREASE R
OTHERS   TM    F,X'82'
         BZ    SCAN2                   NO VALID NUMBER READ, NEW SCAN
         B     DELIMIT                 A VALID NUMBER AND K BLANKS READ
*
DIGIT    TM    F,X'08'
         BO    DIGIT1                  EXPONENT DIGIT
         TM    F,X'40'                 MANTISSA DIGIT
         BZ    DIGIT2                  FIRST MANTISSA DIGIT
         CR    R8,R9
         BL    DIGIT3                  < 19 MANTISSA DIGITS
         B     DIGIT3A
*
DIGIT3   MVC   0(1,R8),0(R4)           DIGIT INTO MANTISSA BUFFER (MB)
DIGIT3A  LA    R8,1(,R8)               INCREASE MANTISSA POINTER
         TM    F,X'20'
         BZ    SCAN3                   NO DEC POINT IS READ, NEXT CHAR
         OI    F,X'10'                 F3 = 1 DIGIT BEHIND DEC PT READ
         B     SCAN3
*
DIGIT2   CLI   0(R4),C'0'
         BE    DIGIT2A
         OI    F,X'C0'                 F0, F1 = 1 MANTISSA DIGIT ¬ 0
         B     DIGIT3
*
DIGIT2A  OI    F,X'80'                 F0 = 1 LEADING ZERO
         TM    F,X'20'
         BZ    SCAN3
         BCTR  R10,0                   DECR DECIMAL POINT POINTER
         OI    F,X'10'                 F3 = 1 DIGIT BEHIND DEC P READ
         B     SCAN3
*
DIGIT1   TM    F,X'01'
         BZ    DIGIT4                  NO EXP DIGIT NOT 0 WAS READ
         LA    R2,MB+21                END OF EXPONENT BUFFER
         CR    R9,R2
         BNL   ERROR6                  MORE THAN 2 EXP DIGITS WERE READ
DIGIT5   MVC   0(1,R9),0(R4)           DIGIT INTO EXPONENT BUFFER
         LA    R9,1(,R9)               INCREASE EXPONENT POINTER
         B     SCAN3                   EVALUATE NEXT CHARACTER
*
DIGIT4   OI    F,X'02'                 F6 = 1 ANY EXPONENT DIGIT READ
         CLI   0(R4),C'0'
         BE    SCAN3                   EVALUATE NEXT CHARACTER
         OI    F,X'01'                 F7 = 1 EXPONENT DIGIT ¬ 0 READ
         B     DIGIT5
*
SIGN     TM    F,X'08'
         BO    SIGN1                   SIGN FOLLOWED AN APOSTROPHE
         TM    F,X'80'
         BO    DELIMIT                 SIGN FOLLOWED A MANTISSA DIGIT
         B     SIGN2
*
SIGN1    TM    F,X'06'
         BZ    SIGN2A                  EXPONENT SIGN
         TM    F,X'82'
         BNZ   DELIMIT                 SIGN FOLLOWED A VALID NUMBER
SIGN2    MVC   SM,0(R4)                MANTISSA SIGN
         B     SCAN2A                  NEW SCAN
*
SIGN2A   MVC   SE,0(R4)                EXPONENT SIGN
         OI    F,X'04'                 F5 = 1 EXPONENT SIGN READ
         B     SCAN3                   EVALUATE NEXT CHARACTER
*
DECPT    TM    F,X'28'
         BZ    DECPT1                  NO DEC POINT OR APOST BEFORE
         TM    F,X'82'
         BNZ   DELIMIT                 DEC PT FOLLOWED A VALID NUMBER
         TM    F,X'08'
         BO    DECPTA                  DEC POINT FOLLOWED APOSTROPHE
         MVI   SM,C'+'                 MANTISSA SIGN INITIALLY PLUS
         B     SCAN3                   NEW SCAN
*
DECPTA   MVC   SM,SE                   EXP SIGN IS ASSIGNED TO MANTSIGN
         MVI   SE,C'+'                 EXPONENT SIGN INITIALLY PLUS
         MVI   F,0                     CLEAR FLAG BYTE F
DECPT1   OI    F,X'20'                 F2 = 1 DEC POINT WAS READ
         LR    R10,R8                  STATE OF MANT POINTER INTO R10
         ST    R4,DPI                  STATE OF CHAR POINTER INTO DPI
         B     SCAN3                   NEXT CHARACTER
*
APOSTR   TM    F,X'08'
         BO    APOSTRA                 AN APOSTROPHE WAS ALREADY READ
         TM    F,X'30'
         BNM   APOSTR1                 A VALID NUMBER WAS READ
APOSTRA  TM    F,X'82'                 APOSTROPHE FOLLOWED DEC POINT
         BNZ   DELIMIT                 NUMBER BEFORE DEC POINT IS VALID
         MVC   SM,SE                   EXP SIGN IS ASSNED TO MANT SIGN
         MVI   SE,C'+'                 EXPONENT SIGN INITIALLY PLUS
         MVI   F,0                     CLEAR FLAG BYTE F
APOSTR1  OI    F,X'08'                 APOSTROPHE WAS READ F4.=1
         ST    R4,API                  STATE OF CHAR POINTER INTO API
         B     SCAN3                   EVALUATE NEXT CHARACTER
*
DELIMIT  TM    F,X'30'
         BNM   DELIMIT1                MANTISSA PART IS VALID
         L     R4,DPI                  CHAR POINTER OF DEC POINT INTO R
         NI    F,X'DF'                 F2.=0 NO DEC POINT WAS READ
         B     DELIMIT2
*
DELIMIT1 TM    F,X'0A'
         BNM   DELIMIT2                EXPONENT PART IS VALID
         L     R4,API                  CHAR PTR OF APOSTROPHE INTO R
         NI    F,X'F3'
DELIMIT2 C     R4,RE
         BNE   DELIMITB
DELIMITC L     R15,IORLST(,R12)
         L     R15,NX(,R15)            REQUEST NEXT RECORD
         BALR  R14,R15                 RECORD CHANGE IS PERFORMED
         B     DELIMIT3
*
DELIMITB LA    R4,1(,R4)               INCR CHARACTER POINTER
         C     R4,RE
         BE    DELIMITC
         ST    R4,R                    STORE CHAR POINTER TO DSTABLE
DELIMIT3 TM    F,X'28'                 TEST TYPE OF NUMBER
         BNZ   TRREAL                  REAL TYPE NUMBER
         TM    F,X'40'
         BO    DELIMITD                NUMBER ¬= ZERO
         SR    R0,R0
         B     TRINT1                  NUMBER = ZERO
*
DELIMITD LA    R2,MB+11
         CR    R8,R2
         BH    TRREAL                  > 10 DIGITS READ, REAL
         BL    DELIMITH                < 10 DIGITS READ, INTEGER
         CLC   MB+1(10),DMINT          10 DIGITS WERE READ
         BNL   TRREAL                  NUMBER GREATER (2**31)-1, REAL
DELIMITH LA    R2,MB+2
         SR    R8,R2                   NUMBER OF DIGITS DECR BY ONE
         EX    R8,PACK                 PACK NUMBER
         CLI   SM,C'+'                 TEST SIGN OF THE NUMBER
         BNE   DELIMITE
         OI    MB+17,X'0F'
         B     DELIMITF
*
DELIMITE OI    MB+17,X'0D'
         NI    MB+17,X'FD'
DELIMITF CVB   R0,MB+10
TRINT1   LA    R2,4
         CLI   FKT,X'04'
         BE    FIN3                    CONVERSION NOT REQ, FKT=INTEGER
*
*        CALL CONVERSION ROUTINE (LOADED IN FSA)
*
         STM   R14,R13,8(R13)          ALL REGISTERS INTO SAVEAREA
         LR    R2,R13                  R2 -> SAVE AREA
         LA    R7,ACNVIRD(,R12)
         LR    R14,R0                  INTEGER INTO R14
         LR    R13,R12                 R13 -> FSA
         BALR  R8,R7
         LM    R14,R13,8(R2)           RESTORE REGS
         SR    R2,R2
         USING FSAAREA,R12
         TM    OPTSW(R12),X'20'        LONG OR SHORT PRECISION ?
         BZ    FIN3                    LONG PRECISION STATED
         LA    R2,8
         B     FIN3
*
TRREAL   SWR   FPR0,FPR0
         TM    F,X'C0'
         BO    TRREALA
         BM    FIN                     MANTISSA IS ZERO
         SR    R10,R10
         LD    FPR0,KFPD1              MANTISSA IS 1.0
         B     TRREAL1
*
TRREALA  TM    F,X'20'
         BO    TRREALB                 A DECIMAL WAS READ
         LR    R10,R8                  DECPT IS ACCEPTED BEH LAST DIGIT
TRREALB  LA    R2,MB+10
         SR    R10,R2                  POS OF DECPT: BEHIND 9. DIGIT
TRREAL2  PACK  MB+2(8),MB+1(9)         PACK UPPER 9 DIGITS
         OI    MB+9,X'0F'
         CVB   R0,MB+2                 CONVERT UPPER 9 DIGITS TO BINARY
         ST    R0,MASK+4               MASK FLOATING ZERO WITH EXPON 78
         AD    FPR0,MASK               TRANSFORM NUMBER TO FLOAT TYPE
         CR    R8,R2
         BNH   TRREAL1
         MD    FPR0,TPNINE
         S     R10,KF9                 SHIFT DECPT 9 POSITIONS TO RIGHT
         SR    R8,R8
         PACK  MB+2(8),MB+10(9)        PACK LOWER 9 DIGITS
         B     TRREAL2+6               REPEAT ACTION FOR LOWER 9 DIGITS
*
TRREAL1  CLI   SM,C'+'
         BE    TRREAL1A                NUMBER IS POSITIVE
         LCDR  FPR0,FPR0               INSERT MINUS
TRREAL1A SR    R0,R0
         TM    F,X'01'
         BZ    TRREAL3                 SCALE FACTOR
         NI    MB+19,X'0F'             CLEAR ZONE OF ONE EXPONENT DIGIT
         IC    R0,MB+19
         TM    MB+20,X'FF'             2. EXPONENT DIGIT IS TESTED
         BZ    TRREAL3A                NO 2. EXPONENT
         MH    R0,KH10                 FIRST EXPONENT DIGIT MULT BY 10
         LR    R2,R0
         NI    MB+20,X'0F'             CLEAR ZONE OF 2. EXPONENT DIGIT
         IC    R0,MB+20
         AR    R0,R2                   TOTAL PRELIMINARY EXPONENT
TRREAL3A CLI   SE,C'+'
         BE    TRREAL3                 EXPONENT IS POSITIVE
         LCR   R0,R0                   INSERT MINUS
TRREAL3  AR    R10,R0                  CORR EXP BY DEC POINT POSITION
         BZ    FIN                     CORRECTED EXPONENT IS ZERO
         L     R15,VPTTAB              ADDR OF POWERTEN TABLE
         BP    TRREAL3B
         LA    R15,128(R15)            ADDR OF 10**(-1) DIMIN BY EIGHT
TRREAL3B LPR   R10,R10                 ABS (CORRECTED EXPONENT)
         SR    R11,R11                 CLEAR REGISTER
         SRDA  R10,3
         SLA   R10,3
TRREAL5  BZ    TRREAL4A                CORRECTED EXPONENT LESS 8
         C     R10,KF72
         BNH   TRREAL4                 CORRECTED EXPONENT LESS 73
         MD    FPR0,128(,R15)          MULTIPLY OR DIVIDE BY 10**72
         S     R10,KF72                DECREASE CORRECTED EXP BY 72
         B     TRREAL5                 REPEAT MULT OR DIVISION
*
TRREAL4  MD    FPR0,56(R10,R15)
TRREAL4A SRL   R11,26
         LTR   R11,R11
         BZ    FIN
         MD    FPR0,0(R11,R15)       * OR / 10**(EXP-(ENTIER(EXP/8)*8))
FIN      SR    R2,R2                   CLEAR R2, TYPE = REAL LONG
         TM    OPTSW(R12),X'20'        LONG OR SHORT PRECISION ?
         BZ    FIN1                    LONG PRECISION STATED
         STD   FPR0,BUFF               SHORT PRECISION STATED
         MVC   ROUND(1),BUFF           EXPONENT TO ROUND
         AD    FPR0,ROUND              LONG PRECISION ROUNDED TO SHORT
         LA    R2,8                    TYPE = REALSHORT
FIN1     CLI   FKT,0
         BE    FIN3                    CONVERSION NOT NECESSARY
         LA    R2,4                    TYPE = INTEGER
         L     R15,IORLST(,R12)
         L     R15,CI(,R15)
         BALR  R14,R15                 NUMBER CONVERTED TO INTEGER
FIN3     EX    0,STORE(R2)
         L     R13,SAVEAREA+4
*
         RETURN (14,12)
*
PACK     PACK  MB+10(8),MB+1(0)        EXE INSTRUCTIONS
STORE    STD   FPR0,0(,R7)             *
         ST    R0,0(,R7)               |
         STE   FPR0,0(,R7)             V
*
ERROR2   LR    R13,R12
         B     FSAERR+2*4(R12)         INCOMP ACTION ON DATASET
*
ERROR3   LR    R13,R12
         B     FSAERR+3*4(R12)         INPUT BEYOND LAST OUTPUT
*
ERROR5   LR    R13,R12                 INPUT REQ BEYOND END OF DATASET
         B     FSAERR+5*4(R12)
*
ERROR6   LR    R13,R12                 EXP PART CONSIST OF
         B     FSAERR+6*4(R12)         MORE TH.2DIGITS
*
*        EXTERNAL ADDRS
*
VPTTAB   DC    V(IHIPTTAB)
*
ACNVIRD  EQU   X'120'
*
*        INTERNAL CONSTANTS AND STORAGE
*
KF9      DC    F'9'                    FOR SHIFT OF DECIMAL POINT
KF72     DC    F'72'                   FOR EXPONENT TREATMENT
API      DC    A(0)                    CHARACTER POINTER OF APOSTROPHE
DPI      DC    A(0)                    CHARACTER POINTER OF DEC POINT
BUFF     DC    D'0'                    FOR CONVERSION OF NUMBER
KFPD1    DC    D'1.0'
TPNINE   DC    DE9'1'                  10**9
MASK     DC    FL8S56'78'              FLOAT 0 WITH EXPONENT 78
ROUND    DC    X'0000000080000000'     FOR CONVERSION OF NUMBER
KH10     DC    H'10'                   FOR EXPONENT TREATMENT
FKT      DC    X'00'                   FLAG BYTE
F        DC    X'00'                   FLAG BYTE
SM       DC    C' '
SE       DC    C' '
MB       DC    XL21'00'                MANTISSA BUFFER
DMINT    DC    C'2147483648'           2**31
*
IPTAB    DC    64X'08'                 OTHERS
         DC    X'04'                   BLANK
         DC    10X'08'                 OTHERS
         DC    X'14'                   DECIMAL POINT
         DC    2X'08'                  OTHERS
         DC    X'10'                   SIGN +
         DC    17X'08'                 OTHERS
         DC    X'10'                   SIGN -
         DC    28X'08'                 OTHERS
         DC    X'18'                   APOSTROPHE
         DC    114X'08'                OTHERS
         DC    10X'0C'                 DIGITS 0 TO 9
         DC    6X'08'                  OTHERS
*
SAVEAREA DC    18F'0'
*
         LTORG
*
         DSTABLE  DSECT=YES
*
FSAAREA  DSECT
*
         COPY  FSAREA
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIIOR   0201-12230-12230-1200-01169-01169-00000-LEVEL
IOR      TITLE 'IHIIORTN, LIBRARY I/O SERVICE ROUTINES, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        THE CODE HAS BEEN UPDATED -
*
*        1. ALL HARDCODED LENGTH CALCULATIONS FOR GETMAINED
*           AREAS USED FOR DCB, DECB ETC ARE NOW CALCULATED
*        2. ALL REFERENCES TO VARIOUS DCB FIELDS UTILIZE THE
*           MAPPING SYMBOLS PROVIDED BY DCBD
*        3. ALL REFERENCES TO VARIOUS JFCB FIELDS UTILIZE THE
*           MAPPING SYMBOLS PROVIDED BY IEFJFCBN
*        4. THE DCBS FOR SYSIN, SYSPRINT AND ALGLIB01 ARE OPENED
*           WITH OPEN OPTIONS SUITABLE FOR JES2/3 DATASETS
*           THIS WILL PREVENT 013-BC ABENDS THAT OCCURRED WITH THE
*           PREVIOUS RELEASE
*        5. ALL NUMERIC BRANCH CONDITIONS ARE RATIONALIZED TO USE
*           STANDARD ASSEMBLER MNEMONICS
*        6. MINOR CODE AND COMMENT CHANGES FOR IMPROVED READABILITY
*
*        FUNCTION/OPERATION -
*        THIS MODULE CONTAINS A SET OF SERVICE ROUTINES USED BY
*        OTHER I/O MODULES AS SUBROUTINES
*        THEY PERFORM THE FOLLOWING -
*        OPEN DATASET
*        CHANGE TO NEXT RECORD
*        CLOSE DATASET
*        CLOSE ALL DATASETS
*        CLEAR NOTTAB
*        ENTRY NOTTAB
*        EVALUATE DATASET NUMBER
*        END OF DATA HANDLING
*        SYNCHRONOUS ERROR HANDLING
*        CONVERT REAL TO INTEGER.
*        MORE DETAIL BEFORE EACH ROUTINE
*
*        ENTRY POINTS -
*        IHIIOROP
*        IHIIOROQ
*        IHIIORNX
*        IHIIORCL
*        IHIIORCP
*        IHIIORCN
*        IHIIOREN
*        IHIIOREV
*        IHIIORCI
*        IHIIORED
*        IHIIORER
*        ALL INVOKED BY BALR R14,R15
*        DIFFERENCE EXPLAINED BEFORE EACH ROUTINE
*
*        INPUT - SEE EACH ROUTINE
*
*        OUTPUT - SEE EACH ROUTINE
*
*        EXTERNAL ROUTINES - IHIGPR - CLOSE DATASET FOR PUT/GET
*
*        EXITS - NORMAL - ALL ROUTINES EXCEPT END OF DATA AND
*                         SYNAD RELOAD REGISTERS AND BR 14
*              - ERROR  - NO  EXPLANATION
*                         0   DATASET NUMBER OUT OF RANGE
*                         1   REAL NUMBER TO BE CONVERTED OUT OF
*                             INTEGER RANGE
*                         2   INCOMPATIBLE ACTIONS ON SAME DATASET
*                         3   INPUT BEYOND LAST OUTPUT
*                         4   OVERFLOW OF NOTTAB
*                         5   INPUT REQUEST BEYOND END OF DATASET
*                         7   DATA SECTIONED AND NO CTRL CHARACTER
*                             SPECIFIED
*                         32  UNRECOVERABLE I/O ERROR
*                         37  BLOCKSIZE NOT A MULTIPLE OF RECORD
*                             LENGTH
*                         41  DDCARD INCORRECT OR MISSING
*              - ACTION - BRANCH TO IHGFSA
*                         LA 13,IHGFSA
*                         B  FSAERR+XX*4(13)  XX ERROR NUMBER
*
*        TABLES/WORK AREAS -
*        NOTTAB, FOR STORING OF RECORD IDENTIFICATION USING WHEN
*        REPOSITIONING, IS CREATED DYNAMICALLY WHEN OPEN A DATASET
*        WITH UNBLOCKED RECORD FORMAT SIZE OF 1024 BYTES
*
*        ATTRIBUTES - SERIALLY REUSABLE
*
*        NOTES -
*        THE OPERATION OF THIS MODULE DOES NOT DEPEND UPON A
*        SPECIAL INTERNAL REPRESENTATION OF THE EXTERNAL
*        CHARACTER SET
*
*        REGISTER USAGE
*
*        R5  -> RELEVANT ENTRY IN DSTAB
*        R6     DATASET NUMBER
*        R7     PROGRAM BASE REGISTER
*        R8  -> DCB AND DECB'S
*        R12 -> FSA
*        R13 -> SAVE AREA
*        R14 -> RETURN
*        R15 -> ROUTINE
*
IHIIORTN CSECT
*
         ENTRY IHIIOROP
         ENTRY IHIIOROQ
         ENTRY IHIIORNX
         ENTRY IHIIORCL
         ENTRY IHIIORCP
         ENTRY IHIIORGP
         ENTRY IHIIORCN
         ENTRY IHIIOREN
         ENTRY IHIIOREV
         ENTRY IHIIORED
         ENTRY IHIIORCI
         ENTRY IHIIORER
*
*        DISPLACEMENT IN FSA
*
ADSTAB   EQU   X'AC'
ANOTTAB  EQU   X'B0'
OPTSW    EQU   X'C2'
FSAERR   EQU   X'1CC'
*
*
*
*----------------------------------------------------------------------
*        OPEN A DATASET
*----------------------------------------------------------------------
*
*        FUNCTION/OPERATION -
*        RESERVE STORAGE FOR AND COMPLETE A DCB AND TWO I/O BUFFERS
*
*        COMPLETE DSTAB FIELDS IN GENERATED OBJECT MODULE
*
*        STAB HAS AN ENTRY AND INDICATOR STATUS FOR EVERY DATASET
*        USED IN THE PROGRAM
*
*        INPUT -
*        IF DATASET SHOULD PERFORM ONLY INPUT OR OUTPUT BLOCKED
*        RECORD FORMAT IS USED ELSE UNBLOCKED FORMAT - ACCESS
*        METHOD BSAM.
*        IN CASE OF INPUT TWO RECORDS OR BLOCKS READ TO I/O
*        BUFFERS. BLOCKED RECORD FORMAT IS USED ONLY WHEN
*        BLOCKING FACTOR > 1
*
*        OUTPUT - N/A
*
*        NOTES -
*        ADDR OF THE DCB IS LOADED IN R8 AND KEPT THROUGH ALL
*        I/O MODULES
*
*        ROUTINE IHIIOROQ IS ENTERED FROM SYSACT 12
*
IHIIOROQ SAVE  (14,12),,'IHIIOROQ LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R4,R15
         USING IHIIOROQ,R4
         LA    R7,IHIIOROP
         USING IHIIOROP,R7
         ST    R13,SAVAR+4
         LA    R13,SAVAR
         USING DSTABLE,R5              DSN RELEVANT ENTRY IN DSTABLE
         CH    R6,=H'1'                DATASET NUMBER 0 OR 1 ?
         BNH   OPEN00                  YES, BRANCH TO IHIIOROP
         NI    DSF,255-DS6
         TM    DSF+1,DS14              DATASET BEEN OPEN BEFORE ?
         BO    OPEN00                  YES
*
*        OPEN DATASET FOR THE FIRST TIME
*
*        GETMAIN AREA FOR DCB, DECB AND JFCB
*        EXAMINE THE DISP PARAMETER IN JFCB IF NEW OPEN THE
*        DATASET FOR OUTIN ELSE FOR INOUT
*
         GETMAIN R,LV=DCBAREAL
*
         ST    R1,ADCB                 SAVE DCB ADDR IN DSTABLE
         LR    R8,R1
         USING IHADCB,R8
         MVC   0(DCBMODLN,R8),DCBMODEL  MOVE DCBMODEL INTO GETMAIN AREA
*
*        CONVERT BINARY DATASET NUMBER INTO CHARACTER TO
*        MOVE INTO THE DDNAME
*
         CVD   R6,DWORD
         UNPK  DWORD(2),DWORD+6(2)     EXTRACT LAST TWO DIGITS
         OI    DWORD+1,X'F0'
         MVC   DCBDDNAM+6(2),DWORD     MOVE IN DCB DDNAME NUMBER
         LA    R3,JFCB
         STCM  R3,B'0111',ADCBEXIT+5   STORE JFCB AREA ADDR
*
         RDJFCB ((R8))
*
         TM    JFCBTSDM,JFCSDS         SYSIN/SYSOUT DATASET ?
         BZ    ROQA                    NO, BRANCH
*
*        SUBSYSTEM DATASET
*
         TM    JFCBIND2,JFCMOD         NEW OR MOD DATASET ?
         BO    ROQB                    YES, MUST BE SYSOUT
         MVC   DCBMACRF,=AL1(DCBMRRD,0)  NO POINT OPTION FOR SUBSYS DS
         B     ROQD
*
ROQB     MVC   DCBMACRF,=AL1(0,DCBMRWRT) NO POINT OPTION FOR SUBSYS DS
         OI    DSF,DS6
         B     ROQD
*
ROQA     TM    JFCBIND2,JFCMOD         NEW OR MOD DATASET ?
         BZ    ROQD                    NO, BRANCH
         OI    DSF,DS6
ROQD     LA    R1,JFCB
*
*        FREE UP THE JFCB AREA ON THE END OF DCBAREA AS ITS NO
*        LONGER NEEDED
*
         FREEMAIN R,LV=JFCB_LEN,A=(1)
*
         B     OPEN20
*
IHIIOROP SAVE  (14,12),,'IHIIOROP LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15
         ST    R13,SAVAR+4
         LA    R13,SAVAR
OPEN00   CH    R6,=H'1'
         BNE   OPEN01
*
*        DATASET NUMBER = 1
*        IF DATASET HAS BEEN OPENED BEFORE (DS14=1)
*        SET DS0 = 1 AND GO BACK. IF NOT OPEN THE DATASET
*
         TM    DSF+1,DS14              PREVIOUSLY OPENED ?
         BZ    OPEN01                  NO, BRANCH
         OI    DSF,DS0
         B     OPEN51
*
*        GETMAIN FOR DCB AND DECB, NO JFCB
*
OPEN01   GETMAIN R,LV=DCBAREAL-JFCB_LEN
*
         ST    R1,ADCB
         LR    R8,R1
         MVC   0(DCBMODLN,R8),DCBMODEL  MOVE IN MODEL DCB
         CH    R6,=H'1'
         BL    DSIN
         BE    DSPRINT
*
*        CONVERT BINARY DSNUMBER TO CHAR
*
         CVD   R6,DWORD                DATASET NUMBER TO DDNAME
         UNPK  DWORD(2),DWORD+6(2)     EXTRACT LAST TWO DIGITS
         OI    DWORD+1,X'F0'
         MVC   DCBDDNAM+6(2),DWORD     MOVE IN DCB DDNAME NUMBER
         B     OPEN2
*
DSIN     MVC   DCBDDNAM,=CL8'SYSIN   '
         MVC   DCBMACR,=AL1(DCBMRRD,0)  NO POINT OPTION FOR SYSIN
*
         OPEN  ((R8),(INPUT))          INPUT ONLY FOR SYSIN
*
         B     OPEN300
*
*        IF DS11 = 0 OPEN DATASET SYSPRINT
*        IF DS11 = 1 OPEN DATASET ALGLDD01
*
DSPRINT  TM    DSF+1,DS11
         BO    DSPR2
         MVC   DCBDDNAM+6(2),=CL2'01'  LAST 2 CHARS OF DDNAME
         OI    DSF+1,DS14
         B     DSPR2A
*
DSPR2    MVC   DCBDDNAM,=CL8'SYSPRINT'
DSPR2A   MVC   DCBMACR(2),=AL1(0,DCBMRWRT)  NO POINT OPT FOR SYSPRINT
*
         OPEN  ((R8),(OUTPUT))        OUTPUT ONLY FOR SUBSYS SYSOUT
*
         B     OPEN300
*                                     SET MACRF=(RP,WP)
OPEN2    MVC   DCBMACR,=AL1(DCBMRRD+DCBMRPT1,DCBMRWRT+DCBMRPT2)
OPEN20   ICM   R2,B'1111',ANOTTAB(R12)
         BNZ   OPEN3
*
         GETMAIN R,LV=1024             GET AREA FOR NOTE TABLE
*
         ST    R1,ANOTTAB(R12)
         LR    R2,R1                   ANOTTAB TO R2
         LR    R3,R2                   ANOTTAB TO R3
         LA    R3,8(,R3)
         ST    R3,0(,R2)               STORE POINTER NXE IN NOTTAB
         LA    R3,1016(,R3)
         ST    R3,4(,R2)               STORE POINTER NEXEF IN NOTTAB
OPEN3    TM    DSF,DS6                 OUTPUT POSSIBLE ?
         BO    OPEN30                  YES
*
         OPEN  ((R8),(INOUT))
*
OPEN300  TM    DCBOFLGS,DCBOFOPN       OPEN SUCCESSFUL ?
         BO    OPEN355                 YES, BRANCH
         NI    DSF+1,255-DS14          NO, SET DS14 = 0
         LR    R13,R12                 DDCARD INCORRECT OR MISSING
         B     FSAERR+41*4(R12)
*
OPEN30   OPEN  ((R8),(OUTIN))
*
         B     OPEN300                 CONTINUE
*
OPEN355  TM    EXERFLAG,X'11'          ERROR IN DCBEXIT ?
         BZ    OPEN301
*
*        CLOSE DATASET AND FREEMAIN FOR DCB AND DECB ONLY
*
         CLOSE ((R8),REREAD)
*
         FREEMAIN R,LV=DCBAREAL-JFCB_LEN,A=ADCB
*
         LR    R13,R12
         TM    EXERFLAG,X'01'          ERROR 7 IN DCBEXIT ?
         MVI   EXERFLAG,X'00'          CLEAR FLAG
         BZ    OPEN350
         B     FSAERR+7*4(R12)         ERROR 7
*
OPEN350  B     FSAERR+37*4(R12)        ERROR 37
*
OPEN301  OI    DSF,DS0
         CH    R6,=H'1'                DATASET NUMBER = 0 OR 1
         BNH   OPEN301A
         OI    BL+3,DS14
OPEN301A LH    R0,BL
         AR    R0,R0                   DOUBLE BUFFER LENGTH
*
         GETMAIN R,LV=(0)              GET AREA FOR TWO BUFFERS
*
         ST    R1,BB                   BUFFER BEGIN
         LR    R2,R1
         AH    R1,BL
         ST    R1,NBB                  ALTERNATE BUFFER BEGIN
         TM    DSF,DS6
         BO    OPEN4
OPEN31   OI    DSF+1,DSEOD             SET MARK FOR END OF DATA
         LA    R4,DECB
         L     R3,8(,R4)
         CR    R3,R8
         BNE   OPEN311
*
         CHECK DECB
*
OPEN311  READ  DECB,SF,(R8),(R2),MF=E  READ FIRST BLOCK
*
         CHECK DECB
*
         NI    DSF+1,255-DSEOD         RESET
         LH    1,DCBBLKSI
         L     R4,DCBIOBA
         SH    1,22(R4)
         STH   1,BL
*
         NOTE  (R8)
*
         ST    R1,NOTEADR
OPEN41   L     R3,NBB
*
         READ  DECB,SF,(R8),(R3),MF=E  READ SECOND BLOCK
*
         B     OPEN5
*
OPEN4    TM    DSF+1,DS9
         BZ    OPEN5
         MVC   0(1,R2),=C'1'           INSERT FIRST CONTROL CHAR
         LA    R2,1(,R2)               PROVIDE SPACE FOR CONTROL CHAR
OPEN5    ST    R2,R
         AH    R2,P
         ST    R2,RE
OPEN51   L     R13,SAVAR+4
*
         RETURN (14,12)
*
*----------------------------------------------------------------------
*        DCB OPEN EXIT ROUTINE
*----------------------------------------------------------------------
*
IHIIORDX TM    DSF+1,DS11
         BZ    EXIT3
*
*        EXIT ROUTINE FOR PRINTING ERROR MESSAGE
*
         MVC   Q(1),=X'32'             RECORD IS SECTIONED Q=50
         MVC   P(2),=X'005A'           RECORD LENGTH P=90
*                                      INSERT RECORD FORMAT=FBA
         MVI   DCBRECFM,DCBRECF+DCBRECBR+DCBRECCA
         OI    DSF+1,DS9               INSERT FLAG REC CONT CONTR CHAR
         LH    R4,P
         LA    R4,1(,R4)               P+1 TO LRECL
         STH   R4,DCBLRECL
*
*        EXAMINE DCB BLKSIZE
*
         LH    R3,DCBBLKSI             LOAD DCBBLKSI INTO R3
         SR    R2,R2
         DR    R2,R4
         LTR   R3,R3
         BZ    EXITA                   BLKSI < LRECL OR BLKSI = 0
         BCT   R3,EXITB
EXITA    STH   R4,DCBBLKSI
         OI    DSF,DS1
EXITC    MVC   BL(2),DCBBLKSI
         B     RETEX
*
EXITB    LA    R3,1(R3)
         MH    R3,DCBLRECL
         STH   R3,DCBBLKSI
         NI    DSF,255-DS1
         B     EXITC
*
*        ALGOL USER'S EXIT ROUTINE
*
EXIT0    TM    DCBRECFM,X'FF'          RECFM PROVIDED ?
         BZ    EXIT1                   RECFM = 0
         TM    DCBRECFM,DCBRECF+DCBRECCA  RECFM = FBA OR FBA ?
         BO    EXIT4
         TM    Q,X'FF'                 RECORDS PER SECTION PROVIDED ?
         BZ    RETEX                   NO, BRANCH
         OI    EXERFLAG,X'01'          DATASET SPLIT INTO SECTIONS
         B     RETEX                   AND NO CTL CHARACTER ERROR NO 7
*
EXIT1    OI    DCBRECFM,DCBRECF        SET RECFM = F
         TM    DSF,DS1
         BO    EXIT12
         OI    DCBRECFM,DCBRECBR       SET RECFM = BLOCKED
EXIT12   TM    DSF+1,DS9
         BZ    RETEX
         OI    DCBRECFM,DCBRECCA       SET RECFM = ASA CNTL
         B     RETEX
*
EXIT4    OI    DSF+1,DS9
         B     RETEX
*
*        EXAMINE LRECL
*
EXIT3    OI    DSF,DS1
         TM    Q,X'FF'
         BZ    EXIT3A
         OI    DSF+1,DS9
EXIT3A   LH    R4,DCBLRECL
         LTR   R4,R4
         BZ    EXIT2
         TM    DSF+1,DS9
         BO    EXIT5                   DS9=1 RECORDS CONTAIN CNTL CHAR
         STH   R4,P                    LRECL  TO  P
         B     EXIT6
*
EXIT5    BCTR  R4,0
         STH   R4,P                    LRECL-1 TO P
         LA    R4,1(,R4)
         B     EXIT6
*
EXIT2    TM    DSF+1,DS9
         BO    EXIT7                   DS9 = 1
         LH    R4,P
         STH   R4,DCBLRECL             P TO LRECL
         B     EXIT6
*
EXIT7    LH    R4,P
         LA    R4,1(,R4)               P+1 TO LRECL
         STH   R4,DCBLRECL
*
*        EXAMINE BLKSIZE
*
EXIT6    LH    R2,DCBBLKSI
         LTR   R2,R2                   BLKSIZE = 0 ?
         BZ    EXIT8                   YES, BRANCH
         CH    R4,DCBBLKSI             DCBBLKSI = DCBLRECL ?
         BE    EXIT61A                 YES, BRANCH
         LH    R3,DCBBLKSI
         SR    R2,R2
         DR    R2,R4
         LTR   R2,R2
         BZ    EXIT61
         OI    EXERFLAG,X'10'          BLOCKSIZE NOT A MULTIPLE OF
         B     RETEX                   LOGICAL RECORD LENGTH ERR NO.37
*
EXIT61   NI    DSF,255-DS1             0 TO DS1 UNBLOCKED FORMAT NESC
EXIT61A  MVC   BL(2),DCBBLKSI          BLKSI TO BL
         B     EXIT0
*
EXIT8    STH   R4,DCBBLKSI
         STH   R4,BL
         B     EXIT0
*
RETEX    RETURN
*
*----------------------------------------------------------------------
*        NEXTREC - CHANGE TO NEXT RECORD
*----------------------------------------------------------------------
*
*        INPUT -
*        IN CASE OF AN IN-MODULE CALLING NEXTREC, LAST I/O
*        OPERATION IS CHECKED FOR COMPLETION AND ONE BLOCK OR
*        RECORD IS READ TO THE OTHER I/O BUFFER
*
*        OUTPUT -
*        IN CASE OF AN OUT-MODULE CALLING NEXTREC, LAST I/O
*        OPERATION IS CHECKED FOR COMPLETION AND ONE BLOCK OR
*        RECORD IS WRITTEN TO THE DATASET
*
*
IHIIORNX SAVE  (14,12),,'IHIIORNX LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15
         USING IHIIORNX,R7
         ST    R13,SAVAR+4
         LA    R13,SAVAR
         L     R8,ADCB
*
*        FLOW CHAR PROGRAM BEGIN
*
         TM    DSF,DS2+DS6
         BZ    NXIN1
         BO    NXUT1
*
*        DS6=0 DS2=1 CURRENT BLOCK WAS READ AND SHOULD BE WRITTEN
*        BACK
*
         CHECK DECB
*
         MVC   BL(2),DCBBLKSI
         LR    R1,R8
*
         POINT (1),NOTEADR
*
         OI    DSF,DS6
*
*        DS6=1 DS2=1 WRITE BLOCK IF LAST RECORD
*
NXUT1    TM    DSF,DS1
         BZ    NXUT2
*
*        CHANGE BUFFERS
*
NXUT3    L     R2,BB
         L     R4,NBB
         ST    R4,BB
         ST    R2,NBB
         ST    R4,R
         AH    R4,P
         ST    R4,RE
         NI    DSF,255-DS3
NXUT4    L     R4,DECB+8
         CR    R4,R8
         BNE   NXUT41
*
         CHECK DECB
*
NXUT41   WRITE DECB,SF,(R8),(R2),MF=E
*
*        CLEAR NOTTAB IF BACKWARD REPOSITIONING HAS OCCURED
*
NXUT5    TM    DSF,DS5
         BZ    NXUT6
         L     R15,VIORCN              R15 -> IHIIORCN
         BALR  R14,R15                 CALL IHIIORCN
         NI    DSF,255-DS5
*
*        INSERT NOTTAB ENTRY IF REQUESTED
*
NXUT6    TM    DSF,DS4
         BZ    NXUT7
*
         CHECK DECB
*
         NOTE  (R8)
*
         ST    R1,NOTEADR
         L     R15,VIOREN              R15 -> IHIIOREN
         BALR  R14,R15                 CALL IHIIOREN
         NI    DSF,255-DS4
*
*        INSERT CONTROL CHARACTER IF SECTIONED
*
NXUT7    TM    DSF+1,DS9
         BZ    NXRET
         L     R4,R
         CLC   S+1(1),Q
         BL    NXUT8
         SR    R2,R2
         STH   R2,S
         MVI   0(R4),C'1'
         B     NXUT9
*
NXUT8    MVI   0(R4),C' '
NXUT9    LA    R4,1(R4)
         ST    R4,R
         AH    R4,P
         ST    R4,RE
*
*        INCREASE RECORD POINTER AND RETURN
*
NXRET    L     R2,S
         SRL   R2,16
         LA    R2,1(R2)
         STH   R2,S
         L     R13,SAVAR+4
*
         RETURN (14,12)
*
*        BLOCKED FORMAT
*        CHECK IF LAST RECORD IND IF NOTTAB ENTRY REQUIRED
*
NXUT2    L     R2,BB
         AH    R2,BL
         C     R2,RE
         BE    NXUT3
         L     R4,RE
         ST    R4,R
         AH    R4,P
         ST    R4,RE
         TM    DSF,DS4
         BZ    NXUT7
         NI    DSF,255-DS6
         L     R2,BB
         B     NXUT4
*
*        DS6=0 DS2=0 CHECK IF NOTTAB ENTRY REQUIRED
*        STORE ADDR OF LAST BLOCK IN NOTEADR AND READ NEXT
*        BLOCK
*
NXIN1    TM    DSF,DS4
         BZ    NXIN2
         L     R1,NOTEADR
         L     R15,VIOREN
         BALR  R14,R15
         NI    DSF,255-DS4
NXIN2    TM    DSF,DS1
         BZ    NXIN5
*
NXIN3    CHECK DECB
*
         TM    DSF,DS7
         BZ    NXIN7
         OI    DSF,DS6
         MVC   BL(2),DCBBLKSI
         B     NXIN6
*
NXIN7    LH    1,DCBBLKSI
         L     R4,DCBIOBA
         SH    1,22(R4)
         STH   1,BL
*
         NOTE  (R8)
*
         ST    R1,NOTEADR
         L     R2,BB
*
         READ  DECB,SF,(R8),(R2),MF=E
*
*        CHANGE BUFFERS
*
NXIN6    L     R2,BB
         L     R4,NBB
         ST    R4,BB
         ST    R4,R
         AH    R4,P
         ST    R4,RE
         ST    R2,NBB
         B     NXRET
*
*        BLOCKED FORMAT
*
NXIN5    L     R2,BB
         AH    R2,BL
         C     R2,RE
         BE    NXIN3
         L     R4,RE
         ST    R4,R
         AH    R4,P
         ST    R4,RE
         B     NXRET
*
*----------------------------------------------------------------------
*        CLOSE DATASET
*----------------------------------------------------------------------
*
*        FUNCTION/OPERATION -
*        CLOSE A DATASET, RELEASE STORAGE FOR I/O BUFFERS AND DCB
*        CALL FOR ROUTINE CLEAR NOTTAB
*
*        OUTPUT -
*        IN CASE OF OUTPUT WRITE LAST BLOCK TO DATASET
*
IHIIORCL SAVE  (14,12),,'IHIIORCL LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15
         USING IHIIORCL,R7
         ST    R13,SAVAR+4             SAVE REGISTER
         LA    R13,SAVAR
         L     R8,ADCB
*
*        DATASET 1 IS TO BE CLOSED ONLY IF DS15=1
*
*        IF DS15 = 0 FILL CURRENT BLOCK WITH BLANKS AND BRANCH
*        TO ROUTINE IHIIORNX TO WRITE THE BLOCK AND RETURN
*
         CH    R6,=H'1'
         BNE   CLOSE01
         TM    DSF+1,DS15
         BO    CLOSE01
         OI    DSF,DS2+DS6
         NI    DSF,255-DS0             SET DS0=0
         LH    R2,BL
         A     R2,BB
         L     R3,R
         ST    R2,R
         SR    R2,R3
         BZ    CLOSE02
CLOSE03  MVI   0(R3),C' '
         LA    R3,1(R3)
         BCT   R2,CLOSE03
CLOSE02  NI    S,X'00'
         MVC   S+1(1),Q
         L     R7,VIORNX               R15 -> IHIIORNX
         B     14(,R7)                 CALL IHIIORNX
*
CLOSE01  TM    DSF,DS7
         BO    CLOSE1                  END OF DATA REACHED
         TM    DSF+1,DSIOERR           I/O ERROR ?
         BO    CLOSE1                  YES, GO CLOSE DCB
         LA    R4,DECB                 TEST IF READ OR WRITE BEFORE
         L     R2,8(,R4)               PICK UP DCB ADDR
         CR    R2,R8
         BNE   CLOSE2
         OI    DSF+1,DS8               SET DS8=1 FOR END OF DATA
*
CLOSE0   CHECK DECB                    LAST I/O FINISHED
*
CLOSE2   TM    DSF,DS2                 LAST I/O OUTPUT ?
         BZ    CLOSE1
         TM    DSF,DS6                 BLOCK BEEN READ ?
         BO    WRITE2
         LR    R1,R8                   OUTPUT OCCUR WRITE BACK RECORD
*
         POINT (1),NOTEADR             NO BLANKS
*
         B     WRITE1
*
WRITE2   TM    DSF,DS3                 OUTPUT IN BLOCK
         BZ    CLOSE1                  NO CLOSE
*
*        OUTPUT HAS OCCURED, FILL BUFFER WITH BLANKS AND WRITE
*
WRITE1   LH    R2,BL
         L     R3,R
         S     R2,R
         A     R2,BB
         BZ    CLOSE21
CLOSE22  MVI   0(R3),C' '
         LA    R3,1(,R3)
         BCT   R2,CLOSE22
*
*        WRITE BUFFER
*
CLOSE21  L     R2,BB
*
CLOSE211 WRITE DECB,SF,(R8),(R2),MF=E
*
         CHECK DECB
*
*        CLOSE DATASET
*
CLOSE1   CLOSE ((R8),REREAD)
*
         L     R1,BB
         C     R1,NBB
         BL    *+8                     THE LOWEST ADDR TO R1
         L     R1,NBB
         LH    R0,BL                   BUFFER LEN TO R0
         SLA   R0,1
*
*        FREEMAIN FOR RECORD BUFFERS
*
         FREEMAIN  R,LV=(0),A=(1)
*
*        FREEMAIN FOR DCB AND DECB
*
         FREEMAIN R,LV=DCBAREAL-JFCB_LEN,A=ADCB
*
         SR    R2,R2
         LA    R2,1(,R2)
         STH   R2,S
         LA    R2,1(,R2)
         MVC   P(2),=H'80'              P=80
         LTR   R2,R6
         BZ    CLOSE3
         BCT   R2,CLOSE4
         B     CLOSE3
*
CLOSE4   L     R15,VIORCN
         BALR  R14,R15                  CLEAR NOTTAB FOR DATASET
CLOSE3   MVC   DSF,BL+2                 RESTORE DATASET FLAGS
         L     R13,SAVAR+4
*
         RETURN (14,12)
*
*----------------------------------------------------------------------
*        CLOSE ALL DATASETS
*----------------------------------------------------------------------
*
*        FUNCTION/OPERATION -
*        CALL ROUTINE CLOSE FOR ALL OPEN DATASETS AND ROUTINE
*        CLOSEGP IN IHIGPR MODULE
*
*        THIS ROUTINE IS CALLED FROM IHIFSA AND IHIERR. IN BOTH
*        CASES R5 CONTAINS THE ADDR OF THE ENTRY IN DSTABLE
*        FOR DATASET ONE IE DSTABLE+40
*
IHIIORCP SAVE  (14,12),,'IHIIORCP LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15
         USING IHIIORCP,R7             SAVE REGISTER
         ST    R13,SAVCLO+4
         LA    R13,SAVCLO
         SR    R6,R6
         SH    R5,=H'40'               DSN TO DSTABLE START
         ICM   R2,B'1111',0(R5)        TEST APGCF
         BP    CLOSEPE4                PUT/GET ENTRY IN DSTABLE
         LA    R2,0(,R2)
         LA    R5,4(,R5)               R5 -> FIRST DSTABLE ENTRY
CLOSEPE2 CR    R2,R5
         BE    CLOSEPE3                ALL DATASETS ARE CLOSED
         NI    BL+3,255-DS6
         CH    R6,=H'1'
         BE    CLOSEPE5
CLOSEPE7 TM    DSF,DS0
         BZ    CLOSEPE1
*
*        CALL FOR ROUTINE CLOSE
*
CLOSEPE6 L     R8,ADCB
         L     R15,ACLOSE
         BALR  R14,R15
CLOSEPE1 LA    R5,DSTABLEL(,R5)        NEXT ENTRY IN DSTAB
         LA    R6,1(,R6)               INCREASE DATASET NUMBER
         B     CLOSEPE2
*
CLOSEPE5 TM    DSF+1,DS14              DATASET OPENED ?
         BZ    CLOSEPE7
         B     CLOSEPE6
*
CLOSEPE4 TM    27(R2),X'80'            PUT/GET DATASET OPEN ?
         BZ    CLOSEPE2-4              DATASET CLOSED
         L     R15,IHIIORGP
         BALR  R14,R15                 CLOSE PUT/GET DATASET
         B     CLOSEPE2-4
*
*        ALL DATASETS ARE CLOSED
*
CLOSEPE3 L     R1,ANOTTAB(R12)
         LTR   R1,R1
         BZ    RETCLOSP
*
         FREEMAIN R,LV=1024,A=(1)      FREE NOTTAB
*
RETCLOSP L     R13,SAVCLO+4
*
         RETURN (14,12)
*
SAVCLO   DC    18F'0'
*
*        EXTERNAL ADDR
*
ACLOSE   DC    A(IHIIORCL)
*
IHIIORGP DC    A(0)
*
*----------------------------------------------------------------------
*        CLEAR NOTTAB
*----------------------------------------------------------------------
*
*        FUNCTION/OPERATION -
*        ALL ENTRIES IN NOTTAB FOR RECORDS EQUAL OR GREATER THAN
*        ACTUAL RECORD COUNTERS ARE CLEARED BY INSERTING INVALID
*        FLAG
*
IHIIORCN SAVE  (14,12),,'IHIIORCN LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15                  DEFINE BASE REGISTER
         USING IHIIORCN,R7
         L     R9,ANOTTAB(R12)
         LR    R4,R9
CLNOTB1  LA    R4,8(,R4)               START ENTRY ADDR TO R4
         C     R4,0(,R9)
         BE    RETCLEAR                NOTTAB CLEARED
         LR    R2,R6                   DATASET NUMBER TO R2
         CH    R2,0(,R4)
         BNE   CLNOTB1                 CURRENT DSN NOT EQUAL
         CLC   S(2),2(R4)
         BH    CLNOTB1
         MVI   0(R4),X'80'             INSERT INVALID FLAG IN NOTTAB
         B     CLNOTB1
*
RETCLEAR RETURN (14,12)
*
*----------------------------------------------------------------------
*        CLEAR NOTTAB
*----------------------------------------------------------------------
*
*        FUNCTION/OPERATION -
*        AN ENTRY FOR RECORD JUST HANDLED IS MADE IN NOTTAB
*
*        NOTES - ON ENTRY R1 = NOTEADR FROM DSTABLE
*
*
IHIIOREN SAVE  (14,12),,'IHIIOREN LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15
         USING IHIIOREN,R7
         L     R9,ANOTTAB(R12)
         LR    R4,R9
ENNOTB1  LA    R4,8(,R4)               START ENTRY ADDR
         C     R4,0(,R9)
         BNE   ENNOTB3
         L     R2,0(,R9)               NXE TO R2
         LA    R2,8(,R2)               INCREASE NXE BY EIGHT
         ST    R2,0(,R9)
         C     R2,4(,R9)
         BE    ENNERR4                 OVERFLOW NOTTAB
ENNOTB2  LR    R2,R6
         SLA   R2,16
         ST    R2,0(,R4)               NEW ENTRY DSN AND S TO NOTTAB
         MVC   2(2,R4),S
         ST    R1,4(,R4)               NOTEADR
*
         RETURN (14,12)
*
ENNOTB3  TM    0(R4),X'80'             NOTTAB ENTRY INVALID ?
         BO    ENNOTB2
         B     ENNOTB1
*
ENNERR4  LR    13,R12                  OVERFLOW OF RECORD IDENT AREA
         B     FSAERR+4*4(R12)
*
*----------------------------------------------------------------------
*        EVALUATE DATASET NUMBER
*----------------------------------------------------------------------
*
*        FUNCTION/OPERATION -
*        ADDR OF DSTABLE IN GENERATED OBJECT MODULE IS PICKED UP
*        FROM FSA
*        L R4,ADSTAB(R12)
*        ACTUAL DATASET NUMBER LOADED IN BINARY FORM TO R6,
*        ADDR OF ACTUAL ENTRY IN DSTABLE TO R5, THESE REGISTERS
*        ARE KEPT THROUGH ALL I/O MODULES IN ORDER TO ADDR
*        POINTERS AND FLAGS IN DSTAB
*
*        ENTRY POINT -
*        DATA IS PASSED VIA NAME
*        LA   R1,PARMLIST
*        BALR R14,R15
*
*
*
IHIIOREV SAVE  (14,12),,'IHIIOREV LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15
         USING IHIIOREV,R7
         ST    R13,SAVAR+4
         LA    R13,SAVAR
*
*        PARAMETER LIST ADDR IN R1
*
         ICM   R5,B'1111',0(R1)
         BP    DSNINT
         TM    OPTSW(R12),X'20'        LONG OR SHORT PRECISION ?
         BO    EVD1                    SHORT
         LD    FPR0,0(,R5)             LONG
         B     EVD1+4
*
EVD1     LE    FPR0,0(,R5)             SHORT
         L     R15,VIORCI              R15 -> IHIIORCI
         BALR  R14,R15                 CALL IHIIORCI
         B     DSNINTA
*
DSNINT   L     R0,0(,R5)               DATASET NUMBER IN R0
DSNINTA  LR    R5,R0
         N     R0,RANGEDSN             DATASET NUMBER OUT OF RANGE
         BM    EVDERR0
         LR    R6,R5
         LA    R0,DSTABLEL             L'DSTABLE ENTRY
         MR    R4,R0
         L     R4,ADSTAB(R12)
         LA    R5,4(R5,R4)             ENTRY TO DSTABLE IN R5
         L     R13,SAVAR+4
         LM    R14,R4,12(R13)
         LM    R7,R12,48(R13)          KEEP R5 AND R6
         BR    R14
*
EVDERR0  LR    R13,R12                 DATASET NUMBER OUT OF RANGE
         B     FSAERR(R12)
*
RANGEDSN DC    F'-16'                  SCOPE OUTSIDE RANGE OF DSN
*
VIORCI   DC    V(IHIIORCI)             ADDR OF CONVERSION ROUTINE
*
*----------------------------------------------------------------------
*        DCB END OF DATA EXIT
*----------------------------------------------------------------------
*
*        FUNCTION/OPERATION - INVOKED VIA CHECK MACRO
*
*        EXITS - NORMAL - CHECK FROM SYSACT4 OR CLOSE RELOAD
*                         REGISTERS AND RETURN TO CALLING PROGRAM
*                         VIA BR14
*              - CHECK FROM NEXTREC - BLOCKED FORMAT SET FLAG DS7 IN
*                         DSTABLE AND BRANCH TO END OF NEXTREC
*              - UNBLOCKED FORMAT OUTPUT - RETURN TO NEXTREC TO WRITE
*                         BACK CURRENT RECORD
*              - UNBLOCKED FORMAT INPUT - SET FLAG DS7 IN DSTABLE AND
*                         RETURN TO NEXTREC TO UPDATE PTR IN DSTABLE
*              - ERROR -  CHECK FROM OPEN
*                         INPUT REQUEST BEYOND END OF DATASET
*
*
IHIIORED SAVE  (14,12),,'IHIIORED LEVEL 2.1 &SYSDATE &SYSTIME'
*
         BALR  R7,0
         USING *,R7
         ST    R13,SAVEOD+4
         LA    R13,SAVEOD
         L     R8,ADCB
         TM    DSF+1,DSEOD             CHECK FROM OPEN ?
         BZ    END00
         NI    DSF,255-(DS2+DS3+DS6)   SET FLAGS FOR A CORRECT CLOSE
         LR    R13,R12
         B     FSAERR+5*4(R12)         INPUT REQUEST BEYOND END
*
END00    CLOSE ((R8),LEAVE),TYPE=T
*
         TM    DSF+1,DS8               CHECK FROM CLOSE OR SYSACT4 ?
         BZ    END02
END11    L     R13,SAVEOD+4
         LM    R14,R12,12(R13)
         BR    R14                     RETURN TO CALLING SYSACT4 OR
*                                      CLOSE ROUTINE
END02    TM    DSF,DS2
         BZ    END03
         B     END11
*
END03    OI    DSF,DS7
         MVI   DECB+8,X'FF'            FLAG DCB ADDR IN DECB
         L     R13,SAVEOD+4            RETURN TO CALLING NEXTREC
         LM    R14,R12,12(R13)
         BR    R14                     RETURN TO CALLING NEXTREC
*
*        INTERNAL ADDRESSES
*
SAVEOD   DC    18F'0'
*
*----------------------------------------------------------------------
*        CONVERSION TO INTEGER
*----------------------------------------------------------------------
*
*        FUNCTION/OPERATION - CONVERT REAL LONG OR SHORT TO INTEGER
*
*        NOTES - CALLED BY BALR 14,15
*        DATA PASSED BY VALUE IN FPR0
*        RESULT IN R0
*
IHIIORCI TM    OPTSW(R12),X'20'        LONG OR SHORT PRECISION ?
         USING IHIIORCI,R15
         BZ    LONG
         STE   FPR0,BUFF3
         LD    FPR0,BUFF3
*
LONG     AD    FPR0,CONST2
         STD   FPR0,BUFF4
         CE    FPR0,CONST3
         BNL   ERROR1
         AW    FPR0,CONST1
         BP    LABEL
         CLC   BUFF4(8),CONST4
         BH    ERROR1
LABEL    STD   FPR0,BUFF2
         L     R0,BUFF2+4
         X     R0,CONST1+4
         SD    FPR0,CONST1
         CD    FPR0,BUFF4
         BNHR  R14
         BCTR  R0,R14
ERROR1   LR    R13,R12
         B     FSAERR+1*4(R12)
*
*        INTERNAL CONSTANTS AND STORAGE
*
         DC    0D'0'
CONST1   DC    X'4E00000080000000'
CONST2   DC    X'4080000000000000'
BUFF2    DC    D'0'
BUFF3    DC    D'0'
CONST4   DC    X'C880000000000000'
BUFF4    DC    D'0'
CONST3   DC    X'48800000'
*
*        DCB SYNAD EXIT
*
*        EXIT - NORMAL - BRANCH ERROR UNRECOVERABLE I/O ERROR
*
IHIIORER LR    R7,R15
         USING IHIIORER,R7
         OI    DSF+1,DSIOERR           SET MARK FOR CORRECT CLOSE
         LR    R13,R12
         B     FSAERR+32*4(R12)        I/O ERROR
*
*
DCBMODEL DCB   DSORG=PS,MACRF=(RP,WP),DDNAME=ALGLDD,NCP=1,             X
               EODAD=IHIIORED,                                         X
               EXLST=ADCBEXIT,                                         X
               SYNAD=IHIIORER
*
DCBMODLN EQU   *-DCBMODEL              LENGTH OF DCBMODEL FOR MVC
*
         DC    0F'0'
ADCBEXIT DC    X'05'                   DCB OPEN EXIT REQUESTED
         DC    AL3(IHIIORDX)           OPEN EXIT ROUTINE ADDR
         DC    X'87',AL3(0)            JFCB ADDR UPDATED WHEN GETMAINED
*
DWORD    DC    D'0'                    WORK AREA FOR DSN
SAVAR    DC    18F'0'
EXERFLAG DC    X'00'
*
*        INTERNAL ADDRS
*
VIORCN   DC    A(IHIIORCN)
VIOREN   DC    A(IHIIOREN)
VIORNX   DC    A(IHIIORNX)
*
         LTORG
*
*        SEE GC28-6615 ALGOL LANGUAGE P82 FOR A DETAILED DESCRIPTION
*        OF THE DSTABLE FIELDS MAINTAINED FOR EACH DATASET
*
         DSTABLE  DSECT=YES
*
*        SYMBOLIC NAMES FOR DCB
*
         PRINT NOGEN
*
         DCBD  DSORG=BS,DEVD=DA
*
         PRINT GEN
*
*        DECB
*
         READ  DECB,SF,MF=L
*
JFCB     DS    22D
         ORG   JFCB
*
         IEFJFCBN ,                    MAP THE JFCB
*
JFCB_LEN EQU   *-JFCB
*
*        CALCULATE TOTAL GETMAINED AREA FOR DCBAREA WITH DECB AND JFCB
*
DCBAREAL EQU   *-IHADCB
*
*        REGISTER EQUATES
*
         IEZREGS
*
FPR0     EQU   0
*
         END
./ ADD NAME=IHIISY   0201-12230-12230-1200-00152-00152-00000-LEVEL
ISY      TITLE 'IHIISYMB, INSYMBOL, ALGOL F LIBRARY'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        COMPARE ONE CHARACTER FROM AN INPUT BUFFER WITH AN
*        INTERNAL STRING AND ASSIGN WHEN CORRESPONDENCE POSITION
*        NUMBER IN STRING TO THIRD ACTUAL PARAMETER
*
*        ENTRY POINT - IHIISYMB - FROM GENERATED OBJECT MODULE
*                      LA   R1,PARMLIST
*                      BALR R14,R15
*                      DATA PASSED BY NAME
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES -
*        IHIIOR - EVALUATE DATASET NUMBER
*               - OPEN DATASET
*               - CHANGE TO NEXT INPUT RECORD
*
*        EXITS - NORMAL - RELOAD REGISTERS AND RETURN VIA R14
*              - ERROR  - INPUT REQUEST BEYOND END OF DATASET NO 5
*                         BRANCH TO FSA
*                         LA   R13,IHIFSA
*                         B    FSAERR+XX*4(R13) XX ERROR NUMBER
*
*        TABLES/WORK AREAS - N/A
*
IHIISYMB CSECT
*
*        GENERAL REGISTER USAGE
*
*        R5                            -> DSTABLE ENTRY
*        R6                            DATASET NUMBER
*        R3                            -> DESTINATION
*        R4                            -> STRING SYMBOL
*        R9                            -> END OF STRING
*        R10                           CHARACTER POINTER
*        R8                            INCREMENT FOR LOOP
*        R12                           -> FSA
*
*        DISPLACEMENTS IN ADRLST IN IHIFSA
*
CI       EQU   0                       IHIIORCI
CL       EQU   4                       IHIIORCL
EV       EQU   8                       IHIIOREV
NX       EQU   12                      IHIIORNX
OP       EQU   16                      IHIIOROP
OQ       EQU   20                      IHIIOROQ
*
         SAVE  (14,12),,'IHIISYMB LEVEL 2.1 &SYSDATE &SYSTIME'
         LR    R7,R15
         USING IHIISYMB,R7
         LR    R12,R13                 R12 -> FSA
         LA    R13,SAVEAREA            CHAIN SAVE AREAS
         ST    R12,SAVEAREA+4
         ST    R13,8(,R12)
*
*        EVALUATE DATASET NUMBER (EVDSN)
*
         L     R15,IORLST(,R12)
         L     R15,EV(,R15)
         BALR  R14,R15                 CALL IHIIOREV
         L     R4,4(,R1)               R4 - STRING
         L     R3,8(,R1)               R3 -> DESTINATION
         LA    R8,1                    INCREMENT
*
*        TEST IF DATASET IS OPEN
*
         USING DSTABLE,R5
         NI    DSF+1,255-DS10          SET DS10 = 0
         CLI   Q,0                     DATASET SECTIONED ?
         BNE   ERROR2                  INCOMPATIBLE ACTION
         LR    R10,R6                  DATASET NO = 1 ?
         BCT   R10,SYMBBB              NO, BRANCH
         B     ERROR2                  INCOMPATIBLE ACTION
*
SYMBBB   TM    DSF,DS0                 DATASET OPEN ?
         BZ    SYMBDD                  NO, BRANCH
*                                      DATASET IS OPEN
SYMBCC   TM    DSF,DS2                 LAST I/O OUTPUT ?
         BZ    SYMBEE
         B     ERROR3                  INPUT BEYOND LAST OUTPUT
*
SYMBEE   TM    DSF,DS6                 OPEN FOR OUTPUT OR EOD ?
         BZ    EVSYMB
         TM    DSF,DS7                 END OF DATA BEEN REACHED ?
         BO    ERROR5                  INPUT RQUEST BEYOND END OF DATA
         B     ERROR2
*
SYMBDD   NI    DSF,255-DS6             SET DS6 = 0
         L     R15,IORLST(,R12)
         L     R15,OP(,R15)            R15 -> IHIIOROP
         BALR  R14,R15                 CALL IHIIOROP TO OPEN DATASET
*
EVSYMB   LH    R9,0(,R4)               LENGTH OF STRING
         BCTR  R9,0
         AR    R9,R4                   STRING-END LESS 1
         LA    R4,2(,R4)               -> STRING-SYMBOL
         L     R10,R                   CHARACTER POINTER
SYMBLOOP CLC   0(1,R10),0(R4)
         BE    TERMINBB
         BXLE  R4,R8,SYMBLOOP
         SR    R4,R4                   ZERO INSERTED R4
         B     TERMINAA
*
TERMINBB S     R4,4(,R1)
         BCTR  R4,0
TERMINAA ST    R4,0(,R3)               NUMBER OF SYMBOL INSERTED
*                                      DESTINATION
TERMIN   LA    R10,1(,R10)
         C     R10,RE
         BNL   NEXTREC
         ST    R10,R
TERMINCC LR    R13,R12
*
         RETURN (14,12)                RESTORE CALLERS REGS AND RETURN
*
NEXTREC  L     R15,IORLST(,R12)
         L     R15,NX(,R15)            R15 -> IHIIORNX
         BALR  R14,R15                 GET NEXT RECORD
         B     TERMINCC
*
ERROR2   LR    R13,R12
         B     FSAERR+2*4(R12)         INCOMPATIBLE ACTION ON DATASET
*
ERROR3   LR    R13,R12
         B     FSAERR+3*4(R12)         INPUT BEYOND LAST OUTPUT
*
ERROR5   LR    R13,R12
         B     FSAERR+5*4(R12)         INPUT REQUEST BEYOND END OF DATA
*
SAVEAREA DC    18F'0'                  SAVE AREA
*
         LTORG
*
         DSTABLE DSECT=YES
*
FAS      DSECT
*
         COPY  FSAREA
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHILAT   0201-12230-12230-1200-00124-00124-00000-LEVEL
TAN      TITLE 'IHILATAN, ATAN LONG PRECISION, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION-
*        1. REDUCE THE CASE TO THE 1ST OCTANT BY USING
*           ATAN(-X) = -ATAN(X), ATAN(1/X) = PI/2-ATAN(X)
*        2. REDUCE FURTHER TO THE CASE /X/ LESS THAN TAN(PI/2) BY
*           ATAN(X)=PI/6+ATAN((X*SQRT3-1)/(X+SQRT3)
*        3. FOR THE BASIC RANGE (X LESS THAN TAN(PI/12)),
*           USE A FRACTIONAL APPROXIMATION
*
*        ENTRY POINT -
*        IHILAT - ATAN FUNCTION, LONG
*                 LA   R1,PARMLIST
*                 BALR R14,R15
*                 DATA PASSED BY NAME
*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXIT - NORMAL -
*        RETURN VIA R14, RESULT IN FPR0
*
*        EXIT - ERROR - N/A
*
*        TABLES/WORKAREAS - N/A
*
IHILATAN CSECT
*
         ENTRY IHILAT
*
FPR0     EQU   0                       RESULT REGISTER
FPR2     EQU   2                       SCRATCH REGISTERS
FPR4     EQU   4
FPR6     EQU   6
*
IHILAT   SAVE  (14,12),,'IHILATAN LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHILATAN,R15
         L     R1,0(,R1)
         LD    FPR0,0(,R1)             OBTAIN ARGUMENT
         STE   FPR0,SIGN               SAVE ARG FOR SIGN CONTROL
         LPER  FPR0,FPR0               SET SIGN POSITIVE
         SR    R1,R1                   R1 FOR DISTINGUISHING CASES
         CE    FPR0,ONE
         BL    SKIP1
         LD    FPR2,ONE                IF X > 1, TAKE INVERSE
         DDR   FPR2,FPR0
         LDR   FPR0,FPR2
         LA    R1,16                   INCR R1 BY 16
SKIP1    CE    FPR0,TAN15
         BNH   SKIP2
         LDR   FPR2,FPR0               IF X >TAN(PI/12),
         MD    FPR0,RT3M1             REDUCE X TO (X*SQRT3-1)/(X+SQRT3)
         SD    FPR0,HALF
         SD    FPR0,HALF               COMPUTE X*SQRT3-1 AS
         ADR   FPR0,FPR2               X*(SQRT3-1)-0.5-0.5+X
         AD    FPR2,RT3                TO GAIN ACCURACY
         DDR   FPR0,FPR2
         LA    R1,8(,R1)               INCR R1 BY 8
SKIP2    LDR   FPR6,FPR0               COMPUTE ATAN OF REDUCED
         MDR   FPR0,FPR0               ARGUMENT BY
         LDR   FPR2,FPR0               ATAN(X) = X(1+F*XSQ)
         AD    FPR2,BETA4
         LD    FPR4,ALPHA4             F = A1/(B1+XSQ+A2/(B2+XSQ+A3
         DDR   FPR4,FPR2                    /(B3+XSQ+A4/(B4+XSQ))..)
         ADR   FPR4,FPR0
         AD    FPR4,BETA3
         LD    FPR2,ALPHA3
         DDR   FPR2,FPR4
         ADR   FPR2,FPR0
         AD    FPR2,BETA2
         LD    FPR4,ALPHA2
         DDR   FPR4,FPR2
         ADR   FPR4,FPR0
         AD    FPR4,BETA1
         LD    FPR2,ALPHA1
         DDR   FPR2,FPR4
         MDR   FPR0,FPR2
         MDR   FPR0,FPR6
         ADR   FPR0,FPR6
         C     R1,KF16                 DEPENDING ON THE CASE EITHER ADD
         BL    SKIP3                   0 OR PI/6 OR SUBTRACT FROM PI/3
         LCER  FPR0,FPR0               OR PI/2.  DO LATTER IN 2 STEPS
         AD    FPR0,PO2M1-16(R1)
SKIP3    AD    FPR0,ZERO(R1)
         TM    SIGN,X'80'              SIGN NEGATIVE ?
         BZ    SKIP4                   YES, ANSWER IS NEGATIVE
         LCER  FPR0,FPR0
SKIP4    BR    R14                     RETURN
*
SIGN     DC    F'0'
         DC    0D'0'
RT3M1    DC    X'40BB67AE8584CAA8'      SQRT(3)-1
RT3      DC    X'411BB67AE8584CAB'      SQRT(3)
ALPHA1   DC    X'C0D5F788DF6CB457'       -0.8358083291502266
BETA1    DC    X'414D42F041242098'        4.828842405755528
ALPHA2   DC    X'C1DD6E91F2AD24DF'      -13.839494655565710
BETA2    DC    X'4168C2DCB9C0437F'        6.547573781576119
ALPHA3   DC    X'C1138256FCDD5CB6'       -1.219321239235610
BETA3    DC    X'41224D09A3EFF7AC'        2.143808021908152
ALPHA4   DC    X'C0145A9C5C07FB43'       -0.07950761076788829
BETA4    DC    X'4114451896975D03'        1.266869152304765
PO2M1    DC    X'40921FB54442D184'       90 DEGREES MINUS ONE
         DC    X'408C152382D73658'       60 DEGREES MINUS HALF
ZERO     DC    D'0'                     0
         DC    X'40860A91C16B9B2D'      30 DEGREES
ONE      DC    X'4110000000000000'
HALF     DC    X'4080000000000000'
TAN15    DC    X'40449851'
KF16     DC    F'16'
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHILEX   0201-12230-12230-1200-00154-00154-00000-LEVEL
LEX      TITLE 'IHILEXPT, EXPONENTIAL, LONG PRECISION, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        Y = X*LOG2(E) = 4A-B-C/16-D
*        WHERE A, B, AND C ARE INTEGERS
*        B BETWEEN 0 AND 3
*        C BETWEEN 0 AND 15
*        D IS A FRACTION BETWEEN 0 AND 1/16
*         THEN
*        E**X = 2**Y = (16**A)(2**-B)N2**-C/16)(2**-D)
*
*        ENTRY POINT -
*        IHILEX - EXP FUNCTION, LONG
*                 LA   R1,PARMLIST
*                 BALR R14,R15
*        DATA PASSED BY NAME
*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXIT - NORMAL -
*        RETURN VIA R14, RESULT IN FPR0
*
*        EXIT - ERROR -
*        IF ARGUMENT GREATER THAN 174673 GOTO ERROR ROUTINE VIA
*        B FSAERR+24*4(R13)
*
*        TABLES/WORKAREAS - N/A
*
IHILEXPT CSECT
*
         ENTRY IHILEX
*
FPR0     EQU   0                       RESULT REGISTER
FPR2     EQU   2                       SCRATCH REGISTER
*
IHILEX   SAVE  (14,12),,'IHILEXPT LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHILEXPT,R15
         L     R1,0(,R1)               OBTAIN ARGUMENT
         LD    FPR0,0(,R1)
         CE    FPR0,MAX                MAX = 63*LOG16 = 174.67309
         BH    ERROR                   ARG > MAX, ERROR
         CE    FPR0,MIN                MIN = -65*LOG16 = -180.21867
         BNH   SMALL                   ARG < MIN, GIVE ANS=0
         DD    FPR0,LOGE2              Y = X*LOG2(E) BY ACCURATE DIVIDE
         STE   FPR0,SIGN               SAVE SIGN OF Y
         LER   FPR2,FPR0               DECOMPOSE Y = (-4A'-B'-C'/16)-D'
         AU    FPR2,SCALER             BY FORCING CHARACTISTIC OF X'45'
         STE   FPR2,FIELDS             -4A'-B'-C'/16 IN FIELDS,
         SDR   FPR2,FPR2               UNNORMALIZED
         AE    FPR2,FIELDS             NORMALIZE THIS AND SUBTRACT IT
         SDR   FPR0,FPR2               FROM Y TO OBTAIN -D' IN FPR0
         L     R2,FIELDS
         TM    SIGN,X'80'              Y NEGATIVE ?
         BO    READY                   YES, BRANCH
*                                      Y NON-NEGATIVE,
         SD    FPR0,ONO16              -D = /D'/-1/16
         LA    R2,1(,R2)              -4A-B-C/16 = -(-4A'-B'-(C'+1)/16)
         LCR   R2,R2                   NOW IN ANY CASE, B, C,
READY    SR    R3,R3                   AND D ARE POSITIVE
         SRDL  R2,4                    C IN HIGH R3
         SRL   R3,25
         SRDL  R2,2                    B IN HIGH R3, C IN LOW R3
         SLL   R2,24
         LCR   R0,R2                   A (IN SCALE B7) IN R0,
         SR    R2,R2                   CHAR MODIFIER
         SLDL  R2,2                    B IN R2, 8*C IN R3
         LDR   FPR2,FPR0               COMPUTE 2**-D BY USE OF
         ME    FPR0,C6                 CHEBYSHEV INTERPOLATION
         AD    FPR0,C5                 POLYNOMIAL OF DEGREE 6
         MDR   FPR0,FPR2
         AD    FPR0,C4
         MDR   FPR0,FPR2
         AD    FPR0,C3
         MDR   FPR0,FPR2
         AD    FPR0,C2
         MDR   FPR0,FPR2
         AD    FPR0,C1
         MDR   FPR0,FPR2
         AD    FPR0,C0A                ADD C0 = 1. IN 2 STEPS
         AD    FPR0,C0A                TO PROTECT LAST DIGIT
         LTR   R3,R3                   MULTIPLY 2**(-C/16)
         BZ    SKIP2                   IN DOING SO, AVOID
         CE    FPR0,ONE                MULTIPLICATION BY 1
         BL    SKIP1
         LD    FPR0,MCONST-8(R3)
         B     SKIP2
*
SKIP1    MD    FPR0,MCONST-8(R3)
SKIP2    LTR   R2,R2                   MULTIPLY 2**(-B)
         BZ    SKIP3                   BY HALVING B TIMES
SKIP3A   HDR   FPR0,FPR0
         BCT   R2,SKIP3A
SKIP3    STD   FPR0,SIGN               ADD A TO CHARACTERISTIC
         A     R0,SIGN
         ST    R0,SIGN
         SDR   FPR0,FPR0               NORMALIZE ANSWER JUST IN CASE
         AD    FPR0,SIGN
*
EXIT     RETURN (14,12)                RETURN
*
SMALL    SDR   FPR0,FPR0               IF X IS VERY LARGE NEGATIVE,
         B     EXIT                    GIVE 0 AS ANSWER
*
ERROR    L     R13,4(R13)              RESTORE FSA ADDR
         B     FSAERR+24*4(R13)        PARAM GREATER 174.673
*
FSAERR   EQU   X'1CC'
*
SIGN     DC    D'0'
FIELDS   EQU   SIGN+4
LOGE2    DC    X'40B17217F7D1CF79'     LOG 2 (BE) TRUNCATED
ONO16    DC    X'4010000000000000'
ONE      DC    X'41100000'
C6       DC    X'3D9E0F1E'             .1507368551403575E-3
C5       DC    X'3E575D42BB7276D4'     .1333073417706260E-2
C4       DC    X'3F276553A5F9BC94'     .9618117095313700E-2
C3       DC    X'3FE35846A61AEE7A'     .5550410840231345E-1
C2       DC    X'403D7F7BFF0289DE'     .2402265069563678
C1       DC    X'40B17217F7D1CC79'     .6931471805599346
C0A      DC    X'4080000000000000'     .5    C0/2
MCONST   DC    X'40F5257D152486CC'     2**(-1/16)
         DC    X'40EAC0C6E7DD2439'     2**(-2/16)
         DC    X'40E0CCDEEC2A94E1'     2**(-3/16)
         DC    X'40D744FCCAD69D6B'     2**(-4/16)
         DC    X'40CE248C151F8481'     2**(-5/16)
         DC    X'40C5672A115506DB'     2**(-6/16)
         DC    X'40BD08A39F580C37'     2**(-7/16)
         DC    X'40B504F333F9DE65'     2**(-8/16)
         DC    X'40AD583EEA42A14B'     2**(-9/16)
         DC    X'40A5FED6A9B15139'     2**(-10/16)
         DC    X'409EF5326091A112'     2**(-11/16)
         DC    X'409837F0518DB8A9'     2**(-12/16)
         DC    X'4091C3D373AB11C3'     2**(-13/16)
         DC    X'408B95C1E3EA8BD7'     2**(-14/16)
         DC    X'4085AAC367CC487B'     2**(-15/16)
SCALER   DC    X'45000000'
MAX      DC    X'42AEAC4E'             174.6731
MIN      DC    X'C2B437DF'             -180.2187
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHILLO   0201-12230-12230-1200-00126-00126-00000-LEVEL
LLO TITLE 'IHILLOGM, LOGARITHMIC FUNCTION, LONG PRECISION, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        WRITE X = (16**P)*(2**-Q)*M
*        Q BETWEEN 0 AND 3
*        AND M BETWEEN 1/2 AND 1
*        DEFINE A=1, B=0
*        IF M IS > SQRT2/2, OTHERWISE A=1/2, B=1
*        WRITE Z = (M-A)/(M+A), THEN
*        LOG(X) = (4P-Q-B)*LOG(2) + LOG((1+Z)/(1-Z))
*
*        ENTRY POINT -
*        IHILLO - LOG FUNCTION, LONG
*                 LA   R1,PARMLIST
*                 BALR R14,R15
*                 DATA PASSED BY NAME
*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0
*
*        EXIT - ERROR -
*        IF ARGUMENT ZERO OR NEGATIVE GOTO ERROR ROUTINE VIA
*        B   FSAERR+25*4(R13)
*
*        TABLES/WORKAREAS - N/A
*
IHILLOGM CSECT
*
         ENTRY IHILLO
*
FPR0     EQU   0                       RESULT REGISTER
FPR2     EQU   2                       SCRATCH REGISTER
*
IHILLO   SAVE  (14,12),,'IHILLOGM LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHILLOGM,R15
         L     R1,0(,R1)               OPTAIN ARGUMENT IN R0,R1
         LM    R0,R1,0(R1)
         LTR   R2,R0
         BNP   ERROR                   0 OR NEGATIVE, ERROR
         SRDL  R2,24                   CHAR IN LOW R2
         SLL   R2,2                    FIRST DIGIT IN HIGH R3
         STH   R2,IPART+2              FLOAT 4*CHAR AND SAVE IT
         SR    R2,R2
         SLDL  R2,4                    FIRST DIGIT IN R2
         IC    R2,TABLE(R2)            NO OF LEADING ZEROS (=Q) IN R2
         SLDL  R0,0(R2)
         STM   R0,R1,BUFF
         MVI   BUFF,X'40'              M = FRACTION*2**Q  IN CELL BUFF
         LA    R1,8
         LD    FPR0,BUFF               PICK UP M IN FPR0
         CE    FPR0,LIMIT              M > SQRT2/2, R1=8 ?
         BH    READY                   YES, BRANCH
         SR    R1,R1                   M < SQRT2/2, R1=0,
         LA    R2,1(,R2)               CRANK R2 BY 1, Q+B IN R2
READY    LDR   FPR2,FPR0               Z = (M-A)/(M+A),  A = 1 OR 1/2
         SD    FPR0,HALF               SUBTRACT A IN 2 STEPS TO PROTECT
         SD    FPR0,ZERO(R1)           THE LAST DIGIT
         AD    FPR2,HALF(R1)           M+A HAS ONLY 53BITS. NOT SERIOUS
         DDR   FPR0,FPR2
         STD   FPR0,BUFF
         MDR   FPR0,FPR0               COMPUTE LOG((1+Z)/(1-Z))
         LDR   FPR2,FPR0               BY CHEBYSHEV INTERPOLATION
         MD    FPR2,C7                 POLYNOMIAL (IN ZSQ) OF DEGREE 7
         AD    FPR2,C6
         MDR   FPR2,FPR0
         AD    FPR2,C5
         MDR   FPR2,FPR0
         AD    FPR2,C4
         MDR   FPR2,FPR0
         AD    FPR2,C3
         MDR   FPR2,FPR0
         AD    FPR2,C2
         MDR   FPR2,FPR0
         AD    FPR2,C1
         MDR   FPR2,FPR0             F = ZSQ*(C1+ZSQ*(C2+...+ZSQ*C7)..)
         LD    FPR0,BUFF               LOG((1+Z)/(1-Z)) = Z*(2+F)
         MDR   FPR2,FPR0                                = Z+Z+Z*F
         ADR   FPR2,FPR0               TO GAIN ACCURACY
         ADR   FPR2,FPR0
         LD    FPR0,IPART              4*CHARACTERISTIC IN FPR0
         LA    R2,256(,R2)             ADD 4*(BASE CHARAC=64) TO Q+B
         STH   R2,IPART+2              FLOAT THIS AND SUB FROM FPR0
         SE    FPR0,IPART              TO OBTAIN 4P-Q-B
         MD    FPR0,LOGE2              MULTIPLY LOG(2) BASE E
         ADR   FPR0,FPR2               AND ADD TO LOG((1+Z)/(1-Z))
*
         RETURN (14,12)                RETURN
*
ERROR    B     FSAERR+25*4(R13)        PARAMETER ¬> ZERO
*
FSAERR   EQU   X'1CC'
*
BUFF     DC    D'0'
IPART    DC    X'4600000000000000'
*
TABLE    DC    X'0303020201010101'   * THESE 4
ZERO     DC    X'0000000000000000'   | CONSTANTS
HALF     DC    X'4080000000000000'   | MUST BE
         DC    X'4110000000000000'   V TOGETHER
*
C7       DC    X'4025E9B17CA9B973'     .1480971268990510
C6       DC    X'40273337E26DBA7F'     .1531252792171731
C5       DC    X'402E8CD32A425C06'     .1818363168880382
C4       DC    X'4038E38A00083F6B'     .2222219705656678
C3       DC    X'4049249251450212'     .2857142876064318
C2       DC    X'40666666665EBAA3'     .3999999999930233
C1       DC    X'40AAAAAAAAAAAD6C'     .666666666666764
LOGE2    DC    X'40B17217F7D1CF7B'     LOG 2 (BE) + 1 IN LAST DGT
LIMIT    DC    X'40B504F3'             1/SQRT 2
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHILOR   0201-12230-12230-1200-00294-00294-00000-LEVEL
LOR      TITLE 'IHILOREA, OUTREAL LONG PRECISION, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        CONVERT BINARY ARITHMETIC VALUE, FROM SECOND ACTUAL
*        PARAMETER, TO ZONED DECIMAL FORM AND TRANSFER TO AN
*        OUTPUT BUFFER
*
*        ENTRY POINTS -
*        IHILOREL - FROM GENERATED OBJECT MODULE
*                   LA   R1,PARMLIST
*                   BALR R14,R15
*                   DATA PASSED BY NAME
*        IHILORAR - FROM ARRAY MODULE IHIOAR
*                   LA   R7,DATA
*                   BALR R14,R15
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES -
*        IHIIOR - EVALUATE DATA SET NUMBER
*               - OPEN DATASET
*               - CHANGE TO NEXT OUTPUT RECORD
*        IHIFSA - CNVIRD - CONVERT INTEGER TO REAL LONG
*        IHIPTT - POWER OF TEN TABLE LONG PREC
*
*        EXIT - NORMAL - RELOAD REGISTERS AND RETURN VIA R14
*
*        EXIT - ERROR - TOO LONG RECORD NO 38
*                       BRANCH TO IHIFSA
*                       L    R13,IHIFSA
*                       B    FSAERR+XX*4(R13) XX ERROR NO
*
*        TABLES/WORK AREAS - N/A
*
IHILOREA CSECT
*
         ENTRY IHILOREL
         ENTRY IHILORAR
*
         USING DSTABLE,R5
*
FPR0     EQU   0                   FLOATING POINT NUMBER
*
*        R5                            -> DSTABLE ENTRY
*        R7                            -> SOURCE
*        R4                            =  CHARACTER POINTER
*        R8                            =  BLANK COUNTER
*        R2                               EXPONENT > EIGHT
*        R3                               EXPONENT < EIGHT
*        R9                               DECIMAL EXPONENT
*        R8                               BLANK COUNTER
*        R15                           -> POWER TEN TABLE
*
*        DISPLACEMENTS IN ADRLST IN IHIFSA
*
CI       EQU   0             DISPLACEMENT FOR - IHIIORCI
CL       EQU   4                                IHIIORCL
EV       EQU   8                                IHIIOREV
NX       EQU   12                               IHIIORNX
OP       EQU   16                               IHIIOROP
OQ       EQU   20                               IHIIOROQ
*
IHILORAR SAVE  (14,12),,'IHILORAR LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHILORAR,R15
         LR    R10,R13                 CHAIN SAVE AREAS
         LA    R13,SAVEAREA
         ST    R10,4(,R13)
         ST    R13,8(,R10)
         LA    R10,COMMON
         DROP  R15
         USING COMMON,R10
         B     SOUFLPA
*
         DROP  R10
*
IHILOREL SAVE  (14,12),,'IHILOREL LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHILOREL,R15
         LR    R12,R13                 R12 -> FSA
         LA    R13,SAVEAREA
         ST    R12,4(,R13)
         ST    R13,8(,R12)
         LA    R10,COMMON
         DROP  R15
         USING COMMON,R10
*
*        EVALUATE DATASET NUMBER (EVDSN)
*
COMMON   L     R15,IORLST(,R12)
         L     R15,EV(,R15)
         BALR  R14,R15
SOUFLP   L     R7,4(,R1)               R7 -> SOURCE
SOUFLPA  OI    DSF,DS2+DS3             DS2, DS3 = 1
         NI    DSF,255-DS7             DS7 = 0
         LTR   R7,R7
         BP    REAL1
*
*        CALL CONVERSION ROUTINE (LOADED IN FSA)
*
         STM   R14,R13,8(R13)          SAVE REGS
         LR    R2,R13                  R2 -> SAVEAREA
         L     R14,0(,R7)              INTEGER INTO R14
         LA    R7,ACNVIRD(R12)
         LR    R13,R12                 R13 -> FSA
         BALR  R8,R7
         LM    R14,R13,8(R2)           RESTORE REGS
         B     REAL1A                  NUMBER IN FPRO AFTER CONVERSION
*
REAL1    LD    FPR0,0(,R7)             NUMBER IN FPR0
REAL1A   TM    DSF,DS0                 DATASET OPEN ?
         BO    NOCLO                   YES, BRANCH
         OI    DSF,DS6                 DS6 = 1 OPEN FOR OUTPUT
         L     R15,IORLST(,R12)
         L     R15,OP(,R15)
         BALR  R14,R15
NOCLO    L     R4,R                    CHARACTER POINTER
         LA    R8,22(,R4)
         C     R8,RE                   BUFFER CAN ACCEPT 22 DIGITS ?
         BNH   NONEXREC                YES, BRANCH
         L     R8,RE
         SR    R8,R4
         BNP   CALLNXT                 NO, REQUEST NEW RECORD
BLANKS   MVI   0(R4),C' '              BLANK IN BUFFER
         LA    R4,1(,R4)               INCR R
         BCT   R8,BLANKS
CALLNXT  L     R15,IORLST(,R12)
         L     R15,NX(,R15)
         BALR  R14,R15                 GET NEXT RECORD
         L     R4,R
         LA    R8,22(,R4)
         C     R8,RE
         BH    ORLERR                  TOO SHORT RECORD LENGTH
         OI    DSF,DS3
NONEXREC LA    R9,16
         LTDR  FPR0,FPR0               NUMBER IS ZERO ?
         BNZ   NOT0                    NO, BRANCH
         MVI   0(R4),C' '              NUMBER IS ZERO
         MVC   1(21,R4),0(R4)
         MVI   1(R4),C'0'
         B     TERMIN
*
NOT0     MVI   0(R4),C'+'              ZONE IS INSERTED
         BP    EXPLOOP
         MVI   0(R4),C'-'
         LCDR  FPR0,FPR0
EXPLOOP  STD   FPR0,CHAR
         SR    R3,R3
         IC    R3,CHAR
         MVI   SE,0
         S     R3,KF78
         BP    EXPLOAA
         BZ    EXP0                    EXPONENT = 78
         MVI   SE,X'80'
         LCR   R3,R3
EXPLOAA  MH    R3,LOG2
         AH    R3,ROUND
         SRL   R3,14
         C     R3,KF78
         BNH   EXPLOBB
         L     R3,KF78                 EXPONENT = 78
EXPLOBB  TM    SE,X'80'
         L     R15,VPTTAB              R15 -> POWER TEN TABLE
         BZ    EXPLOCC
         SR    R9,R3
         B     EXPLODD
*
EXPLOCC  LA    R15,128(,R15)
         AR    R9,R3
EXPLODD  LR    R2,R3
         SR    R3,R3                   CLEAR REGISTER
         SRDA  R2,3
         SLA   R2,3
TESTEXP1 BZ    EXP1LS8
         C     R2,KF72
         BL    EXP1LS8A                EXPONENT NEGATIVE
         MD    FPR0,128(,R15)
         S     R2,KF72
         B     TESTEXP1
*
EXP1LS8A MD    FPR0,56(R2,R15)
EXP1LS8  SRL   R3,26                   EXPONENT MULTIPLIED EIGHT
         LTR   R3,R3
         BZ    EXPLOOP
         MD    FPR0,0(R3,R15)
         B     EXPLOOP
*
EXP0     CD    FPR0,TENP16             NUMBER >= 10**16 ?
         BNL   DIG17                   YES, BRANCH
EXP0AA   MVI   CHAR,0
         LM    R2,R3,CHAR
         D     R2,TENP9I
*
*        TRANSFORM NUMBER TO DECIMAL FORM
*        EDIT OUTPUT NUMBER IN I/O BUFFER
*
         CVD   R3,BUFF                 QUOTE CONVERTED
         UNPK  1(9,R4),BUFF+3(5)
         OI    9(R4),X'F0'
         CVD   R2,BUFF
         UNPK  10(9,R4),BUFF+3(5)
         OI    18(R4),X'F0'
         CLI   2(R4),C'0'              LEADING ZERO ?
         BNE   TRANSAA
         BCTR  R9,0
         MVC   2(16,R4),3(R4)
TRANSAA  MVC   1(1,R4),2(R4)
         MVI   2(R4),C'.'              DECIMAL POINT INSERTED
         MVI   18(R4),C''''            APOSTROPHE INSERTED
DECEXP   CVD   R9,BUFF
         UNPK  19(3,R4),BUFF+6(2)
         LTR   R9,R9
         BNM   DECEXPAA
         MVI   19(R4),C'-'             EXPONENT SIGN IS NEGATIVE
         B     DECEXPBB
*
DECEXPAA MVI   19(R4),C'+'
DECEXPBB OI    21(R4),X'F0'            ZONE INSERTED EXPONENT
*
*        TERMINATION ROUTINE INSERT BLANKS
*        IF RECORD END CALL NEXTREC
*
TERMIN   LA    R4,22(,R4)
         SR    R8,R8
         IC    R8,K
TERMINAA C     R4,RE
         BE    RECEND
         MVI   0(R4),C' '
         LA    R4,1(,R4)
         BCT   R8,TERMINAA
         C     R4,RE
         BE    RECEND
         ST    R4,R
TERMINBB L     R13,SAVEAREA+4
*
         RETURN (14,12)
*
RECEND   L     R15,IORLST(,R12)
         L     R15,NX(,R15)
         BALR  R14,R15
         B     TERMINBB
*
*        NUMBER >= 10**16
*
DIG17    AW    FPR0,FIVE
         STD   FPR0,CHAR
         CD    FPR0,TWOP56B
         BL    EXP0AA
         MVC   1(18,R4),TWOP56         NUMBER > 16**14
         B     DECEXP
*
ORLERR   LR    R13,R12
         B     FSAERR+38*4(R12)
*
VPTTAB   DC    V(IHIPTTAB)
*
ACNVIRD  EQU   X'120'
*
*        CONSTANTS AND STORAGE
*
SAVEAREA DC    18F'0'
*
KF72     DC    F'72'
KF78     DC    F'78'
LOG2     DC    H'19728'
ROUND    DC    H'8192'
TENP9I   DC    F'1000000000'
BUFF     DC    D'0'
CHAR     DC    D'0'
FIVE     DC    X'4E00000000000005'
TWOP56B  DC    X'4F10000000000000'
TENP16   DC    DE16'1'
SE       DC    X'00'
TWOP56   DC    C'7.205759403792794'''
*
         LTORG
*
         DSTABLE DSECT=YES
*
FAS      DSECT
*
         COPY  FSAREA
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHILSC   0201-12230-12230-1200-00151-00151-00000-LEVEL
LSC      TITLE 'IHILSCSN, SINE/COSINE, LONG PRECISION, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        1. DIVIDE MAGNITUDE OF ARG BY PI/4 TO FIND OCTANT AND
*           FRACTION
*        2. IF COSINE ADD 2 TO OCTANT NUMBER
*           IF SINE FOR NEGATIVE ARG, ADD 4 TO OCTANT NUMBER
*        3. COMPUTE SINE OR COSINE OF FRACTION*PI/4 DEPENDING ON
*           THE OCTANT
*        4. IF OCTANT NUMBER IS FOR LOWER PLANE MAKE SIGN MINUS
*
*        ENTRY POINTS -
*        IHILSCC - COSINE FUNCTION, LONG
*        IHILSCS - SINE FUNCTION, LONG
*                  LA   R1,PARMLIST
*                  BALR R14,R15
*                  DATA PASSED BY NAME
*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0
*
*        EXIT - ERROR -
*        IF ABS(ARG) ¬< PI*2**50 GOTO ERROR ROUTINE VIA
*                                B    FSAERR+27*4(R13)
*
*        TABLES/WORKAREAS - N/A
*
IHILSCSN CSECT
*
         ENTRY IHILSCC
         ENTRY IHILSCS
*
FPR0     EQU   0                       RESULT REGISTER
FPR2     EQU   2                       SCRATCH REGISTERS
FPR4     EQU   4
*
IHILSCC  SAVE  (14,12),,'IHILSCC  LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHILSCC,R15
         LA    R10,COMMON
         DROP  R15
         USING COMMON,R10
         LA    R0,2                    OCTANT CRANK OF 2 TO R0
         L     R1,0(,R1)               R1 -> ARGUMENT ADDR
         B     COMMON
*
         DROP  R10
*
IHILSCS  SAVE  (14,12),,'IHILSCS  LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHILSCS,R15
         LA    R10,COMMON
         DROP  R15
         USING COMMON,R10
         SR    R0,R0
         L     R1,0(,R1)               R1 -> ARGUMENT
         TM    0(R1),X'80'             IF ARG IS +, CRANK OF 0 TO R0
         BZ    COMMON                  IF ARG IS -, CRANK OF 4 TO R0
         LA    R0,4
COMMON   LD    FPR0,0(,R1)             PICK UP THE ARGUMENT
         LPER  FPR0,FPR0               FORCE SIGN OF ARG TO +
         CE    FPR0,MAX                /X/ >= PI*2**50 ?
         BNL   ERROR                   YES, ERROR
         DD    FPR0,PIOV4              DIV BY PI/4, SEPARATE INTEGER
         LDR   FPR2,FPR0               PART AND FRACT PART OF QUOTIENT
         AW    FPR2,SCALER             FORCE CHARACTERISTIC X'4E'
         STD   FPR2,ARG                INTEGER PART UNNORMAL = OCTANT
         SDR   FPR2,FPR2
         AD    FPR2,ARG                INTEGER PART NORMALIZED
         SDR   FPR0,FPR2               FRACTION PART TO FPR0
         AL    R0,ARG+4                ADJUST OCTANT NUMBER WITH CRANK
         ST    R0,OCTNT                SAVE IT
         TM    OCTNT+3,X'01'           IF ODD OCTANT, TAKE COMPLEMENT
         BZ    EVEN                    OF FRACT TO OBTAIN MODIFIED ARG
         SD    FPR0,HALF
         SD    FPR0,HALF               SUBTRACT 1 IN 2 STEPS
EVEN     LPDR  FPR4,FPR0
         SR    R1,R1                   R1 = 0 FOR COSINE POLYNOMIAL
         TM    OCTNT+3,X'03'           THIS IS FOR OCTANT 2,3,6, OR 7
         BM    LABAA                   IF OCTANT 1,4,5, OR 8, USE SINE
         LA    R1,8                    POLYNOMIAL.   R1 = 8
LABAA    MDR   FPR0,FPR0               CALC SIN OR COS OF MODIFIED ARG
         LDR   FPR2,FPR0               USING PROPER CHEBYSHEV
         MD    FPR0,C7(R1)             INTERPOLATION POLYNOMIAL
         AD    FPR0,C6(R1)
         MDR   FPR0,FPR2              SIN(X)/X POLYN OF DEGREE 6 IN XSQ
         AD    FPR0,C5(R1)            COS(X) POLYN OF DEGREE 7 IN XSQ
         MDR   FPR0,FPR2
         AD    FPR0,C4(R1)
         MDR   FPR0,FPR2
         AD    FPR0,C3(R1)
         MDR   FPR0,FPR2
         AD    FPR0,C2(R1)
         MDR   FPR0,FPR2
         AD    FPR0,C1(R1)
         LTR   R1,R1
         BZ    COSF
         MDR   FPR0,FPR4               COMPLETE SIN POLYNOMIAL BY
         B     SIGN                    MULTIPLYING BY X
*
COSF     MDR   FPR0,FPR2               COMPLETE COS POLYNOMIAL
         AD    FPR0,HALF               (ONE MORE DEGREE)
         AD    FPR0,HALF               ADD 1 IN 2 STEPS
SIGN     TM    OCTNT+3,X'04'           IF MODIFIED OCTANT IS IN
         BZ    SIGNAA                  LOWER PLANE, SIGN IS NEGATIVE
         LNER  FPR0,FPR0
*
SIGNAA   RETURN (14,12)                RESTORE CALLERS REGS AND RETURN
*
ERROR    B     FSAERR+27*4(R13)        PARAMETER ¬< PI*2**50
*
FSAERR   EQU   X'1CC'
*
ARG      DC    D'0'
*
SCALER   DC    X'4E00000000000000'
*
C7       DC    X'B66C992E84B6AA37'
         DC    X'3778FCE0E5AD1685'     S6
C6       DC    X'387E731045017594'
         DC    X'B978C01C6BEF8CB3'     S5
C5       DC    X'BA69B47B1E41AEF6'
         DC    X'3B541E0BF684B527'     S4
C4       DC    X'3C3C3EA0D06ABC29'
         DC    X'BD265A599C5CB632'     S3
C3       DC    X'BE155D3C7E3C90F8'
         DC    X'3EA335E33BAC3FBD'     S2
C2       DC    X'3F40F07C206D6AB1'
         DC    X'C014ABBCE625BE41'     S1
C1       DC    X'C04EF4F326F91777'     LAST DGT REDUCED BY 2
PIOV4    DC    X'40C90FDAA22168C2'     S0
HALF     DC    X'4080000000000000'     1/2 = C0/2
*
MAX      DC    X'4DC90FDA'
OCTNT    DC    F'0'
*
*        REGSITER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHILSQ   0201-12230-12230-1200-00097-00097-00000-LEVEL
QRT      TITLE 'IHILSQRT, SQUARE ROOT, LONG PRECISION, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        WRITE X = M*16**(2P-Q), M MANTISSA, Q=0 OR 1
*        THEN SQRT(X) = SQRT(M)*(4**-Q)*(16**P)
*
*        ENTRY POINT -
*        IHILSQ - SQRT FUNCTION, LONG
*                 LA   R1,PARMLIST
*                 BALR R14,R15
*                 DATA PASSED BY NAME
*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXIT - NORMAL -
*        RETURN VIA R14, RESULT IN FPR0
*
*        EXIT - ERROR -
*        IF ARGUMENT NEGATIVE GOTO ERROR ROUTINE VIA
*        B   FSAERR+23*4(R13)
*
*        TABLES/WORKAREAS - N/A
*
IHILSQRT CSECT
*
         ENTRY IHILSQ
*
FPR0     EQU   0                       RESULT REGISTER
FPR2     EQU   2                       SCRATCH REGISTERS
FPR4     EQU   4
*
IHILSQ   SAVE  (14,12),,'IHILSQRT LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHILSQRT,R15
         L     R1,0(,R1)
         LD    FPR0,0(,R1)             OBTAIN ARGUMENT
         LTDR  FPR4,FPR0               ARG = 0 ?
         BZ    FIN                     YES, ANS = 0, RETURN
         BM    ERROR                   NEGATIVE ARG, ERROR
         STE   FPR0,BUFF               CONSTRUCT Y = M*16**P AS FOLLOWS
         SR    R0,R0
         IC    R0,BUFF                 P+64 = INT PART OF (CHAR+65)/2
         AH    R0,BIAS
         SRDL  R0,1                    P+64 IN R0, R1 IS - IF EVEN CHAR
         STC   R0,BUFF                 Y IS READY IN BUFF
         STC   R0,B                    CONSTRUCT (2/9)*16**P IN B
         LE    FPR0,BUFF               COMPUTE ((2/9+(8/9)*M)*16**P
         ME    FPR0,A
         AE    FPR0,B
         LTR   R1,R1
         BM    OK                      EVEN CHAR, 1ST APPROX IS READY
         HER   FPR0,FPR0               ODD CHAR, DIVIDE BY 4 TO OBTAIN
         HER   FPR0,FPR0               1ST APPROXIMATION
OK       LER   FPR2,FPR4               NEWTON RAPHSON ITERATIONS
         DER   FPR2,FPR0               Y(N+1) = (Y(N)+ARG/Y(N))/2
         AER   FPR0,FPR2               2 PASSES IN SHORT FORM
         HER   FPR0,FPR0
         LER   FPR2,FPR4
         DER   FPR2,FPR0
         AER   FPR0,FPR2
         HER   FPR0,FPR0
         LDR   FPR2,FPR4               2 PASSES IN LONG FORM
         DDR   FPR2,FPR0
         HDR   FPR2,FPR2
         HDR   FPR0,FPR0
         ADR   FPR0,FPR2
         DDR   FPR4,FPR0
         SWR   FPR4,FPR0
         HDR   FPR4,FPR4
         ADR   FPR0,FPR4
*
FIN      RETURN (14,12)                RESTORE REGS AND RETURN
*
ERROR    B     FSAERR+23*4(R13)        NEGATIVE PARAMETER
*
FSAERR   EQU   X'1CC'
*
BUFF     DC    F'0'
A        DC    X'40E38E39'
B        DC    X'4038E38E'
*
BIAS     DC    H'65'
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIOAR   0201-12230-12230-1200-00096-00096-00000-LEVEL
AOR      TITLE 'IHIOARRY, OUTARRAY REAL, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        TRANSFER NUMBERS FROM ARRAY INDICATED BY SECOND ACTUAL
*        PARAMETER TO OUTPUT BUFFER BY CALLING OUTREAL LONG OR
*        SHORT REPEATEDLY
*
*        ENTRY POINT -
*        IHIOARRY - FROM GENERATED OBJECT MODULE
*                   LA   R1,PARMLIST
*                   BALR R14,R15
*                   DATA PASSED BY NAME
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES -
*        IHIIOR - EVALUATE DATA SET NUMBER
*        IHISOR - OUTREAL SHORT
*        IHILOR - OUTREAL LONG
*
*        EXIT - NORMAL - RELOAD REGISTERS AND RETURN VIA R14
*
*        EXIT - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
IHIOARRY CSECT
*
         SAVE  (14,12),,'IHIOARRY LEVEL 2.1 &SYSDATE &SYSTIME'
         LR    R8,R15
         USING IHIOARRY,R8
         LR    R12,R13                  R12 -> FSA
         LA    R13,ASAVE(,R12)          R13 -> SECOND FSA SAVEAREA
         SR    R3,R3
*
*        EVALUATE DATASET NUMBER
*
         L     R15,VIOREV              R15 -> IHIIOREV ROUTINE
         BALR  R14,R15                 CALL IHIIOREV
*
*        EVALUATE SOURCE ADDR
*
         ICM   R1,B'1111',4(R1)
         BNM   OTARY1                  >= 0, BRANCH
         O     R3,=X'80000000'
         N     R1,=X'00FFFFFF'
OTARY1   L     R2,12(,R1)              R2 -> DESTEND+1
         L     R7,8(,R1)               R7 -> STARTDEST
         AR    R7,R3
         AR    R2,R3
*
*        CALL ROUTINE OUREAL LONG OR SHORT
*
         LA    R4,4                    SETUP FOR SHORT
         TM    OPTSW(R12),X'20'        LONG OR SHORT PRECISION ?
         BO    OTARY2                  SHORT, BRANCH
         LA    R4,8                    LONG
OTARY2   L     R15,ARROUTR(R4)
         BALR  R14,R15
         TM    OPTSW(R12),X'20'        LONG OR SHORT
         BO    OTARY3                  SHORT
         LTR   R7,R7                   LONG
         BP    OTARY3
         SH    R7,=H'4'
OTARY3   AR    R7,R4                   INCREASE DEST ADDR
         CR    R7,R2
         BL    OTARY2                  DESTEND NOT REACHED
         LR    R13,R12
*
         RETURN (14,12)
*
*        EXTERNAL ADDRS
*
VIOREV   DC    V(IHIIOREV)
*
ARROUTR  DC    A(0)                    +00
         DC    V(IHISORAR)             +04
         DC    V(IHILORAR)             +08
*
         LTORG
*
FAS      DSECT
*
         COPY  FSAREA
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIOBA   0201-12230-12230-1200-00073-00073-00000-LEVEL
AOB      TITLE 'IHIOBARR, OUTBARRAY, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        TRANSFER BOOLEAN VALUES FROM ARRAY DEFINED BY SECOND
*        ACTUAL PARAMETER TO AN OUTPUT BUFFER BY CALLING
*        OUTBOOLEAN REPEATEDLY
*
*        ENTRY POINTS -
*        IHIOBARR - FROM GENERATED OBJECT MODULE
*                   LA   R1,PARMLIST
*                   BALR R14,R15
*                   DATA PASSED BY NAME
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES -
*        IHIIOR - EVALUATE DATASET NUMBER
*
*        IHIOBO - INBOOLEAN
*
*        EXIT - NORMAL - RELOAD REGISTERS AND RETURN VIA R14
*
*        EXIT - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
IHIOBARR CSECT
*
         SAVE  (14,12),,'IHIOBARR LEVEL 2.1 &SYSDATE &SYSTIME'
         LR    R7,R15
         USING IHIOBARR,R7
         LR    R12,R13                 R12 -> FSA
         LA    R13,ASAVE(,R12)         R13 -> SECOND FSA SAVEAREA
*
*        EVALUATE DATASET NUMBER
*
         L     R15,VIORREC             R15 -> IHIIOREC ROUTINE
         BALR  R14,R15                 CALL IHIIOREC
         L     R1,4(,R1)
         L     R4,12(,R1)              R4 -> SOURCEEND+1
         L     R2,8(,R1)               R2 -> SOURCE
*
*        CALL ROUTINE OUTBOOLEAN
*
OUTBY1   L     R15,VOBOAR              R15 -> IHIOBOAR ROUTINE
         BALR  R14,R15                 CALL IHIOBOAR
         LA    R2,1(,R2)               INCREASE SOURCE ADDR BY ONE
         CR    R2,R4
         BL    OUTBY1                  LOOP, MORE VALUE TO WRITE
         LR    R13,R12
*
         RETURN (14,12)                RESTORE REGS AND RETURN
*
*        EXTERNAL ADDRS
*
VIORREC  DC    V(IHIIOREV)
VOBOAR   DC    V(IHIOBOAR)
*
FAS      DSECT
*
         COPY  FSAREA
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIOBO   0201-12230-12230-1329-00183-00183-00000-LEVEL
BOO      TITLE 'IHIOBOOL, OUTBOOLEAN, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        TRANSFER BOOLEAN VALUE FROM SECOND PARAMETER TO AN
*        OUTPUT BUFFER WITH CHARACTER STRING 'TRUE' OR 'FALSE'
*
*        ENTRY POINTS -
*        IHIOBOOL - FROM GENERATED OBJECT MODULE
*                   LA   R1,PARMLIST
*                   BALR R14,R15
*                   DATA PASSED BY NAME
*        IHIOBOAR - FROM ARRAY MODULE IHIOBA
*                   LA   R2,DATA
*                   BALR R14,R15
*        DATA PASSED BY NAME
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES -
*        IHIIOR - EVALUATE DATASET NUMBER
*               - OPEN DATASET
*               - CHANGE TO NEXT RECORD
*
*        EXIT - NORMAL - RELOAD REGISTERS AND RETURN VIA R14
*
*        EXIT - ERROR - TOO LONG RECORD - NO 38
*                       BRANCH TO IHIFSA
*                       L    R13,IHIFSA
*                       B    FSAERR+XX*4(R13) XX ERROR NO
*
*        TABLES/WORK AREAS - N/A
*
IHIOBOOL CSECT
*
         ENTRY IHIOBOAR
*
*        DISPLACEMENTS IN ADRLST IN IHIFSA
*
CI       EQU   0             DISPLACEMENT FOR - IHIIORCI
CL       EQU   4                                IHIIORCL
EV       EQU   8                                IHIIOREV
NX       EQU   12                               IHIIORNX
OP       EQU   16                               IHIIOROP
OQ       EQU   20                               IHIIOROQ
*
         USING DSTABLE,R5              R5 -> DSTABLE ENTRY
*
         SAVE  (14,12),,'IHIOBOOL LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHIOBOOL,R15
         LR    R12,R13                 CHAIN SAVE AREAS
         LA    R13,SAVEAREA
         ST    R12,4(,R13)
         ST    R13,8(,R12)
         LA    R7,COMMON
         DROP  R15
         USING COMMON,R7
*
*        EVALUATE DATASET NUMBER
*
         L     R15,IORLST(,R12)
         L     R15,EV(,R15)
         BALR  R14,R15
         L     R1,4(,R1)
         ST    R1,ASOURCE
         B     COMMON
*
         DROP  R7
*
IHIOBOAR SAVE  (14,12),,'IHIOBOAR LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHIOBOAR,R15
         LR    R7,R13                  CHAIN SAVE AREAS
         LA    R13,SAVEAREA
         ST    R7,4(,R13)
         ST    R13,8(,R7)
         LA    R7,COMMON
         DROP  R15
         USING COMMON,R7
*
COMMON   OI    DSF,DS2+DS3             DS2, DS3 SET TO ONE
         NI    DSF,255-DS7             DS7 IS SET TO 0
         TM    DSF,DS0                 DATASET OPEN ?
         BO    OTBOOL1                 YES, BRANCH
         OI    DSF,DS6                 NO, OPEN DATASET
         L     R15,IORLST(,R12)
         L     R15,OP(,R15)
         BALR  R14,R15                 CALL DATASET OPEN ROUTINE
OTBOOL1  L     R4,RE
         L     R3,R
         LA    R3,7(,R3)
         CR    R4,R3
         BNL   OTBOOL2                 SEVEN CHARACTER FREE IN RECORD
*
*        NOT ROOM ENOUGH TO STORE BOOLEAN VALUE IN RECORD
*        FILL CURRENT RECORD BY BLANKS
*        CALL FOR ROUTINE NEXTREC
*
         L     R3,R
         L     R4,RE
         SR    R4,R3
         BZ    OTBOOL7
         MVI   0(R3),C' '
         BCTR  R4,0
         BCTR  R4,0
         LTR   R4,R4
         BM    OTBOOL7
         EX    R4,BLANKS
OTBOOL7  L     R15,IORLST(,R12)
         L     R15,NX(,R15)
         BALR  R14,R15
         L     R3,R
         LA    R3,7(,R3)
         C     R3,RE
         BH    OERROR                  TOO SHORT RECORD LENGTH
         OI    DSF,DS3
OTBOOL2  L     R2,ASOURCE
         SR    R9,R9
         IC    R9,0(,R2)
         L     R3,R
         LTR   R9,R9
         BZ    OTBOOL3
         MVC   0(L'TRUE,R3),TRUE       BOOLEAN VALUE TRUE OR FALSE
         B     OTBOOL3A                TO RECORD WHICH ONE DEPENDING
*
OTBOOL3  MVC   0(L'FALSE,R3),FALSE     ON VALUE OF SOURCE
OTBOOL3A LA    R3,7(,R3)
         ST    R3,R                    UPDATE CHARACTER POINTER
*
*        ROUTINE BLADEL
*
         SR    R8,R8
         IC    R8,K                    NUMBER OF DELIMITERS
OTBOOL4  C     R3,RE
         BE    OTBOOL5                 RECORD END REACHED
         MVI   0(R3),C' '              FILL WITH BLANK
         LA    R3,1(,R3)
         BCT   R8,OTBOOL4
         ST    R3,R                    UPDATE CHARACTER POINTER
         B     OTBOOL6
*
*        CALL NEXTREC
*
OTBOOL5  L     R15,IORLST(,R12)
         L     R15,NX(,R15)
         BALR  R14,R15
OTBOOL6  L     R13,SAVEAREA+4
*
         RETURN (14,12)                RESTORE REGS AND RETURN
*
OERROR   LR    R13,R12
         B     FSAERR+38*4(R12)
*
BLANKS   MVC   1(0,R3),0(R3)           EXE INSTRUCTION
*
ASOURCE  DC    A(0)
*
TRUE     DC    C'''TRUE'' '
FALSE    DC    C'''FALSE'''
*
SAVEAREA DC    18F'0'
*
         LTORG
*
*        DSTABLE MAPPING DSECT
*
         DSTABLE DSECT=YES
*
FAS      DSECT
*
         COPY  FSAREA
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIOIN   0201-12230-12230-1200-00216-00216-00000-LEVEL
NTE      TITLE 'IHIOINTE, OUT INTEGER, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        TRANSFER NUMBER FROM INTEGER INDICATED BY SECOND ACTUAL
*        PARAMETER TO OUTPUT BUFFER IN ZONED DECIMAL FORM
*
*        ENTRY POINTS -
*        IHIOINTG - FROM GENERATED OBJECT MODULE
*                   LA   R1,PARMLIST
*                   BALR R14,R15
*                   DATA PASSED BY NAME
*        IHIOINAR - FROM ARRAY MODULE IHIOTA
*                   LA   R7,DATA
*                   BALR R14,R15
*                   DATA PASSED BY NAME
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES -
*
*        IHIIOR - EVALUATE DATASET NUMBER
*               - OPEN DATASET
*               - CHANGE TO NEXT OUTPUT RECORD
*        CNVRI  - CONVERT REAL TO INTEGER
*
*        EXIT - NORMAL - RELOAD REGISTERS AND RETURN VIA R14
*             - ERROR  - TOO LONG RECORD     NO 38
*                        BRANCH TO IHIFSA
*                        L   R13,IHIFSA
*                        B   FSAERR+XX*4(13)   XX ERROR NO
*
*        TABLES/WORK AREAS - N/A
*
*        ATTRIBUTES - SERIALLY REUSABLE
*
*        NOTES -
*        LINKING TO IHIOINAR DEVIATES FROM STANDARD CHARACTER
*        DEPENDENCE
*
IHIOINTE CSECT
*
         ENTRY IHIOINTG
         ENTRY IHIOINAR
*
FPR0     EQU   0                       FPRO
*
         USING DSTABLE,R5
*
*        DISPLACEMENTS IN ADRLST IN IHIFSA
*
CI       EQU   0                       IHIIORCI
CL       EQU   4                       IHIIORCL
EV       EQU   8                       IHIIOREV
NX       EQU   12                      IHIIORNX
OP       EQU   16                      IHIIOROP
OQ       EQU   20                      IHIIOROQ
*
IHIOINAR SAVE  (14,12),,'IHIOINAR LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHIOINAR,R15
         LR    R10,R13                 CHAIN SAVE AREAS
         LA    R13,SAVEAREA
         ST    R10,4(,R13)
         ST    R13,8(,R10)
         LA    R10,COMMON
         DROP  R15
         USING COMMON,R10
         B     SOUINTA
*
         DROP  R10
*
IHIOINTG SAVE  (14,12),,'IHIOINTG LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHIOINTG,R15
         LR    R12,R13                 R12 -> FSA  TO FSA REG
         LA    R13,SAVEAREA
         ST    R12,4(,R13)
         ST    R13,8(,R12)
         LA    R10,COMMON
         DROP  R15
         USING COMMON,R10
*
*        EVALUATE DATASET NUMBER (EVDSN)
*
COMMON   L     R15,IORLST(,R12)
         L     R15,EV(,R15)
         BALR  R14,R15
*
*        EVALUATE ADDR OF SOURCE
*        TEST IF SOURCE NUMBER IS REAL
*
SOUINT   L     R7,4(,R1)               ADDR OF SOURCE
SOUINTA  OI    DSF,DS2+DS3             DS2, DS3 = 1
         NI    DSF,255-DS7             TURN OFF EOF DS7
         LTR   R7,R7
         BP    INT1
*
*        CALL CONVERSION ROUTINE
*
         LE    FPR0,0(,R7)
         TM    OPTSW(R12),X'20'        LONG OR SHORT PRECISION ?
         BO    CONVA                   SHORT PRECISION STATED
         LD    FPR0,0(,R7)             LONG PRECISION STATED
CONVA    L     R15,IORLST(,R12)
         L     R15,CI(,R15)
         BALR  R14,R15
         B     DSTEST
*
INT1     L     R0,0(,R7)               NUMBER IN R0
*
*        DATASET OPEN ?
*
DSTEST   TM    DSF,DS0
         BO    NOCLO1                  DCB IS OPEN
         OI    DSF,DS6                 DS6 = 1
         L     R15,IORLST(,R12)
         L     R15,OP(,R15)
         BALR  R14,R15                 OPEN DATASET
*
*        RECORD ACCEPT 11 DIGITS ?
*        IF NOT FILL RECORD WITH BLANKS AND CALL NEXTREC
*
NOCLO1   L     R2,R                    CHARACTER POINTER
         LA    R3,11(,R2)
         C     R3,RE
         BNH   NONR1                   BUFFER CAN ACCEPT 11 DIGITS
         L     R9,RE
         SR    R9,R2
         BNP   GETREC
BLANKS   MVI   0(R2),C' '              BLANK IN BUFFER
         LA    R2,1(,R2)               INCREASE R
         BCT   R9,BLANKS
GETREC   L     R15,IORLST(,R12)
         L     R15,NX(,R15)
         BALR  R14,R15
         L     R2,R
         LA    R3,11(,R2)
         C     R3,RE
         BH    OINERR                  TOO SHORT RECORD LENGTH
         OI    DSF,DS3
*
*        TEST SOURCE NUMBER AND CONVERT TO DECIMAL
*
NONR1    LTR   R0,R0
         BZ    OUTINT0                 NUMBER IS ZERO
         CVD   R0,BUFF
         UNPK  1(10,R2),BUFF+2(6)
         OI    10(R2),X'F0'            ZONE INSERTED
*
LEAD0    CLI   1(R2),C'0'
         BNE   TERMIN0
         MVI   0(R2),C' '              LEADING ZERO IS BLANKED
         LA    R2,1(,R2)
         B     LEAD0
*
TERMIN0  LTR   R0,R0
         BP    POSITIVE
         MVI   0(R2),C'-'              - SIGN INSERTED
         B     TERMIN1
*
POSITIVE MVI   0(R2),C'+'              + SIGN INSERTED
*
TERMIN1  SR    R4,R4
         IC    R4,K                    VALUE OF K IN REGISTER
TERMIN1A C     R3,RE
         BE    RECEND                  RECORD END IS REACHED
         MVI   0(R3),C' '              FILL WITH BLANKS
         LA    R3,1(,R3)
         BCT   R4,TERMIN1A
         C     R3,RE
         BE    RECEND
         ST    R3,R
TERMIN1B L     R13,SAVEAREA+4
*
         RETURN (14,12)                RESTORE REGS AND RETURN
*
*        OUTINTEGER NUMBER IS 0
*
OUTINT0  MVI   0(R2),C' '
         MVC   1(9,R2),0(R2)           BLANKS IN BUFFER
         MVI   10(R2),C'0'             0 IN BUFFER
         B     TERMIN1
*
RECEND   L     R15,IORLST(,R12)
         L     R15,NX(,R15)
         BALR  R14,R15
         B     TERMIN1B
*
*        RECORD LENGTH < 11
*
OINERR   LR    R13,R12
         B     FSAERR+38*4(R12)
*
BUFF     DC    D'0'
*
SAVEAREA DC    18F'0'
*
         LTORG
*
         DSTABLE DSECT=YES
*
FSAAREA  DSECT
*
         COPY  FSAREA
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIOST   0201-12230-12230-1200-00127-00127-00000-LEVEL
OST  TITLE 'IHIOSTRG, LIBRARY I/O SERVICE RTN, OUTSTRING, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        TRANSFER STRING DEFINED BY SECOND ACTUAL PARAMETER
*        TO AN OUTPUT BUFFER
*
*        ENTRY POINT -
*        IHIOSTRG - FROM GENERATED OBJECT MODULE
*        LA    R1,PARMLIST
*        BALR  R14,R15
*        DATA PASSED BY NAME
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES-
*        IHIIOR - EVALUATE DATASET NUMBER
*               - OPEN DATASET
*               - CHANGE TO NEXT OUTPUT RECORD
*
*        EXIT - NORMAL - RELOAD REGISTERS AND RETURN VIA R14
*             - ERROR  - N/A
*
*        TABLES/WORK AREAS - N/A
*
IHIOSTRG CSECT
*
*        DISPLACEMENTS IN ADRLST IN IHIFSA
*
CI       EQU   0             DISPLACEMENT FOR - IHIIORCI
CL       EQU   4                                IHIIORCL
EV       EQU   8                                IHIIOREV
NX       EQU   12                               IHIIORNX
OP       EQU   16                               IHIIOROP
OQ       EQU   20                               IHIIOROQ
*
         SAVE  (14,12),,'IHIOSTRG LEVEL 2.1 &SYSDATE &SYSTIME'
         LR    R8,R15
         USING IHIOSTRG,R8
         ST    R13,SAVAR+4
         LR    R12,R13
         LA    R13,SAVAR
         USING DSTABLE,R5
*
*        EVALUATE DATASET NUMBER
*
         L     R15,IORLST(R12)
         L     R15,EV(,R15)
         BALR  R14,R15
*
*        STORE SOURCE ADDR
*
         L     R1,4(,R1)
         ST    R1,ASTRING              SAVE STRING ADDR
         OI    DSF,DS2+DS3             DS2,DS3=1 OUTPUT
         NI    DSF,255-DS7             DS7=0 NO END OF DATA
         TM    DSF,DS0                 DATASET OPEN ?
         BO    OUTSTR1                 YES, BRANCH
         OI    DSF,DS6                 NO, DATASET IS NOT OPEN
         L     R15,IORLST(R12)
         L     R15,OP(,R15)
         BALR  R14,R15                 CALL FOR ROUTINE OPEN
OUTSTR1  L     R2,ASTRING              R2 -> STRING
         MVC   STRLTH,0(R2)            MOVE L'STRING
         LH    R4,STRLTH
         BCTR  R4,0
         BCTR  R4,0                    REAL STRING LENGTH TO REGISTER
         LTR   R4,R4                   ZERO LENGTH STRING ?
         BZ    OUTSTR3                 YES, BRANCH
         LA    R2,2(,R2)               R2 -> STRING
OUTSTR4  LR    R3,R4
         OI    DSF,DS3
         A     R4,R
         C     R4,RE
         BH    OUTSTR2                 OVERFLOW IN CURRENT RECORD
         BCTR  R3,0
         L     R9,R
         EX    R3,OUTMOV               CONTENT OF STRING TO BUFFER
         LA    R3,1(,R3)
         ST    R4,R
         C     R4,RE
         BNE   OUTSTR3
         L     R15,IORLST(R12)
         L     R15,NX(,R15)
         BALR  R14,R15                 CURRENT RECORD FILLED
OUTSTR3  L     R13,SAVAR+4
*
         RETURN (14,12)                RETURN TO CALLER
*
OUTSTR2  L     R7,RE                   RE-R AVAILIABLE, PLACE IN
         S     R7,R                    CURRENT RECORD
         L     R9,R
         BCTR  R7,0
         EX    R7,OUTMOV
         LA    R7,1(,R7)
         LR    R4,R3
         SR    R4,R7
         AR    R2,R7
         L     R15,IORLST(R12)
         L     R15,NX(,R15)
         BALR  R14,R15
         B     OUTSTR4
*
OUTMOV   MVC   0(1,R9),0(R2)           MOVE STRING
*
SAVAR    DC    18F'0'
ASTRING  DC    A(0)
STRLTH   DC    H'0'
*
         LTORG
*
         DSTABLE  DSECT=YES
*
FAS      DSECT
*
         COPY  FSAREA
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIOSY   0201-12230-12230-1200-00138-00138-00000-LEVEL
OSY   TITLE 'IHIOSYMB, LIBRARY I/O SERVICE RTN, OUTSYMBOL, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        COMPARE NUMBER ASSIGNED TO THIRD ACTUAL PARAMETER WITH
*        AN INTERNAL STRING AND TRANSFER CHARACTER IN
*        CORRESPONDING POSITION TO AN OUTPUT BUFFER
*
*        ENTRY POINT -
*        IHIOSYMB - FROM GENERATED OBJECT MODULE
*        LA   R1,PARMLIST
*        DATA PASSED BY NAME
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES -
*        IHIIOR - EVALUATE DATASET NUMBER
*               - OPEN DATASET
*               - CHANGE TO NEXT OUTPUT RECORD
*
*        EXITS - NORMAL - RELOAD REGISTERS AND RETURN VIA R14
*
*        EXITS - ERROR  - SOURCE DOES NOT MATCH STRING NO 8
*        BRANCH TO FSA    LA  R13,IHIFSA
*                         B   FSAERR+XX*4(13) XX ERROR NO
*
*        TABLES/WORK AREAS - N/A
*
IHIOSYMB CSECT
*
*        R3                            -> SOURCE
*        R4                            -> START OF STRING
*        R8                             = INTEGER NUMBER FROM SOURCE
*        R9                             = L'SOURCE STRING
*        R10                           -> CHARACTER POINTER
*
         USING DSTABLE,R5
*
*        DISPLACEMENTS IN ADRLST IN IHIFSA
*
CI       EQU   0             DISPLACEMENT FOR - IHIIORCI
CL       EQU   4                                IHIIORCL
EV       EQU   8                                IHIIOREV
NX       EQU   12                               IHIIORNX
OP       EQU   16                               IHIIOROP
OQ       EQU   20                               IHIIOROQ
*
         SAVE  (14,12),,'IHIOSYMB LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15
         USING IHIOSYMB,R7
         ST    R13,SAVEAREA+4          SAVE HIGH SAVEAREA ADDR
         LR    R12,R13                 R12 -> FSA
         LA    R13,SAVEAREA
*
*        EVALUATE DATASET NUMBER (EVDSN)
*
         L     R15,IORLST(,R12)
         L     R15,EV(,R15)
         BALR  R14,R15
         L     R4,4(,R1)               R4 -> STRING
*
*        TEST IF DATASET IS OPEN
*
         NI    DSF,255-DS7             DS7 = 0
         OI    DSF,DS2+DS3             DS2, DS3 = 1
         TM    DSF,DS0                 DATASET OPEN ?
         BO    SOURCE0                 YES, BRANCH
         OI    DSF,DS6                 DS6 = 1
         L     R15,IORLST(,R12)
         L     R15,OP(,R15)
         BALR  R14,R15                 OPEN DATASET
SOURCE0  L     R3,8(,R1)               R3 -> SOURCE
         LTR   R3,R3                   CONVERSION REQUIRED ?
         BP    EVSOURCE                NO CONVERSION NEEEDED
         TM    OPTSW(R12),X'20'        YES, LONG OR SHORT PREC ?
         BO    SOURCE1                 SHORT
         LD    0,0(,R3)
         B     SOURCE1A
*
SOURCE1  LE    0,0(,R3)
SOURCE1A L     R15,IORLST(,R12)
         L     R15,CI(,R15)
         BALR  R14,R15                 REQUEST CONVERSION
         LR    R8,R0
         B     EVSOURAA
*
EVSOURCE L     R8,0(,R3)               SOURCE INTEGER LOADED
EVSOURAA LTR   R8,R8
         BM    ERR8                    INTEGER -VE
         L     R10,R                   CHARACTER POINTER
         BP    EVSOURBB                INTEGER +VE
         MVI   0(R10),C' '             INTEGER = ZERO
         B     TERMIN
*
EVSOURBB LH    R9,0(,R4)               LENGTH OF STRING
         LA    R8,1(,R8)               INTEGER INCR BY ONE
         BCTR  R9,0                    LENGTH DECR BY ONE
         CR    R8,R9
         BH    ERR8
         AR    R8,R4
         MVC   0(1,R10),0(R8)
TERMIN   LA    R10,1(,R10)
         C     R10,RE
         BNL   NEXTREC
         ST    R10,R
TERMINA  LR    R13,R12
*
         RETURN (14,12)
*
NEXTREC  L     R15,IORLST(,R12)
         L     R15,NX(,R15)
         BALR  R14,R15
         B     TERMINA
*
ERR8     LR    R13,R12
         B     FSAERR+8*4(R12)         SOURCE DOES NOT MATCH STRING
*
SAVEAREA DC    18F'0'                  MODULE SAVE AREA
*
         LTORG
*
         DSTABLE  DSECT=YES
*
FAS      DSECT
*
         COPY  FSAREA
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIOTA   0201-12230-12230-1200-00088-00088-00000-LEVEL
ARR      TITLE 'IHIOTARR, OUTTARRAY, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        TRANSFER NUMBERS FROM ARRAY INDICATED BY SECOND
*        PARAMETER TO OUTPUT BUFFER BY CALLING OUTINTEGER
*        REPEATEDLY
*
*        ENTRY POINT -
*        IHIOTARR - FROM GENERATED OBJECT MODULE
*                   LA   R1,PARMLIST
*                   BALR R14,R15
*                   DATA PASSED BY NAME
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES -
*        IHIIOR - EVALUATE DATASET NUMBER
*        IHIOIN - OUTINTEGER
*
*        EXIT - NORMAL - RELOAD REGISTERS RETURN VIA R14
*
*        EXIT - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
IHIOTARR CSECT
*
         SAVE  (14,12),,'IHIOTARR LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R8,R15
         USING IHIOTARR,R8
         LR    R12,R13                 R12 -> FSA
         LA    R13,ASAVE(,R13)         R13 -> SECOND FSA SAVEAREA
         SR    R3,R3
*
*        EVALUATE DATASET NUMBER
*
         L     R15,VIOREV
         BALR  R14,R15
*
*        EVALUATE SOURCE ADDR
*
         ICM   R1,B'1111',4(R1)         GET SECOND PARAMETER
         BNM   OUTT1                    >= 0, BRANCH
         O     R3,=X'80000000'          MINUS, INSERT FLAG BYTE
         N     R1,=X'00FFFFFF'
OUTT1    L     R2,12(,R1)               R2 -> DESTEND+1
         L     R7,8(,R1)                R7 -> STARTDEST
         AR    R7,R3
         AR    R2,R3
*
*        CALL ROUTINE OUTINTEGER
*
OUTT2    L     R15,VOINAR
         BALR  R14,R15
         AH    R7,=H'4'
         BP    OUTT2A
         TM    OPTSW(R12),X'20'
         BO    OUTT2A
         LA    R7,4(,R7)                INCR DEST ADDR
OUTT2A   CR    R7,R2
         BL    OUTT2                    DESTEND NOT REACHED
         LR    R13,R12
*
         RETURN (14,12)                 RESTORE REGS AND RETURN
*
*        EXTERNAL ADDRS
*
VIOREV   DC    V(IHIIOREV)
VOINAR   DC    V(IHIOINAR)
*
         LTORG
*
FAS      DSECT
*
         COPY  FSAREA
*
*        REGSITER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHIPTT   0201-12230-12230-1200-00068-00068-00000-LEVEL
TAB      TITLE 'IHIPTTAB, POWER OF TEN TABLE, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        CONSISTS ONLY OF FLOATING POINT CONSTANTS
*
*        ENTRY POINT - IHIPTTAB -
*                      USED TO ADDR DESIRED CONSTANT FROM
*                      INREAL AND OUTREAL LONG
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXITS - NORMAL - N/A
*              - ERROR  - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        CONSTANT IS ADDRESSED IN FOLLOWING WAY
*                 LA R15,IHIPTTAB
*                 MD R1,D2(R2,15)
*        DATA PASSED BY VALUE
*
IHIPTTAB CSECT
*
         DC    D'0'
         DC    DE1'1'
         DC    DE2'1'
         DC    DE3'1'
         DC    DE4'1'
         DC    DE5'1'
         DC    DE6'1'
         DC    DE7'1'
         DC    DE8'1'
         DC    DE16'1'
         DC    DE24'1'
         DC    DE32'1'
         DC    DE40'1'
         DC    DE48'1'
         DC    DE56'1'
         DC    DE64'1'
         DC    DE72'1'
*
         DC    DE-1'1'
         DC    DE-2'1'
         DC    DE-3'1'
         DC    DE-4'1'
         DC    DE-5'1'
         DC    DE-6'1'
         DC    DE-7'1'
         DC    DE-8'1'
         DC    DE-16'1'
         DC    DE-24'1'
         DC    DE-32'1'
         DC    DE-40'1'
         DC    DE-48'1'
         DC    DE-56'1'
         DC    DE-64'1'
         DC    DE-72'1'
*
         END
./ ADD NAME=IHISAT   0201-12230-12230-1200-00108-00108-00000-LEVEL
TAN      TITLE 'IHISATAN, ATAN, SHORT PRECISION, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        1. REDUCE THE CASE TO THE 1ST OCTANT BY USING
*           ATAN(-X)=-ATAN(X), ATAN(1/X)=PI/2-ATAN(X)
*        2. REDUCE FURTHER TO THE CASE /X/ LESS THAN TAN(PI/2) BY
*           ATAN(X)=PI/6+ATAN((X*SQRT3-1)/(X+SQRT3)
*        3. FOR THE BASIC RANGE (X LESS THAN TAN(PI/12)),
*           USE A FRACTIONAL APPROXIMATION
*
*        ENTRY POINT -
*        IHISAT - ATAN FUNCTION, SHORT
*                 LA   R1,PARMLIST
*                 BALR R14,R15
*                 DATA PASSED BY NAME
*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0
*
*        EXIT - ERROR - N/A
*
*        TABLES/WORKAREAS - N/A
*
IHISATAN CSECT
*
         ENTRY IHISAT
*
FPR0     EQU   0
FPR2     EQU   2
FPR4     EQU   4
FPR6     EQU   6
*
*
IHISAT   SAVE  (14,12),,'IHISATAN LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHISATAN,R15
         L     R1,0(,R1)
         LE    FPR0,0(R1)              OBTAIN ARGUMENT
         STE   FPR0,SIGN               SAVE ARG FOR SIGN CONTROL
         LPER  FPR0,FPR0               SET SIGN POSITIVE
         SR    R1,R1                   R1 DENOTES THE SECTION TO WHICH
         CE    FPR0,ONE                ANSWER BELONGS. BREAK POINTS ARE
         BNH   REDUC                 TAN(PI/12), TAN(PI/4), TAN(5PI/12)
         LE    FPR0,ONE                ARG > 1, TAKE INVERSE
         DER   FPR0,FPR0
         LER   FPR0,FPR0
         LA    R1,8                    SET R1 TO 8
REDUC    CE    FPR0,TAN15              ARG > TAN(PI/12) ?
         BNH   OK                      NO, BRANCH
         LER   FPR0,FPR0               REDUCE THE ARG BY USING
         ME    FPR0,RT3M1              ATAN(X) = PI/6+ATAN(Y)
         SE    FPR0,ONE                WHERE Y = (X*SQRT3-1)/(X+SQRT3)
         AER   FPR0,FPR0
         AE    FPR0,RT3                CALC X*SQRT3-1 AS X(SQRT3-1)-1+X
         DER   FPR0,FPR0               TO PROTECT SIGNIFICANT DIGITS
         LA    R1,4(,R1)               INCR R1 BY 4
OK       LER   FPR4,FPR0               NOW MAGNITUDE OF REDUCED ARG IS
         MER   FPR0,FPR0               LESS THAN TAN(PI/12)=0.26795
         LER   FPR0,FPR0
         ME    FPR0,C                  COMPUTE ANGLE BY
         LER   FPR6,FPR0
         AE    FPR0,A                  ATAN(X)/X = D-C*XSQ+B/(XSQ+A)
         LE    FPR0,B
         DER   FPR0,FPR0
         SER   FPR0,FPR6
         AE    FPR0,D
         MER   FPR0,FPR4
         C     R1,KF8                  DEPENDING ON THE SECTION WHICH
         BL    LABAA                   ANSWER BELONGS, ADD OR SUBTRACT
         LCER  FPR0,FPR0               REDUCED ANSWER FROM A BASE ANGLE
LABAA    AE    FPR0,ZERO(R1)
         TM    SIGN,X'80'              SIGN OF ANS SHOULD AGREE WITH
         BZ    LABBB                   SIGN OF ARG
         LCER  FPR0,FPR0
*
LABBB    RETURN (14,12)                RESTORE REGS AND RETURN
*
SIGN     DC    F'0'
ONE      DC    X'41100000'
TAN15    DC    X'40449851'             TAN 15 DEGREES
RT3M1    DC    X'40BB67AF'             SQRT3-1
RT3      DC    X'411BB67B'             SQRT3
KF8      DC    F'8'
A        DC    X'41168A5E'             1.4087812
B        DC    X'408F239C'             0.55913709
C        DC    X'3FD35F49'             0.051604543
D        DC    X'409A6524'             0.60310579
*
ZERO     DC    F'0'                *
         DC    X'40860A92'         |   PI/6
         DC    X'411921FB'         |   PI/2
         DC    X'4110C152'         V   PI/3
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHISEX   0201-12230-12230-1200-00131-00131-00000-LEVEL
XPT      TITLE 'IHISEXPT, EXPONENTIAL, SHORT PRECISION, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        Y = X*LOG2(E) = 4R-S-T
*        WHERE R AND S ARE INTEGERS
*        T FRACTION AND BOTH S AND T ARE NON NEGATIVE
*        THEN E**X = 2**Y = (16**R)(2**-S)N2**-T)
*
*        ENTRY POINT -
*        IHISEX - EXP FUNCTION, SHORT
*                 LA   R1,PARMLIST
*                 BALR R14,R15
*                 DATA PASSED BY NAME
*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0
*
*        EXIT - ERROR - IF ARGUMENT NOT POSITIVE GOTO ERROR
*                       OUTINE VIA
*                       B    FSAERR+25*4(R13)
*
*        TABLES/WORKAREAS - N/A
*
IHISEXPT CSECT
*
         ENTRY IHISEX
*
FPR0     EQU   0                       RESULT REGISTER
*
IHISEX   SAVE  (14,12),,'IHISEXPT LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHISEXPT,R15
         L     R1,0(,R1)
         LE    FPR0,0(,R1)             OBTAIN ARGUMENT
         CE    FPR0,MAX                > MAX ?
         BH    ERROR                   YES, ERROR
         CE    FPR0,MIN                > MIN ?
         BH    OK1                     YES, ACCEPTABLE
         SER   FPR0,FPR0               VERY SMALL, GIVE 0 AS ANSWER
         B     EXIT
*
OK1      L     R1,0(,R1)               PICK UP ARGUMENT AGAIN
         SLDL  R0,8
         N     R0,MASK                 =X'0000007F' CHARACTERISTIC OF X
         CH    R0,SMALL                R0 > 57 ?
         BH    OK2                     YES, BRANCH
         LE    FPR0,ONE                NO, ABS VALUE OF X < 2**-28
*                                      GIVE 1 AS RESULT
         B     EXIT                    THIS AVOIDS SHIFT TROUBLE
*
OK2      SRL   R1,1                    NORMAL CASE MANTISSA OF X IN R1
         SLL   R0,2                    B0 -4*CHARACTERISTIC
         LCR   R2,R0
         M     R0,LOG2E                LOG E BASE 2 IN B1, PROD IN B2
         SRDL  R0,287(R2)              B33  /R/ IN R0, /S+T/ IN R1
         LTER  FPR0,FPR0
         BNP   OK3                     X NOT POSITIVE, BRANCH
         X     R0,ALLF                 X POSITIVE, -R = -R(R'+1) IN R0
         X     R1,ALLF                 S+T = 4-(S'+T') IN R1
OK3      SLL   R0,24
         LR    R2,R0                   SAVE -R IN R2 B7, CHAR MODIFIER
         SLDL  R0,2                    S IN R0 LOW, T IN R1 HIGH
         LR    R3,R0                   SAVE S IN R3, FOR SHIFT COUNT
         SRL   R1,4                    T                    (B3)
         LR    R6,R1                   SAVE T       IN R6   (B3)
         MR    R0,R1                   T*T                  (B7)
         LR    R5,R0
         M     R4,C                    C*T*T        IN R4   (B4)
         A     R0,A
         LR    R5,R0                   A+T*T        IN R5   (B7)
         L     R0,B
         DR    R0,R5                   B/(A+T*T)    IN R1   (B3)
         SR    R1,R6
         SRL   R1,1                    -T+B/(A+T*T) IN R1   (B4)
         A     R1,D
         AR    R1,R4                   C*T*T+D-T+B/(A+T*T)  (B4)
         LR    R4,R6
         SRL   R4,2                    2*T                  (B6)
         DR    R4,R1                   2*T/(C*T*T+D-T+B/(A+T*T))   (B1)
         A     R5,FXONE                2**(-T) NOW READY IN  B1
         SRL   R5,0(R3)                (2**-S)(2**-T) READY (B1)
         A     R5,FUDGE                ROUND AND
         C     R5,FXONE                FLOAT THIS NUMBER
         BL    OK4
         L     R5,ONE
         B     JOIN
*
OK4      SRL   R5,6
         O     R5,FXONE                BASE CHARACTERISTIC
JOIN     SR    R5,R2                   ADJUST CHARACTERISTIC WITH -R
         ST    R5,BUFF
         LE    FPR0,BUFF
*
EXIT     RETURN (14,12)                RESTORE REGS AND RETURN
*
ERROR    L     R13,4(,R13)             RESTORE FSA ADDR
         B     FSAERR+24*4(R13)        PARAM > 174.673
*
FSAERR   EQU   X'1CC'
*
         DC    0F'0'
MAX      DC    X'42AEAC4F'             174.673
MIN      DC    X'C2B437E0'             -180.218
ONE      DC    X'41100000'
MASK     DC    X'0000007F'
LOG2E    DC    X'5C551D95'             LOG E BASE 2    B1
ALLF     DC    X'FFFFFFFF'
A        DC    X'576AE119'             87.4174972      B7
B        DC    X'269F8E6B'             617.972269      B11
C        DC    X'B9059003'             -0.034657359    B-4
D        DC    X'B05CFCE3'             -9.95459578     B4
FXONE    DC    X'40000000'             1. B1  ALSO BASE CHARACTERISTIC
FUDGE    DC    X'00000020'
BUFF     DC    F'0'
SMALL    DC    H'57'
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHISLO   0201-12230-12230-1200-00109-00109-00000-LEVEL
OGM     TITLE 'IHISLOGM, LOGARITHMIC FUNCTION, SHORT PREC, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        WRITE X = M*16**P, M MANTISSA
*        PICK A BASE VALUE A DEPENDING ON SIZE OF M
*        WRITE Z = (M-A)/(M+A)
*        THEN LOG(X) = P*LOG(16) + LOG(A) + LOG((1+Z)/(1-Z))
*
*        ENTRY POINT -
*        IHISLO - LOG FUNCTION, SHORT
*                 LA   R1,PARMLIST
*                 BALR R14,R15
*                 DATA PASSED BY NAME
*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0
*
*        EXIT - ERROR - IF ARGUMENT NOT POSITIVE GOTO ERROR
*                       OUTINE VIA
*                       B    FSAERR+25*4(R13)
*
*        TABLES/WORKAREAS - N/A
*
IHISLOGM CSECT
*
         ENTRY IHISLO
*
FPR0     EQU   0                       RESULT REGISTER
FPR2     EQU   2                       SCRATCH REGISTER
*
IHISLO   SAVE  (14,12),,'IHISLOGM LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHISLOGM,R15
         L     R1,0(,R1)
         ICM   R0,B'1111',0(R1)        OBTAIN ARGUMENT
         BNP   ERROR                   ARG 0 OR NEGATIVE, ERROR
         SRDL  R0,24
         SRL   R1,8
         ST    R1,ARG                  STORE MANTISSA M ALONE
         OI    ARG,X'40'               FLOAT IT
         SLL   R0,2                    4*CHAR IN R0
         STH   R0,IPART+2              SAVE THIS IN FLOAT FORM
         SR    R14,R14                 SET R14 TO O,4 OR 8
         SRL   R1,21                   DEFINE A TO BE 1, 1/4, OR 1/16
*                                      IF M IS IN
         IC    R14,TABLE(R1)         (1/2,1),(2/8,1/2),OR IN (J/16,1/8)
         LE    FPR0,ARG                OBTAIN  Z = (M-A)/(M+A)
         LER   FPR2,FPR0
         SE    FPR0,ONE(R14)
         AE    FPR2,ONE(R14)           POSSIBLY ONLY 21 SIGNIF BPTS
         DER   FPR0,FPR2
         STE   FPR0,ARG                Z READY, STORE IT AT ARG
         MER   FPR0,FPR0               Z**2
         LE    FPR2,C4                 COMPUTE LOG((1+Z)/(1-Z)) USING
         MER   FPR2,FPR0             CHEBYSHEV INTERPOLATION POLYNOMIAL
         AE    FPR2,C3
         MER   FPR2,FPR0
         AE    FPR2,C2
         MER   FPR2,FPR0
         AE    FPR2,C1
         MER   FPR2,FPR0
         LE    FPR0,ARG
         MER   FPR2,FPR0
         AER   FPR2,FPR0
         AER   FPR2,FPR0
         LE    FPR0,IPART              4*(P+64)
         SRL   R14,1                   0,2 OR 4 = - LOG(A) BASE 2
         LA    R14,256(,R14)           4*64-LOG2(A)
         STH   R14,IPART+2             STORE THIS AND FLOAT IT
         SE    FPR0,IPART              4*P+LOG2(A)
         ME    FPR0,LOGE2
         ADR   FPR0,FPR2               NATURAL LOG READY
*
         RETURN (14,12)                RESTORE REGISTERS AND RETURN
*
ERROR    B     FSAERR+25*4(R13)        PARAMETER ZERO OR NEGATIVE
*
FSAERR   EQU   X'1CC'
*
ARG      DC    F'0'
IPART    DC    X'46000000'
*
TABLE    DC    X'0804040400000000'
*
ONE      DC    X'41100000'         *   1   FOLLOWING 3 CONSTANTS MUST
         DC    X'40400000'         |   1/4       BE CONSECUTIVE
         DC    X'40100000'         V   1/16
*
LOGE2    DC    X'40B17219'             LOG(2) BASE E + FUDGE 1
C4       DC    X'4048157B'             0.28157778
C3       DC    X'4047973F'             0.27965158
C2       DC    X'40667685'             0.40024595
C1       DC    X'40AAAA71'             0.66666322
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHISOR   0201-12230-12230-1200-00312-00312-00000-LEVEL
REA      TITLE 'IHISOREA, OUTREAL, SHORT PRECISION, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        CONVERT BINARY ARITHMETIC VALUE FROM SECOND PARAMETER
*        TO ZONED DECIMAL FORM AND TRANSFER TO AN OUTPUT BUFFER
*
*        ENTRY POINTS -
*        IHISOREL - FROM GENERATED OBJECT MODULE
*                   LA   R1,PARMLIST
*                   BALR R14,R15
*                   DATA PASSED BY NAME
*        IHISORAR - FROM ARRAY MODULE IHIOAR
*                   LA   R7,DATA
*                   BALR R14,R15
*                   DATA PASSED BY NAME
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES -
*        IHIIOR - EVALUATE DATA SET NUMBER
*               - OPEN DATA SET
*               - CHANGE TO NEXT OUTPUT RECORD
*        IHIFSA - CNVIR - CONVERT INTEGER TO REAL SHORT
*
*        EXIT - NORMAL - RELOAD REGISTERS AND RETURN VIA R14
*
*        EXIT - ERROR - TOO LONG RECORD NO 38
*                       BRANCH TO IHIFSA
*                       L   R13,IHIFSA
*                       B FSAERR+XX*4(R13) XX ERROR NO
*
*        TABLES - PTTAB - POWER OF TEN TABLE, SHORT PREC
*
*        NOTES -
*        LINKING TO IHISORAR DEVIATES FROM STANDARD
*
IHISOREA CSECT
*
         ENTRY IHISOREL
         ENTRY IHISORAR
*
         USING DSTABLE,R5
*
FPR0     EQU   0                       FLOATING-POINT NUMBER
*
*        R2                            EXPONENT > 8
*        R3                            EXPONENT < 8
*        R4                            CHARACTER POINTER
*        R7                            -> SOURCE
*        R8                            BLANK COUNTER
*        R9                            DECIMAL EXPONENT
*        R10                           -> POWER TEN TABLE
*
*        DISPLACEMENTS IN ADRLST IN IHIFSA
*
CI       EQU   0             DISPLACEMENT FOR - IHIIORCI
CL       EQU   4                                IHIIORCL
EV       EQU   8                                IHIIOREV
NX       EQU   12                               IHIIORNX
OP       EQU   16                               IHIIOROP
OQ       EQU   20                               IHIIOROQ
*
IHISORAR SAVE  (14,12),,'IHISORAR LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHISORAR,R15
         LR    R11,R13                 CHAIN SAVE AREAS
         LA    R13,SAVEAREA
         ST    R11,4(,R13)
         ST    R13,8(,R11)
         LA    R11,COMMON
         DROP  R15
         USING COMMON,R11
         B     SOUFLPA
*
         DROP  R11
*
IHISOREL SAVE  (14,12),,'IHISOREL LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHISOREL,R15
         LR    R12,R13                 R12 -> FSA  STORAGE AREA TO FSA
         LA    R13,SAVEAREA
         ST    R12,4(,R13)
         ST    R13,8(,R12)
         LA    R11,COMMON
         DROP  R15
         USING COMMON,R11
*
*        EVALUATE DATASET NUMBER (EVDSN)
*
COMMON   L     R15,IORLST(,R12)
         L     R15,EV(,R15)
         BALR  R14,R15
SOUFLP   L     R7,4(,R1)               R7 -> SOURCE
SOUFLPA  OI    DSF,DS2+DS3             DS2, DS3 = 1
         NI    DSF,255-DS7             DS7 = 0
         LTR   R7,R7
         BP    REAL1
*
*        CALL CONVERSION ROUTINE (LOADED IN FSA)
*
         STM   R14,R13,8(R13)          SAVE REGS
         LR    R2,R13                  R2 -> SAVEAREA
         L     14,0(,R7)               INTEGER INTO R14
         LA    R7,ACNVIRD(R12)
         LR    R13,R12                 R13 -> FSA
         BALR  R8,R7                   CALL CONVERSION ROUTINE
         LM    R14,R13,8(R2)           RESTORE REGS
         B     REAL1A                  NUMBER IN FPR0 AFTER CONVERSION
*
REAL1    LE    FPR0,0(,R7)             NUMBER IN FPR0
REAL1A   TM    DSF,DS0                 DATASET OPEN ?
         BO    NOCLO                   YES, BRANCH
         OI    DSF,DS6                 DS6 = 1 OPEN FOR OUTPUT
         L     R15,IORLST(,R12)
         L     R15,OP(,R15)
         BALR  R14,R15                 CALL OPEN ROUTINE
NOCLO    L     R4,R                    CHARACTER POINTER
         LA    R8,13(,R4)
         C     R8,RE                   BUFFER CAN ACCEPT 13 DIGITS ?
         BNH   NONEXREC                YES, BRANCH
         L     R8,RE
         SR    R8,R4
         BNP   CALLNXT                 NO, REQUEST NEW RECORD
BLANKS   MVI   0(R4),C' '              BLANK IN BUFFER
         LA    R4,1(,R4)               INCR R
         BCT   R8,BLANKS
CALLNXT  L     R15,IORLST(,R12)
         L     R15,NX(,R15)
         BALR  R14,R15                 GET NEXT RECORD
         L     R4,R
         LA    R8,13(,R4)
         C     R8,RE
         BH    ORSERR                  TOO SHORT RECORD LENGTH
         OI    DSF,DS3
NONEXREC LA    R9,7
         LTER  FPR0,FPR0               NUMBER ZERO ?
         BNZ   NOT0                    NO, BRANCH
         MVI   0(R4),C' '              NUMBER IS ZERO
         MVC   1(12,R4),0(R4)
         MVI   1(R4),C'0'
         B     TERMIN
*
NOT0     MVI   0(R4),C'+'              ZONE IS INSERTED
         BP    EXPLOOP
         MVI   0(R4),C'-'
         LCER  FPR0,FPR0
EXPLOOP  STE   FPR0,CHAR
         SR    R3,R3
         IC    R3,CHAR
         MVI   SE,0
         S     R3,KF70
         BP    EXPLOAA
         BZ    EXP0                    EXPONENT = 78
         MVI   SE,X'80'
         LCR   R3,R3
EXPLOAA  MH    R3,LOG2
         AH    R3,ROUND
         SRL   R3,14
         C     R3,KF70
         BNH   EXPLOBB
         L     R3,KF70                 EXPONENT = 70
EXPLOBB  TM    SE,X'80'
         LA    R10,PTTAB-4             R10 -> PTTAB-4
         BZ    EXPLOCC
         SR    R9,R3
         B     EXPLODD
EXPLOCC  LA    R10,64(,R10)
         AR    R9,R3
EXPLODD  LR    R2,R3
         SR    R3,R3                   CLEAR REGISTER
         SRDA  R2,3
         SLA   R2,3
TESTEXP1 BZ    EXP1LS8
         C     R2,KF72
         BL    EXP1LS8A                EXPONENT NEGATIVE
         ME    FPR0,64(,R10)
         S     R2,KF72
         B     TESTEXP1
*
EXP1LS8A SRL   R2,1
         ME    FPR0,28(R2,R10)
EXP1LS8  SRL   R3,27                   EXPONENT MULTIPLIED FOUR
         LTR   R3,R3
         BZ    EXPLOOP
         ME    FPR0,0(R3,R10)
         B     EXPLOOP
*
EXP0     CE    FPR0,TENP7              NUMBER > 10**7 ?
         BNL   DIG8                    YES, BRANCH
EXP0AA   MVI   CHAR,0
         L     R3,CHAR
         CVD   R3,BUFF                 INTEGER CONVERTED
         UNPK  1(9,R4),BUFF+3(5)
         OI    9(R4),X'F0'
         CLI   2(R4),C'0'              LEADING ZERO ?
         BNE   TRANSAA
         BCTR  R9,0
         MVC   2(7,R4),3(R4)
TRANSAA  MVC   1(1,R4),2(R4)
         MVI   2(R4),C'.'              DECIMAL POINT INSERTED
         MVI   9(R4),C''''             APOSTROPHE INSERTED
DECEXP   CVD   R9,BUFF
         UNPK  10(3,R4),BUFF+6(2)
         LTR   R9,R9
         BNM   DECEXPAA
         MVI   10(R4),C'-'             EXPONENT SIGN IS NEGATIVE
         B     DECEXPBB
*
DECEXPAA MVI   10(R4),C'+'
DECEXPBB OI    12(R4),X'F0'            ZONE INSERTED EXPONENT
TERMIN   LA    R4,13(,R4)
         SR    R8,R8
         IC    R8,K
TERMINAA C     R4,RE
         BE    RECEND
         MVI   0(R4),C' '
         LA    R4,1(,R4)
         BCT   R8,TERMINAA
         C     R4,RE
         BE    RECEND
         ST    R4,R
TERMINBB L     R13,SAVEAREA+4
*
         RETURN (14,12)                RESTORE CALLERS REGS AND RETURN
*
RECEND   L     R15,IORLST(,R12)
         L     R15,NX(,R15)
         BALR  R14,R15
         B     TERMINBB
*
DIG8     AU    FPR0,FIVE
         STE   FPR0,CHAR
         CE    FPR0,TWOP24B
         BL    EXP0AA
         MVC   1(9,R4),TWOP24           NUMBER GE 10**7
         B     DECEXP
*
ORSERR   LR    13,R12
         B     FSAERR+38*4(R12)
*
ACNVIRD  EQU   X'120'
*
*        INTERNAL CONSTANTS AND STORAGE
*
KF72     DC    F'72'
KF70     DC    F'70'
LOG2     DC    H'19728'
ROUND    DC    H'8192'
TENP7    DC    X'46989680'
FIVE     DC    X'46000005'
TWOP24B  DC    X'47100000'
TWOP24   DC    C'1.677722'''
SE       DC    X'00'
CHAR     DC    E'0'
BUFF     DC    D'0'
*
*        POWER OF TEN TABLE SHORT PRECISION
*
PTTAB    DC    EE1'1'
         DC    EE2'1'
         DC    EE3'1'
         DC    EE4'1'
         DC    EE5'1'
         DC    EE6'1'
         DC    EE7'1'
         DC    EE8'1'
         DC    EE16'1'
         DC    EE24'1'
         DC    EE32'1'
         DC    EE40'1'
         DC    EE48'1'
         DC    EE56'1'
         DC    EE64'1'
         DC    EE72'1'
         DC    EE-1'1'
         DC    EE-2'1'
         DC    EE-3'1'
         DC    EE-4'1'
         DC    EE-5'1'
         DC    EE-6'1'
         DC    EE-7'1'
         DC    EE-8'1'
         DC    EE-16'1'
         DC    EE-24'1'
         DC    EE-32'1'
         DC    EE-40'1'
         DC    EE-48'1'
         DC    EE-56'1'
         DC    EE-64'1'
         DC    EE-72'1'
*
SAVEAREA DC    18F'0'
*
         LTORG
*
         DSTABLE DSECT=YES
*
FAS      DSECT
*
         COPY  FSAREA
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHISSC   0201-12230-12230-1200-00137-00137-00000-LEVEL
CSN      TITLE 'IHISSCSN, SINE/COSINE, SHORT PRECISION, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        1. DIVIDE MAGNITUDE OF ARG BY PI/4 TO FIND OCTANT AND
*           FRACTION
*        2. IF COSINE ADD 2 TO OCTANT NUMBER
*           IF SINE FOR NEGATIVE ARG, ADD 4 TO OCTANT NUMBER
*        3. COMPUTE SINE OR COSINE OF FRACTION*PI/4 DEPENDING ON
*           THE OCTANT
*        4. IF OCTANT NUMBER IS FOR LOWER PLANE MAKE SIGN MINUS
*
*        ENTRY POINTS -
*        IHISSCC - COSINE FUNCTION, SHORT
*        IHISSCS - SINE FUNCTION, SHORT
*                  LA   R1,PARMLIST
*                  BALR R14,R15
*                  DATA PASSED BY NAME
*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXIT - NORMAL - RETURN VIA R14, RESULT IN FPR0
*
*        EXIT - ERROR -
*        IF ABS(ARG) ¬< PI*2**18 GOTO ERROR ROUTINE VIA
*                                B    FSAERR+26*4(R13)
*
*        TABLES/WORKAREAS - N/A
*
IHISSCSN CSECT
*
         ENTRY IHISSCC
         ENTRY IHISSCS
*
FPR0     EQU   0                       RESULT REGISTER
FPR2     EQU   2                       SCRATCH REGISTERS
FPR4     EQU   4
*
IHISSCC  SAVE  (14,12),,'IHISSCC  LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHISSCC,R15
         LA    R10,COMMON
         DROP  R15
         USING COMMON,R10
         MVI   CRANK+3,X'02'           FOR COSINE, OCTANT CRANK IS 2
         L     R1,0(,R1)               COS(X) = SIN(PI/2+X)
         B     COMMON
*
         DROP  R10
*
IHISSCS  SAVE  (14,12),,'IHISSCS  LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHISSCS,R15
         LA    R10,COMMON
         DROP  R15
         USING COMMON,R10
         MVI   CRANK+3,X'00'           OCTANT CRANK IS 0 IF +ARG
         L     R1,0(,R1)               OCTANT CRANK IS 4 IF -ARG
         TM    0(R1),X'80'             SIN(-X) = SIN(PI+X)
         BZ    COMMON
         MVI   CRANK+3,X'04'
COMMON   SDR   FPR0,FPR0               CLEAR FPR0 DOUBLE
         SDR   FPR2,FPR2               CLEAR FPR2 DOUBLE
         LE    FPR0,0(,R1)             OBTAIN ARGUMENT
         LPER  FPR0,FPR0               CONSIDER ARGUMENT TO BE POSITIVE
         CE    FPR0,MAX                /X/ >= PI*2**18 ?
         BNL   ERROR                   YES, ERROR
         MD    FPR0,FOVPI              MULTIPLY BY 4/PI (LONG FORM)
         CE    FPR0,ONE                < 1 ?
         BL    SMALL                   YES, BRANCH
         AW    FPR0,CH46               PROD CHAR OF 46, UNNORMALIZED
         LER   FPR2,FPR0               INT PART OF PROD TO FPR2, UNNORM
         SDR   FPR0,FPR2               FRACT PART OF PROD TO FPR0, NORM
SMALL    AU    FPR2,CRANK              ADD OCTANT CRANK TO FPR2, UNNORM
         STE   FPR2,OCTNT              SAVE IT
*                                      LAST 3 BITS ARE MODIFIED OCTANT
         TM    OCTNT+3,X'01'           IF ODD OCTANT, TAKE COMPLEMENT
         BZ    EVEN                    OF FRACTION TO OBTAIN THE
         SE    FPR0,ONE                MOFIFIED FRACTION R
         LPER  FPR0,FPR0
EVEN     SR    R1,R1                   R1 = 0 FOR COSINE POLYNOMIAL
         TM    OCTNT+3,X'03'           THIS IS FOR OCTANT 2,3,6, OR 7
         BM    LABAA                   IF OCTANT 1,4,5, OR 8, USE SINE
         LA    R1,4                    POLYNOMIAL, R1 = 4
LABAA    LER   FPR4,FPR0
         MER   FPR0,FPR0               COMPUTE SIN OR COS OF MODIFIED
         LER   FPR2,FPR0               FRACTION USING PROPER CHEBYSHEV
         ME    FPR0,C3(R1)             INTERPOLATION POLYNOMIAL
         AE    FPR0,C2(R1)
         MER   FPR0,FPR2
         AE    FPR0,C1(R1)
         MER   FPR0,FPR2
         AE    FPR0,C0(R1)             SIN(R)/R  OR COS(R) READY
         LTR   R1,R1
         BZ    LABBB
         MER   FPR0,FPR4               IF SINE POLYNOMIAL, MULTIPLY R
LABBB    TM    OCTNT+3,X'04'
         BZ    LABCC                   IF MODIFIED OCTANT IS IN
         LNER  FPR0,FPR0               LOWER PLANE, SIGN IS NEGATIVE
*
LABCC    RETURN (14,12)                RESTORE CALLERS REGS AND RETURN
*
ERROR    B     FSAERR+26*4(13)
*
FSAERR   EQU   X'1CC'
*
         DC    0D'0'
FOVPI    DC    X'41145F306DC9C830'
CH46     DC    X'4600000000000000'
CRANK    DC    X'46000000'
MAX      DC    X'45C90FDB'
*
C3       DC    X'BE14E5E0'         *   -0.00031888   C3
         DC    X'BD25B368'         |   -0.00003595   S3
C2       DC    X'3F40EBD6'         |    0.01584991   C2
         DC    X'3EA32F62'         |    0.00249001   S2
C1       DC    X'C04EF4E5'         |   -0.30842425   C1 + FUDGE 1
         DC    X'C014ABBC'         |   -0.08074543   S1
C0       DC    X'41100000'         |    1.0          C0
         DC    X'40C90FDB'         V    0.78539816   S0
ONE      EQU   C0
*
OCTNT    DC    F'0'
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHISSQ   0201-12230-12230-1200-00100-00100-00000-LEVEL
QRT      TITLE 'IHISSQRT, SQUARE ROOT, SHORT PRECISION, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        WRITE X = M*16**(2P-Q), M MANTISSA, Q=0 OR 1
*        THEN SQRT(X) = SQRT(M*16**-Q)*16**P
*
*        ENTRY POINT -
*        IHISSQ - SQRT FUNCTION, SHORT
*                 LA   R1,PARMLIST
*                 BALR R14,R15
*                 DATA PASSED BY NAME
*        THE MODULE IS ENTERED FROM THE GENERATED OBJECT MODULE
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXIT - NORMAL -
*        RETURN VIA R14, RESULT IN FPR0
*
*        EXIT - ERROR -
*        IF ARGUMENT NEGATIVE GOTO ERROR ROUTINE VIA
*        B   FSAERR+23*4(R13)
*
*        TABLES/WORKAREAS - N/A
*
IHISSQRT CSECT
*
         ENTRY IHISSQ
*
FPR0     EQU   0                       RESULT REGISTER
FPR2     EQU   2                       SCRATCH REGISTERS
FPR4     EQU   4
*
IHISSQ   SAVE  (14,12),,'IHISSQRT LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IHISSQRT,R15
         L     R1,0(,R1)
         L     R0,0(,R1)               OBTAIN ARGUMENT
         LE    FPR4,0(,R1)
         LTR   R0,R0
         BZ    ZRANS                   ARG IS 0, RESULT IS 0
         BM    ERROR                   NEGATIVE ARG, ERROR
         AL    R0,BIAS                 ADD X'41' TO CHAR
         SRDL  R0,25
         SLL   R0,24                   CHAR OF RESULT IS READY
         LR    R14,R0                  KEEP IT IN R14
         LTR   R1,R1                   SIGN BIT OF R1 = 1-Q
         BM    LABAA
         A     R14,FOUR                Q=1,ADD 4 (B31) TO R14 FOR INDEX
LABAA    SRL   R1,3                    SCALE 1+M (Q=0) OR M (Q=1) TO B3
         A     R1,C(R14)               OBTAIN FIRST APPROXIMATION BY
*                                      A HYPERBOLIC FIT OF THE
         L     R0,B(R14)               RESPECTIVE INTERVAL
         DR    R0,R1                   Q=1, INTERPRET M AS M/16 (B-1)
         A     R1,A(R14)
         AR    R1,R14                  ADD ON CHAR TO COMPLETE FIRST
         ST    R1,BUFF                 APPROXIMATION
         LER   FPR0,FPR4               GIVE 2 PASSES OF NEWTON-RAPHSON
         DE    FPR0,BUFF               ITERATION
         AE    FPR0,BUFF
         HER   FPR0,FPR0
         DER   FPR4,FPR0
         SER   FPR4,FPR0               Y2 =(Y1+X/Y1)/2 = (X/Y1-Y1)/2+Y1
         HER   FPR4,FPR4               USE THE LATTER TO PROTECT
         AER   FPR0,FPR4               LAST DIGIT
*
FIN      RETURN (14,12)                RESTORE REGS AND RETURN
*
ZRANS    SER   FPR0,FPR0
         B     FIN
*
ERROR    SLL   R0,1
         LTR   R0,R0                   NEGATIVE ZERO ?
         BZ    ZRANS
         B     FSAERR+23*4(R13)        NEGATIVE PARAMETER
*
FSAERR   EQU   X'1CC'
*
BUFF     DC    F'0'
BIAS     DC    X'41000000'
FOUR     DC    F'4'
A        DC    X'01CE9FE0'             1.8071270   A0 (B7)
         DC    X'006DC57C'             0.4287950   A1 (B7) MINUS 4(B31)
B        DC    X'FFE6C37D'            -1.5772732   B0 (B11)
         DC    X'FFFA82EB'            -0.0214398   B1 (B7)
C        DC    X'FF44546F'             0.95418214  C0 (B3) MINUS 1(B3)
         DC    X'0E0A7419'             0.0548470   C1 (B-1)
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IHISYS   0201-12230-12230-1200-00822-00822-00000-LEVEL
SYS      TITLE 'IHISYSCT, SYSACT I/O SERVICE ROUTINES, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        STATUS - LEVEL 2.1
*
*        FUNCTION/OPERATION -
*        CONSISTS OF 15 ROUTINES WITH DIFFERENT ACTIONS ON DATASET
*        WHICH DEPENDING ON SECOND PARAMETER IN SYSACT
*
*        ENTRY POINTS -
*        IHISYSCT - FROM GENERATED OBJECT MODULE
*                   LA   R1,PARMLIST
*                   BALR R14,R15
*                   DATA PASSED BY NAME
*
*        INPUT - SYSACT4 READS TWO RECORDS AFTER REPOSITIONING
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES -
*        IHIIOR - EVALUATE DATASET NUMBER
*               - OPEN DATASET
*               - CHANGE TO NEXT RECORD
*               - CLOSE DATASET
*               - CONVERT REAL TO INTEGER
*
*        EXITS - NORMAL - RELOAD REGISTERS RETURN VIA R14
*              - ERROR  -
*                DATASET NUMBER OUT OF RANGE                      NO 0
*                INCOMPATIBLE ACTIONS ON SAME DATASET             NO 2
*                INPUT REQUEST BEYOND END OF DATASET              NO 5
*                UNDEFINED FUNCTION NUMBER                        NO 9
*                DATASET CLOSED                                   NO 10
*                DATASET OPEN                                     NO 11
*                QUANTITY IN SYSACT PROCEDURE MUST BE A VARIABLE  NO 12
*                QUANTITY IN SYSACT PROCEDURE OUT OF RANGE        NO 13
*                BACKWARD REPOSITIONING NOT DEFINED               NO 14
*                BRANCH TO IHIFSA
*                          L  R13,IHIFSA
*                          B  FSAERR+XX*4(R13)       XX  ERROR NO
*
*        TABLES/WORK AREAS - N/A
*
*        ATTRIBUTES - SERIALLY REUSABLE
*
*        NOTES -
*        THE OPERATION OF THIS MODULE DOES NOT DEPEND UPON A
*        SPECIAL INTERNAL REPRESENTATION OF THE EXTERNAL
*        CHARACTER SET
*
*        REGISTERS
*        R1  -> PARAMETER LIST
*        R5  -> DSTABLE ENTRY FOR DATASET
*        R6   = DATASET NUMBER
*        R8  -> DCB AND DECB
*        R12 -> FSA
*        R13 -> SAVE AREA IN FSA
*        R14 -> RETURN
*        R15 -> ROUTINE SYSACT
*
IHISYSCT CSECT
*
*        FLOATING POINT REGISTER
*
FR0      EQU   0
*
*        DISPLACEMENTS IN ADRLST IN IHIFSA
*
*                                      DISPLACEMENT FOR -
CI       EQU   0                       IHIIORCI
CL       EQU   4                       IHIIORCL
EV       EQU   8                       IHIIOREV
NX       EQU   12                      IHIIORNX
OP       EQU   16                      IHIIOROP
OQ       EQU   20                      IHIIOROQ
*
         SAVE  (14,12),,'IHISYSCT LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15                  LOAD BASE REGISTER
         USING IHISYSCT,R7
         LR    R12,R13                 ADDR OF FIXED STORAGE AREA
*                                      TO R12
         ST    R13,SAVEAR+4
         LA    R13,SAVEAR
         L     R15,IORLST(,R12)        R15 -> COMMON I/O ROUTINES
         L     R15,EV(,R15)            EVALUATE DATASET NUMBER
         BALR  R14,R15
*
*        ON RETURN -
*        R6  = DATASET NUMBER
*        R5 -> DSTABLE ENTRY
*
         USING DSTABLE,R5
*
*        EVALUATE SECOND PARAMETER FUNCTION
*
         ICM   R2,B'1111',4(R1)
         BNM   SYS1
         TM    OPTSW(R12),X'20'        CONVERSION TO INTEGER TEST PRE
         BO    SYS11                   SHORT
         LD    FR0,0(,R2)              LONG
         B     SYS11A
*
SYS11    LE    FR0,0(,R2)
SYS11A   L     R15,IORLST(,R12)
         L     R15,CI(,R15)
         BALR  R14,R15                 CONVERT TO INTEGER
         B     SYS1A
*
SYS1     L     R0,0(,R2)
SYS1A    LTR   R2,R0
         BNP   SYSERR9                 ZERO OR NEG, FUNCT OUT OF RANGE
         C     R2,=F'15'               EXCEED FUNCTION RANGE
         BH    SYSERR9                 YES, FUNCTION OUT OF RANGE
         SLA   R2,2                    CONVERT TO OFFSET
         L     R3,SYSVECT(R2)          R3 -> REQUESTED SYSACT ROUTINE
*
*        EVALUATE THIRD PARAMETER QUANTITY
*
         SR    R9,R9                   ZERO REG USED AS FLAG
         L     R2,8(,R1)
         SLL   R2,1
         LTR   R2,R2
         BM    SYS11B
         LA    R9,1(,R9)               QUANTITY IS A VARIABLE
SYS11B   SRL   R2,1
         N     R2,=X'00FFFFFF'
         L     R4,0(,R2)
*
*        R3 -> REQUESTED SYSSACT
*        R2 -> QUANTITY
*        R4  = QUANTITY
*        R9 EQUAL ONE IF QUANTITY IS A VARIABLE ELSE ZERO
*
         BR    R3                      BRANCH TO SYSACT ROUTINE
*
RETSYS   L     R13,SAVEAR+4
*
         RETURN (14,12)                RESTORE CALLERS REGS AND RETURN
*
SYSERR9  LR    R13,R12                 UNDEFINED FUNCTION NUMBER ERR9
         B     FSAERR+9*4(R12)
*
*        BRANCH TO NEXTREC IN IHIIOR
*
NXREC    L     R15,IORLST(R12)
         L     R15,NX(R15)
         BR    R15
*
*----------------------------------------------------------------------
*        ROUTINE SYSACT1
*----------------------------------------------------------------------
*
*        QUANTITY = R
*
SYSACT1  TM    DSF,DS0
         BO    SYS1T1
SYSCLOSD LR    R13,R12                 DATASET IS CLOSED ERROR 10
         B     FSAERR+10*4(R12)
*
SYS1T1   LTR   R9,R9
         BP    SYS1T2
SYSCONST LR    R13,R12                 QUANTITY SHOULD BE A VARIABLE
         B     FSAERR+12*4(R12)        ERROR12
*
SYS1T2   L     R4,R
         S     R4,RE
         AH    R4,P
         LA    R4,1(,R4)
         ST    R4,0(,R2)
         B     RETSYS
*
*----------------------------------------------------------------------
*        ROUTINE SYSACT2
*----------------------------------------------------------------------
*
*        R = QUANTITY
*
SYSACT2  LTR   R4,R4
         BP    SYSACT2A
         B     SYS2T1
*
SYSACT2A CH    R4,P
         BNH   SYS2T1+6
SYS2T1   LR    R13,R12
         B     FSAERR+13*4(R12)        QUANTITY OUT OF RANGE ERROR 13
*
         TM    DSF,DS0
         BZ    SYSCLOSD                DATASET IS CLOSED
         LR    R3,R4
         A     R3,RE
         SH    R3,P
         BCTR  R3,0
         S     R3,R
         BP    SYS2T2
*
*        NEW CHARACTER POINTER LESS OR EQUAL R
*
         TM    DSF,DS2
         BO    SYS2T3
         TM    DSF+1,DS10              DATASET OPENED BY SYSACT 12 ?
         BO    SYS2T30
         TM    DSF,DS7                 EOD BEEN REACHED ?
         BO    SYSEOD
         BAL   R14,NXREC               LAST I/O PROCEDURE WAS INPUT
         TM    DSF,DS7                 END OF DATA REACHED ?
         BZ    SYS2T1A
         LR    R3,R4                   QUANTITY = 1 ?
         BCT   R3,SYSEOD               NO, INPUT REQUEST BEYOND EOD
SYS2T1A  A     R4,RE
         SH    R4,P                    ASSIGN A NEW VALUE TO CHARACTER
         BCTR  R4,0
         ST    R4,R
         B     RETSYS
*
SYS2T30  LTR   R6,R6                   DATASET NUMBER = 0 ?
         BZ    SYSINCOM                YES, BRANCH
         OI    DSF,DS2
*
*        LAST I/O PROCEDURE WAS OUTPUT
*
SYS2T3   L     R3,RE
         S     R3,R
         BZ    SYS2T31
         LA    R15,SYBLANK             FILL RECORD WITH BLANKS
         BALR  R14,R15
SYS2T31  BAL   R14,NXREC
*
         LR    R3,R4
         BCTR  R3,0
         LTR   R3,R3
         BZ    SYS2T32
         OI    DSF,DS3
         LA    R15,SYBLANK             FILL RECORD WITH BLANKS
         BALR  R14,R15
SYS2T32  L     R11,R
         AR    R4,R11
         BCTR  R4,0                    CHARACTER POINTER
         ST    R4,R                    QUANTITY+R-1 ASSIGN TO R
         B     RETSYS
*
*        NEW CHARACTER POINTER GREATER THAN R
*
SYS2T2   TM    DSF,DS2
         BO    SYS2T20
         TM    DSF+1,DS10              DS BEEN OPENED BY SYSACT 12 ?
         BZ    SYS2T5
         LTR   R6,R6                   DATASET NUMBER = 0 ?
         BZ    SYSINCOM                YES, BRANCH
         OI    DSF,DS2
SYS2T20  LR    R3,R4                   LAST I/O WAS OUTPUT
         A     R3,RE
         S     R3,R
         OI    DSF,DS3
         SH    R3,P
         BCTR  R3,0
         LA    R15,SYBLANK             FILL RECORD WITH BLANKS
         BALR  R14,R15
*
SYS2T5   TM    DSF,DS7                 EOD BEEN REACHED ?
         BO    SYSEOD
SYS2T4   A     R4,RE
         SH    R4,P                    ASSIGN NEW VALUE TO CHAR POINTER
         BCTR  R4,0
         ST    R4,R
         B     RETSYS
*
*----------------------------------------------------------------------
*        ROUTINE SYSACT3
*----------------------------------------------------------------------
*
*        QUANTITY = S
*
SYSACT3  TM    DSF,DS0
         BZ    SYSCLOSD                DATASET CLOSED ERROR10
         LTR   R9,R9
         BZ    SYSCONST                QUANTITY NOT A VARIABLE ERR 12
         LH    R4,S
         ST    R4,0(,R2)
         B     RETSYS
*
*----------------------------------------------------------------------
*        ROUTINE SYSACT4
*----------------------------------------------------------------------
*
*        UNDEFINED IF DATASET SPLIT INTO SECTION BY SYSACT8 OR
*        IF THE DATASET IS 0 OR 1
*
*        ACTION AFTER INPUT - S = QUANTITY
*                             R = 1
*        ACTION AFTER OUTPUT - S = QUANTITY
*                              R = 1
*        IF FORWARD SKIPPING FILL SKIPPED RECORDS WITH BLANKS
*
SYSACT4  L     R8,ADCB
         LTR   R4,R4                   TEST QUANTITY
         BP    SYS4T01
         LR    R13,R12
         B     FSAERR+13*4(R12)        QUANTITY OUT OF RANGE
*
SYS4T01  TM    DSF+1,DS9               DATASET SECTIONED ?
         BO    SYSINCOM
         LTR   R2,R6                   DATASET NO = 1 OR 0 ?
         BZ    SYSINCOM
         BCT   R2,SYS4T0
         B     SYSINCOM
*
SYS4T0   TM    DSF,DS0                 DATASET OPEN ?
         BZ    SYSCLOSD
         CH    R4,S                    QUANTITY > S ?
         BL    SYS4T2                  NO, LESS
         BE    SYS4T3                  NO, EQUAL
SYS4T1   TM    DSF,DS2                 LAST I/O OUTPUT ?
         BO    SYS4T15                 YES, BRANCH TO SYS4T15
*
*        LAST I/O INPUT AND QUANTITY > S
*
         TM    DSF+1,DS10              DS BEEN OPENED BY SYSACT 12 ?
         BZ    SYS4T12
         OI    DSF,DS2                 DATASET OPEN FOR OUTPUT
         B     SYS4T15
*
SYS4T12  LA    R15,SYSNOT              QUANTITY IN NOTTAB ?
         BALR  R14,R15
         TM    DSF,DS7                 EOD BEEN REACHED ?
         BO    SYSEOD
         LTR   R3,R3
         BP    SYS4T21                 YES, BRANCH TO SYS4T21
SYS4T13  TM    DSF,DS7                 END OF DATA BEEM REACHED ?
         BO    SYSEOD
         BAL   R14,NXREC               GET NEXT RECORD
         CH    R4,S                    QUANTITY = S ?
         BNE   SYS4T13
         B     RETSYS
*
*        LAST I/O OUTPUT AND QUANTITY > S
*
SYS4T15  L     R3,RE                   FILL RECORD WITH BLANKS
         S     R3,R
         BZ    SYS4T14
         LA    R15,SYBLANK
         BALR  R14,R15
SYS4T14  BAL   R14,NXREC
         CH    R4,S                    QUANTITY = S ?
         BNE   SYS4T15
         B     RETSYS
*
SYS4T2   LA    R15,SYSNOT              QUANTITY IN NOTTAB ?
         BALR  R14,R15
         LTR   R3,R3
         BZ    SYSERR14                NO BACKWARD REP. NOT DEFINED
         TM    DSF,DS2                 LAST I/O OUTPUT ?
         BO    SYS4T24
*
*        LAST I/O INPUT AND QUANTITY < S
*
         OI    DSF,DS5                 DS5=1
         NI    DSF,255-DS6-DS7         SET DS6 AND DS7 = 0
SYS4T21  OI    DSF+1,DS8               DS8=1
         USING IHADCB,R8
*
         CHECK SYDECB
*
         NI    DSF+1,255-DS8           SET DS8=0
SYS4T22  LR    R0,R10
         LR    R1,R8
*
         POINT (1),(0)
*
         L     R2,NBB
*
         READ  SYDECB,SF,(R8),(R2),MF=E
*
         L     R2,BB
         AH    R2,BL
         ST    R2,RE
         LR    R2,R4
         BCTR  R2,0
         STH   R2,S                    S = QUANTITY - 1
         BAL   R14,NXREC
         TM    DSF,DS1                 DATASET BLOCKED ?
         BO    RETSYS
         SR    R2,R2                   YES, EVALUATE NUMBER OF FIRST
         L     R3,BL                   RECORD IN THE BLOCK =
         SRL   R3,16                   ENTIER((QUANTITY-1)/(BLKLTH/
         L     R1,S                    RECLNTH))*(BLKLNTH/RECLNTH)+1
         SLL   R1,16
         SRL   R1,16
         DR    R2,R1
         LR    R1,R3
         SR    R2,R2
         LR    R3,R4
         BCTR  R3,0
         DR    R2,R1
         MR    R2,R1
         LA    R3,1(R3)
         STH   R3,S
SYS4T23  CH    R4,S                    QUANTITY = S ?
         BE    RETSYS
         BAL   R14,NXREC
         B     SYS4T23
*
*        LAST I/O WAS OUTPUT AND QUANTITY < S
*
SYS4T24  TM    DSF,DS1                 DATASET BLOCKED ?
         BO    SYS4T25
         L     R3,BB
         AH    R3,BL
         ST    R3,RE
SYS4T25  L     R3,RE                   FILL BLOCK WITH BLANKS
         S     R3,R
         BZ    SYS4T26
         LA    R15,SYBLANK
         BALR  R14,R15
SYS4T26  BAL   R14,NXREC
*
SYS4T27  CHECK SYDECB
*
         CLOSE ((R8),LEAVE),TYPE=T     SET END OF DATA MARK
*
         OI    DSF,DS5
         NI    DSF,255-DS2-DS6         SET DS2 AND DS6 = 0
         B     SYS4T22                 WAS LAST I/O OUTPUT
*
SYS4T3   TM    DSF,DS2
         BZ    SYS4T31
*
*        LAST I/O OUTPUT AND QUANTITY = S
*
         OI    DSF,DS4
         L     R3,BB
         AH    R3,BL
         ST    R3,RE
         S     R3,R                    FILL BLOCK WITH BLANKS
         BZ    SYS4T33
         LA    R15,SYBLANK
         BALR  R14,R15
SYS4T33  BAL   R14,NXREC               WRITE BLOCK
         LA    R15,SYSNOT              MAKE NOTTAB ENTRY
         BALR  R14,R15
         B     SYS4T27
*
*        LAST I/O INPUT AND QUANTITY = S
*
SYS4T31  L     R2,RE
         SH    R2,P
         ST    R2,R                    RESET CHARACTER POINTER
         B     RETSYS
*
SYSEOD   LR    R13,R12
         B     FSAERR+5*4(R12)
*
*        SCAN NOTTAB IN ORDER TO FIND OUT IF AN ENTRY HAS BEEN
*        MADE FOR QUANTITY
*        IF YES R3 IS SET TO ONE, ADDR OF NOTEADR IN R10
*
SYSNOT   L     R3,ANOTTAB(R12)
         LR    R10,R3
SYSNOT1  C     R10,0(,R3)
         BE    SYSNOT2
         LA    R10,8(,R10)
         LR    R2,R6
         CH    R2,0(,R10)
         BNE   SYSNOT1
         CH    R4,2(,R10)
         BNE   SYSNOT1
         SR    R3,R3
         LA    R3,1(,R3)
         LA    R10,4(,R10)
         BR    R14
*
SYSNOT2  SR    R3,R3
         BR    R14
*
SYSERR14 LR    R13,R12                 BACKWARD REPOSITIONING NOT
         B     FSAERR+14*4(R12)        DEFINED
*
*----------------------------------------------------------------------
*        ROUTINE SYSACT5
*----------------------------------------------------------------------
*
*        QUANTITY = P
*
SYSACT5  TM    DSF,DS0
         BZ    SYSCLOSD                DATASET CLOSED ERROR10
         LTR   R9,R9
         BZ    SYSCONST                QUANTITY NOT A VARIABLE ERR 12
         LH    R4,P
         ST    R4,0(,R2)
         B     RETSYS
*
*----------------------------------------------------------------------
*        ROUTINE SYSACT6
*----------------------------------------------------------------------
*
*        P = QUANTITY
*        DATASET HAS TO BE CLOSED
*
SYSACT6  TM    DSF,DS0
         BO    SYSOPEN
         LTR   R4,R4                   TEST QUANTITY
         BNP   SYSQOUTR                MINUS OR ZERO
         C     R4,=F'32760'
         BH    SYSQOUTR                TOO GREAT
         STH   R4,P
         B     RETSYS
*
SYSOPEN  LR    R13,R12                 DATASET IS OPEN ERROR 11
         B     FSAERR+11*4(R12)
*
*----------------------------------------------------------------------
*        ROUTINE SYSACT7
*----------------------------------------------------------------------
*
*        QUANTITY = Q
*
SYSACT7  LTR   R9,R9
         BZ    SYSCONST                QUANTITY NOT A VARIABLE ERR 12
         SR    R4,R4
         IC    R4,Q
         ST    R4,0(,R2)
         B     RETSYS
*
*----------------------------------------------------------------------
*        ROUTINE SYSACT8
*----------------------------------------------------------------------
*
*        Q = QUANTITY
*        DATASET HAS TO BE CLOSED
*        ASSIGNING A VALUE TO Q
*
SYSACT8  TM    DSF,DS0
         BO    SYSOPEN                 DATASET IS OPEN ERROR11
         LTR   R6,R6                   DATASET 0 ?
         BZ    SYSINCOM                YES, INCOMPATIBLE ACTION
         LTR   R3,R4                   TEST QUANTITY
         BNP   SYSQOUTR                MINUS OR ZERO
         S     R3,KF256
         BP    SYSQOUTR
         BZ    SYSQOUTR
         STC   R4,Q
         OI    DSF+1,DS9               RECORD CONTAIN CNTL CHARACTER
         B     RETSYS
*
SYSDSN0  LR    R13,R12                 DATASET NUMBER OUT OF RANGE
         B     FSAERR(R12)
*
SYSQOUTR LR    R13,R12                 QUANTITY OUT OF RANGE ERROR 13
         B     FSAERR+13*4(R12)
*
KF256    DC    F'256'
*
*----------------------------------------------------------------------
*        ROUTINE SYSACT9
*----------------------------------------------------------------------
*
*        QUANTITY = K
*
SYSACT9  LTR   R9,R9
         BZ    SYSCONST                QUANTITY NOT A VARIABLE ERR 12
         SR    R4,R4
         IC    R4,K
         ST    R4,0(,R2)
         B     RETSYS
*
*----------------------------------------------------------------------
*        ROUTINE SYSACT10
*----------------------------------------------------------------------
*
*        K = QUANTITY
*        ASSIGN NUMBER OF BLANK DELIMTERS
*
SYSACT10 LTR   R4,R4                   TEST QUANTITY
         BNP   SYSQOUTR                MINUS OR ZERO
         C     R4,KF256
         BNL   SYSQOUTR                TOO GREAT
         STC   R4,K
         B     RETSYS
*
*----------------------------------------------------------------------
*        ROUTINE SYSACT11
*----------------------------------------------------------------------
*
*        ASSIGN VALUE TO QUANTITY FOR DEFINING IF DATASET OPEN
*        OR CLOSED
*
SYSACT11 LTR   R9,R9
         BZ    SYSCONST                QUANTITY NOT A VARIABLE ERR 12
         SR    R4,R4
         TM    DSF,DS0
         BZ    SYS11T1                 DATASET IS CLOSED
         LA    R4,1(,R4)
         TM    DSF,DS7
         BO    SYS11T2                 DS7 EQUAL 1
         TM    DSF,DS2
         BO    SYS11T1                 OUTPUT
         TM    DSF,DS1
         BO    SYS11T1                 UNBLOCKED
         L     R11,R
         L     R1,RE
         SH    R1,P
         CR    R1,R11
         BNE   SYS11T1                 R NOT EQUAL RE MINUS P
         L     R1,BB
         AH    R1,BL
         SR    R1,R11
SYS11T3  CLI   0(R11),C' '
         BNE   SYS11T1                 CHARACTER NOT BLANK
         LA    R11,1(R11)
         BCT   R1,SYS11T3
         L     R8,ADCB
*
         CHECK SYDECB
*
         TM    DSF,DS7
         BZ    SYS11T1                 NO END OF DATA
SYS11T2  LNR   R4,R4
SYS11T1  ST    R4,0(,R2)
         B     RETSYS
*
*----------------------------------------------------------------------
*        ROUTINE SYSACT12
*----------------------------------------------------------------------
*
*        OPEN OR CLOSE DATASET
*
SYSACT12 LTR   R4,R4
         BZ    SYS12T1
         BCT   R4,SYSQOUTR             QUANTITY OUT OF RANGE
         TM    DSF,DS0                 ROUTINE SHOULD PERFORM OPEN
         BO    SYS12T2                 DATASET WAS OPEN ALREADY
         OI    DSF+1,DS10              DS10=1 DS OPENED BY SYSACT 12
         L     R15,IORLST(R12)
         L     R15,OQ(R15)             OPEN DATASET
         BALR  R14,R15
         B     RETSYS
*
SYS12T1  TM    DSF,DS0                 ROUTINE SHOULD PERFORM CLOSE
         BZ    SYS12T2                 DATASET WAS CLOSED ALREADY
         L     R15,IORLST(R12)
         L     R15,CL(,R15)
         BALR  R14,R15
SYS12T2  B     RETSYS
*
*----------------------------------------------------------------------
*        ROUTINE SYSACT13
*----------------------------------------------------------------------
*
*        QUANTITY = S
*        SETTING DS4 FLAG USED BY A LATER SYSACT4 FOR AN ENTRY
*        TO NOTTAB
*
SYSACT13 TM    DSF,DS0
         BZ    SYSCLOSD                DATASET IS CLOSED ERROR10
         TM    DSF+1,DS9               DATASET SECTIONED ?
         BO    SYSINCOM                YES, INCOMPATIBLE ACTION
         LTR   R3,R6                   DATASET NO = 1 OR 0 ?
         BZ    SYSINCOM
         BCT   R3,SYS13T1
*
SYSINCOM LR    R13,R12                 INCOMPATIBLE ACTION ON THE SAME
         B     FSAERR+2*4(R12)         DATASET
*
SYS13T1  LTR   R9,R9
         BZ    SYSCONST                QUANTITY NOT A VARIABLE ERR 12
         LH    R4,S
         ST    R4,0(,R2)
         OI    DSF,DS4                 SET FLAG DS4
         B     RETSYS
*
*----------------------------------------------------------------------
*        ROUTINE SYSACT14
*----------------------------------------------------------------------
*
*        SKIPS RECORDS OR FILLS THEM BY BLANKS, DEPENDING ON THE
*        LAST I/O PROCEDURE
*
SYSACT14 LTR   R4,R4
         BNP   SYSQOUTR                QUANTITY OUT OF RANGE ERROR13
         TM    DSF,DS0
         BZ    SYSCLOSD
SYS14T1  AH    R4,S
         TM    Q,X'FF'
         BZ    SYS14T2
*
*        SECTIONED FORMAT ONLY OUTPUT POSSIBLE
*
         SR    R2,R2
         IC    R2,Q
         CR    R4,R2
         BNH   SYS14T2
         L     R3,RE
         S     R3,R                    NUMBER OF BLANKS IN R3
         BZ    SYS14T11
         LA    R15,SYBLANK             FILL RECORD WITH BLANKS
         BALR  R14,R15
SYS14T11 MVC   S+1(1),Q
         OI    DSF,DS2                 OUTPUT
         BAL   R14,NXREC               SKIP TO BEGIN OF NEXT SECTION
         B     RETSYS
*
*        NOT SECTIONED FORMAT OR QUANTITY LESS OR EQUAL Q
*
SYS14T2  TM    DSF,DS2
         BZ    SYS14T4                 LAST I/O WAS INPUT
SYS14T3  L     R3,RE
         S     R3,R
         BZ    SYS14T5
         LA    R15,SYBLANK             FILL RECORD WITH BLANKS
         BALR  R14,R15
SYS14T5  BAL   R14,NXREC
         CH    R4,S
         BNE   SYS14T3
         B     RETSYS
*
*        INPUT
*
SYS14T4  TM    DSF+1,DS10              DS BEEN OPENED BY SYSACT 12 ?
         BO    SYS14T7
*
*        ONLY INPUT READ THE FOLLWING UNTIL RECORD POINTER S
*        EQUALS QUANTITY
*
SYS14T6  TM    DSF,DS7                 EOD BEEN REACHED ?
         BO    SYSEOD
         BAL   R14,NXREC
         CH    R4,S
         BE    RETSYS
         B     SYS14T6
*
SYS14T7  LTR   R6,R6                   DATASET NUMBER = 0 ?
         BZ    SYSINCOM                YES, BRANCH
         OI    DSF,DS2                 OUTPUT
         B     SYS14T3
*
*----------------------------------------------------------------------
*        ROUTINE SYSACT15
*----------------------------------------------------------------------
*
*        SKIP TO RECORD EQUAL QUANTITY IN NEXT SECTION IF DATA
*        IS NOT SECTIONED. SYSACT14 IS INVOKED
*
SYSACT15 LTR   R4,R4
         BNP   SYSQOUTR                QUANTITY OUT OF RANGE ERROR13
         TM    DSF,DS0
         BZ    SYSCLOSD
         TM    Q,X'FF'
         BZ    SYS14T1                 DATA IS NOT SECTIONED SYSACT14
*                                      IS INVOKED
         SR    R3,R3
         IC    R3,Q
         CR    R4,R3
         BH    SYSQOUTR
         L     R3,RE
         S     R3,R                    FILL RECORD WITH BLANKS
         BZ    SYS15T0
         LA    R15,SYBLANK             FILL RECORD WITH BLANKS
         BALR  R14,R15
SYS15T0  MVC   S+1(1),Q
         OI    DSF,DS2                 OUTPUT
         BAL   R14,NXREC
         LR    R3,R4
         BCT   R3,SYS14T3
*
SYS15T1  B     RETSYS                  QUANTITY EQUALS ONE
*                                      FIRST RECORD IN NEXT SECTION
*
*        SYBLANK FILL RECORD WITH BLANKS
*
SYBLANK  L     R11,R
SYBLANK1 MVI   0(R11),C' '
         LA    R11,1(,R11)
         BCT   R3,SYBLANK1
         BR    R14
*
*        CONSTANTS
*
SAVEAR   DC    18F'0'                  SAVEAREA
*
         LTORG
*
*        SYSACT VECTOR TABLE
*
SYSVECT  DS    A(0)
         DC    A(SYSACT1)
         DC    A(SYSACT2)
         DC    A(SYSACT3)
         DC    A(SYSACT4)
         DC    A(SYSACT5)
         DC    A(SYSACT6)
         DC    A(SYSACT7)
         DC    A(SYSACT8)
         DC    A(SYSACT9)
         DC    A(SYSACT10)
         DC    A(SYSACT11)
         DC    A(SYSACT12)
         DC    A(SYSACT13)
         DC    A(SYSACT14)
         DC    A(SYSACT15)
*
*        DSTABLE
*
         DSTABLE  DSECT=YES
*
*        DSECT FOR ADDRESSING DECB
*
         PRINT NOGEN
*
         DCBD  DSORG=BS,DEVD=DA
*
         PRINT GEN
*
         READ  SYDECB,SF,MF=L
*
FAS      DSECT
*
         COPY  FSAREA
*
         IEZREGS
*
         END
