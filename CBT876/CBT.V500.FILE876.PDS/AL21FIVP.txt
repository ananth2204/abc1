./ ADD NAME=IEXOPTNS 0201-12230-12230-1200-00058-00058-00000-LEVEL
//T1ACO   JOB  111,'ALGOL F LVL2.1',   <-- CUSTOMIZE FOR SITE STANDARDS
//             CLASS=S,MSGCLASS=C,     <-- CUSTOMIZE FOR SITE STANDARDS
//             REGION=1024K,COND=(0,NE),MSGLEVEL=(1,1)
//*
//*       IBM Algol F Level 2.1
//*
//*       360S-AL-531 Algol F Compiler
//*
//*       Set Compiler Default Options
//*
//SETOPTS EXEC PGM=AMASPZAP
//SYSPRINT DD  SYSOUT=*
//SYSLIB   DD  DSN=SYS2.LINKLIB,DISP=SHR
//SYSIN    DD  *
*
*          Set Algol F Level 2.1 Compiler Default Options
*
*          For a complete explanation of the Options refer to -
*
*          GC28-6554-13 OS System Generation Release 21.8
*                       and
*          GC33-4000-00 Algol Programmers Guide
*
*          Option                    POSITION
*                                    BYTE 0    BYTE 1
*          Bit Settings              01234567  01234567
*
*          Internal Compiler Use     0
*          Internal Compiler Use      0
*          Internal Compiler Use       0
*          Internal Compiler Use        0
*          Internal Compiler Use         0
*          Internal Compiler Use          0
*          LONG/SHORT PRECISION            0              0 = SHORT
*          Internal Compiler Use            0
*
*          NOSOURCE/SOURCE                     0          0 = SOURCE
*          NOLOAD/LOAD                          0         0 = LOAD
*          NODECK/DECK                           1        1 = NODECK
*          ISO/EBCDIC                             0       0 = EBCDIC
*          Internal Compiler Use                   0
*          Internal Compiler Use                    0
*          Internal Compiler Use                     1
*          Internal Compiler Use                      0
*
*          Verify Default settings of -
*          PRECISN=SHORT
*          SORLIST=SOURCE
*          TYPERUN=LOAD
*          PUNCH=NODECK
*          SORCODE=EBCDIC
*
           NAME IEX00 IEX00001
           VER  80    0022        Verify Default Settings
           REP  80    0022        <- Change options
           IDRDATA    IEXOPTNS
/*
//
./ ADD NAME=IEXSAMP1 0201-12230-12230-1200-00077-00077-00000-LEVEL
//T1IV1   JOB  111,'ALGOL F LVL2.1',   <-- CUSTOMIZE FOR SITE STANDARDS
//             CLASS=S,MSGCLASS=C,     <-- CUSTOMIZE FOR SITE STANDARDS
//             REGION=1024K,COND=(0,NE),MSGLEVEL=(1,1)
//*
//*       IBM Algol F Level 2.1 IVP
//*
//*       360S-AL-531 Algol F Compiler
//*            and
//*       360S-LM-532 Algol F Library
//*
//IVP1   EXEC  ALGOFCLG,PARM.GO='TRACE'
//ALGOL.SYSIN  DD  *
     'BEGIN'
      'COMMENT' TEST PROGRAM Q09
                MODIFIED FOR IBM ALGOL F LEVEL 2.1 IVP

                GENERATE AND PRINTS THE FIRST TWENTY
                LINES OF PASCALS TRIANGLE

          THE K TH ELEMENT P(K,J) OF THE J TH LINE SHOULD BE
          EQUAL TO THE SUM OF P(K-1,J-1) AND P(K,J-1) FOR K ¬= 0
          AND K ¬= J. P(0,J)=P(J,J)=1
          THUS BY ADDING TWO BY TWO ALL ELEMENTS IN ONE LINE
          PLACING EACH SUM BELOW AND BETWEEN THE TWO ELEMENTS THE
          NEXT LINE OF PASCALS TRIANGLE COULD BE EXPANDED ;

     'INTEGER' l,k,n,i,m,Powerten;
     'INTEGER' 'ARRAY' aÝ0:19¨;
     'BOOLEAN' c;
     SYSACT(1,6,120);
     SYSACT(1,8,62);
     SYSACT(1,12,1);
     SYSACT(1,2,56);
     OUTSTRING (1,'('Pascals Triangle')');
     'FOR' l := 0 'STEP' 1 'UNTIL' 19 'DO'
      'BEGIN'
       SYSACT(1,14,3);
       'IF' l < 19 'THEN'
         SYSACT(1,2,58-3*l);
       aÝl¨ := 1;
       'FOR' k := l-1 'STEP' -1 'UNTIL' 1 'DO'
        aÝk¨ := aÝk-1¨ + aÝk¨;
        'FOR' K :=0 'STEP' 1 'UNTIL' L 'DO'
         'BEGIN'
          c := 'TRUE';
          m := aÝk¨;
          'FOR' I := 5 'STEP' -1 'UNTIL' 0 'DO'
           'BEGIN'
             Powerten := 10 ** I;
             n := m '/' Powerten;
             m := m-n * Powerten;
             'IF' n 'EQUAL' 0 'THEN'
              'BEGIN'
               'IF' c 'THEN' OUTSYMBOL (1,'(' ')',1)
                 'ELSE' OUTSYMBOL (1,'('0')',1);
              'END'
               'ELSE'
                'BEGIN'
                 c := 'FALSE';
                 OUTSYMBOL(1,'('123456789')',N);
                'END'
           'END'
         'END'
      'END'
     'END'
/*
//AMBLIST  EXEC PGM=AMBLIST
//*
//*        DEMONSTRATE LANGUAGE TRANSLATOR ID FOR ALGOL F
//*        PROGRAMS AND TIME OF COMPILATION
//*
//SYSPRINT  DD  SYSOUT=*
//SYSLIB    DD  DSN=&&GOSET,DISP=(OLD,PASS)
//SYSIN     DD  *
        LISTIDR  MEMBER=GO
/*
//
./ ADD NAME=IEXSAMP2 0201-12230-12230-1200-00050-00050-00000-LEVEL
//T1IV2   JOB  111,'ALGOL F LVL2.1',   <-- CUSTOMIZE FOR SITE STANDARDS
//             CLASS=S,MSGCLASS=C,     <-- CUSTOMIZE FOR SITE STANDARDS
//             REGION=1024K,COND=(0,NE),MSGLEVEL=(1,1)
//*
//*       IBM ALGOL F LEVEL 2.1 IVP
//*
//*       360S-AL-531 ALGOL F COMPILER
//*            AND
//*       360S-LM-532 ALGOL F LIBRARY
//*
//IVP2   EXEC  ALGOFCLG,PARM.GO='TRACE,DUMP'
//ALGOL.SYSIN  DD  *
      'BEGIN'
      'COMMENT'
       IBM ALGOL F LEVEL 2.1 IVP
       SAMPLE PROGRAM TO CREATE DELIBERATE DIVIDE BY ZERO ERROR
       TO DEMONSTRATE ALGOL RUN TIME DIAGNOSTIC INFORMATION;

      'INTEGER' I;
      'REAL' A;
      'BOOLEAN' B;
      'INTEGER' 'ARRAY' IAÝ1:5¨;
      'ARRAY' ARÝ0:3,2:8¨;
      'BOOLEAN' 'ARRAY' BAÝ0:1,1:3,3:7¨;
      'INTEGER' 'PROCEDURE' IP;
      IP := I + 5;
      'REAL' 'PROCEDURE' RP(A);
      'VALUE' A;
      'INTEGER' A;
      RP := A*A;
      'PROCEDURE' P(A,B,C);
      'BOOLEAN' A;
      'REAL' B;
      'INTEGER' C;
      A:= B < C ;
      I := 1;
      A := 2.6;
      ARÝ1,1¨ := IP;
      ARÝ1,2¨ := RP(ARÝ1,1¨);
      P(BAÝ0,1,3¨,A,I);
      P(B,ARÝ1,2¨,IP);
      SYSACT(1,8,50);
      OUTREAL(1,ARÝ1,1¨);
      OUTBOOLEAN(1,BAÝ0,1,3¨);
      OUTBOOLEAN(1,B);
      'COMMENT' DELIBERATE DIVIDE BY ZERO ERROR;
      A := A/0;
      'END'
/*
//
./ ADD NAME=IEXSAMP3 0201-12230-12230-1200-00081-00081-00000-LEVEL
//T1IV3   JOB  111,'ALGOL F LVL2.1',   <-- CUSTOMIZE FOR SITE STANDARDS
//             CLASS=S,MSGCLASS=C,     <-- CUSTOMIZE FOR SITE STANDARDS
//             REGION=1024K,COND=(0,NE),MSGLEVEL=(1,1)
//*
//*       IBM ALGOL F LEVEL 2.1 IVP
//*
//*       360S-AL-531 ALGOL F COMPILER
//*            AND
//*       360S-LM-532 ALGOL F LIBRARY
//*
//IVP3   EXEC  ALGOFCLG,PARM.GO='TRACE'
//ALGOL.SYSIN  DD  *
 'BEGIN'
 'COMMENT'
 ////////////////////////////////////////////////////////////////////
 // NAME: PETER M. MAURER
 // Program: Sieve of Eratosthenes
 // DUE: NEVER
 // LANGUAGE: ALGOL 60 ALA IBM ALGOL F
 // IBM Algol F IVP Contribution
 // by the kind permission of PETER M. MAURER
 ////////////////////////////////////////////////////////////////////
 ;
    'COMMENT' Define the Sieve Data Structure ;
    'INTEGER' 'ARRAY' Candidates Ý0:1000¨;
    'INTEGER' i,j,k;
    'COMMENT' Set line-length = 120, Set lines-per-page = 62, OPEN;
    SYSACT(1,6,120);
    SYSACT(1,8,62);
    SYSACT(1,12,1);
    'COMMENT' 1000 to protect against strict evaluation of and ;
    'FOR' i := 0 'STEP' 1 'UNTIL' 1000 'DO'
    'BEGIN'
        'COMMENT' everything is potentially prime
                        until proven otherwise ;
        CandidatesÝi¨ := 1;
    'END';
    'COMMENT' Neither 1 nor 0 is Prime, so flag them off  ;
    CandidatesÝ0¨ := 0;
    CandidatesÝ1¨ := 0;
    'COMMENT' Start the Sieve with the Integer 0 ;
    i := 0;
    'FOR' i := i 'WHILE' i 'LESS' 1000 'DO'
    'BEGIN'
        'COMMENT' Advance to the next un-crossed out. ;
        'COMMENT' this number must be a prime;
        'FOR' i := i 'WHILE' i 'LESS' 1000
                            'AND' CandidatesÝi¨ 'EQUAL' 0 'DO'
        'BEGIN'
            i := i+1;
        'END';
        'COMMENT' insure against running off the end;
        'IF' i 'LESS' 1000 'THEN'
        'BEGIN'
            'COMMENT' Cross out all multiples of the Prime.;
            j := 2;
            k := j*i;
            'FOR' k := k 'WHILE' k 'LESS' 1000 'DO'
            'BEGIN'
                CandidatesÝk¨ := 0;
                j := j + 1;
                k := j*i;
            'END';
            'COMMENT' Advance to the next candidate ;
            i := i+1;
            'END'
        'END';
        'COMMENT' All uncrossed out numbers are prime;
        'COMMENT' Print all Primes ;
        'FOR' i := 0 'STEP' 1 'UNTIL' 999 'DO'
        'BEGIN'
        'IF' CandidatesÝi¨ ¬= 0  'THEN'
        'BEGIN'
            OUTINTEGER(1,i);
            OUTSTRING(1,'(' Is Prime')');
            SYSACT(1,14,1)
        'END'
    'END'
 'END'
/*
//
./ ADD NAME=IEXSAMP4 0201-12230-12230-1200-00888-00888-00000-LEVEL
//T1IV4   JOB  111,'ALGOL F LVL2.1',   <-- CUSTOMIZE FOR SITE STANDARDS
//             CLASS=S,MSGCLASS=C,     <-- CUSTOMIZE FOR SITE STANDARDS
//             REGION=1024K,COND=(0,NE),MSGLEVEL=(1,1)
//*
//*       IBM Algol F Level 2.1 IVP
//*
//*       360S-AL-531 Algol F Compiler
//*            and
//*       360S-LM-532 Algol F Library
//*
//IVP4    EXEC ALGOFCL
//ALGOL.SYSIN  DD  *
    'BEGIN'
    'COMMENT'  Basic Statement Times for Algol 60
               B A Wichmann
               National Physics laboratory
               Teddington, Middlesex
               November 1973;

    'COMMENT'  Modified for IBM Algol F Level 2.1 IVP
               This program will execute for aproximately 4 minutes
               on an MVS 3.8 system running on a Hercules 3.07
               system averaging 25 mips.

               Timings are guidelines only due to the PC, Windows
               and the Hercules timer implementations and will
               therefore vary for each execution;

    'REAL' x, y, z;
    'INTEGER' i, j, n, k, l, m, case;
    'INTEGER' 'ARRAY' e1Ý1:1¨, e2Ý1:1,1:1¨, e3Ý1:1,1:1,1:1¨;

    'PROCEDURE' p0;
       ;

    'PROCEDURE' p1(x);
       'VALUE' x;
       'REAL' x;
       ;

    'PROCEDURE' p2(x,y);
       'VALUE' x, y;
       'REAL' x, y;
       ;

    'PROCEDURE' p3(x,y,z);
       'VALUE' x, y, z;
       'REAL' x, y, z;
       ;

    'INTEGER' 'ARRAY' #TTÝ1:43¨;

    'PROCEDURE' printt;
         'BEGIN'
              'INTEGER' i;
              'REAL' x, mix, loop;
              'COMMENT' calculate time differences;
              'FOR' i := 43 'STEP' -1 'UNTIL' 2 'DO'
                   'BEGIN'
                        #TTÝi¨ := #TTÝi¨ - #TTÝi-1¨;
                        'COMMENT' subtract previous accum cpu time
                                  to derive case timing;
                   'END';
              'FOR' i := 2 'STEP'  1 'UNTIL' 42 'DO'
                   'BEGIN'
                        #TTÝi¨ := (#TTÝi¨ - #TTÝ43¨)/ ((n * 10)/1000);
                        'COMMENT' subtract loop overhead and
                                  convert to picroseconds;
                   'END';
              'COMMENT' Print results;
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ2¨);
              OUTSTRING(1,'('x := 1.0 ')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ3¨);
              OUTSTRING(1,'('x := 1 ')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ4¨);
              OUTSTRING(1,'('x := y ')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ5¨);
              OUTSTRING(1,'('x := y + z')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ6¨);
              OUTSTRING(1,'('x := y * z')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ7¨);
              OUTSTRING(1,'('x := y / z')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ8¨);
              OUTSTRING(1,'('k := 1')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ9¨);
              OUTSTRING(1,'('k := 1.0')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ10¨);
              OUTSTRING(1,'('k := l + m')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ11¨);
              OUTSTRING(1,'('k := l * m')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ12¨);
              OUTSTRING(1,'('k := l / m')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ13¨);
              OUTSTRING(1,'('k := l')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ14¨);
              OUTSTRING(1,'('x := l')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ15¨);
              OUTSTRING(1,'('l := y')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ16¨);
              OUTSTRING(1,'('x := y ** 2')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ17¨);
              OUTSTRING(1,'('x := y ** 3')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ18¨);
              OUTSTRING(1,'('x := y ** z')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ19¨);
              OUTSTRING(1,'('e1Ý1¨ := 1')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ20¨);
              OUTSTRING(1,'('e2Ý1,1¨ := 1')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ21¨);
              OUTSTRING(1,'('e3Ý1,1,1¨ := 1')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ22¨);
              OUTSTRING(1,'('l := e1Ý1¨')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ23¨);
              OUTSTRING(1,'('begin real a; end')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ24¨);
              OUTSTRING(1,'('begin real aÝ1:1¨; end')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ25¨);
              OUTSTRING(1,'('begin real aÝ1:500¨; end')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ26¨);
              OUTSTRING(1,'('begin real aÝ1:1,1:1¨; end')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ27¨);
              OUTSTRING(1,'('begin real aÝ1:1,1:1,1:1¨; end')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ28¨);
              OUTSTRING(1,'('begin goto lab; lab: end')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ29¨);
              OUTSTRING(1,'('begin switch s := q; goto sÝ1¨; q: end')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ30¨);
              OUTSTRING(1,'('x := sin(y)')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ31¨);
              OUTSTRING(1,'('x := cos(y)')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ32¨);
              OUTSTRING(1,'('x := abs(y)')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ33¨);
              OUTSTRING(1,'('x := exp(y)')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ34¨);
              OUTSTRING(1,'('x := ln(y)')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ35¨);
              OUTSTRING(1,'('x := sqrt(y)')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ36¨);
              OUTSTRING(1,'('x := arctan(y)')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ37¨);
              OUTSTRING(1,'('x := sign(y)')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ38¨);
              OUTSTRING(1,'('x := entier(y)')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ39¨);
              OUTSTRING(1,'('p0')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ40¨);
              OUTSTRING(1,'('p1(x)')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ41¨);
              OUTSTRING(1,'('p2(x,y)')');
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ42¨);
              OUTSTRING(1,'('p3(x,y,z)')');
              'COMMENT' print DO loop overhead;
              SYSACT(1,14,1);
              OUTINTEGER(1,#TTÝ43¨);
              OUTSTRING(1,'('DO Loop overhead')');
         'END';

    'INTEGER' 'PROCEDURE' CPUTIM; 'CODE';
           'COMMENT' Procedure that returns the current accumulated
                     job step processor time in microseconds in the
                     MVS 3.8J environment;

    'COMMENT' Set line-length = 120, Set lines-per-page = 62, OPEN;
    SYSACT(1,6,120);
    SYSACT(1,8,62);
    SYSACT(1,12,1);
    SYSACT(1,2,10);
    OUTSTRING (1,'('Algol F Statement Timings')');
    SYSACT(1,14,1);
    OUTSTRING(1,'('Picoseconds  Statement')');

    x := y := z := 1.0;
    l := k := m := 1;
    e1Ý1¨ := 1;
    case := 1;

         'COMMENT' Case 01;
    n := 100000;
         'COMMENT' n should be given a large enough value
                   for the resolution of the clock not to
                   be a limiting factor to the accuracy.
                   If n is made too large then processor time
                   is wasted;
    #TTÝ1¨ := CPUTIM;
         'COMMENT' #TTÝ1¨ equals program initialization overhead;

         'COMMENT' Case 02;
    case := case + 1;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              x := 1.0; x := 1.0; x := 1.0; x := 1.0; x := 1.0;
              x := 1.0; x := 1.0; x := 1.0; x := 1.0; x := 1.0;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 03;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              x := 1; x := 1; x := 1; x := 1; x := 1;
              x := 1; x := 1; x := 1; x := 1; x := 1;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 04;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              x := y; x := y; x := y; x := y;
              x := y; x := y; x := y; x := y;
              x := y; x := y; x := y; x := y;
              x := y;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 05;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              x := y + z; x := y + z; x := y + z; x := y + z;
              x := y + z; x := y + z; x := y + z; x := y + z;
              x := y + z; x := y + z;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 06;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              x := y * z; x := y * z; x := y * z; x := y * z;
              x := y * z; x := y * z; x := y * z; x := y * z;
              x := y * z; x := y * z;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 07;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              x := y/z; x := y/z; x := y/z; x := y/z;
              x := y/z; x := y/z; x := y/z; x := y/z;
              x := y/z; x := y/z;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 08;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              k := 1; k := 1; k := 1; k := 1;
              k := 1; k := 1; k := 1; k := 1;
              k := 1; k := 1;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 09;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              k := 1.0; k := 1.0; k := 1.0; k := 1.0;
              k := 1.0; k := 1.0; k := 1.0; k := 1.0;
              k := 1.0; k := 1.0;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 10;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              k := l + m; k := l + m;
              k := l + m; k := l + m;
              k := l + m; k := l + m;
              k := l + m; k := l + m;
              k := l + m; k := l + m;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 11;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              k := l * m; k := l * m; k := l * m;
              k := l * m; k := l * m; k := l * m;
              k := l * m; k := l * m; k := l * m;
              k := l * m;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 12;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              k := l / m; k := l / m; k := l / m;
              k := l / m; k := l / m; k := l / m;
              k := l / m; k := l / m; k := l / m;
              k := l / m;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 13;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              k := l; k := l; k := l;
              k := l; k := l; k := l;
              k := l; k := l; k := l;
              k := l; k := l; k := l;
              k := l;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 14;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              x := l; x := l; x := l; x := l;
              x := l; x := l; x := l; x := l;
              x := l; x := l;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 15;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              l := y; l := y; l := y;
              l := y; l := y; l := y;
              l := y; l := y; l := y;
              l := y;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 16;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              x := y ** 2; x := y ** 2;
              x := y ** 2; x := y ** 2;
              x := y ** 2; x := y ** 2;
              x := y ** 2; x := y ** 2;
              x := y ** 2; x := y ** 2;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 17;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              x := y ** 3; x := y ** 3;
              x := y ** 3; x := y ** 3;
              x := y ** 3; x := y ** 3;
              x := y ** 3; x := y ** 3;
              x := y ** 3; x := y ** 3;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 18;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              x := y ** z;       x := y ** z;
              x := y ** z;       x := y ** z;
              x := y ** z;       x := y ** z;
              x := y ** z;       x := y ** z;
              x := y ** z;       x := y ** z;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 19;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              e1Ý1¨ := 1; e1Ý1¨ := 1; e1Ý1¨ := 1;
              e1Ý1¨ := 1; e1Ý1¨ := 1; e1Ý1¨ := 1;
              e1Ý1¨ := 1; e1Ý1¨ := 1; e1Ý1¨ := 1;
              e1Ý1¨ := 1;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 20;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              e2Ý1,1¨:= 1; e2Ý1,1¨:= 1; e2Ý1,1¨:= 1;
              e2Ý1,1¨:= 1; e2Ý1,1¨:= 1; e2Ý1,1¨:= 1;
              e2Ý1,1¨:= 1; e2Ý1,1¨:= 1; e2Ý1,1¨:= 1;
              e2Ý1,1¨:= 1; e2Ý1,1¨:= 1;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 21;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              e3Ý1,1,1¨:= 1; e3Ý1,1,1¨ := 1;
              e3Ý1,1,1¨:= 1; e3Ý1,1,1¨ := 1;
              e3Ý1,1,1¨:= 1; e3Ý1,1,1¨ := 1;
              e3Ý1,1,1¨:= 1; e3Ý1,1,1¨ := 1;
              e3Ý1,1,1¨:= 1; e3Ý1,1,1¨ := 1;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 22;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              l := e1Ý1¨; l := e1Ý1¨; l := e1Ý1¨;
              l := e1Ý1¨; l := e1Ý1¨; l := e1Ý1¨;
              l := e1Ý1¨; l := e1Ý1¨; l := e1Ý1¨;
              l := e1Ý1¨;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 23;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              'BEGIN'
                   'REAL' a;
              'END';
              'BEGIN'
                   'REAL' a;
              'END';
              'BEGIN'
                   'REAL' a;
              'END';
              'BEGIN'
                   'REAL' a;
              'END';
              'BEGIN'
                   'REAL' a;
              'END';
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 24;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              'BEGIN'
                   'ARRAY' aÝ1:1¨;
              'END';
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 25;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              'BEGIN'
                   'ARRAY' aÝ1:500¨;
              'END';
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 26;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              'BEGIN'
                   'ARRAY' aÝ1:1,1:1¨;
              'END';
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 27;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              'BEGIN'
                   'ARRAY' aÝ1:1,1:1,1:1¨;
              'END';
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 28;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              'GOTO' l0;
              l0: ;
              'GOTO' l1;
              l1: ;
              'GOTO' l2;
              l2: ;
              'GOTO' l3;
              l3: ;
              'GOTO' l4;
              l4: ;
              'GOTO' l5;
              l5: ;
              'GOTO' l6;
              l6: ;
              'GOTO' l7;
              l7: ;
              'GOTO' l8;
              l8: ;
              'GOTO' l9;
              l9: ;
              p0;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 29;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              'BEGIN'
                   'SWITCH' s := q; 'GOTO' sÝ1¨;
                   q:  ;
              'END';
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 30;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              x := sin(y);
              x := sin(y);
              x := sin(y);
              x := sin(y);
              x := sin(y);
              x := sin(y);
              x := sin(y);
              x := sin(y);
              x := sin(y);
              x := sin(y);
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 31;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              x := cos(y);
              x := cos(y);
              x := cos(y);
              x := cos(y);
              x := cos(y);
              x := cos(y);
              x := cos(y);
              x := cos(y);
              x := cos(y);
              x := cos(y);
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 32;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              x := abs(y); x := abs(y); x := abs(y);
              x := abs(y); x := abs(y); x := abs(y);
              x := abs(y); x := abs(y); x := abs(y);
              x := abs(y);
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 33;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              x := exp(y);
              x := exp(y);
              x := exp(y);
              x := exp(y);
              x := exp(y);
              x := exp(y);
              x := exp(y);
              x := exp(y);
              x := exp(y);
              x := exp(y);
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 34;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              x := ln(y);
              x := ln(y);
              x := ln(y);
              x := ln(y);
              x := ln(y);
              x := ln(y);
              x := ln(y);
              x := ln(y);
              x := ln(y);
              x := ln(y);
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 35;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              x := sqrt(y);
              x := sqrt(y);
              x := sqrt(y);
              x := sqrt(y);
              x := sqrt(y);
              x := sqrt(y);
              x := sqrt(y);
              x := sqrt(y);
              x := sqrt(y);
              x := sqrt(y);
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 36;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              x := arctan(y);
              x := arctan(y);
              x := arctan(y);
              x := arctan(y);
              x := arctan(y);
              x := arctan(y);
              x := arctan(y);
              x := arctan(y);
              x := arctan(y);
              x := arctan(y);
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 37;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              x := sign(y); x := sign(y); x := sign(y);
              x := sign(y); x := sign(y); x := sign(y);
              x := sign(y); x := sign(y); x := sign(y);
              x := sign(y);
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 38;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              x := entier(y); x := entier(y);
              x := entier(y); x := entier(y);
              x := entier(y); x := entier(y);
              x := entier(y); x := entier(y);
              x := entier(y); x := entier(y);
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 39;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              p0;
              p0;
              p0;
              p0;
              p0;
              p0;
              p0;
              p0;
              p0;
              p0;
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 40;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              p1(x);
              p1(x);
              p1(x);
              p1(x);
              p1(x);
              p1(x);
              p1(x);
              p1(x);
              p1(x);
              p1(x);
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 41;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
              p2(x,y);
              p2(x,y);
              p2(x,y);
              p2(x,y);
              p2(x,y);
              p2(x,y);
              p2(x,y);
              p2(x,y);
              p2(x,y);
              p2(x,y);
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 42;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         'BEGIN'
             p3(x,y,z);
             p3(x,y,z);
             p3(x,y,z);
             p3(x,y,z);
             p3(x,y,z);
             p3(x,y,z);
             p3(x,y,z);
             p3(x,y,z);
             p3(x,y,z);
             p3(x,y,z);
         'END';
    #TTÝcase¨ := CPUTIM;

    case := case + 1;
         'COMMENT' Case 43;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         ;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         ;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         ;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         ;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         ;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         ;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         ;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         ;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         ;
    'FOR' i := 1 'STEP' 1 'UNTIL' n 'DO'
         ;
    #TTÝcase¨ := CPUTIM;

    printt;

    'END';
/*
//ASMTIM   EXEC ASMFCL
//ASM.SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR
//           DD DSN=SYS1.AMODGEN,DISP=SHR
//ASM.SYSIN  DD *
CPU         TITLE 'CPUTIM - ALGOL F FUNCTION TO RETURN ACCUMULATED STEPX
                CPU TIME'
*
*        FUNCTION -
*        RETURN THE ACCUMULATED STEP CPU TIME IN MICROSECONDS WHEN
*        CALLED AS AN ALGOL F FUNCTION DECLARED AS -
*        'INTEGER' 'PROCEDURE' CPUTIM; 'CODE';
*        THIS ALGOL F FUNCTION IS DESIGNED TO OPERATE IN THE
*        MVS 3.8 ENVIRONMENT
*
*        ENVIRONMENT -
*        SEE OS/360 ALGOL F PROGRAMMERS GUIDE GC33-4000 FOR A
*        DESCRIPTION OF THE INVOKING ENVIRONMENT
*
*        STATUS -
*        THIS FUNCTION IS SERIALLY REUSEABLE BUT NOT
*        RECURSIVE OR REENTRANT
*
CPUTIM   CSECT
*
*        FSA OFFSETS
*
CAP1     EQU   X'0D4'
CAP2     EQU   X'0D8'
PROLOGFP EQU   X'0DC'
RETPROG  EQU   X'0E4'
EPILOGP  EQU   X'0E8'
CSWE1    EQU   X'0F4'
VALUCALL EQU   X'118'
*
         USING PBTAB,R11
*
*        PROGRAM BLOCK TABLE
*
PBTAB    DC    A(0)
         DC    CL4'CPUT'           NAME
         DC    A(0)
         DC    H'32'               L'DSA FOR TYPED PROCEDURE (FUNCTION)
         DC    X'08'               TYPE PROCEDURE INTEGER
         DC    AL1(0)              NUMBER OF FORMAL PARAMETERS
*
*        ENTRY BLOCK
*
CPUENT   DC    A(PBTAB)
         DC    A(0)
         DC    A(CPUCODE)
*
*        ESTABLISH ADDRESSABILITY TO THE PSA, ASCB
*
         USING PSA,R0
         USING ASCB,R4
*
CPUCODE  B     CPUCODEA
*
         DC    AL1(L'ID)
ID       DC    C'CPUTIM &SYSDATE &SYSTIME'
*
CPUCODEA STM   R14,R10,SAVEAREA+12
         L     R4,PSAAOLD          R4 -> CURRENT ASCB
         LM    R2,R3,ASCBEJST      ACCUM STEP TCB CPU TIME
         AL    R3,ASCBSRBT+4       ADD ACCUM SRB CPU TIME
         BC    12,CPUCODEB         OVERFLOW ? NO, BRANCH
         LA    R2,1(,R2)           YES, ADD CARRY
CPUCODEB A     R2,ASCBSRBT         TOTAL CPU TIME (TCB + SRB)
         SRDL  R2,(63-51)          SHIFT TO CONVERT TO MICROSECONDS
         ST    R3,24(,R10)         STORE RESULT IN DSA+24
         LM    R14,R10,SAVEAREA+12
         B     EPILOGP(,R13)       RETURN VIA EPILOG CODE IN FSA
*
SAVEAREA DC    18F'0'
*
         PRINT NOGEN
*
*        PREFIXED SAVE AREA
*
         IHAPSA
*
*        ADDRESS SPACE CONTROL BLOCK
*
         IHAASCB
*
         PRINT GEN
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END CPUENT
/*
//LKED.SYSLMOD DD DSN=&&GOSET(CPUTIM),DISP=(OLD,PASS)
//GOIVP4  EXEC PGM=GO
//STEPLIB  DD  DSN=&&GOSET,DISP=(OLD,PASS)
//ALGLDD01 DD  SYSOUT=*
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  UNIT=VIO,SPACE=(1024,(20,10))
//
