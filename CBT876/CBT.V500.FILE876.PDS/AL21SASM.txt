./ ADD NAME=IEX00    0201-12230-12230-1200-00400-00400-00000-LEVEL
X00      TITLE 'IEX00 - COMPILER DIRECTORY, ALGOL F'
*
*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER
*
*        FUNCTION/OPERATION -
*        THIS MODULE HAS TWO FUNCTIONS -
*        1. IT PROVIDES THE INITIAL ENTRY POINT TO AND FINAL
*           EXIT POINT FROM THE ALGOL COMPILER
*        2. IT CONTAINS ROUTINES AND DATA WHICH MAY BE NEEDED BY
*           SOME OR ALL OF THE FOLLOWING COMPILER PHASES
*
*        ENTRY POINTS -
*        IEX00000 - INITIAL ENTRY POINT. MAY BE ENTERED BY AN
*                   JCL EXEC STATEMENT OR BY ANY ONE OF THE
*                   MACROS LINK, CALL, XCTL OR ATTACH
*        IEX00PIC - PROGRAM INTERRUPT ROUTINE
*        IEX00ED1 - END OF DATA ROUTINE FOR SYSUT1
*        EODAD2   - END OF DATA ROUTINE FOR SYSUT2
*        EODAD3   - END OF DATA ROUTINE FOR SYSUT3
*        IEX00EDI - END OF DATA ROUTINE FOR SYSIN
*                   (THE FOUR END OF DATA ROUTINES ABOVE ARE
*                   DUMMIES WHICH ONLY TRANSFER CONTROL TO THE
*                   ACTUAL ROUTINES, THE ADDRESSES OF WHICH HAVE
*                   BEEN STORED IN THE COMMON WORK AREA)
*        IEX00SYN - SYNCHRONOUS ERROR ROUTINE FOR ALL DATA SETS
*                   EXCEPT SYSPRINT
*        SYNPR    - SYNCHRONOUS ERROR ROUTINE FOR SYSPRINT
*        IEX00PRI - A COMMON SUBROUTINE FOR WRITING OUTPUT TO
*                   SYSPRINT
*
*        INPUT - N/A
*
*        OUTPUT -
*        THE SUBROUTINE PRINT EXECUTES ALL OUTPUT OPERATIONS ON
*        SYSPRINT
*        RECORD LENGTH IS 121 BYTES WITH ASA CONTROL CHARACTERS
*
*        EXTERNAL ROUTINES -
*        IEX00001 - THE COMMON WORK AREA
*        THIS IS NOT AN EXECUTABLE ROUTINE BUT RATHER A
*        COLLECTION OF TABLES, DATA AND WORK AREAS WHICH ARE
*        NEEDED BY SOME OR ALL OF THE COMPILER PHASES, THUS
*        SUPPLEMENTING THE FUNCTION OF THIS MODULE. IT IS
*        ASSEMBLED SEPARATELY AND LINKAGE EDITED WITH THIS
*        MODULE. ITS CONTENTS AND FORMAT CAN BE FOUND IN THE
*        DUMMY CONTROL SECTION WORKAREA
*
*        IEX10000 - THE COMPILER INITIALIZATION PHASE
*        THE WHOLE CHAIN OF COMPILER PHASES STARTING WITH
*        IEX10000 AND ENDING WITH IEX51002 CAN BE REGARDED AS A
*        SUBROUTINE TO THIS MODULE. IT IS ENTERED BY A MACRO
*        LINK EP=IEX10000. ON ENTRY, R0 CONTAINS THE ADDRESS
*        OF THE COMMON WORK AREA. CONTROL IS FINALLY RETURNED TO
*        THIS MODULE FROM IEX51002 BY A RETURN MACRO WITH THE
*        COMPLETION CODE IN R15
*
*        EXITS - NORMAL -
*        THE FINAL EXIT FROM THE COMPILER IS BY A RETURN MACRO
*        TO THE INVOKING PROGRAM. R15 CONTAINS A RETURN
*        CODE TO INDICATE WHETHER THE COMPILATION WAS SUCCESSFUL
*        OR NOT
*
*        EXIT FROM THE SUBROUTINE PRINT IS BY A RETURN MACRO
*        R1 CONTAINS THE ADDR OF A BUFFER AREA INTO
*        WHICH THE NEXT OUTPUT LINE CAN BE MOVED
*
*        EXITS - ERRORS -
*        EXIT FROM THE COMMON ERROR ROUTINES PIROUT, SYNAD AND
*        SYNPR IS NORMALLY TO AN ERROR ROUTINE WHICH IS PRIVATE
*        TO EACH COMPILER PHASE. THE ADDR OF THIS ROUTINE HAS
*        BEEN STORED IN ERET IN THE COMMON WORK AREA. HOWEVER, IF
*        THE PIROUT ROUTINE IS ENTERED FOR THE SECOND TIME, EXIT
*        IS MADE TO THE ROUTINE GOTOEND IN THIS MODULE WHICH IN
*        ITS TURN XCTL'S TO THE TERMINATING PHASE IEX51002
*
*        EXIT FROM THE ROUTINES SYNAD AND SYNPR IS BY LOADING
*        ERET INTO R15 AND BRANCHING
*
*        EXIT FROM THE ROUTINE PIROUT IS BY MOVING THE RETURN
*        ADDRESS INTO THE OLD PSW AND EXECUTING A RETURN MACRO.
*
*        TABLES/WORK AREAS -
*        SAVE     - THE SAVE AREA IN STANDARD FORMAT
*        IEX00PIC - THE PROGRAM INTERRUPT CONTROL AREA
*        SYSPRINT - DCB FOR SYSPRINT
*        SYSLIN   - DCB FOR SYSLIN
*        SYSPUNCH - DCB FOR SYSPUNCH
*        SYSUT2   - DCB FOR SYSUT2
*        SYSUT3   - DCB FOR SYSUT3
*        WORKAREA - THE COMMON WORKAREA IN THE EXTERNAL CONTROL
*                   SECTION IEX0001
*
*        ATTRIBUTES - NOT SERIALLY REUSABLE
*
*        NOTES -
*        THIS MODULE IS TO BE LINKAGE EDITED WITH THE COMMON
*        WORK AREA (MODULE IEX00001). THE RESULTING LOAD MODULE
*        FORMS THE RESIDENT PART (IEX00) OF THE ALGOL COMPILER
*
*        THE OPERATION OF THIS MODULE DEPENDS UPON AN INTERNAL
*        REPRESENTATION OF THE EXTERNAL CHARACTER SET WHICH IS
*        EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME
*
IEX00000 CSECT
*
*        BIT PATTERNS
*
ONSW     EQU   X'F0'                    ON SWITCH IN BRANCH INSTR
OFFSW    EQU   X'0F'                    OFF SWITCH IN BRANCH INSTR
*
*        ENTRY POINTS
*
         ENTRY IEX00LIN,IEX00PCH,IEX00PRT,IEX00UT2,IEX00UT3
         ENTRY IEX00SYN,IEX00ED1,IEX00EDI,IEX00PIC,IEX00PRI
*
         USING IEX00000,R15
*
         SAVE  (14,12),,'IEX00000 LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LA    R2,SAVE
         ST    R13,SAVE+4
         ST    R2,8(,R13)
         LR    R13,R2
         L     R0,=V(IEX00001)         R0 -> COMMON WORKAREA
*
         LINK  EP=IEX10                LINK TO PHASE 10
*
*        TWO PARAMETERS ARE TRANSMITTED TO PHASE 10, R0
*        CONTAINS THE ADDR OF THE COMMON WORKAREA, R1 CONTAINS
*        THE ADDR OF THE PARAMETER LIST OF THE INVOKER
*
*        FINAL EXIT OF THE COMPILER
*
*        PHASE 51 GENERATED THE RETURN CODE IN R15
*        THE RETURN CODE IS PASSED BACK TO THE INVOKER
*
         BALR  R14,0
         USING *,R14
         L     R13,SAVE+4
*
         RETURN (14,12),RC=(15)
*
*        SAVEAREA FOR THIS LEVEL OF CONTROL
*
SAVE     DC    18F'0'
*
         LTORG
*
*        THE FOLLOWING SECTION CONTAINS -
*        THE PROGRAM INTERRUPT CONTROL AREA
*        THE PROGRAM CHECK
*        AND I/O ERROR ROUTINES
*        THE PRINT ROUTINE AND THE DCBS FOR SYSLIN, SYSPUNCH,
*        SYSPRINT, SYSUT2 AND SYSUT3
*
         USING WORKAREA,R13
*
*        PROGRAM INTERRUPT CONTROL AREA
*
IEX00PIC SPIE  PIROUT,((1,15)),MF=L
*
*        PROGRAM INTERRUPT ROUTINE
*
         USING *,R15
PIROUT   TM    COMPFLGS+1,TERM         PROG INTERRUPT IN
*                                      TERMINATING PHASE ?
         BO    TERMERR                 YES, BRANCH
         TM    COMPFLGS+1,ERR
         BO    ERRERR                  PROG INTERRUPT IN ERROR RTN
         STM   R4,R7,PISAVE            SAVE REGISTERS
         L     R6,NEXTERR              ADDR OF NEXT BYTE IN ERROR POOL
         MVC   0(2,R6),=AL1(20,209)    PATTERN FOR MSG 209
         MVC   2(2,R6),SEMCNT          SEMICOLON COUNTER
         TM    COMPFLGS+2,NOSC         SEMICOLON COUNTER VALID ?
         BZ    *+8                     YES, BRANCH
         OI    0(R6),X'80'             INDICATE SCNTR NOT VALID
         SR    R7,R7                   INITIALIZE INDEX
         L     R5,4(R1)                FIRST HALF OF PSW
LOOP     SR    R4,R4
         SLDL  R4,4                    GET HALF A BYTE OF OLD PSW
         STC   R4,4(R7,R6)             STORE FOR CONVERSION
         LA    R7,1(R7)                INCREASE INDEX
         CH    R7,=H'8'                PERFORM LOOP
         BL    LOOP                    EIGHT TIMES
         L     R5,8(,R1)               SECOND HALF OF PSW
LOOP2    SR    R4,R4
         SLDL  R4,4                    GET HALF A BYTE OF OLD PSW
         STC   R4,4(R7,R6)             STORE FOR CONVERSION
         LA    R7,1(R7)                INCREASE INDEX
         CH    R7,=H'16'               PERFORM LOOP
         BL    LOOP2                   EIGHT TIMES
         TR    4(16,R6),=C'0123456789ABCDEF' TRANSLATE TO PRINTABLE HEX
         LA    R6,20(R6)               UPDATE POINTER
         ST    R6,NEXTERR              TO ERROR POOL
FIRSTERR OI    COMPFLGS+1,ERR          SET ERROR ROUT SWITCH ON
         LM    R4,R7,PISAVE            RESTORE REGISTERS
TERMERR  MVC   9(3,R1),ERET+1          ADDR OF ERR RTN TO OLD PSW
         OI    COMPFLGS,TERR           INDICATE TERMINATING ERROR
*
         RETURN
*
PISAVE   DC    4F'0'                   REGISTER SAVE AREA
*
ERRERR   MVC   9(3,R1),=AL3(GOTOEND)   SET ADDR IN OLD PSW
*
         RETURN
*
         DROP  R15
GOTOEND  BALR  R15,0
         USING *,R15
*
         XCTL  EP=IEX51002             GOTO TERMINATING PHASE
*
         DROP  R15
*
*        ENTRY OF THE END OF DATA EXIT ROUTINES
*
IEX00ED1 EQU   *
EODAD1   L     R15,EODUT1              SYSUT1
         BR    R15
*
EODAD2   L     R15,EODUT2              SYSUT2
         BR    R15
*
EODAD3   L     R15,EODUT3              SYSUT3
         BR    R15
*
IEX00EDI EQU   *
EODADIN  L     R15,EODIN               SYSIN
         BR    R15
*
*
*        SYNAD ROUTINE (ENTRY POINT FOR SYSPRINT)
*
SYNPR    OI    COMPFLGS+2,PRT          SET SYSPRINT DOWN SWITCH ON
         BALR  R15,0
*
*        SYNAD ROUTINE
*        FOR ALL DATA SETS EXCEPT SYSPRINT
*
         USING *,R15
IEX00SYN EQU   *
SYNAD    LA    R2,0(,R1)               GET DCB ADDR
*
         CLOSE ((R2))
*
         DROP  R15
         BALR  R15,0
         USING *,R15
         L     R3,NEXTERR              STORE ERROR PATTERN
         MVC   0(2,R3),PTTRN210        IN ERROR POOL
         MVC   2(2,R3),SEMCNT
         USING IHADCB,R2
         MVC   4(8,R3),DCBDDNAM
         DROP  R2
         LA    R3,12(R3)               UPDATE ERROR POINTER
         ST    R3,NEXTERR
         OI    COMPFLGS,TERR           INDICATE TERMINATING ERROR
         TM    COMPFLGS+2,PRT          SYSPRINT NOT AVAIL ?
         BZ    SYNADX                  NO, BRANCH, MUST BE OTHER DCB
         LM    R4,R14,SAVEP            RESTORE REGS FROM PRINT ROUTINE
SYNADX   L     R15,ERET                EXIT TO ERROR ROUTINE
         BR    R15                     IN CURRENT PHASE
*
PTTRN210 DC    AL1(12),AL1(210)
*
         DROP  R15
*
*        PRINTS ONE LINE ON SYSPRINT
*
*        IT ALSO TAKES CARE OF LINE COUNTING, PAGE COUNTING AND
*        PRINTING OF HEADING LINES AT THE TOP AF EACH NEW PAGE
*
*        CALLING SEQUENCE -
*        L     R15,PRTRTADD          ENTRY ADDR IN CWA
*        BALR  R14,R15
*
*        ON RETURN, R1 -> PRINT BUFFER
*
*        GENERAL REGISTERS
*
*        R6       LINE COUNTER
*        R12      SYSPRINT DCB ADDR
*        R14      RETURN ADDR
*
         USING IEX00PRI,R15
IEX00PRI STM   R14,R12,SAVEP+12
         DROP  R15
         LR    R5,R15
         USING IEX00PRI,R5
         L     R12,APRTDCB             R12 -> SYSPRINT DCB
         LH    R6,LINCNT               TEST LINE COUNTER
         CH    R6,MAXLINES
         BNH   PRINTL                  NOT HIGH, NO NEED TO PRINT HEAD
*
*        PRINT HEADINGS
*
         AP    PAGECNT,=P'1'           ADD ONE TO PAGE COUNT
         MVC   PAGENUMB,PAGEPATT       MOVE IN PAGE EDIT PATTERN
         ED    PAGENUMB,PAGECNT+2      FORMAT PAGE NUMBER
*
NOPAGENO PUT   (R12)                   REQUEST QSAM BUFFER
*
         MVC   0(L'PAGEHD1,R1),PAGEHD1 MOVE HEADING LINE 1 INTO BUFFER
*
         PUT   (R12)                   REQUEST QSAM BUFFER
*
         MVC   0(L'PAGEHD2,R1),PAGEHD2 MOVE HEADING LINE 2 INTO BUFFER
*
         PUT   (R12)                   REQUEST QSAM BUFFER
*
         MVC   0(L'PAGEHD3,R1),PAGEHD3 MOVE HEADING LINE 2 INTO BUFFER
         LA    R6,3                    PRINTED 3 LINES
*
PRINTL   PUT   (R12)                   REQUEST QSAM BUFFER
*
         MVI   0(R1),C' '
         MVC   1(120,R1),0(R1)         BLANK BUFFER
         LA    R1,11(,R1)              MAKE A LEFT HAND MARGIN
         LA    R6,1(,R6)               INCR LINE COUNTER
         STH   R6,LINCNT               SAVE UPDATED LINECNT
         LM    R14,R0,SAVEP+12         RESTORE ALL REGS EXCEPT R1
         LM    R2,R12,SAVEP+28
         SR    R15,R15
         BR    R14                     RETURN TO CALLER
*
SAVEP    DC    18F'0'                  REG SAVE AREA
*
PAGEPATT DC    XL4'40202020'           PAGE NUMBER ED PATTERN
*
         LTORG
*
*        PRINT NOGEN
*
*        DATA CONTROL BLOCKS
*
SYSPRINT DCB   DDNAME=SYSPRINT,                                        C
               DSORG=PS,                                               C
               MACRF=(PL),                                             C
               RECFM=FBA,                                              C
               LRECL=121,                                              C
               SYNAD=SYNPR
*
SYSLIN   DCB   DDNAME=SYSLIN,                                          C
               DSORG=PS,                                               C
               MACRF=(PL),                                             C
               RECFM=FB,                                               C
               LRECL=80,                                               C
               SYNAD=SYNAD
*
SYSPUNCH DCB   DDNAME=SYSPUNCH,                                        C
               DSORG=PS,                                               C
               MACRF=(PL),                                             C
               RECFM=FB,                                               C
               LRECL=80,                                               C
               SYNAD=SYNAD
*
SYSUT2   DCB   DDNAME=SYSUT2,                                          C
               DSORG=PS,                                               C
               MACRF=(R,W),                                            C
               RECFM=F,                                                C
               SYNAD=SYNAD,                                            C
               EODAD=EODAD2
*
SYSUT3   DCB   DDNAME=SYSUT3,                                          C
               DSORG=PS,                                               C
               MACRF=(RP,WP),                                          C
               BLKSIZE=2000,                                           C
               RECFM=U,                                                C
               SYNAD=SYNAD,                                            C
               EODAD=EODAD3
*
*
*        PRINT GEN
*
IEX00PRT EQU   SYSPRINT
IEX00LIN EQU   SYSLIN
IEX00PCH EQU   SYSPUNCH
IEX00UT2 EQU   SYSUT2
IEX00UT3 EQU   SYSUT3
*
WORKAREA DSECT
*
         COPY  WORKAREA
*
*        DUMMY CONTROL SECTION TO PROVIDE ADDRESSABILITY OF DCB
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(DA)
*
         PRINT GEN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         END
./ ADD NAME=IEX10    0201-12230-12230-1200-00751-00751-00000-LEVEL
X10      TITLE 'IEX10 - COMPILER INITIALIZATION PHASE, ALGOL F'
*
*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER
*
*        FUNCTION/OPERATION -
*        THIS MODULE PERFORMS THE FOLLOWING INITIALIZATION
*        ACTIONS -
*        1. SAVE THE REGISTERS AND ESTABLISH THE LOWER
*           PART OF THE COMMON WORKAREA AS THE NEW SAVEAREA
*           TO BE USED THROUGHOUT THE COMPILATION
*        2. EXECUTE A SPIE MACRO
*        3. SCAN THE OPTION PARAMETER FIELD PROVIDED BY THE USER
*           AND SET THE SWITCHES IN COMPFLGS ACCORDINGLY
*        4. IF PROVIDED BY THE USER, INSERT NEW DD NAMES INTO
*           THE DCB'S AND STORE THE INITIAL PAGECOUNT IN THE COMMON
*           COMMON WORKAREA
*        5. OBTAIN STORAGE FOR THE ERROR POOL AND MOVE ANY ERROR
*           PATTERNS ALREADY STORED FROM THE PRELIMINARY ERROR POOL
*           INTO THE NEW POOL
*        6. COMPLETE AND OPEN THE DCB'S FOR ALL DATASETS TO BE USED
*        7. OBTAIN THE TIME AND DATE WITH A TIME MACRO
*           STORE IT IN EDITED FORM IN A HEADLINE, WHICH IS
*           PRINTED AT THE TOP OF THE FIRST PAGE
*        8. TRANSFER CONTROL TO THE SCANI/II PHASE (IEX11)
*
*        IF ERRORS ARE DETECTED IN THE STEPS DESCRIBED ABOVE
*        (SUCH AS INVALID OPTION PARAMETERS OR INCORRECT DD
*        CARDS), SOME OF THE STEPS MAY BE BYPASSED, AND AN ERROR
*        EXIT MAY BE TAKEN
*
*        ENTRY POINTS -
*        IEX10000 - THE ONLY ENTRY POINT TO THIS MODULE
*                   CONTROL IS TRANSFERRED HERE FROM IEX00 BY THE
*                   MACRO LINK EP=IEX10. R0 THEN CONTAINS THE
*                   ADDR OF THE COMMON WORKAREA AND R1 THE ADDR
*                   OF THE PARAMETER LIST PROVIDED BY THE USER
*
*        INPUT - N/A
*
*        OUTPUT -
*        THE TEXT STORED AT FIRSTLIN IS OUTPUT TO SYSPRINT AS A
*        91-CHARACTER RECORD WITH MACHINE CONTROL CHARACTER
*
*        EXTERNAL ROUTINES - N/A
*
*        IF NO TERMINATING ERRORS ARE FOUND, CONTROL IS
*        TRANSFERRED TO THE SCANI/II PHASE BY MEANS OF THE MACRO
*        'XCTL EP=IEX11'
*
*        EXITS - ERRORS -
*        IF A PROGRAM CHECK OR UNRECOVERABLE I/O ERROR OCCURS
*        DURING ONE OF THE INITIALIZATION STEPS, CONTROL IS
*        TRANSFERRED (VIA AN ERROR ROUTINE IN IEX00) TO THE
*        ROUTINE GOTOTERM IN THIS MODULE. FROM THERE AN EXIT IS
*        MADE TO THE TERMINATING PHASE BY MEANS OF THE MACRO
*        XCTL EP=IEX51002
*
*        IF ANY OTHER TERMINATING ERROR IS DETECTED, CONTROL IS
*        TRANSFERRED TO THE ROUTINE GOTOEDIT IN THIS MODULE. FROM
*        THERE AN EXIT IS MADE TO THE ERROR EDITING MODULE BY
*        MEANS OF THE MACRO XCTL EP=IEX21000
*
*        TABLES/WORK AREAS -
*        STARTING AT PTRN200 - ERROR PATTERNS FOR ALL
*                   ERRORS WHICH MAY BE DETECTED IN THIS MODULE
*        FIRSTLIN - THE FIRST OUTPUT LINE TO BE PRINTED
*                   CONTAINS PROGRAM IDENTIFICATION AND
*                   LEVEL AND THE DATE OF THE RUN
*        PARMLIST - A TABLE USED FOR DECODING THE OPTION
*                   PARAMETERS
*
*        ATTRIBUTES - NOT REUSABLE
*
*        NOTES -
*        THIS MODULE IS ONLY INTENDED TO BE USED IN CONNECTION
*        WITH THE OTHER MODULES COMPRISING THE ALGOL COMPILER
*
*        THE OPERATION OF THIS MODULE DEPENDS UPON AN INTERNAL
*        REPRESENTATION OF THE EXTERNAL CHARACTER SET WHICH IS
*        EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME
*
IEX10000 CSECT
*
*        REGISTER ASSIGNMENTS
*
*        R4         RUNNING ADDR OF PARAMETER FIELD MINUS 2
*        R5         ADDR OF BYTE FOLLOWING LAST BYTE OF FIELD MINUS 2
*        R6         RUNNING ADDR OF PARAMETER LIST
*        R7         ADDR OF LAST ENTRY OF PARAMETER LIST
*        R8         LENGTH-1 OF PARAMETER
*        R9         CURRENT FIELD IN ERROR POOL
*        R10        NEXT FIELD IN ERROR POOL
*        R11        BYTE COUNT OF PARAMETER IN ERROR
*
         SAVE  (14,12),,'IEX10000 LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R2,R15                  SET BASE
         USING IEX10000,R2
         ST    R0,8(R13)               ADDR OF LOWER LEVEL SAVAREA
         LR    R12,R13
         LR    R13,R0
         ST    R12,4(R13)              ADDR OF HIGHER LEVEL SAVEAREA
         USING WORKAREA,R13
*
*        EXECUTE THE SPIE MACRO
*
         L     R3,PICAADD              ADDR OF PICA OF COMPILER
*
         SPIE  MF=(E,(3))
*
         ST    R1,PICAADD              STORE ADDR OF OLD PICA IN
         MVC   ERET,=A(GOTOTERM)       ERROR ROUT FOR NEXT PART
*                                      OF PHASE
*
*        INTERROGATE THE CONTROL PARAMETERS AND SET SWITCHES IN
*        THE WORKAREA
*
         L     R14,4(,R13)
         L     R14,24(,R14)            GET CALLERS R1
         LTR   R14,R14                 ZERO ?
         BZ    BYPASSOP                YES, NO OPTIONS ARE SPECIFIED
         L     R4,0(,14)               ADDR OF PARMETER FIELD
         LA    R4,0(,R4)               RESET HIGH ORDER BYTE
         LH    R5,0(,R4)               FIELD LENGTH
         LTR   R5,R5                   NONZERO FIELD LENGTH ?
         BZ    DDNAMES                 NO CONTROL PARAMETERS SPECIFIED
         AR    R5,R4                   END OF FIELD
         LA    R7,LSTENTRY             LAST ENTRY OF LIST
         SR    R8,R8                   ZERO REG
FNDCOMMA CLI   2(R4),C','              COMMA ?
         BNE   FNDPAR                  NO, BRANCH
STEP1    LA    R4,1(,R4)               STEP FIELD
COMP1    CR    R4,R5
         BL    FNDCOMMA                IF NOT END OF FIELD YET
         TM    COMPFLGS+1,NLOAD+NDECK  NOLOAD AND NODECK ?
         BNO   DDNAMES                 NO, BRANCH
         OI    COMPFLGS,COMPMODE       YES, FORCE SYNTAX MODE ONLY
         B     DDNAMES                 END OF FIELD
*
         USING LENGTH,R6
COMPINST CLC   2(0,R4),PARAM
FNDPAR   CLC   2(5,R4),=C'SIZE='
         BE    FNDSIZE
         LA    R6,PARMLIST
NXTPAR   IC    R8,LENGTH
         EX    R8,COMPINST
         BNE   NOTFOUND
         LA    R10,1(R4,R8)            ADDR OF BYTE FOLLOWING
*                                      PARAMETER-2
         CLI   2(R10),C','             COMMA ?
         BE    SETBIT                  YES, BRANCH
         CR    R10,R5                  END OF PARAMETER FIELD ?
         BL    ERROR200                IF NO
SETBIT   LR    R4,R10
         EX    0,INSTR
         DROP  R6
         B     COMP1
*
NOTFOUND CR    R6,R7
         LA    R6,LENGTH-PARMLIST(R6)  STEP LIST ADDR
         BL    NXTPAR                  IF NOT END OF LIST YET
*
ERROR200 L     R9,NEXTERR              ADDR OF NEXT FREE BYTE
*                                      IN ERRORPOOL
         CLI   0(R9),C'X'              TEST IF THE PRELIMINARY ERROR
         BE    FULLPOOL                POOL IS FILLED
         LA    R10,16(R9)
         ST    R10,NEXTERR
         MVC   0(16,R9),PTRN200        PATTERN WITH BLANKS
*                                      TO ERROR POOL
         LA    R11,12(0)
MOVE     MVC   4(1,R9),2(R4)
         LA    R9,1(R9)
MOVENOT  LA    R4,1(R4)
         CLI   2(R4),C','
         BE    STEP1                   IF END OF PARAMETER
         CLR   R4,R5
         BNL   DDNAMES                 IF END OF PARAMETER LIST
         SH    R11,=H'1'
         BP    MOVE
         B     MOVENOT
*
FNDSIZE  LA    R10,5(R4)               ADDR OF FIRST DIGIT -2
         SR    R11,R11                 SET COUNT OF DIGITS TO ZERO
TSTDIGIT CLI   2(R10),C'0'             TEST IF
         BL    ERROR200                THE CHARACTER
         CLI   2(R10),C'9'             IS A DIGIT
         BH    ERROR200
         LA    R10,1(R10)
         CR    R10,R5                  END OF PARAMTER FIELD ?
         BE    PCKSIZE
         CLI   2(R10),C','             DIGIT IS FOLLOWED ?
*                                      BY A COMMA
         BE    PCKSIZE
         LA    R11,1(R11)              ADD 1 TO DIGIT COUNT
         CH    R11,=H'7'               TEST IF TOO MANY DIGITS
         BE    ERROR200
         B     TSTDIGIT
*
PCKINSTR PACK  FIELD1,7(0,R4)
PCKSIZE  EX    R11,PCKINSTR            L2 IS IN TEGH
         CVB   R6,FIELD1
         LR    R4,R10
         C     R6,=F'45056'            SPECIFIED STORAGE SIZE
         BL    ERROR208                IS TOO SMALL ?
         ST    R6,SIZE
         B     COMP1
*
ERROR208 L     R9,NEXTERR
         MVC   0(4,R9),PTRN208         PATTERN FOR MSG 208
*                                      TO ERROR POOL
         LA    R9,4(R9)                UPDATE POINTER TO NEXT
         CLI   0(R9),C'X'              TEST IF THE PRELIMINARY ERROR
         BE    FULLPOOL                POOL IS FILLED
         ST    R9,NEXTERR              FREE ENTRY
         B     COMP1
*
FULLPOOL MVC   0(4,R9),PTRN206         PATTERN FOR MESSAGE 206
         LA    R9,4(R9)                UPDATE POINTER TO
         ST    R9,NEXTERR              NEXT FREE ENTRY
         B     DDNAMES                 NO PARAMETER TESTING ANY MORE
*
*        FIND THE DD NAMES
*
DDNAMES  TM    0(14),X'80'
         BO    BYPASSOP                IF NO DDNAMES AND HEADING INFO
         L     R4,4(14)
         LH    R5,0(R4)
         LTR   R5,R5
         BZ    BYPASSOP                IF NO DDNAMES SPECIFIED
         CL    R5,=F'80'               MORE THAN TEN
         BNH   FNDDCB-4                DD NAMES
         L     R5,=F'80'               NOT ALLOWED
         L     R9,NEXTERR
         MVC   0(4,R9),PTRN207         PATTERN TO ERROR POOL
         LA    R9,4(R9)                UPDATE POINTER
         ST    R9,NEXTERR              TO ERROR POOL
         LA    R6,DCBTABLE             R6 -> TABLE OF DCB ADDRS
FNDDCB   L     R7,0(R6)
         LTR   R7,R7                   THIS DATASET EXIST ?
         BZ    NXTDDNAM                NO, BRANCH
         CLC   2(8,R4),=XL8'00'        NULL DDNAME ?
         BE    NXTDDNAM                YES, BRANCH
         USING IHADCB,R7
         MVC   DCBDDNAM,2(R4)          MOVE IN OVERRIDE DDNAME
         DROP  R7
NXTDDNAM LA    R4,8(R4)                INCR DDNAME PTR
         LA    R6,4(R6)
         SH    R5,=H'8'                DECR COUNT
         BP    FNDDCB
*
*        ACQUIRE THE ERROR POOL AND THE SOURCE PROG BUFFER 1
*        STORE CONTENT OF PRELIMINARY ERROR POOL IN NEW ERROR
*        POOL
*
BYPASSOP L     R0,POOLS                SIZE OF ERROR POOL
         LR    R4,R0
         A     R0,SRCE1S               SIZE OF SOURCE PROG BUFFER 1
         LR    R6,R0                   SIZE OF TOTAL AREA
*
         GETMAIN R,LV=(0)
*
         XI    COMPFLGS+1,NOBUF        COMMON BUFFER AREA PRESENT
         L     R5,NEXTERR              ADDR OF NEXT FREE BYTE
*                                      IN PREL POOL
         LA    R7,PRELPOOL             ADDR OF BEGIN OF PREL POOL
         SR    R5,R7                   NUMBER OF BYTES IN ERROR POOL
         EX    R5,MVCPOOL
         B     JUMPEXEA                BRANCH AROUND MVC INSTR
*
MVCPOOL  MVC   0(0,R1),PRELPOOL        EXE INSTRUCTION
*
JUMPEXEA ST    R1,ERRPOOL              ADDR OF FIRST BYTE OF POOL
         AR    R5,R1                   ADDR OF NEXT FREE BYTE
         ST    R5,NEXTERR
         AR    R4,R1                   ADDR OF END OF POOL +1
         ST    R4,SRCE1ADD             ADDR OF SOURCE PROG BUFFER 1
         AR    R6,R1                   END ADDR OF SOURCE PROG BUFFER 1
         ST    R6,SRCE1END
         SH    R4,=H'24'               ADDR OF END OF POOL-23
         ST    R4,ENDPOOL
*
*        COMPLETE THE DCBS
*
         LM    R3,R12,DCBTABLE         ADDRS OF THE DCBS
*                                      R4, R5, R6 NOT USED
         USING IHADCB,R3               SYSLIN DCB
         MVC   DCBEXLST+1(3),=AL3(LINEX)  ADDR OF EXLIST
         DROP  R3
         USING IHADCB,R7               SYSIN DCB
         MVC   DCBEXLST+1(3),=AL3(INEX)  ADDR OF EXLIST
         DROP  R7
         USING IHADCB,R8
         MVC   DCBEXLSA,=AL3(PRINTEX)  EXLIST FOR PRINT DCB
         DROP  R8
         USING IHADCB,R9               SYSPUNCH DCB
         MVC   DCBEXLST+1(3),=AL3(PCHEX)  ADDR OF EXLIST
         DROP  R9
         USING IHADCB,R10              SYSUT1 DCB
         LH    R4,SRCE1S+2             SOURCE PROG BUFFER 1 SIZE
         STH   R4,DCBBLKSI             BLOCK SIZE
         DROP  R10
         USING IHADCB,R11              SYSUT2 DCB
         STH   R4,DCBBLKSI             BLOCK SIZE
         DROP  R11
         MVC   ERET,=A(OPEXERR)        ERROR ROUTINE FOR OPEN EXIT
*                                      ROUTINES
*
*        OPEN THE SYSLIN, SYSPRINT, SYSPUNCH, SYSUT2 AND SYSUT3 DCBS
*
         OPEN  ((3),OUTPUT,(8),OUTPUT,(9),OUTPUT,(11),OUTIN,(12),OUTIN)
*
         OPEN  ((10),OUTIN,(R7),INPUT)  OPEN SYSUT1 AND SYSIN DCBS
*
         MVC   ERET,=A(GOTOTERM)
*
*        TEST IF THE SYSPRINT DCB HAS BEEN OPENED
*
         USING IHADCB,R8
TSTDCB   TM    DCBOFLGS,DCBOFOPN       OPEN SUCCESSFULL ?
         DROP  R8
         BO    EDITDATE                YES, BRANCH
         OI    COMPFLGS+2,PRTNO        SYSPRINT DCB FAILED TO OPEN
         LR    R7,R8                   DCB ADDR
         L     R4,NEXTERR
         B     ERROR201
*
*        GET DATE AND TRANSLATE IT TO DD MMM YYYY HH:MM:SS
*
EDITDATE TIME  DEC                     GET SYSTEM DATE
*
         STM   R0,R1,TEMP2             STORE SYSTEM TIME AND DATE
*                                      INTO TEMP2 AND TEMP3
         ED    HEADTIME,TEMP2          FORMAT TIME
         UNPK  TEMP(3),TEMP3+1(2)      UNPACK YY
         MVC   HEADYEAR+2(2),TEMP      MOVE YEAR ACROSS
         ZAP   TEMP1,TEMP3+2(2)        JULIN DAY NO INTO DOUBLE WORD
         CVB   R14,TEMP1               GET JULIAN DAY IN BINARY
         LA    R15,MNTHTBL             R15 -> MNTHTBL
         SH    R15,=H'8'               ADJUST ADDR FOR FIRST ITERATION
         TM    TEMP3+1,X'01'           IF ODD YEAR THEN
         BO    NOTLEAP                 NOT LEAP YEAR
         TM    TEMP3+1,X'12'           TEST FOR LEAP (OK TILL 2099)
         BNM   NEXTMNTH                IF MIXED NOT LEAP YEAR
NOTLEAP  CH    R14,H60                 DDD AFTER 28TH FEBRUARY?
         BL    NEXTMNTH                NO, LEAP YEAR IRRELEVANT
         LA    R14,1(,R14)             YES, FUDGE DDD ACCORDINGLY
NEXTMNTH LA    R15,8(,R15)             INCREMENT THRU MONTH TABLE
         SH    R14,0(,R15)             DECREASE NUMBER OF DAYS
         BP    NEXTMNTH                NOT YET, TRY NEXT MONTH
*                                      FOUND THE CORRECT MONTH
         AH    R14,0(,R15)             ADD BACK THE DAYS IN MONTH
         CVD   R14,TEMP1               GET DAY OF MONTH
         OI    TEMP1+7,X'0F'           MAKE UNPK RESULT PRINTABLE
         UNPK  HEADDAY,TEMP1+6(2)      FORMAT DAY OF MONTH
         MVC   HEADMON,2(R15)          MOVE IN MONTH NAME
*
*        SETUP HEADING LINE
*
         MVC   PAGEHD1,HEADING         FIRST LINE ON PAGE
*
         MVC   ERET,=A(GOTOEDIT)       ERROR ROUTINE FOR REST OF PHASE
*
*        TEST IF THE OTHER DCBS HAVE BEEN OPENED
*
         LM    R3,R12,DCBTABLE         R3 -> SYSLIN DCB
         L     R4,NEXTERR
         USING IHADCB,R3
         TM    COMPFLGS+1,NLOAD        NOLOAD SPECIFIED ?
         BO    TSTPUNCH                YES, BRANCH
         TM    DCBOFLGS,DCBOFOPN       DCB OPENED SUCCESSFULLY ?
         BO    TSTPUNCH                YES, BRANCH
         OI    COMPFLGS+1,NLOAD        NO, SET NOLOAD OPTION
         MVC   0(4,R4),PTRN202         PATTERN FOR MSG 202
         LA    R4,4(R4)                POINTER TO NEXT FREE ENTRY
         DROP  R3
         USING IHADCB,R9               R9 -> SYSPUNCH
TSTPUNCH TM    COMPFLGS+1,NDECK        NODECK SPECIFIED ?
         BO    TSTIN                   YES, BRANCH
         TM    DCBOFLGS,DCBOFOPN       SYSPUNCH DCB OPEN SUCESSFULLY ?
         BO    TSTIN                   YES, BRANCH
         OI    COMPFLGS+1,NDECK        NO, SET NODECK OPTION
         MVC   0(4,R4),PTRN203         PATTERN FOR MSG 203
         LA    R4,4(R4)                POINTER TO NEXT FREE ENTRY
         DROP  R9
*
TSTIN    BAL   R14,TSTDCBRT            DCB ADDR FOR SYSIN IS IN REG 7
         LR    R7,R10                  TEST SYSUT1
         BAL   R14,TSTDCBRT
         LR    R7,R11                  TEST SYSUT2
         BAL   R14,TSTDCBRT
         LR    R7,R12                  TEST SYSUT3
*
*        ENTRY IF SYSPRINT NOT OPENED
*
ERROR201 LA    R14,STPOINTR            DO NOT RETURN
         USING IHADCB,R7
TSTDCBRT TM    DCBOFLGS,DCBOFOPN       DCB OPENED ?
         BOR   R14                     YES, RETURN
         MVC   0(4,R4),PTRN201         PATTERN FOR MSG 201
         MVC   4(8,R4),DCBDDNAM        MOVE DDNAME INTO MSG
         LA    R4,12(R4)               UPDATE POINTER
         OI    COMPFLGS+1,NOGO         SET NOGO SWITCH ON
         BR    R14                     RETURN
*
         DROP  R7
STPOINTR ST    R4,NEXTERR
*
*        END OF INITIALIZATION OF THE COMPILER
*        GOTO SCAN 1/2 OR TO PHASE 21 FOR ERROR EDITING IF
*        COMPILATION IS IMPOSSIBLE
*
         TM    COMPFLGS+1,NOGO
         BO    GOTOEDIT                IF COMPILATION IMPOSSIBLE
         L     R2,=A(IEX10001)
         BR    R2                      TO INITIALIZE IEX11
*
*        DCB EXIT ROUTINES
*
         USING IHADCB,R1
*
*        SYSIN OPEN EXIT
*
INEXRT   LH    R6,DCBBLKSI             GET BLKSIZE
         LTR   R6,R6                   VALUE PROVIDED ?
         BNZR  R14                     YES, RETURN
         MVC   DCBBLKSI,DCBLRECL       NO, SET BLKSIZE TO LRECL
         BR    R14                     RETURN
*
*        SYSLIN OPEN EXIT
*
LINEXRT  LH    R6,DCBBLKSI             GET BLKSIZE
         LTR   R6,R6                   VALUE PROVIDED ?
         BNZR  R14                     YES, RETURN
         LA    R6,3200                 SET A DEFAULT OF 3200
         STH   R6,DCBBLKSI             UPDATE BLKSIZE
         BR    R14                     RETURN
*
*        SYSPUNCH OPEN EXIT
*
PCHEXRT  LH    R6,DCBBLKSI             GET BLKSIZE
         LTR   R6,R6                   VALUE PROVIDED ?
         BNZR  R14                     YES, RETURN
         MVC   DCBBLKSI,DCBLRECL       NO, SET BLKSIZE TO LRECL
         BR    R14                     RETURN
*
*        SYSPRINT OPEN EXIT
*
PRTEXRT  LH    R6,DCBBLKSI             GET BLKSIZE
         LTR   R6,R6                   VALUE PROVIDED ?
         BNZR  R14                     YES, RETURN
         MVC   DCBBLKSI,DCBLRECL       NO, SET BLKSIZE TO LRECL
         BR    R14                     RETURN
*
         DROP  R1
*
*        ERROR ROUTINES
*
*        ROUTINE FOR UNEXPECTED ERROR DURING OPEN
*        ENTERED VIA ERET
*
OPEXERR  OI    COMPFLGS+1,NOGO
         BR    R14                     GO BACK TO OPEN ROUTINE
*
         DROP  R2
*
*        EXIT TO TERMINATING PHASE IF ERROR EDITING NOT POSSIBLE
*
GOTOTERM BALR  R2,0
         USING *,R2
         BAL   R4,CLOSE
*
         XCTL  EP=IEX51002             GO TO TERMINATING PHASE
*
         DROP  R2
*
*        TERMINATE VIA ERROR EDITING PHASE
*
GOTOEDIT BALR  R2,0
         USING *,R2
         BAL   R4,CLOSE
         OI    COMPFLGS,TERR           INDICATE TERMINATING ERROR
*
         XCTL  EP=IEX21000             GO TO EDIT PHASE
*
         DROP  R2
*
*        SUBROUTINE FOR CLOSING SYSIN AND SYSUT1
*
CLOSE    BALR  R3,0
         USING *,R3
         L     R6,ASYSDCB              R6 -> SYSIN DCB
         USING IHADCB,R6
         TM    DCBOFLGS,DCBOFOPN       OPEN SUCCESFULLY ?
         DROP  R6
         BO    *+8                     YES, BRANCH
         OI    SWITCH+1,X'F0'          NO, SYSIN NOT OPENED
         L     R7,AUT1DCB              R7 -> SYSUT1 DCB
*
         CLOSE ((6),,(7))              CLOSE SYSIN AND SYSUT1
*
SWITCH   NOPR  R4                      RETURN IF SYSIN NOT OPENED
*
         FREEPOOL (R6)                 FREE SYSIN BUFFER
*
         BR    R4                      RETURN
*
         DROP  R3
*
         LTORG
*
*        DCB EXIT LIST FOR SYSIN, SYSLIN, SYSPUNCH AND SYSPRINT
*
         DC    0F'0'
INEX     DC    X'85',AL3(INEXRT)
LINEX    DC    X'85',AL3(LINEXRT)
PCHEX    DC    X'85',AL3(PCHEXRT)
PRINTEX  DC    X'85',AL3(PRTEXRT)
*
*
*        PATTERNS FOR THE ERROR MESSAGES OF THE INITIALIZATION
*        PHASE
*
*        W OPTION PARAMETER ... IS INVALID. THE PARAMETER IS
*        DISREGARDED
*
PTRN200  DC    AL1(128+16,200),AL2(0),CL12' '
*
*        T DD CARD FOR ... IS INCORRECT OR MISSING
*
PTRN201  DC    AL1(128+12,201),AL2(0)
*
*        W DD CARD FOR SYSLIN IS INCORRECT OR MISSING. OPTION
*        NOLOAD IS ASSUMED
*
PTRN202  DC    AL1(128+4,202),AL2(0)
*
*        W DD CARD FOR SYSPUNCH IS INCORRECT OF MISSING. OPTION
*        NODECK IS ASSUMED
*
PTRN203  DC    AL1(128+4,203),AL2(0)
*
*        T BLOCKSIZE SPECIFIED FOR SYSIN IS INCORRECT
*
PTRN204  DC     AL1(128+4,204),AL2(0)
*
*        W BLOCKSIZE SPECIFIED FOR ... IS INCORRECT. UNBLOCKED
*        OUTPUT IS GENERATED INSTEAD
*
PTRN205A DC    AL1(128+12,205),AL2(0),CL8'SYSLIN'
PTRN205B DC    AL1(128+12,205),AL2(0),CL8'SYSPUNCH'
PTRN205C DC    AL1(128+12,205),AL2(0),CL8'SYSPRINT'
*
*        W INCORRECT PARAMETER FIELD. NO OPTION PARAMETERS ARE
*        HANDLED ANY MORE
*
PTRN206  DC    AL1(128+4,206),AL2(0)
*
*        W POSSIBLE ERROR IN DD NAMES PARAMETER
*
PTRN207  DC    AL1(128+4,207),AL2(0)
*
*        T SIZE PARAMERER IS INCORRECT. MINIMUM STORAGE SIZE FOR
*        ALGOL F COMPILER IS 45056 BYTES
*
PTRN208  DC   AL1(128+4,208),AL2(0)
*
*        FIRST LINE OF PRINTED OUTPUT
*
HEADING  DC    CL121' '                HEADING LINE
         ORG   HEADING
         DC    C'1'                    ASA CNTL
         DC    C'360S-AL-531 LEVEL 2.1'  IDENTIFY UPDATED SOURCE
         DC    C'          OS ALGOL F'
         ORG   HEADING+87
HEADDAY  DC    C'DD'                                            |
         DC    C' '                                             |
HEADMON  DC    C'MMM'                  ALPHA 3 CHAR MONTH       |
         DC    C' '                                             |
HEADYEAR DC    C'20XX'                                          |
HEADTIME DC    XL9'4021217A21217A2121'  PATTERN FOR TIME        |
         DC    C'      '                                        |
HEADPAGE DC    C'PAGE   1'                                      |
         ORG   ,                                                V
*
*        TABLE OF OPTION PARAMETERS
*
PARMLIST DC    AL1(6)                  (LENGTH-1) OF PARAM
         DC    CL9'PROGRAM'            PARAMETER
         NI    COMPFLGS,PGR            SET SWITCH IN COMPFLGS
LENGTH   DC    AL1(8)
PARAM    DC    CL9'PROCEDURE'
INSTR    OI    COMPFLGS,PROC
         DC    AL1(4)
         DC    CL9'SHORT'
         NI    COMPFLGS,SHRT
         DC    AL1(3)
         DC    CL9'LONG'
         OI    COMPFLGS,LNG
         DC    AL1(5)
         DC    CL9'SOURCE'
         NI    COMPFLGS+1,SRCE
         DC    AL1(7)
         DC    CL9'NOSOURCE'
         OI    COMPFLGS+1,NSRCE
         DC    AL1(3)
         DC    CL9'LOAD'
         NI    COMPFLGS+1,LOAD
         DC    AL1(5)
         DC    CL9'NOLOAD'
         OI    COMPFLGS+1,NLOAD
         DC    AL1(3)
         DC    CL9'DECK'
         NI    COMPFLGS+1,DECK
         DC    AL1(5)
         DC    CL9'NODECK'
         OI    COMPFLGS+1,NDECK
         DC    AL1(5)
         DC    CL9'EBCDIC'
         NI    COMPFLGS+1,EBCDIC
         DC    AL1(5)
         DC    CL9'NOTEST'
         OI    COMPFLGS+2,NOTEST
         DC    AL1(3)
         DC    CL9'TEST'
         NI    COMPFLGS+2,TEST
         DC    AL1(2)
         DC    CL9'ISO'
         OI    COMPFLGS+1,ISO
         DC    AL1(1)
         DC    CL9'NS'
         OI    COMPFLGS+1,NSRCE
         DC    AL1(1)
         DC    CL9'ND'
         OI    COMPFLGS+1,NDECK
         DC    AL1(1)
         DC    CL9'NL'
         OI    COMPFLGS+1,NLOAD
         DC    AL1(1)
         DC    CL9'EB'
         NI    COMPFLGS+1,EBCDIC
         DC    AL1(1)
         DC    CL9'PG'
         NI    COMPFLGS,PGR
         DC    AL1(1)
         DC    CL9'PC'
         OI    COMPFLGS,PROC
         DC    AL1(1)
         DC    CL9'NT'
         OI    COMPFLGS+2,NOTEST
         DC    AL1(1)
         DC    CL9'SP'
         NI    COMPFLGS,SHRT
         DC    AL1(1)
         DC    CL9'LP'
         OI    COMPFLGS,LNG
         DC    AL1(0)
         DC    CL9'D'
         NI    COMPFLGS+1,DECK
         DC    AL1(0)
         DC    CL9'I'
         OI    COMPFLGS+1,ISO
         DC    AL1(0)
         DC    CL9'L'
         NI    COMPFLGS+1,LOAD
         DC    AL1(0)
         DC    CL9'S'
         NI    COMPFLGS+1,SRCE
LSTENTRY DC    AL1(0)
         DC    CL9'T'
         NI    COMPFLGS+2,TEST
*
*        WORKSPACE FOR TRANSLATING THE SIZE PARAMETER AND THE
*        ACTUAL DATE
*
         DC    0D'0'
FIELD1   DC    PL8'0'
*
TEMP     DC    F'0'                    TEMP WORK SLOT
TEMP1    DC    D'0'                    WORK SPACE FOR DEC TO BIN CONV
TEMP2    DC    F'0'                    TEMP WORK SLOT
TEMP3    DC    F'0'                    TEMPORARY WORK SPACE
*
*        TABLE OF THE MONTH NAMES AND THE NUMBER OF DAYS
*
MNTHTBL  DC    H'31'                   JAN DAYS IN MONTH
         DC    C'JAN '                     3 CHAR MONTH CODE
         DC    C'01'                       MONTH NUMBER
         DC    H'29'                   FEB
         DC    C'FEB '
         DC    C'02'
         DC    H'31'                   MAR
         DC    C'MAR '
         DC    C'03'
         DC    H'30'                   APR
         DC    C'APR '
         DC    C'04'
         DC    H'31'                   MAY
         DC    C'MAY '
         DC    C'05'
         DC    H'30'                   JUN
         DC    C'JUN '
         DC    C'06'
         DC    H'31'                   JUL
         DC    C'JUL '
         DC    C'07'
         DC    H'31'                   AUG
         DC    C'AUG '
         DC    C'08'
         DC    H'30'                   SEP
         DC    C'SEP '
         DC    C'09'
         DC    H'31'                   OCT
         DC    C'OCT '
         DC    C'10'
         DC    H'30'                   NOV
         DC    C'NOV '
         DC    C'11'
         DC    H'255'                  DEC (ALLOW FOR STUPID DDD)
         DC    C'DEC '
         DC    C'12'
*
H60      DC    H'60'
*
IEX10001 CSECT
*
         USING IEX10001,R2
*
*        INSTRUCTIONS FOR INITIALIZING IEX11 CAN BE INSERTED HERE
*
         XCTL  EP=IEX11000             EXIT TO NEXT PHASE
*
*        DUMMY CONTROL SECTION TO PROVIDE ADRESSABILITY OF DCB
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(DA)
*
         PRINT GEN
*
WORKAREA DSECT
*
         COPY  WORKAREA
*
*        CWA SYMBOL DEFINITIONS FOR IEX11 CAN BE INSERTED HERE
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END   IEX10000
./ ADD NAME=IEX11    0201-12230-12230-1200-04989-04989-00000-LEVEL
X11      TITLE 'IEX11 - SCAN I/II, ALGOL F'
*
*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER
*
*        FUNCTION/OPERATION -
*        TO TRANSFORM THE SOURCE PROGRAM TO MODIFICATION LEVEL 1,
*        WHICH INCLUDES A ONE FOR ONE TRANSLATION OF ALL
*        CHARACTERS, THE REPLACEMENT OF ALL ALGOL DELIMITERS BY
*        ONE BYTE OPERATORS AND THE REMOVAL OR MODIFICATION OF
*        ALL DECLARATIONS
*        1. TABULATE AND CLASSIFY ALL VALID IDENTIFIERS
*        2. ASSIGN A SERIAL PROGRAM BLOCK NUMBER TO ALL BLOCKS
*           AND PROCEDURES AND A SERIAL GROUP NUMBER TO ALL BLOCKS,
*           PROCEDURES AND FOR STATEMENTS
*        3. RECOGNIZE SYNTACTICAL ERRORS IN THE SOURCE PROGRAM
*           AND TO GENERATE APPROPRIATE ERROR PATTERNS
*        4. PRINT A LISTING ON SYSPRINT OF THE SOURCE PROGRAM IF
*           OPTION SOURCE IS SPECIFIED
*        5. PREPARE TABLES TO BE USED BY THE SUCCEEDING PHASES.
*           THE TABLES ARE PBTAB1, GROUPTABLE, AND SCOPETABLE
*
*        ENTRY POINTS -
*        IEX11000 SCAN I/II XCTL EP=IEX11000
*
*        INPUT - THE SOURCE PROGRAM IS READ IN FROM SYSIN
*
*        OUTPUT -
*        1. THE SOURCE PROGRAM, MODIFICATION LEVEL 1, IS WRITTEN
*           ON SYSUT1
*        2. AN ITAB RECORD IS WRITTEN FOR EACH BLOCK ON SYSUT3
*        3. ESD CARD FOR THE OBJECT MODULE AND TXT CARDS FOR THE
*           CONSTANTS 0 THROUGH 15 AND THE STRINGS IN THE CONSTANT
*           POOL ARE WRITTEN ON SYSLIN AND OR SYSPUNCH IF THE
*           OPTIONS LOAD AND OR DECK IS SPECIFIED
*        4. THE SOURCE PROGRAM IS LISTED ON SYSPRINT IF THE
*           SOURCE OPTION IS SPECIFIED
*
*        EXITS - NORMAL -
*        CONTROL IS GIVEN TO ITAB MANIPULATION, XCTL EP=IEX20000
*        IF NO TERMINATING ERROR HAS BEEN DETECTED
*
*        EXITS - ERROR -
*        IF A TERMINATING ERROR HAS BEEN DETECTED CONTROL IS
*        GIVEN TO THE ERROR MESSAGE HANDLING PHASE XCTL
*        EP=IEX21000
*
*        EXTERNAL ROUTINES - THE PRINT ROUTINE IN IEX00 IS USED
*
*        TABLES/WORKAREAS -
*        BPRTAB   - BRANCH ADDR TABLE
*        TESTTABL - FOR MAINLOOP SCANNING
*        TRINTEXT - FOR TRANSLATION FROM INTERNAL TO EBCDIC
*                   CHARACTER SET
*        COMTABLE - USED BY COMMENT PROGRAM
*        STRTABLE - USED BY STRING PROGRAM
*        BTABLE   - USED BY BLANK PROGRAM
*        KEYTAB   - USED BY TRANSOP
*        PTTABLE  - USED BY POINT AND POINT IN LIST PROGRAMS
*        TREXTINT - FOR TRANSLATION FROM EBCDIC TO INTERNAL
*                   CHARACTER SET
*        KFCONST  - CONTAIN THE FULL WORD CONSTANTS 0 THROUGH 15
*        ATABLE   - USED BY APOSTROF
*        SCTAB    - USED TO SAVE THE STARTING SEMICOLON COUNTER
*                   FOR THE BLOCKS
*        KEYWTAB  - TABLE OF ALGOL KEYWORDS
*        KWLUTAB  - DISPLACEMENTS INTO KEYWTAB
*        DELPRGTB - BRANCH ADDR TABLE AFTER A DELIMITER HAS
*                   BEEN FOUND
*        ARTABLE  - USED BY LIST PROGRAM
*        WA       - 80 BYTE WORKAREA WITH 17 PRECEEDING CHARACTERS,
*                   USED FOR INPUT RECORDS. THE 17 EXTRA BYTES USED
*                   TO OVERLAP BETWEEN ONE RECORD AND THE NEXT ONE
*        STACK    - USED FOR THE SCOPE STRUCTURE HANDLING
*        ITAB     - USED TO TABULATE ALL VALID IDENTIFIERS
*        SAVEPRT  - DUMMY PRINTAREA. USED TO PICK UP STRINGS FROM
*                   IN EBCDIC FORM IF THE OPTION 'NOSOURCE'
*                   IS SPECIFIED
*
*        NOTES -
*        CHARACTER CODE DEPENDENCE IF THE SOURCE PROGRAM IS IN
*        ISO CODE A SCAN IS MADE IN THE PROGRAM CIB TO EXCHANGE
*        THE CHARACTERS -
*        4C, 7B, 7C, 6C, 50,
*        WITH THE EBCDIC CHARACTERS -
*        5D, 7E, 7D, 4D, 4E
*        THEN WHEN THE SOURCE PROGRAM IN WA IS IN EBCDIC FORM IT
*        IS TRANSFERRED TO THE PRINTBUFFER, POSSIBLY THE DUMMY
*        PRINTAREA. THE SOURCE PROGRAM IN WA IS THEN TRANSLATED
*        TO INTERNAL CODE BY MEANS OF THE HEXADECIMAL TABLE
*        TREXTINT. THE INVERSE TABLE, TRANSLATING FROM INTERNAL TO
*        EBCDIC CODE, IS CALLED TRINTEXT AND IS IN CHARACTER FORM.
*        THE TRANSFER OF PRECOMPILED AND CODE PROCEDURE NAMES,
*        THE TRANSFER OF STRINGS AND CONSTANTS TO THE CONSTANT
*        POOL AND THE OPERATION OF THE ROUTINE GENERATE DEPENDS
*        ON AN INTERNAL REPRESENTATION OF THE EXTERNAL CHARACTER
*        SET WHICH IS EQUIVALENT TO THE ONE USED AT ASSEMBLY
*        TIME. THE OPERATION OF THE OTHER PARTS DOES NOT DEPEND
*        UPON A PARTICULAR INTERNAL REPRESENTATION OF THE
*        EXTERNAL CHARACTER SET
*
*        THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN
*        CONNECTION WITH THE OTHER MODULES OF THE ALGOL COMPILER.
*        IN PARTICULAR IT REQUIRES THE COMMON WORKAREA
*
*        INITIALIZATION
*        MAINLOOP AND ITS SUBPROGRAMS
*        BLANK
*        TRANSOP (*,/,(,>,<,NOT,)
*        RIGHTPAR
*        POINT
*        COLON
*        LABEL
*        LETDEL
*        ASSIGN
*        APOSTROPHE
*        SCALE
*        BLKAPOS
*        ZETAAPOS
*        NPAFAPO (NOT PERMITTED)
*        SOME GENERAL ROUTINES
*        STATE (STATEMENT PROGRAM)
*        ERROR ROUTINES
*        ITABCLEA
*        IDCHCK1
*        FINDSEMCO
*        AND TABLES AND CONSTANTS OUTSIDE CWA
*
*        COB (CHANGE OUTPUT BUFFER)
*        CIB (CHANGE INPUT BUFFER)
*        DELIMITER EROUT (DELIMITER ERROR ROUTINE)
*        NORMAL (/ OR AND NOT STEP LESS IMPL UNTIL WHILE POWER
*        EQUIU
*        NOTLESS GREATER NOTEQUAL NOT GREATER)
*        BOLCON ('TRUE', 'FALSE')
*        GIF (GOTO, IF)
*        TED (THEN, ELSE, DO)
*        BEGIN
*        BEGI (BLOCKHEAD)
*        END
*        FOREND
*        PBLCKEND
*        COM (COMMENT)
*        FOR
*        TYPE (REAL, INTEGER, BOOLEAN)
*        IER (IDENT ERROR ROUTINE)
*        CODE
*
*        IDCHECK (SPECIFIED IDENTIFIERS)
*        VALUE
*        TYPEARRAY
*        ARRAY
*        TRATE (ARRAY AND SWITCH LIST)
*        PONTLST
*        SEMCLST
*        LEFTPARL
*        RIGHTPARL
*        SLASHLST
*        COMMALST
*        COLONLST
*        SWITCH
*        STRING
*        TYPPROC
*        PROCEDURE
*        PROCEDEL (PROC LETTERSTRING)
*        ENDMISSIN (UNBALANCED BEGIN END COUNT)
*
*        TERMINATION
*
IEX11000 CSECT
*
*        R3                       OUTPUT POINTER
*        R4                       POINTS TO FIRST APOSTROPHE
*        R4                       TRANSOP REGISTER
*        R4                       LINK REGISTER FOR PRGBLOCKEND
*        R4                       LINK REGISTER FOR FDREND
*        R6                       RETURN REG FROM ERROR ROUTINES
*        R7                       ITAB POINTER
*        R8                       BASE REGISTER
*        R9                       RETURN REGISTER FROM BEGI
*        R10                      TESTLOOP AND LIST MAIN RETURN REG
*        R11                      BASE REGISTER
*        R12                      SPECIFICATION HANDLING
*        R12                      RETURN REG FROM COB
*        R14                      LABEL POINTER
*
*        INITIALIZATION
*
*        GETMAIN FOR -
*        1. KOPOOL
*        2. STACK
*        3. ITABBUF
*        4. OUTPUTAREA2
*        5. ITAB
*        ALPHA 00 IS PUT IN STACK AND SP (STACK POINTER) IS MADE
*        TO POINT TO NEXT BYTE
*        ADDR OF THE FIRST O/P AREA IS TAKEN FROM CWA AND PUT
*        IN ADDARI. THE ADDR OF SECOND O/P AREA (FROM
*        GETMAIN) IS PUT IN ADDARI+4
*        AITAB, LIGP, LPBP, AITAB AND ELI ARE INITILIZED IN
*        ITAB. HEADLINE FOR PB0 IS CREATED.
*        AITAB, LPBP, LIGP WILL POINT TO PB0 HEAD
*        AITL TO NEXT FREE ENTRY
*        ELI TO LAST POSITION+1 OF ITAB
*        APE WILL POINT TO LAST POSITION IN FIRST OUTPUT BUFFER
*        WADDARI (CURRENT OUTPUT BUFFER) WILL POINT TO FIRST
*        OUTPUT BUFFER
*        R3 WILL POINT TO FIRST O/P BUFFER
*        PRINTING OF HEADLINES IS INITIALIZED IF SOURCE WAS
*        SPECIFIED
*        SWITCHES ARE SET TO ZERO
*        FIRST ENTRIES IN TABLES ARE SET TO ZERO
*
         IEXENTRY 'IEX11000 LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IEX11000,R5,R8,R11
         LR    R5,R15
         LA    R8,2048(,R5)
         LA    R8,2048(,R8)
         LA    R11,2048(,R8)
         LA    R11,2048(,R11)
*
         USING WORKAREA,R13
         LA    R12,SLUT2
         ST    R12,ERET                INTERUPT BEFORE GETMAIN
         LH    R1,KH4096               KOPOOL
         LA    R1,1000(,R1)            STACK
         A     R1,SRCE1S               O/P BUFFER 1
         A     R1,ITAB10S              ITAB
         LA    R1,2000(,R1)            ITAB BUF
         ST    R1,POOLLEN              STORE TOTAL LENGTH
         LR    R0,R1
*
         GETMAIN R,LV=(0)              GET AREAS NEEDED
*
         ST    R1,POOLLOC              SAVE LOCATION
         LA    R12,ENDMISS             END OF DATA ADDR
         ST    R12,EODIN
         LA    R12,EODADIN
         ST    R12,ERET                ADDR AFTER GETMAIN
         ST    R1,AKOPOOL              ADDR OF KOPOOL
         LA    R1,4095(,R1)
         MVC   1(4,R1),KF0             INITIALIZE STACK
         LA    R1,2(,R1)
         ST    R1,SP                   ADDR OF SECOND BYTE IN STACK
         LA    R1,999(,R1)
         ST    R1,AITABBUF             INITIALIZE ITAB BUFFER
         LA    R1,2000(,R1)
         ST    R1,ADDARI+4                       OUTPUTAREA 2
         A     R1,SRCE1S
         ST    R1,AITAB                          ITAB
         ST    R1,LIGP                 SURROUNDING GROUP ADDR
         ST    R1,LPBP                             BLOCK ADDR
         MVI   0(R1),0                 CLEAR FIRST TWO ITAB ENTRIES
         MVC   1(21,R1),0(R1)
         MVI   3(R1),X'FF'             CONSTRUCT CONTINUATION
         MVI   5(R1),XFBLANK           LINE FOR PB0
         LA    R12,11(,R1)
         ST    R12,AITL                ADDR OF FIRST FREE ENTRY
         A     R1,ITAB10S
         ST    R1,ELI                  END OF ITAB
         L     R3,SRCE1ADD             ADDR OF FIRST OUTPUT BUFFER
         A     R3,SRCE1S
         BCTR  R3,0
         ST    R3,APE                  END OF FIRST O/P BUFFER
         L     R3,SRCE1ADD             OUTPUT AREAS CONSTANTS
         MVC   ADDARI(4),SRCE1ADD
         MVC   WADDARI(4),ADDARI       CURRENT O/P AREA ADDR
         LA    R12,SAVEPRNT            APRNTAR INITIALIZED WITH
         ST    R12,APRNTAR             DUMMY PRINT AREA ADDR
*
*        SETUP HEADING TEXT
*
         MVC   PAGEHD1D+30(L'HEAD1),HEAD1
         MVC   PAGEHD2D+4(L'HEAD2),HEAD2
         MVI   LINCNT+1,255            FORCE HEADINGS
         BAL   R9,CIB                  GET FIRST RECORD AND ADDR
*                                      OF FIRST PRINTAREA
         SR    R2,R2                   ZERO REG
         STC   R2,ONC                  ZERO COUNTERS
         STC   R2,DISP                 ZERO SWITCHES
         LA    R12,64
         ST    R12,PRPT                PROGRAM POINTER
         STH   R2,IGC                  ZERO ITAB GROUP COUNTER
         ST    R2,MGESITL
         STC   R2,PBC                  ZERO PROGRAM BLOCK COUNTER (PBC)
         STC   R2,ONC                  ZERO OUTPUT RECORD COUNTER (ONC)
         STC   R2,BITS1                ZERO SWITCHBITS
         STC   R2,BITS2
         STC   R2,BITS3
         STH   R2,SEMCNT               ZERO SEMICOLON COUNTER
         STC   R2,FSN                  ZERO FSN
         STC   R2,PBTAB1               ZERO PB0
         ST    R2,GPTAB+3              ZERO GROUP AND SCOUP TABLE
         STC   R2,SPTAB
         STC   R2,0(,R3)               FIRST BYTE IN FIRST OUTPUTRECD
         ST    R3,OPIN
         ST    R3,LAPIN                SET LABEL POINTERS
         STC   R2,OPIN+4
         LA    R12,GPTAB
         ST    R12,AGT                 ADDR TO GROUPTABLE
         L     R12,AITABBUF
         BCTR  R12,0
         ST    R12,ATOPSTAK            HIGHEST BYTE IN STACK TO USE
         B     TESTLOOP                GOTO START PROCESSING
*
EXMVC    MVC   0(1,R3),0(R4)
*
*        MAINLOOP
*
*        SCANS THE INPUT STREAM WHICH IS IN INTERNAL CODE
*
*        EVERYTHING PRECEDING THE FIRST REAL ALGOL WORD WILL BE
*        SKIPPED WITH THE HELP OF THE FALG BITS2, X'20'
*
TESTLOOP BALR  R10,0
         LR    R9,R10                  RETURN ADDR FOR CIB PROGRAM
         LR    R4,R1
         SR    R2,R2
         TRT   0(73,R1),TESTTABL       SCAN INTERNAL CODE WITH TESTTABL
         TM    BITS2,X'20'             FIRST BEGIN FOUND ?
         BZ    FIRSTSTR                NO
CONT     LR    R15,R1                  FIND LENGTH OF SCANNED BYTES
         SR    R15,R4
         BZ    SUBROUT
         BAL   R12,COB
         LA    R0,0(R15,R3)
         C     R0,APE                  SPACE LEFT IN O/P BUFFER ?
         BH    MSBLOOP
         BCTR  R15,0
         EX    R15,EXMVC               MOVE SCANNED BYTES
         LR    R3,R0                   INCREASE OUTPUT POINTER
SUBROUT  L     R6,BPRTAB(R2)
         BR    R6                      BRANCH TO PROGRAM
*
*        MSBLOOP
*
*        USED WHEN SCANNED BYTES HAS TO BE PLACED IN TWO O/P AREAS
*
MSBLOOP  L     R6,APE
         SR    R6,R3
         BCTR  R6,0
         EX    R6,EXMVC                MOVE TO FIRST O/P AREA
         LA    R3,1(R6,R3)
         BAL   R12,COBSPEB             CHANGE O/P BUFFER
         LA    R12,1(R6,R4)
         SR    R15,R6
         BCTR  R15,0
         BCTR  R15,0
         EX    R15,MOVERST             MOVE TO 2ND O/P BUFFER
         LA    R3,1(R15,R3)
         B     SUBROUT                 RETURN
*
MOVERST  MVC   0(1,R3),0(R12)
FIRSTSTR CLI   0(R1),XFQUOTE           QUOTE ?
         BE    APOSTROF
         CLI   0(R1),XFZETA            ZETA ?
         BE    CIB
         LA    R1,1(,R1)               IF NEITHER- CONTINUE SCANNING
         B     TESTLOOP
*
*        BLANK
*
*        SCANS TO THE NEXT NONBLANK CHARACTER
*        ALL BLANK CHARACTER WILL BE SKIPPED
*        USED BY MAIN LOOP AND ARRAYLIST
*
BLANK    LA    R1,1(,R1)               INCREASE INPUT POINTER
         CLI   0(R1),XFBLANK           BLANK ?
         BNER  R10                     NO, RETURN
         LA    R1,1(,R1)               YES, INCREASE INPUT POINTER
         SR    R2,R2
         TRT   0(73,R1),BTABLE         SCAN INPUT TO NEXT DELIMITER
         BR    R10                     RETURN
*
*        TRANSOP
*
*        CHECKS THE NEXT BYTE IN THE INPUT AREA AGAINS A
*        KEY IE IF ( FOUND, NEXT BYTE WILL BE CHECKED FOR /, IF
*        A SLASH IS FOUND A LEFT SQUARE BRACKET WILL BE
*        TRANSFERED OTHERWISE A (
*        USED BY MAIN LOOP AND ARRAYLIST
*
TRANSOP  LA    R4,KEYTAB(R2)           GET CORRECT ENTRY IN TABLE
INCR     LA    R1,1(,R1)
INCRA    CLC   0(1,R1),3(R4)           INPUT EQUAL EXPECTED ONE ?
         BE    TROE                    YES, TAKE SUBSTITUTE CHAR
         CLI   0(R1),XFBLANK           BLANK ?
         BE    INCR
         CLI   0(R1),XFZETA            ZETA ?
         BNE   TRONE                   IF NEITHER TAKE CHAR IN I/P
         LA    R9,INCRA
         B     CIB
*
TRONE    BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVC   0(1,R3),2(R4)           TAKE CHAR FOUND IN INPUT
         LA    R3,1(,R3)
         BR    R10                     RETURN
*
TROE     BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVC   0(1,R3),1(R4)           TAKE SUBSTITUTE CHAR FROM TABLE
         L     R12,BRACKET
         CLI   0(R3),XFRSQBR           RIGHT SQUARE BRACKET ?
         BNE   TSTMORE                 NO
         BCTR  R12,0                   YES, SUBTRACT 1 FROM CTR
         B     NOUPDAT
*
TSTMORE  CLI   0(R3),XFLSQBR           LEFT SQUARE BRACKET ?
         BNE   NOUPDAT                 NO
         LA    R12,1(,R12)             YES, INCR COUNTER
NOUPDAT  ST    R12,BRACKET
         LA    R3,1(,R3)
         LA    R1,1(,R1)
         BR    R10                     RETURN
*
*        RIGHTPAR
*
*        INSERTS A ) IN O/P, SETS THE LABEL POINTERS
*
RIGHTPAR BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFRBRAC           TRANSFER ) TO OUTPUT BUFFER
         ST    R3,OPIN                 NOTE ITS POSITION
         MVI   OPINCHAR,XFRBRAC
         MVC   OPIN+4(1),ONC           AND THE OUTPUT RECORD NUMBER
         LA    R3,1(,R3)
         ST    R3,LAPIN                NOTE POSITION WHERE LETTERSTRING
         LA    R1,1(,R1)               MAY START
         B     TESTLOOP
*
*        POINT
*
*        SCANS FOR -
*        DECPOINT
*        ERROR
*        COLON
*        SEMICOLON
*        ASSIGN
*        USED BY MAIN LOOP AND ARRAYLIST
*
POINT    LA    R1,1(,R1)               SCAN SOURCE STRING
         LA    R9,*                    RETURN ADDR FOR CIB PROGRAM
         SR    R2,R2                   CLEAR FUNCTION BYTE REG
         TRT   0(73,R1),PTTABLE        TO NEXT DELIMITER
         L     R6,BPRTAB(R2)           BRANCH TO SELECTED
         BR    R6                      SUBROUTINE
*
*        DECPOINT
*
*        TRANSFERS A DECIMAL POINT
*
DECPOINT BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFDECPT           TRANSFER DECIMAL POINT
         LA    R3,1(,R3)
         BR    R10
*
*        ASSIGN
*
*        TRANSFERS A ASSIGN CHAR TO O/P
*        RETURNS VIA STATEMENT
*
ASSIGN   BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFASSIGN          TRANSFER .= TO OUTPUTBUFFER
         LA    R1,1(,R1)               INCR INPUT POINTER
         LA    R3,1(,R3)               INCR OUTPUT POINTER
         B     STATE                   BRANCH TO STATEMENT PROGRAM
*
*        STATE
*
*        1. CHECKS WITH PROBIT IF FIRST LABEL, FOR, IF, GOTO OR
*           ASSIGN STATMENT AFTER A PROCEDURE
*        2. CHECKS THAT ALL PARAMETERS HAVE BEEN SPECIFIED
*        3. TURNS OFF THE PROBIT AND THE BEGBIT, POSSIBLE
*           PROCEEDING BEGIN WILL BE COMPOUND BEGIN
*
STATE    NI    BITS1,X'7F'             BEGBIT = 0
         L     R15,SP
         CLI   0(R15),X'0C'            PROC IN STACK ?
         BNER  R10                     IF NO RETURN
         MVI   0(R15),X'14'
         NI    BITS1,X'BF'             PROBIT.=0
         CLI   PZ,0                    ALL PARAMETERS SPECIFIED ?
         BER   R10                     YES, RETURN
         BAL   R12,ERROR10             NO, GENERATE E10
         BR    R10                     RETURN
*
*        APOSTROF
*
*        SCANS FOR -
*        SCALE
*        BLANK
*        ZETA
*        NOT PERMITTED
*        ONE MORE APOSTROPHE (DELIMITER)
*        R4 WILL POINT TO THE APOSTROPHE
*        USED BY TESTLOOP AND LIST
*
APOSTROF MVI   FBYTE,0                 ZERO FBYTE
ENTRAPR  LR    R4,R1                   R4 WILL POINT TO FIRST APOST
         LA    R1,1(,R1)
         BALR  R9,0
         SR    R2,R2
         TRT   0(73,R1),ATABLE         SOURCE STRING IS SCANNED TO
*                                      THE NEXT SIGNIFICANT DELIMITER
         L     R6,BPRTAB(R2)           R6 -> SELECTED SUBROUTINE
         BR    R6                      BRANCH TO ROUTINE SELECTED
*
*        SCALE
*
*        CORRECT ONLY DIRECT AFTER TESTLOOP OR LIST
*        CHECK THAT THE APOSTROPHE IS ONLY ONE CHAR IN FRONT OF
*        DIGIT
*
SCALE    TM    FBYTE,X'FF'
         BO    COMCEE2                 COMMENT UNDER PROCESS
         BM    TYPESPEC                DECLARATION UNDER PROCESS
SCALEOK  LR    R6,R1
         TM    BITS2,X'20'             PROGRAM STARTED YET ?
         BZ    TESTLOOP                NO, RETURN
         BCTR  R6,0
         CLI   0(R6),XFQUOTE           QUOTE ONE BYTE BEFORE SIGN
*                                      OR DIGIT ?
         BNE   EROUT                   IF NO, BRANCH TO ERROR ROUTINE
         BAL   R12,COB                 CHECK IF O/P AREA FILLED
MOVETEN  MVI   0(R3),X'3F'             MOVE SCALE FACTOR TO OUTPUT REC
         LA    R3,1(,R3)               INCREASE OUTPUT
         BR    R10                     RETURN
*
*        BLKAPOS
*
*        SHIFT THE BLANK OR BLANKS AWAY AND MOVES THE QUOTE
*        AND VALID CHARACTERS UP TO THE RIGHT
*
*        SETS R4 TO POINT NEW LOCATION OF THE QUOTE
*        USED BY MAINLOOP AND INDIRECT BY THE ARRYLIST AND THE
*        NPAFTAPO
*
BLKAPOS  LR    R15,R1                  NOTE POSITION OF FIRST BLANK
BLKAPOSA TRT   0(73,R1),BTABLE
         LR    R6,R1                   CALC NUMBER OF BLANKS
         SR    R6,R15                  NUMBER OF BLANKS IN R6
         LR    R14,R15
         SR    R14,R4
         C     R14,KF11                BYTES EXCEED THE LIMIT ALREADY ?
         BH    EROUT
         BCTR  R14,0                   NUMBER OF BYTES TO BE SHIFTED
         LA    R15,0(R6,R4)            COMPUTE NEW POSITION OF QUOTE
         EX    R14,MAPOS               MOVE QUOTE AND SCANNED CHARS
         EX    R14,MAPOS2
         LR    R4,R15                  NOTE NEW POSITION OF QUOTE
         BR    R9                      RETURN
*
MAPOS    MVC   BUCKET(1),0(R4)
MAPOS2   MVC   0(1,R15),BUCKET
*
BUCKET   DC    11X'00'
*
*        ZETAAPO
*
*        MOVES SCANNED BYTES AND APOSTROPHE IN FRONT OF WA AND
*        PUTS R4 TO NEW START LOCATION OF POSSIBLE DELIMITER
*        USED BY MAINLOOP AND ARRAYLIST
*
ZETAAPO  LR    R15,R4                  COMPUTE
         LR    R14,R1                  NUMBER OF SCANNED
         SR    R14,R4                  BYTES
         C     R14,KF11                EXCEED LIMIT ?
         BH    EROUT                   YES
         LA    R4,WA                   NO, CALCULATE WHERE TO MOVE
         SR    R4,R14                  CHAR STRING
         BCTR  R14,0
         EX    R14,MOVBEFWA            MOVE CHAR IN FRONT OF WA
         B     CIB                     CHANGE INPUT BUFFER
*
MOVBEFWA MVC   0(1,R4),0(R15)
*
*        NPAFAPO
*
*        GIVES ERROR MESSAGE AND UTILIZES BLANKAPO TO SHIFT THE
*        INVALID CHARACTER AWAY
*        USED BY MAINLOOP AND ARRAYLIST
*
NPAFTAPO TM    FBYTE,X'FF'
         BM    TYPESPEC                INVALID IDENTIFIER
         BO    COMCED2                 COMMENT UNDER PROCESS
         TM    BITS2,X'20'             PROGRAM STARTED YET ?
         BZ    NPAFTAPA                NO, BYPASS ERROR MSG
         BAL   R6,ERR7
*
         DC    X'0401'                 E1
*
NPAFTAPA LR    R15,R1
         LA    R1,1(,R1)               GOTO BLKAPOS TO SHIFT AWAY
         B     BLKAPOSA                INVALID CHARACTER
*
*        COLON
*
*        ENTERD FROM MAINLOOP OR POINT
*        CHECKS FOR   :=  ASSIGN
*                     :(  DELIMITER
*                         LABEL
*
COLON    LR    R6,R1                   STORE PRECEEDING 6 CHARACTERS
         S     R6,KF6                  TO BE USED ONLY IF INCORRECT
         MVC   BUCKET(6),0(R6)         USE OF COLON E3
COLON2   LA    R1,1(,R1)               R1 -> NEXT INPUT CHAR
EQUAL    CLI   0(R1),XFEQUAL           COLON FOLLOWED BY EQUAL SIGN ?
         BE    ASSIGN                  BRANCH TO ASSIGN PROGRAM
         CLI   0(R1),XFLBRAC           COLON FOLLOWED BY LEFT BRACKET ?
         BE    LETDEL                  BRANCH TO DELIMITER PROCESSING
         CLI   0(R1),XFBLANK           COLON FOLLOWED BY BLANK ?
         BE    COLON2                  REPEAT SEARCH
         CLI   0(R1),XFZETA            COLON FOLLOWED BY ZETA ?
         BNE   LABEL01                 NO, BRANCH TO LABEL PROCESSING
         LA    R9,EQUAL                YES, PROVIDE RETURN ADDR
         B     CIB                     GET NEW INPUT BUFFER
*
*        LABEL
*
*        OPIN POINTS TO LAST OPERATOR WHICH MIGHT BE
*        FOLLOWED BY A LABEL
*        R14 IS THE POINTER, STEPPING UP BETWEEN LAPIN AND
*        THE COLON POINTED TO BY R3
*        OPIN+4 CONTAINS THE O/P REC NUMBER WHEN OPIN WAS SET
*        LABEL IS CHECKED FOR VALIDITY. THE FIRST 6 CHAR
*        ARE MOVED TO OUTPUT AND ITAB
*        CHECKS IF THE LABEL IS SPLIT OVER MORE THAN ONE
*        O/P BUFFER
*
*        IF THE LABEL IS SPLIT BY ONE O/P BUFFER END THE HANDLING
*        IS THE SAME AS IF NOT EXECPT THAT WHEN ZETA
*        IS FOUND R14 IS UPDATED TO THE FIRST CHARACTER OF THE
*        CURRENT O/P REC
*
*        E3 IF THERE IS NO LABEL
*        E6 IF LABEL LONGER THAN 1024 BYTES
*        E7 IF LABEL CONTAINS INVALID CHARACTER
*        E8 IF LABEL STARTS WITH INVALID CHAR
*
LABEL01  CLC   ONC,OPIN+4              LABEL EXCEEDS ONE O/P REC ?
         BE    LABEL                   NO
         SR    R4,R4
         IC    R4,OPIN+4
         LA    R4,1(,R4)
         IC    R2,ONC
         CR    R2,R4                   LABEL EXCEEDS 2 O/P REC ?
         BE    LABEL                   NO
         BAL   R6,ERR4
*
         DC    X'0406'                 TERMINATING ERROR
*
LABEL    L     R14,LAPIN
         CR    R3,R14                  ANY IDENTIFIER ?
         BE    ERROR3                  E3 COLON DELETED
         CLI   OPINCHAR,XFRBRAC        LABEL PROCEEDED BY RIGHT BRACK ?
         BE    ERROR3                  YES, E3 IS GIVEN
LABNAME  CLI   0(R14),XFA              FIRST CHAR SPECIAL OR NUMERIC ?
         BL    LABNAMER                YES, BRANCH, NOT LETTER
         L     R7,AITL                 NO, LETTER
         MVC   0(1,R7),0(R14)          MOVE CONTENTS OF R14 TO ITAB
         LA    R7,1(,R7)               INCR R7
         LA    R2,1                    INITIALIZE R2 WITH 1
LABID    LA    R14,1(,R14)             GET NEXT CHAR
         CR    R14,R3                  R14 = R3 ?
         BE    LABEND
LABCHECK CLI   0(R14),XFZETA           ZETA ?
         BNE   LABCHK1                 NO, BRANCH
         L     R14,WADDARI             GET START OF CURRENT O/P AREA
         B     LABCHECK
*
LABCHK1  BL    ERROR7
         C     R2,KF6                  R2 = 6 ?
         BE    LABID                   YES, DON'T MOVE MORE CHAR TO
*                                      ITAB
         MVC   0(1,R7),0(R14)          MOVE CONTENT OF PINTOIN
         LA    R7,1(,R7)               INCR R7, R2
         LA    R2,1(,R2)
         B     LABID
*
LABNAMER CLI   0(R14),XFZETA           ZETA ?
         BNE   LABNAM01                NO, BRANCH
         L     R14,WADDARI             UPDATE R14 TO CURRENT O/P BUFFER
         B     LABNAME
*
LABNAM01 CLI   0(R14),XFBLANK          BLANK ?
         BE    LABNAME                 YES, BRANCH
         BAL   R6,ERR7
*
         DC    X'0408'                 E8
*
         B     ERROR7A
*
ERROR7   BAL   R6,ERR2
*
         DC    X'0007'                 E7 INCORRECT LABEL
*
ERROR7A  L     R15,AITL
         BAL   R12,ITABCLEC            CLEAR THE ITAB ENTRY
         BR    R10
*
*        LABEND
*
*        IF (LABEL:LABELX) THE LN (LABEL NUMBER) WILL ONLY BE
*        INCREASED ONCE
*        INTERNAL NAME IS CREATED AND LN INSERTED
*        X'27' IS MOVED TO THE O/P TO INDICATE LABEL OPIN,
*        OPIN+4 AND LAPIN ARE UPDATED
*        ITABCLEA IS ACTIVATED TO PREPARE NEXT ITABENTRY
*
LABEND   CLI   OPINCHAR,XFLABEL        +. LABEL PRECEEDED BY LABEL
         BE    LABLAHEI                YES, DO NOT UPDATE LN
         LH    R15,LN                  LN = LN+4
         LA    R15,4(,R15)
LABCREAT CLC   LN(2),KH4096            LN = 2**12 ?
         BL    LABCRT01
         BAL   R6,ERR7
*
         DC    X'04D8'                 E216
*
         LA    R15,LATBEG              RESET LN
LABCRT01 STH   R15,LN
LABLAHEI L     R15,AITL
         MVI   6(R15),X'CC'            CREATE INTERNAL NAME
         MVI   7(R15),X'08'
         L     R14,LPBP
         MVC   8(1,R15),10(R14)        PROGRAM BLOCK NR AITL + 7
         MVC   9(2,R15),LN             LN IN AITL+9
         BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFLABEL           MOVE LABEL IND TO O/P
         ST    R3,OPIN                 SET LABEL POINTERS
         MVI   OPINCHAR,XFLABEL
         MVC   OPIN+4(1),ONC
         LA    R3,1(,R3)
         ST    R3,LAPIN
         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY
         B     STATE                   RETURN VIA STATEMENT PCM
*
*        LETDEL
*
*        :( HAS BEEN FOUND IN THE I/P
*        IF OPIN POINTS TO A RIGHT PARENTHESIS IT SHOULD BE
*        LETTER DELIMITER, WHICH SHOULD BE REMOVED AND REPLACED
*        BY A COMMA
*        IT IS CHECKED THAT ALL CHARACTERS ARE LETTERS OTHERWISE
*        E3 IS GIVEN
*
LETDEL   CLI   OPINCHAR,XFRBRAC        OPIN POINTS TO A RIGHT BRACKET ?
         BNE   ERROR3                  NO, E3, COLON DELETED
         CLC   ONC(1),OPIN+4           LETDEL EXCEEDS ONE O/P REC ?
         BNE   LETDELB2                YES
         L     R14,OPIN
         LA    R6,1(,R14)
         CR    R6,R3                   AT LEAST ONE CHAR ?
         BE    ERROR3                  NO, E3 DELETE COLON
LETDELE1 LA    R14,1(,R14)             OTHER CHAR THAN
         CLI   0(R14),XF9              LETTERS ?
         BNH   ERROR3
         LA    R6,1(,R14)
         CR    R6,R3                   ALL CHAR CHECKED ?
         BNE   LETDELE1                NO, CHECK NEXT
         L     R3,OPIN                 SET O/P POINTER TO BEGINING OF
         MVI   0(R3),XFCOMMA           THE STRING, MOVE IN A COMMA
         LA    R3,1(,R3)
         LA    R1,1(,R1)               GET NEXT CHAR
         BR    R10
*
*        DELIMITER EXCEEDS ONE O/P RECORD
*
LETDELB2 SR    R6,R6                   DOES THE STRING
         IC    R6,OPIN+4               EXCEED 2 O/P RECORDS ?
         LA    R6,1(,R6)
         IC    R2,ONC
         CR    R6,R2
         BE    LETDEL01                NO
         BAL   R6,ERR4
*
         DC    X'0404'                 E4  GOES TO COMPFIN
*
LETDEL01 L     R14,OPIN                MAKE R14 POINT TO LETTER DEL
LETDELB3 LA    R14,1(,R14)
         CLI   0(R14),XFA              LETTER ?
         BNL   LETDELB3                YES
         CLI   0(R14),XFZETA           NO, ZETA ?
         BNE   ERROR3
         L     R14,WADDARI             CHANGE BACK SO R14 POINT
*                                      TO CURR.O/P
LETDELF4 CLI   0(R14),XFA              LETTER ?
         BL    ERROR3                  E3 DELETE COLON
         LA    R14,1(,R14)             SKIP ALL LETTERS
         CR    R14,R3                  UNTIL END OF DELIMITERS
         BNE   LETDELF4
         L     R3,WADDARI              LOAD ADDR OF CURRENT O/P REC
         MVI   0(R3),X'3D'             MOVE IN $ RHO
         LA    R3,1(,R3)
         LA    R1,1(,R1)               GET NEXT CHAR
         BR    R10
*
*        SEMCO
*
*        IF THE DELTA BIT IS ON, THE DELTA AND SEMICOLON COUNTER
*        (SEMCNT) IS MOVED TO THE OUTPUT
*        IF THE DELTABIT IS OFF THE STACK IS INSPECTED
*
*        BEGIN, BETA OR PROC* -
*        A SEMICOLON AND THE SEMCNT IS MOVED TO THE O/P AND
*        PROCESSING IS CONTINUES VIA TEST
*
*        FOR -
*        THE FORSTATMENT IS COMPLETE, THE FOREND PROGRAM IS
*        ACTIVATED
*        THE RETURN IS TO STACKTST TO SEE IF ONE MORE FOR
*        STATEMENT OR A PROC** HAS ENDED AT THE SAME TIME
*
*        PROC -
*        A PROCEDURE CONSISTING OF ONLY ONE STATMENT OR A DUMMY
*        STATMENT HAS ENDED IT IS CHECKED THAT ALL PARAMETERS
*        HAVE BEEN SPECIFIED, AND THE PROC** PGM IS JOINED
*
*        PROC** -
*        A PROCEDURE CONSISTING OF ONE LABELED STATEMENT OR ONE
*        FOR, IF, GOTO OR ASSIGN STATEMENT HAS ENDED
*        THE PROGRAM BLOCKEND PROGRAM IS ACTIVATED AND A DELTA
*        AND THE SEMCNT IS MOVED OUT
*
*        THE FINAL EXIT IS IN ALL CASES TO TEST
*
SEMC60   OI    COMPFLGS+2,SET60        SET SWITCH FOR 60 CHAR SET
SEMCO    LH    R4,SEMCNT
         C     R4,SCOVFL               TEST SEMICOLON OVERFLOW
         BL    SEMCO01
         BAL   R6,ERR7
*
         DC    X'0411'                 E17
*
         MVC   SEMCNT,KF0              ZERO SEMICOLON COUNT
SEMCO01  LA    R4,1(,R4)               INCR SEMICOLON COUNTER
         STH   R4,SEMCNT
         LA    R0,3(,R3)               PROVIDE 3 BYTES IN OUTPUT BUF
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         NI    BITS3,FMOFF
         TM    BITS1,X'20'             TEST DELTABIT
         BO    DELTA                   ON, BRANCH TO DELTA TRANSFER
         LA    R4,STACKTST             RETURN REG (FOREND, PBLCKEND)
         L     R15,SP
         IC    R2,0(,R15)              SELECT BRANCH ADDR
         L     R6,PROG2(R2)            DEPENDING ON WHAT IS IN STACK
         BR    R6
*
PROG2    DC    A(ERR8)                 +00 ALPHA   SHOULD NOT OCCUR
         DC    A(SCTRANS)              +04 BETA
         DC    A(SCTRANS)              +08 BEGIN
         DC    A(SEMPROC)              +12 PROC
         DC    A(SCTRANS)              +16 PROC*
         DC    A(SEMPROC2)             +20 PROC**
         DC    A(FOREND)               +24 FOR
*
DELTA    NI    BITS1,X'DF'             DELTA BIT= 0
         MVI   0(R3),XFDELTA           TRANSFER DELTA
         B     SCTRANSA
*
SCTRANS  MVI   0(R3),XFSCOLON          TRANSFER SEMICOLON
SCTRANSA MVI   OPINCHAR,XFSCOLON
         ST    R3,OPIN                 NOTE POS OF SEMICOLON IN OPIN
         MVC   OPIN+4(1),ONC           AND O/P NO
         MVC   1(2,R3),SEMCNT          TRANSFER SEMICOLON COUNTER
         LA    R3,3(,R3)               INCREASE OUTPUT POINTER
         ST    R3,LAPIN
         NI    BITS1,X'7F'             BEGBIT.=0
         LA    R1,1(,R1)               INCREASE INPUT POINTER
         B     TESTLOOP
*
SEMPROC  NI    BITS1,X'BF'             PROBIT.=0
         CLI   PZ,0                    ALL PARAMETERS SPECIFIED
         BE    SEMPROC2
         BAL   R12,ERROR10
SEMPROC2 BAL   R4,PBLCKEND
         LA    R0,3(,R3)               PROVIDE 3 BYTES IN OUTPUT BUF
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         MVI   0(R3),XFDELTA           TRANSFER DELTA
         B     SCTRANSA
*
STACKTST CLI   0(R15),X'14'
         BE    SEMPROC2                PROC**
         BH    FOREND                  FOR
         LA    R0,3(,R3)
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         B     SCTRANS
*
*        ERROR ROUTINE
*
*        GENERATES ERROR PATTERNS
*
*        MAINLY CLOSED SUBROUTINES, ENTERED WITH BAL R6
*        FOLLOWED BY TWO BYTES. FIRST BYTE SPECIFIES THE LENGTH,
*        IF KNOW AND SECOND BYTE ERROR NUMBER.
*        USES ERROR1 TO CHECK FOR ERRORPOL OVERFLOW AND TO
*        INSERT NUMBER, LENGTH AND SEMCNT
*
*        ERR0
*
*        GENERATES E212 PATTERN
*        EXITS TO COMFIN
*
ERR0     MVI   0(R15),X'02'
         MVI   1(R15),X'D4'            E212
         LA    R15,2(,R15)
         ST    R15,NEXTERR
         B     COMPFIN
*
*        ERR1
*
*        E1
*        ACTIVATES ERR7, SKIPS INVALID CHARACTER AND RETURNS TO
*        EITHER TESTLOOP OR LIST
*        ENTERED VIA BPRTAB WHEN USED BY TESTLOOP OR LIST
*        INVALID CHARACTER FOLLOWING AN APOSTROPHE IS TREATED
*        SPECIALLY IN NPAFTAPO
*
ERR1     BAL   R6,ERR7                 NOT PERMITTED CHARACTER
*
         DC    X'0401'                 E1
*
         LA    R1,1(,R1)
         BR    R10                     RETURN TO TEST OR TRATE
*
*        ERR2
*
*        ERR2      7, 16, 31, 32, 33, 34
*             ENTERED   ERROR7, IER, ARRAYERR, SWITCHERR
*                       SLASHERR, SEMCLST, SEMCLER, ARRYSLSH
*                       SLASHLST, PNAMERR
*             NAME TAKE FROM AITL
*        ERR2B          10, 36, 37
*                       ERROR10, PROCFIN, ERROP37
*             NAME TAKEN FROM LPBP-11
*        ERR2C     14
*                       EROUT
*             DELIMITER TAKEN FROM BUCKET
*        ERR2E     16, 26, 27, 30
*                       IDVALCHK, VALDLB2, IDSELSE, NOTFOUND
*             NAME TAKEN FROM IDBUCKET
*        ERR2D UTILISES ERROR2 TO FIND LENGTH
*                       ERROR1 TO CREATE MESSAGE
*                       MOVES IN INFORMATION
*                       RETURNS TO CALLING SEQUENCE
*
ERR2     L     R7,AITL                 NAME FROM AITL
         B     ERR2D
*
ERR2B    L     R7,LPBP                 NAME FRM LPBP-11
         S     R7,KF11
         B     ERR2D
*
ERR2C    MVC   BUCKET(6),1(R4)         DELIMITER FROM BUCKET
         LA    R7,BUCKET
         B     ERR2D
*
ERR2E    LA    R7,IDBUCKET             E26 NAME FROM IDBUCKET
ERR2D    STM   R12,R15,ERRSAVE
         BAL   R12,ERROR2              GET NAME AND LENGTHS
         BAL   R12,ERROR1              CREATE ENTRY IN ERRPOOL
         EX    R2,ERRMOVE              MOVE THE NAME
         LM    R12,R15,ERRSAVE
         B     2(,R6)
*
*        ERROR3
*
*        GENERATES PATTERN FOR E3
*        ENTERED FROM LABEL, COLONLST
*        TAKES INFORMATION FROM BUCKET
*
ERROR3   STM   R12,R15,ERRSAVE         GET PARAMETER FIELD
         LA    R6,PARAM3
         BAL   R12,ERROR1              CREATE PATTERN
         MVC   4(6,R15),BUCKET         MOVE IN INFORMATION
         LM    R12,R15,ERRSAVE
         BR    R10
*
PARAM3   DC    X'0A03'
*
*        ERR4
*
*        PROCESS ALL TERMINATING ERRORS THAT ARE 4 BYTTES LONG
*
*        NO - 4, 6, 20, 22, 38, 41, 44, 213, 215, 216
*        ENTERED FROM - LABEL, ITABCLEA, COB, BEGIN, BEG1,
*                       PBLCKEND, FOR, PROCEDUR, ENDMISS
*        EXITS TO COMPFIN
*
ERR4     BAL   R12,ERROR1
*
*        COMPFIN
*
*        TERMINATING ERROR HAS BEEN FOUND
*        SETS TERR IN COMPFLGS
*        EXITS TO KOPOOLRL IN TERMINATION
*
COMPFIN  OI    COMPFLGS,TERR           SET TERMINATING ERROR BIT
         B     KOPOOLRL                EXIT TO TERMINATION
*
*        ERR5
*
*        ERR5A     E35  FROM BPRTAB, DISP IN TESTTABL
*        ERR5      E2   FROM BPRTAB, DISP IN ARTABLE
*        GENERATES ERROR PATTERN RETURNS TO TESTLOOP OR LIST
*
ERR5A    LA    R6,PPARLST              GET PARAMETER FIELD
         B     ERR5B
*
ERR5     LA    R6,PONTPAR              GET PARAMETER FIELD
ERR5B    STM   R12,R15,ERRSAVE
         BAL   R12,ERROR1              GENERATE PATTERN
         LM    R12,R15,ERRSAVE
         BR    R10                     RETURN TO TESTLOOP OR LIST
*
PPARLST  DC    X'0423'
PONTPAR  DC    X'0402'                 E2
*
*        ERR6
*
*        GENERATES PATTERN FOR E6
*        TESTS IF PROGRAM STARTED IF NOT, NO ERROR MESSAGE
*        TEST IF IN COMMENT OR IDENTIFIER PROGRAM
*        TAKES THE 6 CHARACTERS PRECEEDING THE FIRST QUOTE
*        RETURNS TO APOSTROPHE PROGRAM TO TEST ON SECOND
*        QUOTE
*
ERR6     TM    BITS2,X'20'             FIRST BEGIN FOUND YET ?
         BZ    TESTLOOP                NO
         TM    FBYTE,X'FF'
         BO    ENTRAPR                 INVALID IDENTIFIER
         BZ    ERR6A                   COMMENT
         LA    R1,1(,R1)
         B     TPSPECER
*
ERR6A    BCTR  R1,0
         STM   R12,R15,ERRSAVE
         BAL   R12,ERROR1
         S     R1,KF6                  SUBTRACT 6
         MVC   4(6,R15),0(R1)          MOVE OUT INFORMATION TO POOL
         LA    R1,7(,R1)
         LM    12,15,ERRSAVE
         B     ENTRAPR                 RETURN TO TEST SECOND APOST
*
*        ERR7
*
*        TAKES CARE OF ALL SERIOUS AND WARNING MESSAGES THAT ARE
*        4 BYTES LONG
*
*        ENTERED FROM -
*        ERR1, IERSPEC, ARNAMSE, SWITCHNSE, PNAMESE, LABNAMER,
*        CODE, SEMCO, ERR18 ERR23, CODE, SPEC, VALUE, VALDLB2,
*        FIRSTBEG, ERR9, LABEL, PROCEDURE, SWITCH, COM
*        1, 5, 8, 15, 17, 18, 23, 24, 25, 28, 29, 42, 43, 216
*        RETURNS TO CALLING SEQUENCE
*
ERR7     STM   R12,R15,ERRSAVE
         BAL   R12,ERROR1              CREATE ENTRY
         LM    R12,R15,ERRSAVE
         B     2(,R6)
*
*        ERR8
*
*        GENERATES ERROR PATTERN E11 ONCE
*
*        IF FOUND DELIMITER IS COMMENT E18 IS GIVEN INSTEAD
*        ENTERED FROM - TYPESPEC, STARTDEL
*        EXITS TO TESTLOOP
*
ERR8     TM    BITS3,E11BIT            MESSAGE ALLREADY GIVEN ONCE ?
         LA    R1,1(,R1)               GET NEXT CHARACTER
         BO    TESTLOOP                YES, RETURN
         CLI   BCHAR,X'38'             COMMENT FOUND ?
         BE    E18                     YES GENERATE E18 INSTEAD
         OI    BITS3,E11BIT            SET E11BIT
         BAL   R6,ERR7                 GENERATE E11 PATTERN
*
         DC    X'040B'
*
         B     E18A
*
E18      BAL   R6,ERR7
*
         DC    X'0412'
*
E18A     BR    R10                     RETURN
*
*        ERR9
*
*        GENERATE E9 PATTERN
*
*        ENTERED FROM - TED, END, READROUT
*        EXITS TO EODADIN
*
ERR9     BAL   R6,ERR7                 PROGRAM CONT AFTER LAST END
*
         DC    X'042B'
*
         B     EODADIN
*
*        ERROR10
*
*        GENERATES E10 PATTERN
*
*        INSERTS IN THE NOT SPECIFID PARAMETERS AN ALL PURPOSE
*        IDENTIFIER
*        RETURNS TO CALLING PROGRAM
*
ERROR10  BAL   R6,ERR2B
*
         DC    X'000A'                 E10
*
         L     R6,LPBP
FINDEMTY LA    R6,11(,R6)              GET FIRST PARAMETER
         C     R6,AITL                 ALL PARAMETERS CHECKED ?
         BER   R12                     WHEN ALL CHECKED RETURN
         CLI   6(R6),0                 INSERT ALL PURPOSE IDENTIFIER
         BNE   FINDEMTY                IN EMPTY INTERNAL NAMES
         MVC   6(5,R6),ALLPUPOS
         B     FINDEMTY
*
ALLPUPOS DC    X'91FF010000'
*
*        ERR13
*
*        GENERATES E13 PATTERN
*        PICKS UP THE DELIMITER FROM KEYWTAB
*
ERR13    STM   12,15,ERRSAVE
         LA    R12,5(,R14)             INCREASE TO GET WHOLE LENGTH
         STC   R12,0(R6)
         BAL   R12,ERROR1
         L     R14,ERRSAVE+8           GET LENGTH OF DELIMITER
         LA    R7,1(,R4)               GET START ADDR OF DELIMITER
         EX    R14,ERRMOVE             MOVE DELIMITER TO ERROR PATTERN
         LM    12,15,ERRSAVE
         B     2(0,R6)                 RETURN
*
*        ERROR21
*
*        GENERATES E21 PATTERN
*        PICKS UP DELIMITER FROM DELIMITER TABLE
*        EXITS TO PROGRAM WHICH CALLED FOR BEG1
*
ERROR21  STM   12,15,ERRSAVE
         LA    R6,5(,R14)              INCREASE L TO GET WHOLE LENGTH
         STC   R6,E21PAR
         LA    R6,E21PAR
         BAL   R12,ERROR1
         L     R7,SAVE1                GET DEK FROM DELIMITER TABLE
         L     R14,ERRSAVE+8           LENGTH FROM SAVEAREA
         EX    R14,ERRMOVE             MOVE IN DEK IN ERROR MESSAGE
         LA    R3,1(,R3)               SUBSTITUTE BEG1 DECREASION
         LM    12,15,ERRSAVE           BEGIN WILL REMAIN COMPOUND
         BR    R9                      RETURN
*
E21PAR   DC    X'0015'                 E21
*
*        ERROR1
*
*        CHECKS IF SPACE LEFT IN ERRORPOOL
*        INSERTS LENGTH, SEMCNT, ERROR NUMBER
*        RETURNS TO CALLIN ERROR PUTINE
*
ERROR1   MVC   ERRMOD1+3(1),0(R6)      MOVES IN THE LENGTH AND
         MVC   ERRMOD2+1(1),0(R6)      ERROR NUMBER IN THE FOLLOWING
         MVC   ERRMOD3+1(1),1(R6)      INSTRUCTIONS
         L     R15,NEXTERR
ERRMOD1  LA    R14,0(,R15)
         C     R14,ENDPOOL             ROOM LEFT IN ERRORPOOL ?
         BNH   *+8                     FOR THIS MESSAGE
         B     ERR0                    NO, GENERATE E212
*
         L     R15,NEXTERR
         ST    R14,NEXTERR             CORRECT NEXTERR POINTER
ERRMOD2  MVI   0(R15),0                MOVE IN LENGTH
ERRMOD3  MVI   1(R15),0                        ERRORNUMBER
         MVC   2(2,R15),SEMCNT                 SEMICOLON COUNTER
         LR    R14,R1                  MAKE R14 POINT TO SIX CHAR
         SH    R14,KH7                 BEFORE CURRENT INPUT POINTER
         BR    R12
*
*        ERROR2
*
*        FINDS FIRST NONZERO CHAR IN BUCKET, ITAB, IDBUCKET OR
*        BUCKET
*
ERROR2   LA    R2,5                    INITIALIZE R2 FOR THE LOOP
ERROR2A  STC   R2,ERRKCAL+3
ERRKCAL  CLI   0(R7),0                 LOOP TO FIND THE FIRST 0 CHAR
         BNE   ERRKC01                 OR END OF EXTERNALNAME
         BCT   R2,ERROR2A
ERRKC01  LA    R15,5(,R2)              INCREASE TO GET THE WHOLE
         STC   R15,0(,R6)              ERROR MESSAGE LENGTH
         BR    R12
*
         CNOP  0,4
ERRMOVE  MVC   4(1,R15),0(R7)
*
KH7      DC    X'0007'
*
*        IDCHECK1
*
*        CHECKS IDENTIFIER NAMES FOR ARRAY, PROCEDURE AND SWITCH
*
*        MOVES THE FIRST 6 CHARACTERS OF THE NAME TO ITAB AND THE
*        OUTPUT
*        RETURNS VIA R6 WHEN A CHARACTER IS FOUND THAT IS NOT
*        LETTER, DIGIT, BLANK OR ZETA
*
IDCHECK1 BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVC   0(1,R3),0(R1)           MOVE OUT FIRST CHAR
         LA    R3,1(,R3)
         L     R7,AITL                 GET ITAB POINTER
         MVC   0(1,R7),0(R1)           MOVE IN FIRST CHAR TO ITAB
         LA    R7,1(,R7)
         LA    R2,1                    INITIALIZE R2
         LA    R9,IDCHECK3
IDCHECK2 LA    R1,1(,R1)               GET NEXT CHAR
IDCHECK3 CLI   0(R1),XFZETA            WHAT IS CHAR ?
         BLR   R6                      NOT LETTER
         BE    CIB                     ZETA
         C     R2,KF6                  LETTER, 6 CHAR MOVED ALREADY ?
         BE    IDCHECK2                YES, SKIP ADDITIONAL CHAR
         BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVC   0(1,R3),0(R1)           MOVE CHAR TO OUTPUT
         LA    R3,1(,R3)
         MVC   0(1,R7),0(R1)           TO ITAB
         LA    R7,1(,R7)               INCREASE
         LA    R2,1(,R2)               POINTERS
         B     IDCHECK2                GO AND CHECK NEXT CHAR
*
*        FINDSEMC
*
*        CHECKS FOR SEMICOLON OR POINT
*        COMMA BLANKS AND I/P BUFFER CHANGE IS HANDLED
*        IF SEMICOLON IS FOUND THE RETURN IS VIA R12 IF NOT
*        THE RETURN IS VIA R6
*
FINDSEMA LA    R1,1(,R1)
FINDSEMC LA    R9,*
         CLI   0(R1),XFSCOLON          SEMICOLON ?
         BE    0(,R12)                 YES, SEMICOLON FOUND
         CLI   0(R1),XFPERIOD          POINT ?
         BE    FINDCOMA                YES, LOOK FOR COMMA
         CLI   0(R1),XFBLANK           BLANK ?
         BE    FINDSEMA                YES, BACK TO START
         CLI   0(R1),XFZETA
         BE    CIB
         BR    R6                      ERROR, NO SEMICOLON
*
FINDCOMA LA    R9,*+8
FINDCOMB LA    R1,1(,R1)
         CLI   0(R1),XFCOMMA           COMMA ?
         BE    0(,R12)                 YES, SEMICOLON FOUND
         CLI   0(R1),XFBLANK           BLANK ?
         BE    FINDCOMB
         CLI   0(R1),XFZETA
         BE    CIB
         BR    R6                      ERROR, NO SEMICOLON
*
*        ITABCLEA
*
*        CHECKS FOR ITAB OVERFLOW AND CLEARS THE NEXT ENTRY
*
ITABCLEA L     R15,AITL
         LA    R15,11(,R15)
ITABCLEC C     R15,ELI                 ROOM FOR ONE MORE ITAB ENTRY ?
         BL    ITABCLEB
         BAL   R6,ERR4
*
         DC    X'04D5'                 E213
*
ITABCLEB LR    R7,R15                  INCREASE ITAB POINTERS
         ST    R15,AITL
         MVI   0(R15),0                CLEAR NEXT
         MVC   1(10,R15),0(R15)        ITAB ENTRY
         BR    R12                     RETURN
*
*        COB
*
*        CHECKS IF NEW O/P BUFFER IS NEEDED
*
*        ENTRY IS TO COBSPEC IF TWO OR MORE CONTINIOUS BYTES ARE
*        NEEDED
*        THE CHANGE OF ADDR BETWEEN THE TWO BUFFERS IS DONE
*        WITH DISP. DISP IS EITHER 0 OR 4 SO ADDARI+DISP WILL
*        PICK UP EITHER ADDARI OR THE ADDR OF THE ALTERNATE
*        O/P BUFFER
*        WADDARI POINTS TO THE FIRST BYTE OF THE CURRENT O/P
*        BUFFER
*        R3 IS THE CURRENT O/P POINTER
*        APE POINTS TO THE LAST BYTE OF THE CORRENT BUFFER
*        ONC CONTAINS THE CURRENT O/P RECORD NUMBER
*        ZETA IS THE BUFFER END INDICATION
*
COBSPEC  C     R0,APE                  SPACE LEFT FOR X MORE BYTES ?
         BLR   R12                     YES, RETURN
         B     COBSPEB                 NO CHANGE OUTPUT BUFFER FIRST
*
COB      C     R3,APE                  SPACE LEFT FOR ONE MORE BYTE ?
         BLR   R12                     YES, RETURN
COBSPEB  MVI   0(R3),XFZETA            MOVE ZETA TO O/P BUFFER
         STM   R14,R2,SAVE1            SAVE REGISTERS
         ST    R6,SAVE1+24
         CLI   ONC,255                 ALREADY 256 OUTPUT RECORDS ?
         BL    COBSPED                 NO, BYPASS ERROR MSG
         BAL   R6,ERR4                 YES, TERMINATE COMPILATION
*
         DC    X'04D7'                 E215
*
COBSPED  L     R3,WADDARI              LOAD ADDR OF CURRENT O/P REC
         LA    R6,SYSUT1               R6 -> SYSUT1 DCB ADDR
         CLI   ONC,0                   FIRST OUTPUT RECORD ?
         BE    WRITEOB                 YES, SKIP CHECK
*
         CHECK ODECB                   CHECK IF BEFORE LAST RECORD IS
*                                      WRITTEN
WRITEOB  WRITE ODECB,SF,(R6),(R3)
*
         XI    DISP,X'04'              CHANGE ADDR DISPLACEMENT
         IC    R2,DISP
         L     R3,ADDARI(R2)           COMPUTE VALID O/P BUFFER ADDR
         ST    R3,WADDARI              STORE IN WADDARI
         LR    R14,R3                  COMPUTE ADDR OF LAST BYTE IN
         A     R14,SRCE1S              THE NEW OUTPUT AREA
         BCTR  R14,0
         ST    R14,APE                 SAVE IN APE
         IC    R2,ONC                  INCREASE OUTPUT RECORD COUNTER
         LA    R2,1(,R2)
         STC   R2,ONC
         L     R6,SAVE1+24
         LM    R14,R2,SAVE1
         BR    R12                      RETURN TO CALLING SEQUENCE
*
*        CIB
*
*        GET NEXT RECORD AND PRINTS IT WITH THE SEMICOLON COUNTER
*
*        IF ISO CODE IS SPECIFIED A TRANSLATION IS FIRST MADE TO
*        EBCDIC
*        THE RECORD IS TRANSLATED AND THE RECORD END INDICATION
*        ZETA IS INSERTED
*
CIB      STM   R14,R2,SAVE1            SAVE REGS
         SH    R1,KH7                  MOVE SEVEN CHAR INFRONT
         MVC   WABEFOR(7),0(R1)        OF WORKAREA
         TM    COMPFLGS+1,NSRCE        NOSOURCE SPECIFIED ?
         BO    GETREC                  YES, SKIP PRINTING
         L     R15,PRTRTADD            PRINT
         BALR  R14,R15
         ST    R1,APRNTAR              SAVE NEW PRINT BUFFER ADDR
GETREC   L     R1,ASYSDCB              R1 -> SYSIN DCB ADDR
*
         GET   (1),WA                  GET NEXT RECORD
*
TESTISO  TM    COMPFLGS+1,ISO          ISO INPUT ?
         BO    ISOTRANS                YES, TRANSLATE ISO TO EBCDIC
         L     R1,APRNTAR
         TM    COMPFLGS+1,NSRCE        NOSOURCE SPECIFIED ?
         BO    NOPRINT                 YES, MOVE TO DUMMY PRINTAREA
         LH    R15,SEMCNT              CONVERT SEMICOLON COUNTER
         CVD   R15,DOUBLE
         MVC   0(L'SCPATTN,R1),SCPATTN  MOVE IN SEMICOLON COUNT PATTERN
         ED    0(L'SCPATTN,R1),DOUBLE+5  FORMAT SEMICOLON COUNT
         MVC   10(80,R1),WA            MOVE RECORD TO PRINT BUFFER
         B     PRNTREC
*
NOPRINT  MVC   SAVEPRNT+8(72),WA       IF NSRCE MOVE WA TO DUMMY PRINT
PRNTREC  LM    R14,R2,SAVE1
         LA    R1,WA                   SET INPUT POINTER
         TR    WA(72),TREXTINT         TRANSLATE RECORD
         MVI   72(R1),XFZETA           MOVE RECORD END IDENTIFIER
         BR    R9                      RETURN
*
ISOTRANS ST    R6,SAVE1+24
         LA    R6,WA                   GET START OF WA
         LA    R15,79(,R6)             GET END OF WA
LOOP     CLI   0(R6),X'4C'             )
         BE    IRPAR
         CLI   0(R6),X'7B'             =
         BE    IEQUAL
         CLI   0(R6),X'7C'             '
         BE    IAPOST
         CLI   0(R6),X'6C'             (
         BE    ILPAR
         CLI   0(R6),X'50'             +
         BNE   LOOPEND
         MVI   0(R6),X'4E'             +
         B     LOOPEND
*
IRPAR    MVI   0(R6),X'5D'             )
         B     LOOPEND
*
IEQUAL   MVI   0(R6),X'7E'             =
         B     LOOPEND
*
IAPOST   MVI   0(R6),X'7D'             '
         B     LOOPEND
*
ILPAR    MVI   0(R6),X'4D'             (
LOOPEND  LA    R6,1(,R6)
         CR    R6,R15                  ALL CHAR CHECKED IN WA ?
         BNH   LOOP                    NO, CHECK NEXT
         L     R6,SAVE1+24             YES, RETURN
         B     TESTISO+8
*
*        DELTMIT
*
*        TWO QUOTES HAVE BEEN FOUND
*
*        IT IS CHECKED THAT THE LENGTH IS NOT ZERO OR EXCEED THE
*        MAXIMUM LIMIT FOR A DELIMITER (10 CHARACTERS)
*        R4 POINTS TO THE FIRST AND R1 TO THE LAST QUOTE
*        THE LENGTH IS USED TO GET A DISPLACEMENT FROM THE KWLUTAB
*        FOR A SECTION IN THE KEYWTAB. A SECTION IN THE KEYWTAB
*        CONTAINS ALL DELIMITERS OF THE SAME LENGTH.
*        1. THE FIRST BYTE IN EACH SECTION SAYS HOW MANY ENTRIES
*           THERE ARE IN THE SECTION. THEREAFTER A DELIMITER PLUS 3
*           BYTES OF INTERNAL CODE MAKES A SUBSECTION.
*        2. THE FIRST 2 BYTES OF THE INTERNAL CODE IS
*           CHARECTERISTCS FOR THE DELIMITER.
*        3. THE THIRD BYTE IS A DISPLACEMENT TO THE DELPRGTB,
*           WHERE THE ADDR IS PICKED UP TO THE PROGRAM TO HANDLE
*           THE DELIMITER.
*        A CHECK IS MADE WHEN A DELIMITER IS FOUND IF IT IS THE
*        FIRST FOUND IN THE PROGRAM. THE EXIT IS THEN TO
*        STARTDEL. THE TEST IS ON BITS2 X'20'. IF NO DELIMITER IS
*        FOUND THE EXIT IS TO THE EROUT PROGRAM.
*        FBYTE - SWITCH -
*        1. THE FBYTE IS FF IF AN APOSTROPHE IS FOUND IN THE
*           COMMENT PROGRAM
*        2. THE FBYTE IS F0 IF AN APOSTROPHE IS FOUND IN THE TYPE
*           PROGRAM INSTEAD OF THE FIRST CHARACTER OF THE NAME
*        3. OTHERWISE IT IS 00
*
DELIMIT  SR    R15,R15
         LR    R14,R1
         BCTR  R14,0
         SR    R14,R4                  COMPUTE LENGTH OF KEYWORD
         BP    DELIM01                 > ZERO ?
         BAL   R6,ERR6                 ZERO, ERROR
*
         DC    X'0A0C'                 E12 DELETE FIRST APOSTROPHE
*
DELIM01  C     R14,KF11                LIMIT EXEEDED ALREADY ?
         BH    EROUT                   BRANCH TO ERROR ROUTINE
         BCTR  R14,0
         LA    R9,KWLUTAB
         TM    FBYTE,X'FF'             TEST FBYTE
         BO    COMSPEC
         BM    TYPESPEC
         SLA   R14,2                   START OF LOOKUP STRING
         L     R9,0(R14,R9)
         IC    R15,0(,R9)              NUMBER OF ENTRIES IN THIS SECT
         LA    R9,1(,R9)               AND ADDR OF FIRST WORD ENTRY
         SRA   R14,2(0)
CLCLOOP  EX    R14,EXCLC               DELIMITER FOUND ?
         BNE   NOMATCH                 NO, TRY NEXT IN SAME SECTION
         IC    R2,3(R14,R9)            YES, MATCH
         TM    BITS2,X'20'             PROGRAM STARTED YET ?
         BO    DELIM02                 YES
         B     STARTDEL                NO, CHECK FOR CORRECT START
*
DELIM02  L     R6,DELPRGTB(R2)         BRANCH TO APPROPRIATE SUBPGM
         BR    R6                      DEPENDING ON DISP IN KEYWTAB
*
NOMATCH  LA    R9,4(R14,R9)            GET NEXT DELIMITER
         BCT   R15,CLCLOOP             ANY DELIMITERS LEFT TO CHECK ?
         B     EROUT                   BRANCH TO ERROR ROUTINE
*
EXCLC    CLC   1(1,R4),0(R9)           EXECUTED INSTRUCTION
*
*        EROUT
*
*        CHECKS ALL SECTIONS OF THE KEYWTAB FOR AN EQUAL DELIMITER
*        TO THE ONE IN I/P, DISREGARDING LENGTH
*
*        IF NO EQUAL FOUND E14 IS GENERATED AND THE FIRST
*        APOSTROPHE IS DELETED. EXIT IS THEN TO TEST.
*        IF AN EQUAL IS FOUND E13 IS GENERATED AND AN BRANCH IS
*        TAKEN TO THE APPROPRIATE SUBPROGRAM
*
EROUT    TM    FBYTE,X'FF'
         BM    TYPESPEC                INVALID IDENTIFIER
         BO    COMCEE2                 COMMENT
EROUTOK  LA    R2,10                   GO THROUGH ALL POSSIBILITIES
         SR    R15,R15                 ZERO R14, R15
         SR    R14,R14
EROUT2   SLA   R14,2
         LA    R9,KWLUTAB
         L     R9,0(R14,R9)            GET SECTION IN KEYWTAB
         IC    R15,0(,R9)              NUMBER OF ENTRIES IN STRING
         LA    R9,1(,R9)               FIRST ENTRY
         SRA   R14,2
CLCERR   EX    R14,EXCLC               DELIMITER FOUND ?
         BNE   EROUT3                  NO
         TM    BITS2,STARTBIT          YES, PROGRAM STARTED YET ?
         BZ    STARTDEL                NO, CHECK FOR A CORRECT START
         BAL   R6,ERR13
*
         DC    X'000D'                 E13
*
         LA    R1,1(R14,R4)            SET R1 TO ONE BEYOND DELIMITER
         IC    R2,3(R14,R9)            GET DISPLACEMENT OF PROGRAM
         L     R6,DELPRGTB(R2)         IN DELPRGTB
         BR    R6                      BRANCH TO PROGRAM
*
EROUT3   LA    R9,4(R14,R9)            NOW GET NEXT DELIMITER
         BCT   R15,CLCERR              ALL DEL IN STRING CHECKED ?
         LA    R14,1(,R14)             YES, GET NEXT STRING
         BCT   R2,EROUT2
         TM    BITS2,X'20'             PROGRAM STARTED YET ?
         BZ    TESTLOOP                NO, RETURN TO MAINLOOP SCANNING
         BAL   R6,ERR2C
*
         DC    X'0A0E'                 E14
*
         LA    R1,1(,R4)               GET NEXT CHAR
         BR    R10                     RETURN
*
*        TYPESPEC
*
*        'REAL'' OR 'INTEGER'' OR 'BOOLEAN'' HAS BEEN FOUND
*
*        THE ONLY VALID DELIMITERS ARE AT THIS POINT ARRAY OR
*        PROCEDURE
*
TYPESPEC CLC   1(L'KWPROC,R4),KWPROC   PROCEDURE ?
         BE    TYPPROC                 YES
         TM    BITS2,X'20'             PROGRAM STARTED YET ?
         BZ    ERR8                    NO, GENERATE E11
         CLC   1(L'KWARRAY,R4),KWARRAY  ARRAY ?
         BE    TYPEARRY                YES
*                                      INVALID IDENTIFIER HAS BEEN
*                                      FOUND GOTO IER SPEC
TPSPECER TM    BITS1,X'40'             SPECIFICATION ?
         BO    TPSPEC01
         LA    R15,TYPEDAFI            NO, SET RETURN TO TYPE PGM
         B     IERSPEC
*
TPSPEC01 LA    R15,IDCHECK             YES, SET RETURN TO IDCHECK
         B     IERSPEC
*
*        COMSPEC
*
*        TWO APOSTROPHES HAVE BEEN FOUND IN A COMMENT
*
*        VALID DELIMITERS TO END A COMMENT ARE END OR ELSE
*
COMSPEC  LA    R9,KWELSE
         CLC   1(L'KWELSE,R4),KWELSE   COMMENT ENDING WITH ELSE ?
         BNE   COMSPECN                NO
         C     R14,KF3                 YES, CHECK CORRECT LENGTH
         BE    TED                     ELSE
         B     ENTRAPR                 R10 TO FIND ANOTHER QUOTE
*
COMSPECN CLC   1(L'KWEND,R4),KWEND     COMMENT ENDED WITH END ?
         BNE   ENTRAPR                 NO, R10 TO FIND ANOTHER QUOTE
         C     R14,KF2                 YES, CHECK CORRECT LENGTH
         BE    END                     END
         B     ENTRAPR                 R10 TO FIND ANOTHER QUOTE
*
*        STARTDEL
*
*        THE ONLY VALID DELIMITERS TO START A PROGRAM IS BEGIN
*        OR IF PRECOMPILED PROCEDURE IS SPECIFIED PROCEDURE OR
*        TYPE PROCEDURE
*
STARTDEL STC   R2,BCHAR                GET DELIMITERS CHARACTERISTIC
*                                      FROM KEYWTAB
         CLI   BCHAR,X'24'             BEGIN FOUND ?
         BE    FIRSTBEG                YES
         TM    COMPFLGS,PROC           PRECOMPILED SPECIFIED ?
         BZ    ERR8                    NO, GENERATE E11
         CLI   BCHAR,X'3C'             FOUND WORD IS PROCEDURE ?
         BNE   TYPEPR01                NO
         B     PROCEDUR                YES
*
TYPEPR01 CLI   BCHAR,X'18'             TYPE FOUND ?
         BNE   ERR8                    NO
TYPEPREC LA    R1,1(,R1)               LOOK FOR QUOTE TYPE PROC
TYPEPREA CLI   0(R1),XFQUOTE           QUOTE FOUND ?
         BNE   TYPEPR02                NO, BRANCH
         BCTR  R1,0                    YES, DECREASE TO LET TYPE PGM
         B     TYPE                    FIND THE QUOTE AGAIN
*
TYPEPR02 CLI   0(R1),XFBLANK           BLANK ?
         BE    TYPEPREC
         CLI   0(R1),XFZETA            ZETA ?
         BNE   ERR8                    NEITHER, GENERATE E11
         ST    R9,SAVE1+20             CHANGE I/P AND LOOK AGAIN
         BAL   R9,CIB
         L     R9,SAVE1+20
         B     TYPEPREA
*
*        NORMAL
*
*        INSERTS IN THE O/P THE INTERNAL CODE FROM KEYWTAB
*
NORMAL   BAL   R12,COB                 CHECK IF O/P AREA FILLED
         LA    R9,1(R14,R9)            COMPUTE ADDR OF CODE
         MVC   0(1,R3),0(R9)           MOVE CODE TO OUTPUT BUFFER
         LA    R3,1(,R3)               INCREASE OUTPUT AND
         LA    R1,1(,R1)               INPUT POINTERS
         BR    R10
*
*        BOLCON
*
*        MOVES OUT SIX BYTES OF INTERNAL CODE FOR FALSE OR TRUE
*
BOLCON   LA    R0,6(,R3)
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         MVC   0(5,R3),INT             TRANSFER FIRST PART
*                                      OF INTERNAL NAME
         LA    R7,1(R14,R9)            AND
         MVC   5(1,R3),0(R7)           LAST PART
         LA    R3,6(,R3)               INCR OUTPUT POINTER
         LA    R1,1(,R1)               INCR INPUT POINTERS
         BR    R10
*
*        GIF
*
*        TRANSFERS INTERNAL CODE BYTE AND EXITS TO THE STATEMENT
*        PROGRAM TO CHECK IF A PROCEDURE BOBY HAS STARTED
*
GIF      BAL   R12,COB                 CHECK IF O/P AREA FILLED
         LA    R7,1(R14,R9)            TRANSFER INTERNAL CODE
         MVC   0(1,R3),0(R7)
         LA    R3,1(,R3)               INCR OUTPUT POINTER
         LA    R1,1(,R1)               INCR INPUT POINTER
         B     STATE                   BRANCH TO STATEMENT PROGRAM
*
*        TED
*
*        TRANSFERS INTERNAL CODE
*        SETS POSSIBLE LABEL POINTERS
*
TED      TM    BITS2,ENDBIT            ELSE ENDED FINAL END COMMENT ?
         BO    ERR9                    YES
         BAL   R12,COB
         LA    R9,1(R14,R9)
         MVC   0(1,R3),0(R9)           TRANSFER INTERNAL CODE
         ST    R3,OPIN                 SET LABEL POINTERS
         MVC   OPIN+4(1),ONC
         MVC   OPINCHAR(1),0(R9)
         LA    R3,1(,R3)
         ST    R3,LAPIN
         LA    R1,1(,R1)
         NI    BITS2,X'FE'             SET ENDELSE BIT TO ZERO
         BR    R10
*
*        BEGIN
*
*        TEST IF PROC IN STACK
*
*        TRANSFERS 'BEGIN' TO OUTPUT AND STACK
*        SETS OPIN, OPIN+4, LAPIN, BEGBIT
*        BEGBIT IS USED TO DISTINGUISH BETWEEN COMPOUND BEGIN
*        AND BLOCK BEGIN. IF A DECLARATION IS FOUND WHEN THE
*        BEGBIT IS ON IT'S A BLOCK BEGIN THE BEGBIT IS TURNED OF
*        BY THE STATEMENT PROGRAM AND THE BEG1 PROGRAM
*
BEGIN    L     R15,SP
         CLI   0(R15),X'0C'            PROC IN STACK ?
         BE    BEGPROC                 YES, BRANCH TO PROC PROCESSING
         LA    R0,4(,R3)
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         MVI   0(R3),X'0C'             TRANSFER BEGIN TO O/P
         MVI   OPINCHAR,X'0C'          SET LABELSAVE
         ST    R3,OPIN                 NOTE ITS POSITION IN OPIN AND
         MVC   OPIN+4(1),ONC           THE NUMBER OF THE OUTPUT BUFFER
         LA    R3,1(,R3)               INCREASE OUTPUT POINTER
         ST    R3,LAPIN                NOTE WHERE LABEL MAY START
         OI    BITS1,X'80'             BEGBIT.= 1
         LA    R15,1(,R15)             INCR STACK POINTER
         C     R15,ATOPSTAK
         BL    BEGINAA
         BAL   R6,ERR4                 STACK OVERFLOW
*
         DC    X'0414'                 E20
*
BEGINAA  MVI   0(R15),X'08'            PUT BEGIN IN STACK
         ST    R15,SP
BEGINAB  LA    R1,1(,R1)
         B     TESTLOOP
*
*        BEGPROC
*
*        PROCEDURE - SPECIFICATIONS - BEGIN HAS BEEN FOUND
*
*        PROC BODY IS TO COME. PROC IS CHANGED TO PROC*
*        ITS CHECKED THAT ALL PARAMETERS HAVE BEEN SPECIFIED
*        THE RETURN IS TO TEST VIA THE BEGIN PROGRAM
*
BEGPROC  MVI   0(R15),X'10'            CONVERT PROC INTO PROC*
         NI    BITS1,X'BF'             PROBIT=0
         CLI   PZ,0                    ALL PARAMETERS SPECIFIED ?
         BE    BEGINAB                 YES
         BAL   R12,ERROR10             NO, GENERATE E11
         B     BEGINAB
*
*        FIRSTBEG
*
*        THE FIRST BEGIN IS CONSIDERED AS A BLOCK BEGIN
*        THE START BIT IS TURNED OFF
*        THE BEG1 PROGRAM IS JOINED
*        IF PRECOMPILED PROCEDURE HAS BEEN SPECIFID E42 IS GIVEN
*        AS A WARNING AND THE BEGIN IS DISREGARDED
*
FIRSTBEG TM    COMPFLGS,PROC           PRECOMPILED PROCEDURE ?
         BZ    FIRSTB01                NO, BRANCH
         BAL   R6,ERR7                 YES, GIVE WARNING MESSAGE
*
         DC    X'042A'
*
         LA    R1,1(,R1)               DISREGARD THE BEGIN
         B     TESTLOOP
*
FIRSTB01 OI    BITS2,X'20'             NO, TURN STARTBIT OFF
         LA    R9,TESTLOOP             MAKE RETURN FROM BEGI BE TEST
         LA    R1,1(,R1)
         B     BEG1FRST                FIRST BEGIN = BLOCK BEGIN
*
*        BEGI
*
*        BLOCK BEGIN PROGRAM
*
*        CHANGES BEGIN TO BETA IN STACK AND OUTPUT
*        INCREASES ITAB GROUP NUMBER AND PROGRAM BLOCK NUMBER
*        ENTRIES ARE MADE IN -
*        GROUPTABEL
*        SURROUNDING BLOCKS IG. NR
*        PBTAB1
*        SURROUNDING PBN
*        SCTAB - CURRENTSC COUNTER
*        ITAB
*        ADDRS OF SURROUNDING BLOCK AND IG HEAD ENTRIES, NEW
*        PBN AND IGN
*        LPBP (ADDR OF CURRENT PROGRAM BLOCK HEAD ENTRY)
*        AND
*        LIGP (ADDR OF CURRENT ITAB GROUP HEAD ENTRY)
*        ARE UPDATED
*        PUTS BETA + NEW PBN AND IGN TO OUTPUT REC.
*
BEG1     BCTR  R3,0
         NI    BITS1,BEGOFF            BEGBIT 0
         CLI   0(R3),X'0C'             BEGIN IN O/P ?
         BNE   ERROR21                 NO, DECLARATION INCORRECT PLACE
BEG1FRST MVI   0(R3),X'0D'             MOVE BETA TO O/P
         L     R15,SP                  AND
         MVI   0(R15),X'04'            STACK
         SR    R6,R6
         LH    R6,IGC
         LA    R6,1(,R6)               INCREASE ITAB GROUP NUMBER
         STH   R6,IGC
         AR    R6,R6                   ENTRY IS TO GO INTO
         AH    R6,IGC                  A(GT)+3*(IGC)
         A     R6,AGT
         L     R7,LIGP
         MVC   0(2,R6),8(R7)           ENTRY INTO GROUPTABLE
         MVI   2(R6),0
         NI    0(R6),X'7F'             CLEAR POSSIBLE PHI IND
         CLI   PBC,255                 MORE THAN 255 BLOCKS ?
         BNE   BEG1FAAA
         BAL   R6,ERR4
*
         DC    X'0416'                 E22
*
BEG1FAAA IC    R2,PBC
         LA    R2,1(,R2)               INCR PROGRAM BLOCK NUMBER
         STC   R2,PBC
         L     R7,LPBP
         LA    R6,PBTAB1
         AR    R6,R2
         MVC   0(1,R6),10(R7)          ENTRY INTO PROGRAM BLOCK TABLE
         STC   R2,1(,R3)               TRANSFER PBN TO O/P
         AR    R2,R2                   MAKE ENTRY OF CURRENT
         LA    R6,SCTAB(R2)            SEMCNT COUNTER IN SCTAB
         MVC   0(2,R6),SEMCNT
         MVC   2(2,R3),IGC             IGN IN OUTPUT BUFFER
         LA    R3,4(,R3)
         ST    R3,LAPIN                SET LABEL POINTERS
         L     R15,AITL                MAKE BLOCK HEAD IN ITAB
         MVC   0(4,R15),LIGP
         MVC   4(4,R15),LPBP
         MVC   8(2,R15),IGC
         MVC   10(1,R15),PBC
         ST    R15,LPBP                UPDATE LIGP AND LPBP
         ST    R15,LIGP
         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY
         BR    R9
*
*        END
*
*        ACTION DEPENDS ON WHAT IS IN THE STACK
*
*        TURNS IN ALL CASES OFF THE DELTABIT AND THE END ELSE
*        BIT
*        GENERAL RETURN POINT IS CSPEND IF RETURN ADDR, IN
*        R4, IS NOT CHANGED
*        FINAL RETURN IS TO TEST VIA SEMCO OR COMMENT PROGRAM
*        PROC** IN STACK ACTIVATES PBLOCKEND AND RETURNS TO END
*        TO INSPECT THE STACK AGAIN
*
END      NI    BITS1,X'DF'             DELTABIT.=0
         TM    BITS2,ENDBIT            END FINISHED FINAL END COMMENT ?
         BO    ERR9                    YES
         NI    BITS2,X'FE'             SET ENDELSE BIT TO ZERO
CSPEND   LA    R4,*                    RETURN FOR PBLCKEND, FOREND
         L     R15,SP
         IC    R2,0(,R15)              BRANCH
         L     R6,PROG1(R2)            DEPENDING ON TOP BYTE
         BR    R6                      OF THE STACK
*
PROG1    DC    A(ERR8)                 +00 E11 IF ALPHA
         DC    A(BLOCKEND)             +04 BETA
         DC    A(COMPDEND)             +08 BEGIN
         DC    A(PREND)                +12 PROC
         DC    A(STAREND)              +16 PROC*
         DC    A(PBLCKEND)             +20
         DC    A(FOREND)               +24 FOR
*
*        STAREND
*
*        PROC* HAS ENDED
*
*        ACTIVATES THE PBLOCK END PROGRAM AND RETURNS AFTERWARDS
*        TO TEST VIA COMMENT PROGRAM
*
STAREND  OI    BITS1,X'20'             DELTABIT= 1
         LA    R4,COMMEND              LOAD ADDR OF END ENTRY
*                                      INTO COMMENT PROGRAM
         B     PBLCKEND
*
*        PREND
*        PROC HAS ENDED
*
*        CHECKS IF ALL PARAMETERS SPECIFIED.
*        TURNS OFF THE PROBIT.
*        A PROC THAT ENDS WITH 'END' IS NOT CORRECTED, THEREFORE
*        THE STACK IS AGAIN INSPECTED AFTER THE PBLOCKEND PROGRAM
*        HAS BEEN ACTIVATED
*
PREND    NI    BITS1,X'BF'             PROBIT.=0
         CLI   PZ,0                    ALL PARAMETERS SPECIFIED ?
         BE    PBLCKEND                YES, ACTIVATE PBLCKEND
         BAL   R12,ERROR10             NO, GENERATE E10 FIRST
         B     PBLCKEND
*
*        COMPDEND
*
*        A COMPOUND STATMENT HAS ENDED
*
*        TRANSFERS END '2C' TO OUTPUT AND RELEASES BEGIN IN
*        STACK.
*        THEN IT CHECKS IF THE END OF THIS COMPOUND STATEMENT
*        INDICATES THE END OF ANY FOR STATMENT(S) OR PROC**.
*        THIS IS DONE WITH BITS2 X'01' AND THE COMMENT PROGRAM.
*        IF THE END IS FOLLOWED BY A ., OR 'END' THE STACK IS
*        INSPECTED AGAIN.
*        IF THE END IS FOLLOWED BY AN 'ELSE' THE COMPOUND
*        STATMENT ITSELF IS ALL THAT HAS ENDED AT THIS POINT.
*
COMPDEND BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFEND             TRANSFER END TO OUTPUT BUFFER
         LA    R3,1(,R3)               INCR OUTPUT POINTER
         L     R15,SP                  RELEASE BEGIN IN
         BCTR  R15,0                   STACK
         ST    R15,SP
COMPENDI CLI   0(R15),X'00'            ALPHA IN STACK ?
         BE    PGMEND                  YES, LOGICAL PROGRAM END
         CLI   0(R15),X'14'            PROC** ?
         BL    COMMEND                 BRANCH TO COM-PROGRAM, END-ENTRY
*                                      FOR BEGIN OR BETA OR PROC*
*                                      IN STACK
         OI    BITS2,X'01'             SET END-ELSE BIT
         B     COMMEND                 CHECK HOW END COMMENT ENDS
*                                      DCOMMENT ENDED WITH A SEMICOLON
COMPEND2 NI    BITS2,X'FE'             RESET END ELSE BIT
         L     R15,SP                  INSPECT STACK AGAIN
         CLI   0(R15),X'14'            PROC** OR FOR IN STACK ?
         BE    COMPEND3                PROC**
         LA    R4,COMPEND4             FOR GOTO FORENS AND THEN
         B     FOREND                  TEST AGAIN - COMPEND4
*
COMPEND3 OI    BITS1,X'20'             PROC**- SET DELTABIT
         LA    R4,SEMCO                RETURN FROM PBLCKEND
         B     PBLCKEND                BLOCKEND FOR PROC**
*
COMPEND4 CLI   0(R15),X'14'            PROC**,FOR OR SE ?
         BE    COMPEND3                PROC**
         BH    FOREND                  FOR
         B     SEMCO                   SOMETHING ELSE
*
*        BLOCKEND
*
*        A BETA BLOCK HAS ENDED
*
*        THE RETURN AFTER THE PBLOCKEND PROGRAM IS TO THE
*        COMPENDI TO CHECK IF SOME MORE ITAB GROUP SHOULD END AT
*        THIS POINT
*
BLOCKEND BAL   R4,PBLCKEND             EXECUTE PROGRAM BLOCKEND
         B     COMPENDI
*
*        FOREND
*
*        CORRECTS THE LIGP POINTER
*
*        INSERTS A CONTINUATION LINE IN ITAB IF THE FORSTATMENT
*        CONTAINED ANY LABEL.
*        IF THE FORSTATMENT DID NOT CONTAIN ANY DEKLARATIONS THE
*        PREVIOUSC CREATED FOR HEADENTRY IS ERASED.
*        IF ONE CONTINUATION LINE IS CREATED, FOLLOWING
*        ENCLOSING FORSTATEMENTS WILL OVERLAY THE FIRST
*        CONTINUATION LINE, IF LABELS OR NOT ETA AND SURROVNDING
*        ITABGROUPS IG NR. IS MOVED TO THE OUTPUT
*        FOR IS RELEASED IN THE STACK
*
*        ENTERED FROM SEMCO, END
*        EXITS TO END, COMPEND4, STACKTST (IN SEMCO)
*
FOREND   L     R6,LIGP
         MVC   LIGP(4),0(R6)           GET PREVIOUS LIGP HEAD
         L     R15,AITL                CURRENT ENTRY
         S     R15,KF11                MINUS ELEVEN
         TM    6(R15),X'FF'            CONTINUATION LINE NEEDED ?
         BZ    EMPTYFOR                NO
         BO    FORENDAA                OVERLAY PREVIOUS CONT LINE
         LA    R15,11(,R15)            CREATE NEW CONT LINE
FORENDAA L     R6,LIGP
         MVC   8(2,R15),8(R6)          COPY IG NUMBER
         MVI   6(R15),X'FF'            CONTINUATION LINE INDICATOR
         NI    8(R15),X'7F'            CLEAR POSSIBLE PHI INDICATOR
         MVI   5(R15),XFBLANK
         BAL   R12,ITABCLEA+4          CLEAR NEXT ENTRY
         B     EMPTYFAA
*
EMPTYFOR BAL   R12,ITABCLEC            CLEAR FORHEAD FOR EMPTY FORGROUP
EMPTYFAA LA    R0,3(,R3)
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         MVI   0(R3),XFBLANK           INSERT ETA
         L     R6,LIGP
         MVC   1(2,R3),8(R6)           AND CURRENT IGN IN OUTPUT BUFFER
         NI    1(R3),X'7F'             CLEAR EVENTUALLY PHI
         LA    R3,3(,R3)
         L     R15,SP                  RELEASE FOR IN STACK
         BCTR  R15,0
         ST    R15,SP
         BR    R4                      RETURN
*
*        PBLCKEND
*
*        ERASES EMPTY CONTINUATION LINES
*        WRITES OUT THE PROGRAM BLOCK TO SYSUT3
*        LENGTH IS CALCULATED AND SAVED IN ITABLEN AND STORED IN
*        THE FIRST TWO BYTES OF THE ITAB RECORD
*        SEMCNT IS PICKED UP FROM SCTAB AND ENTERED IN BYTES 6+7
*        THE BLOCK IS MOVED TO THE ITAB BUFFER WHERE IT
*        IS WRITTEN OUT
*        THE SURROUNDING BLOCKS NEW DECLARATIONS WILL BE
*        OVERLAYING THE OUTWRITTEN RECORD
*        AITL WILL POINT TO THE HEADENTRY'S PLACE OF THE BLOCK
*        WHICH NOW WAS WRITTEN OUT
*        LPBP TO THE SURROUNDING BLOCKS HEADENTRY
*        LIGP TO THE SURROUNDING ITABGROUPS HEADENTRY
*        AITL, LPBP AND LIGP WILL BE MODIFIED ACCORDINLY
*        EPSILON, THE SURROUNDING BLOCKS PBN AND IGN WILL BE PUT
*        TO THE OUTPUT
*        THE BLOCK INDICATOR IN THE STACK WILL BE RELEASED IF
*        STACK NOW IS EMPTY - ALPHA IN STACK - PGMEND WILL SET
*        THE END BIT AND CHANGE END OF DATA EXIT TO EODADIN. THIS
*        WILL CAUSE THE COMMENT PROGRAM TO CHECK FOR AN CORRECT
*        ENDCOMMENT BUT NOTHING MORE IS TO BE PROCESSED.
*        FOR PROGRAM BLOCK 0, IF ANY, THE BLOCK WILL ONLY BE
*        WRITTEN OUT AND NO FURTHER ACTIONS TAKEN.
*
*        ENTERED FROM END (BETA, PROC*), SEMCO (PROC, PROC**)
*
*        EXITS TO COMMEND (NORMAL), COMPEND4 (PROC OR PROC**
*        FOLLOWED BY END), TERMINATION (NOPBN0)
*
PBLCKEND L     R15,AITL
PBLCKEAA S     R15,KF11                SUBTRACT 11 TO EARSE
         CLI   6(R15),0                EMPTY
         BE    PBLCKEAA                CONTINUATION
         LA    R15,11(,R15)
WRTITAB  S     R15,LPBP                COMPUTE LENGTH OFITAB SECTION
         ST    R15,ITABLEN
         C     R15,KF2000              ITAB SECTION TOO LONG ?
         BL    WRTITABA                NO, BYPASS ERROR
         BAL   R6,ERR4
*
         DC    X'0426'                 E38 MORE THAN 184 IDENTIFIERS
*
WRTITABA MVC   AITL(4),LPBP            UPDATE AITL
         L     R6,LPBP
         MVC   LIGP(4),0(R6)           UPDATE LIGP
         MVC   LPBP(4),4(R6)           UPDATE LPBP
         MVC   0(2,R6),ITABLEN+2       INSERT LENGTH IN HEADENTRY
         MVI   5(R6),XFBLANK
         STM   R14,R3,SAVE1            SAVE REGISTERS
         SR    R2,R2
         IC    R2,10(,R6)              GET CORRENT PBN
         AR    R2,R2                   INSERT SEMCNT AT BLOCKSTART
         LA    R7,SCTAB(R2)            IN HEADING
         MVC   6(2,R6),0(R7)
         TM    BITS2,X'08'             PB0 ?
         BZ    WRTITABB                NO
         MVI   6(R6),0                 CORRECT SEMCNT
         MVI   7(R6),0                 FOR PB0
WRTITABB TM    BITS3,FRSITB            FIRST BLOCK TO BE WRITTEN ?
         BZ    WRT1                    YES, DO NOT CHECK
         STM   R14,R15,ERRSAVE         CHECK PREVIOUS WRITE
*
         CHECK ITABC
*
         LM    R14,R15,ERRSAVE
WRT      L     R7,AITABBUF             ADDR OF BUFFER
COMPARE1 C     R15,KF256               MORE THAN 256 BYTES TO MOVE ?
         BL    EXMVC1                  NO, MOVE ALL AT ONCE
COMPARE2 MVC   0(256,R7),0(R6)         YES, MOVE A SECTION OF 256
         LA    R6,256(,R6)             BYTES AT A TIME
         LA    R7,256(,R7)
         S     R15,KF256
         C     R15,KF256               STILL MORE THAN 256 LEFT ?
         BH    COMPARE2                YES, MOVE NEXT SECTION
EXMVC1   EX    R15,MOVE4               MOVE A SECTION OF LESS THAN 256
         LA    R3,0(R15,R7)
         L     R7,AITABBUF             LOAD ADDR OF ITAB BUFFER
         L     R15,AUT3DCB                          SYSUT3 DCB
         L     R14,ITABLEN                          LENGTH
*
         WRITE ITABC,SF,(R15),(R7),(R14)
*
         LM    R14,R3,SAVE1
         TM    BITS2,X'08'             PB0 WAS WRITTEN ?
         BOR   R4                      BRANCH BACK IF TERBIT ON
         L     R6,AITL                 CLEAR
         MVI   0(R6),0                 NEXT
         MVC   1(10,R6),0(R6)          ITABENTRY
         LA    R0,4(,R3)
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         MVI   0(R3),X'2A'             INSERT EPSILON
         L     R6,LPBP
         MVC   1(1,R3),10(R6)                 PBN
         L     R6,LIGP
         MVC   2(2,R3),8(R6)                  IGN
         NI    2(R3),X'7F'             CLEAR FIRST BIT OF IGN (PHI IND)
         LA    R3,4(,R3)
         L     R15,SP                  RELEASE
         BCTR  R15,0                   TOPBYTE
         ST    R15,SP                  IN STACK
         TM    BITS1,X'01'             TERMINATION BIT ON ?
         BOR   R4                      YES, RETURN TO ENDMISS PGM
         CLI   0(R15),0                STACK EMPTY ?
         BE    PGMEND                  YES, LOGICAL PROGRAM ENP
         BR    R4                      RETURN
*
PGMEND   OI    BITS2,ENDBIT            SET ENDBIT
         LA    R12,EODADIN             NEW EOD ADDR
         ST    R12,EODIN
         B     COMMEND
*
WRT1     OI    BITS3,FRSITB            DON'T CHECK FIRST TIME
         B     WRT
*
MOVE4    MVC   0(1,R7),0(R6)           PBLCKEND MOVE FOR ITAB
*
SCTAB    DC    XL256'00'
         DC    XL254'00'
*
*        COMMENT
*
*        THREE ENTRIES -
*        1. COM FOR THE ALGOL WORD COMMENT
*           SETS CODIT=1, CHECKS THAT COMMENT IS IN A LEGAL
*           POSITION
*        2. COMERR FOR ERRORS IN DECLARATIONS
*           ALL CHARACTERS TO NEXT SEMICOLON WILL BE SKIPPED
*           SET COBIT AND DELTABIT = 1
*        3. COMMEND ENTERED AFTER AN END IS FOUND
*           SKIPS ALL CHARACTERS TO NEXT ; OR END OR ELSE SETS
*           THE COBIT = 0
*
COMERR   OI    BITS2,X'40'             SET COBIT AND
         OI    BITS1,X'20'             DELTABIT ON
         B     COMCEE2
*
COMMEND  NI    BITS2,X'BF'             SET COBIT TO 0
         B     COMCED2
*
COM      OI    BITS2,X'40'             SET COBIT TO I
         LR    R4,R3
         BCTR  R4,0
         CLI   0(R4),X'0C'             BEGIN IN O/P ?
         BE    COMCED2
         BCTR  R4,0
         BCTR  R4,0
         CLI   0(R4),X'0B'             BETA IN O/P ?
         BE    COMCED2
         CLI   0(R4),XFDELTA           DELTA IN O/P ?
         BE    COMCED2
         BCTR  R4,0
         CLI   0(R4),X'0D'             SEMICOLON IN O/P ?
         BE    COMCED2
         BAL   R6,ERR7                 E18
*
         DC    X'0412'
*
COMCED2  LA    R1,1(,R1)               INCR R1
COMCEE2  BALR  R9,0
         SR    R2,R2
         TRT   0(73,R1),COMTABLE       SCAN THE COMMENT
         LA    R4,0(R2,R9)             BRANCH WITH OFFSET FROM COMTABLE
         BR    R4                      TO APPROPRIATE ROUTINE
*
***********************************************************************
*
*        ROUTINES COMAPOST, COMZETA, COMPOINT AND COMSEMCO
*        ARE ADDRESSED AS OFFSETS FROM COMCEE2 VIA COMTABLE
*
*        COMAPOST
*
*        IF AN END COMMENT IS PROCESSED, COBIT= 0, CHECK IF
*        APOSTROPHE IS THE START OF END OR ELSE OTHERWISE RETURN
*        TO SCAN THE COMMENT AGAIN
*
COMAPOST TM    BITS2,X'40'             COBIT ON ?
         BO    COMCED2                 YES, RETURN TO SCANNING AGAIN
         MVI   FBYTE,X'FF'             SET FBYTE
         B     ENTRAPR                 RETURN TO APOSTROE PROGRAM
*
COMZETA  B     CIB                     ZETA - RETURN TO COMERR
*
*        COMPOINT
*
*        CHECK FOR SEMICOLON ., IF NOT RETURN
*
COMPOINT LA    R6,COMCEE2               RETURN IF NOT SEMCOLON
         BAL   R12,FINDSEMC
*
*        COMSEMCO
*
*        ENDELSE BIT ON -
*        END COMMENT AFTER BEGIN OR BETA ENDED WITH A ., MEANS
*        THAT THE END MIGHT ALSO CLOSE AN FOR STATEMENT OR A
*        PROCEDURE.
*        ENDBIT ON -
*        FINAL END HAS BEEN REACHED NOTHING IS TO FOLLOW THIS
*        COMMENT IN THE CORRECT CASE.
*        AN SEMICOLON AFTER AN COMMENT IS NOT TO BE COUNTED THAT
*        IS COBIT= 1 AND DELTABIT=0 RETURN TO TEST OTHERWISE
*        RETURN VIA SEMICOLON PROGRAM
*
COMSEMCO TM    BITS2,X'01'             END ELSE BIT ?
         BO    COMPEND2                YES
         TM    BITS2,ENDBIT            FINAL END COMMENT HAS ENDED ?
         BO    READROUT                YES, OK
         TM    BITS2,X'40'             COMMENT ?
         BZ    SEMCO                   NO
         TM    BITS1,X'20'             DELIMITER ERROR ?
         BO    SEMCO                   YES
         LA    R1,1(,R1)               FOR A COMMENT SKIP SEMICOLON
         B     TESTLOOP
*
***********************************************************************
*
*        FOR
*
*        INCREASES IG AND FSN NUMBER
*        MAKES ENTRIES IN SCOPE AND GROUPTABE
*        MOVES FOR (18) TO OUTPUT FOLLOWED BY NEW IG NUMBER
*        CHECKS IF PROC IN STACK, IF YES PROC IS CHANGED TO
*        PROC**
*        PUTS FOR IN STACK
*        AN FORHEAD ENTRY IS MADE IN ITAB
*        THE RETURN IS TO TEST
*
FOR      LA    R0,3(,R3)
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         LH    R15,IGC                 INCREASE ITAB GROUP NUMBER
         LA    R15,1(,R15)
         MVI   0(R3),XFFOR             MOVE 'FOR'
         STH   R15,IGC                 AND IGN
         MVC   1(2,R3),IGC
         LA    R3,3(,R3)               TO OUTPUT BUFFER
         CLI   FSN,255                 > 255 FOR STATEMENTS ?
         BNE   FORAA
         BAL   R6,ERR4
*
         DC    X'0429'                 E41
*
FORAA    IC    R2,FSN                  INCREASE FSN
         LA    R2,1(,R2)
         STC   R2,FSN
         LA    R12,SPTAB-1
         AR    R12,R2
         L     R15,LPBP
         MVC   0(1,R12),10(R15)        MAKE ENTRY IN SCOUP TABLE
         NI    BITS1,X'7F'             BEGBIT= 0
         L     R12,SP
         C     R12,ATOPSTAK            STACK OVERFLOW ?
         BL    FORBB
         BAL   R6,ERR4
*
         DC    X'0414'                 E20
*
FORBB    CLI   0(R12),X'0C'            PROC IN STACK ?
         BNE   NOPROCBY                NO
         MVI   0(R12),X'14'            MAKE PROC BE PROC**
         NI    BITS1,X'BF'             PROBIT=0
         CLI   PZ,0                    ALL PARAMETERS SPECIFIED ?
         BE    NOPROCBY                YES
         BAL   R12,ERROR10             NO, GENERATE E10
NOPROCBY L     R12,SP
         LA    R12,1(,R12)             INCR STACK POINTER
         MVI   0(R12),XFFOR            PUT FOR INTO STACK
         ST    R12,SP
         LH    R12,IGC
         AR    R12,R12
         AH    R12,IGC
         A     R12,AGT
         L     R15,LIGP
         MVC   0(2,R12),8(R15)         ENTRY INTO GROUP TABLE
         STC   R2,2(R12)
         NI    0(R12),X'7F'            CLEAR POSSIBLE PHI IND
         L     R15,AITL
         MVC   0(4,R15),LIGP           CONSTRUCT FOR HEAD ENTRY IN ITAB
         MVI   5(R15),X'2B'
         MVC   8(2,R15),IGC
         ST    R15,LIGP                UPDATE LIGP
         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITAB ENTRY
         LA    R1,1(,R1)
         B     TESTLOOP
*
*        TYPE
*
*        ENTRED FOR INTEGER, REAL AND BOOLEAN.
*        TESTS FOR NEWBLOCK, BEGBIT, AND IF IDENTIFIER IS
*        SPECIFIED, PROBIT.
*        MOVES INTERNAL NAME CHARACTERISTICS AND PBN TO ITAB.
*        CHECKS THE IDENTIFIER FOR VALIDITY AND MOVES UP TO 6
*        CHARACTERS TO ITAB EXTERNAL NAME.
*        IF THE FIRST CHARACTER FOUND IS AN APOSTROPHE THE CHECK
*        IS VIA APOSTROF, DELIMITER AND TYPESPEC FOR ARRAY OR
*        PROCEDURE (FBYTE=F0)
*
TYPE     TM    BITS1,X'40'             PROBIT = 1 ?
         BO    SPECENT                 YES
         TM    BITS1,X'80'             BEGBIT = 1 ?
         BZ    TYPEAA
         ST    R9,SAVE1                IF YES GOTO BEGI PGM
         BAL   R9,BEG1
         L     R9,SAVE1
TYPEAA   L     R15,AITL                MOVE CHARACTERISTICS TO ITAB
         MVI   6(R15),X'C0'            TO THE 7TH AND 8TH
         MVI   7(R15),X'30'            BYTE OF THE ENTRY
         LA    R6,2(R14,R9)            MODIFIY THE LAST 4 BITS WITH
         MVN   7(1,R15),0(R6)          INFORMATION FROM THE KEYWTAB
         L     R6,LPBP
         MVC   8(1,R15),10(R6)         MOVE IN PROGRAM BLOCK NUMBER
TYPEDAFI LA    R1,1(,R1)               GET NEXT CHARACTER
         CLI   0(R1),XFA               CHAR A LETTER ?
         BNL   TYPENAME                YES
         CLI   0(R1),XFBLANK           BLANK ?
         BE    TYPEDAFI
         CLI   0(R1),XFZETA            ZETA ?
         BNE   TYPEBB
         LA    R9,TYPEDAFI+4           CHANGE INPUT
         B     CIB                     BUFFER
*
TYPEBB   CLI   0(R1),XFQUOTE           QUOTE ?
         BE    TYPECC
         LA    R15,TYPEDAFI            STORE RETURN ADDR
         B     IERSPEC                 GOTO ERROR ROUTINE
*
TYPECC   MVI   FBYTE,X'F0'             MOVE F0 TO FBYTE
         B     ENTRAPR                 CHECK FOR TYPE ARRAY OR PROC
*
TYPENAME L     R7,AITL                 GET ITAB POINTER
         MVC   0(1,R7),0(R1)           MOVE FIRST CHAR TO ITAB
         LA    R7,1(,R7)               INCREASE POINTER
         LA    R2,1                    INITIALIZE COUNTER
         LA    R9,TYPENM03             RTN IF CHANGE OF I/P BUF NEEDED
TYPENM02 LA    R1,1(,R1)               GET NEXT CHAR
TYPENM03 CLI   0(R1),XFZETA            LETTER, ZETA OR SOMETHING ELSE ?
         BE    CIB                     CHANGE I/P BUFFER
         BL    TLISTSE                 CHECK FURTHER
         C     R2,KF6                  6 CHAR ALREADY MOVED IN ?
         BE    TYPENM02                YES
         MVC   0(1,R7),0(R1)           NO, MOVE IN NEXT CHAR
         LA    R7,1(,R7)               INCREASE
         LA    R2,1(,R2)               POINTERS
         B     TYPENM02                TAKE NEXT CHAR
*
TLISTSE  CLI   0(R1),XFBLANK           BLANK ?
         BE    TYPENM02
         CLI   0(R1),XFCOMMA           COMMA ?
         BE    TYPECOMA
         LA    R15,TYPEDAFI            RETURN ADDR FOR IER
         LA    R6,IER                  RETURN ADDR IF NO SEMICOLON
         BAL   R12,FINDSEMC            LOOK FOR SEMICOLON
*
*        TYPESEMC
*
*        SEMICOLON FOUND
*        END OF THIS DECLARATION
*        DELTABIT IS TURNED ON AND THE RETURN TO TEST IS VIA
*        SEMCO
*
TYPESEMC BAL   R12,ITABCLEA            CLEAR NEXT ITAB ENTRY
         OI    BITS1,X'20'             SET DELTABIT TO ONE
         B     SEMCO                   GO TO SEMICOLON PROGRAM
*
*        TYPECOMA
*
*        AN COMMA ENDED THE IDENTIFIER
*        THE INTERNAL NAME IS COPIED AND TYPE PROGRAM UTILIZED
*        AGAIN
*
TYPECOMA L     R9,AITL
         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY
         MVC   6(3,R15),6(R9)          COPY ID AND PBN FIELDS
         B     TYPEDAFI                RETURN TO CHECK NEXT IDENTIFIER
*
*        IER
*
*        IDENTIFIER ERROR ROUTINE
*
*        HAS 2 ENTRIES -
*        1. IERSPEC IF FIRST CHARACTER IS IN ERROR, E5
*        2. IER ANY OTHER CHARACTER, E16
*        RETURN -
*        1. VIA R15 IF AN COMMA IS FOUND AFTER
*           THE IDENTIFIER IN ERROR.
*        2. TO TEST VIA SEMCO IF AN SEMICOLON IS FOUND.
*        3. TO PROCFIN IF AN RIGHT PARENTHESIS IS FOUND AND THE
*        FMBIT IS ON WHICH INDICATES THAT THE FORMAL PARAMETER
*        LIST OF A PROCEDURE IS UNDER PROCESS
*
*        R15 MIGHT LEAD TO TYPEDAFI, IDCHECK, PROCID
*
IERSPEC  BAL   R6,ERR7
*
         DC    X'0405'                 E5
*
         B     IERSPECA
*
IER      BAL   R6,ERR2
*
         DC    X'0010'                 E16
*
IERSPECA L     R7,AITL                 RESET R7 TO START
         MVI   0(R7),0                 CLEAR EXTERNAL NAME PART
         MVC   1(5,R7),0(R7)
IERCOMMA LA    R1,1(,R1)
         LA    R6,IERSELSE             RETURN IF NO SEMICOLON FOUND
         BAL   R12,FINDSEMC            LOOK FOR SEMICOLON
IERSEMCO L     R15,AITL                SEMICOLON FOUND - END OF DCL.
         BAL   R12,ITABCLEC            CLEAR ITAB ENTRY
         TM    BITS3,FMBIT             FORMAL PARAMETER LIST PROCESSED?
         BO    SCYES3-8                YES, RETURN TO PROCEDURE END
         OI    BITS1,X'20'             DELTABIT = 1
         NI    BITS2,X'EF'             VALBIT=0
         MVC   KB(2),KF0               CKB = 00
         B     SEMCO                   RETURN TO TEST VIA SEMCO
*
IERSELSE CLI   0(R1),XFCOMMA           COMMA ?
         BER   R15                     RETURN IF COMMA FOUND
         TM    BITS3,FMBIT             FORMAL PARAMETER LIST PROCESSED?
         BZ    IERCOMMA                NO
         CLI   0(R1),XFRBRAC           RIGHT BRACKET ?
         BE    PROCFIN                 YES, GOTO PROCEDURE END HANDLING
         B     IERCOMMA                CONTINUE CHECKING NEXT CHAR
*
*        CODE
*
*        SETS THE PROBIT TO ZERO
*        CHECKS THAT CODE IS IN THE CORRECT PLACE AND IS
*        FOLLOWED BY A SEMICOLON
*        CORRECTS THE INTERNAL NAME OF THE PROCEDURE
*        TRANSFER THE NAME IN EXTERNAL FORM TO OUTPUT
*        RETURNS VIA PROGRAM BLOCK END TO TEST
*
CODE     NI    BITS1,X'BF'             PROBIT=0
         CLI   PZ,0                    ALL PARAMETERS SPECIFIED ?
         BZ    CODEAA                  YES
         BAL   R12,ERROR10             NO, GENERATE E10
CODEAA   L     R15,SP
         CLI   0(R15),X'0C'            PROC IN STACK ?
         BNE   CODERR                  IF NO BRANCH TO ERROR
         LR    R14,R3
         S     R14,KF3
         CLI   0(R14),XFDELTA          DELTA IN O/P ?
         BNE   CODERR                  IF NO  BRANCH TO ERROR
         L     R15,LPBP
         S     R15,KF11                GET PROCEDURE NAME
         XI    7(R15),X'80'            INTERNAL NAME IS CORRECTED
         TM    19(R15),X'80'           TYPE PROCEDURE ?
         BZ    CODEBB
         XI    29(R15),X'80'           YES, CORRECT SECOND NAME ENTRY
CODEBB   LA    R0,9(,R3)
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         MVI   0(R3),X'3C'             TRANSFER GAMMA
         MVC   1(6,R3),0(R15)          TRANSFER NAME AND
         TR    1(6,R3),TRINTEXT        CONVERT TO EXTERNAL CODE
         MVI   7(R3),C' '              MOVE IN EXTERNAL BLANK
         MVI   8(R3),C' '              MOVE IN EXTERNAL BLANK
         LA    R3,9(,R3)
         OI    BITS1,X'20'             DELTABIT = 1
SEARCH   LA    R6,NOSEMC               RETURN IF NO SEMICOLON FOUND
         LA    R4,SEMCO                RETURN ADDR FOR PBLCKEND
         LA    R1,1(,R1)
         BAL   R12,FINDSEMC            SEMICOLON FOLLOWS ?
         B     PBLCKEND                SEMICOLON FOUND, GOTO PBLCKEND
*
NOSEMC   BAL   R6,ERR7
*
         DC    X'040F'                 E15
*
         LA    R6,FINDSEMC             PERIOD FOUND ?
         CR    R6,R9
         BE    PBLCKEND                NO
         BCTR  R1,0                    YES
         MVI   0(R1),XFPERIOD          MOVE IN A PERIOD
         BCTR  R1,0                    DECREASE R1, WILL BE INCREASED
         B     PBLCKEND                BY SEMCO. RETURN VIA PBLCKEND
*
CODERR   BAL   R6,ERR7
*
         DC    X'0418'                 E24
*
         B     COMERR                  SKIP TO NEXT SEMICOLON
*
*        SPEC
*
*        ENTERED FOR LABEL AND STRING
*        CHECKS THAT THEY ARE IN PROCEDURE HEAD
*
SPEC     TM    BITS1,X'40'             PROBIT ON ?
         BO    SPECENT                 YES, PROCESS SPECIFIED
*                                      LABEL OR STRING
         BAL   R6,ERR7
*
         DC    X'0419'                 E25
*
         B     COMERR                  SKIP TO NEXT SEMICOLON
*
*        SPECENT
*
*        ENTERED FOR SPECIFICATIONS FROM -
*        TYPE
*        SPEC
*        ARRAY
*        SWITCH
*        PROCEDURE
*        SAVES IN KB THE CHARACTERISTICS TAKEN FROM THE
*        DELIMITER TABLE
*
SPECENT  LA    R15,1(R14,R9)           MOVE IN IDFIELD
         MVC   KB(2),0(R15)
*
*        IDCHECK
*
*        ENTERED FROM -
*        VALUE
*        TYPEARRAY
*        TYPEPROCEDURE
*        SPECENT
*        CHECKS THE NAME FOR FORMAL PARAMETERS
*        FINDS THE ENTRY IN ITAB AND INSERTS THERE THE
*        CHARACTERISTICS AND PROGRAM BLOCK NUMBER.
*        DECREASES THE PARAMETER COUNT PZ BY ONE FOR EACH
*        CORRECT PARAMETER FOUND .
*        IF A COMMA ENDS THE IDENTIFIER IDCHECK WILL BE
*        ACTIVATED AGAIN.
*        IF A SEMICOLON ENDS THE DELIMITER THE RETURN IS TO TEST
*        VIA SEMICOLON PROGRAM
*
IDCHECK  LA    R1,1(,R1)               GET NEXT CHAR
         CLI   0(R1),XF9               LETTER ?
         BNH   IDNOLETR                NO
         MVC   IDBUCKET(6),KF0         CLEAR BUCKET WITH ZEROS
         LA    R7,IDBUCKET
         LA    R14,1
         MVC   0(1,R7),0(R1)           MOVE FIRST CHAR TO BUCKET
         LA    R7,1(,R7)
         LA    R9,IDLOOPAA             RETURN IF CIB NEEDED
IDLOOP   LA    R1,1(,R1)               GET NEXT CHAR
IDLOOPAA CLI   0(R1),XFZETA            ZETA ?
         BE    CIB                     YES
         BL    IDSEARCH                SOMETHING ELSE
         C     R14,KF6                 LETTER OR DIGIT
         BE    IDLOOP                  6 CHAR MOVED ALREADY YES ?
         MVC   0(1,R7),0(R1)           NO, MOVE CHAR
         LA    R7,1(,R7)               INCREASE POINTERS
         LA    R14,1(,R14)
         B     IDLOOP                  TAKE NEXT CHAR
*                                      FIRST CHAR WAS NOT LETTER
IDNOLETR CLI   0(R1),XFBLANK           BLANK ?
         BE    IDCHECK                 YES, GET NEXT CHAR
         CLI   0(R1),XFZETA            ZETA ?
         BNE   IDNOLETA                NO
         LA    R9,IDCHECK+4            YES, CHANGE I/P-BUFFER
         B     CIB                     BUFFER
*
IDNOLETA CLI   0(R1),XFQUOTE           QUOTE ?
         BE    IDNOLETB                YES
         LA    R15,IDCHECK             NO, SET RETURN ADD AND GOTO
         B     IERSPEC                 IDENTIFIER ERROR ROUTINE
*
IDNOLETB MVI   FBYTE,X'F0'             SET FBYTE, LOOK FOR TYPE
         B     ENTRAPR                 ARRAY OR TYPE PROC
*
IDSELSE  BAL   R6,ERR2E
*
         DC    X'0010'                 E16
*
         LA    R15,IDCHECK             RETURN ADDR FOR IER
         B     IERCOMMA                GOTO IDENTIFIER ERROR ROUTINE
*
IDBUCKET DC    6X'00'
*
IDSEARCH CLI   0(R1),XFBLANK           BLANK ?
         BE    IDLOOP                  YES, BRANCH
         CLI   0(R1),XFCOMMA           COMMA ?
         BE    IDCOMMA                 YES, BRANCH
         LA    R6,IDSELSE              IF NOT SEMICOLON FOUND
         BAL   R12,FINDSEMC            LOOK FOR SEMICOLON
         OI    BITS1,X'20'             SEMICOLON FOUND SET DELTABIT
IDCOMMA  CLC   PRIMPAR(4),KF0          ARE THERE ANY PARAMETERS ?
         BE    NOTFOUND                NO
         L     R12,PRIMPAR             GET FIRST PARAMETER
*
*        COMPID
*
*        A LOOP TO FIND THE PARAMETER IN ITAB
*
COMPID   CLC   IDBUCKET(6),0(R12)      CHECK IF IDENTIFIER FOUND
         BE    IDVALCHK                FOUND
         LA    R12,11(,R12)            NOT FOUND. TRY NEXT PARAMETER
         C     R12,AITL                IF THERE ARE ANY LEFT
         BNE   COMPID                  YES
NOTFOUND BAL   R6,ERR2E
*
         DC    X'001B'                 E27
*
         B     IDENDER
*
IDVALCHK TM    BITS2,X'10'             VALUE CALL ?
         BO    VALDLB2                 YES, GOTO VAL ROUTINE
         TM    6(R12),X'06'            SPECIAL USE BITS ON ?
         BZ    IDCHKEND                NO
         BAL   R6,ERR2E                YES, CREATE
*
         DC    X'001A'                 E26
*
         B     IDENDER                 GET NEXT IDENTIFIER
*
*        IDCHKEND
*
*        INSERTS CHARACTERISTICS AND PBN, DECRESES PZ.
*        IF BOTH VALUE AND NAME BIT ON BYTE 7 EQVALS 30 A VALUE
*        SPECIFICATION HAS BEEN MADE EARLIER SO IT IS CORRECTED
*        TO BE A CALL BY VALUE.
*
IDCHKEND L     R6,LPBP
         MVC   8(1,R12),10(R6)         INSERT PBN
         OC    6(2,R12),KB
         IC    R6,PZ                   CORRECT IDFIELD IS CREATED
         BCTR  R6,0                    PZ = PZ-1
         STC   R6,PZ
         TM    7(R12),X'30'            VALUE BIT ON ?
         BM    IDENDER
VALCALL  NI    7(R12),X'EF'            YES, ZERO NAME BIT
IDENDER  TM    BITS1,X'20'             DELTABIT ON ?
         BZ    IDCHECK                 NO, GET NEXT IDENT
         MVC   KB(2),KF0               YES, CLEAR IDFIELD
         NI    BITS2,X'EF'             SET VALBIT TO ZERO
         B     SEMCO                   GOTO SEMICOLON PROGRAM
*
*        VALUE
*
*        CHECKS THAT SPECIFICATION IS IN A PROCEDURE HEAD
*        EXITS FIRST TO IDCHECK TO FIND THE PARAMETER WILL THEN
*        RETURN TO VALDLB2 FOR FUTHER CHECKS AND TO INSERT THE
*        VALUE BIT IN THE INTERNAL NAME
*
VALUE    TM    BITS1,X'40'             PROCEDURE ?
         BZ    VALUERR                 NO, ERROR
         OI    BITS2,X'10'             YES, SET VALUE BIT TO ONE
         B     IDCHECK                 AND GO TO IDCHEK
*
VALUERR  BAL   R6,ERR7                 E28 VALVE
*
         DC    X'041C'                 OUTSIDE PROC
*
         B     COMERR                  SKIP TO NEXT SEMICOLON
*
VALDLB2  TM    7(R12),X'20'            VALUE BIT ON IN IDENTIFIER ?
         BZ    VALDLB3                 NO
         BAL   R6,ERR2E
*
         DC    X'001E'                 E30
*
         B     IDENDER                 GET NEXT IDENTIFIER
*
VALDLB3  TM    6(R12),X'06'            SPECIAL USE BIT ENTERED ?
         BZ    VALDLB4                 NO
         BAL   R6,ERR7
*
         DC    X'041D'                 E29
*
         XI    7(R12),X'30'            MOVE IN IDFIELD
         B     IDENDER                 GET NEXT IDENTIFIER
*
VALDLB4  MVI   7(R12),X'30'            CORRECT - MOVE IN IDFIELD
         B     IDENDER                 GET NEXT IDENTIFIER
*
*        TYPEARRAY
*
*        ENTERED FROM TYPESPEC
*        TEST FOR PROBIT, BEGBIT
*        INSERTS CHARACTERISTICS IN INTERNAL NAME WITHOUT
*        DESTROYING THE TYPE SPECIFICATIONS ENTERED BY THE TYPE
*        PROGRAM
*        JOINS ARRAY PROGRAM FOR A SPECIFIED TYPEARRAY THE EXIT
*        IS TO IDCHECK
*
TYPEARRY TM    BITS1,X'40'             PROBIT ON ?
         BO    TARYDHB3                YES, SPECIFICATION
         TM    BITS1,X'80'             BEGBIT ON ?
         BZ    TYPEARAA
         ST    R9,SAVE1                YES
         BAL   R9,BEG1                 GO AND PROCESS PROGRAMBLOCK HEAD
         L     R9,SAVE1
TYPEARAA L     R7,AITL
         MVI   6(R7),X'C8'             MOVE IN
         XI    7(R7),X'34'             ID FIELD
         B     ARRYDME1                GOTO ARRAY PROCECING
*
TARYDHB3 MVI   KB,X'CA'                MOVE IN
         OI    KB+1,X'04'              TYPE ARRAY SPECIFICATION ID
         B     IDCHECK
*
*        ARRAY
*
*        TESTS FOR PRO AND BEGBIT
*        ENTERS CHARACTERISTICS IN INTERNAL NAME
*        TYPEARRAY JOINS HERE
*        PBN IS ENTERED IN INTERNAL NAME
*        09 FOR ARRAY IS MOVED TO OUTPUT
*        THE NAME IS CHECKED AND MOVED TO OUTPUT AND ITAB SHOULD
*        BE FOLLOWED BY A COMMA OR LEFT PARENTHISIS
*        SETS N (NUMBER OF ARRAYS WITH SAME DIMENSIONS) TO ONE
*
ARRAY    TM    BITS1,X'40'             PROBIT ON ?
         BO    SPECENT                 YES
         TM    BITS1,X'80'             BEGBITI ON ?
         BZ    ARRAYAA
         ST    R9,SAVE1                YES, PROCESS PROGRAM BLOCK HEAD
         BAL   R9,BEG1
         L     R9,SAVE1
ARRAYAA  L     R7,AITL
         MVI   6(R7),X'C8'             MOVE IN
         MVI   7(R7),X'06'             IO FIELD
ARRYDME1 L     R6,LPBP
         MVC   8(1,R7),10(R6)          MOVE IN PROGRAM BLOCK NUMBER
         LA    R6,9(,R7)               MOVE ADDR OF AITL+9
         ST    R6,DIM                  TO DIM
         BAL   R12,COB
         MVI   0(R3),X'09'             MOVE ARRAY ID TO O/P
         LA    R3,1(,R3)
ARRYNAME LA    R1,1(,R1)               GET FIRST CHAR
         CLI   0(R1),XF9               LETTER ?
         BNH   ARNAMESE                NO
         TM    BITS1,X'04'             LISTBIT ON ?
         BO    ARRYMULT                YES
         MVC   N(1),KF1+3              SET N=1
ARRYID   BAL   R6,IDCHECK1             CHECK, MOVE IDENT TO ITAB
ARRYSE   CLI   0(R1),XFBLANK           O/P BLANK ?
         BE    IDCHECK2
         CLI   0(R1),XFLBRAC           LEFT BRACKET ?
         BE    ARRYLPAR                YES, BRANCH
         CLI   0(R1),XFLSQBR           LEFT SQUARE BRACKET ?
         BE    ARRYLPAR                YES, BRANCH
         CLI   0(R1),XFCOMMA           COMMA ?
         BE    ARCOMMA
ARRAYERR BAL   R6,ERR2                 SOMETHING ELSE FOUND
*
         DC    X'0010'                 E16
*
         BAL   R12,COB
         MVI   0(R3),X'3D'             MOVE IN RHA
         LA    R3,1(,R3)
ARYEXIT  L     R15,AITL
         BAL   R12,ITABCLEA+8          CLEAR ITAB-ENTRY
ARYEXITA NI    BITS1,X'F7'             TURN OFF ARBIT
         LA    R10,TESTLOOP            RESET RETURN REG TO MAINLOOP
         B     COMERR                  SKIP TO NEXT SEMICOLON
*
ARNAMESE CLI   0(R1),XFBLANK           NAME STARTS WITH BLANK ?
         BE    ARRYNAME                YES, BRANCH
         CLI   0(R1),XFZETA            ZETA ?
         BNE   ARNAMEAA
         LA    R9,ARRYNAME+4
         B     CIB
*
ARNAMEAA BAL   R6,ERR7                 FIRST CHAR OF NAME IN ERROR
*
         DC    X'0405'
*
         B     ARYEXIT                 DELETE DECLARATION
*
*        ARRAYPAR
*
*        ENTERED WHEN A LEFT BRACKET OR LEFT SQUARE BRACKET IS
*        FOUND AFTER THE NAME
*        INITIALIZES D DIMENSION COUNTER=0
*        SETS THE ARBIT C PARENTHESIS COUNT=1
*        SEARCHES FOR A SLASH
*        MOVES OUT SUBSCRIPT BRACKETS TO OUTPUT
*        EXITS TO ARRAYLIST
*
ARRYLPAR OI    BITS1,X'08'             ARBIT = 1
         LA    R12,1
         STH   R12,C                   C=1
         LA    R12,0
         STC   R12,D                   D=0
         CLI   0(R1),XFLSQBR           LEFT SQUARE BRACKET ON ENTRY ?
         BE    ARRYLSQB                YES, BRANCH
         LA    R1,1(,R1)               GET NEXT CHAR
ARRYSLSH CLI   0(R1),XFSLASH           SLASH ?
         BE    ARRYLSQB                YES, MOVE IN LEFT SQUARE BRACKET
         CLI   0(R1),XFBLANK           BLANK ?
         BE    ARRYSLSH-4              YES, GET NEXT CHAR
         CLI   0(R1),XFZETA            ZETA ?
         BNE   ARRYSLAA                NO, GOTO ERROR ROUTINE
         LA    R9,ARRYSLSH             YES, CHANGE
         B     CIB                     INPUT BUFFER
*
ARRYSLAA BAL   R6,ERR2
*
         DC    X'001F'                 E31
*
         BCTR  R1,0
ARRYLSQB BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFLSQBR           MOVE IN LEFT SQUARE BRACKET
         LA    R3,1(,R3)               INCR
         LA    R1,1(,R1)               POINTERS
         B     LIST                    GOTO PROCESS ARRAY LIST
*
*        ARCOMMA
*
*        COPIES INTERNAL PART OF ITAB ENTRY SETS THE LISBIT
*        EXITS TO ARRAYNAME TO CHECK FIRST CHARACTER OF NEXT NAME
*        THE LIST BIT WILL THEN CAUSE ARRAYMULT TO BE
*        EXECUTED BEFORE THE REST OF THE NAME IS CHECKED
*        INCREASES N, NUMBER OF ARRAYS WITH THE SAME DIMENSIONS,
*        BY ONE
*
ARCOMMA  L     R9,AITL                 SAVE AITL
         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY
         MVC   6(3,R15),6(R9)          COPY ID AND PBN FIELDS
         IC    R6,N                    INCREASE
         LA    R6,1(,R6)               N
         STC   R6,N                    BY ONE
         OI    BITS1,X'04'             SET LISTBIT TO ONE
         B     ARRYNAME                GET NEXT EXTERNAL NAME
*
*        ARRAYMULT
*
*        MOVES OUT THE COMMA PREVIOUSLY FOUND
*        SETS THE LISTBIT TO ZERO
*        RETURNS TO ARRAYID (AVOIDS RESETING N TO ONE)
*
ARRYMULT BAL   R12,COB
         MVI   0(R3),XFCOMMA           MOVE OUT THE COMMA
         LA    R3,1(,R3)
         NI    BITS1,X'FB'             SET LISTBIT TO ZERO
         B     ARRYID
*
*        LIST
*
*        USED FOR ARRAY AND SWITCH LIST PROCESSING
*        MAKES THE TRT AGAINST ARTABLE AND UTILIZES MAINLOOP TO
*        MOVE SCANNED BYTES AND BRANCH TO THE APPROPRIATE
*        PROGRAM, EITHER A LIST PROGRAM OR ONE OF THE COMMON
*        PROGRAMS. THE RETURN WILL BE TO LIST VIA R10
*        R10 WILL POINT TO LIST UNTIL CHANGED BY ENDLIST TO
*        POINT TO TESTLOOP AGAIN
*
LIST     BALR  R10,0                   SET RETURN REGISTER
         LR    R4,R1                   START CHAR IN SCAN
         LR    R9,R10                  RETURN FROM CIB
         SR    R2,R2
         TRT   0(73,R1),ARTABLE        SCAN AGAINST AR TABLE
         B     CONT                    UTILIZE TESTLOOP
*
*        PONTLST
*
*        USES THE SAME POINTABEL AS MAINLOOP BUT ADDS 56 TO THE
*        DISPLACEMENTS
*
PONTLST  LA    R1,1(,R1)               GET NEXT CHAR
         SR    R2,R2
         TRT   0(73,R1),PTTABLE        SCAN TO NEXT DELIMITER
         LA    R6,BPRTAB               IN PTTABLE
         L     R6,56(R6,R2)
         BR    R6                      BRANCH ACCORDING TO 56+
*                                      DISP+ BPRTAB
PZETA    LA    R9,PONTLST+4            ZETA IN POINTLIST
         B     CIB
*
*        RIGTPARL
*
*        MOVES OUT THE RIGHT PARENTHESIS
*        DECREASES THE PARENTHESIS COUNT AND RETURNS TO LIST
*
RIGTPARL BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFRBRAC           MOVE IN RIGHT BRACKET
         LA    R3,1(,R3)
         LA    R1,1(,R1)               GET NEXT  CHAR
         LH    R6,C
         BCTR  R6,0                    DECREASE PARENTHESIS COUNT
         STH   R6,C
         BR    R10
*
*        LEFTPARL
*
*        INCREASES THE PARENTHESIS COUNT
*        CHECKS IF NEXT CHARACTER IS A SLASH, IF IT IS MOVES A
*        SUBSCRIPT BRACKET OUTPUT, IF NOT MOVES A SIMPLE
*        PARENTHESIS
*
LEFTPARL LH    R6,C                    INCREASE PARENTHESIS COUNT
         LA    R6,1(,R6)
         STH   R6,C
         CLI   0(R1),XFLSQBR           LEFT SQUARE BRACKET ON INPUT ?
         BE    LPARDQAA                YES, BRANCH
LPARDQC3 LA    R1,1(,R1)               GET NEXT CHAR
         CLI   0(R1),XFSLASH           SLASH ?
         BNE   SIMPLPAR                NO, SIMPLE PARENTHESIS
LPARDQAA BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFLSQBR           YES, MOVE IN SQUARE BRACKET
LPARDQ63 LA    R1,1(,R1)               INCREASE POINTERS
         LA    R3,1(,R3)
         BR    R10                     RETURN
*
SIMPLPAR CLI   0(R1),XFBLANK           NEXT CHAR BLANK ?
         BE    LPARDQC3                YES
         CLI   0(R1),XFZETA            NO, ZETA ?
         BNE   SIMPLPAA
         LA    R9,LPARDQC3+4
         B     CIB
*
SIMPLPAA BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFLBRAC           MOVE IN LEFT PARENTHESIS
         B     LPARDQ63+4
*
*        COMMALST
*
*        INCREASES THE DIEMSION COUNTER D IF C THE PARENTHESIS
*        COUNTER IS 1 FOR ARRAY OR 0 FOR SWITCH LIST
*
COMMALST TM    BITS1,X'08'             AR BIT = 0 ?
         BZ    COMMAG3
         CLC   C(2),KF1+2              C=1 ?
         BNE   COMMAJ2                 NO
COMMAH2  IC    R2,D                    INCREASE D-COUNTER
         LA    R2,1(,R2)
         STC   R2,D
COMMAJ2  BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFCOMMA           MOVE COMMA TO OUTPUT
         LA    R3,1(,R3)               INCREASE POINTERS
         LA    R1,1(,R1)
         BR    R10
*
COMMAG3  CLC   C(2),KF0                C=0 ?
         BE    COMMAH2
         B     COMMAJ2
*
*        COLONLST
*
*        CORRECT ONLY FOR AN ARRAY LIST
*
COLONLST TM    BITS1,X'08'             ARBIT ON ?
         BZ    ERROR3                  E3 COLON DELETE D
         BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFCOLON           MOVE COLON TO O/P
         LA    R3,1(,R3)
         LA    R1,1(,R1)               GET NEXT CHAR
         BR    R10                     AND RETURN
*
*        SEMCLST
*
*        IS ONLY VALID FOR AN SWITCH IN WHICH CASE INDICATES
*        THE END OF THE SWITCH LIST
*        THE NUMBER OF COMPONENTS IS INSERTED IN THE INTERNAL
*        NAME
*        EXIT IS TO ENDLIST
*
SEMCLST  TM    BITS1,X'08'             ARBIT=1 ?
         BO    SEMCLER                 YES, ERROR
*
*        END OF SWITCH HANDLING
*
         CLI   D,16                    MORE THAN 15 COMPONENTS ?
         BL    SEMCLAA
         BAL   R6,ERR2
*
         DC    X'0021'                 E33
*
         B     COMPFIN
*
SEMCLAA  L     R7,AITL                 INSERT DIMENSION COUNTER
         SR    R6,R6
         IC    R6,D
         SLA   R6,4                    IN LEFTMOST 4 BYTES
         STC   R6,D
         MVZ   9(1,R7),D               IN DECLARATION
         B     ENDLIST                 GO TO ENDLIST
*
*        SEMCLER
*
*        ENTERED IF A SEMICOLON IS FOUND IN AN ARRAY LIST
*        GIVES E32, CLEAR THE ITAB ENTRY SETS THE ARBIT OFF,
*        DELTABIT ON AND RETURNS TO TEST VIA SEMCO
*
SEMCLER  BAL   R6,ERR2
*
         DC    X'0020'                 E32
*
         L     R15,AITL
         BAL   R12,ITABCLEC            CLEAR THE ENTRY
         OI    BITS1,X'20'             DELTABIT ON
         NI    BITS1,X'F7'             ARRAYBIT OFF
         B     SEMCO                   RETURN TO SEMCO, WILL RESET R10
*
*        SLASHLST
*
*        CHECKS IF NEXT CHARACTER IS A RIGHT PARENTHESIS
*        IT IS NOT MOVES OUT A SLASH
*        IF IT IS MOVES OUT A RIGHT SQUARE BRACKET
*        DECREASES THE PARENTHESIS COUNT
*        RETURNS TO LIST IF EITHER AN SWITCH LIST IS PROCESSED
*        OR THE PARENTHESIS COUNT NOT IS 0
*
SLASHLST CLI   0(R1),XFRSQBR           RIGHT SQUARE BRACKET ON ENTRY ?
         BE    SLASHRSB                YES, BRANCH
         LA    R1,1(,R1)               GET NEXT CHAR
         CLI   0(R1),XFRBRAC           RIGHT BRACKET ?
         BNE   SLASHSE                 NO SOMETHING ELSE
SLASHRSB BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFRSQBR           TRANSFER A RIGHT SQUARE BRACKET
         LA    R3,1(,R3)
         LA    R1,1(,R1)
         LH    R6,C                    DECREASE PARENTHESIS COUNT
         BCTR  R6,0
         STH   R6,C
         TM    BITS1,X'08'             ARBIT = 1 ?
         BZ    0(,R10)                 NO, RETURN
         CLC   C(2),KF0                C=0 ?
         BNE   0(,R10)                 NO, RETURN
*
*        ARRAY END HANDLING
*
*        INSERT THE DIMENSION COUNTERS IN THE INTERNAL NAME OR
*        NAMES IF MORE THAN ONE ARRAY WITH THE SAME DIMENSIONS
*
*        IF A COMMA FOLLOWS THE CHARACTERISTICS AND THE PBN IS
*        COPIED AND THE NEXT ARRAY NAME IS HANDLED
*        IF A SEMICOLON FOLLOWS ENDLIST IS ACTIVATED
*
         IC    R2,D
         CLI   D,16                    MORE THAN 16 DIMENSIONS ?
         BL    SLASHLAA
         BAL   R6,ERR2
*
         DC    X'0021'                 EOO
*
         B     COMPFIN
*
SLASHLAA SLA   R2,4                    SHIFT DIMENSION COUNTER
         STC   R2,D
SLASHREP L     R6,DIM
         MVZ   0(1,R6),D               INSERT DIMENSION COUNTER
         LA    R6,11(,R6)              INCREASE DIM POINTER
         ST    R6,DIM
         IC    R12,N                   DECREASE
         BCTR  R12,0                   REP DECLARATION COUNTER
         STC   R12,N
         CLC   N(1),KF0                ZERO ?
         BNE   SLASHREP                NO, INSERT DIM IN NEXT
         B     SLASHEND+4              ITAB ENTRY
*
SLASHSE  CLI   0(R1),XFBLANK           BLANK ?
         BE    SLASHLST
         CLI   0(R1),XFZETA            ZETA ?
         BNE   SLASHLBB
         LA    R9,SLASHLST+4
         B     CIB
*
SLASHLBB BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFSLASH           MOVE IN A SLASH
         LA    R3,1(,R3)
         BR    R10
*
SLASHEND LA    R1,1(,R1)               GET NEXT CHAR
         CLI   0(R1),XFCOMMA           COMMA ?
         BNE   SLSHENSE                NO SOMETHING ELSE
         BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFCOMMA           MOVE IN A COMMA
         LA    R3,1(,R3)
         L     R9,AITL                 SAVE AITL
         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY
         MVC   6(3,R15),6(R9)          COPY ID AND PBN FIELDS
         B     ARRYNAME                GET NEXT NAME
*
SLSHENSE CLI   0(R1),XFBLANK           BLANK ?
         BE    SLASHEND
         CLI   0(R1),XFZETA            ZETA ?
         BNE   SLASHLCC
         LA    R9,SLASHEND+4
         B     CIB
*
SLASHLCC LA    R6,SLASHERR             RETURN IF NO SEMICOLON FOUND
         BAL   R12,FINDSEMC            LOOK FOR SEMICOLON
*
*        ENDLIST
*
*        SETS DELTABIT TO ONE, ARBIT TO ZERO, CLEARS NEXT ITABENTRY
*
*        RESETS THE RETUN REGISTER TO TEST
*        RETURNS TO TESTLOOP VIA SEMCO
*
ENDLIST  OI    BITS1,X'20'             DELTA BIT =1
         NI    BITS1,X'F7'             ARBIT= 0
         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY
         LA    R10,TESTLOOP            RESET RETURN REG TO MAINLOOP
         B     SEMCO                   GO TO SEMICOLON PROGRAM
*
SLASHERR BAL   R6,ERR2
*
         DC    X'0022'                 E34
*
         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY
         B     ARYEXITA                CLEAR ENTRY IN ITAB AND RETURN
*
*        SWITCH
*
*        TESTS ON PROBIT (SPECIFICATION) AND BEGBIT (PROGRAM
*        BLOCK HEAD)
*        INSERTS CHARACTERISTICS AND PBN IN INTERNAL NAME
*        INCREASES AND INSERTS LABELNUMBER LN
*        MOVES 0A SWITCH TO OUTPUT
*        SETS ARBIT TO ZERO
*        CHECKS THE NAME FOR VALIDITY AND MOVES FIRST 6
*        CHARACTERS TO OUTPUT AND ITAB VIA IDCHECK
*        SEARCHES FOR ASSIGN TO FOLLOW THE SWITCHNAME
*        INITIALIZES C PARENTHESIS COUNT AND D DIMENSION COUNT
*        WITH ZERO AND N WITH ONE
*        EXITS TO LIST
*
SWITCH   TM    BITS1,X'40'             PROCEDURE HEAD ?
         BO    SPECENT                 YES
         TM    BITS1,X'80'             BLOCK START ?
         BZ    SWITCHAA
         ST    R9,SAVE1
         BAL   R9,BEG1                 YES, PROCESS BLOCK BEGIN
         L     R9,SAVE1
SWITCHAA L     R15,AITL                MOVE IN ID FIELDS
         MVI   6(R15),X'CC'
         MVI   7(R15),X'0C'
         L     R12,LPBP
         MVC   8(1,R15),10(R12)        AND PBN- NUMBER
         LH    R12,LN                  INCREASE LABEL NUMBER
         LA    R12,4(,R12)
         CLC   LN(2),KH4096            LN OVERFLOW ?
         BL    SWITCHBB
         BAL   R6,ERR7
*
         DC    X'04D8'                 E216
*
         LA    R12,LATBEG              RESET LN
SWITCHBB STH   R12,LN
         MVC   9(2,R15),LN             MOVE IN LABEL NUMBER
         BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),X'0A'             MOVE IN $ SWITCH
         LA    R3,1(,R3)
         NI    BITS1,X'F7'             SET ARBIT TO ZERO
SWTCHB3  LA    R1,1(,R1)               GET FIRST CHAR
         CLI   0(R1),XF9               LETTER ?
         BL    SWTCHNSE                NO
         BAL   R6,IDCHECK1             INITIALIZE N WITH ONE
SWITCHSE CLI   0(R1),XFBLANK           BLANK ?
         BE    IDCHECK2
         CLI   0(R1),XFCOLON           COLON ?
         BE    SWCOLON
         CLI   0(R1),XFPERIOD          PERIOD ?
         BNE   SWITCHER
SWPOINT  LA    R1,1(,R1)               ONE POINT HAS BEEN FOUND
         CLI   0(R1),XFPERIOD          ONE MORE PERIOD ?
         BE    SWCOLON
         CLI   0(R1),XFEQUAL           EQUAL ?
         BE    EQUALOK
         CLI   0(R1),XFBLANK           BLANK ?
         BE    SWPOINT
         CLI   0(R1),XFZETA            ZETA ?
         BNE   SWITCHER
         LA    R9,SWPOINT+4
         B     CIB
*
SWCOLON  LA    R1,1(,R1)               A COLON OR TWO POINTS ARE FOUND
         CLI   0(R1),XFEQUAL           EQUAL ?
         BE    EQUALOK                 YES '= OR  = OR  = ARE FOUND
         CLI   0(R1),XFBLANK           BLANK ?
         BE    SWCOLON
         CLI   0(R1),XFZETA            ZETA ?
         BNE   SWITCHER
         LA    R9,SWCOLON+4
         B     CIB
*
EQUALOK  BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFASSIGN          MOVE IN ASSIGNMENT
         LA    R3,1(,R3)               INCREASE O/P POINTER
         SR    R6,R6
         STH   R6,C                    C=0
         MVI   N,X'01'                 N=1
         STC   R6,D                    D=0
         LA    R1,1(,R1)               GET NEXT CHAR
         B     LIST                    GO TO PROCESS LIST
*
SWTCHNSE CLI   0(R1),XFBLANK           BLANK ?
         BE    SWTCHB3
         CLI   0(R1),XFZETA            ZETA ?
         BNE   SWTCHNAA
         LA    R9,SWTCHB3+4
         B     CIB
*
SWTCHNAA BAL   R6,ERR7
*
         DC    X'0405'                 E5
*
         B     SWTCHNBB
*
SWITCHER BAL   R6,ERR2
*
         DC    X'0010'                 E16
*
         BAL   R12,COB
         MVI   0(R3),X'3D'             MOVE IN RHA
         LA    R3,1(,R3)
SWTCHNBB L     R6,AITL                 CLEAR ITAB-ENTRY
         MVI   0(R6),0
         MVC   1(10,R6),0(R6)
         B     COMERR                  COM-PRGM ERROR-ENTRY
*
*        STRING
*
*        MOVES INTERNAL NAME TO OUTPUT
*
*        START ADDR IS IN PRPT THE STRINGS TWO FIRST BYTES
*        SPECIFIES ITS LENGTH THE TRT TESTS ONLY FOR APOSTROPHE
*        AND ZETA
*
*        NOTE -
*        THE STRING IS TAKEN FROM THE PRINT AREA (OR DUMMY) AND
*        MOVED TO KOPOOL TO CAPTURE THE STRING IN EBCDIC
*
STRING   LA    R0,6(,R3)               PROVIDE 6 BYTES IN O/P
         BAL   R12,COBSPEC
         MVC   0(4,R3),SINT            MOVE FIRST 4 BYTES OF INTERNAL
         MVC   4(2,R3),PRPT+2          NAME AND LAST TWO BYTES IN O/P
         LA    R3,6(,R3)
         L     R14,PRPT                GET CURRENT DISP WITHIN KOPOOL
         LA    R14,2(,R14)             INCREASE FOR LEN SPECIFICATION
         C     R14,KF4095              STRING POOL OVERFLOW ?
         BNH   STRAAA
         BAL   R12,E23
STRAAA   LA    R1,1(,R1)
         MVC   SQC,KF1                 STRINQUOTE=1
CDE2     LA    R9,*                    PROVIDE RETURN ADDR FOR CIB
         LR    R4,R1
         SR    R2,R2
         TRT   0(73,R1),STRTABLE       SCAN STRING
         LR    R7,R1                   COMPUTE NUMBER OF SCANNED BYTES
         SR    R7,R4
         BZ    SROUT
         LA    R0,0(R7,R14)            STRINGPOOL OVERFLOW ?
         C     R0,KF4095
         BNH   STRBBB
         BAL   R12,E23
STRBBB   BCTR  R7,0                    MOVE SCANNED BYTES TO KOPOOL
         L     R6,AKOPOOL
         LA    R15,0(R6,R14)           COMPUTE NEW KOPOOL ADDR
         LA    R0,WA                   COMPUTE ADDR
         LR    R12,R4                  OF STRING IN
         SR    R12,R0                  PRINT BUFFER
         L     R6,APRNTAR              R6 -> PRINT BUFFER
         LA    R12,10(R6,R12)          GET STRING FROM PRINT BUFFER
         EX    R7,MV1
         LA    R14,1(R7,R14)           INCREASE PRPT
SROUT    L     R12,BPRTAB(R2)          BRANCH TO APPROPRIATE
         BR    R12                     SUBROUTINE
*
*        QUOTE
*
*        CHECKS IF THE APOSTROPHE IS THE START OF A QUOTE SIGN
*
*        USES REPL TO MOVE THE FOUND CHARACTER(S) TO KOPOOL
*        REPL+1 WILL BE A LEFT OR RIGHT PARENTHESIS
*        HOW MUCH OF REPL THAT IS TO BE MOVED TO KOPOOL IS KEPT
*        TRACK OF IN R7
*        IF A COMPLETE LEFT STRING QUOTE IS FOUND THE STRING
*        QUOTE COUNTER IS INCREASED AND THE REPL MOVED TO
*        KOPOOL
*        IF A COMPLETE RIGHT STRING QUOTE IS FOUND IT IS CHECKED
*        IF IT IS THE CLOSING ONE FOR THE STRING (SQC=0) IF IT
*        IS ENDSTRING IS ACTIVATED IF NOT REPL IS MOVED TO KOPOOL
*        AFTER SQC IS DECREASED
*        IF NO COMPLETE QUOTE IS FOUND THE CHARACTER(S) FOUND
*        ARE MOVED TO KOPOOL FROM REPL, LENGTH SPECIFIED BY R7
*        AND THE SCANNING OF THE STRING IS REASSUMED
*
QUOTE    LA    R1,1(,R1)
         LA    R9,*+4
         CLI   0(R1),XFRBRAC           RIGHT BRACKET IN SOURCE ?
         BNE   NORIP                   NO, BRANCH
         MVI   REPL+1,C')'             MAKE REPL A RIGHT STRING QUOTE
         B     TESTAPOS                LOOK FOR APOSTROPHE
*
NORIP    CLI   0(R1),XFLBRAC           LEFT BRACKET ?
         BNE   TESTZETA                NO
         MVI   REPL+1,C'('             MAKE REPL A LEFT STRING QUOTE
         B     TESTAPOS                LOOK FOR APOSTROPHE
*
TESTZETA CLI   0(R1),XFZETA            ZETA ?
         BE    CIB                     YES
         LA    R7,1                    NO MOVE STRING ONLY FIRST QUOTE
         B     CID1                    MOVE REPL
*
TESTAPOS LA    R1,1(,R1)
         LA    R9,*+4                  NEW RETURN FOR CIB
         CLI   0(R1),XFQUOTE           SECOND QUOTE ?
         BE    CID                     YES
         CLI   0(R1),XFZETA            ZETA
         BE    CIB                     YES
         LA    R7,2                    NO, MOVE TO STRING ONLY FIRST
         B     CID1                    QUOTE AND THE BRACKET
*
CID      LA    R1,1(,R1)
         L     R12,SQC
         CLI   REPL+1,C'('             LEFT STRING QUOTE ?
         BNE   CIDAA                   NO
         LA    R12,1(,R12)             YES, INCREASE STRING QUOTE COUNT
         B     CIDBB
*
CIDAA    S     R12,KF1                 RIGHT QUOTE DECREASE QUOTE COUNT
         BNP   ENDSTRIN                BRANCH IF LAST QUOTE
CIDBB    ST    R12,SQC
         LA    R7,3
CID1     LA    R0,0(R7,R14)
         C     R0,KF4095               STRING POOL OVERFLOW ?
         BNH   CIDCC
         BAL   R12,E23
CIDCC    L     R6,AKOPOOL
         LA    R6,0(R6,R14)            COMPUTE NEW KOPOOL ADDR
         BCTR  R7,0
         EX    R7,MV2                  MOVE CONTENTS OF REPL TO KOPOOL
         LA    R14,1(R7,R14)           INCREASE PRPT
         B     CDE2                    RESUME SCAN OF STRING
*
*        ENDSTRIN
*
*        INCREASES PRPT
*        PUTS THE LENGTH OF THE STRING (DIFFERENCE BETWEEN NEW
*        AND OLD PRPT) AS TWO FIRST BYTES IN THE STRING
*
ENDSTRIN L     R9,PRPT                 COMPUTE LENGTH AND PUT IT
         STH   R14,PRPT+2              AS THE FIRST 2 BYTES IN STRING
         L     R6,AKOPOOL              AND
         LA    R12,0(R6,R9)            STORE NEW DISPLACEMENT
         SR    R14,R9                  IN PRPT
         STCM  R14,B'0011',0(R12)
         BR    R10                     RETURN TO TESTLOOP
*
E23      NOP   E23AA                   NO BRANCH FIRST TIME
         BAL   R6,ERR7                 RECORD ERROR
*
         DC    X'0417'                 E23
*
E23AA    OI    E23+1,X'F0'             NO ERROR RECORDING NEXT
         LA    R14,64
         ST    R14,PRPT                RESET PRPT TO 64 AGAIN
         BR    R12                     RESUME STRING PROCESSING
*
MV1      MVC   0(1,R15),0(R12)
MV2      MVC   0(1,R6),REPL
*
SQC      DC    F'0'                    STRING QUOTE COUNTER (AFTER MV2
SINT     DC    X'2EC90000'             STRING INTERNAL NAME OF
*                                      THE CONSTANT POOL NAMED KOPOOL
REPL     DC    C''' '''                BUCKET TO BUILD STRING QUOTES
*
*        TYPPROC
*
*        TEST PRO AND BEGBIT (FORMAL PARAMETER, BLOCKSTART)
*        MOVE PHI TO OUTPUT
*        INSERT CHARACTERISTICS IN INTERNAL NAME
*        JOIN PROCEDURE PROGRAM
*
TYPPROC  TM    BITS1,X'40'             PROCEDURE PROCEDED ?
         BZ    TYPPROCA                NO
         MVI   KB,X'CA'                YES, MOVE IN IDFIELD
         OI    KB+1,X'C0'
         B     IDCHECK
*
TYPPROCA TM    BITS1,X'80'             BEGBIT ON ?
         BZ    TYPPROCB                NO
         ST    R9,SAVE1
         BAL   R9,BEG1                 GOTO PROCESS PROGRAM BLOCK HEAD
         L     R9,SAVE1
TYPPROCB LA    R0,4(,R3)               PROVIDE FOUR BYTES IN OUTPUT
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         MVI   0(R3),X'0F'             MOVE PHI TO O/P
         L     R15,AITL
         XI    7(R15),X'F0'            MOVE IN THE IDCODE
         MVI   6(R15),X'CA'            TO ITAB
         B     PROCEAG1                JOIN THE PROCEDURE PROGRAM
*
*        PROCEDURE
*
*        TEST PRO AND BEGBIT
*        MOVE PI TO OUTPUT
*        INSERT CHARACTERISTICS IN INTERNAL NAME
*        TYPE PROCEDURE JOINS PROCEDURE PROGRAM AT THIS POINT
*        IF ALPHA IN STACK, PRECOMPILED PROCEDURE, THE STARTBIT
*        IS TURNED ON.
*        PROC IS PUT IN STACK.
*        PROGRAM BLOCK AND ITAB GROUP NUMBER ARE INCREASED.
*        THE NEW PBN IS INSERTED IN THE INTERNAL NAME.
*        LABELNUMBER IS INCREASED AND INSERTED IN THE INTERNAL
*        NAME.
*        THE SURRONDING BLOCKNUMBET IS ENTERED IN PBTAB1.
*        THE SURROUNDING ITAB GROUP NUMBER IN GROUPTABLE
*        SEMCNT IS ENTERED IN SCTAB
*        PROBIT AND IDBIT ARE SET TO ONE
*        PROBIT WILL STAY AS ONE TILL THE WHOLE PROCEDURE HEAD
*        IS PROCESSED. THE IDBIT IS ONLY ONE WHILE THE PROCEDURE
*        NAME IS PROCESSED
*        THE FM (FORMAL PARAMETER) BIT IS ONE WHEN THE FORMAL
*        PARAMETER LIST IS PROCESSED
*        THE ITAB GROUP NUMBER IS MOVED TO O/P
*
PROCEDUR TM    BITS1,X'40'             PROBIT ON ?
         BO    SPECENT                 YES, GOTO IDCHECK VIA SPECENT
         TM    BITS1,X'80'             BEGBIT ON ?
         BZ    PROCEDAA                NO
         ST    R9,SAVE1
         BAL   R9,BEG1                 GOTO PROCESS PROGRAM BLOCK HEAD
         L     R9,SAVE1
PROCEDAA LA    R0,4(,R3)               PROVIDE FOUR BYTES IN OUTPUT
         BAL   R12,COBSPEC
         MVI   0(R3),X'0E'             TRANSFER PI IN OUTPUT BUFFER
         L     R15,AITL
         MVI   6(R15),X'CA'            CONSTRUCT FIRST PART
         MVI   7(R15),X'C0'            INTERNAL NAME ?
PROCEAG1 L     R14,SP
         CLI   0(R14),0                ALPHA IN STACK ?
         BNE   L3
         OI    BITS2,X'20'             TURN ON THE STARTBIT
         OI    BITS3,PROCESD
L3       LA    R14,1(,R14)             INCREASE STACK POINTER
         C     R14,ATOPSTAK            STACK OVERFLOW ?
         BL    L3AA                    NO, BYPASS ERROR
         BAL   R6,ERR4
*
         DC    X'0414'                 E20
*
L3AA     MVI   0(R14),X'0C'            PUT PROC IN STACK
         ST    R14,SP
         CLI   PBC,X'FF'               PBN OVERFLOW ?
         BNE   L3BB                    NO
         BAL   R6,ERR4
*
         DC    X'0416'                 E22
*
L3BB     IC    R2,PBC
         LA    R2,1(,R2)               INCR PROGRAM BLOCK NUMBER
         STC   R2,8(,R15)              INSERT PBN IN INTERVAL NAME
         STC   R2,PBC
         LA    R14,PBTAB1(R2)          CONSTRUCTION
         L     R6,LPBP                 PBTAB1-ENTRY
         MVC   0(1,R14),10(R6)
         AR    R2,R2
         LA    R14,SCTAB(R2)
         MVC   0(2,R14),SEMCNT         MAKE ENTRY IN SCTAB
         LH    R14,LN                  INCREASE
         LA    R14,4(,R14)             LABEL NUMBER BY 4
         CLC   LN(2),KH4096            LN OVERFLOW ?
         BL    L3CC
         BAL   R6,ERR7
*
         DC    X'04D8'                 E216
*
         LA    R14,LATBEG              RESET LN
L3CC     STH   R14,LN
         L     R15,AITL
         MVC   9(2,R15),LN             PUT LN IN INTERNAL NAME
         LH    R15,IGC                 INCREASE
         LA    R15,1(,R15)             ITAB GROUP NUMBER
         STH   R15,IGC
         MVC   1(2,R3),IGC             INSERT IT IN OUTPUT BUFFER
         LA    R3,3(,R3)
         AR    R15,R15
         AH    R15,IGC
         A     R15,AGT
         L     R7,LIGP
         MVC   0(2,R15),8(R7)          CONSTRACT ENTRY
         MVI   2(R15),0                IN GROUP TABLE
         NI    0(R15),X'7F'            CLEAR POSSIBLE PHI IND.
         MVC   PRIMPAR(4),KF0          CLEAR PRIMPAR WITH ZEROS
         OI    BITS1,X'50'             PROBIT =1,IDBIT =1
         MVI   PZ,0                    SET PARAMTER COUNT TO ZERO
*
*        PROCID
*
*        PROCESSES PROCEDURE NAME (IDBIT=1) AND THE FORMAL
*        PARAMETER LIST (IDBIT=0).
*        CHECKS THE NAMES FOR VALIDITY AND MOVES THEM TO ITAB
*        AND OUTPUT. THIS IS DONE VIA IDCHECK1.
*
PROCID   LA    R1,1(,R1)
         CLI   0(R1),XFA               IDENTIFIER STARTS WITH LETTER ?
         BL    NOLETTER
         BAL   R6,IDCHECK1             CHECK AND MOVE IDENTIFIER
*                                      TO O/P AND ITAB
         CLI   0(R1),XFBLANK           BLANK ?
         BE    IDCHECK2
         TM    BITS1,X'10'             IDBIT ONE ?
         BZ    EDA1                    GOTO PROCESS FORMAL PARAM NAME
*
*        PROCEDURE NAME
*
*        CHECKS IF NAME IS FOLLOWED BY A FORMAL PARAMETER LIST
*        FOLLOWS OR ; NO PARAMETERS.
*        CHECKS IF PROCEDURE IS TO BE PRECOMPILED, IF YES THE
*        NAME IN EXTERNAL FORM AND EXPANDED WITH TWO ZEROS IS PUT
*        FOR AN ESDCARD IF SYLIN OR DECK HAS BEEN SPECIFIED
*        THE NEW BLOCK ENTRY IS DONE IN ITAB
*        ADDR OF SURROUNDING BLOCK AND ITAB GROUP, PBN AND IGN
*        ARE INSERTED
*        IF TYPEPROCEDURE, BIT 0 IN BYTE 8 IS TURNED ON AND A
*        SECOND ENTRY OF THE NAME IS DONE AFTER THE HEAD ENTRY
*        IDBIT IS SET TO ZERO, FMBIT TO ONE
*        IF THE NAME WAS FOLLOWED BY A SEMICOLON THE SEMCO IS
*        ACTIVATED
*        IF THE NAME WAS FOLLOWED BY A (PROCID IS ACTIVATED TO
*        PROCESS THE NAME IN THE LIST
*
         CLI   0(R1),XFLBRAC           IDENTIFIER FOLLOWED BY ) ?
         BE    EBF4
         LA    R6,ERROR16              RETURN IF NOT SEMICOLON
         BAL   R12,FINDSEMC            SEMICOLON ?
         OI    BITS1,X'20'             YES, DELTABIT = 1
EBF4     TM    BITS3,PROCESD
         BZ    DEL1                    NO
         NI    BITS3,PROCOFF
         TM    COMPFLGS+1,NLOAD+NDECK  DECK AND OR LOAD SPECIFIED ?
         BO    DEL1                    NO, NO NEED FOR ESD CARD
         L     R15,AITL
         MVC   ESDNAME(6),0(R15)       MOVE IN AND
         TR    ESDNAME(6),TRINTEXT     TRANSLATE EXTERNAL NAME
DEL1     TM    BITS1,X'20'             DELTABIT = 1 ?
         BO    ECA3
         BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFLBRAC           INSERT )
         LA    R3,1(,R3)
ECA3     BAL   R12,ITABCLEA
         MVC   0(4,R15),LIGP           MOVE ADDR HEADING ENTRY OF
*                                      EMBRACING ITAB GROUP
         MVC   4(4,R15),LPBP           AND PBLOCK TO ENTRY
         MVC   8(2,R15),IGC            INSERT CURRENT IGN
         MVC   10(1,R15),PBC           AND CURRENT PBN
         ST    R15,LIGP                NEW VALUE OF LIGP
         ST    R15,LPBP                AND LPBP
         S     R15,KF11                DECREASE R15 BY 11
         TM    7(R15),X'03'            TYPE PROCEDURE ?
         BNZ   TPROHEAD
         LA    R15,22(,R15)            IF NO INCREASE ITAB POINTER
ECJ3     BAL   R12,ITABCLEC
         OI    BITS3,FMBIT             FMBIT
         TM    BITS1,X'20'             DELTABIT = 1 ?
         BO    SEMCO                   YES, BRANCH TO SEMICOLON PROGRAM
         NI    BITS1,X'EF'             IDBIT'= 0
         B     PROCID                  CHECK NEXT IDENTIFIER
*
*        CONSTRUCT TYPE PROCEDURE ENTRIES
*
TPROHEAD OI    19(R15),X'80'           FLAGBIT IN IGN IS SET ON
         LA    R0,22(,R15)             ONE MORE ENTRY IN ITAB AVAIL
         C     R0,ELI
         BNE   TPROHEAA
         BAL   R6,ERR4
*
         DC    X'04D5'                 E213
*
TPROHEAA MVC   22(11,R15),0(R15)       ENTER PROCEDURE NAME ONCE MORE
         XI    28(R15),X'08'           NO-ASSIGNMENTBIT IS SWITCHED OFF
         LA    R15,33(,R15)            INCREASE ITAB POINTER
         B     ECJ3                    BRANCH BACK TO MAIN PROGRAM
*
NOLETTER CLI   0(R1),XFBLANK           BLANK INSTEAD OF LETTER ?
         BE    PROCID
         LA    R9,PROCID+4
         CLI   0(R1),XFZETA            ZETA ?
         BE    CIB                     CHANGE INPUT BUFFER
         TM    BITS1,X'10'
         BO    ERROR16A
         LA    R15,PROCID              LOAD RETURN ADDR
         B     IERSPEC                 BRANCH TO IDENTIFIER ERROR RTN
*
ERROR16  BAL   R12,COB
         MVI   0(R3),X'3D'             MOVE IN RHA
         LA    R3,1(,R3)
         TM    BITS1,X'10'             PROC NAME UNDER PROCESS ?
         BO    PNAMERR                 YES
         LA    R15,PROCID              LOAD RETURN ADDR
         B     IER                     GO TO IDENTIFIER ERROR ROUTINE
*
ERROR16A BAL   R6,ERR7
*
         DC    X'0405'                 E5
*
         B     PNAMERRA
*
PNAMERR  BAL   R6,ERR2
*
         DC    X'0010'                 E16
*
PNAMERRA L     R7,AITL
         MVI   0(R7),0                 CLEAR ERRONEOUS NAME
         MVC   1(5,R7),0(R7)
         LA    R6,PROCIDSE             THE PROCEDURE HEAD SHOULD
         BAL   R12,FINDSEMC
         B     EBF4-4                  BE FOLLOWED BY EITHER  ( OR .,
*
PROCIDSE CLI   0(R1),X'06'             KEEP LOOPING UNTIL :-
         BE    EBF4                    LEFT PARENTHESIS FOUND
         BAL   R12,FINDSEMC-4
         B     EBF4-4                  SEMICOLON FOUND
*
*        FORMAL PARAMETER LIST
*
*        IF A COMMA TERMINATES THE NAME, THE COMMA IS TRANSFERED
*        TO OUTPUT AND THE PARAMETER COUNT (PZ) IS INCREASED BY
*        ONE. AND PROCID IS ACTIVATED AGAIN TO TAKE NEXT NAME.
*        IF A ) FOLLOWED BY A SEMICOLON TERMINATES THE NAME
*        PROCFIN IS ACTIVATED.
*        IF A ) BUT NO SEMICOLON TERMINATES THE NAME PROCDEL IS
*        ACTIVATED.
*        IS SOMETHING ELSE IS FOUND RHA IS MOVED TO OUTPUT, THE
*        PARAMETER COUNT IS NOT INCREASED AND IER ACTIVATED
*        (NOLETTER, ERROR16).
*
EDA1     CLI   0(R1),XFCOMMA           COMMA TERMINATES IDENTIFIER ?
         BNE   PAR
PROCEND  IC    R2,PZ                   INCREASE
         LA    R2,1(,R2)               PARAMETER
         STC   R2,PZ                   COUNT BY ONE
         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY
         BAL   R12,COB                 CHECK IF O/P AREA FILLED
         CLI   0(R1),XFCOMMA           COMMA ?
         BNE   PROCFIN
         MVI   0(R3),XFCOMMA           MOVE COMMA TO OUTPUT BUFFER
         LA    R3,1(,R3)               INCREASE OUTPUT POINTER
         B     PROCID                  BRANCH TO CHECK THE
*                                      NEXT IDENTIFIER
PAR      CLI   0(R1),XFRBRAC           ) TERMINATES IDENTIFIER ?
         BE    PROCEND
         BAL   R12,COB
         MVI   0(R3),X'3D'             MOVE IN RHA
         LA    R3,1(,R3)
         LA    R15,PROCID              NOTE RETURN ADDR
         B     IER                     BRANCH TO IER
*
*        PROCFIN
*
*        THE PARAMETER LIST HAS BEEN COMPLETLY CHECKED
*        THE RIGHT PARENTHESIS IS MOVED TO OUTPUT
*        DELTABIT IS SET TO ONE
*        THE PARENTHESIS COUNT IS INSERTED IN THE PROCEDURE NAME
*        (NAMES IF TYPEPROCEDURE)
*        FMBIT IS TURNED OFF
*        THE RETURN TO TEST IS VIA SEMCO
*        IF SOMETHING ELSE, E5 OR E16 IS GENERATED AND
*        EVERYTHING SKIPPED TILL A (OR A; IS FOUND (NOLETTER,
*        PNAMERR)
*
PROCFIN  LA    R1,1(,R1)
         LA    R6,PROCDEL              RETURN IF NO SEMICOLON
         BAL   R12,FINDSEMC            SEMICOLON ?
         BAL   R12,COB
         LA    R14,SEMCO               EXIT FROM PROCEDUR
SCYES3   MVI   0(R3),XFRBRAC           MOVE RIGHT PARENTHESIS
         LA    R3,1(,R3)
         OI    BITS1,X'20'             DELTABIT'=1
         CLI   PZ,16                   MORE THAN 15 PARAMETERS ?
         BL    SCYES3A
         BAL   R6,ERR2B
*
         DC    X'0024'                 E36
*
         B     COMPFIN
*
SCYES3A  L     R15,LPBP
         S     R15,KF11                R15 CONTAINS ADDR OF PROC ENTRY
         SR    R6,R6
         IC    R6,PZ
         SLA   R6,4(0)
         STC   R6,PZ
         MVZ   9(1,R15),PZ             INSERT NUMBER OF PARAMETERS INTO
*                                      INTERNAL NAME OF THE PROCEDURE
         SRA   R6,4
         STC   R6,PZ                   NOTE NUMBER OF PARAMETER
         NI    BITS3,FMOFF             FMBIT=0
         TM    19(R15),X'80'           TYPE PROCEDURE ?
         BZ    TESTPAR                 NO
         MVZ   31(1,R15),9(R15)        INSERT NUMBER OF PARAMETERS INTO
*                                      SECOND NAME ENTRY IN ITAB
         LA    R15,33(,R15)            GET ADDR OF FIRST PARAMETER
         B     TESTPARA
*
TESTPAR  LA    R15,22(,R15)
TESTPARA CLI   PZ,0                    ANY PARAMETERS ?
         BER   R14                     NO, BRANCH TO SEMCO OR COMERR
         ST    R15,PRIMPAR             YES, SAVE ADDR OF FIRST
         BR    R14                     BRANCH TO SEMCO OR COMERR
*
*        PROCDEL
*
*        A RIGHT PARENTHESIS HAS BEEN FOUND IN THE LIST THAT NOT
*        WAS FOLLOWED BY A .,
*        IF A LETTERSTRING IS FOUND, NOTHING BUT LETTERS AND
*        BLANKS FOLLOWED BY ..(A COMMA IS MOVED TO OUTPUT AND
*        PROCID ACTIVATED TO TAKE NEXT NAME.
*        IF ANYTHING ELSE IS FOUND E37 IS GENERATED AND COMERR
*        ACTIVATED TO SKIP TO NEXT SEMICOLON
*        ADDR OF COMERR IS PUT IN R14
*
PROCDEL  LA    R9,DELCHECK+4
DELCHECK LA    R1,1(,R1)
         CLI   0(R1),XFA               LETTER ?
         BNL   DELCHECK
         CLI   0(R1),XFZETA            ZETA ?
         BE    CIB
         CLI   0(R1),XFCOLON           COLON ?
         BE    DELCOLON
         CLI   0(R1),XFBLANK
         BE    DELCHECK
         CLI   0(R1),XFPERIOD          PERIOD ?
         BNE   ERROR37
DELPOINT LA    R1,1(,R1)
         CLI   0(R1),XFPERIOD          ONE MORE PERIOD ?
         BE    DELCOLON
         CLI   0(R1),XFBLANK
         BE    DELPOINT
         CLI   0(R1),XFZETA            ZETA ?
         BNE   ERROR37
         LA    R9,DELPOINT+4
         B     CIB
*
DELCOLON LA    R1,1(,R1)
         CLI   0(R1),XFLBRAC           LEFT BRACKET ?
         BE    DELPAREN
         CLI   0(R1),XFBLANK           BLANK ?
         BE    DELCOLON
         CLI   0(R1),XFZETA            ZETA ?
         BNE   DELCOLAA
         LA    R9,DELCOLON+4
         B     CIB
*
DELCOLAA BCTR  R1,0                    NO BRACKETS FOLLOWS THE COLON
         B     ERROR37                 RESET R1 AND GOTO ERROR 37
*
DELPAREN BAL   R12,COB
         MVI   0(R3),XFCOMMA           MOVE COMMA TO OUTPUT INSTEAD OF
         LA    R3,1(,R3)               DELIMITER INCREASE O/P POINTER
         B     PROCID                  RETURN TO PROCEDURE CHECKING
*
ERROR37  BAL   R6,ERR2B
*
         DC    X'0025'                 E37
*
         LA    R14,COMERR
         B     SCYES3
*
*        ENDMISS
*
*        ENTERED IF END OF DATA FOUND BEFORE LOGICAL
*        PROGRAM END IS FOUND BY SCAN I/II
*        CLOSES WHAT REMAINS OPEN IN STACK
*        GENERATES PATTERN FOR ERROR MESSAGE 39
*
ENDMISS  TM    BITS2,STARTBIT          FIRST BEGIN FOUND ?
         BO    ENDMISSA                YES
         BAL   R6,ERR4
*
         DC    X'042C'                 E44 NOTHING PROCESSED
*
ENDMISSA OI    BITS1,TERBIT
TERMSEAC LA    R4,TERMSEAC             RETURN FOR PBLCKEND PROG
         L     R15,SP                  GET STACK POINTER
         CLI   0(R15),X'04'            BETA IN STACK ?
         BE    STEPUP
         CLI   0(R15),X'08'            BEGIN ?
         BE    STEPUP
         CLI   0(R15),X'10'            PROC* ?
         BNE   TERMBRNC
STEPUP   LH    R6,ENDCOUNT             INCREASE END COUNT
         LA    R6,1(,R6)
         STH   R6,ENDCOUNT
TERMBRNC IC    R2,0(,R15)
         L     R6,TERMTAB(R2)          BRANCH ACORDING TO STACK BYTE
         BR    R6
*
TERMTAB  DC    A(ERROR39)              +00
         DC    A(PBLCKEND)             +04 BEGIN
         DC    A(TERMBGN)              +08 BETA
         DC    A(PBLCKEND)             +12 PROC
         DC    A(PBLCKEND)             +16 PROC*
         DC    A(PBLCKEND)             +20 PROC**
         DC    A(FOREND)               +24 FOR
*
TERMBGN  BAL   R12,COB
         MVI   0(R3),XFEND             MOVE OUT END TO O/P
         LA    R3,1(,R3)
         L     R15,SP
         BCTR  R15,0                   RELEASE BEGIN IN STACK
         ST    R15,SP
         B     TERMSEAC
*
*        SLUT2
*
*        ENTERED FROM IEX00 IF INTERUPT OCCURS BEFORE GETMAIN
*
SLUT2    OI    BITS3,NOFREE             INTERUPT OCCURED PRIOR
         B     SCANEND                  GOTO PROCESS TERMINATING PART
*
*        READROUT
*
*        ENTERED AFTER FINAL END COMMENT HAS BEEN CHECKED SHOULD
*        EXIT TO EODADIN VIA OS EOD ROUTINE
*
READROUT LA    R1,1(,R1)
         LA    R9,*+4
         TRT   0(73,R1),BTABLE         ONLY VALID CHARACTER AFTER
         CLI   0(R1),XFZETA            FINAL END COMMENT IS ZETA ?
         BE    CIB
         B     ERR9                    ANYTHING ELSE FOUND
*
E39PAR   DC    X'0727'                 E39
*
ERROR39  LA    R6,E39PAR
         BAL   R12,ERROR1              CREATE E39 PATTERN
         LH    R6,ENDCOUNT
         CVD   R6,DOUBLE
         UNPK  SAVE1(4),DOUBLE+5(3)
         OI    SAVE1+3,X'F0'           INSERT NUMBER OF ENDS MISSING
         MVC   4(3,R15),SAVE1+1        IN ERROR PATTERN
*
*        EODADIN
*
*        FALL THROUGH TO TERMINATION SECTION
*
*        TERMINATION
*
*        WRITES PB0 ITAB BLOCK FOR A PRECOMPILED PROCEDURE
*        WRITES LAST O/P REC IF MORE THAN ONE O/P RECORD
*        CORRECTS PRPT AND MOVES THE CONSTANTS 0 TROUGH 15 TO
*        THE CONSTANT POOL
*        IF NO TERMINATION ERROR AND EITHER DECK OR LOAD IS
*        SPECIFIED ESD CARD AND TXT CARDS ARE GENERATED WITH
*        GENERATE
*        CHECKS LAST ITAB RECORD WRITTEN, IF ANY
*        CLOSES SYSIN, SYSUT1, SYSUT3
*        MAKES A FREEMAIN
*        EXITS -
*        IEX20 IF NO TERMINATING ERROR
*        IEX21 IF TERMINATING ERROR
*
EODADIN  TM    COMPFLGS,TERR           TERMINATING ERROR ?
         BO    KOPOOLRL                YES, DO NOT WRITE OUT ANYTHING
         L     R1,AITAB                CHECK IF PB0
         LA    R1,11(,R1)              CONTAINS ANYTHING
         C     R1,AITL
         BE    NOPBN0                  NO PB0
         L     R15,AITL
         OI    BITS2,X'08'             SET SWITCH
         BAL   R4,WRTITAB              WRITE OUT PB0
NOPBN0   BAL   R12,COB
         MVI   0(R3),X'2D'             MOVE OMEGA TO O/P
         LA    R3,1(,R3)
         CLI   ONC,0                   ONLY ONE O/P RECORD ?
         BE    NOPBN0A                 YES, BRANCH
         BAL   R12,COBSPEB             NO, WRITE LAST O/P BUFFER
         B     KOPOOLRL
*                                      SOURCE PROGRAM IN STORAGE
NOPBN0A  OI    COMPFLGS+2,SPIC         LEAVE THE SINGLE BUFFER IN CORE
KOPOOLRL L     R7,POOLLOC
         MVC   0(64,R7),KFCONST        MOVE THE CONSTANTS 0 TO 15
         L     R6,PRPT
         A     R6,KF7                  MAKE PRPT POINT
         ST    R6,PRPT                 TO THE NEAREST
         NI    PRPT+3,X'F8'            DOUBLE WORD BOUNDARY
         MVC   PBN+1(1),PBC            SAVE NUMBER OF BLOCKS
         IC    R1,FSN
         BCTR  R1,0                    CORRECT FSN
         STC   R1,ZFSNMAX              SET FOR SCAN 3
         CLC   MGESITL,KF25000         WILL ITAB OVER FLOW ?
         BL    KOPOOLAA
         BAL   R6,ERR7
*
         DC    X'0413'                 E 19
*
KOPOOLAA TM    COMPFLGS+1,NDECK+NLOAD  DECK AND OR LOAD SPECIFIED
         BO    SCANEND                 NO, SKIP ESD CARD GENERATION
         SR    R6,R6
         MVC   ESDPARM,ESDNAME         SET NAME OF PROCEDURE/BEGIN
KOPOOLBB BAL   R2,GENESD               GENERATE ESD RECORD
*
ESDPARM  DC    CL8' '                  ESD NAME
         DC    X'0000'                 ESD TYPE SD
*
         MVC   29(3,R1),KF0            CORRECT FIRST ESD CARD
         L     R2,AKOPOOL
         MVC   GENTLEN,PRPT+2          GET LENGTH OF KOPOOL FOR TXT
         BAL   R14,GENTXTS             GENERATE TXT CARD
*
GENTLEN  DC    H'0'                    UPDATED PRIOR TO GENTXTS CALL
*
SCANEND  TM    BITS3,FRSITB
         BZ    CLSYSUT3
*
         CHECK ITABC
*
CLSYSUT3 L     R6,AUT3DCB
*
         CLOSE ((R6),REREAD),TYPE=T    RESET SYSUT3
*
         L     R6,ASYSDCB              CLOSE SYSIN
*
         CLOSE ((R6))
*
         FREEPOOL (R6)
*
         L     R6,AUT1DCB
         TM    COMPFLGS,TERR           TERMINATING ERROR ?
         BO    CLSPERM                 YES, CLOSE SYSUT1 FOR GOOD
*
         CLOSE ((R6),REREAD),TYPE=T    RESET SYSUT1
*
         B     FREE
*
CLSPERM  CLOSE ((R6),REREAD)           CLOSE SYSUT1
*
FREE     TM    BITS3,NOFREE            INTERUPT BEFORE GETMAIN ?
         BO    GETERRPH                YES, DO NOT MAKE FREEMAIN
         L     R0,POOLLEN
         L     R1,POOLLOC
*
         FREEMAIN R,LV=(0),A=(1)
*
         OI    COMPFLGS+2,NOSC         SET SWITCH FOR ERROR MESSAGES
         TM    COMPFLGS,TERR           TERMINATING ERROR ?
         BO    GETERRPH                YES, CALL IEX21
         ICM   R6,B'1111',BRACKET      BRACKET COUNTER ZERO ?
         BZ    NEXTMOD                 YES, BRANCH
         OI    COMPFLGS,COMPMODE+SERR  NO, SET SYNTAX MODE
*
NEXTMOD  XCTL  EP=IEX20000             GOTO ITAB MANIPULATION
*
GETERRPH XCTL  EP=IEX21000             GOTO ERROR MESSAGE HANDLING
*
*        GENERATE
*
*        REGISTER DEFINITIONS
*
*        R1                            OUTPUT RECORD POINTER
*        R2                            ADDR OF INFORMATION
*        R3                            TYPE OF RECORD TO BE GENERATED
*        R4                            RETURN REG
*        R14                           L'INFORMATION FROM CALL
*        R15                           L'WITHIN RECORD
*
*        BIT PATTERNS
*
SDENTRY  EQU   X'00'                   SD ENTRY IDENTIFICATION
LDENTRY  EQU   X'01'                   LD ENTRY IDENTIFICATION
RLDFLAG  EQU   B'00001101'             FLAG USED IN RLD ENTRY
*
*        ADDR DISPLACEMENTS
*
GENESD   LA    R14,16                  R14 ALWAYS 16
         LA    R3,ESDT                 INDICATE ESD CALL
         MVC   PIDENT,0(R2)            NAME TO IDENT PART
         B     GEN3                    CALL FOR FIRST OUT REC
*
GENTXTS  LA    R4,2(,R14)              COMPUTE RETURN ADDR
         LH    R14,0(,R14)             LOAD R14 GIVEN IN CALL
GEN2     LA    R3,TXTT                 INDICATE TXT CALL
*
GEN1     L     R1,SAVOUTA              LOAD ADDR OF OUT RECORD
         CLC   1(3,R1),1(R3)           RECORD RIGHT TYPE ?
         BNE   GEN3                    NO, CALL IOR NEW
         CLC   10(2,R1),12(R3)         RECORD FILLED ?
         BNL   GEN3                    YES, CALL FOR NEW
GEN6     LA    R15,56
         LH    R0,10(,R1)              R0 = L'INFORMATION IN REC
         SR    R15,R0                  R15 = EMPTY POS LEFT IN RECORD
         CR    R15,R14                 ENOUTH SPACE LEFT ?
         BL    GEN6A                   NO
         LR    R15,R14                 YES R15=R14 FROM CALL
GEN6A    AR    R15,R0
         STH   R15,10(,R1)             INSERT NEW LENGTH INTO RECORD
*
         SR    R15,R0
         AR    R1,R0                   START ADDR WITHIN RECORD
         SR    R14,R15                 REMAINING LENGTH
         B     14(,R3)                 TO DIFFERENT MOVE ROUTINES
*
GEN4     LTR   R14,R14                 MORE INFORMATION MUST BE MOVED ?
         BH    GEN3                    YES
         BR    R4
*
GEN3     EQU   *                       CALL FOR NEW OUTPUT RECORD
PUNCH    ST    14,ERRSAVE
         TM    COMPFLGS+1,NLOAD+NDECK  BOTH DECK AND LOAD SPECIFIED ?
         BZ    BOTH                    YES
         L     R1,APCHDCB              R1- > SYSPUNCH DCB
         TM    COMPFLGS+1,NDECK        DECK ?
         BZ    PUT1                    YES
PUT1A    L     R1,ALINDCB              R1 -> SYSLIN DCB
*
PUT1     PUT   (R1)                    PUT FOR SYSLIN AND SYSPUNCH IF
*
         ST    R1,SAVOUTA              ONLY SYSPUNCH SPECIFIED
         L     14,ERRSAVE
         B     PUNCHOUT
*
BOTH     TM    BITS2,X'02'             FIRST PUT ?
         BZ    FIRSTPUT                YES
         L     R14,OUTAREA2            COPY SYSLIN BUFFER TO SYSPUNCH
         L     R1,SAVOUTA
         MVC   0(80,R14),0(R1)         BUFFER
PUT2     L     R1,APCHDCB              R1- > SYSPUNCH DCB
*
         PUT   (R1)                    PUT FOR SYSPUNCH WHEN BOTH HAS
*
         ST    R1,OUTAREA2             BEEN SPECIFIED
         B     PUT1A                   GOTO PUT SYSLIN
*
FIRSTPUT OI    BITS2,X'02'
         B     PUT2
*
PUNCHOUT MVC   0(4,R1),0(R3)           INSERT FIRST 4 BYTES
         MVI   4(R1),C' '              INSERT ONE BLANK
         MVC   5(67,R1),4(R1)          BLANK OUTPUT RECORD
         MVC   72(4,R1),PIDENT         INSERT PROGRAM IDENT
         AP    CARDCNT,KP1             INCR CARD COUNT
         UNPK  76(4,R1),CARDCNT        UNPACK INTO RECORD
         OI    79(R1),X'F0'            MAKE PRINTABLE
         MVC   10(2,R1),4(R3)          INSERT INITIAL LENGTH
         MVC   14(6,R1),6(R3)          INSERT ESID+R AND P
         CLC   TXTT+1(3),1(R3)         TXT RECORD PROCESSED ?
         BNE   GEN6                    NO
         ST    R6,4(R1)                YES, INSERT R6
         MVI   4(R1),C' '
         B     GEN6
*
*        TABLES AND MOVE ROUTINES
*
*        ESD RECORD
*
ESDT     DC    X'02'                   RECORD CODE
         DC    C'ESD'                  IDENTIFICATION
         DC    H'0'                    INITIAL LENGTH 0
         DC    C'      '
         DC    H'48'                   MAXIMUM LENTH IN RECORD
*
*        MOVE ESD INFORMATION TO OUTPUT
*
GEN7     MVC   16(9,R1),0(R2)          MOVE ESD NAME AND ESD TYPE SD TO
*                                      ESD OUTPUT RECORD
         MVC   25(L'ESDCON,R1),ESDCON  CHANGE LAST PART OF ENTRY
         LA    R3,1                    SET ESID NUMBER TO 1
         STH   R3,14(R1)               INSERT ESID NUMBER
         B     10(,R2)                 RETURN TO CALLING ROUTINE
*
*        TXT RECORD
*
TXTT     DC    X'02'                   RECORD CODE
         DC    C'TXT'                  IDENTIFICATION
         DC    H'0'                    INITIAL LENGTH 0
         DC    H'1'                    ESID
         DC    C'    '
         DC    H'56'                   MAXIMUM LENGTH
*
*        MOVE TXT INFORMATION TO OUTPUT
*
GEN8     BCTR  R15,0                   DECR R15
         STC   R15,*+5                 INSERT LENGTH TO MOVE IN MVC
         MVC   16(0,R1),0(R2)          MOVE INFORMATION TO OUTAREA
         LA    R6,1(R15,R6)            INCREASE PROGRAM POINTER
         LA    R2,1(R15,R2)            MODIFY DATA ADDR
         B     GEN4                    EXIT MOVE TXT ROUTINE
*
*        BPRTAB
*
*        CONTAINS ADDR CONSTANTS OF PROGRAMS UTILIZED BY -
*        TEST
*        LIST
*        POINT
*        APOSTROF
*        POINTLST
*
*        THE ADDRESSES ARE PICKED UP WITH DISPLACEMENTS FROM -
*        TESTTABL
*        ARTABLE
*        PTTABLE
*        ATABLE
*        PTTABLE FOR POINTLST 56 IS ADDED TO DISP GIVEN
*
BPRTAB   DC    A(0)              + 00
         DC    A(TRANSOP)        + 04
         DC    A(TRANSOP)        + 08
         DC    A(TRANSOP)        + 12
         DC    A(TRANSOP)        + 16
         DC    A(TRANSOP)        + 20
         DC    A(TRANSOP)        + 24
         DC    A(COLON)          + 28  COLON
         DC    A(SEMCO)          + 32  SEMICOLON
         DC    A(RIGHTPAR)       + 36
         DC    A(BLANK)          + 40
         DC    A(ERR1)           + 44
         DC    A(POINT)          + 48
         DC    A(APOSTROF)       + 52
         DC    A(CIB)            + 56
         DC    A(ASSIGN)         + 60
         DC    A(DECPOINT)       + 64
         DC    A(ERR5)           + 68  ERROR AFTER POINT
         DC    A(BLKAPOS)        + 72  BLANK AFTER APOSTROPHE
         DC    A(NPAFTAPO)       + 76  NOT PERMITTED AFTER APOSTR
         DC    A(SCALE)          + 80  DIGIT OR SIGN AFTER APOSTROPHE
         DC    A(COLONLST)       + 84  COLON IN LIST
         DC    A(SEMCLST)        + 88  SEMICOLON IN LIST
         DC    A(DELIMIT)        + 92  DELIMITER PROGRAM
         DC    A(ZETAAPO)        + 96  ZETA AFTER APOSTROPHE
         DC    A(EROUT)          +100  ERROR (FROM W1,W2OR W3 TAB)
         DC    A(LEFTPARL)       +104  LEFT PARENTHESIS IN LIST
         DC    A(RIGTPARL)       +108  RIGHT PARENTHESIS IN LIST
         DC    A(PZETA)          +112  ZETA AFTER POINT IN LIST
         DC    A(ASSIGN)         +116  ASSIGNMENT POINT IN LIST
         DC    A(DECPOINT)       +120  DECPOINT IN LIST
         DC    A(ERR5A)          +124  POINT ERROR IN LIST
         DC    A(COMMALST)       +128  COMMA IN LIST
         DC    A(PONTLST)        +132  POINT IN LIST
         DC    A(SLASHLST)       +136  SLASH IN LIST
         DC    A(QUOTE)          +140  QUOTE
         DC    A(SEMC60)         +144
*
*        PTTABLE
*
*        USED BY -
*        POINT
*        PONTLST
*        GIVES DISPLACEMENTS TO BPRTAB
*        WHEN USED BY PONTLST 56 IS ADDED TO ORIGINAL DISP
*
PTTABLE  DC    AL1(68)                +00   XFPLUS
         DC    AL1(68)                +01   XFMINUS
         DC    AL1(68)                +02   XFASTER
         DC    AL1(68)                +03   XFSLASH
         DC    AL1(0)                 +04
         DC    AL1(0)                 +05
         DC    AL1(68)                +06   XFLBRAC
         DC    AL1(68)                +07   XFCOLON
         DC    AL1(0)                 +08   XFLSQBR
         DC    AL1(0)                 +09
         DC    AL1(0)                 +0A
         DC    AL1(68)                +0B   XFSCOLON
         DC    AL1(0)                 +0C
         DC    AL1(0)                 +0D
         DC    AL1(0)                 +0E
         DC    AL1(0)                 +0F
         DC    AL1(60)                +10   XFEQUAL
         DC    AL1(68)                +11   XFLT
         DC    AL1(68)                +12   XFGT
         DC    AL1(0)                 +13
         DC    AL1(0)                 +14
         DC    AL1(0)                 +15
         DC    AL1(0)                 +16
         DC    AL1(0)                 +17
         DC    AL1(0)                 +18
         DC    AL1(0)                 +19
         DC    AL1(0)                 +1A
         DC    AL1(0)                 +1B
         DC    AL1(0)                 +1C
         DC    AL1(0)                 +1D
         DC    AL1(0)                 +1E
         DC    AL1(0)                 +1F
         DC    AL1(68)                +20   XFNOT
         DC    AL1(0)                 +21
         DC    AL1(68)                +22   XFOR
         DC    AL1(68)                +23   XFAMPER
         DC    AL1(0)                 +24
         DC    AL1(32)                +25   XFCOMMA
         DC    AL1(68)                +26   XFRBRAC
         DC    AL1(0)                 +27
         DC    AL1(0)                 +28   XFRSQBR
         DC    AL1(0)                 +29
         DC    AL1(0)                 +2A
         DC    AL1(0)                 +2B   XFBLANK
         DC    AL1(68)                +2C
         DC    AL1(28)                +2D   XFPERIOD
         DC    AL1(68)                +2E   XFQUOTE
         DC    AL1(56)                +2F
         DC    AL1(64)                +30   XF0
         DC    AL1(64)                +31   XF1
         DC    AL1(64)                +32   XF2
         DC    AL1(64)                +33   XF3
         DC    AL1(64)                +34   XF4
         DC    AL1(64)                +35   XF5
         DC    AL1(64)                +36   XF6
         DC    AL1(64)                +37   XF7
         DC    AL1(64)                +38   XF8
         DC    AL1(64)                +39   XF9
         DC    AL1(0)                 +3A
         DC    AL1(0)                 +3B
         DC    AL1(0)                 +3C
         DC    AL1(0)                 +3D
         DC    AL1(0)                 +3E
         DC    AL1(0)                 +3F
         DC    AL1(68)                +40   XFA
         DC    AL1(68)                +41   XFB
         DC    AL1(68)                +42   XFC
         DC    AL1(68)                +43   XFD
         DC    AL1(68)                +44   XFE
         DC    AL1(68)                +45   XFF
         DC    AL1(68)                +46   XFG
         DC    AL1(68)                +47   XFH
         DC    AL1(68)                +48   XFI
         DC    AL1(68)                +49   XFJ
         DC    AL1(68)                +4A   XFK
         DC    AL1(68)                +4B   XFL
         DC    AL1(68)                +4C   XFM
         DC    AL1(68)                +4D   XFN
         DC    AL1(68)                +4E   XFO
         DC    AL1(68)                +4F   XFP
         DC    AL1(68)                +50   XFQ
         DC    AL1(68)                +51   XFR
         DC    AL1(68)                +52   XFS
         DC    AL1(68)                +53   XFT
         DC    AL1(68)                +54   XFU
         DC    AL1(68)                +55   XFV
         DC    AL1(68)                +56   XFW
         DC    AL1(68)                +57   XFX
         DC    AL1(68)                +58   XFY
         DC    AL1(68)                +59   XFZ
         DC    AL1(68)                +59   XFDOLLAR
         DC    AL1(68)                +59   XFUNDER
         DC    AL1(68)                +59   XFHASH
         DC    AL1(68)                +59   XFAT
*
*        ATABLE
*
*        USED BY THE APOSTROPHE PROGRAM
*        GIVES DISPLACEMENTS TO BPRTAB
*
ATABLE   DC    AL1(80)                +00   XFPLUS
         DC    AL1(80)                +01   XFMINUS
         DC    AL1(100)               +02   XFASTER
         DC    AL1(0)                 +03   XFSLASH
         DC    AL1(0)                 +04
         DC    AL1(0)                 +05
         DC    AL1(0)                 +06   XFLBRAC
         DC    AL1(100)               +07   XFCOLON
         DC    AL1(0)                 +08   XFLSQBR
         DC    AL1(0)                 +09
         DC    AL1(0)                 +0A
         DC    AL1(100)               +0B   XFSCOLON
         DC    AL1(0)                 +0C
         DC    AL1(0)                 +0D
         DC    AL1(0)                 +0E
         DC    AL1(0)                 +0F
         DC    AL1(100)               +10   XFEQUAL
         DC    AL1(100)               +11   XFLT
         DC    AL1(100)               +12   XFGT
         DC    AL1(0)                 +13
         DC    AL1(0)                 +14
         DC    AL1(0)                 +15
         DC    AL1(0)                 +16
         DC    AL1(0)                 +17
         DC    AL1(0)                 +18
         DC    AL1(0)                 +19
         DC    AL1(0)                 +1A
         DC    AL1(0)                 +1B
         DC    AL1(0)                 +1C
         DC    AL1(0)                 +1D
         DC    AL1(0)                 +1E
         DC    AL1(0)                 +1F
         DC    AL1(100)               +20   XFNOT
         DC    AL1(0)                 +21
         DC    AL1(100)               +22   XFOR
         DC    AL1(100)               +23   XFAMPER
         DC    AL1(0)                 +24
         DC    AL1(100)               +25   XFCOMMA
         DC    AL1(100)               +26   XFRBRAC
         DC    AL1(0)                 +27
         DC    AL1(0)                 +28   XFRSQBR
         DC    AL1(0)                 +29
         DC    AL1(0)                 +2A
         DC    AL1(72)                +2B   XFBLANK
         DC    AL1(76)                +2C
         DC    AL1(100)               +2D   XFPERIOD
         DC    AL1(92)                +2E   XFQUOTE
         DC    AL1(96)                +2F
         DC    AL1(80)                +30   XF0
         DC    AL1(80)                +31   XF1
         DC    AL1(80)                +32   XF2
         DC    AL1(80)                +33   XF3
         DC    AL1(80)                +34   XF4
         DC    AL1(80)                +35   XF5
         DC    AL1(80)                +36   XF6
         DC    AL1(80)                +37   XF7
         DC    AL1(80)                +38   XF8
         DC    AL1(80)                +39   XF9
         DC    AL1(0)                 +3A
         DC    AL1(0)                 +3B
         DC    AL1(0)                 +3C
         DC    AL1(0)                 +3D
         DC    AL1(0)                 +3E
         DC    AL1(0)                 +3F
         DC    AL1(0)                 +40   XFA
         DC    AL1(0)                 +41   XFB
         DC    AL1(0)                 +42   XFC
         DC    AL1(0)                 +43   XFD
         DC    AL1(0)                 +44   XFE
         DC    AL1(0)                 +45   XFF
         DC    AL1(0)                 +46   XFG
         DC    AL1(0)                 +47   XFH
         DC    AL1(0)                 +48   XFI
         DC    AL1(0)                 +49   XFJ
         DC    AL1(0)                 +4A   XFK
         DC    AL1(0)                 +4B   XFL
         DC    AL1(0)                 +4C   XFM
         DC    AL1(0)                 +4D   XFN
         DC    AL1(0)                 +4E   XFO
         DC    AL1(0)                 +4F   XFP
         DC    AL1(0)                 +50   XFQ
         DC    AL1(0)                 +51   XFR
         DC    AL1(0)                 +52   XFS
         DC    AL1(0)                 +53   XFT
         DC    AL1(0)                 +54   XFU
         DC    AL1(0)                 +55   XFV
         DC    AL1(0)                 +56   XFW
         DC    AL1(0)                 +57   XFX
         DC    AL1(0)                 +58   XFY
         DC    AL1(0)                 +59   XFZ
         DC    AL1(0)                 +5A   XFDOLLAR
         DC    AL1(0)                 +5B   XFUNDER
         DC    AL1(0)                 +5C   XFHASH
         DC    AL1(0)                 +5D   XFAT
*
*        BTABLE
*
*        BLANK TABLES - SCANS FOR FIRST NONBLANK CHARACTER
*        USED BY -
*        BLANK
*        BLKAPOS BLANK AFTER APOSTROPHE
*        READROUT IN TERMINATION
*
BTABLE   DC    X'FF'                  +00   XFPLUS
         DC    X'FF'                  +01   XFMINUS
         DC    X'FF'                  +02   XFASTER
         DC    X'FF'                  +03   XFSLASH
         DC    X'00'                  +04
         DC    X'00'                  +05
         DC    X'FF'                  +06   XFLBRAC
         DC    X'FF'                  +07   XFCOLON
         DC    X'FF'                  +08   XFLSQBR
         DC    X'00'                  +09
         DC    X'00'                  +0A
         DC    X'FF'                  +0B   XFSCOLON
         DC    X'00'                  +0C
         DC    X'00'                  +0D
         DC    X'00'                  +0E
         DC    X'00'                  +0F
         DC    X'FF'                  +10   XFEQUAL
         DC    X'FF'                  +11   XFLT
         DC    X'FF'                  +12   XFGT
         DC    X'00'                  +13
         DC    X'00'                  +14
         DC    X'00'                  +15
         DC    X'00'                  +16
         DC    X'00'                  +17
         DC    X'00'                  +18
         DC    X'00'                  +19
         DC    X'00'                  +1A
         DC    X'00'                  +1B
         DC    X'00'                  +1C
         DC    X'00'                  +1D
         DC    X'00'                  +1E
         DC    X'00'                  +1F
         DC    X'FF'                  +20   XFNOT
         DC    X'00'                  +21
         DC    X'FF'                  +22   XFOR
         DC    X'FF'                  +23   XFAMPER
         DC    X'00'                  +24
         DC    X'FF'                  +25   XFCOMMA
         DC    X'FF'                  +26   XFRBRAC
         DC    X'00'                  +27
         DC    X'FF'                  +28   XFRSQBR
         DC    X'00'                  +29
         DC    X'00'                  +2A
         DC    X'00'                  +2B   XFBLANK
         DC    X'FF'                  +2C
         DC    X'FF'                  +2D   XFPERIOD
         DC    X'FF'                  +2E   XFQUOTE
         DC    X'FF'                  +2F
         DC    X'FF'                  +30   XF0
         DC    X'FF'                  +31   XF1
         DC    X'FF'                  +32   XF2
         DC    X'FF'                  +33   XF3
         DC    X'FF'                  +34   XF4
         DC    X'FF'                  +35   XF5
         DC    X'FF'                  +36   XF6
         DC    X'FF'                  +37   XF7
         DC    X'FF'                  +38   XF8
         DC    X'FF'                  +39   XF9
         DC    X'00'                  +3A
         DC    X'00'                  +3B
         DC    X'00'                  +3C
         DC    X'00'                  +3D
         DC    X'00'                  +3E
         DC    X'00'                  +3F
         DC    X'FF'                  +40   XFA
         DC    X'FF'                  +41   XFB
         DC    X'FF'                  +42   XFC
         DC    X'FF'                  +43   XFD
         DC    X'FF'                  +44   XFE
         DC    X'FF'                  +45   XFF
         DC    X'FF'                  +46   XFG
         DC    X'FF'                  +47   XFH
         DC    X'FF'                  +48   XFI
         DC    X'FF'                  +49   XFJ
         DC    X'FF'                  +4A   XFK
         DC    X'FF'                  +4B   XFL
         DC    X'FF'                  +4C   XFM
         DC    X'FF'                  +4D   XFN
         DC    X'FF'                  +4E   XFO
         DC    X'FF'                  +4F   XFP
         DC    X'FF'                  +50   XFQ
         DC    X'FF'                  +51   XFR
         DC    X'FF'                  +52   XFS
         DC    X'FF'                  +53   XFT
         DC    X'FF'                  +54   XFU
         DC    X'FF'                  +55   XFV
         DC    X'FF'                  +56   XFW
         DC    X'FF'                  +57   XFX
         DC    X'FF'                  +58   XFY
         DC    X'FF'                  +59   XFZ
         DC    X'FF'                  +5A   XFDOLLAR
         DC    X'FF'                  +5B   XFUNDER
         DC    X'FF'                  +5C   XFHASH
         DC    X'FF'                  +5D   XFAT
*
*        TESTTABL
*
*        USED BY MAIN LOOP SCANNING - GIVES DISPLACEMENTS TO BPRTAB
*
TESTTABL DC    AL1(0)                 +00   XFPLUS
         DC    AL1(0)                 +01   XFMINUS
         DC    AL1(4)                 +02   XFASTER
         DC    AL1(8)                 +03   XFSLASH
         DC    AL1(0)                 +04
         DC    AL1(0)                 +05
         DC    AL1(12)                +06   XFLBRAC
         DC    AL1(28)                +07   XFCOLON
         DC    AL1(0)                 +08   XFLSQBR
         DC    AL1(0)                 +09
         DC    AL1(0)                 +0A
         DC    AL1(144)               +0B   XFSCOLON
         DC    AL1(0)                 +0C
         DC    AL1(0)                 +0D
         DC    AL1(0)                 +0E
         DC    AL1(0)                 +0F
         DC    AL1(0)                 +10   XFEQUAL
         DC    AL1(16)                +11   XFLT
         DC    AL1(20)                +12   XFGT
         DC    AL1(0)                 +13
         DC    AL1(0)                 +14
         DC    AL1(0)                 +15
         DC    AL1(0)                 +16
         DC    AL1(0)                 +17
         DC    AL1(0)                 +18
         DC    AL1(0)                 +19
         DC    AL1(0)                 +1A
         DC    AL1(0)                 +1B
         DC    AL1(0)                 +1C
         DC    AL1(0)                 +1D
         DC    AL1(0)                 +1E
         DC    AL1(0)                 +1F
         DC    AL1(24)                +20   XFNOT
         DC    AL1(0)                 +21
         DC    AL1(0)                 +22   XFOR
         DC    AL1(0)                 +23   XFAMPER
         DC    AL1(0)                 +24
         DC    AL1(0)                 +25   XFCOMMA
         DC    AL1(36)                +26   XFRBRAC
         DC    AL1(0)                 +27
         DC    AL1(0)                 +28   XFRSQBR
         DC    AL1(0)                 +29
         DC    AL1(0)                 +2A
         DC    AL1(40)                +2B   XFBLANK
         DC    AL1(44)                +2C
         DC    AL1(48)                +2D   XFPERIOD
         DC    AL1(52)                +2E   XFQUOTE
         DC    AL1(56)                +2F
         DC    AL1(0)                 +30   XF0
         DC    AL1(0)                 +31   XF1
         DC    AL1(0)                 +32   XF2
         DC    AL1(0)                 +33   XF3
         DC    AL1(0)                 +34   XF4
         DC    AL1(0)                 +35   XF5
         DC    AL1(0)                 +36   XF6
         DC    AL1(0)                 +37   XF7
         DC    AL1(0)                 +38   XF8
         DC    AL1(0)                 +39   XF9
         DC    AL1(0)                 +3A
         DC    AL1(0)                 +3B
         DC    AL1(0)                 +3C
         DC    AL1(0)                 +3D
         DC    AL1(0)                 +3E
         DC    AL1(0)                 +3F
         DC    AL1(0)                 +40   XFA
         DC    AL1(0)                 +41   XFB
         DC    AL1(0)                 +42   XFC
         DC    AL1(0)                 +43   XFD
         DC    AL1(0)                 +44   XFE
         DC    AL1(0)                 +45   XFF
         DC    AL1(0)                 +46   XFG
         DC    AL1(0)                 +47   XFH
         DC    AL1(0)                 +48   XFI
         DC    AL1(0)                 +49   XFJ
         DC    AL1(0)                 +4A   XFK
         DC    AL1(0)                 +4B   XFL
         DC    AL1(0)                 +4C   XFM
         DC    AL1(0)                 +4D   XFN
         DC    AL1(0)                 +4E   XFO
         DC    AL1(0)                 +4F   XFP
         DC    AL1(0)                 +50   XFQ
         DC    AL1(0)                 +51   XFR
         DC    AL1(0)                 +52   XFS
         DC    AL1(0)                 +53   XFT
         DC    AL1(0)                 +54   XFU
         DC    AL1(0)                 +55   XFV
         DC    AL1(0)                 +56   XFW
         DC    AL1(0)                 +57   XFX
         DC    AL1(0)                 +58   XFY
         DC    AL1(0)                 +59   XFZ
         DC    AL1(0)                 +5A   XFDOLLAR
         DC    AL1(0)                 +5B   XFUNDER
         DC    AL1(0)                 +5C   XFHASH
         DC    AL1(0)                 +5D   XFAT
*
*        ARTABLE
*
*        USED BY LIST EQUIVALENT TO THE USE OF TESTTABLE BY TESTLOOP
*        GIVES DISPLACEMENT TO BPRTAB
*
ARTABLE  DC    AL1(0)                 +00   XFPLUS
         DC    AL1(0)                 +01   XFMINUS
         DC    AL1(4)                 +02   XFASTER
         DC    AL1(136)               +03   XFSLASH <-------
         DC    AL1(0)                 +04                  |
         DC    AL1(0)                 +05                  |
         DC    AL1(104)               +06   XFLBRAC <--    |
         DC    AL1(84)                +07   XFCOLON   |    |
         DC    AL1(104)               +08   XFLSQBR <--    |
         DC    AL1(0)                 +09                  |
         DC    AL1(0)                 +0A                  |
         DC    AL1(88)                +0B   XFSCOLON       |
         DC    AL1(0)                 +0C                  |
         DC    AL1(0)                 +0D                  |
         DC    AL1(0)                 +0E                  |
         DC    AL1(0)                 +0F                  |
         DC    AL1(0)                 +10   XFEQUAL        |
         DC    AL1(16)                +11   XFLT           |
         DC    AL1(20)                +12   XFGT           |
         DC    AL1(0)                 +13                  |
         DC    AL1(0)                 +14                  |
         DC    AL1(0)                 +15                  |
         DC    AL1(0)                 +16                  |
         DC    AL1(0)                 +17                  |
         DC    AL1(0)                 +18                  |
         DC    AL1(0)                 +19                  |
         DC    AL1(0)                 +1A                  |
         DC    AL1(0)                 +1B                  |
         DC    AL1(0)                 +1C                  |
         DC    AL1(0)                 +1D                  |
         DC    AL1(0)                 +1E                  |
         DC    AL1(0)                 +1F                  |
         DC    AL1(24)                +20   XFNOT          |
         DC    AL1(0)                 +21                  |
         DC    AL1(0)                 +22   XFOR           |
         DC    AL1(0)                 +23   XFAMPER        |
         DC    AL1(0)                 +24                  |
         DC    AL1(128)               +25   XFCOMMA        |
         DC    AL1(136)               +26   XFRBRAC        |
         DC    AL1(0)                 +27                  |
         DC    AL1(136)               +28   XFRSQBR <-------
         DC    AL1(0)                 +29
         DC    AL1(0)                 +2A
         DC    AL1(40)                +2B   XFBLANK
         DC    AL1(44)                +2C
         DC    AL1(132)               +2D   XFPERIOD
         DC    AL1(52)                +2E   XFQUOTE
         DC    AL1(56)                +2F
         DC    AL1(0)                 +30   XF0
         DC    AL1(0)                 +31   XF1
         DC    AL1(0)                 +32   XF2
         DC    AL1(0)                 +33   XF3
         DC    AL1(0)                 +34   XF4
         DC    AL1(0)                 +35   XF5
         DC    AL1(0)                 +36   XF6
         DC    AL1(0)                 +37   XF7
         DC    AL1(0)                 +38   XF8
         DC    AL1(0)                 +39   XF9
         DC    AL1(0)                 +3A
         DC    AL1(0)                 +3B
         DC    AL1(0)                 +3C
         DC    AL1(0)                 +3D
         DC    AL1(0)                 +3E
         DC    AL1(0)                 +3F
         DC    AL1(0)                 +40   XFA
         DC    AL1(0)                 +41   XFB
         DC    AL1(0)                 +42   XFC
         DC    AL1(0)                 +43   XFD
         DC    AL1(0)                 +44   XFE
         DC    AL1(0)                 +45   XFF
         DC    AL1(0)                 +46   XFG
         DC    AL1(0)                 +47   XFH
         DC    AL1(0)                 +48   XFI
         DC    AL1(0)                 +49   XFJ
         DC    AL1(0)                 +4A   XFK
         DC    AL1(0)                 +4B   XFL
         DC    AL1(0)                 +4C   XFM
         DC    AL1(0)                 +4D   XFN
         DC    AL1(0)                 +4E   XFO
         DC    AL1(0)                 +4F   XFP
         DC    AL1(0)                 +50   XFQ
         DC    AL1(0)                 +51   XFR
         DC    AL1(0)                 +52   XFS
         DC    AL1(0)                 +53   XFT
         DC    AL1(0)                 +54   XFU
         DC    AL1(0)                 +55   XFV
         DC    AL1(0)                 +56   XFW
         DC    AL1(0)                 +57   XFX
         DC    AL1(0)                 +58   XFY
         DC    AL1(0)                 +59   XFZ
         DC    AL1(0)                 +5A   XFDOLLAR
         DC    AL1(0)                 +5B   XFUNDER
         DC    AL1(0)                 +5C   XFHASH
         DC    AL1(0)                 +5D   XFAT
*
*        TRINTEXT
*
*        CONVERT TABLE FOR INTERNAL CODE TO EBCDIC
*
*        USED BY CODE TO TRANSLATE PROCEDURE NAME PROCEDURE TO
*        TRANSLATE PROCEDURE NAME FOR ESD CARD IF PRECOMPILED
*        SPECIFIED
*
TRINTEXT DC    96C' '
         ORG   TRINTEXT+XFBLANK
         DC    C' '
         ORG   TRINTEXT+XF0
         DC    C'0123456789'
         ORG   TRINTEXT+XFA
         DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
         ORG   TRINTEXT+XFDOLLAR
         DC    C'$_#@'
         ORG
*
*        KWLUTAB
*
*        USED TO REFERENCE ENTRIES IN KEYWTAB FOR KEYWORDS
*
KWLUTAB  DC    A(KEYWDL01)             KEY WORDS LENGTH OF 1
         DC    A(KEYWDL02)             KEY WORDS LENGTH OF 2
         DC    A(KEYWDL03)             KEY WORDS LENGTH OF 3
         DC    A(KEYWDL04)             KEY WORDS LENGTH OF 4
         DC    A(KEYWDL05)             KEY WORDS LENGTH OF 5
         DC    A(KEYWDL06)             KEY WORDS LENGTH OF 6
         DC    A(KEYWDL07)             KEY WORDS LENGTH OF 7
         DC    A(KEYWDL08)             KEY WORDS LENGTH OF 8
         DC    A(KEYWDL09)             KEY WORDS LENGTH OF 9
         DC    A(KEYWDL10)             KEY WORDS LENGTH OF 10
*
*        KEYWTAB
*
*        CONTAINS ALL KEYWORDS, EACH FOLLOWED BY 3 BYTES OF
*        INFORMATION BEING 2 BYTES OF CHARACTERISTICS AND A
*        DISPLACEMENT INTO DELPRGTB
*        FOR A SECTION IN THE KEYWTAB. A SECTION CONTAINS
*        ALL THE KEYWORDS OF THE SAME LENGTH
*        1. THE FIRST BYTE IN EACH SECTION SAYS HOW MANY ENTRIES
*           THERE ARE IN THE SECTION. THEREAFTER THE DELIMITER PLUS 3
*           BYTES OF INTERNAL CODE MAKES A SUBSECTION
*        2. THE FIRST 2 BYTES OF THE INTERNAL CODE IS
*           CHARECTERISTCS FOR THE DELIMITER
*        3. THE THIRD BYTE IS A DISPLACEMENT TO THE DELPRGTB,
*           WHERE THE ADDR IS PICKED UP TO THE PROGRAM TO HANDLE
*           THE KEYWORD
*
KEYWTAB  EQU   *
KEYWDL01 DC    AL1(2)                  NUMBER OF ENTRIES
         IEXCGEN DC,'/'                /
         DC    XL2'0400',XL1'00'
         IEXCGEN DC,'('                (
         DC    XL2'0000',XL1'04'       LEFT BRACKET (STRING)
*
KEYWDL02 DC    AL1(3)                  NUMBER OF ENTRIES
         IEXCGEN DC,'DO'               DO
         DC    XL2'1C00',XL1'08'
         IEXCGEN DC,'IF'               IF
         DC    XL2'1D00',XL1'0C'
         IEXCGEN DC,'OR'               OR
         DC    XL2'2200',XL1'00'
*
KEYWDL03 DC    AL1(4)                  NUMBER OF ENTRIES
KWEND    IEXCGEN DC,'END'              END
         DC    XL2'0000',XL1'10'
         IEXCGEN DC,'FOR'              FOR
         DC    XL2'0000',XL1'14'
         IEXCGEN DC,'AND'              AND
         DC    XL2'2300',XL1'00'
         IEXCGEN DC,'NOT'              NOT
         DC    XL2'2000',XL1'00'
*
KEYWDL04 DC    AL1(9)                  NUMBER OF ENTRIES
         IEXCGEN DC,'REAL'             REAL
         DC    XL2'C212',XL1'18'
         IEXCGEN DC,'STEP'             STEP
         DC    XL2'1900',XL1'00'
         IEXCGEN DC,'THEN'             THEN
         DC    XL2'1E00',XL1'08'
KWELSE   IEXCGEN DC,'ELSE'             ELSE
         DC    XL2'1F00',XL1'08'
         IEXCGEN DC,'GOTO'             GOTO
         DC    XL2'1700',XL1'0C'
         IEXCGEN DC,'TRUE'             TRUE
         DC    XL2'0700',XL1'1C'
         IEXCGEN DC,'LESS'             LESS
         DC    XL2'1100',XL1'00'
         IEXCGEN DC,'CODE'             CODE
         DC    XL2'0000',XL1'20'
         IEXCGEN DC,'IMPL'             IMPL
         DC    XL2'2100',XL1'00'
*
KEYWDL05 DC    AL1(10)                 NUMBER OF ENTRIES
         IEXCGEN DC,'BEGIN'            BEGIN
         DC    XL2'0000',XL1'24'
         IEXCGEN DC,'UNTIL'            UNTIL
         DC    XL2'1A00',XL1'00'
KWARRAY  IEXCGEN DC,'ARRAY'            ARRAY
         DC    XL2'CA16',XL1'28'
         IEXCGEN DC,'VALUE'            VALUE
         DC    XL2'0000',XL1'2C'
         IEXCGEN DC,'LABEL'            LABEL
         DC    XL2'CA18',XL1'30'
         IEXCGEN DC,'WHILE'            WHILE
         DC    XL2'1B00',XL1'00'
         IEXCGEN DC,'FALSE'            FLASE
         DC    XL2'0000',XL1'1C'
         IEXCGEN DC,'POWER'            POWER
         DC    XL2'0500',XL1'00'
         IEXCGEN DC,'EQUAL'            EQUAL
         DC    XL2'1000',XL1'00'
         IEXCGEN DC,'EQUIV'            EQUIV
         DC    XL2'2400',XL1'00'
*
KEYWDL06 DC    AL1(2)                  NUMBER OF ENTRIES
         IEXCGEN DC,'SWITCH'           SWITCH
         DC    XL2'CA1C',XL1'34'
         IEXCGEN DC,'STRING'           STRING
         DC    XL2'CB10',XL1'30'
*
KEYWDL07 DC    AL1(5)
         IEXCGEN DC,'INTEGER'          INTEGER
         DC    XL2'C211',XL1'18'
         IEXCGEN DC,'BOOLEAN'          BOOLEAN
         DC    XL2'C213',XL1'18'
         IEXCGEN DC,'COMMENT'          COMMENT
         DC    XL2'0000',XL1'38'
         IEXCGEN DC,'NOTLESS'          NOTLESS
         DC    XL2'1500',XL1'00'
         IEXCGEN DC,'GREATER'          GREATER
         DC    XL2'1200',XL1'00'
*
KEYWDL08 DC    AL1(1)                  NUMBER OF ENTRIES
         IEXCGEN DC,'NOTEQUAL'         NOTEQUAL
         DC    XL2'1300',XL1'00'
*
KEYWDL09 DC    AL1(1)                  NUMBER OF ENTRIES
KWPROC   IEXCGEN DC,'PROCEDURE'        PROCEDURE
         DC    XL2'CAD0',XL1'3C'
*
KEYWDL10 DC    AL1(1)                  NUMBER OF ENTRIES
         IEXCGEN DC,'NOTGREATER'       NOTGREATER
         DC    XL2'1400',XL1'00'
*
*        DELPRGTB
*
*        BRANCH ADDR TABLE USED AFTER A KEYWORD HAS BEEN FOUND
*
DELPRGTB DC    A(NORMAL)               +00
         DC    A(STRING)               +04
         DC    A(TED)                  +08
         DC    A(GIF)                  +12
         DC    A(END)                  +16
         DC    A(FOR)                  +20
         DC    A(TYPE)                 +24
         DC    A(BOLCON)               +28
         DC    A(CODE)                 +32
         DC    A(BEGIN)                +36
         DC    A(ARRAY)                +40
         DC    A(VALUE)                +44
         DC    A(SPEC)                 +48
         DC    A(SWITCH)               +52
         DC    A(COM)                  +56
         DC    A(PROCEDUR)             +60
         DC    A(TYPEARRY)             +64
         DC    A(TYPPROC)              +68
*
*        COMTABLE
*
*        USED BY COMMENT PROGRAM
*        TESTS FOR SEMICOLON, PERIOD, QUOTE AND ZETA
*        GIVES DISPLACEMENT TO PROGRAMS FROM COMCEE2+2
*
COMTABLE DC    XL96'00'
         ORG   COMTABLE+XFSCOLON
         DC    AL1(42)                 COMCEE2+2+42
         ORG   COMTABLE+XFPERIOD
         DC    AL1(34)                 COMCEE2+2+34
         ORG   COMTABLE+XFQUOTE
         DC    AL1(14)                 COMCEE2+2+14
         ORG   COMTABLE+XFZETA
         DC    AL1(30)                 COMCEE2+2+30
         ORG   ,
*
*        STRTABLE
*
*        USED BY STRING PROGRAM
*        SCANS FOR QUOTE OR ZETA
*        PROVIDES DISPLACEMENTS TO BPRTAB
*
STRTABLE DC    XL96'00'
         ORG   STRTABLE+XFQUOTE
         DC    AL1(140)
         ORG   STRTABLE+XFZETA
         DC    AL1(56)
         ORG   ,
*
*        KEYTAB
*
*        USED BY TRANSOP
*        BYTE 3 IS EXPECTED BYTE, IF THAT ONE MATCHES CHAR IN
*        INPUT BYTE 1 IS PUT OUT OTHERWISE BYTE 2
*        THE DISPLACEMENT FROM TESTTABL OR ATABLE IS USED TO GET
*        THE APPROPRIATE ENTRY IN KEYTAB
*        USED WHEN -
*                   FOUND                    EXPECTED
*                   *                        *
*                   /                        )
*                   (                        /
*                   <                        =
*                   >                        =
*                   ¬                        =
*
KEYTAB   DC    X'00000000'                                  +00
         DC    X'00',AL1(XFPOWER),AL1(XFASTER),AL1(XFASTER) +04 XFASTER
         DC    X'00',AL1(XFRSQBR),AL1(XFSLASH),AL1(XFRBRAC) +08 XFSLASH
         DC    X'00',AL1(XFLSQBR),AL1(XFLBRAC),AL1(XFSLASH) +12 XFLBRAC
         DC    X'00',AL1(20),AL1(XFLT),AL1(XFEQUAL)         +16 XFLT
         DC    X'00',AL1(21),AL1(XFGT),AL1(XFEQUAL)         +20 XFGT
         DC    X'00',AL1(19),AL1(XFNOT),AL1(XFEQUAL)        +24 XFNOT
*
*        TREXTINT
*
*        USED IN CIB TO TRANSLATE FROM EBCDIC TO INTERNAL CODE
*
TREXTINT DC    256AL1(XFEND)
         ORG   TREXTINT+C' '
         DC    AL1(XFBLANK)
         ORG   TREXTINT+C'.'
         DC    AL1(XFPERIOD),AL1(XFLT),AL1(XFLBRAC),AL1(XFPLUS)
         DC    AL1(XFOR),AL1(XFAMPER)
         ORG   TREXTINT+C'$'
         DC    AL1(XFDOLLAR)
         ORG   TREXTINT+C'*'
         DC    AL1(XFASTER),AL1(XFRBRAC),AL1(XFSCOLON),AL1(XFNOT)
         DC    AL1(XFMINUS),AL1(XFSLASH)
         ORG   TREXTINT+C','
         DC    AL1(XFCOMMA)
         ORG   TREXTINT+C'_'
         DC    AL1(XFUNDER)
         ORG   TREXTINT+C'>'
         DC    AL1(XFGT)
         ORG   TREXTINT+C':'
         DC    AL1(XFCOLON)
         ORG   TREXTINT+C'#'
         DC    AL1(XFHASH),AL1(XFAT)
         ORG   TREXTINT+C''''
         DC    AL1(XFQUOTE),AL1(XFEQUAL)
         ORG   TREXTINT+X'81'          LOWER CASE A
         DC    AL1(XFA),AL1(XFB),AL1(XFC),AL1(XFD),AL1(XFE),AL1(XFF)
         DC    AL1(XFG),AL1(XFH),AL1(XFI)
         ORG   TREXTINT+X'91'          LOWER CASE J
         DC    AL1(XFJ),AL1(XFK),AL1(XFL),AL1(XFM),AL1(XFN),AL1(XFO)
         DC    AL1(XFP),AL1(XFQ),AL1(XFR)
         ORG   TREXTINT+X'A2'          LOWER CASE S
         DC    AL1(XFS),AL1(XFT),AL1(XFU),AL1(XFV),AL1(XFW),AL1(XFX)
         DC    AL1(XFY),AL1(XFZ)
         ORG   TREXTINT+C'Ý'
         DC    AL1(XFLSQBR)
         ORG   TREXTINT+C'¨'
         DC    AL1(XFRSQBR)
         ORG   TREXTINT+C'A'
         DC    AL1(XFA),AL1(XFB),AL1(XFC),AL1(XFD),AL1(XFE),AL1(XFF)
         DC    AL1(XFG),AL1(XFH),AL1(XFI)
         ORG   TREXTINT+C'J'
         DC    AL1(XFJ),AL1(XFK),AL1(XFL),AL1(XFM),AL1(XFN),AL1(XFO)
         DC    AL1(XFP),AL1(XFQ),AL1(XFR)
         ORG   TREXTINT+C'S'
         DC    AL1(XFS),AL1(XFT),AL1(XFU),AL1(XFV),AL1(XFW),AL1(XFX)
         DC    AL1(XFY),AL1(XFZ)
         ORG   TREXTINT+C'0'
         DC    AL1(XF0),AL1(XF1),AL1(XF2),AL1(XF3),AL1(XF4),AL1(XF5)
         DC    AL1(XF6),AL1(XF7),AL1(XF8),AL1(XF9)
         ORG   ,                       RESTORE LOCATION COUNTER
*
*        KFCONST
*
*        KEEPS THE CONSTANTS 0 THROUGH 15
*        THE CONSTANTS ARE USED WITHIN SCAN 1/2 FOR CALCULATION
*        AND ARE THEN INSERTED AS THE FIRST 64 BYTES OF THE
*        CONSTANT POOL
*
KFCONST  DC    0F'0'
KF0      DC    F'0'                    +00
KF1      DC    F'1'                    +04
KF2      DC    F'2'                    +08
KF3      DC    F'3'                    +12
KF4      DC    F'4'                    +16
KF5      DC    F'5'                    +20
KF6      DC    F'6'                    +24
KF7      DC    F'7'                    +28
KF8      DC    F'8'                    +32
KF9      DC    F'9'                    +36
KF10     DC    F'10'                   +40
KF11     DC    F'11'                   +44
KF12     DC    F'12'                   +48
KF13     DC    F'13'                   +52
KF14     DC    F'14'                   +56
KF15     DC    F'15'                   +60
*
*        VARIABLES AND CONSTANTS
*
KF25000  DC    F'25000'
KF2000   DC    F'2000'
KF4095   DC    F'4095'
KH4096   DC    H'4096'
DOUBLE   DC    D'0'
KF256    DC    F'256'
INT      DC    X'2EC8030000'           COMMON PART OF THE INTERNAL
*                                      NAMES OF BOOLEAN CONSTANTS
ENDCOUNT DC    H'0'
ERRSAVE  DC    4F'0'
*
ESDNAME  DC    CL8'PROGRAM'
KP1      DC    PL1'1'                  CARD COUNT INCREMENT
*
HEAD1    DC    C'SOURCE PROGRAM'
HEAD2    DC    C'SC     SOURCE STATEMENT'
*
OPINCHAR DC    C'0'
BRACKET  DC    F'0'                    BRACKET COUNTER
ESDCON   DC    X'00000040404040'       ESD CONSTANT 7 BYTES
SCPATTN  DC    XL6'402020202020'       SEMICOLON EDIT PATTERN
*
SAVE1    DC    7F'0'
SAVEPRNT DC    CL88' '
SCOVFL   DC    F'65535'                (2**16)-1
*
         LTORG
*
WORKAREA DSECT
*
         COPY  WORKAREA                COMMON WORKAREA
*
C        DS    H                  PARENTHESIS COUNT
KB       DS    H                  HOLDS ID FIELD FOR SPECIFICATIONS
POOLLEN  DS    F                  LENGTH OF AREA GOTTEN FROM GETMAIN
POOLLOC  DS    F                  START LOC OF AREA FROM GETMAIN
AITABBUF DS    F                  ADDR OF ITAB BUFFER
ELI      DS    F                  ADDR OF ONE LOC  BEYOND ITAB AREA
ADDARI   DS    A                  ADDR OF FIRST O/P BUFFER
         DS    A                  ADDR OF SECOND O/P BUFFER
DISP     DS    C                  DISPLACEMENT TO ADDARI
D        DS    C                  DIMENSION COUNTER
SP       DS    F                  CURRENT STACK POINTER
APE      DS    F                  LAST AVAILABLE BYTE IN CURRENT O/P
WASAVE   DS    CL12
WABEFOR  DS    CL7
WA       DS    CL80               READIN AREA FOR SYSIN SOURCE RECORDS
APRNTAR  DS    A                  ADDR OF CURRENT PRINT BUFFER
ATOPSTAK DS    A                  LAST BYTE IN THE STACK
IGC      DS    H                  ITAB GROUP COUNTER
AGT      DS    A                  ADDR OF GROUPE TAB -3
AKOPOOL  DS    A                  ADDR OF THE CONSTANT POOL (0)
LAPIN    DS    A                  ADDR OF LAST POSSIBLE LABEL START
DIM      DS    A                  ADDR FOR DIMENSION IN ITAB NAME
PRIMPAR  DS    A                  ADDR OF FIRST SPECIFICATION
AITAB    DS    A                  START ADDR OF ITAB
AITL     DS    A                  CURRENT ITAB ENTRY ADDR
LIGP     DS    A                  POINTER TO CURRENT IG HEAD ENTRY
LPBP     DS    A                  POINTER TO CURRENT PBHEADING
WADDARI  DS    A                  CURRENT O/P BUFFER ADD
ITABLEN  DS    F                  ITAB LENGTH
MGESITL  DS    F                  ACCUMULATED ITAB LENGTH
BCHAR    DS    C                  SAVE CHAR
FBYTE    DS    CL1                SWITCH BYTE FOR APOSTROPHE
FSN      DS    C                  FOR STATEMENT COUNTER
ZFSNMAX  DS    C
PBC      DS    C                  PROGRAM BLOCK COUNTER
ONC      DS    C                  O/P REC COUNTER
N        DS    C                  NUMBER OF ARRAYS WITH SAME DIM
OPIN     DS    A                  POINTS TO LAST LABEL OPERATER
         DS    C                  O/P REC NO WHEN OPIN WAS SET
PZ       DS    C                  COUNTS NUMBER OF PARMETERS
BITS1    DS    C                  INTERNAL SWITCHES
BEGBIT   EQU   X'80'              BLOCK BEGIN
BEGOFF   EQU   X'7F'
PROBIT   EQU   X'40'              PROCEDURE HEAD PROCESSING
DELTABIT EQU   X'20'              SEMICOLON FOUND AFTER DECLARATION
IDBIT    EQU   X'10'              PROCEDURE NAME
ARBIT    EQU   X'08'              ARRAY PROCESSED
LISTBIT  EQU   X'04'              COMMA FOUND AFTER ARRAY NAME
TERBIT   EQU   X'01'              RETURN TO TERM AFTER PBLCKEND
BITS2    DS    C
ENDBIT   EQU   X'80'              LOGICAL END HAS BEEN FOUND
COBIT    EQU   X'40'              COMMENT
STARTBIT EQU   X'20'              ZERO UNTIL FIRST BEGIN FOUND
VALBIT   EQU   X'10'              VALUE
PB0BIT   EQU   X'08'              WRITE PB0 FOR PRE COMP PROC
FRSTPUT  EQU   X'02'              FIRST PUT IN GENERATE
ENDELSE  EQU   X'01'              END MAY CLOSE FOR OR PROC**
BITS3    DS    C
E11BIT   EQU   X'80'              E11 HAS BEEN GENERATED ONCE
FMBIT    EQU   X'40'              FORMAL PARAMETER BIT
FMOFF    EQU   X'BF'
NOFREE   EQU   X'20'              INTERUPT BEFORE GETMAIN
FRSITB   EQU   X'10'              FIRST ITAB REC IS WRITTEN
PROCESD  EQU   X'08'              WRITE SED CARD FOR PRE COMP PROC
PROCOFF  EQU   X'F7'
*
*        CHARACTER EQUATES
*
         IEXCHAR
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END   IEX11000
./ ADD NAME=IEX20    0201-12230-12230-1200-00775-00775-00000-LEVEL
X20      TITLE 'IEX20 - ITAB MANIPULATION, ALGOL F'
*
*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER
*
*        FUNCTION/OPERATION -
*        EACH ITAB BLOCK IS SCANNED FOR DUPLICATE IDENTIFIERS
*        RELATIVE DISPLACEMENTS IN DSA IS ALLOCATED FOR ALL
*        IDENTIFIERS, EXCEPT PROCEDURES, LABELS AND SWITCHES
*        THE ITAB BLOCKS ARE WRITTEN IN PROGRAM BLOCK NUMBER
*        ORDER TO SYSUT3
*        THE ITAB BLOCKS ARE PRINTED ON SYSPRINT IN PROGRAM
*        BLOCK NUMBER ORDER AND WITH THE IDENTIFIERS IN
*        ALPHABETIC FORM WITHIN EACH BLOCK, IF THE OPTION
*        SOURCE IS SPECIFIED
*        CREATES PBTAB2
*
*        ENTRY POINT -
*        IEX20000 ITAB MANIPULATION - XCTL EP=IEX20
*
*        INPUT - THE ITAB BLOCKS ARE READ IN FROM SYSUT3
*
*        OUTPUT -
*        THE ITAB BLOCKS ARE WRITTEN TO SYSUT3 AND PRINTED ON
*        SYSPRINT IF THE OPTION SOURCE IS SPECIFIED
*
*        EXTERNAL ROUTINES - THE PRINT ROUTINE IN IEX00 IS USED
*
*        EXITS - NORMAL -
*        CONTROL IS GIVEN TO IEX21 XCTL EP=IEX21
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORKAREA -
*        ATAB     - ADDR IS OF THE ITAB RECORDS IN PROGRAM BLOCK
*                   NUMBER ORDER
*        TRINTEXT - TRANSLATION OF INTERNAL CHARACTERS TO EBCDIC
*                   CHARACTERS
*        TAB      - PRINTING OF HEXADECIMAL DIGITS
*        WORK     - BUILDING THE PRINT ENTRIES
*
*        NOTES -
*        CHARACTER CODE DEPENDENCE
*        THE OUTPUT ON SYSPRINT -
*        THE IDENTIFIER NAME IS TRANSLATED BY MEANS OF TRINTEXT,
*        WHICH IS A CHARACTER TABLE
*        THE HEXADECIMAL PART IS TRANSLATED BY MEANS OF TAB
*        THE REMAINING PARTS DEPEND ON THE INTERNAL
*        REPRESENTATION OF THE EXTERNAL CHARACTER SET WHICH IS
*        EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME
*        THE OPERATION OF THE OTHER PARTS OF THE PHASE DOES NOT
*        DEPEND UPON A PARTICULAR INTERNAL REPRESENTATION OF THE
*        EXTERNAL CHARACTER SET
*
IEX20000 CSECT
*
*        R1                       PBN
*        R2                       CALCULATIONS
*        R3                       PARAMETER FOR CONVERT ROUTINE
*        R3                       DOUBLE WORD POINTER
*        R4                       WORD POINTER
*        R5                       KEEPS TRACK OF WHEN TO PRINT
*        R5                       HALF WORD POINTER
*        R6                       BYTE POINTER
*        R7                       CURRENT IDENTIFIER
*        R8                       CURRENT BLOCKHEAD
*        R9                       SCANS FOR DUPLICATES
*        R10                      ARRAY STORAGE ALLOCATIONS
*        R11                      BASE REGISTER
*        R12                      RETURN FROM CONVERT, PRINT ROUTINE
*        R14                      PBN DURING PRINTING
*        R15
*
*        INITIALIZATION
*
*        GETMAIN FOR ITAB AND ATAB
*        FIRST ENTRY IN ATAB IS MADE ZERO IF NO PBN 0
*        PRINTING OF HEADING LINES IS INITIALIZED IF SOURCE SPECIFIED
*        FPLEN IS MADE 4 IF SHORT SPECIFIED OTHERWISE IT REMAINS 8
*
         IEXENTRY 'IEX20000 LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IEX20000,R11
         LR    R11,R15
         USING WORKAREA,R13
         LA    R15,SLUT2               INTERUPT BEFORE GETMAIN
         ST    R15,ERET
         L     R1,ITAB20S              ITAB
         LA    R1,1024(,R1)            ATAB
         LR    R0,R1
*
         GETMAIN R,LV=(0)              GET ITAB ATAB AREAS
*
         LA    R15,SLUT
         ST    R15,ERET                INTERRUPT ADDR AFTER GETMAIN
         ST    R1,AREALOC
         ST    R1,AITAB                ITAB START LOCATION
         A     R1,ITAB20S
         ST    R1,ATABAD               ATAB START LOCATION
         SR    R2,R2                   ZERO REG FOR INIT VALUES
         ST    R2,KF0
         ST    R2,SAVEPB
         TM    COMPFLGS,PROC           A PB0 ?
         BO    INITIAL                 YES, BRANCH
         LA    R15,1                   NO, PROGRAM BLK 1 IS FIRST BLOCK
         ST    R15,SAVEPB
INITIAL  ST    R2,0(,R1)
         ST    R2,SAVE                 INITIALIZE WITH ZEROS
         MVC   SAVE1(16),SAVE
         STC   R2,BITS1                INITIALIZE SWITCHES
         LA    R10,PBTAB2
         ST    R10,APBTAB2             START ADDR OF PBTAB2
         TM    COMPFLGS+1,NSRCE        SOURCE SPECIFIED ?
         BO    INITIALA                NO
         MVI   LINCNT+1,255            FORCE HEADINGS TO BE PRINTED
         MVI   PAGEHD1C+1,C' '         BLANK FIRST HEADING LINE
         MVC   PAGEHD1C+2(109),PAGEHD1C+1
         MVC   PAGEHD2D(L'PAGEHD2D),PAGEHD1D  BLANK 2ND HEADING LINE
         MVC   PAGEHD3D(L'PAGEHD3D),PAGEHD1D  BLANK 3RD HEADING LINE
         MVC   PAGEHD1D+39(L'HEAD1),HEAD1
         MVC   PAGEHD2D(L'HEAD2),HEAD2
         MVC   PAGEHD3D(L'HEAD3),HEAD3
         BAL   R12,PRINTITB            INITIALIZE PRINTING FOR ITAB
INITIALA SR    R1,R1
         TM    COMPFLGS,LNG            LONG OR SHORT PRECISION
         BO    READBLK                 LONG, BRANCH
         MVI   FPLEN+1,4               SET SHORT FPLEN=4
*
*        SCAN FOR DUPLICATES
*
*        READS IN A NEW BLOCK
*        START ADDR IN R8 END ADDR IN AITAB
*        COMPARES EACH IDENTIFIER WITH ALL IDENTIFIERS FOLLOWING
*        IT IN THE BLOCK
*        IF TWO EQUAL FOUND AND IF NOT FIRST ONE IS A FORMAL
*        PARAMETER AND SECOND NOT E45 IS GENERATED
*        WHEN ALL IDENTIFIERS IN THE BLOCK HAVE BEEN CHECK THE
*        EXIT IS TO ALLOSTUR
*
READBLK  L     R12,AITAB               START ADDR OF NEW BLOCK
         L     R2,AUT3DCB              R2 -> SYSUT3 DCB
*
*        READ IN NEW BLOCK
*
         READ  UT3DECB,SF,(R2),(R12),'S'
*
         CHECK UT3DECB
*
         SR    R2,R2
         IC    R2,10(,R12)             GET NEW PBN
         SLA   R2,2
         L     R7,ATABAD
         ST    R12,0(R2,R7)            SAVE ADDR OF BLOCK IN ATAB
         LR    R8,R12
         MVC   LENCOUNT,0(R12)         GET LENTH OF BLOCK
         AH    R12,LENCOUNT
         ST    R12,AITAB               SAVE END ADDR OF BLOCK
         LR    R7,R8
         TM    8(R8),X'80'             BLOCK TYPE PROC ?
         BZ    SCANNXT                 NO
         LA    R7,22(,R8)              YES, SKIP CHECKING AGAINST
         B     SCANNXTA                TYPE PROCEDURE NAME
*
SCANNXT  LA    R7,11(,R7)
SCANNXTA C     R7,AITAB                ALL IDENTIFIERS CHECKED ?
         BE    ALLOSTOR                YES, GO TO ALLOCATE STORAGE
         CLI   5(R7),X'2B'             FOR HEAD OR CONT ENTRY ?
         BE    SCANNXT                 YES, SKIP CHECKING
         CLI   0(R7),0                 INVALID PROCEDURE NAME ?
         BE    SCANNXT                 YES, SKIP CHECKING
         LR    R9,R7
CHECKNXT LA    R9,11(,R9)
         C     R9,AITAB                ALL IDENT CHECKED AGAINST
         BE    SCANNXT                 THE ONE PROCESSED ?
         CLI   5(R9),X'2B'             FOR HEAD OR CONT ENTRY ?
         BE    CHECKNXT
         CLC   0(6,R9),0(R7)           COMPARE EACH IDENTIFIER AGAINST
*                                      ALL FOLLOWING INDENTIFIERS
*                                      IN THE BLOCK
         BNE   CHECKNXT
         TM    7(R7),X'30'             TWO EQUAL FOUND. PROCESSED
         BM    CHECKNAA                ONE FORMAL PARAMETER ?
         B     E43                     NO
*
CHECKNAA TM    7(R9),X'30'             COMPARED ONE IS FORMAL PARAM
         BM    E43                     YES
         B     CHECKNXT                NO
*
*        ALLOSTOR
*
*        ALLOCATES STORAGE FOR THE IDENTIFIERS
*        FOR A TYPE PROC BLOCK ALLOCATION STARTS AT 32 OTHERWISE
*        AT 24.
*        NO BLOCK MAY GET MORE THAN 4K ALLOCATED.
*        IT IS ALSO CHECKED THAT THERE IS NO PROC, STRING OR
*        SWITCH CALLED BY VALUE.
*        WHEN ALL DECLARATIONS IN THE BLOCK ARE PROCESSED R3-FPLEN
*        WILL BE PUT IN PBTAB2.
*        IF THERE ARE MORE BLOCKS TO BE PROCESSED THE EXIT IS TO
*        IDENTIFIER SCAN OTHERWISE TO WRITE ITAB.
*        FOUR POINTERS ARE USED -
*        R3 DOUBLE WORD POINTER
*        R4 WORD
*        R5 HALF WORD R6 BOOLEAN
*        R3 IS INCREASED BY FPLEN WHICH IS 8 FOR LONG, 4 FOR SHORT.
*        FOR LONG PRECISION ALL 4 POINTERS ARE USED
*        FOR SHORT R4 IS NEVER USED, WILL CONTAIN 0 ALL THE
*        TIME
*        REAL WILL BE ALLOCATED TO R3, 4 OR 8 BYTES.
*        INTEGER WILL GET R3 OR R4. R3 ALWAYS IF SHORT R4 IF
*        LONG AND R4 NOT ZERO.
*        OTHERWISE R3, IN WHICH CASE R4 WILL EQUAL R3+4 FOR THE
*        NEXT INTEGER.
*        BOOLEAN WILL GET R3, R4, R5 OR R6 IF LONG R3, R5 OR R6
*        IF SHORT.
*        FIRST BOOLEAN FOUND WILL GET EITHER R4 OR R3.
*        R5 IS THEN INITILIZED TO R4+2 OR R3+2
*        R6                       R4+1    R3+1
*        SECOND BOOLEND WILL GET THE VALUE OF R6 AND R6 WILL BE 0.
*        THIRD BOOLEAN WILL GET R5 AND R5 WILL BE 0 R6=R5+1.
*        FORTH BOOLEAN WILL GET R6 AND R6 WILL BE 0.
*        THIS WILL THEN BE REPEATED FOR EVERY FOUR BOOLEAN
*        IDENTIFIERS. ALL FORMAL PARAMETERS WILL GET THE R3 VALUE
*        AND R3 WILL BE INCREASED BY 8.
*        ARRAYS WILL GET R3 VALUE AND R3 WILL BE INCREASED BY
*        4(DIM+6)+X WHERE X IS 4 WHEN LONG PRECISION AND DIM IS
*        AN UNEVEN NUMBER, OTHERWISE X IS 0.
*        LABEL, SWITCH , PROCEDURE WILL NOT GET ANYTHING
*        EX. OF STORAGE ALLOCATION
*        LONG           SHORT
*        01234567       01234567  FP   FORMAL PARAMETER
*        FP             FP        R    REAL
*        FP             FP        INT  INTEGER
*        R              R   INT   B    BOOLEAN
*        INT INT        INT INT   NU   NOT USED SPACE
*        INT BBB        BBB R
*        R              INT R
*        INT NU
*        R
*
ALLOSTOR TM    8(R8),X'80'             THE BLOCK A TYPE PROCEDURE ?
         BZ    ALLOSTAA                NO
         LA    R3,32                   YES, SET DOUBLE WORD POINTER
         NI    8(R8),X'7F'             CLEAR TYPE PROCEDURE INDICATION
         B     STARTALL
*
ALLOSTAA LA    R3,24                   SET DOUBLE WORD POINTER
STARTALL SR    R4,R4                   SET ALL POINTERS TO ZERO
         SR    R5,R5
         SR    R6,R6
         LR    R7,R8                   GET FIRST VARIABLE
         B     GETNEXT
*
STORALLO AH    R3,FPLEN                INCREASE ALLOCATION POINTER
STORALLA C     R3,KF4095               HAS 4K BEEN ALLOCATED ALREADY ?
         BH    E44
GETNEXT  LA    R7,11(,R7)              GET NEXT VARIABLE
         STM   R3,R6,DPC               STORE ALL POINTERS
         C     R7,AITAB                ALL VARIABLES TAKEN CARE OF ?
         BE    LASTREC                 YES
         CLI   5(R7),X'2B'             FOR HEADING OR CONTINUATION ?
         BE    GETNEXT
         CLI   6(R7),X'91'             ALL PURPOSE IDENTIFIER ?
         BE    GETNEXT
         TM    7(R7),X'30'             FORMPARAM, DEK VAR OR CONST?
         BM    FORMPARM
         BZ    CONST
         TM    7(R7),X'03'             BOOLEAN VARIABLE ?
         BO    BOOLEAN
         TM    COMPFLGS,LNG            SHORT PRECISION ?
         BZ    REAL                    YES, ALLOCATE SAME FOR REAL AND
*                                      INTEGER
         TM    7(R7),X'01'             INTEGER OR REAL ?
         BO    INTEGER
REAL     MVC   9(2,R7),DPC+2           MOVE IN DISPLACEMENT
         B     STORALLO
*
INTEGER  LTR   R4,R4                   EMPTY HOLE LEFT FOR INTEGER ?
         BZ    INTEGERA                NO
         MVC   9(2,R7),WPC+2           YES, FILL THE HOLE AND MAKE
         LA    R4,0                    WORD POINTER= 0
         B     GETNEXT
*
INTEGERA MVC   9(2,R7),DPC+2           MOVE IN DOUBLEWORD PTR AND MAKE
         LA    R4,4(,R3)               WORDPTR POINT TD EMPTY HOLE NEXT
         B     STORALLO                TO IT
*
BOOLEAN  LTR   R6,R6                   SPACE LEFT NEXT TO PREV BOOL ?
         BZ    BOOLEANA                NO
         MVC   9(2,R7),BPC+2           YES, MOVE IN DISPLACEMENT
         SR    R6,R6                   MAKE BYTE POINTER 0
         B     GETNEXT
*
BOOLEANA LTR   R5,R5                   SPACE LEFT NEXT TO 2 PREV BOOL ?
         BZ    TESTWPA                 NO
         MVC   9(2,R7),HPC+2           YES, MOVE IN DISPLACEMENT
         LA    R6,1(,R5)               MAKE BYTE POINTER POINT TO NEXT
         SR    R5,R5                   HALFWORD POINTER 0
         B     GETNEXT                 FREE BYTE
*
TESTWPA  TM    COMPFLGS,LNG            SHORT PRECISION ?
         BZ    TAKEDP                  YES, DO NOT USE R4 POINTER
TESTWP   LTR   R4,R4                   R4 POINTER FREE ?
         BZ    TAKEDP                  NO, TAKE R3 POINTER INSTEAD
         MVC   9(2,R7),WPC+2           YES, USE R4 AS DISPLACEMENT
         LA    R6,1(,R4)               SET R5 AND R6
         LA    R5,2(,R4)               TO FREE BYTES IN WORD
         SR    R4,R4                   SET R4 TO ZERO
         B     GETNEXT
*
TAKEDP   MVC   9(2,R7),DPC+2           USE R3 AS DISPLACEMENT
         LA    R6,1(,R3)               SET R4, R5, R6 TO FREE BYTES
         LA    R5,2(,R3)               WITHIN THE DOUBLE WORD
         LA    R4,4(,R3)
         B     STORALLO
*
CONST    TM    7(R7),X'04'             FOR LABEL, STRING, PROCEDURE
         BZ    GETNEXT
         TM    7(R7),X'08'             DO NOT ALLOCATE ANY STORAGE
         BO    GETNEXT
         SR    R10,R10
         IC    R10,9(R7)
         SRA   R10,4                   FOR AN ARRAY
         LA    R10,6(,R10)             STORAGE NEEDED IS 4(DIM+6)+X
         SLA   R10,2
         OC    9(2,R7),DPC+2           OR IN THE DISP TO SAVE DIMENSION
         TM    COMPFLGS,LNG            X IS 4 IF LONG PRECISION
         BZ    CONSTAA
         TM    9(R7),X'10'             DIM IS AN UNEVEN NUMBER
         BZ    CONSTAA                 INCREASE IF NEEDED TO GET
         LA    R10,4(,R10)             ON DOUBLE WORD BOUNDARY
CONSTAA  LA    R3,0(R10,R3)
         B     STORALLA
*
FORMPARM TM    7(R7),X'03'             TYPE PARAMETER ?
         BZ    NOTTYPE                 NO
FORMPALL MVC   9(2,R7),DPC+2           MOVE IN DISPLACEMENT
         LA    R3,8(,R3)
         B     STORALLA
*
NOTTYPE  TM    7(R7),X'10'             CALL BY NAME ?
         BO    FORMPALL                YES
         TM    7(R7),X'03'             NO, CHECK IF VALUE CALL CORRECT
         BZ    NOTTYPEA
         B     FORMPALL
*
NOTTYPEA CLI   7(R7),X'28'             LABEL CALLED BY VALUE ?
         BE    FORMPALL
         B     E45                     PROC SWITCH OR STRING
*                                      CALLED BY VALUE
LASTREC  SR    R2,R2                   CONSTRUCT ENTRY OF PBTAB2
         IC    R2,10(,R8)              GET PBN
         SLA   R2,1
         L     R14,APBTAB2
         LA    R14,0(R2,R14)
         SH    R3,FPLEN                GET LAST BYTE USED
         STH   R3,0(,R14)
         L     R1,SAVEPB
         CH    R1,PBN                  ALL ITAB REC WRITTEN OUT ?
         LA    R1,1(,R1)
         ST    R1,SAVEPB
         BNE   READBLK                 NO
*
*        WRITITAB
*
*        WRITES THE ITAB RECORD TO SYSUT3 IN PROGRAM BLOCK NUMBER
*        ORDER
*        THE ADDR TO WHERE THE BLOCK IS GOING TO BE WRITTEN
*        IS PICKED UP FROM ATAB
*        IN EACH BLOCK THE LENGTH OF THE NEXT BLOCK IS INSERTED
*
WRITITAB L     R12,ATABAD              START OF ADDR TABLE
         L     R10,AUT3DCB             R10 -> SYSUT3 DCB ADDR
*
         CLOSE ((R10),REREAD),TYPE=T   GET TO START OF SYSUT3
*
         SR    R2,R2
         TM    COMPFLGS,PROC           IS THERE A PB0 ?
         BZ    ITLP2                   NO
ITABLOOP L     R10,0(,R12)             GET ADDR OF BLOCK
         L     R7,AUT3DCB              DCB ADDR
         L     R5,4(,R12)              GET ADDR OF NEXT BLOCK
         CH    R2,PBN                  LAST BLOCK ?
         BE    ITABLOOA                YES
         MVC   2(2,R10),0(R5)          INSERT LENGTH OF NEXT BLOCK
ITABLOOA MVC   LENCOUNT,0(R10)         GET LENGTH OF CURRENT BLOCK
         LH    R15,LENCOUNT
*
         WRITE PRCH4,SF,(R7),(R10),(R15)
*
         CHECK PRCH4
*
ITLP2    LA    R12,4(,R12)             GET ADDR OF NEXT BLOCK
         CH    R2,PBN                  ALL ITAB REC WRITTEN OUT ?
         LA    R2,1(,R2)
         BNE   ITABLOOP                NO
         B     ITABPRNT                YES
*
*        E43
*
*        GENERATES ERROR MESSAGE 45
*        RETURNS TO SCANNING FOR DUPLICATES
*
E43      BAL   R15,ERRNAME
         MVI   1(R10),X'2D'            E45
         B     SCANNXT
*
*        E45
*
*        GENERATER ERROR MESSAGE 47
*        RETURNS TO FORMPALL AS IF VAR WAS CORRECT
*
E45      BAL   R15,ERRNAME
         MVI   1(R10),X'2F'            E47
         B     FORMPALL
*
*        E44
*
*        GENERATES ERROR MESSAGE 214
*        RETURNS TO LASTREC TO TAKE NEXT BLOCK, IF ANY
*
E44      L     R3,SAVEPB
         BAL   R12,CONVERT             CONVERT PBN
         L     R10,NEXTERR
         LA    R12,7(,R10)             SPACE LEFT IN ERROR POOL ?
         C     R12,ENDPOOL
         BH    E0
         ST    R12,NEXTERR
         MVI   0(R10),X'87'            MOVE LENGTH AND BLANK SC INDIC
         MVI   1(R12),X'D6'            E214
         MVC   4(3,R10),SAVE+1         PBN
         B     LASTREC
*
*        ERRNAME
*
*        FINDS THE LENGTH OF THE VARIABLE IN ERROR, CHECKS FOR
*        ERRPOOL OVERFLOW, MOVES IN THE NAME OF THE VAR AND
*        LENGTH OF MESSAGE
*        RETURNS TO CALLING PROGRAM, E43 OR E44
*
ERRNAME  LA    R12,5
ERRNAMEC STC   R12,ERRNAMEA+3          UPDATE NEXT INSTRUCTION
ERRNAMEA CLI   0(R7),0                 FIND LENGTH OF NAME
         BNE   ERRNAMEB
         BCT   R12,ERRNAMEC
ERRNAMEB L     R9,NEXTERR
         LA    R9,5(R12,R9)
         C     R9,ENDPOOL              CHECK SPACE IN ERRORPOOL
         BH    E0
         L     R10,NEXTERR
         ST    R9,NEXTERR
         EX    R12,MOVE                INSERT NAME IN ERROR PATTERN
         LA    R12,5(,R12)
         STC   R12,0(,R10)
         OI    0(R10),X'80'            BLANK SC INDICATOR
         BR    R15
*
E0       LA    R12,NEXTERR
         MVI   0(R12),X'02'
         MVI   1(R12),X'D4'            E212
         ST    R12,NEXTERR
         B     SLUT
*
MOVE     MVC   4(1,R10),0(R7)
*
*        ITABPRNT
*
*        PRINTS ON SYSPRINT, IF SOURCE SPECIFIED, ALL VARIABLES
*        THE BLOCKS IN PBN NUMBER ORDER AND WITH THE VAR SORTED
*        WITHIN EACH BLOCK
*        R5 KEEPS TRACK OF WHEN PRINTING IS NEEDED, THE
*        INFORMATION ABOUT EACH VAR IS BUILT UP IN WORK AND THEN
*        TRANSFERRED TO PRINTAREA. WHEN 3 VAR HAVE BEEN PLACED IN
*        THE PRINTAREA THE LINES IS PRINTED
*        THE ADDR TO THE BLOCK IS TAKEN FROM ATAB
*        THE LENGTH IS TAKEN FROM THE FIRST 2 BYTES IN THE BLOCK
*        THE SURROUNDING PBN FROM PBTAB1
*        THE STARTING SC COUNTER FOR THE BLOCK FROM BYTE 6 AND 7
*        IN THE BLOCK
*        IF THE BLOCK DOES NOT CONTAIN ANY VAR ONLY THE PBN AND
*        SURROUNDING PBN ARE PRINTED
*        ALL HEAD ENTRIES, FOR AND CONT LINES ARE SKIPPED
*        EACH NEW BLOCK IS PRECEEDED BY A BLANK LINE
*        START ADDR OF THE BLOCK IS IN R8
*        END ADDR OF THE BLOCK IS IN AITAB, THIS ADDR WILL BE
*        R8+11 WHEN ALL VAR PROCESSED
*
ITABPRNT TM    COMPFLGS+1,NSRCE        SOURCE SPECIFIED ?
         BO    SLUT                    NO
         SR    R14,R14                 CLEAR REG
         TM    COMPFLGS,PROC           THERE A PB0 ?
         BO    GETPBA                  YES, PROCESS PB0, R14=0
GETPB    LA    R14,1(,R14)             INCREASE PBN
GETPBA   LR    R12,R14
         SLA   R12,2
         L     R8,ATABAD               GET ADDR OF NEW BLOCK
         L     R8,0(R12,R8)            VIA ATAB + 4 TIMES PBN
         MVC   LENCOUNT,0(R8)          GET LENGTH OF THE BLOCK
         LH    R12,LENCOUNT
         LA    R12,0(R12,R8)           GET END OF BLOCK
         ST    R12,AITAB               STORE END OF IT
         BAL   R12,PRINTITB            PRINT A BLANK LINE
         LR    R3,R14                  CONVERT PBN
         BAL   R12,CONVERT
         MVC   0(3,R1),SAVE+1          NEW PBN
         IC    R3,PBTAB1(R14)          CONVERT SURROUNDING PBN
         BAL   R12,CONVERT
         MVC   10(3,R1),SAVE+1         SURROUNDING PBN
         MVC   SCSAVE(2),6(R8)         CONVERT SC COUNTER TO DECIMAL
         LH    R12,SCSAVE
         CVD   R12,DOUBLE              STARTING SC OF BLOCK IS INSERTED
         UNPK  4(5,R1),DOUBLE
         OI    8(R1),X'F0'
         CLC   LENCOUNT,KA11           EMPTY BLOCK ?
         BNE   ITABPRNX                NO
         BAL   R12,PRINTITB            FOR AN EMPTY BLOCK PRINT
         B     ENDBLOCK                ONLY THE BLOCK NUMBERS
*
ITABPRNX SR    R5,R5
*
*        GETNVAR
*
*        LOOPS THROUGH BLOCK TO GET THE CURRENT LOWEST VARIABLE
*        EXITS TO ENDBLOCK WHEN ALL VAR IN THE BLOCK HAVE BEEN
*        PROCESSED, OTHERWISE TO TESTVAR
*
GETNVAR  LA    R7,11(,R8)              GET FIRST VAR AFTER HEADING
         LR    R10,R7
         C     R7,AITAB                ALL VAR PROCESSED ?
         BE    ENDBLOCK                YES
         CLI   5(R7),X'2B'             HEAD OR CONTINUATION LINE ?
         BE    ENDVAR2
TESTNXT  LA    R10,11(,R10)            GET NEXT VAR
         C     R10,AITAB               ALL VAR COMPARED ?
         BE    TESTVAR
         CLI   5(R10),X'2B'            HEAD OR CONTINUATION LINE ?
         BE    TESTNXT                 YES, SKIP THAT LINE
         CLC   0(6,R7),0(R10)          COMPARE CURRENT LOWEST - NEW ?
         BL    TESTNXT                 CURRENT LOWEST STILL LOW
         LR    R7,R10                  NO, SHIFT R7 TO NEW
         B     TESTNXT
*
*        TESTVAR
*
*        CHECKS THE INTERNAL NAME TO FIND TYPE AND MOVES
*        CHARACTERISTICS TO WORKAREA
*
TESTVAR  TM    6(R7),X'91'             ALL PURPOSE IDENTIFIER ?
         BO    ENDVAR                  YES
         TM    7(R7),X'03'             TYPE ?
         BO    BOL                     TYPE=BOOLEAN
         BZ    BOLA                    NOT TYPE
         TM    7(R7),X'01'             INTEGER OR REAL ?
         BZ    TESTVARA
         MVI   WORK+7,C'I'             INTEGER
         B     BOLA
*
TESTVARA MVI   WORK+7,C'R'             REAL
         B     BOLA
*
BOL      MVI   WORK+7,C'B'             BOOLEAN
BOLA     TM    7(R7),X'0C'
         BZ    TESTPROC
         BO    SWITCH
         TM    7(R7),X'08'             ARRAY OR LABEL ?
         BZ    ARRAY
         MVI   WORK+8,C'L'             LABEL
TESTPROC TM    7(R7),X'C0'
         BO    PROCEDUR
         BZ    FORMAL
         TM    7(R7),X'40'
         BZ    FORMAL
         MVI   WORK+11,C'C'            CODE PROCEDURE
         B     PROCEDUR
*
FORMAL   TM    7(R7),X'30'             SPECIFIED IDENTIFIER ?
         BO    ENDVAR
         BZ    ENDVAR
FORMALC  NI    BITS1,PROCOFF           RESET PROCEDURE BIT
         TM    6(R7),X'01'
         BZ    FORMALA
         MVI   WORK+8,C'T'             STRING
FORMALA  TM    7(R7),X'10'             NAME OR VALUE CALL ?
         BZ    FORMALB
         MVI   WORK+10,C'N'            NAME
         B     ENDVAR
*
FORMALB  MVI   WORK+10,C'V'            VALUE
         B     ENDVAR
*
SWITCH   MVI   WORK+8,C'S'             SWITCH
         B     CONVERT2                CONVERT NUMBER OF COMPONENTS
*
PROCEDUR MVI   WORK+9,C'P'             PROCEDURE
         OI    BITS1,PROCBIT           SET PROCEDURE BIT
         B     CONVERT2                CONVERT NUM OF PARAMETERS
*
ARRAY    MVI   WORK+9,C'A'             ARRAY
*
*        CONVERT2
*
*        ENTERED FOR PROCEDURE, ARRAY AND SWITCH CONVERTS THE
*        NUMBER OF PARAMETERS, DIMENSIONS OR COMPONENTS TO
*        DECIMAL FORM AND PUTS IT IN WORK
*        FOR ARRAY OR SWITCH THE COUNTER IS FIRST INCREASED BY
*        ONE TO GET THE REAL VALUE.
*
CONVERT2 TM    7(R7),X'30'
         BM    FORMALC
         IC    R3,9(,R7)
         SRA   R3,4                    SWITCH OR PROCEDURE
         TM    BITS1,PROCBIT           TEST IF PROC PARAMETERS
         BO    *+8                     YES
         LA    R3,1(,R3)               NO, INCREASE DIM COUNTER
         NI    BITS1,PROCOFF           TO GIVE CORRECT VALUE
         BAL   R12,CONVERT             CONVERT IT TO DECIMAL
         MVC   WORK+13(2),SAVE+2       AND MOVE IT OUT
         B     FORMAL
*
*        CONVERT
*
*        CONVERTS FROM HEXADECIMAL TO DECIMAL
*        USED FOR LN, DISP AND PBN TO BE WRITEN OUT
*
CONVERT  CVD   R3,DOUBLE               CONVERT TO DECIMAL
         UNPK  SAVE(4),DOUBLE+5(3)     UNPACK
         OI    SAVE+3,X'F0'            MAKE PRINTABLE
         BR    R12                     RETURN
*
*        PRINTITB
*        PRINTS A LINE, SAVES NEW PRINTAREA ADDR, RESETS R5
*
PRINTITB STM   R14,R15,SAVE1
         L     R15,PRTRTADD            PRINT A RECORD
         BALR  R14,R15
         ST    R1,APRNTAR              SAVE ADDR OF NEXT PRINT AREA
         LM    R14,R15,SAVE1
         SR    R5,R5                   RESET R5
         BR    R12                     RETURN
*
*        ENDVAR
*
*        MOVES EXTERNAL NAME TO WORK, TRANSLATES IT
*        CONVERTS LN OR DISP AND MOVES THAT TO WORK
*        MOVES WORK TO CURRENT PRINTAREA WITH AN EXECUTE MVC
*        INCREASES R5 AND CHECKS IF ONE LINE HAS BEEN FILLED UP
*        IN THAT CASE - PRINTS THAT LINE
*        SHIFTS AWAY THE NOW PROCESSED VAR AND STORES THE NEW
*        ENDING ADDR OF THE BLOCK IN AITAB
*        RETURNS TO PROCESS NEXT VAR
*
ENDVAR   MVC   WORK(6),0(R7)           MOVE EXTERNAL NAME
         TR    WORK(6),TRINTEXT
         MVC   SAVE2(2),9(R7)          MOVE
         UNPK  SAVE3,SAVE2             CONVERT DISP OR LABEL NUMBER
         TR    SAVE3+1(3),TAB-240      TO BE WRITTEN OUT
         MVC   WORK+16(3),SAVE3+1
         EX    R0,MOVEVAR(R5)          MOVE OUT WORK TO PRINT AREA
         MVI   WORK,C' '               CLEAR WORK
         MVC   WORK+1(L'WORK-1),WORK
         LA    R5,8(,R5)
         C     R5,KF24                 TIME TO PRINT ?
         BNE   ENDVAR2                 NO
         BAL   R12,PRINTITB            YES, CALL FOR PRINT ROUTINE
ENDVAR2  L     R10,AITAB
         LA    R12,12(,R7)             LEN TO MOVE ITAB UP TO
         C     R12,AITAB               NOTHING TO MOVE ?
         BNH   ENDVAR3
         ST    R7,AITAB                STORE ADDR OF CURRENT AS ENDADDR
         B     GETNVAR
*
ENDVAR3  SR    R10,R12                 CALCULATE NEW END ADDR OF THE
         LA    R12,1(R10,R7)           BLOCK AND STORE IT IN AITAB
         ST    R12,AITAB
COMPARE  C     R10,KF256
         BNH   EX1
         MVC   0(256,R7),11(R7)        TRANSFER A 256 BYTE SECTION
         LA    R7,256(,R7)             OF THE BLOCK AT THE TIME
         S     R10,KF256
         B     COMPARE
*
EX1      EX    R10,MOVEITAB            MOVE LAST PARTIAL SECTION
         B     GETNVAR
*
*        ENDBLOCK
*
*        PRINTS LAST LINE OF BLOCK, IF NEEDED
*        EXITS TO GETPB IF ANY BLOCK LEFT TO BE PROCESSED
*        OTHERWISE A FREEMAIN IS DONE AND LINK TO IEX21
*
ENDBLOCK C     R5,KF0                  VAR LEFT TO BE WRITTEN OUT ?
         BE    *+8
         BAL   R12,PRINTITB
         LA    R12,1(,R14)
         CH    R12,PBN                 ALL BLOCKS PROCESSED ?
         BNH   GETPB                   NO, TAKE NEXT
SLUT     L     R1,ITAB20S              ITAB AREA
         LA    R1,1024(0,R1)           AND ATAB AREA ARE MADE
         LR    R0,R1                   FREEMAIN FOR
         L     R1,AREALOC
*
         FREEMAIN R,LV=(0),A=(1)
*
SLUT2    XCTL  EP=IEX21000
*
*        HEADING LINES
*
HEAD1    DC    C'IDENTIFIER TABLE'
*
HEAD2    DC    C'PBN SC    PBN      NAME   TYPE  DM DSP       NAME   TYX
               PE  DM DSP       NAME   TYPE  DM DSP'
*
HEAD3    DC    C'          SURR                  PR LN                 X
                   PR LN                     PR LN '
*
SCSAVE   DC    H'0'                    SAVE SEMICOLON COUNTER
KF256    DC    F'256'                  USED BY MOVE LOOP
SAVE2    DC    C'000'                  USED FOR CONVERSION
SAVE3    DC    XL5'00'
DOUBLE   DC    D'0'
MOVEITAB MVC   0(1,R7),11(R7)          USED BY ENDVAR
WORK     DC    CL30' '                 USED TO BUILD PRINT RECORD
KF4095   DC    F'4095'                 STORAGE ALLOCATION MAXIMUM
*
MOVEVAR  MVC   19(27,R1),WORK          USED TO SORT REC TO BE PRINTED
         CNOP  0,4
         MVC   45(27,R1),WORK
         CNOP  0,4
         MVC   71(19,R1),WORK
*
KF24     DC    F'24'                   USED BY ENDVAR
FPLEN    DC    H'8'                    4 = SHORT PREC, 8 = LONG PREC
*                                      INCREASE VALUE DURING
*                                      STORAGE ALLOCATION
*
*        TRANSLATE FOR INTERNAL TO EBCDIC CODE
*
TRINTEXT DS    0CL96
         DC    C' '
         DC    47C')'
         DC    C'0123456789'
         DC    6C')'
         DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ$_#@))'
*
*        FOR PRINTABLE HEXADECIMAL
*
TAB      DC    C'0123456789ABCDEF'
KA11     DC    AL2(11)
*
         LTORG
*
WORKAREA DSECT
         COPY  WORKAREA
KF0      DS    F                  ZERO CONSTANT
SAVE     DS    F
SAVE1    DS    4F
APBTAB2  DS    A                  START ADDR OF PBTAB2
ATABAD   DS    A                  START ADDR OF ATAB
DPC      DS    F                  SAVE AREAS FOR R3, R4, R5 AND R6
WPC      DS    F
HPC      DS    F
BPC      DS    F
AITAB    DS    F                  ITAB ADDR
APRNTAR  DS    A                  ADDR OF CURRENT PRINTAREA
AREALOC  DS    A                  ADDR OF GETMAIN POOL
SAVEPB   DS    F                  COUNTS NO OF BLOCKS READ
LENCOUNT DS    H                  SAVES LENGTH OF BLOCK
BITS1    DS    C
PROCBIT  EQU   X'02'              PROCEDURE IS PROCESSED
PROCOFF  EQU   X'FD'
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END   IEX20000
./ ADD NAME=IEX21    0201-12230-12230-1200-00114-00114-00000-LEVEL
X21      TITLE 'IEX21 - ERROR MESSAGE EDITING, ALGOL F'
*
*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER
*
*        FUNCTION/OPERATION -
*        THE ERROR PATTERNS GENERATED DURING SCANI/II AND ITAB
*        MANIPULATION ARE HANDLED AND THE CORRESPONDING
*        DIAGNOSTIC MESSAGES ARE GENERATED
*
*        ENTRY POINT -
*        IEX21000 - ERROR MESSAGE EDITING XCTL EP=IEX21
*        THE MODULE IS ENTERED FROM IEX20
*
*        INPUT - N/A
*
*        OUTPUT -
*        THE DIAGNOSTIC MESSAGES ARE PUT OUT ON SYSPRINT
*        IF SYSPRINT IS NOT AVAILABLE A WTO IS ISSUED
*
*        EXTERNAL ROUTINE -
*        THE PRINT ROUTINE IN IEX00 IS USED
*
*        EXIT - NORMAL -
*        IF NO TERMINATING ERROR HAS OCCURRED, CONTROL IS GIVEN
*        TO THE NEXT PHASE BY MEANS OF XCTL EP=IEX30000
*
*        EXIT - ERROR -
*        IF A TERMINATING ERROR HAS OCCURRED (IN THIS MODULE OR
*        ONE OF THE PRECEDING) CONTROL IS GIVEN TO THE
*        TERMINATING MODULE BY MEANS OF XCTL EP=IEX51002
*
*        TABLES/WORKAREAS -
*        THE MESSAGE TEXTS WITH CORRESPONDING ADDR TABLE ARE
*        IN THE LOAD MODULE IEX21M
*        THE ERROR MESSAGE EDITING ROUTINE, CSECT IEX60000, ALSO
*        USES THE FOLLOWING TABLES -
*        WINTEBC  - TRANSLATION OF INTERNAL CHARACTERS TO EBCDIC
*        WSYMBSRC - TRANSLATION OF SOURCE OPERATORS
*        WSYMBSTK - TRANSLATION OF STACK OPERATORS
*        WORDSEBC - TRANSLATION OF COMPOUND SYMBOLS IF SOURCE IN
*                   EBCDIC
*        WORDSISO - TRANSLATION OF COMPOUND SYMBOLS IF SOURCE IN
*                   ISOCODE
*        WEBCDIC  - TRANSLATION EBCDIC EBCDIC
*        A WORKAREA OF 270 BYTES, WAREA, IS USED FOR BUILDING
*        THE MESSAGES
*
*        NOTES -
*        CHARACTER CODE DEPENDENCE - FOR THE BUILDING OF A MESSAGE
*        (CODE PART BETWEEN COT03 AND COT12) THE FOLLOWING
*        APPLIES, IN CASE NO SOURCE INFORMATION IS TO BE INSERTED
*        (COT31), OR IF THE INFORMATION IS EBCDIC CHARACTERS
*        (COT07), THE OPERATION OF CSECT IEX60000 DEPENDS UPON AN
*        INTERNAL REPRESENTATION OF THE EXTERNAL CHARACTER SET
*        WHICH IS EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME.
*        IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL
*        CHARACTERS (COT33) THE OPERATION OF CSECT IEX60000
*        DEPENDS UPON A TRANSLATION FROM THE INTERNAL
*        REPRESENTATION TO THE EBCDIC CHARACTER SET BY MEANS OF
*        THE TABLE WINTEBC.
*        IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL
*        ALGOL SYMBOLS (COT10) THE OPERATION OF CSECT IEX60000
*        DEPENDS UPON A TRANSLATION FROM THE INTERNAL
*        REPRESENTATION TO THE EBCDIC CHARACTER SET BY MEANS OF
*        THE TABLES 'WSYMBSTK'/'WSYMBSRC' AND 'WORDSISO'/
*        'WORDSEBC'.
*        FOR THE OUTPUT OF A MESSAGE (CODE PART BETWEEN COT12
*        AND COT21) THE FOLLOWING APPLIES -
*        WHEN A MESSAGE HAS BEEN BUILT IN EBCDIC, AN EBCDIC TO
*        EBCDIC TRANSLATION IS PERFORMED BEFORE OUTPUT BY MEANS
*        OF THE TABLE WEBCDIC. THUS THE OUTPUT MAY BE MODIFIED
*        BY MAKING CHANGES IN THIS TABLE
*
*        THE OPERATION OF CSECT IEX21000 DOES NOT DEPEND UPON A
*        PARTICULAR INTERNAL REPRESENTATION OF THE EXTERNAL
*        CHARACTER SET
*
*        THIS MODULE IS LINKED WITH THE MODULE IEX21M TO FORM
*        MODULE IEX21
*
*        THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN
*        CONNECTION WITH THE OTHER MODULES OF THE ALGOL COMPILER
*        IN PARTICULAR IT REQUIRES THE COMMON WORKAREA.
*
IEX21000 CSECT
*
         IEXENTRY 'IEX21000 LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IEX21000,R15
*
         L     R2,=A(IEX60000)         ADDR ERROR MSG EDIT ROUTINE
         LA    R14,SCAN3               LOAD RETURN ADDR
         LA    R1,ERRINFO              ADDR INFO FOR ERROR ED ROUTINE
         BR    R2                      GOTO ERROR MESSAGE EDITING
*
SCAN3    XCTL  EP=IEX30000
*
ERRINFO  DC    V(IEX21M00)             ADDR OF MESSAGE TEXTS
         DC    V(IEX21M01)             ADDR OF ADDR TABLE
         DC    H'152'                  MODIFICATION NUMBER
*
         LTORG
*
         COPY  IEX60000
*
WORKAREA DSECT
*
         COPY  WORKAREA
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IEX21M   0201-12230-12230-1200-00338-00338-00000-LEVEL
X2M      TITLE 'IEX21M - ERROR MESSAGE TEXT POOL 1, ALGOL F'
*
*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER
*
*        FUNCTION/OPERATION -
*        THIS MODULE CONTAINS MESSAGE TEXTS FOR ALL ERRORS THAT
*        MAY BE DETECTED BY IEX00, IEX10, IEX11, AND IEX20, AND
*        THE CORRESPONDING ADDRESS TABLE
*
*        ENTRY POINT - N/A
*
*        INPUT -  N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES -  N/A
*
*        EXITS - NORMAL -  N/A
*
*        EXITS - ERROR -  N/A
*
*        TABLES/WORKAREAS -  N/A
*
*        NOTES -
*        THIS MODULE IS LINKED WITH THE MODULE IEX21 TO FORM THE
*        MODULE IEX21
*
IEX21M00 CSECT
*
         ENTRY IEX21M01
*
*        ERROR MESSAGE POOL 1
*
WEMPOOL1 EQU   *
*
W001     DC    X'1C00'
         DC    CL27'WINVALID CHARACTER DELETED.'
*
W002     DC    X'2100'
         DC    CL32'WILLEGAL PERIOD. PERIOD DELETED.'
*
W003     DC    X'2F0300130C240020000F20'
         DC    CL37'WINVALID COLON AFTER . COLON DELETED.'
*
W004     DC    X'1900'
         DC    CL24'TLETTER STRING TOO LONG.'
*
W005     DC    X'3F00'
         DC    CL62'SIDENTIFIER BEGINS WITH INVALID CHARACTER. IDENTIFIX
               ER DELETED.'
*
W006     DC    X'2500'
         DC    CL36'TLABEL CONTAINS TOO MANY CHARACTERS.'
*
W007     DC    X'5005001412240027001B27F00000000D43'
         DC    CL64'WLABEL BEGINNING WITH  CONTAINS INVALID CHARACTER.CX
               OLON DELETED.'
*
W008     DC    X'3500'
         DC    CL52'WLABEL BEGINS WITH INVALID CHARACTER. COLON DELETEDX
               .'
*
W010     DC    X'3703001F0C24002C000B2C'
         DC    CL45'SSPECIFICATION PART OF PROCEDURE  INCOMPLETE.'
*
W011     DC    X'2800'
         DC    CL39'SPROGRAM STARTS WITH ILLEGAL DELIMITER.'
*
W012     DC    X'3C0300150C240022001A22'
         DC    CL50'WTWO APOSTROPHES AFTER . FIRST APOSTROPHE DELETED.'
*
W013     DC    X'3E0300310C24003E00003E'
         DC    CL52'WAPOSTROPHE ASSUMED AFTER DELIMITER BEGINNING WITH X
               .'
*
W014     DC    X'470300180C240025002225'
         DC    CL61'SDELIMITER BEGINNING WITH  INVALID. FIRST APOSTROPHX
               E DELETED.'
*
W015     DC    X'3400'
         DC    CL51'WMISSING SEMICOLON AFTER ''CODE''. SEMICOLON ASSUMEX
               D.'
*
W016     DC    X'5A0500191224002C001B2CF00000001248'
         DC    CL74'SIDENTIFIER BEGINNING WITH  CONTAINS INVALID CHARACX
               TER.IDENTIFIER DELETED.'
*
W017     DC    X'3E00'
         DC    CL61'SMORE THAN 65535 SEMICOLONS. SEMICOLON COUNTER RESEX
               T TO ZERO.'
*
W018     DC    X'2A00'
         DC    CL41'WDELIMITER ''COMMENT'' IN ILLEGAL POSITION.'
*
W020     DC    X'6200'
C        DC    CL97'TBLOCKS, COMPOUND STATEMENTS, FOR STATEMENTS AND PRX
               OCEDURE DECLARATIONSNESTED TO TOO MANY LEVELS.'
*
W021     DC    X'2B03000A0C240017001417'
         DC    CL33'SDECLARATOR  IN ILLEGAL POSITION.'
*
W022     DC    X'1F00'
         DC    CL30'TMORE THAN 255 PROGRAM BLOCKS.'
*
W023     DC    X'1700'
         DC    CL22'SSTRING POOL OVERFLOW.'
*
W024     DC    X'3700'
         DC    CL54'SDELIMITER ''CODE'' IN ILLEGAL POSITION. ''CODE'' DX
               ELETED.'
*
W025     DC    X'530300310CF0000000153E'
         DC    CL73'SSPECIFIER ''STRING'' OR ''LABEL'' IN ILLEGAL POSITX
               ION.SPECIFICATION DELETED.'
*
W026     DC    X'430300090C240016002D16'
         DC    CL57'WPARAMETER  MULTIPLY SPECIFIED. FIRST SPECIFICATIONX
                USED.'
*
W027     DC    X'550500091224001C00231CF00000001540'
         DC    CL69'SPARAMETER  MISSING FROM FORMAL PARAMETER LIST.SPECX
               IFICATION IGNORED.'
*
W028     DC    X'3E00'
         DC    CL61'SDELIMITER ''VALUE'' IN ILLEGAL POSITION. ''VALUE''X
                PART DELETED.'
*
W029     DC    X'2900'
         DC    CL40'WSPECIFICATION PART PRECEDES VALUE PART.'
*
W030     DC    X'2D0300090C240016001716'
         DC    CL35'WPARAMETER  REPEATED IN VALUE PART.'
*
W031     DC    X'660500391224004C00004CF0000000194D'
         DC    CL86'WLEFT PARENTHESIS NOT FOLLOWED BY / AFTER ARRAY IDEX
               NTIFIER .SUBSCRIPT BRACKET ASSUMED.'
*
W032     DC    X'5C05003512240048000048F00000001349'
         DC    CL76'SMISSING RIGHT PARENTHESIS IN BOUND PAIR LIST OF ARX
               RAY .DECLARATION DELETED.'
*
W033     DC    X'440300370C240044000044'
         DC    CL58'TMORE THAN 16 DIMENSIONS OR COMPONENTS IN DECLARATIX
               ON OF .'
*
W034     DC    X'6805000D12240020002320F00000002444'
         DC    CL88'SARRAY SEGMENT  NOT FOLLOWED BY SEMICOLON OR COMMA.X
               CHARACTERS TO NEXT SEMICOLON DELETED.'
*
W035     DC    X'3900'
         DC    CL56'WILLEGAL PERIOD IN ARRAY OR SWITCH LIST. PERIOD DELX
               ETED.'
*
W036     DC    X'360300290C240036000036'
         DC    CL44'TMORE THAN 15 PARAMETERS IN DECLARATION OF .'
*
W037     DC    X'6805003012240043000043F00000002444'
         DC    CL88'SSEMICOLON MISSING AFTER FORMAL PARAMETER LIST OF .X
               CHARACTERS TO NEXT SEMICOLON DELETED.'
*
W038     DC    X'2B00'
         DC    CL42'TTOO MANY IDENTIFIERS DECLARED IN A BLOCK.'
*
W039     DC    X'790484000F00390FF00000003049'
         DC    CL108'S MISSING ''END'' BRACKETS. OPEN BLOCKS, COMPOUND X
               STATEMENTS,FOR STATEMENTS AND PROCEDURE DECLARATIONS CLOX
               SED.'
*
W041     DC    X'1F00'
         DC    CL30'TMORE THAN 255 FOR STATEMENTS.'
*
W042     DC    X'3A00'
         DC    CL57'W''BEGIN'' PRECEDES PRECOMPILED PROCEDURE. ''BEGIN'X
               ' DELETED.'
*
W043     DC    X'5E0300300CF0000000213D'
         DC    CL84'SEQUAL NUMBER OF ''BEGIN'' AND ''END'' BRACKETS FOUX
               ND.REMAINING PART OF PROGRAM IGNORED.'
*
W044     DC    X'1A00'
         DC    CL25'TNO SOURCE PROGRAM FOUND.'
*
W045     DC    X'4003000A0C240017002917'
         DC    CL54'SIDENTIFIER  MULTIPLY DECLARED. LAST DECLARATION USX
               ED.'
*
W045B    DC    X'300300230C240030000030'
         DC    CL38'SILLEGAL CALL BY VALUE OF IDENTIFIER .'
*
*        DIRECTORY MESSAGES, INITIATION PHASE
*
W200     EQU   *
W046     DC    X'380300100C84001D001B1D'
         DC    CL46'WOPTION PARAMETER  INVALID. PARAMETER IGNORED.'
*
W201     EQU   *
W047     DC    X'2D03000B0C840018001518'
         DC    CL35'TDD CARD FOR  INCORRECT OR MISSING.'
*
W202     EQU   *
W048     DC    X'4100'
         DC    CL64'WDD CARD FOR SYSLIN INCORRECT OR MISSING. OPTION NOX
               LOAD ASSUMED.'
*
W203     EQU   *
W049     DC    X'4300'
         DC    CL66'WDD CARD FOR SYSPUNCH INCORRECT OR MISSING. OPTION X
               NODECK ASSUMED.'
*
W204     EQU   *
W050     DC    X'2A00'
         DC    CL41'TBLOCKSIZE SPECIFIED FOR SYSIN INCORRECT.'
*
W205     EQU   *
W051     DC    X'480300170C840024002424'
         DC    CL62'WBLOCKSIZE SPECIFIED FOR  INCORRECT. UNBLOCKED OUTPX
               UT ASSUMED.'
*
W206     EQU   *
W052     DC    X'4200'
         DC    CL65'WTOO MANY OPTION PARAMETER ERRORS. SUBSEQUENT PARAMX
               ETERS IGNORED.'
*
W207     EQU   *
W053     DC    X'2700'
         DC    CL38'WPOSSIBLE ERROR IN DD NAMES PARAMETER.'
*
W208     EQU   *
W054     DC    X'2D00'
         DC    CL44'WSIZE PARAMETER INVALID. SIZE 45056 ASSUMED.'
*
*        OTHER DIRECTORY MESSAGES
*
W209     EQU   *
W055     DC    X'460400360FF00000840046000046'
         DC    CL57'TCOMPILATION UNSUCCESSFUL DUE TO PROGRAM INTERRUPT.X
                PSW .'
*
W056     EQU   *
W210     EQU   *
         DC    X'300300230C840030000030'
         DC    CL38'TUNRECOVERABLE I/O ERROR ON DATA SET .'
*
W057     EQU   *
W211     EQU   *
         DC    CL56'PROGRAM INTERRUPT IN ERROR MESSAGE EDITING ROUTINE.X
                PSW '
*
W058     EQU   *
W212     DC    X'1200'
         DC    CL17'TTOO MANY ERRORS.'
*
W059     EQU   *
W213     DC    X'2800'
         DC    CL39'TINTERNAL OVERFLOW OF IDENTIFIER TABLE.'
*
W060     EQU   *
W214     DC    X'3903002D0C84003A00003A'
         DC    CL48'SDATA STORAGE AREA EXCEEDED, PROGRAM BLOCK NO. .'
*
W215     EQU   *
W061     DC    X'1A00'
         DC    CL25'TSOURCE PROGRAM TOO LONG.'
*
W216     DC    X'2600'
         DC    CL37'STOO MANY LABELS. LABEL NUMBER RESET.'
*
         DC    0F'0'
*
*        ADDRESS TABLE FOR WEMPOOL1
*
IEX21M01 DC    A(0)
         DC    A(W001)
         DC    A(W002)
         DC    A(W003)
         DC    A(W004)
         DC    A(W005)
         DC    A(W006)
         DC    A(W007)
         DC    A(W008)
         DC    A(0)
         DC    A(W010)
         DC    A(W011)
         DC    A(W012)
         DC    A(W013)
         DC    A(W014)
         DC    A(W015)
         DC    A(W016)
         DC    A(W017)
         DC    A(W018)
         DC    A(0)
         DC    A(W020)
         DC    A(W021)
         DC    A(W022)
         DC    A(W023)
         DC    A(W024)
         DC    A(W025)
         DC    A(W026)
         DC    A(W027)
         DC    A(W028)
         DC    A(W029)
         DC    A(W030)
         DC    A(W031)
         DC    A(W032)
         DC    A(W033)
         DC    A(W034)
         DC    A(W035)
         DC    A(W036)
         DC    A(W037)
         DC    A(W038)
         DC    A(W039)
         DC    A(0)
         DC    A(W041)
         DC    A(W042)
         DC    A(W043)
         DC    A(W044)
         DC    A(W045)
         DC    A(0)
         DC    A(W045B)
         DC    A(W046)
         DC    A(W047)
         DC    A(W048)
         DC    A(W049)
         DC    A(W050)
         DC    A(W051)
         DC    A(W052)
         DC    A(W053)
         DC    A(W054)
         DC    A(W055)
         DC    A(W056)
         DC    A(W057)
         DC    A(W058)
         DC    A(W059)
         DC    A(W060)
         DC    A(W061)
         DC    A(W216)
*
         END
./ ADD NAME=IEX30    0201-12230-12230-1200-03071-03071-00000-LEVEL
X30      TITLE 'IEX30 - SCAN III, ALGOL F'
*
*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER
*
*        FUNCTION/OPERATION -
*        EXTERNAL NAMES OF IDENTIFIERS ARE REPLACED BY THE
*        INTERNAL NAMES CONTAINED IN THE ITAB ENTRY OF THE
*        IDENTIFIER, AND CONSTANTS ARE REPLACED BY INTERNAL NAMES
*        CONSTRUCTED IN IEX30
*        OBJECT CODE IS PRODUCED FROM THE CONSTANT POOL IF
*        PARAMETERS DECK OR LOAD ARE SPECIFIED IN THE
*        EXEC STATEMENT
*        FOR STATEMENTS ARE CLASSIFIED FOR FURTHER USE BY IEX50
*        THE SUBSCRIPT TABLE (SUTAB) AND THE LEFT VARIABLE TABLE
*        (LVTAB) ARE CONSTRUCTED FOR FURTHER USE BY IEX40
*        SOURCE PROGRAM ERRORS CAUSES GENERATION OF ERROR
*        PATTERNS FOR FUTHER USE BY 1EX31
*
*        ENTRY POINT - IEX30000 FROM IEX21000 VIA XCTL
*
*        INPUT -
*        THE SOURCE PROGRAM MODIFICATION LEVEL 1 IS READ FROM
*        SYSUT1
*        THE IDENTIFIER TABLE (ITAB) IS READ FROM SYSUT3
*
*        OUTPUT -
*        THE SOURCE PROGRAM MODIFICATION LEVEL 2 IS WRITTEN OUT
*        ON SYSUT2
*        OBJECT TXT RECORDS IS WRITTEN ON SYSLIN OR/AND SYSPUNCH
*        IF THE PARAMETERS LOAD OR/AND DECK ARE SPECIFIED IN THE
*        EXEC CARD
*        THE SUBSCRIPT TABLE (SUTAB) IS WRITTEN OUT ON SYSUT3
*        A LINEAR SUBSCRIPT EXPRESSION ENCOUNTED IN A FOR
*        STATEMENT THAT IS OPTIMIZABLE IN REGARD TO SUBSCRIPTS
*        WILL GENERATE AN ENTRY IN THIS TABLE
*        THE LEFT VARIABLE TABLE (LVTAB) IS WRITTEN OUT ON
*        SYSUT3. INTEGER LEFT VARIABLES ENCOUNTED IN FOR
*        STATEMENT THAT IS OPTIMIZABLE IN REGARD TO SUBSCRIPTS
*        WILL GENERATE AN ENTRY IN THIS TABLE
*
*        EXTERNAL ROUTINES -
*        THE INTERRUPT ROUTINE OF IEX00 ARE USED FOR ALL
*        INTERRUPTS EXCEPT FLOATING POINT OVERFLOW
*
*        EXITS - NORMAL -
*        CONTROL IS ALWAYS GIVEN TO IEX31 BY MEANS OF XCTL
*        EP=IEX31
*
*        TABLES/WORKAREAS -
*        GROUP TABLE (GPTAB) CONSTRUCTED IN IEX11, USED TO
*        DIAGNOSE BRANCHES INTO FOR STATEMENTS.
*        SCOPE TABLE (SPTAB) CONSTRUCTED IN IEX11, USED TO CHECK
*        SUBSCRIPT EXPRESSIONS FOR POSSIBLE OPTIMIZATION
*        FOR STATEMENT TABLE (FSTAB) CONSTRUCTED IN IEX30
*        COMPLEATED IN IEX40 AND FINALLY USED IN IEX50, CONTAINS
*        A CLASSIFICATION BYTE FOR EVERY FOR STATEMENT
*        ERROR POOL CONSTRUCTED IN IEX30 AND USED IN IEX31,
*        CONTAINS ERROR PATTERNS GENERATED FROM SOURCE PROGRAM
*        ERRORS
*        CONSTANT POOL INTERNAL TABLE IN IEX30. THE FIRST
*        APPEARANCE OF A CONSTANT IN THE SOURCE STREAM GENERATES
*        AN ENTRY IN THE TABLE. THE RELATIVE ADDRESS OF THE
*        CONSTANT POOL ENTRY IS USED IN CONSTRUCTING THE
*        INTERNAL NAME OF A CONSTANT CRITICAL VARIABLE TABLE
*        (CRIDTAB) INTERNAL TABLE IN IEX30
*        DURING THE TREATMENT OF A FOR STATEMENT THE TABLE
*        CONTAINS ENTRIES CORRESPONDING TO THE IDENTIFIERS IN THE
*        FOR LIST
*
*        NOTES -
*        THE OPERATION OF THIS MODULE DOES NOT DEPEND ON ANY
*        SPECIAL REPRESENTATION OF THE CHARACTER SET. THIS MODULE
*        IS ONLY INTENDED TO BE EXECUTED IN CONNECTION WITH THE
*        OTHER MODULES OF THE ALGOL COMPILER. IN PARTICULAR IT
*        REQUIRES THE COMMON WORKAREA
*
IEX30000 CSECT
*
*        R3                            INPUT RECORD POINTER REGISTER
*        R4                            OUTPUT RECORD POINTER REGISTER
*
*        BIT PATTERNS
*
SARRAY   EQU   X'80'                   HANDLING ARRAY DECLARATION
SSWITCH  EQU   X'40'                   HANDLING SWITCH DECLARATION
FF       EQU   X'FF'
*                                      SCALE FACTOR MASKS
SFSIGN   EQU   X'80'                   SIGNED SCALE FACTOR
SFL0     EQU   X'40'                   LEADING ZERO IN SCALE FACTOR
SF19     EQU   X'20'                   SIGNIFICANT DIGIT IN SCALE FAC
SF       EQU   X'10'                   SCALE FACTOR PRESENT
SFDIGIT  EQU   X'60'
SFLSIGN  EQU   X'E0'
PRECERR  EQU   X'08'                   REAL CONSTANT EXCEEDS PRECISION
*
*        CLASSIFICATION MASKS OF I/O STATUS ON SYSUT3
*
READM    EQU   X'80'                   UNCHECKED READ OPERATION
WRITEM   EQU   X'40'                   UNCHECKED WRITE OPERATION
READC    EQU   X'20'                   CHECKED READ OPERATION
WRITEC   EQU   X'10'                   CHECKED WRITE OPERATION
*
*        FOR STATEMENT CLASSIFICATION MASKS
*
NOCOUNT  EQU   X'80'                   COUNTING LOOP IMPOSSIBLE
NOSUOP   EQU   X'40'                   NO SUBSCRIPT OPTIMIZATION
OUTOFFOR EQU   X'20'                   BRANCH OUT OF FOR STATEMENT
NORMAL   EQU   X'F0'                   NORMAL LOOP
STEPM    EQU   X'08'                   STEP IN FORLIST
WHILEM   EQU   X'84'                   WHILE IN FOR LIST
*
         IEXENTRY 'IEX30000 LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IEX30000,R10,R11,R12
         LR    R10,R15
         LA    R11,2048(,R15)
         LA    R11,2048(,R11)
         LA    R12,2048(,R11)
         LA    R12,2048(,R12)
*
         USING WORKAREA,R13
*
         LA    R5,TERM1                ERROR EXIT ADDR
         ST    R5,ERET
         LA    R5,LOMEGA6              PROVIDE EOD ADDR
         ST    R5,EODUT1               FOR UT1
         MVC   SEMCNT,ZERO             ZERO SEMICOLON COUNTER
*
         SPIE  INTERUPT,((1,7),9,11,12,15)
*
         ST    R1,OLDSPIE              SAVE ADDR OF OLD PICA
*
*        ALLOCATE STORAGE FOR TABLESD
*
         LH    R0,KH4096               CONSTANT POOL SIZE
         A     R0,ITAB30S              ITABSIZE
         A     R0,SRCE1S               INPUT BUFFER SIZE
         A     R0,SRCE3S               OUTPUT BUFFER SIZE
         A     R0,SRCE3S               OUTPUT BUFFER SIZE
         A     R0,CRIDTABS             CRIDTAB SIZE
         A     R0,SUTAB30S             SUTAB SIZE
         A     R0,LVTAB30S             LVTAB SIZE
         AH    R0,KH8                  RECORD KEY LENGTH
         ST    R0,TABSIZE              SAVE TABLE AREA LENGTH
*
         GETMAIN R,LV=(0)              ALLOCATE STORAGE
*
         LA    R5,TERM2                ERROR RETURN ADDR
         ST    R5,ERET
         ST    R1,ZKOPOOL              CONSTANT POOL START ADDR
         AH    R1,KH4096
         ST    R1,ZIBSTAO              ITAB START ADDR
         A     R1,ITAB30S
         ST    R1,ZIBREAD              SECOND INPUT BUFFER START ADDR
         A     R1,SRCE1S
         ST    R1,ZOBWORK              OUTPUT BUFFER START ADDR
         A     R1,SRCE3S
         ST    R1,ZOBWRITE             OUTPUT BUFFER START ADDR
         A     R1,SRCE3S
         ST    R1,ZFOCRI               CRIDTAB START ADDR
         A     R1,CRIDTABS
         ST    R1,SUSTRT               SUTAB START ADDR
         A     R1,SUTAB30S
         LA    R1,4(,R1)
         ST    R1,LVSTRT               LVTAB START ADDR
*
*        INITIALIZE INPUT BUFFERS
*
         L     R3,SRCE1ADD             ADDR OF FIRST INPUT BUFFER
         ST    R3,ZIBRUN
         TM    COMPFLGS+2,SPIC         SOURCE PROG IN STORAGE ?
         BO    INCORE                  YES
         BAL   R15,ICHAI               READ FIRST RECORD
*
*        ITAB POINTERS INITIALIZATION
*
INCORE   L     R1,ZIBSTAO              ITAB START ADDR
         MVC   0(256,R1),FIXITAB       INSERT ITAB FIXED PART
         MVC   256(FIXITABL-256,R1),FIXITAB+256
         LA    R5,FIXITABL-11(,R1)     R5 -> LAST FIXED ENTRY
         ST    R5,ZCURITEN             STORE IN ZCURITEN
         LA    R5,11(,R5)              ADDR FIRST FREE ITAB ENTRY
         ST    R5,ZITREC
         A     R1,ITAB30S              ITAB END ADDR PLUS 1
         ST    R1,ZITEND
         L     R1,AUT3DCB              R1 -> SYSUT3 DCB
*
         NOTE  (1)                     ID OF LAST ITAB BLOCK
*
         ST    R1,SULTSTRT             TRANSFER TO SUBSCRIPT HANDLING
         ST    R1,NOTEW                PREPARE WRITE OF SUTAB OR LVTAB
         L     R5,AUT3DCB              R5 -> SYSUT3 DCB
*
         CLOSE ((R5),REREAD),TYPE=T    TEMPORARY CLOSE
*
         BAL   R15,ITABREAD            READ FIRST ITAB RECORD
*
*        INITIALIZE OUTPUT BUFFERS
*
         L     R4,ZOBWORK              START OF ACTIVE OUTPUT BUFFER
         L     R5,SRCE3S               LENGTH OF OUTPUT BUFFER
         SH    R5,KH12                 SET BUFFER END PTRS
         AR    R5,R4
         ST    R5,ZFILE9
         LA    R5,3(,R5)
         ST    R5,ZFILE6
         LA    R5,1(,R5)
         ST    R5,ZFILE5
         LA    R5,2(,R5)
         ST    R5,ZFILE3
         LA    R5,1(,R5)
         ST    R5,ZFILE2
         LA    R5,1(,R5)
         ST    R5,ZFILE1
         BCTR  R4,0
*
*        CRIDTAB AND FSTAB INITIALIZATION
*
         L     R1,ZFOCRI               CRIDTAB START ADDR
         SH    R1,KH9                  INITIALIZE PTRS
         ST    R1,PFANO
         ST    R1,PFA                  CURRENT CRIDTAB PTR
         A     R1,CRIDTABS             GET ADDR OF LAST ENTRY
         ST    R1,PFAMAX               END PTR
         MVI   ZFOSTA,0                ZERO FSTAB
         MVC   ZFOSTA+1(254),ZFOSTA
         LA    R5,FSTAB-1              START ADDR OF FSTAB -1
         ST    R5,ZFSPTR               INITIALIZE FORSTATEMENT ZERO
*
*        SUTAB INITIALIZATION
*
         L     R1,SUSTRT               SUTAB START ADDR
         MVC   0(4,R1),SUKEY           SET SUTAB KEY
         SH    R1,KH10                 INITIALIZE PTRS
         ST    R1,ZSUDAD               START PTR
         ST    R1,ZSUTAPO              CURRENT PTR
         A     R1,SUTAB30S
         ST    R1,ZSUTMAX              END PTR
*
*        LVTAB INITIALIZATION
*
         L     R1,LVSTRT               LVTAB START ADDR
         MVC   0(4,R1),LVKEY           SET LVTAB KEY
         ST    R1,ZLESTA               START PTR
         ST    R1,ZLEVA                CURRENT PTR
         A     R1,LVTAB30S
         ST    R1,ZLEMAX               END PTR
*
*        LITERAL HANDLING INITIALIZATION
*
         TM    COMPFLGS,LNG            LONG PRECISION ?
         BNZ   INLIT2                  YES
         LA    R5,4
         ST    R5,LREAL
         LA    R5,7
         ST    R5,NREAL                MAXIMAL PRECISION
*
*        CONSTANT POOL INITALIZATION
*
INLIT2   L     R1,ZKOPOOL              CONSTANT POOL START ADDR
         LH    R5,KH4096               LENGTH OF CONSTANT POOL
         AR    R5,R1                   CONSTANT POOL END ADDR
         ST    R5,ZKOPEND              END PTR
         A     R1,PRPT
         ST    R1,ZWP                  WORD PTR
         ST    R1,ZDWP                 DOUBLE WORD PTR
         ST    R1,ZLITSTA              START ADDR OF ACTIVE POOL
         AH    R1,TXTPUT               TXT OUTPUT PTR
         ST    R1,ZTEXTCO
         MVC   ZKBNMAX(2),PBN          PREPARE CONSTANT POOL EXCHANGE
         MVC   KBN(2),ZERO             CURRENT POOL NUMBER
*
*        START READ INTO ALTERNATE INPUT BUFFER IF NECESSARY
*
         TM    COMPFLGS+2,SPIC         SOURCE PROG IN STORAGE ?
         BO    INITEND                 YES
         BAL   R15,ICHA
INITEND  NI    COMPFLGS+2,255-NOSC     SET SEMICOLON COUNTER VALID
         TM    COMPFLGS,PROC           PRECOMPILED PROCEDURE ?
         BZ    GENTEST                 NO
         BAL   R15,ITABMOVE            YES, GET ITAB RECORD
         B     GENTEST
*
GENTEST1 LA    R3,1(,R3)
GENTEST  SR    R2,R2
         TRT   0(80,R3),GENER
         B     *(R2)
         B     LETTER                  + 04
         B     DIGIT19                 + 08
         B     DIGIT0                  + 12
         B     DECPOIN                 + 16
         B     SCAFACT                 + 20
         B     QUOTE                   + 24
         B     BETA                    + 28
         B     PIPHI                   + 32
         B     FOR                     + 36
         B     EPSILON                 + 40
         B     ETA                     + 44
         B     DO                      + 48
         B     WHILE                   + 52
         B     SEMIDELT                + 56
         B     OPBRACK                 + 60
         B     COMMA                   + 64
         B     CLOBRACK                + 68
         B     ZETA                    + 72
         B     GAMMA                   + 76
         B     OMEGA                   + 80
         B     OTHOP                   + 84
         B     RHO                     + 88
         B     STEP                    + 92
         B     ARRAY                   + 96
         B     SWITCH                  +100
         B     DIPOW                   +104
*
*        STRING OR LOGICAL VALUE
*
QUOTE    C     R4,ZFILE5               OUTPUT BUFFER EXCHANGE ?
         BH    LQUOT2                  YES
LQUOT3   MVC   1(5,R4),1(R3)           OUTPUT INTERNAL NAME
         LA    R3,6(,R3)
         CLI   0(R3),X'2E'             FOLLOWS AN OPERATOR ?
         BNL   LQUOT1                  PROBABLY NOT, MIGHT BE ZETA
LQUOT5   LA    R4,5(,R4)               STEP OUTPUT PTR
         B     GENTEST                 BRANCH TO GENTEST
*
LQUOT2   BAL   R15,OUCHA               BRANCH TO SUBROUTINE OUCHA
         B     LQUOT3                  BRANCH TO LQUOT3
*
LQUOT1   CLI   0(R3),XFZETA            ZETA ?
         BNE   LQUOT4                  NO, GIVE ERROR MESSAGE
         BAL   R15,ICHA                CHANGE INPUT BUFFER
         CLI   0(R3),X'2E'             FOLLOWS OPERATOR ?
         BL    LQUOT5                  YES
LQUOT4   MVC   ZIDEX(6),ZPOINT         REPLACE OPERAND BY SIX POINTS
         LA    R8,ZIDEX+6
         LA    R0,ZIDEX+12
         MVC   ZERRONU,INVOP
         B     INCOROP                 INCORRECT OPERAND ERROR ROUTINE
*
*        PROGRAM BLOCK BEGIN
*
BETA     CLI   LETTER+1,X'F0'          PROCEDURE BLOCK TO READ ?
         BE    LBETA4                  YES
BETA1    BAL   R15,ITABMOVE            READ ITAB BLOCK
LBETA2   C     R4,ZFILE2               COMPARE ZOUT WITH ZFILE(2)
         BH    LBETA1                  BRANCH IF HIGH
LBETA3   MVC   1(2,R4),0(R3)
         LA    R4,2(,R4)               INCR ZOUT BY 2
         MVC   ZIGN(2),2(R3)           IGN IS RECOGNIZED AND STORED
         LA    R3,4(,R3)               INCR ZIN BY 4
         B     GENTEST                 BRANCH TO GENTEST
*
LBETA1   BAL   R15,OUCHA               BRANCH TO SUBROUTINE OUCHA
         B     LBETA3                  BRANCH TO LBETA 2
*
LBETA4   BAL   R15,ITABMOP             READ PROCEDURE BLOCK
         B     BETA1
*
*        PROCEDURE BLOCK BEGIN
*
PIPHI    NI    IDENT4+1,X'0F'          PROC HEAD SWITCH ON
         CLI   LETTER+1,X'F0'          PROCEDURE BLOCK TO READ ?
         BE    LPIPHI6
PIPHI1   MVC   ZIGN(2),1(R3)           SAVE CURRENT IGN
         C     R4,ZFILE6               SPACE IN OUTPUT BUFFER ?
         BH    LPIPHI1                 BRANCH IF HIGH
LPIPHI2  MVC   1(1,R4),0(R3)           OPERATOR IS MOVED TO O-BUFFER
         LA    R4,1(,R4)               INCR ZOUT BY 1
         LA    R3,3(,R3)               INCR ZIN BY 3
LPIPHI3  CLI   0(R3),XFA               LETTER FOLLOWS IN SOURCE INPUT ?
         BL    LPIPHI4                 NO
         OI    LETTER+1,X'F0'          YES, SET PROCEDURE SWITCH
         B     LETTER                  GET IDENT AND READ ITAB
*
LPIPHI4  CLI   0(R3),XFZETA            ZETA IN SOURCE INPUT ?
         BE    LPIPHI5                 YES
         BAL   R15,ITABMOVE            NO, READ ITAB BLOCK
         B     GENTEST
*
LPIPHI5  BAL   R15,ICHA                GET NEXT INPUT RECORD
         B     LPIPHI3
*
LPIPHI1  BAL   R15,OUCHA               BRANCH TO SUBROUTINE OUCHA
         B     LPIPHI2                 BRANCH TO LPIPHI2
*
LPIPHI6  BAL   R15,ITABMOP             READ PROCEDURE BLOCK
         B     PIPHI1
*
*        FOR STATEMENT BEGIN
*
FOR      MVI   ZFORTEST,X'C0'          ZFORTEST IS SET TO X'C0'
         L     R5,ZFSPTR               UPDATE PTR TO FSTAB ENTRY
         LA    R5,1(,R5)
         ST    R5,ZFSPTR
         LA    R6,FSTAB                GET FOR STATEMENT NUMBER
         SR    R5,R6
         STC   R5,ZFSN
LFOR3    MVC   ZIGN(2),1(R3)           IGN IS RECOGNIZED AND STORED
         C     R4,ZFILE1               TEST IF SPACE IN OUTPUT BUFFER
         BH    LFOR1                   BRANCH IF HIGH
LFOR4    MVC   1(1,R4),0(R3)
         LA    R4,1(,R4)               INCR ZOUT
         LA    R3,3(,R3)               INCR ZIN BY 3
         B     GENTEST                 BRANCH TO GENTEST
*
LFOR1    BAL   R15,OUCHA               CALL SUBROUTINE OUCHA
         B     LFOR4                   BRANCH TO LFOR2
*
*        END OF PROGRAM OR PROCEDURE BLOCK
*
EPSILON  CLI   LETTER+1,X'F0'          ITAB BLOCK TO READ ?
         BE    EPSILON2                YES
EPSILON1 L     R6,ZCURITEN             ADDR LAST ITAB ENTRY
         SH    R6,ZCURITLE             ZCURITEN = ZCURITEN - ZCURITLE
         ST    R6,ZCURITEN             ZCURITEN IS STORED
         MVC   ZCURITLE(2),17(R6)      ZCURITLE IS UPDATED
         B     LBETA2                  BRANCH TO LBETA2
*
EPSILON2 BAL   R15,ITABMOP             READ ITAB BLOCK
         B     EPSILON1
*
*        FOR STATEMENT END
*
ETA      MVI   ZFORTEST,0              ZERO ZFORTEST
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    LFOR3                   YES
         BAL   R15,CRIFODEL            CALL CRIFODEL
         B     LFOR3                   BRANCH TO LFOR3
*
*        FOR LIST END
*
DO       MVI   ZFORTEST,0              ZERO ZFORTEST
LDO3     C     R4,ZFILE1               COMPARE ZOUT WITH ZFILE
OTHOP    EQU   LDO3
         BH    LDO1                    HIGH, BRANCH
LDO2     MVC   1(1,R4),0(R3)           OPERATOR IS MOVED TO O BUFFER
         LA    R4,1(,R4)               INCR ZOUT
         B     GENTEST1
*
LDO1     BAL   R15,OUCHA               BRANCH TO SUBROUTINE OUCHA
         B     LDO2                    BRANCH TO LDO2
*
*        WHILE
*
WHILE    L     R5,ZFSPTR               ADDR FSTAB ENTRY
         OI    0(R5),WHILEM            INDICATE 'WHILE HAS APPEARED'
         B     LDO3
*
*        STEP OPERATOR
*
STEP     L     R5,ZFSPTR               ADDR FSTAB ENTRY
         OI    0(R5),STEPM             INDICATE 'STEP HAS APPEARED'
         B     LDO3
*
*        DIVIDE AND POWER ROUTINE
*
DIPOW    CLI   ZFORTEST,0              OPERATOR IN FOR LIST ?
         BE    OTHOP                   NO, MOVE TO OUTPUT STREAM
         L     R5,ZFSPTR               YES, ADDR FSTAB ENTRY
         OI    0(R5),NOCOUNT           COUNTING LOOP IMPOSSIBLE
         B     OTHOP                   MOVE TO OUTPUT STREAM
*
*        SEMICOLON OR DELTA
*
SEMIDELT MVC   SEMCNT,1(R3)            SAVE SEMICOLON COUNTER
         OI    IDENT4+1,X'F0'          PROC HEAD SWITCH OFF
         C     R4,ZFILE3               COMPARE ZOUT WITH ZFILE(3)
         BH    LSEM1                   HIGH, BRANCH
LSEM2    MVC   1(3,R4),0(R3)           OPERATOR,SC ARE MOVED TO O-BUFF
         LA    R4,3(,R4)               ZOUT IS INCREASED BY 3
         LA    R3,3(,R3)               ZIN IS INCREASED BY 3
         MVI   STATUS,0                TURN OFF SWITCH OR ARRAY BITS
         B     GENTEST                 BRANCH TO GENTEST
*
LSEM1    BAL   R15,OUCHA               CALL SUBROUTINE OUCHA
         B     LSEM2                   BRANCH TO LSEM2
*
SWITCH   OI    STATUS,SSWITCH          SET ON SWITCH SWITCH
         B     OTHOP
*
ARRAY    OI    STATUS,SARRAY           SET ON ARRAY SWOTCH
         MVC   BRCNT(2),ZERO           ZERO BRACKET COUNTER
         B     OTHOP                   OUTPUT OPERATOR
*
*        PROGRAM END
*
OMEGA    MVC   1(1,R4),0(R3)
         OI    COMPFLGS+2,NOSC         SET SEMICOLON COUNTER NOT VALID
         TM    COMPFLGS+2,SPIC         SOURCE PROG IN STORAGE ?
         BO    LOMEGA6                 YES, BRANCH
*
         CHECK SREAD
*
LOMEGA6  L     R5,AUT1DCB              R5 -> SYSUT1 DCB
*
         CLOSE ((R5))                  CLOSE SYSUT1 FINALY
*
         CLC   KH1,ZOUTCOT             ZOUTCOT = 1 ?
         BE    LOMEGA1                 YES, BRANCH
         LA    R4,1(,R4)               SAVE OMEGA FROM OVERLAY
         BAL   R15,OUCHA               WRITE LAST RECORD
         NI    COMPFLGS+2,255-SPIC     OUTPUT ON SECONDARY STORAGE
*
         CHECK SWRITE                  CHECK LAST OUTPUT RECORD
*
*        WRITE OUT CONSTANT POOL
*
LOMEGA3  L     R9,ZDWP                 ADDR OF FREE BYTE IN CONST POOL
         LR    R5,R9
         AH    R5,TXTPUT               MORE TXT TO WRITE ?
         C     R5,ZTEXTCO
         BE    LOMEGA2
         BAL   R14,TXTTRAF             YES, WRITE REST OF CONST POOL
*
LOMEGA2  EQU   *
TERM2    EQU   *
         SR    R5,R5
         IC    R5,ZFSN
         STH   R5,FSNMAX
         MVC   SUCOUNT(2),SUCNT        NUMBER OF SUTAB RECORDS
         MVC   LVCOUNT(2),LVCNT        NUMBER OF LVTAB RECORDS
         L     R1,SULENGTH             GET FULL LENGTH OF SUTAB
         A     R1,ZSUTAPO
         S     R1,ZSUDAD
         ST    R1,ZSUTEN               LENGTH OF SUTAB
         BZ    LOMEGA4
         CLC   ZSUTAPO(4),ZSUDAD       ANYTHING IN SUTAB BUFFER ?
         BE    LOMEGA5                 NO
         BAL   R5,CHECK                CHECK LAST I/O OPERATION ON UT3
         L     R5,SUSTRT               WRITE START ADDR
         L     R6,SUTAB30S             LENGTH OF RECORD
         BAL   R15,WRITE               WRITE
*
LOMEGA5  L     R1,LVLENGTH             GET FULL LENGTH OF LVTAB
         A     R1,ZLEVA
         S     R1,ZLESTA
         ST    R1,ZLEVEN               LENGTH OF LVTAB
         BZ    LOMEGA4
         CLC   ZLEVA(4),ZLESTA         ANYTHING IN LVTAB BUFFER ?
         BE    LOMEGA4                 NO
         BAL   R5,CHECK                CHECK LAST I/O OPERATION ON UT3
         L     R5,LVSTRT               LVTAB BUFFER START ADDR
         L     R6,LVTAB30S             LENGTH OF LVTAB BUFFER
         BAL   R15,WRITE               WRITE
*
LOMEGA4  BAL   R5,CHECK                CHECK LAST I/O OPERATION ON UT3
         L     R5,AUT2DCB              R5 -> SYSUT2
*
         CLOSE ((R5),REREAD),TYPE=T    CLOSE SYSUT2 TEMPORARILY
*
         L     R0,TABSIZE              RELEASE MAIN STORAGE
         L     R1,ZKOPOOL
*
         FREEMAIN R,LV=(0),A=(1)
*
TERM1    L     R1,OLDSPIE
*
         SPIE  MF=(E,(1))
*
         XCTL  EP=IEX31                TRANSFER TO NEXT PHASE
*
LOMEGA1  OI    COMPFLGS+2,SPIC         SOURCE PROG IN STORAGE
         L     R1,SRCE1ADD             ADDR OF RESIDENT BUFFER
         L     R2,ZOBWORK              ADDR OF OUTPUT BUFFER
         L     R5,SRCE1S               BUFFER LENGTH
         BCTR  R5,0
         LR    R6,R5
         SRA   R6,8                    GET MULTIPLE OF 256
         LTR   R6,R6                   MAXIMUM 256 ?
         BZ    LOMEGA12                YES
LOMEGA11 MVC   0(256,R1),0(R2)         MOVE BLOCK OF 256
         LA    R1,256(,R1)
         LA    R2,256(,R2)
         BCT   R6,LOMEGA11
LOMEGA12 EX    R5,ONERM                MOVE REST OF BUFFER
         B     LOMEGA3
*
ONERM    MVC   0(0,R1),0(R2)           LENGTH IN R5
*
*        CODE PROCEDURE
*
GAMMA    C     R4,ZFILE9               COMPARE ZOUT WITH ZFILE9
         BH    LGAMMA1                 HIGH, BRANCH
LGAMMA2  MVI   1(R4),X'2E'             NEW CODE FOR GAMMA IS SET
         MVC   2(8,R4),1(R3)           OPT, EXTERNAL NAME TO O-BUFF
         LA    R3,9(,R3)               INCR ZIN BY 9
         LA    R4,9(,R4)
         B     GENTEST                 BRANCH TO GENETEST
*
LGAMMA1  BAL   R15,OUCHA
         B     LGAMMA2                 BRANCH TO LGAMMA2
*
*        END OF INPUT BUFFER
*
ZETA     BAL   R15,ICHA                BRANCH TO SUBROUTINE ICHA
         B     GENTEST                 BRANCH TO GENTEST
*
*        OPENING BRACKET
*
OPBRACK  TM    STATUS,SARRAY           HANDLING ARRAY DECLARATION ?
         BO    LOPBRA5                 YES
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    OTHOP                   YES
         L     R7,ZITAN                ZITEAN IS LOADED INTO R7
         TM    7(R7),X'08'             AN ARRAY IDENTIFIER ?
         BO    LDO3                    NO
         TM    7(R7),X'04'
         BZ    LDO3
         CLC   PFA(4),PFANO            PFA = PFANO ?
         BE    LDO3                    YES, BRANCH
         CLI   ZLVOV,X'FF'             TABLE OVERFLOW ?
         BE    LDO3                    YES
         CLC   ZARSPO(4),ZARNO         COMPARE ZARSPO WITH ZARNO
         BE    LOPBRA4                 NO SUBSCRIPT NESTING
         BAL   R15,SUCRIDEL
         L     R8,ZARSPO               ZARSPO IS SET INTO R8
         C     R8,ZARMAX               ZARSPO EQUAL TO ZARMAX ?
         BE    LOPBRA4                 YES, BRANCH
         MVC   10(1,R8),ZPOSIX+1       NUMBER OF COMMAS TO ARIDSTACK
         LA    R8,7(,R8)               ADDR NEXT ENTRY
LOPBRA3  ST    R8,ZARSPO               ZARSPO IS SET TO ZARSTACK
         MVC   0(3,R8),8(R7)           ARRAY IDENTIFIER IS STORED
         LA    R0,1(,R4)
         ST    R0,ZBRACK               ZBRACK IS SET TO ZOUT+1
         S     R0,ZOBWORK
         ST    R0,ALIGN                RELATIVE BUFFER ADDR
         MVC   5(2,R8),ALIGNH
         MVC   4(1,R8),ZOUTCOT+1       RECORD COUNTER TO ARIDSTAB
         MVC   ZPOSIX(2),ZERO          ZPOSIX IS SET TO 0
         MVI   ZCLOBRA,X'00'           ZCLOBRA IS SET TO X'00'
         B     LDO2                    PUT OUT OPERATOR
*
LOPBRA4  LA    R8,ZARSTACK             START ADDR OF ARIDSTAB
         B     LOPBRA3                 BRANCH TO LOPBRA3
*
LOPBRA5  LH    R5,BRCNT                INCREASE BRACKET COUNTER
         LA    R5,1(0,R5)
         STH   R5,BRCNT
         B     OTHOP                   OUTPUT OPERATOR
*
*        COMMA
*
COMMA    TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    OTHOP                   YES
         CLC   ZARSPO(4),ZARNO         ZARSPO = ZARNO ?
         BE    LDO3                    YES, BRANCH
         CLC   ZPOSIX(2),KH15          ZPOSIX = 15 ?
         BE    LCOMMA1                 YES, BRANCH
         CLI   ZCLOBRA,0               ZCLOBRA = X'FF' ?
         BNE   LCOMMA2                 NO, BRANCH
         L     R7,ZBRACK               ZBRACK IS SET INTO R7
         LA    R7,18(,R7)
         CR    R4,R7                   COMPARE ZOUT AND ZBRACK+18
         BH    LCOMMA3
         BAL   R9,SUSCRITE             OPTIMIZATION POSSIBLE ?
LCOMMA4  LH    R7,ZPOSIX               ZPOSIX IS SET INTO R7
         LA    R7,1(,R7)               INCR ZPOSIX BY 1
         STH   R7,ZPOSIX
         LA    R7,1(,R4)
         ST    R7,ZBRACK               ZBRACK IS SET TO ZOUT+1
         B     LDO2                    PUT OUT OPERATOR
*
LCOMMA1  OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         B     LDO3                    BRANCH TO LDO3
*
LCOMMA2  MVI   ZCLOBRA,0               ZERO ZCLOBRA
LCOMMA3  BAL   R15,SUCRIDEL
         B     LCOMMA4                 BRANCH TO LCOMMA4
*
*        CLOSING BRACKET
*
CLOBRACK TM    STATUS,SARRAY           HANDLING ARRAY DECLARATION ?
         BO    CLOBRA3
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    OTHOP                   YES
         CLC   ZARSPO(4),ZARNO         THERE AN ARIDSTAB ENTRY ?
         BE    LDO3                    NO
         CLI   ZCLOBRA,0               PRECEEDING SUBSCR OPER CLOBRA ?
         BNE   CLOBRA1                 YES
         L     R7,ZBRACK               SUBSCRIPT MORE THAN 18 BYTES ?
         LA    R7,18(,R7)
         CR    R4,R7
         BH    CLOBRA1                 YES, NO OPTIMIZATION
         BAL   R9,SUSCRITE             TEST IF OPTIMIZABLE
CLOBRA2  L     R7,ZARSPO               UPDATE CURRENT ARIDSTAB PTR
         SH    R7,KH7
         ST    R7,ZARSPO
         C     R7,ZARNO                ARIDSTAB EMPTY
         BE    LDO3                    YES
         MVC   ZPOSIX+1(1),10(R7)      RESET SUBSC POSITION CNTR
         LA    R7,1(,R4)               SET ZBRACK
         ST    R7,ZBRACK
         MVI   ZCLOBRA,X'FF'           LAST SUBSCR OPER CLOBRACK
         B     LDO3
*
CLOBRA1  BAL   R15,SUCRIDEL            NO OPTIMIZATION POSSIBLE
         B     CLOBRA2
*
CLOBRA3  LH    R5,BRCNT                DECREASE BRACKET COUNTER
         BCTR  R5,0
         STH   R5,BRCNT
         B     OTHOP                   OUTPUT OPERATOR
*
*        LETTER
*
*        SCAN FOR END OF IDENTIFIER
*        BRANCH TO IDENT TO SEARCH FOR THE IDENTIFIER IN ITAB
*        REPLACE IDENTIFIER BY INTERNAL NAME
*
*        INITIALIZED REG = IDENTIFIER START ADDR
*        SUBROUTINE LINK IDENTX
*
LETTER5  BAL   R15,ITABMOP             READ ITAB RECORD
         B     LETTERP
*
LETTER   NOP   LETTER5                 BRANCH TO READ ITAB RECORD
LETTERP  LA    R8,ZIDEX
         LA    R0,ZIDEX+6
LETTER4  LR    R9,R3
         SR    R2,R2
         SR    R1,R1
LETTER6  TRT   0(256,R3),IDENTI
         BZ    LETTER0                 STILL SAME IDENTIFIER
         LR    R3,R1                   UPDATE R3
         B     *(R2)
         B     ZETALET                 +04
         B     RHO                     +08
         B     ERROR1                  +12
*                                      END OF IDENTIFIER IS FOUND
         B     IDENT                   ITAB SEARCH
*
LETTER1  ST    R7,ZITAN                SAVE POINTER TO LAST IDENTIFIER
         C     R4,ZFILE5               SPACE IN OUTPUT BUFFER
         BH    LETTER2                 NO SPACE
LETTER3  MVC   1(5,R4),6(R7)           MOVE INTERNAL NAME TO OUTPUT BUF
         LA    R4,5(,R4)
         B     GENTEST
*
LETTER2  BAL   R15,OUCHA
         B     LETTER3
*
LETTER0  LA    R3,256(,R3)             UPDATE INPUT PTR
         B     LETTER6
*
*        END OF INPUT BUFFER IN THE MIDDLE OF AN IDENTIFIER
*
ZETALET  BAL   R15,MOVE
         BAL   R15,ICHA
         B     LETTER4
*
*        LETTER STRING USED AS PARAMETER DELIMITER
*        REPLACE STRING BY COMMA
*
RHO      CLI   0(R4),XFRBRAC           RIGHT BRACKET ?
         BNE   GENTEST1                NO
         MVI   0(R4),XFCOMMA           REPLACE RIGHT BRACKET BY COMMA
         B     GENTEST1
*
*        INVALID CHARACTER IN IDENTIFIER
*
ERROR1   BAL   R15,MOVE
         MVC   ZERRONU,INVOP
         B     INCOROP
*
*        IDENT
*
*        A SEARCH THRU ITAB FOR THE IDENTIFIER WITH THE START
*        ADDRESS IN ZIDSTAR IS DONE. IF FOUND BRANCH TO ROUTINE
*        FOL1 FOR TYPECHECK, IF NOT REPLACE IDENTIFIER WITH ALL
*        PURPOSE IDENTIFIER
*
*        RECEIVED REG = ADDR OF IDENTIFIER START
*        INITIALIZED R7
*
IDENT    BAL   R15,MOVE                MOVE IDENTIFIER
         MVC   0(5,R8),ZERO            FILL UP WITH ZERO
*                                      START ITAB SEARCH
         L     R7,ZCURITEN             ADDR OF LAST ITAB ENTRY
         L     R1,ZIBSTAO              ITAB START ADDR
         LA    R0,11
         LCR   R0,R0                   MINUS ELEVEN
IDENT2   LA    R5,IDENT4
IDENT3   CLC   0(6,R7),ZIDEX           IDENTIFIER SEARCH
         BER   R5                      FOUND
IDENT6   BXH   R7,R0,IDENT3            PROCEED SEARCH, IF NOT
         MVC   ZBEGERR,OPSTART
         ST    R8,ZENDERR
         MVC   ZERRONU,UNDEFOP
         BAL   R15,MOVERRO
         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         LA    R7,ZALLPU               ALL PURPOSE IDENTIFIER
         B     LETTER1
*
IDENT4   B     IDENT5                  BRANCH IF NOT PROC HEAD
*
         TM    6(R7),X'02'             PROC OR FORMAL PARAMETER ?
         BZ    IDENT6                  NO, CONTINUE SEARCH
         CLC   8(1,R7),CURPBN          DECLARED IN LAST BLOCK ?
         BNE   IDENT6                  NO, CONTINUE SEARCH
IDENT5   TM    STATUS,SARRAY           HANDLING ARRAY DECLARATION ?
         BZ    FOLI                    NO
         CLC   BRCNT(2),ZERO           IDENTIFIER IN ARRAY LIST ?
         BE    FOLI                    NO, ARRAY IDENTIFIER
         CLC   8(1,R7),CURPBN          DECLARED IN LAST BLOCK ?
         BL    FOLI                    NO
         MVC   ZSTO(2),6(R7)           IDENT CHARACTERISTIC
         NC    ZSTO(2),ZSTO1
         CLC   ZSTO(2),ZSTO2           FUNCTION PROCEDURE ?
         BE    IDENT7                  YES
         CLI   ZSTO,X'02'              FORMAL PARAM OR PROC ?
         BE    FOLI                    YES
IDENT7   MVC   ZBEGERR,OPSTART         GIVE WARNING MESSAGE
         ST    R8,ZENDERR
         MVC   ZERRONU,ARRAYERR
         BAL   R15,MOVERRO
         AR    R7,R0                   PROCEED SEARCH FOR IDENTIFIER
         B     IDENT2
*
*        FOLI
*
*        CHECK TYPE OF IDENTIFIER
*
FOLI     IC    R5,6(,R7)               ISOLATE SPECIAL USE BITS
         N     R5,SPECUSE              X'00000006'
         AR    R5,R5                   SPECIAL USE BITS MULTIPLIED BY 4
         B     *+4(R5)
         B     NOCRI               +00 NON-CRITICAL IDENTIFIER
         B     PROFU               +04 PROCEDURE OR FORMAL PARAMETER
         B     SWILA               +08 LABEL OR SWITCH
         B     CRITI               +12 CRITICAL IDENTIFIER
*
NOCRI    TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    LETTER1
         CLI   ZFORTEST,X'00'          APPEARS IDENT BETWEEN FOR - DO
         BNE   NOCRI1                  YES
*                                      SHOULD ENTRY TO LVTAB BE DONE ?
         CLC   PFA(4),PFANO            FOR-STATMENT
         BE    LETTER1                 NO, NO LVTAB-ENTRY
         CLI   0(R3),X'16'             IDENTIFIER FOLLOWED BY ASSIGN ?
         BNZ   LETTER1                 NO, NO LVTEB-ENTRY
         TM    7(R7),X'02'             INTEGER ?
         BO    LETTER1                 NO, NO LVTAB-ENTRY
         BAL   R9,LETRAF               MAKE ENTRY IN LVTAB
         B     LETTER1                 RETURN
*
NOCRI1   BAL   R14,CRIMA               MAKE CRIDTAB ENTRY
         B     LETTER1
*
*        PROFU
*
*        BECAUSE OF POSSIBLE SIDE EFFECTS OF A PROCEDURE,
*        OPTIMIZATION OF SUBSCRIPTS AND FOR-STATEMENTS IS
*        INHIBITED
*
*        SUBROUTINE LINK VIA R15
*
PROFU    TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    LETTER1                 YES
         MVC   ZARSPO(4),ZARNO         SKIP ARIDSTAB
         CLI   ZFORTEST,X'C0'          CONTROLLED VARIABLE ?
         BNE   PROFU1                  NO
         L     R5,ZFSPTR               YES, CLASSIFIED NORMAL
         OI    0(R5),NORMAL
PROFU1   MVI   ZFORTEST,X'00'          TURN OFF FOR-SWITCH
         CLC   PFA(4),PFANO            CRIDTAB EMPTY ?
         BE    LETTER1                 YES, RETURN
         BAL   R15,DELCRIV             DELETE ALL CRIDTAB-ENTRIES
         B     LETTER1                 RETURN
*
*        SWILA
*
*        IN CASE OF SWITCH OF LABEL DECLARATION NO ACTION IS
*        TAKEN. IF USED IN A GO-TO-STATEMENT A TEST IS DONE IF
*        THE ALGOL RULES ARE FOLLOWED. IF NOT GIVE MESSAGE
*
*        RECEIVED R7
*        WORK REG R1, SIGNEMBR, R1, R9
*
SWILA    LR    R1,R7                   START SEARCH FOR HEADING ENTRY
SWILA1   SH    R1,KH11
         CLI   5(R1),X'2B'             HEADING TEST
         BNE   SWILA1                  NO HEADING
         MVC   ALIGNH(2),8(R1)
         L     R9,ALIGN
         LH    R2,ZIGN                 ACTUAL IGN
         LA    R1,ZFOSTA-1             ADDR OF BYTE PRECEED FSTAB
SWILA2   CR    R2,R9                   COMPARE DECLAR AD AND CUR IGN
         BH    SWILA3                  CHECK EMBRACING IGN TO CUR IGN
         BE    LETTER1
         TM    STATUS,SSWITCH          IN SWITCH DECLARATION ?
         BZ    SWILA21                 NO, SERIOUS ERROR
         MVC   ZBEGERR,OPSTART         YES, GIVE WARNING MESSAGE
         ST    R8,ZENDERR
         MVC   ZERRONU,SWITCHER
         BAL   R15,MOVERRO
         B     LETTER1
*
SWILA21  MVC   ZERRONU,GOTOFOR
         B     INCOROP
*
SWILA3   LR    R5,R2                   COMPUTE ADDR OF IGN-TAB-ENTR
         AR    R5,R2
         AR    R5,R2                   3+ZIGNEMB
         LA    R5,GPTAB(R5)            GPTAB+3*ZIGNEMB
         CLI   2(R5),0                 TEST IF FORGROUP
         BE    SWILA4                  NO
         MVC   *+9(1),2(R5)            ADDR ACTUAL ENTRY IN FSTAB
         OI    0(R1),X'20'             SET BIT IND BRANCH OUT OF FS
SWILA4   MVC   ALIGNH(2),0(R5)
         L     R2,ALIGN                LOAD EMBRACING IGN
         B     SWILA2
*
*        CRITI
*
*        ROUTINE ENTRED WHEN A CRITICAL IDENTIFIER IS FOUND IN
*        ITAB. IF THE IDENTIFIER APPEARS BETWEEN FOR AND DO A NEW
*        CHAINED CRIDTAB-ENTRY IS MADE. OTHERWISE ONLY THE
*        FSTAB-ENTRY IS TREATED
*
*        WORK REG R1,R8
*
CRITI    CLI   ZFORTEST,X'00'          CRITICAL IDENTIFIER IN FOR-LIST?
         BNE   CRITIF                  YES
*                                      IDENTIFIER NOT FOR-LIST-ELEMENT
         CLC   ZARSPO(4),ZARNO         CURRENTLY HANDLING SUBSCR EXPR?
         BC    7,LETTER1               YES
         L     R1,PFA                  POINTER TO LAST CRIDTAB ENTRY
CRITI1   CLC   1(3,R1),8(R7)           SCAN CRIDTAB FOR LAST ENTRY
         BE    CRITI2                  FOUND
         SH    R1,KH9
         B     CRITI1
*
CRITI2   CLI   0(R3),X'16'             IDENTIFIER FOLLOWED BY ASSIGN ?
         BE    CRITI3                  YES
         TM    4(R1),X'80'             CONTROLLED VARIABLE ?
         BZ    LETTER1                 NO, RETURN
         SR    R5,R5                   ADDR FSTAB ENTRY
         IC    R5,0(,R1)
         LA    R5,ZFOSTA(R5)
         OI    0(R5),X'80'             ELEMENTARY LOOP
         B     LETTER1                 RETURN
*
*        IDENTIFIER FOLLOWED BY ASSIGNMENT
*
CRITI3   SR    R5,R5                   GET ADDR OF FSTAB ENTRY
         IC    R5,0(,R1)
         LA    R5,ZFOSTA(R5)
         TM    4(R1),X'80'             CONTROLLED VARIABLE ?
         BO    CRITI4                  YES
         OI    0(R5),NORMAL            NORMAL LOOP
         TM    4(R1),X'40'             MORE CHAINED ENTRIES ?
         BZ    LETTER1                 NO, RETURN
         MVC   ALIGNH(2),5(R1)         GET ADDR OF NEXT ENTRY
         L     R1,ALIGN
         A     R1,ZFOCRI
         B     CRITI3                  HANDLE NEXT ENTRY
*
CRITI4   OI    0(R5),X'40'             INDICATE ASSIGN TO CTR VAR
         B     LETTER1
*
*        TREATMENT OF CRIT ID IN FOR-LIST
*
CRITIF   BAL   R14,CRIMA               MAKE CRIDTAB ENTRY
         L     R8,PFA                  PTR TO LAST CRIDTAB ENTRY
         LR    R1,R8                   START SCAN FOR PREVIOUS ENTRY
CRITIF1  SH    R1,KH9
         C     R1,PFANO                THERE A PREVIOUS ENTRY ?
         BNH   LETTER1                 NO, DELETED AT CRIDTAB OVERFLOW
         CLC   1(3,R1),1(R8)           PREVIOUS ENTRY ?
         BNE   CRITIF1                 NO
*                                      PREVIOUS ENTRY IN CRIDTAB FOUND
         BAL   R15,PUTCHAIN            CHAIN NEW ENTRY TO PREVIOUS
         TM    4(R8),X'80'             NEW ENTRY CONTROLLED VARIABLE
         BZ    CRITIN                  NO
*
*        TREATMENT OF CONTROLLED VARIABLE
*
CRITIC   SR    R5,R5
         IC    R5,0(,R1)               FSN OF CHAINED CRIDTAB ENTRY
         LA    R5,ZFOSTA(R5)           ADDR OF CHAINED FSTAB ENTRY
         TM    4(R1),X'80'             CHAINED ENTRY CONTROLLED ?
         BO    CRITIC1                 YES
         OI    0(R5),NORMAL            INDICATE NORMAL LOOP
         TM    4(R1),X'40'             MORE CHAINED ENTRIES ?
         BZ    LETTER1                 NO, RETURN
         MVC   ALIGNH(2),5(R1)         GET ADDR OF NEXT CHAINED ENTRY
         L     R1,ALIGN
         A     R1,ZFOCRI
         B     CRITIC
*
CRITIC1  OI    0(R5),X'40'             BIT FOR ASSIGN TO CONTROL VAR
         B     LETTER1
*
*        TREATMENT OF NON-CONTROLLED VARIABLE
*
CRITIN   TM    4(R1),X'80'             CHAINED ENTRY CONTROLLED ?
         BO    CRITIN1                 YES
         TM    4(R1),X'40'             MORE CHAINED ENTRIES ?
         BZ    LETTER1                 NO
         MVC   ALIGNH(2),5(R1)         GET ADDR OF CHAINED ENTRY
         L     R1,ALIGN
         A     R1,ZFOCRI
         B     CRITIN
*
CRITIN1  SR    R5,R5                   GET ADDR OF CHAINED FSTAB ENTRY
         IC    R5,0(,R1)
         LA    R5,ZFOSTA(R5)
         CLC   0(1,R1),ZFSN            CHAINED ENTRY PART OF ACTIVE FOR
         BE    CRITIN2                 YES
         CLC   ZARSPO(4),ZARNO         CURRENTLY HANDLING A SUBSCRIPT ?
         BNE   LETTER1                 YES, RETURN
         OI    0(R5),X'80'             SET ELEMENTARY LOOP
         B     LETTER1
*
CRITIN2  OI    0(R5),NORMAL            INDICATE NORMAL LOOP
         B     LETTER1
*
*        PUTCHAIN
*
*        ROUTINE TO CHAIN NEW CRIDTAB ENTRY TO PREVIOUS
*
*        RETURN VIA R15
*        RECEIVED REG R8, R1
*
PUTCHAIN OI    4(R8),X'40'             BIT FOR PREVIOUS CRITICAL IDENT
         OI    4(R1),X'20'             BIT FOR SUBSEQUENT CRIT IDENT
         L     R6,ZFOCRI               CRIDTAB START ADDR
         LR    R5,R1                   GET BACKWARD CHAIN
         SR    R5,R6
         ST    R5,ALIGN
         MVC   5(2,R8),ALIGNH
         LR    R5,R8                   GET FORWARD CHAIN
         SR    R5,R6
         ST    R5,ALIGN
         MVC   7(2,R1),ALIGNH
         BR    R15                     RETURN
*
*        CRIMA
*
*        SUBROUTINE TO MAKE A NEW CRIDTAB ENTRY
*
*        IN CASE OF CRIDTAB OVERFLOW THE ROUTINE CRIFLOW IS
*        ENTRED TO DELETE FROM CRIDTAB ALL ENTRIES BELONG TO THE
*        MOST EMBRACING FOR-STATEMENT. CRIFODEL IS ENTERED IF AN
*        ARRAY ELEMENT IS HANDLED
*
*        RETURN VIA R14
*        RECEIVED REG R7 POINTER TO ACTUELL ITAB ENTRY
*        WORK REG R8
*        SUBROUTINE CRIFLOW, LETRAF, CRIFODEL, SUCRIDEL
*
CRIMA    TM    7(R7),X'04'             ARRAY ?
         BO    CRIMA1                  YES, NO OPTIMIZATION POSSIBLE
         L     R8,PFA                  CURRENT CRIDTAB PTR
         TM    ZFORTEST,X'C0'          CONTROLLED VARIABLE ?
         BO    CRIMAC                  YES
*
*        TREATMENT OF 'NOT CONTROLLED' VARIABLE
*
         C     R8,PFAMAX               CRIDTAB OVERFLOW ?
         BE    CRIMAN1                 YES
CRIMAN2  LA    R8,9(,R8)               UPDATE CURRENT PTR
         MVI   4(R8),X'00'             FLAG BYTE SHOWS NO CNTL VARIABLE
         TM    7(R7),X'02'             INTEGER ?
         BZ    CRIMA2                  YES
         L     R5,ZFSPTR               ADDR FSTAB ENTRY
         OI    0(R5),NOCOUNT           CLASSIFY AS NOT COUNTING LOOP
*
CRIMA2   MVC   1(3,R8),8(R7)           MOVE ADDR PART TO CRIDTAB
         MVC   0(1,R8),ZFSN            MOVE FSN TO CRIDTAB
         LR    R5,R7                   GET RELATIVE ADDR IN ITAB
         S     R5,ZIBSTAO
         ST    R5,ALIGN                ITAB RELATIVE ADDR
         MVC   5(2,R8),ALIGNH
         OI    6(R7),X'06'             TURN ON SPECIAL USE BITS
         ST    R8,PFA                  SAVE CURRENT PTR
         BR    R14                     RETURN
*
CRIMAN1  BAL   R15,CRIFLOW             DELETE MOST EMBRACING FOR-STAT
         C     R8,PFANO                ALL CRIDTAB DELETED ?
         BNE   CRIMAN2                 NO
         MVI   ZFORTEST,0              NO MORE CRIDTAB ENT TO BE DONE
         BR    R14
*
CRIMAC   TM    7(R7),X'02'             INTEGER ?
         BZ    CRIMAC1                 YES
         L     R5,ZFSPTR               CURRENT FSTAB PTR
         OI    0(R5),X'80'             SET BIT FOR ELEMENTARY LOOP
CRIMAC4  C     R8,PFAMAX               OVERFLOW ?
         BE    CRIMAC2                 YES
CRIMAC3  LA    R8,9(,R8)               UPDATE CURRENT PTR
         MVI   ZFORTEST,X'80'          INDICATE CONTROL VAR TREATED
         MVI   4(R8),X'80'             SET BIT FOR CONTROLLED VAR
         B     CRIMA2
*
CRIMAC1  C     R8,PFANO                NESTED FOR STATEMENT ?
         BE    CRIMAC3                 NO
         BAL   R9,LETRAF               MAKE LVTAB ENTRY
         B     CRIMAC4
*
CRIMAC2  BAL   R15,CRIFLOW             CRIDTAB OVERFLOW
         B     CRIMAC3
*
CRIMA1   L     R5,ZFSPTR               CURRENT FSTAB PTR
         OI    0(R5),NORMAL            NORMAL LOOP
         MVI   ZFORTEST,0              NO MORE CRIDTAB ENTRIES
         BR    R14                     RETURN
*
*        CRIFLOW
*
*        THE SUBROUTINE IS ENTERED AT CRIDTAB OVERFLOW TO
*        DELETE ALL CRIDTAB ENTRIES BELONGING TO THE MOST
*        EMBRACING FOR STATEMENT
*
*        RETURN VIA R15
*        WORK REG R1, R2, R9
*
CRIFLOW  L     R2,ZFOCRI               CRIDTAB START ADDR
         CLC   0(1,R2),0(R8)           ALL ENTRIES FROM SAME FOR ST ?
         BE    DELCRIV                 YES, DELETE WHOLE CRIDTAB
         MVC   FSNEMBR(1),0(R2)        SAVE MOST EMBRACING FSN
CRIFLOW1 CLC   0(1,R2),FSNEMBR         ENTRY OF MOST EMBRACING FOR ST ?
         BNE   CRIFLOW2                NO
         TM    4(R2),X'20'             SUBSEQUENT CHAINED ENTRY ?
         BO    CRIFLOW3                YES
         MVC   ALIGNH(2),5(R2)         ADDR ITAB ENTRY
         L     R5,ALIGN
         A     R5,ZIBSTAO
         NI    6(R5),X'F9'             SET SPECIAL USE BITS TO 00
CRIFLOW4 LA    R2,9(0,R2)              ADDR NEXT CRIDTAB ENTRY
         B     CRIFLOW1
*
CRIFLOW3 MVC   ALIGNH(2),7(R2)         ADDR CHAINED ENTRY
         L     R5,ALIGN
         A     R5,ZFOCRI
         NI    4(R5),X'B0'             TURN OFF BIT FOR PRECEED ENTRY
         MVC   5(2,R5),5(R2)           INSERT RELATIVE ITAB ADDR
         B     CRIFLOW4
*
CRIFLOW2 SR    R5,R5                   ADDR FSTAB ENTRY OF DEL FOR
         IC    R5,FSNEMBR
         LA    R5,ZFOSTA(R5)
         OI    0(R5),NORMAL            NORMAL LOOP
         L     R9,ZFOCRI               CRIDTAB START ADDR
         LR    R1,R2
         SR    R1,R9                   GET LENGTH OF DELETED PART
*
CRIFLOW5 TM    4(R2),X'40'             PRECEEDING CRIDTAB ENTRY ?
         BZ    CRIFLOW6                NO
         MVC   ALIGNH(2),5(R2)         DECREASE CHAIN ADDR
         L     R5,ALIGN
         SR    R5,R1
         ST    R5,ALIGN
         MVC   5(2,R2),ALIGNH
CRIFLOW6 TM    4(R2),X'20'             SUBSEQUENT CRITAB ENTRY ?
         BZ    CRIFLOW7
         MVC   ALIGNH(2),7(R2)         DECREASE CHAIN ADDR
         L     R5,ALIGN
         SR    R5,R1
         ST    R5,ALIGN
         MVC   7(2,R2),ALIGNH
CRIFLOW7 MVC   0(9,R9),0(R2)           MOVE ENTRY DOWN IN CRIDTAB
         CR    R2,R8                   LAST ENTRY ?
         BE    CRIFLOW8                YES
         LA    R2,9(,R2)               ADDR NEXT ENTRY
         LA    R9,9(,R9)
         B     CRIFLOW5
*
CRIFLOW8 SR    R8,R1                   GET ADDR OF LAST CRIDTAB-ENT
         BR    R15
*
*        DELCRIV
*
*        ROUTINE TO DELETE ALL ENTRIES IN CRIDTAB AND TURN OFF
*        THE SPECIAL USE BITS OF CORRESPONDING ITAB ENTRY. ALL
*        FOR-STATEMENTS WITH CRIDTAB ENTRIES WILL BE CLASSIFIED
*        NORMAL
*
*        RETURN VIA R15
*        INITIALIZED REG R8
*
DELCRIV  L     R5,ZFOCRI               CRIDTAB START ADDR
DELCRIV1 SR    R6,R6                   ADDR FSTAB ENTRY
         IC    R6,0(,R5)
         LA    R6,ZFOSTA(R6)
         OI    0(R6),NORMAL            CLASSIFIED NORMAL
         TM    4(R5),X'40'             IDEN CRIT IN EMBR FOR-STAT ?
         BO    DELCRIV2                YES, ITAB ENTRY ALREADY NON CRI
         MVC   ALIGNH(2),5(R5)         ADDR ITAB ENTRY
         L     R6,ALIGN
         A     R6,ZIBSTAO
         NI    6(R6),X'F9'             CLEAR SPEC USE BITS
DELCRIV2 C     R5,PFA                  LAST CRIDTAB ENTRY ?
         BE    DELCRIV3                YES
         LA    R5,9(,R5)               ADDR NEXT CRIDTAB ENTRY
         B     DELCRIV1
*
DELCRIV3 L     R8,PFANO
         ST    R8,PFA
         BR    R15
*
*        CRIFODEL
*
*        ROUTINE TO DELETE THE CRIDTAB ENTRIES OF THE LAST FOR
*        STATEMENT
*
*        RETURN VIA R15 WORK REG R8
*
CRIFODEL L     R8,PFA                  POINTER TO LAST CRIDTAB-ENTRY
         MVC   CRIFODS+1(1),0(R8)      INSERT FOR STATEMENT NUMBER
CRIFOD1  C     R8,PFANO                CRIDTAB EMPTY ?
         BE    CRIFOD4                 YES, RETURN
CRIFODS  CLI   0(R8),0                 NEW FORSTATEMENT, OLD FSN INSER
         BNE   CRIFOD4                 YES, RETURN
         TM    4(R8),X'40'             IDENTIFIER USED IN EMBR FOR-ST
         BO    CRIFOD2                 YES
         MVC   ALIGNH(2),5(R8)         CLEAR SPEC USE BITS IN CRIDTAB
         L     R5,ALIGN
         A     R5,ZIBSTAO              ABSOLUTE ITAB ADDR
         NI    6(R5),X'F9'             CLEAR SPECIAL USE BITS IN ITAB
CRIFOD3  SH    R8,KH9                  POINT TO PRECEEDING ENTRY
         B     CRIFOD1
*
CRIFOD2  L     R5,ZFOCRI               TURN OFF BIT FOR SUBSEQ ENTRY
         MVC   ALIGNH(2),5(R8)         ADDR OF PREVIOUS CRIDTAB-ENT
         A     R5,ALIGN
         NI    4(R5),X'CF'             TURN OFF BIT FOR SUBSEQ ENTRY
         B     CRIFOD3                 GET NEXT ENTRY
*
CRIFOD4  ST    R8,PFA
         BR    R15
*
*        SUCRIDEL
*
*        THE SUBROUTINE IS ENTERED WHEN UNOPTIMIZABLE SUBSCRIPT
*        EXPRESSION IS FOUND. A SCAN BETWEEN THE TWO LAST
*        SUBSCRIPT OPERATORS IS DONE IN THE OUTPUT BUFFER. IF A
*        CONTROLLED CRITICAL IDENTIFIER IS FOUND, CORRESPONDING
*        ENTRY IN FSTAB IS MADE ELEMENTARY. OTHERWISE NO ACTION
*
*        RETURN VIA R15
*        WORK REG R1, R2, R14
*
SUCRIDEL CLC   PFA(4),PFANO            CRIDTAB EMPTY
         BER   R15                     YES, RETURN
         LA    R2,1(,R4)               ADDR OF LAST SUBSCR OPERAND
         L     R1,ZBRACK               ADDR OF FIRST SUBSCR OPERAND
SUCRID1  LA    R1,1(,R1)               CHECK NEXT BYTE
SUCRID2  CR    R1,R2                   END OF SCAN ?
         BNLR  R15                     YES, RETURN
         TM    0(R1),X'80'             AN OPERAND FOUND ?
         BZ    SUCRID1                 NO
         TM    0(R1),X'06'             CRITICAL IDENTIFIER ?
         BO    SUCRID4                 YES
SUCRID3  LA    R1,5(,R1)               ADDR NEXT ELEMENT
         B     SUCRID2
*
*        TREATMENT OF CRITICAL IDENTIFIERS
*
SUCRID4  L     R14,PFA                 ADDR OF LAST CRIDTAB ENTRY
         LA    R14,9(,R14)
SUCRID5  SH    R14,KH9                 FIND IDENTIFIER IN CRIDTAB
         CLC   1(3,R14),2(R1)          IDENTIFIER FOUND ?
         BNE   SUCRID5                 NO
*
SUCRID6  TM    4(R14),X'80'            CONTROLLED VARIABLE ?
         BZ    SUCRID7                 NO
         LA    R5,ZFOSTA               ADDR OF FSTAB
         MVC   *+9(1),0(R14)           DISPLACEMENT EQUALS FOR NUMBER
         OI    0(R5),X'80'             ELEMENTARY LOOP
         B     SUCRID3
*
*        FIND CHAINED CONTROLLED VARIABLE
*
SUCRID7  TM    4(R14),X'40'            ANY CHAINING ?
         BZ    SUCRID3                 NO
         MVC   ALIGNH(2),5(R14)        CRIDTAB CHAIN
         L     R14,ALIGN
         A     R14,ZFOCRI              ADDR CHAINED ENTRY
         B     SUCRID6
*
*        LETRAF
*
*        MAKE ENTRIES IN LVTAB CORRESPONDING TO ALL
*        SUBSCRIPTABLE NESTED FOR-STATEMENTS
*
*        RETURN VIA R9
*        RECIEVED REG R7, WORK REG R1, R2, R6
*
LETRAF   CLI   ZLVOV,X'FF'             TABLE OVERFLOW OCCURED ?
         BER   R9                      YES
         L     R1,PFA                  ADDR OF LAST CRIDTAB ENTRY
LETRAF1  LR    R2,R1
         LA    R5,ZFOSTA
         MVC   *+9(1),0(R1)            ADDR ACTUAL FSTAB ENTRY
         TM    0(R5),NOSUOP
         BO    LETRAF2
         L     R6,ZLEVA
         C     R6,ZLESTA               WRITE BEEN ISSUED ?
         BNE   LETRAF5                 NO
         BAL   R5,CHECK                YES, CHECK
         CLC   LVLENGTH(4),LVTAB40S    MORE OUTPUT ALLOWED ?
         BNL   LETRAF4                 NO
         LH    R5,LVCNT                STEP RECORD COUNTER
         LA    R5,1(,R5)
         STH   R5,LVCNT
LETRAF5  LA    R6,4(,R6)
         MVC   0(1,R6),0(R1)           PLUG IN FS NUMBER
         MVC   1(3,R6),8(R7)           PLUG IN ADDR PART OF CUR ID
         C     R6,ZLEMAX               LVTAB FILLED UP ?
         BE    LETRAF3                 YES
LETRAF6  ST    R6,ZLEVA
LETRAF2  SH    R1,KH9                  GET NEXT CRIDTAB ENTRY
         C     R1,PFANO                BEGINNING OF CRIDTAB ?
         BER   R9                      YES, RETURN
         CLC   0(1,R1),0(R2)           AN ENTRY IN SAME FS ?
         BE    LETRAF2                 SAME
         B     LETRAF1                 NEW
*
LETRAF3  BAL   R5,CHECK                CHECK POSSIBLE WRITE
         L     R5,LVSTRT               WRITE START ADDR
         L     R6,LVTAB30S             LENGTH OF WRITE
         BAL   R15,WRITE               WRITE
         L     R5,LVLENGTH             LENGTH OF LVTAB
         A     R5,LVTAB30S             BUFFER LENGTH
         ST    R5,LVLENGTH
         L     R6,ZLESTA               START ADDR OF LVTAB
         B     LETRAF6
*
LETRAF4  BAL   R15,TABOFLO
         BAL   R15,MOVERRO
         BR    R9
*
*        SUSCRITE
*
*        ROUTINE TO CHECK IF AN SUBSCRIPT EXPRESSION IS
*        OPTIMIZABLE IN WHAT CASE AN SUTAB-ENTRY IS DONE, OTHER
*        SUBROUTINE SUCRIDEL IS ENTERED BEFORE RETURN
*
*        RETURN VIA R9
*        WORK REG R2, R1, R2, R7, R8, R1
*        SUBROUTINE LINKS R15, R14, R14
*
SUSCRITE L     R1,ZBRACK               INITIALIZE CURRENT POINTER
         LR    R5,R4                   ADDR OF LAST BYTE OF SUBSCR
         SH    R5,KH5                  ADDR OPERATOR BEFOR LAST OPD
         ST    R5,SUBEND
         CLI   1(R1),XFMINUS           SUBSCRIPT START WITH + OR -
         BH    SUB1                    NO
         LA    R1,1(,R1)               POINT TO BYTE BEFORE OPERAND
SUB1     C     R1,SUBEND               ANY OPERAND IN SUBSCRIPT ?
         BHR   R9                      NO, RETURN
         BAL   R15,OPERANDR            TEST OPERAND
         C     R1,SUBEND               END OF SUBSCRIPT
         BE    SUBONE
         CLI   6(R1),XFASTER           WHAT FOLLOWS FIRST OPERAND
         BL    SUBPM                   PLUS OR MINUS ?
         BE    SUBAST                  ASTERISK
*
*        UNOPTIMIZABLE SUBSCRIPT EXPRESSION
*
SUBNOOP  BAL   R15,SUCRIDEL            HANDLE UNOPTIMIZABLE EXPRESSION
         BR    R9                      RETURN
*
*        ONLY ONE OPERAND
*
SUBONE   LTR   R8,R2                   CONTROLLED VARIABLE ?
         BP    SUBONE3                 YES
         MVC   ADDEND(6),0(R1)         OPERAND IS ADDEND
         MVC   FACTOR(6),ZEROELEM      SET FACTOR TO ZERO
         L     R8,ZFOCRI               ADDR OF LAST CRIDTAB ENTRY
         L     R2,ZARSPO               ADDR CURRENT ARIDSTAB ENTRY
SUBONE1  SR    R5,R5                   GET FSN
         IC    R5,0(,R8)
         STC   R5,OLDFSN
         LA    R6,ZFOSTA(R5)           ADDR FSTAB ENTRY
         TM    0(R6),X'40'             SUBSCRIPT OPTIMIZATION POSSIBLE
         BO    SUBONE2
         L     R2,ZARSPO               ADDR LAST ARIDSTACK ENTRY
         LA    R6,SPTAB(R5)            ADDR SPTAB ENTRY
         CLC   0(1,R6),0(R2)           SCOPE OF ARRAY OK
         BL    SUBONE2                 NO
         TM    ADDEND+2,X'30'          CONSTANT ?
         BZ    SUBONE4                 YES
         CLC   0(1,R6),ADDEND+3        SCOPE TEST OF ADDEND
         BL    SUBONE2                 NOT OK
SUBONE4  BAL   R14,SUTABENT            MAKE SUTAB ENTRY
SUBONE2  C     R8,PFA                  END OF CRIDTAB
         BER   R9                      YES, RETURN
         LA    R8,9(,R8)               FIND ENCLOSED FOR STATEMENT
OLDFSN   EQU   *+1
         CLI   0(R8),0                 ENTRY TO SAME FOR STATEMENT ?
         BE    SUBONE2                 YES, CHECK NEXT ENTRY
         B     SUBONE1                 NO, POSSIBLY NEW SUTAB ENTRY
*
*        OPERAND IS CONTROLLED VARIABLE
*
SUBONE3  MVC   FACTOR(1),0(R1)         OPERATOR TO FACTOR
         MVC   FACTOR+1(5),ONEELEM+1   SET FACTOR TO ONE
SUBONE5  MVC   ADDEND(6),ZEROELEM      SET ADDEND TO ZERO
         B     SUBFIN1
*
*        FIRST OPERAND FOLLOWED BY + OR -
*
SUBPM    MVC   ADDEND(6),0(R1)         FIRST OPERAND PROBABLY ADDEND
         LR    R7,R2                   SAVE CRIDTAB POINTER
         LA    R1,6(0,R1)              ADDR SIGN OF SECOND OPERAND
         BAL   R15,OPERANDR            CHECK SECOND OPERAND
         C     R1,SUBEND               END OF SUBSCRIPT ?
         BE    SUBPM1                  YES
         CLI   6(R1),XFASTER           ASTERISK SHOULD FOLLOW
         BNE   SUBNOOP                 NOT OPTIMIZABLE
         BAL   R14,SUBMULT             CHECK MULTIPLICATION
         B     SUBFIN                  TERMINATE
*
SUBPM1   CR    R2,R7                   WHAT IS SECOND OPERAND ?
         BL    SUBPM3                  ADDEND
         BE    SUBPM4                  NOT OPTIMIZABLE EXPRESSION
         LR    R8,R2                   ADDR CRIDTAB ENTRY OF CONTR
         MVC   FACTOR(1),0(R1)         SIGN OF FACTOR
SUBPM2   MVC   FACTOR+1(5),ONEELEM+1   SET FACTOR TO ONE
         B     SUBFIN
*
SUBPM3   LR    R8,R7                   SECOND OPERAND ADDEND, SHIFT
         LR    R7,R2
         MVC   FACTOR(1),ADDEND        SIGN OF FACTOR
         MVC   ADDEND(6),0(R1)
         B     SUBPM2
*
SUBPM4   LTR   R8,R7                   CONTROLLED VARIABLE ?
         BZR   R9                      NO
         B     SUBFIN4                 YES
*
*        FIRST OPERAND FOLLOWED BY ASTERISK
*
SUBAST   BAL   R14,SUBMULT             CHECK MULTIPLICATION
         C     R1,SUBEND               END OF SUBSCRIPT ?
         BE    SUBONE5                 YES, SET ADDEND TO ZERO
         CLI   6(R1),XFMINUS           PLUS OR MINUS
         BH    SUBNOOP                 NO, NO SUBSCRIPT OPTIMIZATION
         LA    R1,6(,R1)               ADDR SIGN
         BAL   R15,OPERANDR            CHECK OPERAND
         MVC   ADDEND(6),0(R1)         SAVE ADDEND
         LR    R7,R2                   LAST OPERAND WAS ADDEND
*
SUBFIN   LTR   R7,R7                   ADDEND CONTROLLED VARIABLE ?
         BZ    SUBFIN1                 NO
         SR    R5,R5                   YES, INDICATE ELEMENTARY LOOP
         IC    R5,0(,R7)
         LA    R6,ZFOSTA(R5)
         OI    0(R6),X'80'
         CR    R8,R7                   OPTIMIZATION POSSIBLE ?
         BNH   SUBFIN4                 NO
SUBFIN1  SR    R5,R5                   FSN OF CONTROLLED VAR TO RE6
         IC    R5,0(0,R8)
         L     R2,ZARSPO               ADDR LAST ARIDSTAB-ENTRY
         LA    R6,ZFOSTA(R5)           ADDR FSTAB-ENTRY
         TM    0(R6),X'40'             SUBSCRIPT OPTIMIZATION POSS ?
         BO    SUBFIN4                 NO, NO OPTIMIZATION
         LA    R6,SPTAB(R5)            ADDR SPTAB-ENTRY
         CLC   0(1,R6),0(R2)           SCOPE OF ARRAY OK ?
         BL    SUBFIN4                 NO, NO OPTIMIZATION
         TM    FACTOR+2,X'30'          FACTOR CONSTANT ?
         BZ    SUBFIN2                 YES
         CLC   0(1,R6),FACTOR+3        SCOPE OF FACTOR OK
         BL    SUBFIN4                 NO, NO OPTIMIZATION
SUBFIN2  TM    ADDEND+2,X'30'          ADDEND CONSTANT ?
         BZ    SUBFIN3                 YES
         CLC   0(1,R6),ADDEND+3        SCOPE OF ADDEND OK ?
         BL    SUBFIN4                 NO, NO OPTIMIZATION
SUBFIN3  BAL   R14,SUTABENT            MAKE SUTAB ENTRY
         BR    R9                      RETURN
*
SUBFIN4  SR    R5,R5
         IC    R5,0(0,R8)              FSN OF CONTROLLED VARIABLE
         LA    R6,ZFOSTA(R5)           ADDR FSTAB ENTRY
         OI    0(R6),X'80'             ELEMENTARY LOOP
         BR    R9
*
*        OPERANDR
*
*        SUBROUTINE TO SUSCRITE TO CHECK WHAT FOLLOWS AN
*        OPERATOR IF NOT AN INTEGER OPERAND AN ERROR EXIT IS
*        TAKEN. ELSE THE SETTING OF REGISTER R2 SHOWS TYPE OF
*        OPERAND
*
*        INITIALIZED REG R2
*
OPERANDR TM    1(R1),X'80'             OPERAND ?
         BZ    SUBNOOP                 NO
         TM    2(R1),X'CE'             INTEGER ?
         BM    SUBNOOP                 NO
         TM    1(R1),X'06'             CRITICAL IDENTIFIER ?
         BO    OPERAND1                YES
OPERAND4 SR    R2,R2                   INDICATE NO-CONTROLLED VARIABLE
         BR    R15                     RETURN
*
*        OPERAND CONTROLLED VARIABLE ?
*
OPERAND1 L     R2,PFA                  ADDR OF LAST CRIDTAB ENTRY
         LA    R2,9(,R2)               INITIALIZE LOOP
OPERAND2 SH    R2,KH9                  GET NEXT ENTRY
         CLC   1(3,R2),3(R1)           OPERAND FOUND
         BNE   OPERAND2                NO, GET NEXT CRIDTAB ENTRY
*
OPERAND3 TM    4(R2),X'80'             CONTROLLED VARIABLE ?
         BOR   R15                     YES
         TM    4(R2),X'40'             PRECEEDING CRITICAL IDENTIFIER ?
         BZ    OPERAND4                NO
         MVC   ALIGNH(2),5(R2)         GET CRIDTAB CHAIN
         L     R2,ALIGN                GET ADDR OF CHAINED ENTRY
         A     R2,ZFOCRI
         B     OPERAND3                CHECK THIS ENTRY
*
*        SUBMULT
*
*        SUBROUTINE TO SUSCRITE TO CHECK WHAT FOLLOWS AN
*        ASTERISK IF NOT INTEGER FACTOR TIMES INTEGER CONTROLLED
*        VARIABLE AN ERROR EXIT IS TAKEN. OTHERWISE REGISTER R8
*        AND BUCKET FACTOR ARE INITIALIZED
*
*        INITIALIZED R8
*
SUBMULT  MVC   FACTOR(6),0(R1)         MOVE OPERAND TO FACTOR
         LR    R8,R2                   SAVE PTR
         LA    R1,6(,R1)               ADDR NEXT OPERAND
         BAL   R15,OPERANDR            CHECK SECOND OPERAND
         CR    R2,R8                   WHICH OPERAND IS FACTOR ?
         BH    SUBMULT2                FIRST
         BE    SUBNOOP                 NONE, NO OPTIMIZATION
         MVC   FACTOR+1(5),1(R1)       SECOND, MOVE OPERAND TO FACTOR
SUBMULT1 LTR   R2,R2                   FACTOR CONTROLLED VARIABLE
         BZR   R14                     NO, RETURN
         SR    R5,R5                   SET FOR-LOOP OF FACTOR ELEMENT
         IC    R5,0(0,R2)              FSN OF FACTOR
         LA    R6,ZFOSTA(R5)           ADDR FSTAB-ENTRY
         OI    0(R6),X'80'             MAKE LOOP ELEMENTARY
         BR    R14                     RETURN
*
SUBMULT2 LR    R5,R2                   EXCHANGE REGISTERS
         LR    R2,R8
         LR    R8,R5
         B     SUBMULT1
*
*        SUTABENT
*
*        SUBROUTINE TO SUBSCRITE TO MAKE AN SUTAB ENTRY
*
SUTABENT L     R1,ZSUTAPO              CURRENT SUTAB PTR
         C     R1,ZSUDAD               A WRITE MACRO BEEN GIVEN ?
         BNE   SUTAB1                  NO
         BAL   R5,CHECK                CHECK LAST OPERATION ON SYSUT3
         CLC   SULENGTH(4),SUTAB40S    TABLE OVERFLOW ?
         BNL   SUTAB4                  YES
         LH    R5,SUCNT                STEP RECORD COUNTER
         LA    R5,1(,R5)
         STH   R5,SUCNT
SUTAB1   LA    R1,14(,R1)              ADDR NEW SUTAB-ENTRY
         ST    R1,ZSUTAPO              SAVE SUTAB PTR
*                                      MAKE SUTAB ENTRY
         MVC   0(1,R1),0(R8)           INSERT FSN
         MVC   1(3,R1),0(R2)           ADDR PART OF ARRAY
         MVC   4(3,R1),FACTOR+3        ADDR PART OF FACTOR
         MVC   7(3,R1),ADDEND+3        ADDR PART OF ADDEND
         MVC   10(1,R1),ZPOSIX+1       SUBSCRIPT NUMBER
         CLI   FACTOR,XFMINUS          SIGN OF FACTOR MINUS ?
         BNE   SUTAB2                  NO
         OI    10(R1),X'80'            YES, SET 1 BIT TO ONE
SUTAB2   CLI   ADDEND,XFMINUS          SIGN OF ADDEND MINUS ?
         BNE   SUTAB3                  NO
         OI    10(R1),X'40'            YES, SET 2 BIT TO ONE
SUTAB3   MVC   11(3,R1),4(R2)          POSITION OF OPENING BRACKET
         C     R1,ZSUTMAX              SUTAB FILLED UP
         BLR   R14
         BAL   R5,CHECK                CHECK POSSIBLE WRITE
         L     R5,SUSTRT               WRITE START ADDR
         L     R6,SUTAB30S             LENGTH OF WRITE
         BAL   R15,WRITE               WRITE
         L     R5,SULENGTH             GET FULL SUTAB LENGTH
         A     R5,SUTAB30S
         ST    R5,SULENGTH
         MVC   ZSUTAPO(4),ZSUDAD       INITIALIZE CURRENT SUTAB PTR
         BR    R14
*
SUTAB4   BAL   R15,TABOFLO             HANDLE TABLE OVERFLOW
         BAL   R15,MOVERRO
         B     SUBFIN4                 NO OPT, MAKE LOOP ELEMENTARY
*
OUCHA    STM   R14,R2,REGSAVE          SAVE REGISTERS
LOUCHAF  B     LOUCHA7                 BRANCH ONLY IF FIRST RECORD
*
         CHECK SWRITE
*
LOUCHA6  CLC   ZARSPO(4),ZARNO         BUFFER EXCHANGE IN SUBSCR EXPR ?
         BNE   LOUCHA1                 YES
LOUCHA5  MVI   1(R4),XFZETA            ZETA TERMINATES O-BUFFER
         L     R4,ZOBWRITE
         LR    R6,R4
         BCTR  R4,0                    INITIALIZE R4
LOUCHA4  L     R5,SRCE3S               OUTPUT BUFFER LENGTH
         SH    R5,KH12                 SET END PTRS
         AR    R5,R6
         ST    R5,ZFILE9
         LA    R5,3(,R5)
         ST    R5,ZFILE6
         LA    R5,1(,R5)
         ST    R5,ZFILE5
         LA    R5,2(,R5)
         ST    R5,ZFILE3
         LA    R5,1(,R5)
         ST    R5,ZFILE2
         LA    R5,1(,R5)
         ST    R5,ZFILE1
         MVC   ZOBWRITE(4),ZOBWORK     ZOBWRITE = ZOBWORK
         ST    R6,ZOBWORK              START ADDR OF NEW OUT BUFFER
         LH    R5,ZOUTCOT              OUTPUT RECORD COUNTER
         CH    R5,KH255                TOO MUCH SOURCE OUTPUT ?
         BE    LOUCHA8                 YES
         LA    R5,1(,R5)
         STH   R5,ZOUTCOT
         L     R5,AUT2DCB              R5 -> SYSUT2 DCB
         L     R6,ZOBWRITE             AREA ADDR
*
         WRITE SWRITE,SF,(R5),(R6)
*
         LM    R14,R2,REGSAVE          RESTORE REGS
         BR    R15
*
LOUCHA1  L     R5,ZBRACK               GET CURRENT LEN OF SUBSCRIPT
         LR    R6,R4
         SR    R6,R5                   SUBSCRIPT LENGTH
         BM    LOUCHA5                 NOTHING TO SAVE
         CH    R6,KH18                 SUBSCRIPT ALREADY TOO LONG ?
         BH    LOUCHA2                 YES
         STC   R6,LOUCHAM+1            LENGTH OF SUBSCRIPT
         STC   R6,LOUCHAL+3
         L     R6,ZOBWRITE             START ADDR OF NEW OUT-BUFFER
LOUCHAM  MVC   0(1,R6),0(R5)           SAVE SUBSCRIPT
         MVI   0(R5),XFZETA            REPLACE OPENING BRACKET BY ZETA
LOUCHAL  LA    R4,0(0,R6)              DISPLACEMENT LENGTH OF SUB
         ST    R6,ZBRACK               ADDR OF OPENING BRACKET
         CLI   0(R6),XFLSQBR           SUBSCRIPT OPERATOR OPEN BRAC ?
         BNE   LOUCHA4                 NO
         L     R5,ZARSPO               YES, UPDATE ARIDSTAB ENTRY
         LH    R6,ZOUTCOT              OUTPUT RECORD COUNTER
         LA    R6,1(,R6)               UPDATE
         STC   R6,4(,R5)               STORE RECORD COUNTER
         MVC   5(2,R5),ZERO            SET RELATIVE ADDR TO ZERO
         L     R6,ZOBWRITE             START ADDR OF NEW BUFFER
         B     LOUCHA4
*
LOUCHA2  BAL   R15,SUCRIDEL
         MVI   ZCLOBRA,X'FF'           ZCLOBRA IS SET TO X'FF'
         L     R5,ZOBWRITE             START ADDR OF NEW BUFFER
         BCTR  R5,0
         ST    R5,ZBRACK
         B     LOUCHA5                 BRANCH TO LOUCHA5
*
LOUCHA7  MVI   LOUCHAF+1,X'00'         TURN OFF SWITCH
         B     LOUCHA6
*
LOUCHA8  MVC   ZERRONU,TOOLONG
         MVC   ZBEGERR,ZENDERR
         BAL   R15,MOVERRO
         B     LOMEGA3
*
*        ICHA
*
*        THE ROUTINE IS ENTERED WHEN OPERATOR ZETA (END OF INPUT
*        BUFFER) IS FOUND. IF NECESSARY A PART OF THE OLD BUFFER
*        IS SAVED IMMEDIATLY BEFORE THE NEW BUFFER. START
*        ADDR OF SAVED AREA IS STORED IN ZIBWORK
*
*        RETURN VIA R15
*
ICHA     STM   R14,R2,REGSAVE          SAVE REGISTERS
*
         CHECK SREAD                   CHECK LAST READ
*
ICHA1    L     R5,AUT1DCB              R5 -> SYSUT1 DCB
         L     R6,ZIBRUN               AREA ADDR
*
         READ  SREAD,SF,(R5),(R6)
*
         LM    R14,R2,REGSAVE          RESTORE REGISTERS
         L     R3,ZIBREAD              BEGIN OF ACTIVITED BUFFER
         MVC   ZIBREAD(4),ZIBRUN       EXCHANGE POINTERS
         ST    R3,ZIBRUN
         BR    R15
*
ICHAI    STM   R14,R2,REGSAVE
         B     ICHA1
*
*        ITABMOVE
*
*        ITABMOVE IS ENTERED AT THE BEGINNING OF A NEW PROGRAM
*        BLOCK AND DURING INITIALIZATION. THE READ OF NEXT ITAB-
*        RECORD IS ALREADY INITIALIZED. IF A MOVE OF NEXT RECORD
*        IS NECESSARY IT IS DONE BY THE SUBROUTINE ITABM. ALL
*        CURRENT ITAB-POINTERS IS UPDATED
*
*        RETURN VIA R15
*        WORKREG R7, R8
*        SUBROUTINE ITABM, MOVERRO
*
ITABMOP  MVI   LETTER+1,X'00'          TURN OFF PROCEDURE SWITCH
ITABMOVE STM   R14,R2,REGSAVE
         CLI   IOBYTE,READM            INITIALIZED READ OPERATION ?
         BNE   ITAB4                   NO
*
         CHECK RITAB                   YES, CHECK
*
         MVI   IOBYTE,READC            SET READ CHECK MASK
ITAB4    L     R7,ZITREC               ADDR OF BLOCKBEGIN
         MVC   6(2,R7),ZCURITLE        ITAB REC LENGTH OF EMBR BLOCK
         MVC   ZCURITLE(2),0(R7)       LENGTH OF BLOCK
         L     R8,ZCURITEN             A MOVE IS NECESSARY ?
         LA    R8,11(,R8)
         CR    R8,R7
         BE    ITAB1                   NO, MOVE
*
*        MOVE ITAB RECORD
*
         LH    R6,ZCURITLE             LENGTH OF ITAB RECORD
         EX    R6,ITABMEX              MOVE FIRST PART
         LR    R5,R6
         AR    R7,R5                   END ADDR OF MOVED RECORD
         AR    R5,R8                   END ADDR OR UNMOVED RECORD
         SH    R7,KH1792               PREPARE MOVE
         SH    R5,KH1792               PREPARE MOVE
         SRA   R6,8                    PREPARE BRANCH
         SLA   R6,2
         B     *+4(R6)
*
         B     ITABM8                  +00
         B     ITABM7                  +04
         B     ITABM6                  +08
         B     ITABM5                  +12
         B     ITABM4                  +16
         B     ITABM3                  +20
         B     ITABM2                  +24
         MVC   0(256,R5),0(R7)         +28
*
ITABM2   MVC   256(256,R5),256(R7)
ITABM3   MVC   512(256,R5),512(R7)
ITABM4   MVC   768(256,R5),768(R7)
ITABM5   MVC   1024(256,R5),1024(R7)
ITABM6   MVC   1280(256,R5),1280(R7)
ITABM7   MVC   1536(256,R5),1536(R7)
ITABM8   EQU   *
*
ITAB1    LH    R5,ZCURITLE             GET ADDR OF LAST ITAB ENTRY
         A     R5,ZCURITEN             ACTUAL RECORD LENGTH + PREV ADD
         ST    R5,ZCURITEN
         LA    R5,11(,R5)              ADDR OF FIRST FREE BYTE
         ST    R5,ZITREC
         CLC   10(1,R8),PBN+1          LAST ITAB RECORD ?
         BE    ITAB7                   YES
         MVC   ALIGNH(2),2(R8)         LENGTH OF NEXT BLOCK
         A     R5,ALIGN                END ADDR OF NEXT BLOCK
         C     R5,ZITEND               ITAB OVERFLOW ?
         BH    ITAB10                  YES
         CLI   IOBYTE,READC            WHICH I/O STATUS ?
         BE    ITAB6                   CHECKED READ OPERATION
         BL    ITAB5                   CHECKED WRITE OPERATION
*
         CHECK TWRITE                  INITIALIZED WRITE OPERATION
*
ITAB5    EQU   *
         L     R1,AUT3DCB              R1 -> SYSUT3 DCB
*
         NOTE  (1)                     SAVE ID OF LAST BLOCK
*
         ST    R1,NOTEW
         L     R1,AUT3DCB              R1 -> SYSUT3 DCB
         MVI   NOTER+3,X'01'           ADDR NEXT ITAB BLOCK
*
         POINT (1),NOTER
*
ITAB6    L     R5,AUT3DCB              R5 -> SYSUT3 DCB
         L     R6,ZITREC               READ START ADDR
*
         READ  RITAB,SF,(R5),(R6),'S'
*
         MVI   IOBYTE,READM            SET ITAB READ
ITAB7    LM    R14,R2,REGSAVE          RESTORE REGS
         MVC   CURPBN(1),10(R8)        SAVE CURRENT PBN
         BR    R15                     RETURN
*
ITAB10   ST    R3,ZBEGERR              ERROR EDIT
         ST    R3,ZENDERR
         MVC   ZERRONU,ITABOVER
         BAL   R15,MOVERRO
         B     LOMEGA3
*
ITABREAD STM   R14,R2,REGSAVE
         LA    R8,GENER                 ADDR DUMMY HEADER
         B     ITAB6
*
ITABMEX  MVC   0(1,R8),0(R7)
*
*        INVALID OPERAND FOUND
*
*        SET SYNTAX CHECK MODE AND GIVE ERROR MESSAGE
*
INCOROP  OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         LA    R0,ZIDEX+12
INCOROP5 LR    R9,R3
INCOROP1 CLI   0(R3),X'2E'             END OF OPERAND ?
         BL    INCOROP2                YES
         BE    INCOROP3                STRING OR LOGICAL VALUE
         CLI   0(R3),XFZETA            END OF INPUT BUFFER ?
         BE    INCOROP4                YES
         LA    R3,1(,R3)               PROCEED SCAN FOR OPERAND END
         B     INCOROP1
*
INCOROP4 LR    R1,R3
         BAL   R15,MOVE
         BAL   R15,ICHA
         B     INCOROP5
*
INCOROP2 LR    R1,R3
         BAL   R15,MOVE
         ST    R8,ZENDERR
         MVC   ZBEGERR,OPSTART
         BAL   R15,MOVERRO
         LA    R7,ZALLPU               REPLACE INCOR ID  BY ALL PUB ID
         B     LETTER1
*
INCOROP3 MVC   0(6,R3),ZPOINT          REPLACE INT NAME BY SIX PERIODS
         LA    R3,6(,R3)
         B     INCOROP1
*
*        MOVERRO
*
*        ERROR EDITING ROUTINE
*
*        OUTPUTS ALWAYS FIXED PART CONTAINING LENGTH OF ENTRY,
*        ERROR NUMBER AND SEMICOLON COUNTER. SOMETMES VARIABLE
*        PART WHOSE START ADDR IS STORED IN ZBEGERR AND (END
*        ADDR + 1) IN ZENDERR
*
*        RETURN VIA R15
*
MOVERRO  L     R5,NEXTERR
         C     R5,ENDPOOL              ERROR POOL OVERFLOW ?
         BH    MOVERRO2                YES
         L     R6,ZENDERR              GET LENGTH OF VARIABLE PART
         S     R6,ZBEGERR
         CH    R6,KH12                 LENGTH EXCEEDS MAXIMUM ?
         BNH   MOVERRO1                NO
         LH    R6,KH12                 YES, SET LENGTH TO MAX
MOVERRO1 LA    R6,4(,R6)               LENGTH OF FULL ERROR ENTRY
         AR    R5,R6                   GET ADDR OF NEXT ERROR ENTRY
         ST    R5,NEXTERR
         SR    R5,R6
         STC   R6,0(,R5)               FIXED PART OF ERROR ENTRY, LEN
         MVC   1(1,R5),ZERRONU+1       ERROR NUMBER
         MVC   2(2,R5),SEMCNT          SEMICOLON COUNTER
         SH    R6,KH5                  ANY VARIABLE PART ?
         BM    MOVERRO3                NO
         STC   R6,MOVERROM+1           LENGTH OF MOVE
         L     R6,ZBEGERR              START ADDR OF ADDITIONAL PART
MOVERROM MVC   4(1,R5),0(R6)           MOVE ADDITIONAL PART
MOVERRO3 BR    R15
*
MOVERRO2 MVI   0(R5),X'04'             TERMINATING ERROR ENTRY
         MVI   1(R5),TOOMANY
         MVC   2(2,R5),SEMCNT
         LA    R5,4(,R5)
         ST    R5,NEXTERR
         B     LOMEGA3
*
MOVEP    LR    R5,R3                   FIELD OF ONE BYTE
         SR    R5,R9
         BNZ   MOVE
         LTR   R7,R7                   POINT FOLLOWED BY ZERO ?
         BMR   R15                     YES, NO SYNTAX ERROR
         LA    R5,NUMBER(R7)           ADDR IMPLIED POINT
         CR    R5,R8                   POINT TERMINATE NUMBER
         BE    QTORLT1                 YES
*
MOVE     SR    R1,R9                   LENGTH OF MOVE
         LR    R5,R8                   CALCULATE END ADDR
         AR    R5,R1
         CR    R5,R0                   FULL MOVE POSSIBLE ?
         BH    MOVE1                   NO
         EX    R1,MOVEEX               MOVE
         LR    R8,R5                   STEP PTR
         BR    R15                     RETURN
*
MOVE1    LR    R5,R0                   CALCULATE LEN OF POSSIBLE MOVE
         SR    R5,R8
         EX    R5,MOVEEX
         LR    R8,R0
         BR    R15                     RETURN
*
MOVEEX   MVC   0(0,R8),0(R9)
*
CHECK    CLI   IOBYTE,WRITEM           INITIALIZED WRITE OPERATION
         BNER  R5                      NO, RETURN
         STM   R14,R2,REGSAVE          SAVE REGS
*
         CHECK TWRITE                  CHECK LAST WRITE
*
         MVI   IOBYTE,WRITEC           SET WRITE CHECK MASK
         LM    R14,R2,REGSAVE          RESTORE REGS
         BR    R5
*
WRITE    STM   R14,R2,REGSAVE
         CLI   IOBYTE,READC            WHICH I/O STATUS ?
         BL    WRITE2                  CHECKED WRITE OPERATION
         BE    WRITE1                  CHECKED READ OPERATION
*
         CHECK RITAB                   INITIALIZED READ OPERATION
*
WRITE1   L     R1,AUT3DCB              R1 -> SYSUT3 DCB
*
         NOTE  (1)                     SAVE ID OF LAST BLOCK
*
         ST    R1,NOTER
         L     R1,AUT3DCB              R1 -> SYSUT3 DCB
         MVI   NOTEW+3,X'01'           ADDR NEXT OUTPUT BLOCK
*
         POINT (1),NOTEW
*
WRITE2   EQU   *
         L     R0,AUT3DCB              R0 -> SYSUT3 DCB
         LA    R6,4(,R6)               ADD KEY LENGTH
*
         WRITE TWRITE,SF,(R0),(R5),(R6)
*
         MVI   IOBYTE,WRITEM           SET WRITE MASK
         LM    R14,R2,REGSAVE
         BR    R15
*
TABOFLO  L     R5,PFA                  ADDR OF LAST CRIDTAB ENTRY
TABOFLO1 SR    R6,R6
         IC    R6,0(,R5)               FOR STATEMENT NUMBER
         LA    R6,FSTAB(R6)            ADDR FOR STATEMENT ENTRY
         OI    0(R6),NOSUOP
         SH    R5,KH9
         C     R5,PFANO                END OF CRIDTAB ?
         BNH   TABOFLO1                NO
         MVI   ZLVOV,X'FF'             SET ERROR SWITCH
         MVC   ZARSPO(4),ZARNO         SKIP ALL ARIDSTAB ENTRIES
         ST    R3,ZBEGERR              ERROR EDITING
         ST    R3,ZENDERR
         MVC   ZERRONU,TABOVER
         BR    R15
*
DIGIT19  LA    R8,NUMBER
         LA    R0,NUMBER+19            MAX LENGTH OF CONSTANT + 1
         SR    R7,R7
         LR    R9,R3                   SET FIELD START
         MVI   SCATEST,0
DIG191   LA    R1,1(,R3)               TRT START
DIG192   SR    R2,R2
DIG193   TRT   0(256,R1),DIG19
         BZ    DIGL19                  MORE THAN 256 BYTES
         LR    R3,R1                   UPDATE R3
         B     *(R2)                   BRANCH TABLE
         B     DECPTM                  +04
         B     SCAFACTM                +08
         B     QTORLT                  +12
         B     ZETAM                   +16
         B     RHO                     +20
         B     OTHER                   +24
*
DECPTM   BAL   R15,MOVE
         AR    R7,R1                   EXPONENT CORRECTION
         B     DECPOIN1
*
SCAFACTM BAL   R15,MOVE
         AR    R7,R1                   EXPONENT CORRECTION
         B     SCA1
*
QTORLT   BAL   R15,MOVE
         AR    R7,R1                   NUMBER OF INTEGERS
QTORLT1  ST    R7,ZEXCORR
         BAL   R2,CERR                 REBUILD CONSTANT
         MVC   ZERRONU,INVOP
         B     INCOROP
*
ZETAM    BAL   R15,MOVE
         AR    R7,R1                   EXPONENT CORRECTION
         BAL   R15,ICHA
         LR    R1,R3
         LR    R9,R3
         B     DIG192
*
OTHER    C     R8,NSTART               BUFFER EXCHANGE WITHIN INTEGER ?
         BNE   OTHER1                  YES
         LR    R7,R3                   COMPUTE NUMBER OF DIGITS
         SR    R7,R9
         B     INTCON
*
OTHER1   BAL   R15,MOVE
         AR    R7,R1                   GET NUMBER OF DIGITS
         LR    R1,R8                   ADJUST POINTERS
         LA    R9,NUMBER
         B     INTCON
*
DIGL19   LA    R1,256(,R1)             UPDATE INPUT PTR
         B     DIG193
*
DIGIT0   LA    R8,NUMBER
         LA    R0,NUMBER+19            MAX LENGTH OF CONSTANT + 1
         SR    R7,R7
         MVI   SCATEST,0
         LA    R1,1(,R3)
DIG01    SR    R2,R2
DIG02    TRT   0(256,R1),DIG0
         BZ    DIGL0                   MORE THAN 256 BYTES
         LR    R3,R1
         LR    R9,R3
         B     *(R2)
         B     DIG191                  +04
         B     QTORLT                  +08
         B     DECPOIN1                +12
         B     SCA0                    +16
         B     ZETA0                   +20
         B     RHO                     +24
         B     OTHOP0                  +28
*
SCA0     LD    0,ZEROFLOA              FLOATING ZERO
         B     SCA1
*
ZETA0    BAL   R15,ICHA                CHANGE INPUT BUFFER
         LR    R1,R3
         B     DIG01
*
OTHOP0   C     R4,ZFILE5               OUTPUT BUFFER FULL ?
         BNH   OTHOP01                 NO
         BAL   R15,OUCHA               YES
OTHOP01  MVC   3(3,R4),ZERO            ADDR PART OF INTERNAL NAME
         MVC   1(2,R4),ZINTYP          INDICATE INTEGER
         LA    R4,5(,R4)
         B     GENTEST
*
DIGL0    LA    R1,256(,R1)             UPDATE INPUT PTR
         B     DIG02
*
DECPOIN  LA    R8,NUMBER
         LA    R0,NUMBER+19            MAX LENGTH OF CONSTANT + 1
         SR    R7,R7
         MVI   SCATEST,0
DECPOIN1 LA    R9,1(,R3)
DECPOIN2 LA    R1,1(,R3)
DECPOIN3 SR    R2,R2
DECPOIN4 TRT   0(256,R1),DECPO
         BZ    DECPOINL                MORE THAN 256 BYTES
         LR    R3,R1
         B     *(R2)
         B     DECP0                   +04 ZERO
         B     QTORLTP                 +08
         B     DECPSCA                 +12 SCALE FACTOR
         B     DECPZETA                +16 ZETA
         B     DECPOT                  +20 OTHER OPERATOR
*
DECP0    CR    R9,R3                   ZERO FOLLOWING POINT ?
         BNE   DECPOIN2                NO
         C     R8,NSTART               PRECEEDING SIGNIFICANT DIGIT ?
         BNE   DECPOIN2                YES
         BCTR  R7,0                    NO, DECREASE EXPONENT
         B     DECPOIN1
*
QTORLTP  BAL   R15,MOVE
         B     QTORLT1
*
DECPSCA  BAL   R15,MOVEP               SYNTAX CHECK AND MOVE
         C     R8,NSTART               ZERO ?
         BNE   SCA1                    NO
         LD    0,ZEROFLOA              YES, FLOATING ZERO
         B     SCA1
*
DECPZETA BAL   R15,MOVE
         BAL   R15,ICHA
         LR    R9,R3
         LR    R1,R3
         B     DECPOIN3
*
DECPOT   ST    R7,ZEXCORR
         BAL   R15,MOVEP               SYNTAX CHECK AND MOVE
         C     R8,NSTART               ZERO ?
         BNE   REALCON                 NO, CONVERT NUMBER
         LD    0,ZEROFLOA              YES, NUMBER IS FLOATING ZERO
         B     REALHAN                 MAKE A CONSTANT POOL ENTRY
*
DECPOINL LA    R1,256(,R1)             UPDATE INPUT PTR
         B     DECPOIN4
*
SCAFACT  SR    R7,R7
         LD    0,ZONEFLOA              MANTISSA SET TO ONE
         LA    R8,NUMBER               NO MANTISSA DIGIT
SCA1     ST    R8,ZTO
         ST    R7,ZEXCORR
         LA    R8,SCAWORK
         LA    R0,SCAWORK+9
         MVI   SCATEST,X'10'           SCALE FACTOR PRESENT
         MVI   SCALE,0                 CLEAR OLD SIGN
SCA20    LA    R9,1(,R3)
SCA2     LA    R1,1(,R3)
SCA3     SR    R2,R2
SCA4     TRT   0(256,R1),SCAFAC
         BZ    SCAL                    MORE THAN 256 BYTES
         LR    R3,R1
         B     *(R2)
         B     SCA19                   +04
         B     SCAZERO                 +08
         B     SCASIGN                 +12
         B     SCAQL                   +16
         B     SCAZETA                 +20
         B     SCAOT                   +24
*
SCA19    OI    SCATEST,SF19            SIGNIFICANT DIGIT PRESENT
         B     SCA2
*
SCAZERO  TM    SCATEST,SF19            ANY SIGNIFICANT DIGIT ?
         BO    SCA2                    YES
         OI    SCATEST,SFL0            LEADING ZERO
         B     SCA20
*
SCASIGN  EQU   *
         TM    SCATEST,SFLSIGN         LEADING SIGN ?
         BNZ   SCAOT                   NO, TREAT AS OTHER OPERATOR
         MVC   SCALE(1),0(R3)          SAVE SIGN
         OI    SCATEST,SFSIGN          SIGNED SCALE FACTOR
         B     SCA20
*
SCAZETA  BAL   R15,MOVE                SAVE FIELD
         BAL   R15,ICHA
         LR    R1,R3
         LR    R9,R3
         B     SCA3
*
SCAOT    TM    SCATEST,SFDIGIT         ANY DIGIT ?
         BZ    SCAQL                   NO, ERROR MESSAGE
         TM    SCATEST,SF19            ANY SIGNIFICANT DIGIT ?
         BZ    SCAOT1                  NO
         BAL   R15,MOVE
         S     R8,SCAWORKA
         EX    R8,SCAPACK
         MVN   ZPACK+7(1),SREF         SET SIGN TO PLUS
         CLI   SCALE,XFMINUS           MINUS SIGN ?
         BNE   *+10                    NO
         MVN   ZPACK+7(1),SREF+1       YES, REPLACE PLUS SIGN
         CVB   R5,ZPACK                CONVERT
         AR    R7,R5                   GET EXPONENT
*
SCAOT1   ST    R8,ZTOSCA
         L     R8,ZTO
         B     REALCON
*
SCAPACK  PACK  ZPACK(8),SCAWORK(0)
*
SCAQL    BAL   R15,MOVE
         S     R8,SCAWORKA             SCALE FACTOR LENGTH
         ST    R8,ZTOSCA
         L     R8,ZTO
         BAL   R2,CERR                 REBUILD CONSTANT
         MVC   ZERRONU,INVOP
         B     INCOROP
*
SCAL     LA    R1,256(,R1)             UPDATE INPUT PTR
         B     SCA4
*
*        CONSTANT ERROR ROUTINE
*
CERR     TM    SCATEST,PRECERR         CONSTANT ALREADY REBUILT ?
         BOR   R2                      YES
         L     R5,ZEXCORR              NUMBER OF INTEGERS IN MANTISSA
         LTR   R5,R5                   LEADING ZEROS AFTER POINT ?
         BM    CERR1                   YES
         CH    R5,KH12                 CONSTANT TOO LONG ?
         BNH   CERRA                   NO
         LH    R5,KH12                 SET MAXIMAL LENGTH
CERRA    EX    R5,CERREX               MOVE CONSTANT INTEGERS
         A     R5,OPSTART              ADDR DECIMAL POINT
         MVI   0(R5),XFDECPT           INSERT POINT
         BCTR  R8,0
         CR    R8,R5                   ANY DECIMAL POINT ?
         BE    *+8                     NO
         LA    R8,1(,R8)               PREVENT POINT OVERLAY
         B     CERR2
*
CERR1    MVI   ZIDEX,XFDECPT           INSERT POINT
CERR2    TM    SCATEST,SF              SCALE FACTOR PRESENT ?
         BZ    CERR3                   NO
         LA    R0,NUMBER+21
         MVC   0(2,R8),SCALEQ          INSERT QUOTE AND SIGN
         TM    SCATEST,SFSIGN          SIGNED SCALE FACTOR ?
         BO    *+6                     YES
         BCTR  R8,0
         LA    R8,2(,R8)
         L     R1,ZTOSCA
         LA    R1,1(,R1)               SCALE FACTOR LENGTH
         LA    R9,SCAWORK
         AR    R1,R9                   SCALE FACTOR END ADDR
         BAL   R15,MOVE                MOVE SCALE FACTOR
*
CERR3    LA    R5,ZIDEX+12
         CR    R8,R5                   MORE THAN 12 CHARACTERS ?
         BNH   *+6                     NO
         LR    R8,R5                   YES, SET LENGTH TO 12
         ST    R8,ZENDERR
         MVC   ZBEGERR,OPSTART
         BR    R2
*
CERREX   MVC   ZIDEX(0),NUMBER
*
INTCON   CH    R7,KH10                 NUMBER OF DIGITS ?
         BL    INTCON1                 NO
         BH    INTCON2                 YES, REAL CONSTANT
         CLC   0(10,R9),MAXINT         MAXIMAL INTEGER
         BH    INTCON2                 GREATER, REAL CONSTANT
INTCON1  BCTR  R7,0
         EX    R7,INTPACK              PACK
         MVN   ZPACK+7(1),SREF         SET PLUS SIGN
         CVB   R2,ZPACK                PACK
         B     INTHAN
*
INTCON2  ST    R9,ZBEGERR              GIVE ERROR MESSAGE
         ST    R1,ZENDERR
         MVC   ZERRONU,RANGEINT
         BAL   R15,MOVERRO
         ST    R7,ZEXCORR
         L     R8,NSTART
         BAL   R15,MOVE
         B     REALCON
*
INTPACK  PACK  ZPACK(8),0(0,R9)        LENGTH IN R1
*
REALCON  LR    R6,R8                   GET LENGTH OF CONSTANT
         S     R6,NSTART
         BZ    REALCON7
*
*        CONVERT MANTISSA TO FLOATING FORM
*
         LD    0,ZEROFLOA              ZERO REG
         LR    R9,R6                   NUMBER OF DIGITS
         SR    R7,R9                   UPDATE EXPONENT CORRECTION
         CH    R9,KH9                  CONVERSION IN ONE STEP ?
         BH    REALCON1                NO
         BCTR  R9,0
         EX    R9,REPACK               PACK
REALCON2 MVN   ZPACK+7(1),SREF         SET PLUS SIGN
         CVB   R5,ZPACK                CONVERT TO BINARY
         ST    R5,ZFLOFIEL+4           CONVERT TO FLOATING FORM
         AD    0,ZFLOFIEL              GET NORMALIZED FLOATING NUMBER
         C     R6,NREAL                MORE DIGITS THAN ALLOWED ?
         BNH   REALCON3                NO
         BAL   R2,CERR                 REBUILD CONSTANT
         MVC   ZERRONU,PRECREAL
         BAL   R15,MOVERRO
         OI    SCATEST,PRECERR         INDICATE PRECISION ERROR
         B     REALCON3
*
*        CONVERT EXPONENT TO FLOATING FORM
*
REALCON7 LTDR  0,0
         BZ    REALHAN                 NUMBER OF DIGITS
REALCON3 LPR   R9,R7                   UPDATE EXPONENT CORRECTION
         BZ    REALHAN                 CONVERSION IN ONE STEP ?
         LR    R1,R9                   NO
         LA    R2,ZEXTABP-8
         LTR   R7,R7                   PACK
         BP    REALCON6                SET PLUS SIGN
         LA    R2,ZEXTABN-8            CONVERT TO BINARY
REALCON6 CH    R9,KH64                 CONVERT TO FLOATING FORM
         BNL   REALCON5                GET NORMALIZED FLOATING NUMBER
         N     R9,SCALEMSK
         BZ    REALCON8                MORE DIGITS THAN ALLOWED ?
         MD    0,56(R9,R2)             NO
REALCON8 SLA   R1,3
         N     R1,SCALEMSK
         BZ    REALCON9                INDICATE PRECISION ERROR
         MD    0,0(R1,R2)
REALCON9 LTDR  0,0                     EXPONENT UNDERFLOW
         BZ    REALERR1
         B     REALHAN
*
REALCON5 MD    0,120(,R2)              10 ** +- 64
         LTDR  0,0
         BZ    REALERR1
         SH    R9,KH64                 ADJUST EXPONENT
         B     REALCON6
*
REALCON1 SH    R9,KH10
         CH    R9,KH9                  CONSTANT TOO LONG ?
         BL    REALCONA                NO
         BCTR  R9,0                    YES, SKIP THE NINETEENTH DIGIT
         AH    R7,KH1                  UPDATE R7
REALCONA EX    R9,REPACK               PACK FIRST PART
         MVN   ZPACK+7(1),SREF         SET PLUS SIGN
         CVB   R5,ZPACK                CONVERT TO BINARY
         ST    R5,ZFLOFIEL+4           CONVERT TO FLOATING FORM
         AD    0,ZFLOFIEL              NORMALIZE
         MD    0,ZTEN9                 MULTIPLY BY 10 ** 9
         LA    R9,NUMBER+1(R9)         ADDR SECOND PART
         PACK  ZPACK(8),0(9,R9)        PACK SECOND PART
         B     REALCON2                TERMINATE CONVERSION
*
REPACK   PACK  ZPACK(8),NUMBER(0)      LENGTH OF NUMBER IN R9
*
REALERR  LA    R5,REALHAN              SET EXIT ADDR
         ST    R5,ZSTO
         MVC   9(3,R1),ZSTO+1          MODIFIED OLD PSW IN PIE
         BAL   R2,CERR                 REBUILD CONSTANT
         MVC   ZERRONU,RANGEREA
         BAL   R15,MOVERRO
         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         BR    R14
*
REALERR1 BAL   R2,CERR                 REBUILD CONSTANT
         MVC   ZERRONU,RANGEREA
         BAL   R15,MOVERRO
         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         B     REALHAN
*
*        INTEGER HANDLING
*
INTHAN   C     R4,ZFILE5               SPACE ENOUGH IN OUTPUT BUFFER ?
         BNH   INTHANA                 YES
         BAL   R15,OUCHA               NO, CHANGE BUFFER
INTHANA  MVC   1(2,R4),ZINTYP          FIRST TWO BYTES OF INTERNAL NAME
INTHANR  CH    R2,KH15                 NUMBER GREATER THAN 15 ?
         BH    INTHAN2                 YES
         SLA   R2,2                    NO, MULTIPLY BY 4
         STH   R2,ZLIRE
         MVI   3(R4),0                 OUTPUT
         MVC   4(2,R4),ZLIRE           FIELD
         LA    R4,5(,R4)               UPDATE OUTPUT POINTER
         B     GENTEST                 RETURN
*
INTHAN2  TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    INTHAN1                 YES
         LA    R14,INTHAN6             INITIALIZE INTEGER SEARCH
         LA    R8,4
         L     R9,ZWP
         L     R7,ZDWP
         L     R1,ZLITSTA
         SR    R1,R8
         SR    R9,R8
INTHAN6  BXH   R1,R8,INTHAN3           EXIT FOR END OF SEARCH
         C     R2,0(,R1)               INTEGER FOUND ?
         BNER  R14                     NO, PROCEED SEARCH
*
INTHAN1  S     R1,ZKOPOOL              GET REL ADDR
         STH   R1,ZLIRE                IN CONST POOL
         MVC   3(1,R4),KBN+1           INSERT CONSTANT BLOCK NUMBER
         MVC   4(2,R4),ZLIRE           DISPLACEMENT ADDR
         LA    R4,5(,R4)
         B     GENTEST
*
INTHAN3  AR    R9,R8
         CR    R9,R7                   DOUBLE WORD BOUNDARY ?
         BE    INTHAN9                 YES
*
INTHAN4  LA    R1,4(,R1)               SCAN REST OF CONSTANT POOL
         CR    R1,R7                   CURRENT END OF CONSTANT POOL ?
         BE    INTHAN10                YES
         C     R2,0(,R1)               LITERAL FOUND ?
         BNE   INTHAN4                 NO
         BE    INTHAN1
*
INTHAN10 LR    R1,R9
         LR    R9,R7
INTHAN7  ST    R9,ZWP                  SAVE PTR
         ST    R2,0(,R1)               MAKE LITERAL POOL ENTRY
         B     INTHAN1
*
INTHAN9  C     R9,ZKOPEND              END OF LITERAL POOL ?
         BNL   INTHAN8
         C     R9,ZTEXTCO              WRITE TXT CARD ?
         BL    INTHAN5                 NO
         BAL   R14,TXTTRAF             WRITE
INTHAN5  LA    R9,4(,R9)               UPDATE POINTERS
         A     R7,LREAL
         ST    R7,ZDWP                 SAVE UPDATE ZDWP
         B     INTHAN7
*
INTHAN8  CLC   ZKBNMAX(2),KH255        LAST CONST POOL
         BE    INTHAN11                YES, GIVE ERROR MESSAGE
         L     R9,ZDWP
         BAL   R14,TXTTRAF             OUTPUT TXT RECORD
         BAL   R14,CPOLEX              CONSTANT POOL EXCHANGE
         L     R1,ZKOPOOL              START ADDR OF CONSTANT POOL
         LA    R9,4(,R1)               UPDATE POINTERS
         LR    R7,R1
         A     R7,LREAL
         ST    R9,ZWP
         ST    R7,ZDWP
         ST    R1,ZLITSTA
         ST    R2,0(,R1)
         B     INTHAN1
*
INTHAN11 ST    R1,ZBEGERR              GIVE
         ST    R1,ZENDERR              ERROR
         MVC   ZERRONU,MANYCON
         BAL   R15,MOVERRO             GOTO ERROR RTN
         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         B     INTHAN1
*
REALHAN  C     R4,ZFILE5               SPACE ENOUGH IN OUTPUT BUFFER ?
         BNH   REALHANA                YES
         BAL   R15,OUCHA               NO, CHANGE BUFFER
REALHANA MVC   1(2,R4),ZREALTYP        FIRST TWO BYTES OF INTERNAL NAME
         CLI   ZFORTEST,0              IN FOR LIST ?
         BE    REALHAN1                NO
         L     R5,ZFSPTR               ADDR FSTAB ENTRY
         OI    0(R5),NOCOUNT           CLASSIFY AS NO COUNTING LOOP
REALHAN1 TM    COMPFLGS,LNG            LONG PRECISION ?
         BO    REALH                   YES, BRANCH
         STE   0,ZSTO                  START ROUNDING
         MVC   ROUND(1),ZSTO
         AD    0,ROUND                 ROUND
         STE   0,ZSTO                  SHORT, TREAT AS INTEGER
         L     R2,ZSTO
         B     INTHANR
*
REALH    L     R1,ZLITSTA              INITIALIZE LITERAL SEARCH
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    INTHAN1                 YES
         LA    R6,8
         LR    R8,R6
         SR    R1,R6
         L     R9,ZWP
         L     R7,ZDWP
         CR    R9,R7
         BE    REALH2
         SR    R7,R6
         LA    R14,REALH3
REALH3   BXH   R1,R8,REALH4            EXIT AT END OF SEARCH
         CD    0,0(,R1)                LITERAL FOUND ?
         BNER  R14                     NO
*
REALH4   LA    R14,REALH5
         SR    R1,R6
REALH5   BXH   R1,R6,REALH6            EXIT AT END OF SCAN
         CD    0,0(,R1)                CONSTANT FOUND ?
         BNER  R14                     NO
         B     INTHAN1                 YES
*
REALH6   AR    R7,R6
         C     R7,ZKOPEND              END OF LITERAL POOL ?
         BNL   REALH10                 YES
REALH8   AR    R7,R6                   UPDATE ZDWP
         ST    R7,ZDWP
         STD   0,0(,R1)
         B     INTHAN1
*
REALH7   BAL   R14,TXTTRAF             OUTPUT TXT
REALH9   AR    R8,R7                   UPDATE ZWP
         ST    R8,ZWP
         B     REALH8
*
REALH2   LA    R14,REALH21
         SR    R7,R6
REALH21  BXH   R1,R6,REALH22           EXIT AT END OF SCAN
         CD    0,0(,R1)                LITERAL FOUND ?
         BNER  R14                     NO
         B     INTHAN1                 YES
*
REALH22  AR    R7,R6
         C     R7,ZKOPEND              END OF LITERAL POOL
         BNL   REALH10
         C     R7,ZTEXTCO              TXT TO BE PUT OUT ?
         BL    REALH9                  NO
         B     REALH7                  YES
*
REALH10  CLC   ZKBNMAX(2),KH255        LAST CONSTANT POOL ?
         BE    REALH11                 YES
         L     R9,ZDWP
         BAL   R14,TXTTRAF             OUTPUT TXT
         BAL   R14,CPOLEX              CONSTANT POOL EXCHANGE
         L     R1,ZKOPOOL              START ADDR OF CONSTANT POOL
         LA    R7,8(,R1)               UPDATE PTRS
         ST    R7,ZDWP
         ST    R7,ZWP
         ST    R1,ZLITSTA
         STD   0,0(,R1)                LITERAL ENTRY
         B     INTHAN1
*
REALH11  ST    R3,ZBEGERR              TOO MANY LITERALS, MESSAGE
         ST    R3,ZENDERR
         MVC   ZERRONU,MANYCON
         BAL   R15,MOVERRO
         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         B     INTHAN1
*
*        CONSTANT POOL EXCHANGE
*
CPOLEX   L     R15,ZKOPOOL             UPDATE
         ST    R15,ZLITSTA
         AH    R15,TXTPUT
         ST    R15,ZTEXTCO             TXT RECORD POINTER
         LH    R15,ZKBNMAX
         LA    R15,1(,R15)
         STH   R15,ZKBNMAX             CONSTANT POOL
         STH   R15,KBN                 NUMBER
         BR    R14                     RETURN
*
*        TRANSFER TXT RECORD
*
TXTTRAF  STM   R14,R6,TXTSAV           SAVE REGS
         L     R2,ZTEXTCO
         SH    R2,TXTPUT               ADDR OUTPUT TXT
         LR    R5,R9                   CALCULATE LENGTH OF TXT
         SR    R5,R2
         STH   R5,TXTLE
         LR    R5,R9                   GET NEW PUT ADDR
         AH    R5,TXTPUT
         ST    R5,ZTEXTCO
         L     R6,PRPT                 LOAD PROGRAM PTR
         TM    COMPFLGS+1,NLOAD+NDECK  NOLOAD AND NODECK ?
         BO    TXTLE2                  YES, BRANCH
         BAL   R14,GENTXT              OUTPUT OF TEXT
TXTLE    DC    H'0'                    INSERT LENGTH OF TEXT
TXTLE1   ST    R6,PRPT                 STORE PROGRAM PTR
         LM    R14,R6,TXTSAV           RESTORE REGS
         BR    R14                     RETURN
*
TXTLE2   AR    R6,R5                   UPDATE PROGRAM PTR
         B     TXTLE1
*
*        GENERATE TXT RECORDS
*
GENTXT   LA    R4,2(,R14)              COMPUTE RETURN ADDR
         LH    R14,0(,R14)             LOAD LENGTH GIVEN IN CALL
         LA    R3,TXTT                 INDICATE TXT CALL
         L     R1,SAVOUTA              LOAD ADDR OF OUT RECORD
         CLC   1(3,R1),1(R3)           RECORD RIGHT TYPE ?
         BNE   GEN3                    NO, CALL IOR NEW
         CLC   10(2,R1),12(R3)         RECORD FILLED ?
         BNL   GEN3                    YES, CALL FOR NEW
GEN6     LA    R15,56
         LH    R0,10(,R1)              R0 = LENGTH OF DATA IN REC
         SR    R15,R0                  R15 = EMPTY POS LEFT IN RECORD
         CR    R15,R14                 ENOUGH SPACE LEFT ?
         BL    GEN6A                   NO
         LR    R15,R14                 YES, R15 = LENGTH FROM CALL
GEN6A    AR    R15,R0
         STH   R15,10(,R1)             INSERT NEW LENGTH INTO RECORD
         SR    R15,R0
         AR    R1,R0                   START ADDR WITHIN RECORD
         SR    R14,R15                 REMAINING LENGTH
         B     GEN8                    GOTO MOVE TEXT
*
GEN4     LTR   R14,R14                 MORE INFORMATION TO BE MOVED ?
         BZR   R4                      NO, RETURN TO CALLING ROUTINE
*
*        OUTPUT NEW RECORD
*
GEN3     ST    R14,SAVELT              SAVE LENGTH
         TM    COMPFLGS+1,NLOAD+NDECK  BOTH DECK AND LOAD SPECIFIED ?
         BZ    BOTH                    YES, BRANCH
         TM    COMPFLGS+1,NDECK        ONLY DECK ?
         L     R1,APCHDCB              R1 -> SYSPUNCH DCB
         BZ    PUT1                    YES
PUT1A    L     R1,ALINDCB              R1 -> SYSLIN DCB
*
PUT1     PUT   (R1)                    PUT FOR SYSLIN AND SYSPUNCH
*
         ST    R1,SAVOUTA              IF ONLY SYSPUNCH SPECIFIED
         L     R14,SAVELT              RESTORE LENGTH
         B     PUNCHOUT
*
SAVELT   DC    F'0'                    SAVE AREA FOR LENGTH
BOTH     L     R14,OUTAREA2            COPY SYSLIN BUFFER TO SYSPUNCH
         L     R1,SAVOUTA
         MVC   0(80,R14),0(R1)         BUFFER
         L     R1,APCHDCB
*
         PUT   (R1)                    PUT FOR SYSPUNCH WHEN BOTH HAS
*
         ST    R1,OUTAREA2             BEEN SPECIFIED
         B     PUT1A                   GOTO PUT SYSLIN
*
PUNCHOUT EQU   *
         MVC   0(4,R1),0(R3)           INSERT FIRST 4 BYTES
         MVI   4(R1),C' '              INSERT ONE BLANK
         MVC   5(67,R1),4(R1)          BLANK OUTPUT RECORD
         MVC   72(4,R1),PIDENT         INSERT PROGRAM IDENT
         AP    CARDCNT,KP1             STEP SEQUENCE NUMBER
         UNPK  76(4,R1),CARDCNT        UNPACK INTO RECORD
         OI    79(R1),X'F0'            MAKE PRINTABLE
         MVC   10(2,R1),4(R3)          INSERT INITIAL LENGTH
         MVC   14(6,R1),6(R3)          INSERT ESID+R AND P
         ST    R6,4(0,R1)
         MVI   4(R1),C' '
         B     GEN6
*
*        TXT RECORD
*
TXTT     DC    X'02'                   CARD CODE
         DC    C'TXT'                  IDENTIFICATION
         DC    H'0'                    INITIAL LENGTH 0
         DC    H'1'                    ESID
         DC    C'    '
         DC    H'56'                   MAXIMUM LENGTH
*
*        TXT MOVE ROUTINE
*
GEN8     BCTR  R15,0                   DECR R15
         STC   R15,*+5                 INSERT PROPER LENGTH TO MOVE
         MVC   16(0,R1),0(R2)          MOVE DATA TO OUT AREA
         LA    R6,1(R15,R6)            INCREASE PROGRAM POINTER
         LA    R2,1(R15,R2)            MODIFY DATA ADDR
         B     GEN4                    OUT OF MOVE TXT ROUTINE
*
*        AREAS AND CONSTANTS LOCAL FOR GENTXT
*
TXTSAV   DC    9F'0'                   REGISTER SAVE AREA
KP1      DC    PL1'1'                  CARD COUNT INCREMENT
*
INTERUPT CLI   7(R1),X'0C'             FLOATING POINT OVERFLOW ?
         BE    REALERR                 YES
         L     R5,OLDSPIE              NO, USE DIRECTORY ROUTINE
         L     R15,0(,R5)              ADDR ERROR ROUTINE OF DIREC
         BR    R15                     ENTER ERROR ROUTINE
*
ZERO     DC    3H'0'
KH1      DC    H'1'
KH5      DC    H'5'
KH7      DC    H'7'
KH8      DC    H'8'
KH9      DC    H'9'
KH10     DC    H'10'
KH11     DC    H'11'
KH12     DC    H'12'
KH15     DC    H'15'
KH18     DC    H'18'
KH56     DC    H'56'
KH64     DC    H'64'
KH255    DC    H'255'
KH1792   DC    H'1792'
KH4096   DC    H'4096'
*
*        ERROR MESSAGE NUMBERS
*
INVOP    DC    H'80'                   SYNTAX ERROR IN OPERAND
UNDEFOP  DC    H'81'                   UNDEFINED IDENTIFIER
RANGEREA DC    H'82'                   REAL CONSTANT OUT OF RANGE
RANGEINT DC    H'83'                   INTEGER OUT OF RANGE
PRECREAL DC    H'84'                   PRECISION OF REAL TOO GREAT
GOTOFOR  DC    H'85'                   GO TO INTO FOR STATEMENT
MANYCON  DC    H'86'                   TOO MANY CONSTANTS
TABOVER  DC    H'87'                   OPTIMIZATION TABLE OVERFLOW
ARRAYERR DC    H'88'                   INVALID ARRAY LIST IDENTIFIER
SWITCHER DC    H'89'                   SWITCH DECLARATION ERROR
ITABOVER DC    H'213'                  ITAB OVERFLOW
TOOMANY  EQU   212                     TOO MANY ERRORS
TOOLONG  DC    H'215'                  TOO MUCH SOURCE OUTPUT
*
*        SUBSCRIPT TABLE
*
ZSUTAPO  DC    A(0)                    CURRENT SUTAB PT
ZSUDAD   DC    A(0)                    ADDR OF FIRST SUTAB ENTRY
ZSUTMAX  DC    A(0)                    SUTAB END PT
SUSTRT   DC    A(0)                    START ADDR OF SUTAB RECORD
SUKEY    DC    C'SUTB'                 SUTAB RECORD IDENTIFICATION
SULENGTH DC    F'0'                    ACCUMULATED LENGTH OF SUTAB
SUCNT    DC    H'0'                    NUMBER OF WRITTEN SUTAB RECORDS
*
*        LEFT VARIABLE TABLE
*
ZLESTA   DC    A(0)                    ADDR OF FIRST LVTAB ENTRY
ZLEVA    DC    A(0)                    CURRENT LVTAB PT
ZLEMAX   DC    A(0)                    LVTAB END PT
LVSTRT   DC    A(0)                    START ADDR OF LVTAB RECORD
LVKEY    DC    C'LVTB'                 LVTAB RECORD IDENTIFICATION
LVLENGTH DC    F'0'                    ACCUMULATED LENGTH OF LVTAB
LVCNT    DC    H'0'                    NUMBER OF WRITTEN LVTAB RECORDS
*
*        INPUT RECORD
*
ZIBRUN   DC    A(0)                    START OF ACTIVE INPUT BUF
ZIBREAD  DC    A(0)                    START OF NEXT INPUT BUFFER
*
*        OUTPUT RECORD
*
ZOBWORK  DC    A(0)                    START OF ACTIVE OUTPUT BUFFER
ZOBWRITE DC    A(0)                    START OF LAST OUTPUT BUFFER
ZFILE1   DC    A(0)                    OUTPUT RECORD END - 1
ZFILE2   DC    A(0)                    OUTPUT RECORD END - 2
ZFILE3   DC    A(0)                    OUTPUT RECORD END - 3
ZFILE5   DC    A(0)                    OUTPUT RECORD END - 5
ZFILE6   DC    A(0)                    OUTPUT RECORD END - 6
ZFILE9   DC    A(0)                    OUTPUT RECORD END - 9
ZOUTCOT  DC    H'1'                    OUTPUT RECORD NUMBER
*
*        IDENTIFIER TABLE
*
ZIBSTAO  DC    A(0)                    ITAB START ADDR
ZITAN    DC    A(0)                    ADDR OF ITAB ENTRY OF LAST ID
ZCURITEN DC    A(0)                    ADDR OF LAST ITAB ENTRY
ZITREC   DC    A(0)                    START OF NEXT ITAB RECORD
ZITEND   DC    A(0)                    ITAB END ADDR
ZCURITLE DC    H'0'                    LENGTH OF LAST ITAB RECORD
*
*        ERROR MESSAGES
*
ZBEGERR  DC    F'0'                    START OF VARIABLE INFORMATION
ZENDERR  DC    F'0'                    END OF VARIABLE INFORMATION
ZERRONU  DC    H'0'                    ERROR NUMBER
*
*        ARRAY IDENTIFIER STACK
*
ZARMAX   DC    A(ZARSTACK+28)          END ADDR IN ARIDSTACK
ZARNO    DC    A(ZARSTACK-7)           START ADDR OF ARIDSTACK
ZARSPO   DC    A(ZARSTACK-7)           CURRENT POINT IN ARIDSTACK
ZPOSIX   DC    H'0'                    COMPONENT NUMBER IN ARRAY
ZARSTACK DC    XL35'00'                ARIDSTACK
*
*        SUBSCRIPT TEST ROUTIN2
*
SUBEND   DC    A(0)                    SUBSCRIPT END ADDR
ADDEND   DC    3H'0'                   SAVE AREA FOR ADDEND
FACTOR   DC    3H'0'                   SAVE AREA FOR FACTOR
ZEROELEM DC    XL6'00C801000000'       INTERNAL CODE FOR +0
ONEELEM  DC    XL6'00C801000004'       INTERNAL CODE FOR +1
ZBRACK   DC    A(0)                    SUBSCRIPT START ADDR - 1
*
ZSTO     DC    F'0'                    TEMPORARY STORAGE
ZSTO1    DC    X'0670'
ZSTO2    DC    X'0240'
ZIGN     DC    H'0'                    CURRENT IDENTIFIER GROUP NUMBER
ZPOINT   DC    6AL1(XFDECPT)
ZALLPUP  DC    X'91FF010000'           ALL PURPOSE IDENTIFIER
ZALLPU   EQU   ZALLPUP-6
ZIDEX    DC    37X'00'                 WORKAREA
NUMBER   EQU   ZIDEX+1
OPSTART  DC    A(ZIDEX)
*
BRCNT    DC    H'0'                    BRACKET COUNTER IN ARRAY DECL
STATUS   DC    X'00'                   STATUS BYTE
CURPBN   DC    C' '                    PBN OF LAST BLOCK
ZCLOBRA  DC    X'00'                   SUBSCRIPT TEST BYTE
ZFORTEST DC    X'00'                   FOR STATEMENT TEST BYTE
ZLVOV    DC    X'00'                   SET X'FF' IF NO MORE SUBSC OPT
ZFSN     DC    C' '                    CURRENT FOR STATEMENT NUMBER
FSNEMBR  DC    C' '                    NUMBER OR EMBRACING BLOCK
IOBYTE   DC    C' '                    STATUS BYTE FOR SYSUT3
NOTEW    DC    F'0'                    ID OF LAST WRITTEN RECORD
NOTER    DC    F'0'                    ID OF LAST READ ITAB RECORD
*
*        CRITICAL VARIABLE TABLE
*
PFA      DC    A(0)                    CURRENT CRIDTAB PT
PFANO    DC    A(0)                    START ADDR OF CRIDTAB
PFAMAX   DC    A(0)                    END ADDR OF CRIDTAB
ZFSPTR   DC    A(0)                    POINT TO CURRENT FSTAB ENTRY
ZFOCRI   DC    A(0)
*
*        CONSTANT POOL
*
ZKOPOOL  DC    A(0)                    START ADDR OF POOL
ZKOPEND  DC    A(0)                    END ADDR OF POOL
ZLITSTA  DC    A(0)                    START ADDR OF USED PART
ZTEXTCO  DC    A(0)                    END ADDR OF TXT PIECE
ZKBNMAX  DC    H'0'                    NUMBER OF NEXT POOL
TXTPUT   DC    H'56'                   LENGTH OF TXT PIECE
*
ZPACK    DC    D'0'                    WORKAREA TO PACK NUMBERS
ZEROFLOA DC    D'0.0'
ZONEFLOA DC    D'1.0'
ZTEN9    DC    D'1.0E+9'
ZFLOFIEL DC    X'4E00000000000000'     WORKAREA FOR FLOATING CONVERS
ROUND    DC    X'0000000080000000'     USED TO ROUND SHORT FORM REAL
ZWP      DC    A(0)                    WORD POINTT IN CONSTANT POOL
ZDWP     DC    A(0)                    DOUBLE WORD PT IN CONSTANT POOL
NSTART   DC    A(NUMBER)               PTR TO NUMBER
SCALEMSK DC    XL4'38'
LREAL    DC    F'8'                    SHORT PREC 4, LONG PREC 8
NREAL    DC    F'18'                   SHORT PREC 7, LONG PREC 18
ZLIRE    DC    H'0'
ZINTYP   DC    X'C801'                 ID OF INTEGER CONSTANT
ZREALTYP DC    X'C802'                 ID OF REAL CONSTANT
SREF     DC    P'+1'                   PLUS
         DC    P'-1'                   MINUS, MUST FOLLOW SREF
SCATEST  DC    C' '                    SCALE FACTOR TEST BYTE
SCALEQ   DC    AL1(XFQUOTE),X'00'
SCALE    EQU   SCALEQ+1
MAXINT   IEXCGEN DC,'2147483647'       MAX INTEGER IN INTERNAL CODE
SCAWORK  DC    10X'00'                 STORE FOR SCALE FACTOR
ZTO      DC    F'0'
ZEXCORR  DC    F'0'
ZTOSCA   DC    F'0'
SCAWORKA DC    A(SCAWORK+1)
*
OLDSPIE  DC    A(0)                    ADDR OF OLD PICA
TABSIZE  DC    F'0'                    ACCUMULATED SIZE OF TABLES
REGSAVE  DC    5F'0'                   SAVEAREA FOR REGISTERS
SPECUSE  DC    XL4'06'
ALIGN    DC    F'0'                    FULL WORD ALIGNMENT
ALIGNH   EQU   ALIGN+2                 HALF WORD ALIGNMENT
*
ZEXTABP  DC    D'1.0E+1'
         DC    D'1.0E+2'
         DC    D'1.0E+3'
         DC    D'1.0E+4'
         DC    D'1.0E+5'
         DC    D'1.0E+6'
         DC    D'1.0E+7'
         DC    D'1.0E+8'
         DC    D'1.0E+16'
         DC    D'1.0E+24'
         DC    D'1.0E+32'
         DC    D'1.0E+40'
         DC    D'1.0E+48'
         DC    D'1.0E+56'
         DC    D'1.0E+64'
*
ZEXTABN  DC    D'1.0E-1'
         DC    D'1.0E-2'
         DC    D'1.0E-3'
         DC    D'1.0E-4'
         DC    D'1.0E-5'
         DC    D'1.0E-6'
         DC    D'1.0E-7'
         DC    D'1.0E-8'
         DC    D'1.0E-16'
         DC    D'1.0E-24'
         DC    D'1.0E-32'
         DC    D'1.0E-40'
         DC    D'1.0E-48'
         DC    D'1.0E-56'
         DC    D'1.0E-64'
*
GENER    DC    X'5454546854685454'
         DC    X'3C606438541C2020'
         DC    8X'54'
         DC    X'245C543430'
         DC    8X'54'
         DC    X'4054544438282C545018480C'
         DC    9X'08'
         DC    X'00004C581014'
         DC    30X'04'
*
IDENTI   DC    45X'10'
         DC    X'000C04'
         DC    13X'00'
         DC    X'080C0C'
         DC    30X'00'
*
DIG19    DC    45X'18'
         DC    X'000C10'
         DC    13X'00'
         DC    X'140408'
         DC    30X'0C'
*
DIG0     DC    45X'1C'
         DC    X'00081400'
         DC    9X'04'
         DC    X'000000180C10'
         DC    30X'08'
*
DECPO    DC    45X'14'
         DC    X'00081004'
         DC    13X'00'
         DC    X'080C'
         DC    30X'08'
*
SCAFAC   DC    X'0C0C'
         DC    43X'18'
         DC    X'00101408'
         DC    9X'04'
         DC    4X'00'
         DC    32X'10'
*
*        ITAB ENTRIES FOR STANDARD PROCEDURES
*
FIXITAB  DC    X'013F0000002B'         HEADER FOR PBN O
         DC    X'0000',X'000000'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'ABS'              ABS
         ORG
         DC    X'8882',X'002080'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'SIGN'             SIGN
         ORG
         DC    X'8881',X'0020C0'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'LENGTH'           LENGTH
         ORG
         DC    X'8881',X'0000E0'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'SYSACT'           SYSACT
         ORG
         DC    X'8A80',X'911203'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'SQRT'             SQRT
         ORG
         DC    X'8882',X'002004'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'SIN'              SIN
         ORG
         DC    X'8882',X'002008'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'COS'              COS
         ORG
         DC    X'8882',X'00200C'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'ARCTAN'           ARCTAN
         ORG
         DC    X'8882',X'002010'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'LN'               LN
         ORG
         DC    X'8882',X'002014'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'EXP'              EXP
         ORG
         DC    X'8882',X'002018'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'ENTIER'           ENTIER
         ORG
         DC    X'8881',X'0020F0'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'INSYMB'           INSYMB
         ORG
         DC    X'8A80',X'90181F'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'INREAL'           INREAL
         ORG
         DC    X'8A80',X'0A1822'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'ININTE'           ININTE
         ORG
         DC    X'8A80',X'091826'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'INBOOL'           INBOOL
         ORG
         DC    X'8A80',X'0B182A'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'INARRA'           INARRA
         ORG
         DC    X'8880',X'0E182E'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'INTARR'           INTARR
         ORG
         DC    X'8880',X'0D1832'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'INBARR'           INBARR
         ORG
         DC    X'8880',X'071836'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'OUTSYM'           OUTSYM
         ORG
         DC    X'8880',X'10143B'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'OUTREA'           OUTREA
         ORG
         DC    X'8880',X'02143E'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'OUTINT'           OUTINT
         ORG
         DC    X'8880',X'011442'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'OUTBOO'           OUTBOO
         ORG
         DC    X'8880',X'031446'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'OUTARR'           OUTARR
         ORG
         DC    X'8880',X'06144A'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'OUTTAR'           OUTTAR
         ORG
         DC    X'8880',X'05144E'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'OUTBAR'           OUTBAR
         ORG
         DC    X'8880',X'071452'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'OUTSTR'           OUTSTR
         ORG
         DC    X'8880',X'001456'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'PUT'              PUT
         ORG
         DC    X'8A80',X'04115A'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'GET'              GET
         ORG
         DC    X'8A80',X'04115E'
*
FIXITABL EQU   *-FIXITAB               L'FIXITAB
*
         LTORG
*
WORKAREA DSECT
*
         COPY  WORKAREA
*
ZFOSTA   EQU   FSTAB
*
         ORG   SYSUT1
*
FSNMAX   DS    H
LVCOUNT  DS    H
SUCOUNT  DS    H
ZLEVEN   DS    F
ZSUTEN   DS    F
*
*        CHARACTER EQUATES
*
         IEXCHAR
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END   IEX30000
./ ADD NAME=IEX31    0201-12230-12230-1200-00128-00128-00000-LEVEL
X31      TITLE 'IEX31 - ERROR MESSAGE EDITING, ALGOL F'
*
*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER
*
*        FUNCTION/OPERATION -
*        THE ERROR PATTERNS GENERATED DURING SCANIII ARE HANDLED
*        AND THE CORRESPONDING DIAGNOSTIC MESSAGES ARE
*        GENERATED
*
*        ENTRY POINT - IEX31000 - ERROR MESSAGE EDITING
*                      XCTL EP=IEX31
*                      THE MODULE IS ENTERED FROM IEX30
*
*        INPUT - N/A
*
*        OUTPUT -
*        THE DIAGNOSTIC MESSAGES ARE PUT OUT ON SYSPRINT. IF
*        SYSPRINT IS DOWN, THIS IS REPORTED WITH A WTO
*
*        EXTERNAL ROUTINE - THE PRINT ROUTINE IN IEX00 IS USED
*
*        EXIT - NORMAL -
*        IF NO TERMINATING ERROR HAS OCCURRED CONTROL IS GIVEN
*        TO THE NEXT PHASE BY MEANS OF XCTL EP=IEX40.
*
*        EXIT - ERROR -
*        IF A TERMINATING ERROR HAS OCCURRED (IN THIS MODULE OR
*        THE PRECEDING) CONTROL IS GIVEN TO THE TERMINATING
*        MODULE BY MEANS OF XCTL EP=51002.
*
*        TABLES/WORKAREAS -
*        THE MESSAGE TEXTS WITH CORRESPONDING ADDRESS TABLE ARE
*        IN THE LOAD MODULE IEX31M
*        THE ERROR MESSAGE EDITING ROUTINE, CSECT IEX60000, ALSO
*        USES THE FOLLOWING TABLES -
*        WINTEBC  - TRANSLATION OF INTERNAL CHARACTERS TO EBCDIC
*        WSYMBSRC - TRANSLATION OF INTERNAL SYMBOLS TO EBCDIC
*        WSYMBSTK - TRANSLATION OF INTERNAL SYMBOLS TO EBCDIC
*        WORDSEBC - TRANSLATION OF COMPOUND SYMBOLS IF SOURCE
*                   IN EBCDIC
*        WORDSISO - TRANSLATION OF COMPOUND SYMBOLS IF SOURCE
*                   IN ISOCODE
*        WEBCDIC  - TRANSLATION EBCDIC - EBCDIC
*        A WORKAREA OF 270 BYTES, WAREA, IS USED FOR BUILDING
*        THE MESSAGES
*
*        ATTRIBUTES - NONE
*
*        NOTES -
*        CHARACTER CODE DEPENDENCE. FOR THE BUILDING OF A
*        MESSAGE (CODE PART BETWEEN COT03 AND COT12) THE
*        FOLLOWING APPLIES. IN CASE NO SOURCE INFORMATION IS TO
*        BE INSERTED (COT31), OR IF THE INFORMATION IS EBCDIC-
*        CHARACTERS (COT07), THE OPERATION OF CSECT IEX60000
*        DEPENDS UPON AN INTERNAL REPRESENTATION OF THE EXTERNAL
*        CHARACTER SET WHICH IS EQUIVALENT TO THE ONE USED AT
*        ASSEMBLY TIME.
*
*        IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL
*        CHARACTERS (COT33) THE OPERATION OF CSECT IEX60000
*        DEPENDS UPON A TRANSLATION FROM THE INTERNAL
*        REPRESENTATION TO THE EBCDIC CHARACTER SET BY MEANS OF
*        THE TABLE 'WINTEBC'.
*
*        IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL
*        ALGOL SYMBOLS (COT10) THE OPERATION OF CSECT IEX60000
*        DEPENDS UPON A TRANSLATION FROM THE INTERNAL
*        REPRESENTATION TO THE EBCDIC CHARACTER SET BY MEANS OF
*        THE TABLES 'WSYMBSTK'/'WSYMBSRC' AND 'WORDSISO'/'WORDSEBC'.
*
*        FOR THE OUTPUT OF A MESSAGE (CODE PART BETWEEN COT12
*        AND COT21) THE FOLLOWING APPLIES.
*        WHEN A MESSAGE HAS BEEN BUILT IN EBCDIC, AN EBCDIC -
*        EBCDIC TRANSLATION IS PERFORMED BEFORE OUTPUT BY MEANS
*        OF THE TABLE 'WEBCDIC'. THUS THE OUTPUT MAY BE MODIFIED
*        BY MAKING CHANGES IN THIS TABLE.
*
*        THE OPERATION OF CSECT IEX31000 DOES NOT DEPEND UPON A
*        PARTICULAR INTERNAL REPRESENTATION OF THE EXTERNAL
*        CHARACTER SET.
*
*        AT SYSTEM GENERATION THIS MODULE WILL BE LINKED
*        TOGETHER WITH THE MODULE IEX31M TO FORM THE MODULE
*        IEX31.
*
*        THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN
*        CONNECTION WITH THE OTHER MODULES OF THE ALGOL COMPILER,
*        IN PARTICULAR IT REQUIRES THE COMMON WORKAREA
*
IEX31000 CSECT
*
         IEXENTRY 'IEX31000 LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IEX31000,R15
*
         L     R2,=A(IEX60000)         ADDRESS ERROR MSG EDIT ROUTINE
         LA    R14,SUSCR               LOAD RETURN ADDRESS
         LA    R1,ERRINFO              ADDRESS INFO FOR ERROR ED ROUT
         BR    R2                      GOTO ERROR MESSAGE EDITING
*
         DC    0F'0'
*
*        INITIALIZATION OF SUBSCR HANDLING
*
SUSCR    XCTL  EP=IEX40000
*
ERRINFO  DC    V(IEX31M00)             ADDR OF MESSAGE TEXTS
         DC    V(IEX31M01)             ADDR OF ADDR TABLE
         DC    H'119'                  MODIFICATION NUMBER
*
         LTORG
*
         COPY  IEX60000
*
WORKAREA DSECT
*
         COPY  WORKAREA
*
*
*        CHARACTER EQUATES
*
         IEXCHAR
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IEX31M   0201-12230-12230-1200-00129-00129-00000-LEVEL
X31M     TITLE 'IEX31M - MESSAGE TEXTS FOR ERRORS DETECTED BY IEX00 ANDX
                IEX30, ALGOL F'
*
*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER
*
*        FUNCTION/OPERATION -
*        THIS MODULE CONTAINS MESSAGE TEXTS FOR ALL ERRORS THAT
*        MAY BE DETECTED BY IEX00 AND IEX30, AND THE CORRESPONDING
*        ADDRESS TABLE
*
*        ENTRY POINT - N/A
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXITS - NORMAL - N/A
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORKAREAS - N/A
*
*        ATTRIBUTES - N/A
*
*        NOTES -
*        AT SYSTEM GENERATION THIS MODULE WILL BE LINKED
*        TOGETHER WITH THE MODULE IEX31 TO FORM THE MODULE IEX31
*
IEX31M00 CSECT
*
         ENTRY IEX31M01
*
*        ERROR MESSAGE POOL 2
*
WEMPOOL2 EQU   *
*
W080     DC    X'3E0300160C240023001B23'
         DC    CL52'SOPERAND BEGINNING WITH  IS SYNTACTICALLY INCORRECTX
               .'
*
W081     DC    X'2403000A0C240017000D17'
         DC    CL26'SIDENTIFIER  NOT DECLARED.'
*
W082     DC    X'3603001C0C240029000D29'
         DC    CL44'SREAL CONSTANT BEGINNING WITH  OUT OF RANGE.'
*
W083     DC    X'5A05001612240029001E29F00000001149'
         DC    CL74'WINTEGER BEGINNING WITH  OUT OF RANGE. INTEGER CONSX
               TANT CONVERTED TO REAL.'
*
W084     DC    X'750500291224003C00083CF00000003045'
         DC    CL101'WPRECISION OF REAL CONSTANT BEGINNING WITH  EXCEEDX
               S INTERNALLY HANDLED PRECISION. CONSTANT TRUNCATED.'
*
W085     DC    X'210300140C240021000021'
         DC    CL23'SILLEGAL USE OF LABEL .'
*
W086     DC    X'1500'
         DC    CL20'STOO MANY CONSTANTS.'
*
W087     DC    X'3A00'
         DC    CL57'WFULL OPTIMIZATION NOT POSSIBLE DUE TO INTERNAL OVEX
               RFLOW.'
*
W088     DC    X'8805000A1224001C002C1DF00000003D4B'
         DC    CL120'WIDENTIFIER  IN BOUND EXPRESSION DECLARED IN SAME X
               PROGRAM BLOCK AS ARRAY. DECLARATION IN SURROUNDING BLOCKX
                SEARCHED FOR.'
*
W089     DC    X'450300040C240011003411'
         DC    CL59'WGOTO  INVALID OUTSIDE FOR STATEMENT CONTAINING THIX
               S LABEL.'
*
*        DIRECTORY MESSAGES
*
W090     EQU   *
W209     EQU   *
         DC    X'460400360FF00000840046000046'
         DC    CL57'TCOMPILATION UNSUCCESSFUL DUE TO PROGRAM INTERRUPT.X
                PSW .'
*
W091     EQU   *
W210     EQU   *
         DC    X'300300270C840030000030'
         DC    CL38'TUNRECOVERABLE I/O ERROR ON DATA SET .'
*
W092     EQU   *
W211     EQU   *
         DC    CL56'PROGRAM INTERRUPT IN ERROR MESSAGE EDITING ROUTINE.X
                PSW '
*
W093     EQU   *
W212     DC    X'1200'
         DC    CL17'TTOO MANY ERRORS.'
*
W094     EQU   *
W213     DC    X'2800'
         DC    CL39'TINTERNAL OVERFLOW OF IDENTIFIER TABEL.'
*
W095     EQU   *
W215     EQU   *
         DC    X'1A00'
         DC    CL25'TSOURCE PROGRAM TOO LONG.'
*
*        ADDR TABLE FOR WEMPOOL2
*
         DC    0F'0'
IEX31M01 EQU   *-320
         DC    A(W080)
         DC    A(W081)
         DC    A(W082)
         DC    A(W083)
         DC    A(W084)
         DC    A(W085)
         DC    A(W086)
         DC    A(W087)
         DC    A(W088)
         DC    A(W089)
         DC    A(W090)
         DC    A(W091)
         DC    A(W092)
         DC    A(W093)
         DC    A(W094)
         DC    A(0)
         DC    A(W095)
*
         END
./ ADD NAME=IEX40    0201-12230-12230-1200-00832-00832-00000-LEVEL
X40 TITLE 'IEX40 - SUBSCRIPT HANDLING AND INITIALIZATION OF COMPILATIONX
                PHASE, ALGOL F'
*
*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER
*
*        FUNCTION/OPERATION -
*        IEX40000 BUILDS THE OPTIMIZATION TABLE (OPTAB) USING
*        THE SUBSCRIPT TABLE, THE LEFT VARIABLE TABLE AND THE FOR
*        STATEMENT TABLE. AN OPTAB ENTRY CORRESPOND TO AN
*        OPTIMIZABLE SUBSCRIPT EXPRESSION INSIDE A FOR STATEMENT.
*        IF NO OPTAB IS PRODUCED THIS IS INDICATED IN THE
*        COMPILER STATUS BYTES IN COMPFLGS
*        IEX40001 IS THE INITIALIZATION OF NEXT MODULE, IEX50,
*        AND PERFORMS THE FOLLOWING FUNCTIONS -
*        CALCULATION AND RESERVATION OF STORAGE AREAS NEEDED
*        LOADING REGISTERS WITH START ADDRESSES
*        READING THE FIRST RECORDS OF SOURCE PROGRAM AND OPTAB
*        SETTING INITIAL VALUES IN THE PRIVATE PART OF COMMON
*        WORKAREA
*
*        ENTRY POINT - IEX40000
*
*        INPUT -
*        IEX40000 READS TWO TABLES CONSTRUCTED IN IEX30
*        FROM SYSUT3. THE SUBSCRIPT TABLE (SUTAB) CONTAINS
*        ENTRIES FOR LINEAR SUBSCRIPT EXPRESSIONS IN FOR
*        STATEMENTS THAT ARE OPTIMIZABLE IN REGARD TO
*        SUBSCRIPTS.
*        THE LEFT VARIABLE TABLE (LVTAB) CONTAINS ENTRIES FOR
*        INTEGER LEFT VARIABLES IN FOR STATEMENTS THAT ARE
*        OPTIMIZABLE IN REGARD TO SUBSCRIPTS.
*        IEX40001 READS THE FIRST TWO RECORDS OF THE
*        SOURCE PROGRAM FROM SYSUT2 INTO TWO SOURCE BUFFERS.
*        THE FIRST TWO RECORDS OF OPTAB ARE READ IN FROM SYSUT3
*        TO TWO OPTAB BUFFERS
*
*        OUTPUT -
*        THE OPTIMIZATION TABLE (UPTAB)IS WRITTEN OUT ON SYSUT3.
*        OPTAB CONTAINS ONE ENTRY FOR EVERY OPTIMIZABLE
*        SUBSCRIPT EXPRESSION IN A FOR STATEMENT
*
*        EXTERNAL ROUTINES -
*        THE INTERRUPT ROUTINES OF IEX00 ARE USED
*
*        EXIT - NORMAL - CONTROL IS GIVEN TO THE NEXT LOAD
*        MODULE BY MEANS OF XCTL EP=IEX50
*
*        EXITS - ERROR -
*        INPUT/OUTPUT ERRORS AND PROGRAM INTERRUPTS ARE HANDLED
*        BY A DIRECTORY ROUTINE WHICH RETURNS CONTROL TO THE
*        INTERRUPTED MODULE. IF THE ERROR OCCURED BEFORE THE
*        GETMAIN IN IEX40001 CONTROL IS GIVEN TO THE TERMINATING
*        MODULE BY MEANS OF XCTL EP=IEX51ER2
*        IF THE ERROR OCCURED AFTER THE GETMAIN CONTROL IS GIVEN
*        TO THE TERMINATING MODULE BY MEANS OF
*        XCTL EP=IEX51ER1
*
*        TABLES/WORKAREAS -
*        THE FOR STATEMENT TABLE (FSTAB) CONSTRUCTED IN IEX30
*        AND POSSIBLY REVISED BY IEX40000 CONTAINS
*        CLASSIFICATIONS OF THE FOR STATEMENTS
*
*        ATTRIBUTES - NONE
*
*        NOTES -
*        THE OPERATION OF THIS MODULE DOES NOT DEPEND UPON ANY
*        SPECIAL REPRESENTATION OF THE EXTERNAL CHARACTER SET.
*        THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN
*        CONNECTION WITH THE OTHER MODULES OF THE ALGOL COMPILER.
*        IN PARTICULAR IT REQUIRES THE COMMON WORKAREA
*
*
IEX40000 CSECT
*
*        BIT PATTERNS
*
FIRSTM   EQU   X'20'                   FIRST ENTRY IN SUTAB CHAIN
SUCM     EQU   X'10'                   SUCCEDING ENTRY IN SUTAB CHAIN
LASTM    EQU   X'30'                   LAST ENTRY IN SUTAB CHAIN
OFFM     EQU   X'CF'                   TURN OFF SUTAB CHAIN BITS
SUOP     EQU   X'40'                   SUBSCRIPT OPTIMIZATION BIT
*
         IEXENTRY 'IEX40000 LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IEX40000,R12
         LR    R12,R15
*
         USING WORKAREA,R13
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    NOSUTAB                 YES
*
*        INITIALIZE SUTAB
*
         CLC   ZSUTEN(4),KF0           SUTAB EMPTY ?
         BE    NOSUTAB                 YES
*
*        ANY NESTED FOR LOOPS ?
*
         SR    R2,R2
         ST    R2,FOR1
         MVC   FOR1+4(255),FOR1+3      SET FOR STMT COUNT
         MVC   FOR2+2(255),FOR2+1      AREAS TO ZERO
         LH    R0,FSNMAX
         AH    R0,KH1                  NO OF FOR STMT
         LA    R1,GPTAB
GP1      LA    R1,3(,R1)               PTR TO NEXT GPTAB RECORD
         CLC   KF0(1),2(R1)            FOR STATEMENT ?
         BE    GP1                     NO
         SH    R0,KH1                  ALL FOR STMT CHECKED ?
         BM    GP10                    YES
         MVC   FOR4(3),0(R1)           MOVE GPTAB RECORD
         LH    R3,FOR4                 MULTIPLY GPTAB PTR BY 3
         AR    R3,R3                   GIVES CORRECT ADDR
         AH    R3,FOR4                 IN GPTAB
         LA    R3,GPTAB(R3)
         CLC   KF0(1),2(R3)            NESTED ?
         BE    GP1                     NO
         IC    R2,FOR4+2               FOR STMT NO+1
         LA    R4,FOR2-1(R2)
         MVC   0(1,R4),2(R3)           STORE ENCLOSING FSN
         B     GP1
*
GP10     LA    R2,TERMIN2              TERMINATION ADDR
         ST    R2,ERET
         L     R0,SUTAB40S             RESERVE TABLE AREA
         A     R0,OPTABS
         AR    R0,R0
         AH    R0,KH8
         ST    R0,TABSIZE              SAVE LENGTH OF TABLE AREA
*
         GETMAIN R,LV=(0)              ALLOCATE STORAGE TO SUTAB
*
         LA    R2,TERM1                ERROR RETURN ADDR
         ST    R2,ERET
         ST    R1,TSTART               SUTAB START ADDR
*
*        READ SUTAB
*
         LH    R10,SUCOUNT             NUMBER OF SUTAB RECORDS - 1
         L     R9,SUTYPE               SUTAB RECORD IDENTIFICATION
         L     R8,SUTAB30S             LENGTH OF WRITTEN SUTAB RECORDS
         L     R11,TSTART              TABLE START ADDR
         BAL   R7,READ                 READ FULL SUTAB
*
*        R11                           END ADDR OF UNSORTED SUTAB
*        R10                           FOR STATEMENT NUMBER
*        R9                            CURRENT PTR IN UNSORTED SUTAB
*        R8                            PTR FOR CHAINING CHECK
*        R7                            FULL LENGTH OF DELETED ENTRIES
*
*        SCAN SUTAB FOR ENTRY CHAINING AND ENTRY DELETION
*
         L     R9,TSTART               TABLE START ADDR WITH KEY
         LA    R9,4(,R9)               DELETE KEY
         LR    R11,R9                  CLACULATE END ADDR
         A     R11,ZSUTEN
         SR    R10,R10
         SR    R7,R7
*
SUTABS   IC    R10,0(,R9)              ISOLATE ACTUAL FOR STATE NUMBER
         LA    R2,FSTAB(R10)           ADDR ACRUAL FOR ENTRY
         TM    0(R2),SUOP              SUBSCRIPT OPTIMIZATION POSSIBLE?
         BZ    SUTABS2                 YES
         LA    R7,14(,R7)              LENGTH OF DELETED ENTRIES
         MVI   0(R9),X'FF'             NOT OPTIMIZABLE ENTRY
         LA    R9,14(,R9)              GET NEXT ENTRY
         CR    R9,R11                  SUTAB END ?
         BE    SORTSU                  YES
         B     SUTABS
*
SUTABS2  LR    R8,R9                   CHECK ENTRY CHAINING
SUTABS3  LA    R8,14(,R8)              SCAN SUTAB FOWORD FOR CHAINING
         CR    R8,R11                  SUTAB END ?
         BE    SORTSU                  YES
         CLC   10(4,R9),10(R8)         CHAIN ?
         BE    SUTABS4                 YES
         LR    R9,R8                   PROCESS NEW ENTRY AS FIRST
         B     SUTABS
*
SUTABS4  IC    R10,0(,R8)              ISOLATE FSN OF NEW ENTRY
         LA    R2,FSTAB(R10)           ADDR FSTAB ENTRY
         TM    0(R2),SUOP              SUBSCRIPT OPTIMIZABLE ?
         BZ    SUTABS5                 YES
         MVI   0(R8),X'FF'             NO, DELETE ENTRY
         LA    R7,14(,R7)              COUNT LENGTH OF DELETED ENTRIES
         B     SUTABS3                 CHECK NEXT ENTRY
*
SUTABS5  OI    10(R9),FIRSTM           INDICATE FIRST ENTRY IN CHAIN
SUTABS6  LR    R9,R8                   ADDR CURRENT LAST CHAIN ENTRY
SUTABS7  LA    R8,14(,R8)              CHECK NEXT SUTAB ENTRY
         CR    R8,R11                  SUTAB END ?
         BE    SUTABS9                 YES
         CLC   10(4,R9),10(R8)         ANOTHER CHAINED ENTRY ?
         BE    SUTABS8                 YES
         OI    10(R9),LASTM            INDICATE ENTRY IN CHAIN
         LR    R9,R8                   PROCESS NEW ENTRY AS FIRST
         B     SUTABS
*
SUTABS8  IC    R10,0(,R8)              NEW FOR STATEMENT NUMBER
         LA    R2,FSTAB(R10)           ADDR FSTAB ENTRY
         TM    0(R2),SUOP              SUBSCRIPT OPTIMIZATION POSSIBLE?
         BZ    SUTABS10                YES, CHAIN
         MVI   0(R8),X'FF'             DELETE ENTRY
         LA    R7,14(,R7)              CALCULATE DELETED LENGTH
         B     SUTABS7
*
SUTABS9  OI    10(R9),LASTM            INDICATE LAST ENTRY IN CHAIN
         B     SORTSU
*
SUTABS10 OI    10(R9),SUCM             INDICATE BETWEEN ENTRY
         B     SUTABS6
*
SORTSU   L     R3,TSTART
         LA    R2,4(,R3)               START ADDR OF UNSORTED SUTAB
         ST    R2,ZSTAD                START OF UNSORTED TABLE
         L     R9,ZSUTEN               GET END OF UNSORTED SUTAB
         AR    R9,R2
         A     R3,TABSIZE              END ADDR OF SORTED SUTAB
         ST    R3,ZSUDEN
         S     R3,ZSUTEN
         AR    R3,R7                   START OF SORTED SUTAB
         C     R3,ZSUDEN               WHOLE SUTAB DELETED ?
         BE    NOSUTAB1                YES
         ST    R3,ZSUDAD
         ST    R3,ZSORTSTA
         LA    R11,14                  ENTRY LENGTH
         BAL   R15,SORT                SORT SUTAB
*
*        INITIALIZE OPTAB BUFFERS
*
         L     R2,TSTART
         ST    R2,ZOTAWRI              SECOND OPTAB BUFFER
         A     R2,OPTABS
         ST    R2,ZOTAFILL             FIRST OPTAB BUFFER
         A     R2,OPTABS
         ST    R2,ZOTMAX               ACTUAL BUFFER END
         CLC   ZLEVEN(4),KF0           LVTAB EMPTY ?
         BNE   SORTLE                  NO
         MVC   ZLESTA(4),ZOTMAX        SET DUMMY START ADDR
         B     SORTLE1
*
SORTLE   LH    R10,LVCOUNT             NUMBER OF LVTAB RECORDS - 7
         L     R9,LVTYPE               LVTAB RECORD IDENTIFICATION
         L     R8,LVTAB30S             LENGTH OF LVTAB RECORD
         L     R11,TSTART              START ADDR OF TABLE AREA
         BAL   R7,READ                 READ LVTAB INTO CORE
         L     R2,TSTART
         LA    R2,4(,R2)
         ST    R2,ZSTAD                START ADDR OF UNSORTED TABLE
         A     R2,ZLEVEN
         LR    R9,R2                   END OF UNSORTED TABLE
         C     R2,ZOTMAX               LVTAB LONGER THAN OPTAB BUFFER ?
         BH    *+8                     YES
         L     R2,ZOTMAX               NO, START SORTED TAB AFTER OPTAB
         ST    R2,ZSORTSTA             START ADDR OF SORTED TABLE
         ST    R2,ZLESTA
         LA    R11,4                   ENTRY LENGTH
         BAL   R15,SORT                SORT LVTAB
*
SORTLE1  L     R2,ZLESTA
         A     R2,ZLEVEN
         MVI   0(R2),X'FF'             SET LVTAB END
         L     R2,AUT3DCB              R2 -> SYSUT3 DCB
*
         CLOSE ((R2),REREAD),TYPE=T    POINT TO BEGINNING OF DATASET
*
*        R4                            PTR TO START OF LVTAB GROUP
*        R5                            CURRENT PTR IN LVTAB GROUP
*        R6                            CURRENT SUTAB PTR
*        R7                            SUTAB CHAIN SEARCHING PTR
*        R8                            CURRENT OPTAB BUFFER PTR
*        R9
*
OPTAB    L     R4,ZLESTA               START OF LVTAB
         L     R6,ZSUDAD               START OF SUTAB
         L     R8,ZOTAFILL             START OF FIRST OPT AB BUFFER
*
*        DOES LVTAB GROUP CORRESPOND TO THIS SUTAB ENTRY
*
OPT1     CLC   0(1,R6),0(R4)
         BL    OPT3                    NO LVTAB ENTRIES TO THIS FOR ST
         LR    R5,R4                   INITIALIZE CURRENT GROUP PTR
         BH    OPT6                    SCAN FOR NEXT LVTAB GROUP
OPT2     CLC   1(3,R5),4(R6)           CHECK FACTOR
         BE    OPT71                   NO OPTIMIZATION
         CLC   1(3,R5),7(R6)           CHECK ADDEND
         BE    OPT7                    NO OPTIMIZATION
         LA    R5,4(0,R5)              ADDR NEXT LVTAB ENTRY
         CLC   0(1,R5),0(R4)           NEW ENTRY OF SAME GROUP ?
         BE    OPT2                    YES, PROCEED CHECK
OPT3     C     R8,ZOTMAX               END OF OPTAB BUFFER ?
         BNL   OPT10                   YES
OPT4     MVC   0(14,R8),0(R6)          MOVE SUTAB ENTRY TO OPTAB
         SR    R2,R2
         IC    R2,0(0,R8)              FOR STATEMENT NO
         SR    R0,R0
OPT42    IC    R0,FOR1(R2)             FOR STATEMENT COUNT
         AH    R0,KH1                  INCREASE FS COUNT
         CL    R0,KF86                 > 85 ENTRIES IN OPTAB ?
         BL    OPT44                   NO
         LA    R1,FSTAB(R2)
         OI    0(R1),X'80'             SET ELEMENTARY LOOP
OPT44    STC   R0,FOR1(R2)             RESTORE FSN COUNT
         IC    R2,FOR2(R2)
         CL    R2,KF0                  ANY ENCLOSING FOR STMT ?
         BE    OPT46                   NO
         SH    R2,KH1                  GIVES CORRECT FSN
         B     OPT42                   ADD UP ENCLOSING LOOP
*
OPT46    LA    R8,14(,R8)              UPDATE OPTAB PTR
OPT5     LA    R6,14(,R6)              GET NEXT SUTAB ENTRY
         C     R6,ZSUDEN               SUTAB END ?
         BE    TERMIN                  YES
         TM    10(R6),SUCM             ACTIVE ENTRY ?
         BZ    OPT1                    YES
         B     OPT5                    NO, GET NEXT ENTRY
*
*        SCAN FOR NEXT LVTAB GROUP
*
OPT6     LA    R5,4(,R5)               GET NEXT LVTAB ENTRY
         CLC   0(1,R5),0(R4)           SAME GROUP ?
         BE    OPT6                    YES
         LR    R4,R5                   NO, SET LVTAB GROUP PTR
         B     OPT1
*
OPT7     CLC   4(3,R6),KF0             FACTOR ZERO ?
         BE    OPT72                   YES
OPT71    SR    R2,R2                   ADDR FSTAB ENTRY
         IC    R2,0(,R6)
         LA    R2,FSTAB(R2)
         OI    0(R2),X'80'             SET ELEMENTARY LOOP
*
*        HANDLE SUTAB CHAINING
*
OPT72    TM    10(R6),FIRSTM           ANY CHAINING ?
         BZ    OPT5
         LR    R7,R6                   INITIALIZE CHAIN SEARCH
OPT8     LA    R7,14(,R7)              NEXT SUTAB ENTRY
         CLC   11(3,R7),11(R6)         ENTRY IN CHAIN ?
         BNE   OPT8                    NO
         MVN   SUPOS(1),10(R7)         SUBSCRIPT NUMBER
         MVN   *+7(1),10(R6)           SUBSCRIPT NUMBER
         CLI   SUPOS,0                 SUBSCRIPT NUMBER EQUAL ?
         BNE   OPT8                    NO
         TM    10(R7),LASTM            LAST ENTRY IN CHAIN ?
         BO    OPT9                    YES
         NI    10(R7),OFFM             TURN OFF CHAIN BITS
         OI    10(R7),FIRSTM           SET FIRST ENTRY BIT
         B     OPT5
*
OPT9     NI    10(R7),OFFM             TURN OFF CHAIN BITS
         B     OPT5
*
OPT10    BAL   R9,OTACHA               CHANGE OPTAB BUFFER
         B     OPT4
*
TERMIN   C     R8,ZOTAFILL             ANY OPTAB ?
         BNE   TERMINNO                YES
         OI    COMPFLGS+2,NOPT         NO OPTAB PRESENT
         B     TERM1
*
TERMINNO C     R8,ZOTMAX               END OF OPTAB BUFFER ?
         BNE   TERMIN1                 NO
         BAL   R9,OTACHA               CHANGE OUTPUT BUFFER
TERMIN1  MVI   0(R8),X'FF'             INDICATE END OF SUTAB
         BAL   R9,OTACHA               WRITE LAST OPTAB RECORD
*
         CHECK OWRITE                  CHECK LAST OPTAB RECORD
*
         L     R0,AUT3DCB              R0 -> SYSUT3 DCB
*
         CLOSE ((R0),REREAD),TYPE=T    POINT TO BEGINNING OF DATASET
*
TERM1    LH    R4,FSNMAX
         SR    R3,R3
         SR    R1,R1
TERM12   LA    R1,1(,R1)
         CLR   R1,R4                   ALL FOR STMT CHECKED ?
         BH    TERM15                  YES
         LA    R2,FOR2(R1)
         CLC   KF0(1),0(R2)            ANY ENCLOSING LOOP ?
         BE    TERM12                  NO
         IC    R3,0(R2)                GET NO OF OPTAB ENTRIES
         SR    R2,R2
         IC    R2,FOR1-1(R3)           IN ENCLOSING LOOP
         CL    R2,KF86                 > 85 ?
         BL    TERM12                  NO
         LA    R2,255                  MARK FOR SUCCEDING FS
         STC   R2,FOR1(R1)             THAT THIS FS IS ELEMENT
         LA    R2,FSTAB(R1)
         OI    0(R2),X'80'             SET ELEMENTARY LOOP
         B     TERM12
*
TERM15   L     R0,TABSIZE              LENGTH OF TABLE AREA
         L     R1,TSTART
*
         FREEMAIN R,LV=(0),A=(1)
*
TERMIN2  TM    COMPFLGS,ERR            ERROR CONDITION ?
         BO    TERMERR                 YES
         B     IEX40001                SETUP INITIALIZATION FOR IEX50
*
TERMERR  XCTL  EP=IEX51ER2
*
NOSUTAB  OI    COMPFLGS+2,NOPT         SET NO SUBSCRIPT OPTIMIZATION
         B     TERMIN2
*
NOSUTAB1 OI    COMPFLGS+2,NOPT         SET NO SUBSCRIPT OPTIMIZATION
         B     TERM1
*
OTACHA   B     OTACHA2                 FIRST TIME SWITCH
*
         CHECK OWRITE
*
OTACHA1  L     R0,AUT3DCB              R0 -> SYSUT3 DCB
         L     R2,ZOTAFILL             ADDR OF BUFFER TO WRITE
         L     R3,OPTABS               SIZE OF OPTAB BUFFER
*
         WRITE OWRITE,SF,(R0),(R2),(R3)
*
         L     R8,ZOTAWRI              CHANGE OPTAB BUFFERS
         MVC   ZOTAWRI(4),ZOTAFILL
         ST    R8,ZOTAFILL
         LR    R2,R8
         A     R2,OPTABS               BUFFER END ADDR
         ST    R2,ZOTMAX
         BR    R9
*
OTACHA2  MVI   OTACHA+1,X'00'          SET OFF FIRST TIME SWITCH
         B     OTACHA1
*
*        R11                           START ADDR OF INPUT AREA
*        R10                           RECORD COUNT
*        R9                            RECORD IDENTIFICATION
*        R8                            RECORD LENGTH
*        R7                            RETURN REGISTER
*
READ     L     R1,AUT3DCB              R1 -> SYSUT3 DCB
         MVI   SULTSTRT+3,X'01'        ADDR FIRST INPUT RECORD
*
         POINT (1),SULTSTRT
*
READ1    L     R2,AUT3DCB              R2 -> SYSUT3 DCB
*
         READ  READR,SF,(R2),(R11),'S'
*
         CHECK READR
*
         C     R9,0(,R11)
         BNE   READ1
         MVC   0(4,R11),SAVETAB        RESTORE OVERLAYED PART
         BCT   R10,READ2               MORE RECORDS TO READ ?
         BR    R7                      NO
*
READ2    AR    R11,R8                  UPDATE CURRENT PT2
         MVC   SAVETAB(4),0(R11)
         B     READ1
*
*        R11                           LENGTH OF TABLE ENTRY
*        R10                           CURRENT PTR IN UNSORTED TABLE
*        R9                            END OF UNSORTED TABLE
*        R15                           RETURN REGISTER
*        R10                           RELATIVE ADDR IN SORTED TAB
*        R8                            PTR TO ACTUAL ADDR TAB ENTRY
*                                      START ADDR OF SORTED TABLE
*        R7                            PTR TO ACTUAL COUNT TAB ENTRY
*        R3                            ADDR OF LAST COUNT TAB ENTRY
*
SORT     MVC   ZCOSTA(1),KF0           ZERO TABLES
         MVC   ZCOSTA+1(254),ZCOSTA
         MVC   ZCOSTA+255(255),ZCOSTA
         MVC   ZADSTA(255),ZCOSTA
         MVC   ZADSTA+255(255),ZCOSTA
         L     R10,ZSTAD               CURRENT PTR
*
SORT1    CLI   0(R10),X'FF'            DELETED ENTRY ?
         BE    SORT2                   YES
         SR    R2,R2                   ISOLATE ACTUAL FSN
         IC    R2,0(,R10)
         AR    R2,R2                   FSN * 2
         LH    R3,ZCOSTA(R2)           GET OLD COUNTER
         LA    R3,1(,R3)               INCR
         STH   R3,ZCOSTA(R2)           STORE NEW COUNTER
*
SORT2    AR    R10,R11                 ADDR NEXT ENTRY
         CR    R10,R9                  END OF TABLE ?
         BL    SORT1                   NO
*
*        BUILD ADDRESS TABLE
*
         LH    R2,FSNMAX               GET ADDR OF LAST COUNT ENTRY
         AR    R2,R2
         LA    R3,ZCOSTA(R2)           LAST ENTRY
         SR    R10,R10                 RELATIVE ADDR IN NEW TABLE
         LA    R7,ZCOSTA               CURRENT COUNT TABLE PTR
         LA    R8,ZADSTA+2             CURRENT ADDR TABLE PTR
SORT3    CR    R7,R3                   LAST ENTRY ?
         BH    SORT4                   YES
         LH    R1,0(,R7)               NUMBER OF ENTRIES
         MR    R0,R11                  COMPUTE TABLE LENGTH
         AR    R10,R1                  RELATIVE TABLE ADDR
         STH   R10,0(,R8)              MAKE ENTRY IN ADDR TABLE
         LA    R7,2(,R7)               ADDR NEXT ENTRY
         LA    R8,2(,R8)               ADDR NEXT ENTRY
         B     SORT3
*
*        BUILD SORTED TABLE
*
SORT4    L     R10,ZSTAD               START OF UNSORTED TABLE
         L     R8,ZSORTSTA             START OF SORTED TABLE
         LR    R2,R11                  INITIALIZE MOVE OF ENTRY
         BCTR  R2,0
         STC   R2,SORTM+1              STORE LEN IN MVC INSTRUCTION
SORT5    CLI   0(R10),X'FF'            DELETED ENTRY ?
         BE    SORT6                   YES
         SR    R2,R2                   ISOLATE FSN
         IC    R2,0(,R10)
         AR    R2,R2                   FSN * 2
         LH    R3,ZADSTA(R2)           GET RELATIVE ADDR
         LR    R0,R3                   UPDATE RELATIVE ADDR
         AR    R0,R11
         STH   R0,ZADSTA(R2)
         AR    R3,R8                   GET ADDR IN SORTED TABLE
SORTM    MVC   0(0,R3),0(R10)          MOVE ENTRY
SORT6    AR    R10,R11                 GET NEXT ENTRY
         CR    R10,R9                  END OF TABLE ?
         BNE   SORT5                   NO
         BR    R15
*
         DC    0F'0'
SUTYPE   DC    C'SUTB'                 SUTAB IDENTIFICATION
LVTYPE   DC    C'LVTB'                 LVTAB IDENTIFICATION
KF0      DC    F'0'
KH8      DC    H'8'
SUPOS    DC    X'00'
         DC    0F'0'
FOR1     DC    XL256'00'               FOR STMT COUNT AREA
FOR2     DC    XL256'00'               ENCLOSING FS MARK AREA
KF86     DC    F'86'                   MAX ENTRIES IN OPTAB
FOR4     DC    3H'0'                   WORK AREA FOR GPTAB REC
KH1      DC    H'1'
*
        TITLE 'IEX40001 - INITIALIZATION OF COMPILATION PHASE, ALGOL F'
*
*        CALCULATE AND RESERVE SPACE NEEDED
*
IEX40001 LA    R2,INERR1
         ST    R2,ERET                 PROVIDE DIRECTORY RETURN ADDR
         SR    R2,R2                   INIT LENGTH OF RES AREA
         L     R3,SRCE1S               GET LENGTH OF 1ST SOURCE BUFFER
         TM    COMPFLGS+2,SPIC         SOURCE PROGRAM IN STORAGE ?
         BO    IN16                    YES
         LR    R2,R3                   NO, OBTAIN A SECOND BUFFER
IN16     TM    COMPFLGS+2,NOPT         ANY OPTAB ?
         BO    IN17                    NO
         L     R4,OPTABS               OBTAIN LENGTH OF OPTAB BUFFER
         AR    R2,R4                   ADD TO TOTAL LENGTH
         AR    R2,R4                   ADD LENGTH OF 2ND OPTAB BUFFER
IN17     L     R6,OOSTACKS             OBTAIN LENGTH OF OPERATOR STACK
         AR    R2,R6                   ADD TO TOTAL LENGTH
         LH    R7,LLAT                 OBTAIN LENGTH OF LAT
         AR    R2,R7                   ADD TO TOTAL LENGTH
         ST    R2,FREEMSIZ             STORE LENGTH OF RESERVED AREA
*
         GETMAIN R,LV=(R2)             RESERVE AREA
*
         LA    R5,INERR2
         ST    R5,ERET                 PROVIDE NEW DIR RETURN ADDR
         ST    R1,FREEMADR             STORE ADDR OF RESERVED AREA
*
*        LOAD REGISTERS FOR REST OF PHASE
*
         L     R8,IBUF1
         ST    R8,SOURCEB              SET FIRST BUFFER AS CURRENT
         LR    R10,R1                  GET CORRECT REG FOR OPT ST ADDR
         TM    COMPFLGS+2,SPIC         SOURCE PROGRAM IN STORAGE ?
         BO    IN18                    YES
         ST    R10,IBUF2               NO, STORE ADDR OF 2ND INPUT BUF
         ST    R10,RSRCB               SECOND BUFFER = READ BUFFER
         LA    R10,0(R3,R10)           GET ADDR OF NEXT RESERVED AREA
IN18     TM    COMPFLGS+2,NOPT         ANY OPTAB ?
         BO    IN19                    NO
         ST    R10,OPBUF1              YES, STORE ADDR OF FIRST OPTBUF
         ST    R10,AOPTABE             ADDR FIRST OPTAB ENTRY
         ST    R10,OPBUFB              FIRST OPTBUF = CURRENT
         LA    R10,0(R4,R10)           GET ADDR OF SECOND OPTAB BUFFER
         ST    R10,OPBUF2              STORE        -''-
         ST    R10,ROPTB               2ND OPTBUF = READ BUFFER
         LA    R10,0(R4,R10)           GET ADDR OF OPERATOR STACK
IN19     LA    R9,0(R6,R10)            GET ADDR OF LAT
         ST    R9,LATAB                STORE IT
         BCTR  R9,0                    GET ADDR OF OPERAND STACK
         L     R6,PRPT                 PRPOINTER
*
*        INITIALIZE WORKAREA FOR REST OF PHASE
*
         TM    COMPFLGS+2,NOPT         ANY OPTAB ?
         BZ    IN3A                    YES
         LA    R4,MAXFSN
         ST    R4,AOPTABE              NO, STORE ADDR OF MAX FS NUMBER
IN3A     LA    R4,SUTABC-9
         ST    R4,SUTABCA              INIT LAST USED SUTAB ENTRY
         LA    R4,IOTAB
         LA    R3,GPBN                 COMPUTE LENGTH OF AREA WITH 0
         SR    R3,R4
         STC   R3,IN3B+1               STORE IN MOVE INSTRUCTION
         MVI   0(R4),0
IN3B     MVC   1(0,R4),0(R4)           MOVE ZEROES
         MVI   MAXFSN,X'FF'            INSERT MAX FS NUMBER
         MVI   CII+1,X'07'
         MVI   CIR+1,X'06'
         MVI   CLEARDIS,X'F0'
         MVI   ONEENTRY+1,X'08'        INSERT VALUES FOR LONG PREC
         MVC   MAXOVERF(2),LONG
         TM    COMPFLGS,LNG            LONG PRECISION ?
         BO    IN3                     YES, BRANCH
         MVI   ONEENTRY+1,X'04'        SHORT, CHANGE VALUES
         MVI   PRECMASK,X'10'
         MVC   MAXOVERF(2),SHORT
IN3      MVI   GPBN+1,X'FF'
         MVC   SEMCNT,KH0              ZERO SEMICOLON COUNTER
*
*        INITIALIZE OPERATOR STACK
*
         MVI   0(R10),X'25'            INSERT OPERATOR ALPHA
*
*        INITIALIZATION OF LABEL ADDRESS TAB
*
         L     R2,LATAB
         MVI   0(R2),0                 ZERO BEGINNING OF LAT
         MVC   1(LATBEG-1,R2),0(R2)
         LA    1,15                    ZERO
         LA    11,79(,R2)                   REST
TSTZER   MVC   1(256,11),0(11)                   OF
         LA    11,256(,11)                            LAT
         BCT   1,TSTZER                                   FOR
         MVC   1(176,11),0(11)                                 TEST
         LA    R3,LATNR
IN4      MVI   0(R2),X'80'             TURN ON FIRST BIT IN LAT ENTRY
         LA    R2,4(,R2)               STEP ADDR
         BCT   R3,IN4                  HANDLE NEXT ENTRY IF ANY
*
*        START READ IN OF SOURCE PROGRAM, IF NECESSARY
*
         TM    COMPFLGS+2,SPIC         SOURCE PROGRAM IN STORAGE ?
         BZ    IN6                     NO, NO BRANCHES WILL BE TAKEN
         OI    IN6+1,X'F0'             YES, ALL BRANCHES WILL BE TAKEN
         OI    IN9+1,X'F0'
         OI    IN14+1,X'F0'
*
IN6      NOP   IN22                    BRANCH IF SOURCE PROG IN CORE
         L     R3,AUT2DCB              R3 -> SYSUT2 DCB
*
         READ  SRC1,SF,(3),(8)         READ FIRST SOURCE RECORD
*
IN22     BCTR  R8,0                    INIT SOURCE POINTER
*
*        CONSTRUCT PBTAB3
*
         LA    R2,PBTAB2               START ADDR OF PBTAB2 IN WORKAREA
         LA    R5,PBTAB3               START ADDR OF PBTAB3 IN WORKAR
         LH    R4,PBN                  GET NUMBER OF PRG BLOCKS
         LA    R4,1(,R4)
IN8      MVC   0(2,R5),0(R2)           MOVE ONE PBTAB2 ENTRY
         MVC   2(2,R5),KH0             ZERO REST OF ENTRY
         LA    R2,2(,R2)               STEP ADDRS
         LA    R5,4(,R5)
         BCT   R4,IN8                  MOVE NEXT IF NOT ALL MOVED
*
*        CHECK READ OF FIRST SOURCE RECORD IF NECESSARY
*
IN9      NOP   IN10                    BRANCH IF SOURCE PROG IN CORE
*
         CHECK SRC1
*
IN10     LA    R2,1                    INIT RECORD COUNT
         STC   R2,NUMBBL               STORE IT
*
*        START READING OF OPTAB
*
         TM    COMPFLGS+2,NOPT         OPTAB EMPTY ?
         BO    IN14                    YES, BYPASS READING
         LA    R2,IN14
         ST    R2,EODUT3               GIVE ADDR OF EOD RTN TO DIR
         L     R2,OPBUF1               GET ADDR OF FIRST BUFFER
         L     R4,AUT3DCB              R4 -> SYSUT3 DCB
*
IN12     READ  OPTB1,SF,(4),(2),'S'    READ FIRST RECORD
*
         CHECK OPTB1
*
IN13     NOP   IN14                    BRANCH AFTER SECOND CHECK
         L     R2,OPBUF2               GET ADDR OF SECOND BUFFER
         OI    IN13+1,X'F0'
         B     IN12                    READ SECOND RECORD
*
*        READ SECOND SOURCE RECORD IF ANY
*
IN14     NOP   IN15                    BRANCH IF SOURCE PROGRAM IN CORE
         LA    R2,IN15
         ST    R2,EODUT2               GIVE ADDR OF EOD RTN TO DIR
         L     R2,IBUF2                GET ADDR OF 2ND BUFFER
*
         READ  SRC2,SF,(3),(2)         READ 2ND RECORD
*
         CHECK SRC2
*
IN15     NI    COMPFLGS+2,255-NOSC     SET SEMICOLON COUNTER VALID FLAG
*
*        XCTL TO NEXT LOAD MODULE
*
         XCTL  EP=IEX50000
*
*        DIRECTORY RETURN BEFORE GETMAIN
*
INERR1   XCTL  EP=IEX51ER2
*
*        DIRECTORY RETURN AFTER GETMAIN
*
INERR2   XCTL  EP=IEX51ER1
*
*        CONSTANTS
*
LLAT     DC    H'4096'                 LENGTH OF LABEL ADDR TABLE
SHORT    DC    H'4092'                 TO CHECK OBJ TIME STACK OVFLOW
LONG     DC    H'4088'                              -''-
*
         LTORG
*
WORKAREA DSECT
*
         COPY  WORKAREA
*
         ORG   SYSUT1
*
FSNMAX   DS    H
LVCOUNT  DS    H
SUCOUNT  DS    H
ZLEVEN   DS    F
ZSUTEN   DS    F
ZCOSTA   DS    255H                    SORT COUNT TABLE
ZADSTA   DS    255H                    SORT ADDR TABLE
TSTART   DS    F                       START OF TABLE AREA
SAVETAB  DS    F                       AREA TO SAVE TABLE END
ZSTAD    DS    F                       START ADDR OF UNSORTED TABLE
ZSORTSTA DS    F                       START ADDR OF SORTED TABLE
ZSUDAD   DS    F                       START OF SORTED SUTAB
ZSUDEN   DS    F                       END ADDR OF SORTED SUTAB
ZLESTA   DS    F                       START ADDR OF SORTED LUTAB
ZOTAFILL DS    F                       OPTAB WORK BUFFER ADDR
ZOTAWRI  DS    F                       OPTAB WRITE BUFFER ADDR
ZOTMAX   DS    F                       END OF OUTPUT BUFFER IN USE
TABSIZE  DS    F                       SIZE OF TABLE AREA
*
*        AREA USED BY COMPILATION PHASE
*
         ORG   SYSUT1
*
RETADR   DS    17F                     SAVE AREA
PLACE14  DS    F                          -''-
RUTI     DS    9F                      GPR CONTROL
RUTR     DS    4F                      FLREG CONTROL
GPROLN   DS    H                       LABEL NR OF OBJ PRG ENTRY POINT
KONSUM   DS    H                       WORKPLACE
WORKPL   DS    F                       WORKPLACE
IBUF1    EQU   SRCE1ADD                ADDR OF FIRST SOURCE BUFFER
IBUF2    DS    A                         -''  SECOND    -''-
SOURCEB  DS    A                         -''  CURRENT   -''-
RSRCB    DS    A                         -''  READ      -''-
OPBUF1   DS    A                       ADDR OF FIRST OPTAB BUFFER
OPBUF2   DS    A                         -''-  SECOND    -''-
OPBUFB   DS    A                         -''-  CURRENT   -''-
ROPTB    DS    A                         -''-  READ      -''-
AOPTABE  DS    A                       ADDR OF CURRENT OPTAB ENTRY
LATAB    DS    A                       ADDR OF LABEL ADDR TABLE
APBTAB4  EQU   LATAB                   ADDR OF PBTAB4
SUTABCA  DS    A                       ADDR OF LAST USED SUTAB ENTRY
STRETURN DS    F                       RETURN ADDR
FREEMADR DS    A                       ADDR FOR FREEMAIN IN 50000
FREEMSIZ DS    F                       SIZE          -''-
*
PBTAB3   DS    1024C                   PROGRAM BLOCK TABLE, 3RD VERS
*
IOTAB    DC    18X'00'                 LIST OF DATA SETS
CII      DC    H'0'                    REGISTER CONTROL
CIR      DC    H'0'                          -''-
RII      DC    H'0'                          -''-
RIR      DC    H'0'                          -''-
OPDPBN   DC    H'0'                    PROGRAM BLOCK NR (BYTE 2 OF OPD
OPDADR   DC    H'0'                    BYTES 3 AND 4 OF OPERAND
OPDLN    DC    H'0'                    LABEL NUMBER TIMES FOUR
KH0      DC    H'0'                    ZEROES
CFSN     DC    X'00'                   CURRENT FS NUMBER
MAXFSN   DC    X'FF'                   MAX FS NUMBER
CLEARDIS DC    X'F000'                 FOR CLEARING OF DISPLACEM PART
ONEENTRY DC    H'4'                    SHORT, FOR INCR OF OT STACK PTR
         ORG   ONEENTRY
         DC    H'8'                    LONG            -''-
PRECMASK DC    X'10'                   SHORT, TO MODIFY INSTRUCTIONS
         ORG   PRECMASK
         DC    X'00'                   LONG            -''-
NUMBBL   DC    X'00'                   RECORD COUNTER
         DS    H
SPBNST   DC    H'0'                    CURRENT PBN
         DS    H                                   AND DISPLACEMENT
GPBN     DC    H'255'                  GLOBAL DSA CONTROL
MAXOVERF DC    H'4092'                 SHORT, TO CHECK OT STACK OVERFL
         ORG   MAXOVERF
         DC    H'4088'                 LONG            -''-
HALFW    DS    H                       WORKPLACE
USPEI2   DS    H                       FOR ARRAY DECLA-
USPEI4   DS    H                                       RATION HANDLING
WPLACE   DS    H                       FOR INSTRUCTION GENERATION
XPLACE   DS    H
YPLACE   DS    H
UPLACE   DS    H
VPLACE   DS    C                                   -''-
STRDNAME DS    5C                      TO STORE OPERAND
CBVTAB   DS    48C                     CALLED-BY-VALUE TABLE
SUTABC   DS    768C                    FOR SUBSCRIPT OPTIMIZATION
         ORG   SUTABC
DSTAB    DS    608C                    DATA SET TABLE
*
*        CHARACTER EQUATES
*
         IEXCHAR
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END   IEX40000
./ ADD NAME=IEX50    0201-12230-12230-1200-01946-01946-00000-LEVEL
X50      TITLE 'IEX50 - COMPILATION PHASE, ALGOL F'
*
*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER
*
*        FUNCTION/OPERATION -
*        THIS MODULE PERFORMS THE REAL TRANSLATION OF THE SOURCE
*        PROGRAM INTO SYSTEM/360 INSTRUCTIONS. THE SOURCE
*        PROGRAM IS AT MODIFICATION LEVEL 2 AND CONSISTS OF A
*        SEQUENCE OF ONE BYTE OPERATORS AND FIVE BYTE OPERANDS,
*        WHICH IS SCANNED SEQUENTIALLY. THE STATUS OF RECOGNITION
*        OF THE SOURCE PROGRAM IS DESCRIBED BY -
*        1. A SEQUENCE OF CONTEXTS (SEE BELOW)
*        2. A SEQUENCE OF STACKED OPERATORS (THE OPERATOR STACK)
*
*        THE ACTION OF THE COMPILER IS DETERMINED BY THE
*        OPERATOR PAIR STACK-SOURCE OPERATOR AND THE CURRENT
*        CONTEXT. THE OPERATOR PAIR DETERMINES AN ELEMENT IN A
*        DECISION MATRIX, WHICH IS DETERMINED BY THE CONTEXT. THE
*        MATRIX ELEMENTS REPRESENT ADDRESSES OF THE COMPILER
*        PROGRAMS, WHICH PERFORM THE ACTIONS REQUESTED BY ALL
*        POSSIBLE OPERATOR PAIRS.
*
*        THERE ARE THREE CONTEXTS, PROGRAM, STATEMENT, AND
*        EXPRESSION CONTEXT, AND THE CURRENT CONTEXT IS INDICATED
*        BY A REGISTER. SWITCHING ING FROM ONE CONTEXT TO
*        ANOTHER IS IN MOST CASES DETERMINED BY THE STACK-SOURCE
*        OPERATOR PAIR, IE THE COMPILER PROGRAM ACTIVATED JUST
*        PERFORMS THE CHANGE OF CONTEXT, BUT IN A FEW CASES THE
*        SOURCE OPERATOR ALONE DETERMINES THE NEW CONTEXT. IN
*        THIS LATTER CASE THE OPERATOR IS STACKED TOGETHER WITH A
*        CONTEXT OPERATOR, INDICATING THE PRECEDING CONTEXT.
*
*        BESIDES THE COMPILER PROGRAMS THERE ARE OTHER ROUTINES
*        PROVIDING DIFFERENT SERVICES. THE MOST IMPORTANT ARE
*        (THOSE MARKED WITH * ARE USED AS SUBROUTINES BY THE
*        COMPILER PROGRAMS) -
*
*        SUBSTART - SCAN TO NEXT OPERATOR IN SOURCE PROGRAM
*        COMP     - CHOOSE COMPILER PROGRAM AND BRANCH
*        JBUFFER  - READ A NEW SOURCE PROGRAM RECORD
*       *NXTOPT   - GET NEXT ENTRY OF OPTAB
*       *SERR     - GENERATE AN ERROR PATTERN
*        CPEND    - NORMAL TERMINATION
*        CPERRI   - ABNORMAL TERMINATION
*       *GENERATE - GENERATE TXT AND RLD RECORDS
*
*        A COMPILER PROGRAM IS ALWAYS FOLLOWED BY SUBSTART OR COMP
*        OR A BRANCH TO ANOTHER COMPILER PROGRAM
*
*        THE MODULE CONSISTS OF SEVEN CONTROL SECTIONS
*        IEX50000 - INITIALIZATION AND SUBROUTINES
*        IEX50001 - DECISION MATRIXES
*        IEX50002 - COMPILER PROGRAMS HANDLING FOR STATEMENTS
*                   AND SUBSCRIPT OPTIMIZATION
*        IEX50003 - COMPILER PROGRAMS HANDLING BEGIN AND END OF
*                   COMPOUND STATEMENTS AND BLOCKS, PROCEDURE
*                   DECLARATIONS, ARRAY DECLARATIONS, SWITCH
*                   DECLARATIONS, GOTO STATEMENTS, SUBSCRIPTED
*                   VARIABLES AND SWITCH DESIGNATORS, SEMICOLON
*                   COUNTER
*        IEX50004 - COMPILER PROGRAMS HANDLING ASSIGNMENTS,
*                   PROCEDURE CALLS, STANDARD PROCEDURE CALLS
*        IEX50005 - COMPILER PROGRAMS HANDLING ERRONEOUS CASES,
*                   BOOLEAN OPERATIONS, ARITHMETIC MINUS, IF,
*                   THEN, ELSE
*        IEX50006 - COMPILER PROGRAM HANDLING ARITHMETICAL
*                   OPERATIONS
*
*        ENTRY POINT -
*        IEX50000 - COMPILATION PHASE XCTL EP=IEX50
*        THE MODULE IS ENTERED FROM IEX40
*
*        INPUT -
*        THE SOURCE PROGRAM IS READ FROM SYSUT2
*        OPTAB IS READ FROM SYSUT3
*
*        OUTPUT -
*
*        THE MAIN PART OF THE OBJECT MODULE IS OUTPUT TO SYSLIN
*        AND/ OR SYSPUNCH IF THE OPTIONS 'LOAD' AND/OR 'DECK' ARE
*        SPECIFIED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXIT - NORMAL -
*        IF NO TERMINATING ERROR HAS OCCURRED, CONTROL IS GIVEN
*        TO THE TERMINATING MODULE BY MEANS OF XCTL EP=IEX51000
*
*        EXIT - ERROR -
*        IF A TERMINATING ERROR HAS OCCURED, CONTROL IS GIVEN TO
*        THE TERMINATING MODULE BY MEANS OF XCTL EP=IEX51ER1
*
*        TABLES/WORKAREAS -
*        SCPTAB  - COMPILER PROGRAM ADDR TABLE USED BY ROUTINE
*                  COMP
*        TXTT    - INFORMATION FOR TXT RECORDS USED BY ROUTINE
*                  GENERATE
*        RLDT    - INFORMATION FOR RLD RECORDS USED BY ROUTINE
*                  GENERATE
*        DECAREA - DECISION MATRIXES USED BY ROUTINE COMP
*
*        THE PART OF COMMON WORKAREA STARTING AT SYSUT1 IS
*        INITIALIZED BY THE PRECEDING LOAD MODULE AND USED BY
*        THIS AND THE NEXT LOAD MODULE
*
*        THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN
*        CONNECTION WITH THE OTHER MODULES OF THE ALGOL COMPILER
*        IN PARTICULAR IT REQUIRES THE COMMON WORKAREA
*
IEX50000 CSECT
*
*        R6                            REL ADDR IN OBJ PROGRAM
*        R7                            DISP IN OBJECT TIME STACK
*        R8                            SOURCE PROGRAM POINTER
*        R9                            OPERAND STACK POINTER
*        R10                           OPERATOR STACK POINTER
*        R11                           INDICATES CURRENT CONTEXT
*        R12                           BASE ADDR OF COMP PROGRAMS
*
*        OBJECT TIME REGISTER DEFINITIONS
*
FPR0     EQU   0                       *
FPR2     EQU   2                       *
GPRA     EQU   3                       *   VARIABLE USE
GPRB     EQU   5                       *
GPRC     EQU   6                       *
ADR      EQU   8                       FOR TRANSFER OF ADDRS
CDSA     EQU   10                      ADDRS CURRENT DSA
GDSA     EQU   9                       ADDRS GLOBAL DSA
PBT      EQU   11                      ADDRS PROGRAM BLOCK TABLE
LAT      EQU   12                      ADDRS LABEL ADDR TABLE (LAT)
FSA      EQU   13                      ADDRS FIXED STORAGE AREA
ENTRY    EQU   15                      ENTRY PT OF LIBRARY SUBRTNS
BRR      EQU   15                      LINK REGISTER
*
*        INITIALIZATION
*
*        THIS ROUTINE PERFORMS THE REMAINING INITIALIZATION
*        THE MAIN PART IS MADE IN IEX40001
*
         IEXENTRY 'IEX50000 LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IEX50000,R15            USE ENTRY POINT REG AS BASE
         USING WORKAREA,R13
         LA    R5,SUBSTART             LOAD BASE REG FOR SUBSTART
         DROP  R15
         USING SUBSTART,R5
         LA    R4,CPERR1               PROVIDE DIRECTORY
         ST    R4,ERET                 RETURN ADDR
         L     R11,DECAADD             LOAD ADDR OF CCT
         LA    R4,JB3                  PROVIDE
         ST    R4,EODUT2               EOD ADDR
         LA    R4,NX4                  FOR UT2
         ST    R4,EODUT3               AND UT3
         CNOP  0,8
*
*        START OF SUBROUTINE POOL
*
*        SCAN SOURCE INPUT TO NEXT OPERATOR
*
SUBSTART NI    COMPFLGS,255-OPERAND    OPERAND FLAG OFF
ABC1     CLI   1(R8),XFZETA            TEST SOURCE
         BL    ABD3                    OPERATOR
         BH    ABD1                    OPERAND
         BAL   R4,JBUFFER              BUFFER CHANGE
         B     ABC1                    CONTINUE
*
ABD3     LA    R8,1(,R8)               INCR SOURCE PTR
         B     COMP                    CHOOSE CP
*
ABD1     OI    COMPFLGS,OPERAND        OPERAND FLAG ON
         SH    R9,KH5                  SOURCE OPERAND
         CR    R10,R9                  TO
         BNL   STACKOFL                STACK
         MVC   0(5,R9),1(R8)
         LA    R8,5(,R8)               SOURCE REG INCREASE
         B     ABC1                    CONTINUE
*
*        AN OPERAND IS NOT ALLOWED IN SOURCE
*
SPECTEST CLI   1(R8),XFZETA            SPECIAL TEST
         BL    ABD3                    OPERATOR
         BH    ABD5                    OPERAND
         BAL   R4,JBUFFER              BUFFER CHANGE
         B     SPECTEST
*
ABD5     LA    R8,6(R8)                SOURCE REG INCREASE
         BAL   R4,SERR3
ERROR    DC    H'191'
*
         BCTR  R8,0                    SOURCE PTR MINUS ONE
         B     SPECTEST
*
*        CHOOSE CP PROGRAM
*
COMP     SR    R1,R1
         LR    R2,R1
         IC    R1,0(,R8)               FETCH SOURCE OPERATOR
         IC    R1,0(R1,R11)            COLUMN VECTOR
         IC    R2,0(,R10)              FETCH STACK OPERATOR
         IC    R2,50(R2,R11)           ROW VECTOR
         AR    R1,R2
         IC    R1,100(R1,R11)
         SLL   R1,2(0)                 COMPILER PROGRAM FROM MATRIX
         L     R12,SCPTAB(R1)          FIND BASE ADDR
         BR    R12                     BRANCH TO COMPILER PROGRAM
*
***********************************************************************
*
*        JBUFFER - READ INPUT BUFFER
*
***********************************************************************
*
* CALL   BAL   R4,JBUFFER              (FROM SUBSTART)
*        BAL   R4,JBUFFER              (FROM COMPILER PROGRAMS)
*
*        REGISTER DEFINITIONS
*
*        R3                            SYSUT2 DCB
*        R2                            ADDR OF CURRENT BUFFER
*        R8                            ADDR OF CURRENT INPUT BUFFER
*
JBUFFER  L     R3,AUT2DCB              R2 -> SYSUT2 DCB
         L     R2,SOURCEB              GET ADDR OF CURRENT BUFFER
JB1      B     JB2                     NO CHECK FIRST TIME
*
         CHECK SRCECO                  CHECK PREVIOUS READ
*
JB2      READ  SRCECO,SF,(R3),(R2)
*
JB3      L     R8,RSRCB                GET ADDR OF OLD READ BUFFER
         ST    R2,RSRCB                CHANGE ADDRS
         ST    R8,SOURCEB
         BCTR  R8,0                    GET START ADDR - 1
         IC    R3,NUMBBL               STEP
         LA    R3,1(,R3)                    RECORD
         STC   R3,NUMBBL                           COUNTER
         MVI   JB1+1,X'00'             CHANGE BRANCH CONDITION
         BR    R4                      RETURN
*
***********************************************************************
*
*        NXTOPT - ACQUIRES NEXT ENTRY OF OPTAB
*
***********************************************************************
*
* CALL   BAL   R4,NXTOPT
*
NXTOPT   L     R2,OPBUFB               GET ADDR OF CURRENT BUFFER
         L     R3,OPREL                GET REL ADDR OF NEW ENTRY
         LA    R3,14(,R3)
         C     R3,OPTABS               A NEW BUFFER REQUIRED ?
         BNL   NX1                     YES
         AR    R2,R3                   NO, STORE
         ST    R2,AOPTABE              ADDR OF NEW ENTRY
         B     NX3
*
NX1      B     NX2                     NO CHECK FIRST TIME
*
         CHECK OPTCO                   CHECK PREVIOUS READ
*
NX2      L     R3,AUT3DCB              R3 -> SYSUT3 DCB
*
         READ  OPTCO,SF,(R3),(R2),'S'  READ OPTAB RECORD
*
         MVI   NX1+1,X'00'             CHANGE BRANCH CONDITION
NX4      L     R1,ROPTB                GET ADDR OF OLD READ BUFFER
         ST    R1,OPBUFB               CHANGE
         ST    R2,ROPTB                       ADDRS
         ST    R1,AOPTABE              STORE
         SR    R3,R3                         ADDRS OF
NX3      ST    R3,OPREL                                   NEW ENTRY
         BR    R4                      RETURN
*
OPREL    DC    F'0'                    REL ADDR IN CURRENT BUFFER
*
*        CONSTANTS LOCATED IN SUBROUTINE POOL
*
KH2      DC    H'2'
KH4      DC    H'4'
KH5      DC    H'5'
KH8      DC    H'8'
KH9      DC    H'9'
KH10     DC    H'10'
KH15     DC    H'15'
KH20     DC    H'20'
KH290    DC    H'290'
KH324    DC    H'324'
KH614    DC    H'614'
API      DC    X'91FF01000000'
*
TYPETEST DC    F'3'
SWVAL    DC    H'0'
SWREL    DC    H'0'
GREGN    DC    H'0'
         DC    0F'0'
DECAADD  DC    A(DECAREA)               ADDR OF DECISION AREA
*                                       ADDR OF PROG CONTEXT COL VECTOR
HEXFFF   DC    X'00000FFF'
STC      DC    A(ADRSTC)                ADDR OF STMT CONTEXT COL VECTOR
EXC      DC    A(ADREXC)                ADDR OF EXPR CONTEXT COL VECTOR
*
***********************************************************************
*
*        COMPILER PROGRAM ADDR TABLE
*
***********************************************************************
*
         DC    0F'0'
SCPTAB   DC    A(CP0,CP1,CP84,CP3)
         DC    A(CP4,CP84,CP6,CP7)
         DC    A(CP8,CP84,CP84,CP84)
         DC    A(CP12,CP84,CP84,CP84)
         DC    A(CP16,CP17,CP18,CP19)
         DC    A(CP20,CP21,CP22,CP23)
         DC    A(CP24,CP25,CP26,CP27)
         DC    A(CP28,CP29,CP30,CP31)
         DC    A(CP84,CP33,CP34,CP84)
         DC    A(CP36,CP84,CP38,CP84)
         DC    A(CP40,CP41,CP84,CP43)
         DC    A(CP84,CP45,CP84,CP47)
         DC    A(CP84,CP49,CP84,CP51)
         DC    A(CP52,CP84,CP54,CP84)
         DC    A(CP56,CP57,CP84,CP59)
         DC    A(CP84,CP61,CP62,CP63)
         DC    A(CP64,CP65,CP66,CP67)
         DC    A(CP68,CP69,CP70,CP71)
         DC    A(CP72,CP73,CP74,CP75)
         DC    A(CP76,CP77,CP78,CP79)
         DC    A(CP80,CP81,CP84,CP83)
         DC    A(CP84,CP85,CP86,CP87)
*
*        NON EXISTANT COMPILER PROGRAMS
*
*        CP2,  CP5,  CP9,  CP10, CP11, CP13, CP14, CP15, CP32,
*        CP35, CP37, CP39, CP42, CP44, CP46, CP48, CP50, CP53,
*        CP55, CP58, CP60, CP82
*
***********************************************************************
*
*        ERROR PATTERN GENERATION
*
***********************************************************************
*
* CALL   BAL   R4,SERRX                X=1, 2, 3, 4, SP
*        DC    H'N'                    N=MSG NUMBER
*
*        ENTRY BOTH OPERATORS
*
SERR4    LA    R3,2
         LA    R2,6                     GET LENGTH OF ENTRY
         B     ER2
*
*        ENTRY STACK OPERATOR
*
SERR2    LA    R3,3
         B     ER1
*
*        ENTRY SOURCE OPERATOR
*
SERR3    LA    R3,1
ER1      LA    R2,5                    GET LENGTH OF ENTRY
ER2      L     R15,NEXTERR             GET ADDR OF POOL ENTRY
         STC   R2,0(,R15)              INSERT LENGTH OF ENTRY
         LA    R2,4                    SET POINTER FOR OPERATOR INSERT
         BCT   R3,ER4                  BRANCH IF STACK OR BOTH
*
ER3      MVC   EP212+3(1),0(R8)        GET SOURCE OP
         OI    EP212+3,X'80'           PUT A TAG
         IC    R1,EP212+3              INSERT SOURCE OPERATOR
         B     ER5
*
ER4      IC    R1,0(,R10)              FETCH STACK OPERATOR
ER5      STC   R1,0(R2,R15)            INSERT OPERATOR
         LA    R2,1(,R2)               INCREASE POINTER
         BCT   R3,ER6                  STACK OR SOURCE, BRANCH
         B     ER3                     BOTH
*
*        SPECIAL ENTRY FOR MSG 214
*
SERRSP   L     R15,NEXTERR             GET ADDR OF POOL ENTRY
         LH    R3,SPBNST               GET CURRENT PBN
         CVD   R3,ERDOUBLE             BINARY
         UNPK  ERDOUBLE(3),ERDOUBLE+6(2)       TO
         MVZ   ERDOUBLE+2(1),ERDOUBLE              CHARACTER
         MVC   4(3,R15),ERDOUBLE       MOVE TO ERROR PATTERN
         LA    R2,7                    SET LENGTH OF ENTRY
         STC   R2,0(,R15)
         B     ER6
*
*        ENTRY NO OPERATOR
*
SERR1    L     R15,NEXTERR
         LA    R2,4                    INSERT LENGTH OF ENTRY
         STC   R2,0(,R15)
ER6      MVC   2(2,R15),SEMCNT         INSERT SEMICOLON COUNTER
         IC    R3,1(,R4)               INSERT ERROR NUMBER
         STC   R3,1(,R15)
         LA    R15,0(R2,R15)           UPDATE PTR TO NEXT ENTRY
         ST    R15,NEXTERR
         C     R15,ENDPOOL             POOL FULL ?
         BNH   ER7                     NO
         MVC   EP212+2(2),SEMCNT       YES, MOVE PATTERN FOR M212
         MVC   0(4,R15),EP212
         LA    R15,4(0,R15)            UPDATE PTR TO NEXT ENTRY
         ST    R15,NEXTERR
         B     CPERR1                  GOTO TERMINATION
*
ER7      OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         LA    R3,2                    STEP RETURN ADDR
         AR    R4,R3
         BR    R4                      R4 TO CALLER
*
EP212    DC    X'04D40000'             ERROR PATTERN FOR MSG 212
ERDOUBLE DC    D'0'
*
*        OPERAND/OPERATOR STACK OVERFLOW
*
* CALL   B STACKOFL
*
STACKOFL BAL   R4,SERR1
         DC    H'186'
*
         B     CPERR1
*
*        NORMAL TERMINATION
*
CPEND    TM    COMPFLGS+2,SPIC         SOURCE IN STORE ?
         BO    CPEND1                  YES
         BAL   R4,JBUFFER              NO, CHECK LAST READ
CPEND1   TM    NX1+1,X'F0'             OPTAB READ IN IEX50 ?
         BO    CPEND2                  NO
         BAL   R4,NXTOPT               NO, CHECK LAST READ
*
CPEND2   XCTL  EP=IEX51000             XCTL TO NEXT MODULE
*
*        DIRECTORY RETURN ADDR
*
CPERR1   TM    JB1+1,X'F0'             READ TO INPUT BUFFERS
         BO    CPERR10                 NO
*
         CHECK SRCECO                  CHECK LAST READ
*
CPERR10  TM    NX1+1,X'F0'             OPTAB READ
         BO    CPERR11                 NO
*
         CHECK OPTCO                   CHECK LAST READ
*
CPERR11  XCTL  EP=IEX51ER1             ERROR MSG EDITING AND TERM
*
         DC    0H'0'
*
***********************************************************************
*
*        CONVERSION - INTEGER TO REAL
*
***********************************************************************
*
*        GENERATES CALL OF CONVERSION ROUTINE FROM INTEGER TO
*        REAL AFTER LOCATING THE OPERAND
*        RESERVES ONE OBJECT STACK TIME ENTRY
*        SETS RIR
*        INTRODUCES OPERAND ADDRS INTO RUTR
*        ADJUSTS OPERAND
*
* CALL   BAL   R4,TRINRE
*
TRINRE   ST    R4,RETADR               STORE RETURN ADDR
         LA    R4,HQF21
         BAL   R3,ROUTIN15
         SR    R1,R1
         IC    R1,3(R9)                PREPARE INSTRUCTION
         SRL   R1,4
         LA    R2,1
         SLL   R2,0(R1)
         STC   R2,HQD2+1
         XI    HQD2+1,X'FF'
HQD2     NI    RII+1,X'00'
         BAL   R4,ROUTINE8             RELILO
         MVN   HQG1+1(1),VPLACE
         BAL   R2,GENTXT2
HQG1     LR    R14,0                   ***GENERATE***
HQH1     TM    RIR+1,X'01'             FPRO FREE ?
         BZ    HQJ1                    YES, BRANCH
         BAL   R4,ROUTIN14             STFPR0
HQJ1     TM    RII,X'01'               ADR FREE ?
         BZ    HQJ11
         BAL   R4,ROUTIN10
HQJ11    BAL   R2,GENTXT4              CALL CONVERSION ROUTINE
*        BAL   ADR,CNVIRD(0,FSA)       ***GENERATE***
         BAL   R8,X'120'(,13)          ***NEW GENERATED ***
         OI    0(R9),X'80'             ADJUST R9 ENTRY
         NI    0(R9),X'9F'
         OI    1(R9),X'32'
         NI    1(R9),X'FE'
         MVC   2(1,R9),SPBNST+1
         AH    R7,ONEENTRY             INCR OF 4(SHORT) OR 8(LONG)
         STH   R7,WORKPL
         MVC   3(2,R9),WORKPL          INTRODUCE STACK ADDR
         ST    R9,RUTR                 INTRODUCE R9 ADDR IN RUTR
         OI    RIR+1,X'01'             SET RIR TO ONE
         MVI   CIR+1,0                 CIR=0
         L     R4,RETADR               LOAD RETURN ADDR
         BR    R4
*
HQF21    MVN   HQG2+1(1),VPLACE        PREPARE INSTRUCTION
         MVC   HQG2+2(2),WPLACE
         BAL   R2,GENTXT4
HQG2     L     R14,0(0,0)              ***GENERATE***
         B     HQH1
*
***********************************************************************
*
*        CONVERSION - REAL TO INTEGER
*
***********************************************************************
*
*        SUBROUTINE TO GENERATE CODE TO CALL REAL TO INTEGER
*        CONVERSION ROUTINE
*
* CALL   BAL   R4,TRREIN
*
*        AT OBJECT TIME THE INTEGER VALUE IS IN R14 AFTER CONVERSION
*
*        BIT PATTERNS
*
OBJSTM   EQU   X'C0'                   OBJECT STACK MASK
RADRFREM EQU   X'01'                   REG ADDR FREE MASK
FPROOCM  EQU   X'01'                   FPR0 MASK
OPDVALUM EQU   X'20'                   VALUE MASK
OPDREGM  EQU   X'40'                   REGISTER MASK
*
TRREIN   ST    R4,SAVTRREI             SAVE RETURN ADDR
         TM    RIR+1,FPROOCM           FPR0 OCCUPIED ?
         BZ    TRREIN1                 NO
         C     R9,RUTR                 OPERAND IN FPR0
         BE    TRREIN8                 YES, RELEASE FPR0
         BAL   R4,ROUTIN14             STORE FPR0
         NI    RIR+1,255-FPROOCM       MARK FPR0 FREE
TRREIN1  LA    R3,TRREIN4              ADDR IF VALUE IN REG
         BAL   R4,ROUTIN15             FIND DISPL AND REG
TRREIN2  MVN   TRREIN3+1(1),VPLACE     INSERT REGISTER AND
         MVC   TRREIN3+2(2),WPLACE     DISPLACEMENT IN LOAD INSTRUCTION
         BAL   R2,GENTXTP4             GENERATE A LOAD FPR0
TRREIN3  LD    FPR0,0(0,0)             *INSTRUCTION, FLOATING POINT *
TRREIN6  TM    RII,RADRFREM            REG ADDR FREE
         BZ    TRREIN9                 YES
         BAL   R4,ROUTIN10             STORE ADDR AND RETURN
         NI    RII,255-RADRFREM
TRREIN9  BAL   R2,GENTXT4              GENERATE A CALL TO THE REAL-
*        BAL   ADR,CNVRDI(FSA,0)       *INTEGER CONVERSION ROUTINE
         BAL   8,X'14C'(13)            ***NEW GENERATED CODE***
         L     R4,SAVTRREI
         BR    R4
*
TRREIN4  MVN   TRREIN5+1(1),VPLACE
         BAL   R2,GENTXTP2             GENERATE A LOAD  FPR0
TRREIN5  LDR   FPR0,0                  *INSTRUCTION FLOATING POINT *
TRREIN8  BAL   R4,ROUTIN12             RELEASE REG CONTAINING OPD
         B     TRREIN6
*
SAVTRREI DC    F'0'                    SAVE AREA FOR RETURN
*
***********************************************************************
*
*        S U B R O U T I N E   G E N E R A T E
*
***********************************************************************
*
*        GENERATE RLD RECORDS
*
* CALL   L     R2,                     VALUE OF PROGRAM POINTER
*        BAL   R14,GENRLD
*        DC    H' '                    LENGTH OF ADDR TABLE
*        DC    H'  '                   ESID OF RELOCATION FACTOR R
*        DC    H'  '                   ESID OF POSITION IDENTIFIER P
*        ---                           RETURN AFTER CALL GENERATE
*
*        GENERATE TXT RECORDS SIX DIFFERENT CALLS
*
*        BAL   R2,GENTXT2
*        RR FORMAT INSTRUCTION OR DATA 2 BYTES LONG
*        ---                           RETURN AFTER CALL GENERATE
*
*        BAL   R2,GENTXTP2
*        RR FORMAT FLOATING POINT LONG FORM INSTRUCTION
*        ---                           RETURN AFTER CALL GENERATE
*
*        BAL   R2,GENTXT4
*        INSTRUCTION(S) OR DATA 4 BYTES LONG
*        ---                           RETURN AFTER CALL GENERATE
*
*        BAL   R2,GENTXTP4
*        RX  FORMAT FLOATING POINT LONG FORM INSTRUCTION
*        ---                           RETURN AFTER CALL GENERATE
*
*        BAL   R2,GENTXT6
*        INSTRUCTIONS OR DATA 6 BYTES LONG
*        ---                           RETURN AFTER CALL GENERATE
*
*        LA    R2,                     ADDR OF CODE TO BE GENERATED
*        BAL   R14,GENTXT8
*        DC    H'  '                   LENGTH OF CODE IN BYTES
*        ---                           RETURN AFTER CALL GENERATE
*
*        REGISTER DEFINITIONS
*
*        R1                            OUTPUT RECORD POINTER
*        R2                            ADDR OF DATA
*        R3                            TYPE OF RECORD TO BE GENERATED
*        R4                            RETURN REGISTER
*        R14                           LENGTH OF DATA FROM CALL
*        R15                           LENGTH WITHIN RECORD
*
*        BIT PATTERNS
*
SDENTRY  EQU   X'00'                   SD ENTRY IDENTIFICATION
LDENTRY  EQU   X'01'                   LD ENTRY IDENTIFICATION
RLDFLAG  EQU   B'00001100'             FLAG USED IN RLD ENTRY
*
*        GENERATE RLD RECORDS
*
GENRLD   LA    R4,6(,R14)              COMPUTE RETURN ADDR
         LA    R3,RLDT                 INDICATE RLD CALL
         LH    R14,0(,R14)             LOAD LENGTH GIVEN IN CALL
         SLL   R14,1                   DOUBLE LENGTH
         B     GEN1                    CONTINUE COMMON PART
*
*        GENERATE TXT RECORDS
*
GENTXTS  LA    R4,2(,R14)              COMPUTE RETURN ADDR
         LH    R14,0(,R14)             LOAD LENGTH GIVEN IN CALL
         B     GEN2                    CONTINUE TXT ENTRY
*
*        GENERATE RX OR RS INSTRUCTION, CHANGE PRECISION
*
GENTXTP4 XI    GENTXT6+7,X'06'         MODIFY LENGTH INSTRUCTION
*
*        GENERATE RR INSTRUCTION, CHANGE PRECISION
*
GENTXTP2 OC    0(1,R2),PRECMASK        MODIFY INSTRUCTION, L OR S
*
*        GENERATE TXT RECORD,2
*
GENTXT2  XI    GENTXT6+7,X'06'         MODIFY LENGTH INSTRUCTION
*
*        GENERATE TXT RECORD,4
*
GENTXT4  XI    GENTXT6+7,X'02'         MODIFY LENGTH INSTRUCTION
*
*        GENERATE TXT RECORD,6
*
GENTXT6  ST    R14,PLACE14             SAVE LENGTH REGISTER
         LA    R14,6                   LENGTH = 2, 4 OR 6
         MVI   GENTXT6+7,X'06'         RESTORE MODIFIED INSTRUCTION
         LA    R4,0(R2,R14)            COMPUTE RETURN ADDR
GEN2     LA    R3,TXTT                 INDICATE TXT CALL
GEN1     L     R1,SAVOUTA              FETCH OLD OUTPUT RECORD ADDR
         TM    COMPFLGS+1,NLOAD+NDECK  LOAD OR DECK SPECIFIED ?
         BO    GEN4A                   NO, OUT OF GENERATE
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    GEN4A
         CLC   1(3,R1),1(R3)           RECORD RIGHT TYPE ?
         BNE   GEN3                    NO, CALL FOR NEW
         CLC   10(2,R1),12(R3)         RECORD FILLED ?
         BNL   GEN3                    YES, CALL FOR NEW
GEN6     LA    R15,56
         LH    R0,10(,R1)              R0 = LENGTH OF DATA IN REC
         SR    R15,R0                  R15 = EMPTY POS LEFT IN RECORD
         CR    R15,R14                 ENOUGH SPACE LEFT ?
         BL    *+6                     NO
         LR    R15,R14                 YES, R15 = R14 FROM CALL
         AR    R15,R0
         STH   R15,10(,R1)             INSERT NEW LENGTH INTO RECORD
         SR    R15,R0
         AR    R1,R0                   START ADDR WITHIN RECORD
         SR    R14,R15                 REMAINING LENGTH
         B     14(,R3)                 TO DIFFERENT MOVE ROUTINES
*
GEN4     LTR   R14,R14                 MORE INFORMATION MUST BE MOVED ?
         BH    GEN3                    YES
GEN4A    L     R14,PLACE14             NO, RESTORE R14
         BR    R4                      RETURN
*
*        NEW OUTPUT RECORD
*
GEN3     ST    R14,SAVELT              SAVE LENGTH
         TM    COMPFLGS+1,NLOAD+NDECK  BOTH LOAD AND DECK SPECIFIED ?
         BZ    BOTH                    YES
         TM    COMPFLGS+1,NDECK        DECK ONLY ?
         L     R1,APCHDCB              R1 -> SYSPUNCH DCB
         BZ    PUT1                    YES
PUT$1    L     R1,ALINDCB              R1 -> SYSLIN DCB
*
PUT1     PUT   (R1)                    PUT FOR SYSLIN AND SYSPUNCH
*
         ST    R1,SAVOUTA              SYSPUNCH OR SYSLIN ADDR
         L     R14,SAVELT              RESTORE LENGTH
         B     PUNCHOUT                OUT OF ROUTINE PUNCH
*
BOTH     L     R14,OUTAREA2            COPY SYSLIN DATA TO SYSPUNCH
         L     R1,SAVOUTA
         MVC   0(80,R14),0(R1)         BUFFER
PUT2     L     R1,APCHDCB              R1 -> SYSPUNCH DCB
*
         PUT   (R1)                    PUT FOR SYSPUNCH WHEN BOTH HAS
*
         ST    R1,OUTAREA2             BEEN SPECIFIED
         B     PUT$1                   GOTO PUT SYSLIN
*
PUNCHOUT MVC   0(4,R1),0(R3)           INSERT FIRST 4 BYTES
         MVI   4(R1),C' '              INSERT ONE BLANK
         MVC   5(67,R1),4(R1)          BLANK OUTPUT RECORD
         MVC   72(4,R1),PIDENT         INSERT PROGRAM IDENT
         AP    CARDCNT,KP1             STEP SEQUENCE NUMBER
         UNPK  76(4,R1),CARDCNT        UNPACK INTO RECORD
         OI    79(R1),X'F0'            MAKE PRINTABLE
         MVC   10(2,R1),4(R3)          INSERT INITIAL LENGTH
         MVC   14(6,R1),6(R3)          INSERT ESID+R AND P
         CLC   TXTT+1(3),1(R3)         TXT RECORD PROCESSED ?
         BNE   GEN6                    NO
         ST    R6,4(R1)                YES INSERT R6
         MVI   4(R1),C' '
         B     GEN6
*
*        TXT RECORD
*
         DC    0H'0'
TXTT     DC    X'02'                   RECORD CODE
         DC    C'TXT'                  IDENTIFICATION
         DC    H'0'                    INITIAL LENGTH 0
         DC    H'1'                    ESID
         DC    C'    '
         DC    H'56'                   MAXIMUM LENGTH
*
*        MOVE TXT INFORMATION TO OUTAREA
*
GEN8     BCTR  R15,0                   DECR LENGTH
         STC   R15,*+5                 INSERT PROPER LENGTH TO MOVE
         MVC   16(0,R1),0(R2)          MOVE DATA TO OUTAREA
         LA    R6,1(R15,R6)            INCREASE PROGRAM POINTER
         LA    R2,1(R15,R2)            MODIFY DATA ADDR
         B     GEN4                    OUT OF MOVE TXT ROUTINE
*
*        RLD RECORD
*
         DC    0H'0'
RLDT     DC    X'02'                   RECORD CODE
         DC    C'RLD'                  IDENTIFICATION
         DC    H'0'                    INITIAL LENGTH 0
         DC    C'  '
RANDP    DC    H'1',H'1'               R AND P ESID ARE 1 AT START
         DC    H'56'                   MAXIMUM LENGTH IN RECORD
*
*        MOVE RLD INFORMATION TO OUTAREA
*
GEN9     AR    R15,R1                  INDICATE LAST ENTRY
GEN5     MVC   16(4,R1),RANDP
         ST    R2,20(,R1)              MOVE PROGRAM POINTER VALUE AND
         MVI   20(R1),RLDFLAG          FLAG TO OUTAREA
         LA    R1,8(,R1)               NEXT ENTRY
         LA    R2,4(,R2)               NEXT PROGRAM POINTER VALUE
         CR    R1,R15                  LAST COLUMN FILLED
         BL    GEN5                    NO, CONTINUE
         B     GEN4                    OUT OF MOVE RLD ROUTINE
*
*        VARIABLES AND CONSTANTS
*
SAVELT   DC    F'0'                    SAVE AREA FOR LENGTH
KP1      DC    PL2'1'                  FOR INCREMENTING CARD COUNT
*
***********************************************************************
*
*        SUBROUTINE CLEAR REGISTERS
*
***********************************************************************
*
* CALL   BAL   R4,CLEARRG
*
*        GENERATES STORE INSTRUCTIONS FOR ALL REGISTERS THAT
*        CONTAIN VALID INFORMATION - SET CII, CIR, RII, RIR
*
CLEARRG  MVI   GPBN+1,X'FF'            DESTROY GDSA
         ST    R4,RETADR               STORE RETURN ADDR
         SR    R14,R14
         BCTR  R14,0
         BCTR  R14,0
         LH    R2,RIR
KIF22    LA    R14,2(,R14)
         LTR   R2,R2
         BZ    KIF21                   YES, BRANCH
         SRDL  R2,1
         LTR   R3,R3
         BNM   KIF22                   NO, BRANCH
         ST    R2,RETADR+64
         BAL   R4,ROUTIN13
         L     R2,RETADR+64
         B     KIF22
*
KIF21    MVI   CIR,0
         MVI   CIR+1,X'06'
         MVC   RIR(2),ZEROHW           CLEAR RIR
         SR    R14,R14
         BCTR  R14,0
         LH    R2,RII
KIF25    LA    R14,1(,R14)
         LTR   R2,R2
         BZ    KIF24                   BRANCH IF YES
         SRDL  R2,1
         LTR   R3,R3
         BNM   KIF25                   BRANCH IF NO
         ST    R2,RETADR+64
         BAL   R4,ROUTINE9
         L     R2,RETADR+64
         B     KIF25
*
KIF24    MVI   CII,0
         MVI   CII+1,X'07'
         MVC   RII(2),ZEROHW           CLEAR RII
         L     R4,RETADR               LOAD RETURN ADDR
         BR    R4
*
***********************************************************************
*
*        O P E R A N D   R E C O G N I Z E R
*
***********************************************************************
*
* CALL   BAL   R4,OPDREC
*
*        CHECK IF OPERAND IN STACK IS A FORMAL PARAMETER OR A
*        PROCEDURE WITHOUT PARAMETERS
*        OPDREC GENERATES AN ACTUAL PARAMETER OR A PROCEDURE CALL
*
*        IF OPERAND IS A FORMAL PARAMETER CALLED BY VALUE LABEL
*        OR ARRAY OPDREC GENERATES LOAD OF REGISTERS GDSA AND/OR ADR
*
*        ADDR DISPLACEMENTS
*
TYPS     EQU   1                       SECOND BYTE TYPE IN IDENTIFIER
NUMP     EQU   3                       NO OF PARAMETERS IN IDENTIFIER
PBNP     EQU   2                       DISP OF PBN IN IDENTIFIER
TYPF     EQU   0                       FIRST BYTE TYPE IN IDENTIFIER
RUTIADR  EQU   4*8                     ENTRY IN RUTI TABLE FOR ADR
*
*        BIT PATTERNS
*
VARIAM   EQU   X'30'                   MASK FOR VARIABLE
INTRVM   EQU   X'7F'                   INTERMIDIATE VALUE IN STACK
INTRRM   EQU   X'60'                   INTERMIDIATE VALUE ADDR IN REG
DESTROY  EQU   X'FF'                   INDICATE THAT GDSA IS NOT VALID
ARRAYM   EQU   X'04'                   ARRAY IDENTIFIER MASK
LABARRM  EQU   X'0C'                   LABEL OR ARRAY IDENTIFIER MASK
RIIADRM  EQU   X'01'                   RII MASK FOR RESERVATION OF ADR
FORMPM   EQU   X'30'                   FORMAL PARAMETER MASK
PROCM    EQU   X'C0'                   PROCEDURE MASK
STPROCM  EQU   X'40'                   STANDARD PROCEDURE MASK
PARAM    EQU   X'F0'                   NUMBER OF PARAMETER MASK
FUNCPM   EQU   X'03'                   FUNCTION PROCEDURE MASK
VALUEM   EQU   X'20'                   VALUE PARAMETER SPEC
REGADRM  EQU   ADR*16                  REGISTER ADR MASK
*
OPDREC   TM    0(R9),X'C0'             IDENTIFIER FROM ITAB ?
         BNOR  R4                      NO, RETURN
         TM    TYPS(R9),FORMPM         OPERAND FORMAL PARAMETER ?
         ST    R4,SAVRT                SAVE RETURN ADDR
         BM    OPDREC1                 YES, FORMAL
         TM    TYPS(R9),PROCM          PROCEDURE IDENTIFIER ?
         BZR   R4                      NO, RETURN
         TM    TYPS(R9),STPROCM        STANDARD PROCEDURE ?
         BZR   R4                      YES, RETURN
         TM    NUMP(R9),PARAM          PARAMETERLESS PROCEDURE ?
         BNZR  R4                      NO, RETURN
*
*        PARAMETERLESS PROCEDURE FOUND
*
         BAL   R4,CLEARRG              CLEAR ALL OBJ TIME REGISTERS
         MVC   PPCODE+2(2),NUMP(R9)    INSERT DISPLACEMENT OF LABEL
         MVC   PPCODE+5(1),PBNP(R9)    INSERT PROGRAM BLOCK NUMBER
         LA    R2,PPCODE               GENERATE A PARAMETERLESS
         BAL   R14,GENTXTS             PROCEDURE
         DC    H'12'                   CALL
         TM    TYPS(R9),FUNCPM         FUNCTION PROCEDURE
         L     R4,SAVRT
         BZR   R4                      NO, RETURN
*                                      PARAMETERLESS FUNCTION
*                                      PROC FOUND
         B     OPDREC4
*
*        FORMAL PARAMETER FOUND
*
OPDREC1  TM    TYPS(R9),VALUEM         CALLED BY NAME ?
         BO    OPDREC3                 NO
*                                      FORMAL PARAMETER CALLED BY NAME
         BAL   R4,CLEARRG              CLEAR ALL OBJ TIME REGISTERS
         SR    R3,R3
         IC    R3,PBNP(,R9)            PROCEDURE PBN FROM IDENTIFIER
         SLL   R3,3                    DISPLACEMENT IN PBT
         STH   R3,CAP+4                INSERTED IN CAP CODE
         LH    R3,SPBNST               CURRENT PBN
         SLL   R3,3                    DISPLACEMENT IN PBT
         STH   R3,CAP+6                INSERTED IN CAP CODE
         MVC   CAP+10(2),NUMP(R9)      INSERT FORMAL PARAM DISPL
         LA    R2,CAP                  GENERATE CALL ACTUAL PARAMETER
         BAL   R14,GENTXTS             CODE
         DC    H'12'
*
         TM    TYPS(R9),PROCM          PROCEDURE
         BZ    OPDREC4                 NO
         TM    PROCWPS,X'80'
         BO    OPDREC4                 NOT PARAMETERLESS, SET IN CP57
         LA    R2,OPDREC6              GENERATE
         BAL   R14,GENTXTS             CHECK FOR PARAMETERLESS
         DC    H'10'                   PROCEDURE
*
OPDREC4  AH    R7,ONEENTRY             RESERVE ONE ENTRY IN OBJ STACK
         STH   R7,SPBNST+2             INSERT NEW DISPL AND
         MVC   PBNP(3,R9),SPBNST+1     PBN IN INTERNAL NAME
         XI    TYPF(R9),INTRRM         ADDR OF OPERAND IN REGISTER
         OI    NUMP(R9),REGADRM        INDICATE REGISTER ADR
         ST    R9,RUTI+RUTIADR         GPR CONTROL ENTRY RUTI
         OI    RII,RIIADRM             GPR CONTROL ENTRY RII
         L     R4,SAVRT
         TM    TYPS(R9),ARRAYM
         BOR   R4
         TM    TYPS(R9),X'03'
         BZR   R4
         MVI   PBNP(R9),X'00'          INDICATE SPECIAL ADDR ADR
*                                      MAY POINT TO FCTVALST IN FSA
*                                      ROUTINE 9 CHECK THIS
         BR    R4                      RETURN
*
*        FORMAL PARAMETER CALLED BY VALUE
*
OPDREC3  TM    TYPS(R9),LABARRM        LABEL OR ARRAY IDENTIFIER
         BNMR  R4                      NO, RETURN
         BAL   R4,ROUTINE3             GENERATE LOAD ADR
         AH    R7,ONEENTRY             OBJECT TIME STACK NOT RELEASED
         TM    TYPS(R9),ARRAYM         ARRAY IDENTIFIER
         BO    OPDREC4                 YES, INTERNAL NAME AND REG CONTR
         LA    R3,4
         AH    R3,GRD3+2               ADD 4 TO DISP, GRD3 IN ROUTINE3
         STH   R3,OPDREC5+2            INSERT DISP+4 (CDSA OR GDSA)
         MVN   OPDREC5+1(1),GRD3+1     IN LOAD GDSA INSTRUCTION
         BAL   R2,GENTXT4              GENERATE A LOAD GDSA
OPDREC5  L     GDSA,4(0,0)             INSTRUCTION
         MVI   GPBN+1,DESTROY          NOTE THAT GDSA IS DESTROYED
         B     OPDREC4                 INTERNAL NAME AND REG CONTROL
*
*        CONSTANTS AND VARIABLES
*
PPCODE   L     ADR,0(LAT,0)            PARAMETERLESS PROCEDURE CALL
         MVI   PROLPBN(FSA),0          CODE, DISP INSERTED
         BAL   BRR,PROLOG(,FSA)        CODE IS 12 BYTES
*
*        CALL ACTUAL PARAMETER, GENERATED CODE
*        DISPL, PBNP AND PBNC INSERTED
*
CAP      BAL   BRR,CAP1(,FSA)          TO CAP SUBROUTINE FIRST PART
         DC    H'0'                    PBNP, PBN DISP OF PROCEDURE
         DC    H'0'                    PBNC, PBN DISP OF CURRENT BLOCK
         L     ADR,0(CDSA,0)           THUNK ADDR FROM PROCEDURE DSA
OPDREC6  LA    R14,FCTVALST(FSA)       CHECK THAT ACTUAL
         CR    R14,ADR                 PARAMETER PROCEDURE
         BNE   OERR21(FSA)             IS PARAMETERLESS
*
SAVRT    DC    F'0'                    SAVE AREA FOR RETURN
PROCWPS  DC    X'00'                   SWITCH TO AVOID PARAMETERLESS
*                                      PROCEDURE CHECK
*
***********************************************************************
*
*        S U B R O U T I N E   M A X C H E C K
*
***********************************************************************
*
*        SUBROUTINE TO CHECK THAT OBJECT TIME STACK POINTER
*        VALUE IS LESS THAN MAX VALUE PLACED IN WORKPL BY CALLING
*        ROUTINE
*
* CALL   BAL   R4,MAXCH
*
MAXCH    STM   R15,R4,MCHSAV           SAVE REGISTERS
         LH    R4,WORKPL               FETCH CHECKVALUE FROM WORKAREA
         LH    R3,SPBNST               CURRENT PBN FROM WORKAREA
         SLL   R3,2                    PBT DISPLACEMENT
         CH    R4,PBTAB3(R3)           R4 < MAX IN PBTAB3 ?
         BNH   MAXCH1                  YES, RETURN
         STH   R4,PBTAB3(R3)           INSERT R4 AS NEW MAX
         CH    R4,MAXOVERF             OVERFLOW OF OBJECT TIME STACK ?
         BNH   MAXCH1                  NO, RETURN
         CR    R7,R4                   R7 ALREADY BEEN RESET ?
         BL    MAXCH1                  YES, NO ERROR MSG
         SR    R7,R7                   NO, RESET R7 TO ZERO
         BAL   R4,SERRSP               ERROR PATTERN GENERATION
         DC    H'214'                  ERROR 214
*
MAXCH1   LM    R15,R4,MCHSAV           RESTORE REGISTERS
         BR    R4                      RETURN
*
*        VARIABLES AND CONSTANTS
*
MCHSAV   DC   6F'0'                    SAVE AREA FOR REGISTERS
*
***********************************************************************
*
*        SEMICOLON COUNTER HANDLING
*
***********************************************************************
*
* CALL   BAL R4,SCHDL
*
*        SET SEMICOLON COUNTER AND MOVE SOURCE POINTER IN SOURCE
*        STRING
*
*        GENERATES SEMICOLON TRACE IF OPTION SPECIFIED
*
SCHDL    ST    R4,SCHDLR               SAVE RETURN ADDR
         MVC   SEMCNT,1(R8)            STORE SEMICOLON NUMBER
         LA    R8,2(R8)                STEP SOURCE POINTER
*
*        GENERATE BRANCH TO TRACE ROUTINE
*
         MVC   SCHDL1(2),SEMCNT        SEMICOLON NUM TO GENERATED CODE
         TM    COMPFLGS+2,NOTEST
         BO    SCHDL1+2                NO SEMICOLON TRACE GEN
         BAL   R2,GENTXT6
         BAL   BRR,TRACE(FSA)          **GENERATED CODE**
SCHDL1   DC    H'0'                    **GENERATED CODE**
*
         L     R4,SCHDLR
         BR    R4
*
SCHDLR   DC    F'0'                    SAVE RETURN ADDR
*
***********************************************************************
*
*        ROUTINE NUMBER 1
*
***********************************************************************
*
* CALL   BAL   R4,ROUTINE1
*
*        LOAD IN W-PLACE THE DISPLACEMENT OF AN OPERAND THAT IS
*        NOT AN ADDR
*        LOAD IN V-PLACE AA OR 99 DEPENDING ON WHERE THE
*        VARIABLE, CONSTANT OR INTERMEDIATE RESULT IS AND
*        GENERATES A LOADING OF GDSA IF NECESSARY
*
ROUTINE1 MVC   WPLACE(2),3(R9)         MOVE DISPLACEMENT OF LO TO W
GPE2     MVI   VPLACE,X'AA'            MOVE CDSA REG TO V
         CLC   2(1,R9),SPBNST+1        PBN OF LO CDSA ?
         BER   R4                      YES, RETURN IF CURRENT DSA
GPE3     MVI   VPLACE,X'99'            MOVE GLOBAL DSA REG TO V
         CLI   GPBN+1,X'FF'            C(GDSA) DESTROYED ?
         BE    GPC3                    YES, BRANCH IF DESTROYED
         CLC   GPBN(1),2(R9)           GDSA = PBN OF LO
         BER   R4                      EQUAL, RETURN
GPC31    SR    R1,R1                   CLEAR R1
         ST    R4,RETADR+4             STORE RETURN ADDR
         MVC   GPBN(1),2(R9)           KEEP NEW LOADED GDSA
         IC    R1,2(,R9)               LOAD IN R1 PBN OF LO
         SLA   R1,3                    MULTIPLY BY 8
         STH   R1,WORKPL               PREPARE INSTRUCTION
         MVC   GPC4+2(2),WORKPL
         BAL   R2,GENTXT4              GENERATE
GPC4     L     GDSA,0(PBT,0)
         L     R4,RETADR+4             LOAD RETURN ADDR
         BR    R4                      RETURN
*
GPC3     MVI   GPBN+1,0                RECONSTRUCT GDSA
         B     GPC31
*
***********************************************************************
*
*        ROUTINE NUMBER 2
*
***********************************************************************
*
* CALL   BAL   R4,ROUTINE2
*
*        GENERATES A LOAD INSTRUCTION INTO THE FLOATING POINT
*        REGISTER SPECIFIED BY R14 OF AN OPERAND THAT IS AN ADDR
*        ADJUSTS THE OPERAND
*        STORES OPERAND STACK ADDR INTO RUTR
*
ROUTINE2 ST    R4,RETADR+8             STORE RETURN ADDR
         LA    R9,5(,R9)               INCREASE R9
         BAL   R4,ROUTINE3             BRANCH TO ROUTINE NUMBER 3
GQE3     SLL   R14,1                   INTRODUCE R9 ADDR IN RUTR
         ST    R9,RUTR(R14)
         SLL   R14,3                   PREPARE INSTRUCTION
         STC   R14,GQD3+1
         MVN   GQD3+1(1),VPLACE
         MVC   GQD3+2(2),WPLACE
         BAL   R2,GENTXTP4
GQD3     LD    0,0(0,0)                ***GENERATE***
GQF3     SRL   R14,4
         SH    R9,KH5                  REDUCE R9
         STH   R7,WORKPL               INTROD R7 INTO R9 ENTRY
         MVC   8(2,R9),WORKPL
         MVZ   8(1,R9),GQD3+1          INTROD REG NUMBER
         MVC   7(1,R9),SPBNST+1        INTROD PBN
         OI    5(R9),X'80'             ADJUST R9 ENTRY
         NI    5(R9),X'9F'
         L     R4,RETADR+8             LOAD RETURN ADDR
         BR    R4
*
***********************************************************************
*
*        ROUTINE NUMBER 3
*
***********************************************************************
*
* CALL   BAL   R4,ROUTINE3
*
*        LOAD IN W-PLACE ZERO
*        LOAD IN V-PLACE 88
*        GENERATE A LOADING OF ADR IF NECCESSARY, IN THIS CASE
*        THE OPERAND IS AN ADDR
*
ROUTINE3 ST    R4,RETADR+12            STORE RETURN ADDR
         TM    0(R9),X'40'             ADDR OF LO IN ADR ?
         BO    GRC3                    NO, NOT
         MVI   RII,0                   CLEAR RIT OF ADR
GRE3     SH    R7,ONEENTRY             REDUCE R7 BY 8
GRG2     MVI   VPLACE,X'88'            V EQUAL ADR
         MVC   WPLACE(2),ZEROHW        W EQUAL ZERO
         L     R4,RETADR+12            LOAD RETURN ADDR
         BR    R4                      RET
*
GRC3     TM    RII,X'01'               ADR FREE ?
         BZ    GRD31                   YES, BRANCH
GRC4     ST    R14,RETADR3
         BAL   R4,ROUTIN10
         L     R14,RETADR3
GRD31    BAL   R4,ROUTINE1             CALL ROUTINE1
         MVC   GRD3+2(2),WPLACE        MOVE DISPLACEMENT
         MVN   GRD3+1(1),VPLACE        MOVE BASE REG
         BAL   R2,GENTXT4              GENERATE
GRD3     L     ADR,0(0,0)              ***GENERATE***
         ST    R9,RUTI+32
         B     GRE3
*
RETADR3  DC    F'0'
*
***********************************************************************
*
*        ROUTINE NUMBER 4
*
***********************************************************************
*
* CALL   BAL   R4,ROUTINE4
*
*        GENERATES A LOAD INSTRUCTION INTO THE FLOATING POINT
*        REGISTER SPECIFIED BY R14 OF AN OPERAND THAT IS NOT AN ADDR
*        ADJUSTS THE OPERAND AND STORES THE OPERAND STACK ADDR
*        INTO RUTR
*
ROUTINE4 ST    R4,RETADR+8             STORE RETURN ADDR
         LA    R9,5(,R9)               INCREASE R9
         BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1
         OI    1(R9),X'30'             SET TO VARIABLE
         B     GQE3                    BRANCH TO ENTRY PT IN RTN NO 2
*
***********************************************************************
*
*        ROUTINE NUMBER 5
*
***********************************************************************
*
* CALL   BAL   R4,ROUTINE5
*
*        GENERATES A LOAD INSTRUCTION INTO A GENERAL PURPOSE
*        REGISTER SPECIFIED BY R14 OF AN OPERAND THAT IS NOT AN ADDR
*        ADJUSTS THE OPERAND AND STORES THE OPERAND STACK ADDR
*        INTO RUTI
*
ROUTINE5 ST    R4,RETADR+8             STORE RETURN ADDR
         LA    R9,5(,R9)               INCREASE R9
         BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1
         OI    1(R9),X'30'             SET TO VARIABLE
GTE3     SLL   R14,2                   INTRODUCE R9 ADDR IN RUTI
         ST    R9,RUTI(R14)
         SLL   R14,2                   PREPARE INSTRUCTION
         STC   R14,GTD3+1
         STC   R14,GQD3+1
         MVN   GTD3+1(1),VPLACE
         MVC   GTD3+2(2),WPLACE
         BAL   R2,GENTXT4
GTD3     L     0,0(0,0)                ***GENERATE***
         B     GQF3                    BRANCH TO ENTRY PT IN RTN NO 2
*
***********************************************************************
*
*        ROUTINE NUMBER 6
*
***********************************************************************
*
* CALL   BAL   R4,ROUTINE6
*
*        GENERATES A LOAD INSTRUCTION INTO A GENRAL PURPOSE
*        REGISTER SPECIFIED BY R14 OF AN OPERAND THAT IS AN ADDR
*        ADJUSTS THE OPERAND AND STORES THE OPERAND STACK ADDR
*        INTO RUTI
*
ROUTINE6 ST    R4,RETADR+8             STORE RETURN ADDR
         LA    R9,5(,R9)               INCREASE R9
         BAL   R4,ROUTINE3             CALL ROUTINE NUMBER 3
         B     GTE3                    BRANCH TO ENTRY PT IN RTN NO 5
*
***********************************************************************
*
*        ROUTINE NUMBER 7
*
***********************************************************************
*
* CALL   BAL   R4,ROUTINE7
*
*        LOADS INTO R14 THE NUMBER OF THE NEXT GENERAL PURPOSE
*        REGISTER TO BE USED ACCORDING TO CII
*        IF IT IS OCCUPIED IT BRANCHES TO ROUTINE NUMBER 9 THAT
*        GENERATES A STORE INSTRUCTION
*        CII AND RII ARE SET
*        RESERVES ONE OBJECT TIME STACK ENTRY
*
ROUTINE7 SR    R14,R14
         CLI   CII+1,X'07'             CII IS 7 ?
         BE    GVC2                    YES, BRANCH
         IC    R14,CII+1(0)            INCREASE CII BY ONE
         LA    R14,1(,R14)
GVC2     STC   R14,CII+1
         LA    R15,1                   LOAD ONE INTO R15
         SLL   R15,0(R14)              GENERATE MASK
         STC   R15,GVC21+1
GVC21    TM    RII+1,0                 GPR OCCUPIED ?
         BZ    GVE2                    NO, BRANCH
         ST    R4,RETADR+28            STORE RETURN ADDR
         BAL   R4,ROUTINE9             CALL ROUTINE9
         L     R4,RETADR+28            LOAD RETURN ADDR
GVE2     OC    RII+1(1),GVC21+1        SET TO ONE RII
GVF2     AH    R7,ONEENTRY             INCREASE R7 BY 4 OR 8
         BR    R4
*
***********************************************************************
*
*        ROUTINE NUMBER 8
*
***********************************************************************
*
* CALL   BAL   R4,ROUTINE8
*
*        THE LAST GENERAL PURPOSE REGISTER RESERVED IS RELEASED
*        CII AND RII ARE SET
*        ONE OBJECT STACK ENTRY IS RELEASED
*
ROUTINE8 SR    R14,R14                 CLEAR R14
         IC    R14,CII+1               LOAD CII INTO R14
         LA    R15,1                   CLEAR RII OF LO
         SLL   R15,0(R14)
         STC   R15,GWD51+1
         XI    GWD51+1,X'FF'
GWD51    NI    RII+1,0
         SH    R7,ONEENTRY             REDUCE R7
GWD5     CLI   CII+1,0                 CII = ZERO
         BE    GWD3                    YES, BRANCH
         BCTR  R14,0                   REDUCE BY ONE
         STC   R14,CII+1               STORE NEW CII
         SRL   R15,1                   GPR INDICATED BY
GWD6     STC   R15,GWD4+1              CII FREE
GWD4     TM    RII+1,0
         BZ    GWD5                    FREE, BRANCH
         BR    R4                      RETURN
*
GWD3     MVI   CII+1,X'07'             MAKE CII = 7
         LA    R14,7
         CLI   RII+1,0                 ALL GPR FREE ?
         BER   R4                      YES, RETURN
         LA    R15,128                 LOAD MASK
         B     GWD6
*
***********************************************************************
*
*        ROUTINE NUMBER 10
*
***********************************************************************
*
* CALL   BAL   R4,ROUTIN10
*
*        CLEARS RII OF ADR
*        LOADS 8 INTO R14
*        FALLS THROUGH TO ROUTINE NUMBER 9
*
ROUTIN10 MVI   RII,X'00'
         LH    R14,KH8
*
***********************************************************************
*
*        ROUTINE NUMBER 9
*
***********************************************************************
*
* CALL   BAL   R4,ROUTINE9
*
*        GENERATE CODE TO STORE GENERAL PURPOSE REGISTER
*        SPECIFIED BY R14 IF THE PBN IS NOT ZERO
*        IF THE PBN IS ZERO IT GENERATES A MOVE INSTRUCTION
*        THE OPERAND IS ADJUSTED
*
ROUTINE9 ST    R4,RETADR+36            STORE RETURN ADDR
         SLL   R14,2                   MULTIPLY BY 4
         LA    R15,RUTI                LOAD ADDR OF RUTI
         L     R15,0(R14,R15)          LOAD ADDR OF OPD TO STORE
         SLL   R14,2                   PREPARE INSTRUCTION
         NI    3(R15),X'0F'
         ST    R15,RETADR+48
         TM    2(R15),X'FF'
         BZ    GXC4
         LA    R14,10(,R14)
         STC   R14,GXC3+1
         MVC   GXC3+2(2),3(R15)        PREPARE INSTRUCTION
         BAL   R2,GENTXT4
GXC3     ST    0,0(CDSA,0)             ***GENERATE***
         B     HBC2
*
GXC4     MVC   GXC5+2(2),3(R15)
         OI    GXC5+2,X'A0'
         MVI   GXC5+1,X'07'
         TM    COMPFLGS,LNG
         BO    GXC6
         MVI   GXC5+1,X'03'
GXC6     NI    0(R15),X'DF'
         MVC   2(1,R15),SPBNST+1
         BAL   R2,GENTXT6
GXC5     MVC   0(4,CDSA),0(ADR)        *** GENERATE ***
         B     HBC2
*
***********************************************************************
*
*        ROUTINE NUMBER 11
*
***********************************************************************
*
* CALL   BAL   R4,ROUTIN11
*
*        LOADS INTO R14 THE NUMBER OF THE NEXT FLOATING POINT
*        REGISTER TO BE USED ACCORDING TO CIR
*        IF IT IS OCCUPIED IT CALLS ROUTINE NUMBER 13 THAT
*        GENERATES A STORE INSTRUCTION
*        CIR AND RIR ARE SET
*        ONE OBJECT TIME ENTRY IS RESERVED
*
ROUTIN11 SR    R14,R14                 CLEAR R14
         CLI   CIR+1,X'06'             CIR = 6 ?
         BE    GZC2                    YES, BRANCH
         IC    R14,CIR+1               LOAD CIR INTO R14
         LA    R14,2(,R14)             INCR CIR BY 2
GZC2     STH   R14,CIR                 STORE NEW CIR
         SRL   R14,1                   DIVIDE R14 BY 2
         LA    R15,1                   LOAD ONE INTO R15
         SLL   R15,0(R14)              GENERATE MASK
         SLL   R14,1
         STC   R15,GZC21+1
GZC21    TM    RIR+1,0                 FPR OCCUPIED ?
         BZ    GZE2                    FREE, BRANCH
         ST    R4,RETADR+44            STORE RETURN ADDR
         BAL   R4,ROUTIN13             CALL ROUTIN13
         L     R4,RETADR+44            LOAD RETURN ADDR
GZE2     OC    RIR+1(1),GZC21+1
GZF2     AH    R7,ONEENTRY             INCREASE R7 BY 4 OR 8
         BR    R4
*
***********************************************************************
*
*        ROUTINE NUMBER 12
*
***********************************************************************
*
* CALL   BAL   R4,ROUTIN12
*
*        THE LAST FLOATING POINT REGISTER RESERVED IS RELEASED
*        CIR AND RIR ARE SET
*        ONE OBJECT STACK ENTRY IS RELEASED
*
ROUTIN12 LH    R14,CIR                 LOAD INTO R14 CIR
         LA    R15,1                   CLEAR RIR OF BLO
         SRL   R14,1
         SLL   R15,0(R14)
         STC   R15,HAD4+1
         XI    HAD4+1,X'FF'
HAD4     NI    RIR+1,0
         SH    R7,ONEENTRY             REDUCE R7
         SLL   R14,1
HAD1     CLI   CIR+1,0                 ZERO ?
         BE    HAD3                    YES, BRANCH
         SH    R14,KH2
         STC   R14,CIR+1
         SRL   R15,1
HAD0     STC   R15,HAD2+1
HAD2     TM    RIR+1,0
         BZ    HAD1
         BR    R4
*
HAD3     MVI   CIR+1,X'06'             SET CIR = 6
         LH    R14,CIR
         CLI   RIR+1,0                 ZERO ?
         BER   R4                      YES, BRANCH
         LA    R15,8
         B     HAD0
*
***********************************************************************
*
*        ROUTINE NUMBER 14
*
***********************************************************************
*
* CALL   BAL   R4,ROUTIN14
*
*        LOAD ZERO INTO R14
*        FALL THROUGH TO ROUTINE NUMBER 13
*
ROUTIN14 SR    R14,R14
*
***********************************************************************
*
*        ROUTINE NUMBER 13
*
***********************************************************************
*
*        GENERATE CODE TO STORE FLOATING POINT REGISTER
*        SPECIFIED BY R14
*        THE OPERAND IS ADJUSTED
*
ROUTIN13 ST    R4,RETADR+36            STORE RETURN ADDR
         SLL   R14,1                   MULTIPLY R14 BY 2
         LA    R15,RUTR                LOAD ADDR OF RUTR
         L     R15,0(R14,R15)          LOAD R9 ADDR OF OPERAND
         SLL   R14,3                   SHIFT REG NO TO OREOARE INSTRUC
         LA    R14,10(,R14)            INTRODUCE CDSA
         STC   R14,HBC3+1
         NI    3(R15),X'0F'
         MVC   HBC3+2(2),3(R15)
         ST    R15,RETADR+48
         BAL   R2,GENTXTP4
HBC3     STD   0,0(CDSA,0)             *** GENERATE ***
HBC2     L     R15,RETADR+48
         XI    0(R15),X'C0'
         MVC   WORKPL(2),3(R15)
         BAL   R4,MAXCH
         SRL   R14,4
         L     R4,RETADR+36            LOAD RETURN ADDR
         BR    R4                      RETURN
*
***********************************************************************
*
*        ROUTINE NUMBER 15
*
***********************************************************************
*
* CALL   BAL   R4,ROUTIN15
*
*        IF THE OPERAND IS AN ADDR BRANCH TO ROUTINE NUMBER 3
*        IF THE OPERAND IS NOT AN ADDR AND IS IN A REGISTER GET
*        THE REGISTER NUMBER TO V-PLACE, ELSE IT BRANCHES TO
*        ROUTINE NUMBER 1
*
ROUTIN15 TM    0(R9),X'20'
         BO    ROUTINE3
         TM    0(R9),X'40'
         BZ    ROUT151
         TM    0(R9),X'80'
         BO    ROUTINE1
         SH    R7,ONEENTRY
         B     ROUTINE1
*
ROUT151  IC    R15,3(,R9)              GET
         SRL   R15,4                       REG
         STC   R15,VPLACE                      NUMBER
         MVZ   VPLACE(1),3(R9)                  TO VPLACE
         BR    R3                      RETURN
*
***********************************************************************
*
*        DECOMP
*
***********************************************************************
*
* CALL   BAL   R4,DECOMP
*
*        DECOMPOSE OPERAND BY MOVING ITS PARTS INTO LOW ENDS OF
*        HALFWORDS
*
DECOMP   MVC   OPDPBN+1(1),2(R9)       MOVE PBN
         MVC   OPDADR(2),3(R9)         MOVE ADDR
         LH    R1,OPDADR
         N     R1,HEXFFF
         STH   R1,OPDLN                LABEL NUMBER
         BR    R4
*
***********************************************************************
*
*        STACKAPI
*
***********************************************************************
*
* CALL   BAL   R4,STACKAPI
*
*        STACK ALL PURPOSE IDENTIFIER (API)
*
STACKAPI SH    R9,KH5
         CR    R10,R9
         BNL   STACKOFL
         MVC   0(5,R9),API
         BR    R4
*
***********************************************************************
*                                                                     *
*        PROGRAM BLOCK NUMBER HANDLING                                *
*                                                                     *
***********************************************************************
*
* CALL   BAL   R4,PBNHDL
*
*        PROGRAM BLOCK NUMBER HANDLING INSERTS NEW PBN IN
*        WORKAREA, SPBNST
*        SAVE R7 IN PBTAB2
*        INSERT NEW OBJECT TIME STACK POINTER VALUE TO R7
*
PBNHDL   SR    R2,R2
         IC    R2,3(,R8)
         CLI   0(R8),X'0D'             SOURCE OPERATOR BETA ?
         BE    PBNHDL1                 YES
         CLI   0(R8),X'2A'             SOURCE OPERATOR EPSILON ?
         BNE   PBNHDL2                 NO
*                                      (=BRANCH IF OPTR IS PI OR PHI)
*
*        OPERATOR IS BETA OR EPSILON
*
PBNHDL1  IC    R2,1(,R8)
         LA    R8,1(,R8)
PBNHDL2  LH    R1,SPBNST               STORE
         SLL   R1,1                    OLD
         STH   R7,PBTAB2(R1)           P-VALUE
         STC   R2,SPBNST+1             INSERT NEW PBN
         SLL   R2,1                    GET DISP IN PBTAB2
         LH    R7,PBTAB2(R2)           LOAD NEW P VALUE
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BOR   R4                      YES, RETURN
         B     CLEARRG                 CLEAR REGISTERS RETURN DIRECT
*
***********************************************************************
*
*        PLPRST - PARAMETERLESS PROCEDURE STATEMENT HANDLING
*
***********************************************************************
*
* CALL   BAL   R4,PLPRST
*
*        CHECKS THAT OPERAND IS A PARAMETERLESS PROCEDURE
*
PLPRST   ST    R4,STRETURN             SAVE RETURN ADDR
         BAL   R4,DECOMP               DECOMPOSE OPERAND
         TM    1(R9),X'C0'             PROCEDURE IDENTIFIER ?
         BZ    PLPRST4                 NO, ERROR
         LH    R4,OPDADR
         SRL   R4,12                   GET NUMBER OF PARAMETERS
         LTR   R4,R4                   NUMBER ZERO ?
         BZ    PLPRST1                 YES, BRANCH
PLPRST0  BAL   R4,SERR1                ERROR
         DC    H'187'
*
         B     PLPRST3
*
PLPRST4  BAL   R4,SERR3                ERROR
         DC    H'183'
*
         B     PLPRST3
*
PLPRST1  TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    PLPRST3                 YES, BRANCH
         BAL   R4,OPDREC               OPERAND RECOGNIZER
         TM    3(R9),REGADRM           OPERAND IN ADR
         BZ    PLPRST3                 NO
         SH    R7,ONEENTRY             RELEASE STACK
         XI    RII,RIIADRM             ADR NOT OCCUPIED
PLPRST3  L     R4,STRETURN             LOAD RETURN ADDR
         BR    R4
*
***********************************************************************
*
*        SUBROUTINE - LOAD VPLACE, WPLACE
*
***********************************************************************
*
* CALL   BAL   R4,LDVWPLC
*
LDVWPLC  ST    R4,LDRET
         BAL   R4,OPDREC               ERAND RECOGNIZER
         TM    0(R9),X'20'             ADDR OR VALUE ?
         BO    LDVW1                   ADDR
         TM    0(R9),X'40'             VALUE IN REG ?
         BO    LDVW3                   NO
         SR    R4,R4
         IC    R4,3(,R9)               GET REG NUMBER
         SRL   R4,4
         SLL   R4,1                    DOUBLE IT
         TM    1(R9),X'01'             VALUE INTEGER ?
         BZ    LDVW4                   NO
         SLL   R4,1                    YES, 4 TIMES REG NUMBER
         ST    R9,RUTI(R4)             INTRODUCE CORRECT R9 ADDR
         B     LDVW3
*
LDVW4    ST    R9,RUTR(R4)             INTRODUCE CORRECT R9 ADDR
LDVW3    BAL   R4,CLEARRG              CLEAR REGISTERS
         BAL   R4,ROUTINE1             USE ROUTINE 1 TO LOAD VW-PLACE
         B     LDVWR
*
LDVW1    CLI   2(R9),X'00'             FUNCTION VALUE IN FSA
         BNE   LDVW1A
         ST    R9,RUTI+32              INTRODUCE CORRECT R9 ADDR
         CLI   0(R8),XFCOMMA           SOURCE OPERATOR COMMA
         BE    LDVW3                   YES
LDVW1A   TM    0(R9),X'40'             ADDR IN STACK ?
         BO    LDVW2                   YES
         MVI   VPLACE,X'88'            ADDR IN REG ADDR
         MVC   WPLACE(2),ZEROHW
         B     LDVWR
*
LDVW2    MVI   VPLACE,X'AA'            ADDR
         MVC   WPLACE(2),3(R9)         IN STACK
LDVWR    L     R4,LDRET
         BR    R4
*
LDRET    DC    F'0'
*
***********************************************************************
*
*        SUBROUTINES FOR MOVING STACK POINTERS
*
***********************************************************************
*
*        ENTRY FOR MOVING OPERATOR STACK PTR
*
MOVEOPTK LA    R10,1(R10)
         B     MOVERET
*
*        ENTRY FOR MOVING OPDSTACK POINTER
*
MOVEOPDK SH    R9,KH5
MOVERET  CR    R10,R9
         BNL   STACKOFL
         BR    R4
*
***********************************************************************
*
*        TARITHM
*
***********************************************************************
*
* CALL   BAL   R4,TARITHM
*
*        RETURN TO RETURN IF OPERAND INTEGER OR REAL
*        ELSE RETURN TO RETURN+4 AFTER ERROR MESSAGE 163 IS
*        GIVEN
*        CHECK FOR ARRAY OR PROCEDURE IDENTIFIER
*
APIMASK  EQU   X'10'
*
*        TEST IF OPERAND IS ARITHMETIC
*
TARITHM  TM    0(R9),APIMASK           API IN STACK
         BOR   R4                      YES, RETURN NO ERROR
         TM    1(R9),X'03'             OPERAND ARITHMETIC
         BM    PROGARR                 YES, CONTINUE CHECK
         ST    R4,SAVTRREI             SAVE RETURN
         BAL   R4,SERR2
         DC    H'163'                  ERROR 163
*
         L     R4,SAVTRREI
         B     4(R4)                   RETURN ERROR MESSAGE 163 GIVEN
*
PROGARR  LA    R1,4(R4)
         ST    R1,SAVTRREI             ERROR RETURN FROM ARRTEST
         B     ARRTESTA                CHECK FOR PROCEDURE OR ARRAY
*
***********************************************************************
*
*        LATRES
*
***********************************************************************
*
* CALL   BAL   R4,LATRES
*
*        RESERVE ONE ENTRY IN LABEL ADDR TABLE (LAT)
*        CHECK IF OVERFLOW
*
LATRES   LH    R1,LN                   GET CURRENT LN
         LA    R1,4(,R1)               ADD ONE ENTRY
         STH   R1,LN                   STORE NEW LN
*
*        CHECK IF LAT OVERFLOW
*
LATOVFLO TM    LN,X'F0'                LAT FULL ?
         BZR   R4                      NO
         ST    R4,LDRET                SAVE RETURN ADDR
         BAL   R4,SERR1                GENERATE ERROR PATTERN
         DC    H'216'
*
         LA    R1,LATBEG               RESET POINTER
         STH   R1,LN                   TO FIRST ENTRY
         L     R4,LDRET
         BR    R4
*
***********************************************************************
*
*        ARRAY AND PROCEDURE TEST
*
***********************************************************************
*
* CALL   BAL   R4,ARRTEST1
*
ARRTEST1 ST    R4,SAVTRREI             SAVE RETURN
*
*        ENTRY POINT FROM TARITHM
*
ARRTESTA TM    0(R9),APIMASK           OPERAND API ?
         BOR   R4                      YES, RETURN
         TM    1(R9),X'C0'             PROCEDURE ?
         BNM   ARRTESTT
         TM    1(R9),X'40'             STANDARD PROCEDURE
         BZ    PROCTES1                YES, ERROR
ARRTESTT TM    0(R9),X'C0'             IDENTIFIER FROM ITAB ?
         BNOR  R4                      NO, RETURN
         TM    1(R9),X'04'
         BZ    PROCTEST                NO, ARRAY CONTINUE TEST
         BAL   R4,SERR3
         DC    H'196'
*
ARRTEST3 L     R4,SAVTRREI             RESTORE RETURN
         BR    R4
*
PROCTEST TM    1(R9),X'C0'             PROCEDURE ?
         BZR   R4                      NO, RETURN
         TM    3(R9),X'F0'             PARAMETERLESS ?
         BZR   R4                      YES, RETURN
PROCTES1 BAL   R4,SERR1                ERROR 187
         DC    H'187'
*
         B     ARRTEST3
*
ARRTEST2 ST    R4,RETARR2
         LA    R9,5(,R9)
         BCTR  R10,0
         BAL   R4,ARRTEST1
         LA    R10,1(,R10)
         SH    R9,KH5
         L     R4,RETARR2
         B     ARRTEST1
*
RETARR2  DC    F'0'
*
***********************************************************************
*
*        OPERAND TEST
*
***********************************************************************
*
* CALL   BAL   R4,OPDTEST
*
*        GIVE ERROR MESSAGE 162 IF OPERAND IS MISSING
*        STACK ALL PURPOSE IDENTIFIER
*        RETURN VIA R4 IF NO ERROR RETURN VIA R3
*
OPDTEST  TM    COMPFLGS,OPERAND        OPERAND PRESENT ?
         BOR   R3                      YES, RETURN
         ST    R4,STRETURN
         BAL   R4,SERR4                ERROR 162
         DC    H'162'
*
         L     R4,STRETURN
         OI    COMPFLGS,OPERAND        OPERAND SWITCH ON
         B     STACKAPI                STACK API RETURN DIRECT
*
ERR166   ST    R4,RETADR               STORE RETURN ADDR
         TM    COMPFLGS,OPERAND        OPDT ?
         BZ    BYB2                    NO, BRANCH
         LA    R9,5(,R9)               CLOPD
         NI    COMPFLGS,255-OPERAND    OPDFL=FALSE
BYB2     BAL   R4,SERR1                ERROR 166
         DC    H'166'
*
         L     R4,RETADR               LOAD RETURN ADDR
         BR    R4                      RETURN
*
         TITLE 'IEX50 - COMPILATION PHASE, DECISION MATRIXES'
*
*        DECISION MATRICIES
*
*        START OF DECISION AREA
*
***********************************************************************
*
*        PROGRAM CONTEXT COLUMN VECTOR
*
***********************************************************************
*
DECAREA  DC    X'0A0A0A0A0A0A09120703030B000002020A0A0A0A0A0A080404'
         DC    X'121212120512060A0A0A0A0A121201120C0D0E0F1110000000'
*
***********************************************************************
*
*        PROGRAM CONTEXT ROW VECTOR
*
***********************************************************************
*
         DC    X'ABABABABABABABABABAB853926131313ABABABABABAB72ABAB'
         DC    X'ABABAB98ABABABABABABABAB00AB4C5FABABABABABAB000030'
*
***********************************************************************
*
*        PROGRAM CONTEXT MATRIX
*
***********************************************************************
*
         DC    X'00010454545454545454545454545454540354'
         DC    X'0001040407074B0707074B191810545453544B'
         DC    X'00011D1D06084B290C404B191C54541054544B'
         DC    X'00011A1A06084B290C404B171C17171754544B'
         DC    X'00011A1A064B11290C404B121C12121254544B'
         DC    X'00011A1A06084B290C404B121C12121254544B'
         DC    X'1B1E1A1A1B131429151616141C14141454544B'
         DC    X'5454545454545454555454541C545454545454'
         DC    X'00011D1D06084B290C404B1A1C54515454544B'
         DC    X'1F1E1F1F1F1F1F1F1F1F1F1F1C1F1F1F545416'
*
***********************************************************************
*
*        STATEMENT CONTEXT COLUMN VECTOR
*
***********************************************************************
*
ADRSTC   DC    X'090909090909010D030F0F0C0F0F0F0F0A0A0A0A0A0A060F0F'
         DC    X'0708070B000F0C0A0A0A0A0A05020F040E0C0C0C0F0F000000'
*
***********************************************************************
*
*        STATEMENT CONTEXT ROW VECTOR
*
***********************************************************************
*
         DC    X'D0D0D0D0D0D0D0B03040D0D0D0D0D0D0D0D0D0D0D0D0D00060'
         DC    X'8090A0D0D0D0D0D0D0D0D0D0D0D0D0D02050D0C07010000033'
*
***********************************************************************
*
*        STATEMENT CONTEXT MATRIX
*
***********************************************************************
*
         DC    X'22384B294B4B4B4B4B4B4B4B3E4B1C1B'
         DC    X'22384B294B3B544B4B4B4B4B1B543B1B'
         DC    X'224039294B394B4B4B21214B1B4B1C1B'
         DC    X'22404B2926264B4B4B214B4B1B4B1C1B'
         DC    X'5454543454345454545454541B543654'
         DC    X'22403D294B3D4B4B4B21214B1B4B1C1B'
         DC    X'4B4B4B294B4B284B4B4B4B1B1B4B1C1B'
         DC    X'22404B294B2B4B2B4B214B2B1B4B1C1B'
         DC    X'22404B294B4B4B4B2D214B1B1B4B1C1B'
         DC    X'22404B294B2F4B4B4B214B2F1B4B1C1B'
         DC    X'22404B294B314B4B4B2121311B4B1C1B'
         DC    X'22404B2933334B4B4B214B4B1B4B1C1B'
         DC    X'22404B294B4B544B4B214B4B1B241C1B'
         DC    X'224B4B4B4B4B4B4B4B4B4B4B474B1C47'
*
***********************************************************************
*
*        EXPRESSION CONTEXT COLUMN VECTOR
*
***********************************************************************
*
ADREXC   DC    X'0B0B0C0C0C0D050F070F0F0F0F0F0F0F0E0E0E0E0E0E0F0F0F'
         DC    X'0F0F0F0F08090A00020304010F060F0F0F0F0F0F0F0F000000'
*
***********************************************************************
*
*        EXPRESSION CONTEXT ROW VECTOR
*
***********************************************************************
*
         DC    X'A0A0B0B0B0C050E0E0E0E0E0E0E0E0E0D0D0D0D0D0D0E0E0E0'
         DC    X'E0E0E0E06070800020304010E060E0E0E0E090E0E0E000003F'
*
***********************************************************************
*
*        EXPRESSION CONTEXT MATRIX
*
***********************************************************************
*
         DC    X'4B4D4D4D4D404D29494D4D424343434D'
         DC    X'414C434343404C29494C4C424343434C'
         DC    X'414C4C4343404C29494C4C424343434C'
         DC    X'414C4C4C43404C29494C4C424343434C'
         DC    X'414C4C4C4C404C29494C4C424343434C'
         DC    X'4143434343404429501B1B424343431B'
         DC    X'4143434343404B29414E56424343431B'
         DC    X'4143434343404B29494B57424343431B'
         DC    X'4143434343404F29414F48424343434F'
         DC    X'4B3F3F3F3F403F29493F3F3F3F433F3F'
         DC    X'4B454545454045294945454543434545'
         DC    X'4B454545454045294945454545434545'
         DC    X'4B454545454045294945454545454545'
         DC    X'4B454545454045294945454243434A45'
         DC    X'4143434343404629464B464243434346'
*
         TITLE 'IEX50 - COMPILATION PHASE, WORKAREA DSECT'
*
*        THIS MODULE HAD ITS OWN INLINE VERSION OF THE WORKAREA
*        WHICH HAD ITS OWN VARIABLES APPENDED ONTO THE END LIKE
*        IEX40. THE INLINE VERSION HAS BEEN DELETED AND HAVE
*        INSTEAD INSERTED A COPY WORKAREA. THIS WILL NEED TO HAVE
*        ADDITIONAL VARIABLES APPENDED AS THEY ARE DISCOVERED BY
*        DISASSEMBLY AND PICKED UP FROM IEX40
*
WORKAREA DSECT
*
         COPY  WORKAREA
         COPY  WAEXT
         ORG   SAVEAREA
         COPY  FSAREA                  COPY RUNTIME DSECT
*                                      FOR OP CODE GENERATION OFFSETS
         COPY  IEX50002                IEX50002 (RECOVERED)
         COPY  IEX5000C                IEX50003 (RECOVERED) INIT
         COPY  IEX50003                IEX50003 CONTINUATION
         COPY  IEX50004                IEX50004
         COPY  IEX50005                IEX50005
         COPY  IEX50006                IEX50006
*
*        CHARACTER EQUATES
*
         IEXCHAR
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
./ ADD NAME=IEX5000C 0201-12230-12230-1200-00815-00815-00000-LEVEL
         TITLE 'IEX50003 - CP0,4,7,8,16,25,36,38,41'
*
***********************************************************************
*
*        THIS SOURCE FOR THE START OF IEX50003 WAS RECOVERED BY
*        DISASSMBLY OF THE LOAD MODULE
*
***********************************************************************
*
*
***********************************************************************
*
*        COMPILER PROGRAM - CP0
*
***********************************************************************
*
         USING CP0,R12
CP0      TM    COMPFLGS,OPERAND
         BZ    CP0D
         CLI   0(R10),X'25'
         BE    CP0C
         BAL   R4,SERR4
         DC    H'164'                  ERROR 164
*
CP0A     LA    R9,5(,R9)
CP0B     BAL   R4,MOVEOPTK
         MVC   0(1,R10),0(R8)
         CLI   0(R8),X'0C'
         BER   R5
         BAL   R4,PBNHDL
         BR    R5
*
CP0C     BAL   R4,SERR1
         DC    H'173'                  ERROR 173
*
         B     CP0A
*
CP0D     CLI   0(R8),X'0D'
         BNE   CP0B
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    CP0B                    YES, BRANCH
         BAL   R4,CLEARRG
         MVC   CP0E+1(1),1(R8)
         LA    R2,CP0E
         BAL   R14,GENTXTS
         DC    H'8'                    LENGTH OF TXT
*
         B     CP0B
*
CP0E     MVI   SAVOUTA+1,X'00'         *** GENERATED TEXT ***
         BAL   R15,PROLOG(R13,0)       *** GENERATED TEXT ***
*
***********************************************************************
*
*        COMPILER PROGRAM - CP1
*
***********************************************************************
*
         USING CP1,R12
CP1      TM    COMPFLGS,OPERAND
         BZ    CP1A
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    CP1B                    YES, BRANCH
         CLI   1(R9),X'08'
         BNE   CP1A
         BAL   R4,CLEARRG
         MVC   WORKPL(2),3(R9)
         LH    R1,WORKPL
         A     R1,LATAB
         ST    R6,0(,R1)
CP1B     CLI   0(R10),X'0D'
         BL    CP1C
         CLI   0(R10),X'0F'
         BNL   CP1C
         BAL   R4,MOVEOPTK
         MVI   0(R10),X'0B'
CP1C     LA    R9,5(,R9)
         BR    R5
*
CP1A     L     R12,SCPTAB+4*84         R12 -> CP84
         BR    R12
*
***********************************************************************
*
*        COMPILER PROGRAM - CP3
*
***********************************************************************
*
         USING CP3,R12
CP3      TM    COMPFLGS,OPERAND
         BO    CP3A
         TM    COMPFLGS,PROC
         BO    CP3B
         BAL   R2,GENTXT4              GENERATE 4 BYTES
         B     TERMNTE(FSA)            *** GENERATED TEXT ***
*
CP3B     B     CPEND
*
CP3A     L     R12,SCPTAB+4*84         R12 -> CP84
         BR    R12
*
***********************************************************************
*
*        COMPILER PROGRAM - CP4
*
***********************************************************************
*
         USING  CP4,R12
CP4      TM     COMPFLGS,OPERAND
         BZ     CP4A
         BAL    R4,SERR4
         DC     H'164'                 ERROR 164
*
         LA     R9,5(R9)
CP4A     BAL    R4,MOVEOPTK
         MVC    0(1,R10),0(R8)
         CLI    0(R8),X'09'
         BE     CP4B
         SH     R9,KH5
         BAL    R4,MOVEOPDK
         CLI    SPBNST+1,0
         BE     CP4C
         BAL    R4,LATRES
         STH    R1,CP4D+2              UPDATE GENERATED CODE
         MVC    3(2,R9),CP4D+2
         BAL    R2,GENTXT6             GENERATE 6 BYTES
CP4D     L      R15,0(R12)             *** GENERATED CODE ***
         BR     R15                    *** GENERATED CODE ***
*
CP4C     CLI    0(R8),X'0A'
         BER    R5                     RETURN TO SUBSTART
         BAL    R4,PBNHDL
         BAL    R4,CP4E
         MVC    5(5,R9),STRDNAME
         LA     R9,5(R9)
         BAL    R4,DECOMP
         MVC    0(5,R9),STRDNAME
         SH     R9,KH5
         MVC    HALFW,KH15
         L      R15,LATAB
         AH     R15,OPDLN
         ST     R6,0(R15)
         TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?
         BO     CP4F                   YES, BRANCH
         CLI    0(R8),XFLBRAC
         BE     CP4G
CP4F     NI     COMPFLGS,255-OPERAND   TURN OFF OPERAND FLAG
CP4H     CLI    0(R8),XFDELTA
         BE     COMP
         BAL    R4,CP4E
         B      CP4H
*
CP4G     BAL    R4,CP4E
         MVC    CP4I(2),STRDNAME
         BAL    R2,GENTXT2             GENERATE 4 BYTES
CP4I     DC     X'0000'                *** GENERATED CODE ***
         MVI    CBVTAB+45,X'00'
         TM     STRDNAME+1,X'20'
         BZ     CP4J
         MVI    CBVTAB+45,X'80'
         MVC    CBVTAB+46(2),STRDNAME
         TM     STRDNAME+1,X'08'
         BZ     CP4J
         MVI    CBVTAB+45,X'C0'
CP4J     MVC    CBVTAB(45),CBVTAB+3
         LH     R15,HALFW
         BCTR   R15,R0
         STH    R15,HALFW
         CLI    0(R8),XFCOMMA
         BE     CP4G
         LH     R15,HALFW
         LTR    R15,R15
         BZ     CP4K
         MVI    CBVTAB+45,X'00'
         B      CP4J
*
CP4K     LH     R15,HALFW
         LA     R15,1(,R15)
         STH    R15,HALFW
         SH     R15,KH15
         BP     CP4F
         TM     CBVTAB,X'80'
         BZ     CP4L
         LH     R15,OPDPBN
         SLL    R15,3
         STH    R15,CP4ZA
         STH    R15,CP4ZB
         SR     R15,R15
         TM     6(R9),X'03'
         BZ     CP4M
         LA     R15,1(,R15)
CP4M     AH     R15,HALFW
         SLL    R15,3
         LA     R15,16(,R15)
         STH    R15,CP4N+2
         STH    R15,CP4ZC
         STH    R15,CP4P+2
         LA     R15,4(,R15)
         STH    R15,CP4Q+2
         LA     R2,CP4R
         BAL    R14,GENTXTS
         DC     H'12'                  GENERATE 12 BYTES
*
         TM     CBVTAB,X'40'
         BZ     CP4S
         LA     R2,CP4P
         BAL    R14,GENTXTS
         DC     H'8'                   GENERATE 8 BYTES
*
         B      CP4L
*
CP4S     MVC    CP4ZF(2),CBVTAB+1
         LA     R2,CP4T
         BAL    R14,GENTXTS
         DC     H'8'                   GENERATE 8 BYTES
*
CP4L     MVC    CBVTAB(45),CBVTAB+3
         B      CP4K
CP4E     ST     R4,STRETURN
         MVC    STRDNAME+3(2),ZEROHW
CP4V     CLI    1(R8),XFZETA
         BL     CP4U
         BH     CP4W
         BAL    R4,JBUFFER
         B      CP4V
*
CP4W     MVC    STRDNAME(5),1(R8)
         LA     R8,5(,R8)
         B      CP4V
*
CP4U     LA     R8,1(,R8)
         L      R15,STRETURN
         BR     R15
*
CP4B     L      R11,STC
         BR     R5                     RETURN TO SUBSTART
*
CP4P     ST     R8,0(R10)              *** GENERATED CODE ***
CP4Q     ST     R9,0(R10)              *** GENERATED CODE ***
CP4R     BAL    R15,CAP1(R13)          *** GENERATED CODE ***
CP4ZA    DC     X'0000'                *** GENERATED CODE ***
CP4ZB    DC     X'0000'                *** GENERATED CODE ***
CP4N     L      R8,0(R10)              *** GENERATED CODE ***
CP4T     BAL    R15,VALUCALL(R13)      *** GENERATED CODE ***
CP4ZC    DC     X'0000'                *** GENERATED CODE ***
CP4ZF    DC     X'0000'                *** GENERATED CODE ***
*
***********************************************************************
*
*        COMPILER PROGRAM - CP7
*
***********************************************************************
*
         USING  CP7,R12
CP7      BAL    R4,MOVEOPTK
         MVI    0(R10),X'0B'
         B      COMP
*
***********************************************************************
*
*        COMPILER PROGRAM - CP8
*
***********************************************************************
*
         USING  CP8,R12
CP8      TM     COMPFLGS,OPERAND
         BO     CP8A
CP8B     BAL    R4,MOVEOPTK
         MVI    0(R10),XFRBRAC
         LA     R11,614(,R11)
         TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?
         BOR    R5                     YES, RETURN TO SUBSTART
         BAL    R4,CLEARRG
         BR     R5                     RETURN TO SUBSTART
*
CP8A     BAL    R4,SERR3
         DC     H'177'                 ERROR 177
*
         LA     R9,5(,R9)
         B      CP8B
*
***********************************************************************
*
*        COMPILER PROGRAM - CP16
*
***********************************************************************
*
         USING  CP16,R12
CP16     TM     COMPFLGS,OPERAND
         BZ     CP16A
         BAL    R4,PLPRST
         LA     R9,5(R9)
         NI     COMPFLGS,255-OPERAND   TURN OFF OPERAND
CP16A    CLI    0(R8),XFEND
         BNE    CP16B
         BCT    R10,SPECTEST
CP16B    TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?
         BO     CP16C                  YES, BRANCH
         CLI    0(R10),X'0D'
         BE     CP16D
         TM     6(R9),X'80'
         BZ     CP16E
         BAL    R2,GENTXT4             GENERATE 4 BYTES
         B      232(R13)               *** GENERATED CODE ***
*
CP16C    CLI    0(R10),X'0D'
         BE     CP16F
         CLI    1(R8),XFPLUS
         BE     CP16G
         TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?
         BO     CP16G                  YES, BRANCH
         BAL    R4,DECOMP
         LH     R4,OPDLN
         L      R15,LATAB
         ST     R6,0(R4,R15)
CP16G    LA     R9,5(R9)
         LA     R1,4
CP16H    CLI    0(R10),X'0F'
         BNE    CP16I
         LA     R1,4(R1)
CP16I    SLL    R1,12
         IC     R1,3(R9)
         SRL    R1,4
         LA     R9,5(R9)
CP16F    LH     R15,SPBNST
         SLL    R15,2
         STH    R1,PBTAB3+2(R15)
         BAL    R4,PBNHDL
         BCT    R10,SPECTEST
CP16D    BAL    R2,GENTXT4             GENERATE 4 BYTES
         BAL    R15,EPILOGB(FSA)       *** GENERATED CODE ***
         LH     R1,ZEROHW
         B      CP16F
*
CP16E    LA     R1,20
         LA     R9,5(R9)
         B      CP16H
*
***********************************************************************
*
*        COMPILER PROGRAM - CP24
*
***********************************************************************
*
         USING  CP24,R12
CP24     TM     COMPFLGS,OPERAND
         BZ     CP24A
         BAL    R4,SERR3
         DC     H'177'                 ERROR 177
*
         LA     R9,5(,R9)
CP24A    BAL    R4,SCHDL
         BR     R5                     RETURN TO SUBSTART
*
***********************************************************************
*
*        COMPILER PROGRAM - CP25
*
***********************************************************************
*
         USING  CP25,R12
CP25     TM     COMPFLGS,OPERAND
         BZ     CP25A
         BAL    R4,PLPRST
         LA     R9,5(,R9)
CP25A    BAL    R4,MOVEOPTK
         MVC    0(1,R10),0(R8)
         BAL    R4,SCHDL
         BR     R5                     RETURN TO SUBSTART
*
***********************************************************************
*
*        COMPILER PROGRAM - CP36
*
***********************************************************************
*
         USING  CP36,R12
CP36     LA     R4,CP36A
         BAL    R3,OPDTEST
         BAL    R4,TARITHM
         B      CP36B                  +00
*
CP36A    LA     R9,5(,R9)              +04
         BAL    R4,MOVEOPTK
         MVC    0(1,R10),0(R8)
         BR     R5                     RETURN TO SUBSTART
*
CP36B    TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?
         BO     CP36A                  YES, BRANCH
         BAL    R4,OPDREC
         TM     1(R9),X'01'
         BO     CP36C
         BAL    R4,TRREIN
         MVC    CP36D+2(2),8(R9)
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP36D    ST     R14,0(R10)             *** GENERATED CODE ***
         B      CP36E
*
CP36F    SR     R14,R14
         IC     R14,3(R9)
         SRL    R14,4
         BAL    R4,ROUTINE9
         BAL    R4,ROUTINE8
CP36E    AH     R7,ONEENTRY
         AH     R7,ONEENTRY
         STH    R7,WORKPL
         BAL    R4,MAXCH
         B      CP36A
*
CP36C    LA     R3,CP36F
         BAL    R4,ROUTIN15
         TM     0(R9),X'A0'
         BZ     CP36E
         NC     CP36G+2(2),CLEARDIS    UPDATE GENERATED CODE
         OC     CP36G+2(2),8(R9)
         MVC    CP36G+4(2),WPLACE
         MVZ    CP36G+4(1),VPLACE
         BAL    R2,GENTXT6             GENERATE 6 BYTES
CP36G    MVC    0(4,R10),0             *** GENERATED CODE ***
         B      CP36E
*
***********************************************************************
*
*        COMPILER PROGRAM - CP38
*
***********************************************************************
*
         USING  CP38,R12
CP38     LA     R4,CP38A
         BAL    R3,OPDTEST
         BAL    R4,TARITHM
         B      CP38B
CP38B    TM     20(R9),X'10'
         BO     CP38A
         TM     21(R9),X'08'
         BZ     CP38C
         CLI    0(R8),XFRSQBR
         BNE    CP38F
         TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?
         BZ     CP38D                  NO, BRANCH
         B      CP38E
*
CP38G    MVI    20(R9),X'A0'
         NI     21(R9),X'03'
         OI     21(R9),X'30'
CP38H    LA     R9,20(R9)
         OI     COMPFLGS,OPERAND
         SH     R10,KH2
         CLC    1(1,R10),99(R11)
         BE     SPECTEST
         LA     R11,324(,R11)
         CLC    1(1,R10),99(R11)
         BE     SPECTEST
         SH     R11,KH614
         B      SPECTEST
*
CP38F    BAL    R4,SERR1
         DC     H'180'                 ERROR 180
*
         MVC    20(5,R9),API
CP38C    TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?
         BZ     CP38J                  NO, BRANCH
CP38A    NI     COMPFLGS,255-NLOAD
         CLI    0(R8),XFRSQBR
         BNE    CP38K
         TM     21(R9),X'30'
         BM     CP38L
         CLC    18(1,R9),17(R9)
         BNE    CP38M
         TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?
         BZ     CP38N                  NO, BRANCH
         B      CP38G
*
CP38M    TM     20(R9),X'10'
         BO     CP38H
         BAL    R4,SERR1
         DC     H'179'                 ERROR 179
*
         B      CP38G
*
CP38K    LA     R9,5(,R9)
         SR     R1,R1
         IC     R1,13(,R9)
         LA     R1,1(,R1)
         STC    R1,13(,R9)
         TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?
         BOR    R5                     YES, RETURN TO SUBSTART
         CLI    14(R9),X'01'
         BNER   R5                     NO, BRANCH TO SUBSTART
         MVC    WORKPL(2),3(R9)
         LH     R0,WORKPL
         SLL    R0,15(R1)
         LTR    R0,R0
         BNMR   R5                     NO, BRANCH TO SUBSTART
         OI     COMPFLGS,SUBSCOPT
         BR     R5                     RETURN TO SUBSTART
*
CP38J    TM     COMPFLGS,SUBSCOPT
         BO     CP38O
         BAL    R4,CP38P
CP38O    TM     21(R9),X'30'
         LA     R9,20(R9)
         BM     CP38Q
         BAL    R4,ROUTINE1
         B      CP38R
*
CP38Q    BAL    R4,ROUTINE3
         AH     R7,ONEENTRY
         MVI    RII,X'01'
         ST     R9,RUTI+32
         MVI    0(R9),X'A8'
CP38R    SH     R9,KH20
         SR     R1,R1
         IC     R1,16(R9)
         LA     R1,4(R1)
         STC    R1,16(R9)
         TM     COMPFLGS,SUBSCOPT
         BO     CP38A
         AH     R1,WPLACE
         STH    R1,CP38S+2             UPDATE GENERATED CODE
         MVN    CP38S+1(1),VPLACE
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP38S    M      R14,0                  *** GENERATED CODE ***
         TM     10(R9),X'40'
         BO     CP38T
         MVZ    CP38U+1(1),13(R9)
         BAL    R2,GENTXT2             GENERATE 2 BYTES
CP38U    AR     R0,R15                 *** GENERATED CODE ***
         B      CP38A
*
CP38T    MVC    CP38V+2(2),13(R9)
         MVC    CP38W+2(2),13(R9)
         LA     R2,CP38V
         BAL    R14,GENTXTS
         DC     H'8'                   GENERATE 8 BYTES
*
         B      CP38A
*
CP38D    BAL    R4,CP38P
         BAL    R4,CLEARRG
         TM     21(R9),X'30'
         BM     CP38X
         SR     R1,R1
         IC     R1,22(R9)
         SLL    R1,3
         STH    R1,CP38AA+2            UPDATE GENERATED CODE
         MVC    CP38AB+2(2),23(R9)
         NI     CP38AB+2,X'0F'
         LA     R2,CP38AA
         BAL    R14,GENTXTS
         DC     H'12'                  GENERATE 12 BYTES
*
         AH     R7,ONEENTRY
         OI     RII,X'01'
CP38E    MVC    20(2,R9),CP38YA
         STH    R7,SPBNST+2
         OI     SPBNST+2,X'80'
         MVC    22(3,R9),SPBNST+1
         B      CP38H
*
CP38X    LR     R1,R7
         AH     R1,ONEENTRY
         STH    R1,CP38AC+2            UPDATE GENERATED CODE
         STH    R1,CP38AD+2
         STH    R1,WORKPL
         BAL    R4,MAXCH
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP38AC   ST     R15,0(R10)             *** GENERATED CODE ***
         LA     R9,20(R9)
         BAL    R4,OPDREC
         SH     R9,KH20
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP38AD   L      R15,0(R10)             *** GENERATED CODE ***
         LA     R2,CP38AE
         BAL    R14,GENTXTS
         DC     H'4'                   GENERATE 4 BYTES
*
         B      CP38E
*
CP38L    TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?
         BO     CP38G                  YES, BRANCH
         MVC    CP38AF+1(1),18(R9)
         LA     R2,CP38AF
         BAL    R14,GENTXTS
         DC     H'8'                   GENERATE 8 BYTES
*
         SH     R7,ONEENTRY
         MVI    RII,X'00'
CP38N    LH     R1,WPLACE
         LA     R1,8(R1)
         STH    R1,CP38AG+2            UPDATE GENERATED CODE
         LA     R1,4(R1)
         STH    R1,CP38AI+2
         MVZ    VPLACE(1),13(R9)
         TM     10(R9),X'40'
         BZ     CP38AHA
         MVZ    VPLACE(1),CP38AH+1
CP38AHA  MVC    CP38AG+1(1),VPLACE     UPDATE GENERATED CODE
         MVC    CP38AI+1(1),VPLACE
         BO     CP38AL
         TM     CP38AG+1,X'80'
         BO     CP38AK
         BAL    R4,ROUTINE8
         AH     R7,ONEENTRY
         SR     R14,R14
         IC     R14,13(R9)
         SRL    R14,4
         TM     RII,X'01'
         BZ     CP38AM
         BAL    R4,ROUTINE9
         B      CP38AL
*
CP38AM   OI     RII,X'01'
         LA     R14,128(R14)
         STC    R14,CP38AN+1
         TM     COMPFLGS+2,NOTEST
         BZ     CP38AO
         STC    R14,CP38AP+1
         BAL    R2,GENTXT2             GENERATE 2 BYTES
CP38AP   LR     R0,R0                  *** GENERATED CODE ***
CP38AO   MVI    CP38YB+1,X'12'         UPDATE GENERATED CODE
         MVZ    13(1,R9),CP38AN+1
CP38AK   LA     R1,20(R9)
         ST     R1,RUTI+32
CP38AL   LA     R2,CP38AG
         TM     COMPFLGS+2,NOTEST
         BO     CP38BA
         BAL    R14,GENTXTS
CP38YB   DC     H'16'                  GENERATE 16 BYTES
*
CP38BA   MVI    CP38YB+1,X'10'
         MVC    20(5,R9),10(R9)
         B      CP38H
*
CP38P    ST     R4,CP38YD
         BAL    R4,OPDREC
         TM     1(R9),X'01'
         BO     CP38YE
         BAL    R4,TRREIN
         BAL    R2,GENTXT2             GENERATE 2 BYTES
         LR     R15,R14                *** GENERATED CODE ***
CP38YF   L      R4,CP38YD
         BR     R4
*
CP38YE   LA     R3,CP38YG
         BAL    R4,ROUTIN15
         MVC    CP38YH+2(2),WPLACE
         MVN    CP38YH+1(1),VPLACE
         BAL    R2,GENTXT4
CP38YH   L      R15,0                  *** GENERATED CODE ***
         B      CP38YF
*
CP38YG   BAL    R4,ROUTINE8
         MVN    CP38AH+1(1),VPLACE
         BAL    R2,GENTXT2             GENERATE 2 BYTES
CP38AH   LR     R15,R0                 *** GENERATED CODE ***
         B      CP38YF
*
CP38V    A      R15,0(R10)             *** GENERATED CODE ***
CP38W    ST     R15,0(R10)             *** GENERATED CODE ***
CP38AA   L      R9,0(R11)              *** GENERATED CODE ***
CP38AB   L      R8,0(R12)              *** GENERATED CODE ***
CP38AE   BAL    R14,244(R13)           *** GENERATED CODE ***
CP38AG   C      R15,0                  *** GENERATED CODE ***
         BL     524(R13)               *** GENERATED CODE ***
CP38AI   C      R15,0                  *** GENERATED CODE ***
         BNL    524(R13)               *** GENERATED CODE ***
CP38AN   LR     R0,R0                  *** GENERATED CODE ***
CP38AF   CLI    0(R8),0                *** GENERATED CODE ***
         BNE    536(R13)               *** GENERATED CODE ***
CP38YA   DC     X'A038'
CP38YD   DC     F'0'                   R4 SAVEAREA
*
***********************************************************************
*
*        COMPILER PROGRAM - CP41
*
***********************************************************************
*
         USING  CP41,R12
CP41     LA     R4,CP41A
         BAL    R3,OPDTEST
         TM     1(R9),X'04'
         BZ     CP41B
CP41A    MVC    CP41C+1(1),0(R10)
         BAL    R4,MOVEOPTK
         MVC    0(1,R10),99(R11)
         L      R11,DECAADD
         LA     R11,290(,R11)
         SH     R9,KH15
         BAL    R4,MOVEOPTK
         MVC    0(1,R10),0(R8)
         TM     15(R9),X'10'
         BO     CP41D
         TM     16(R9),X'08'
         BZ     CP41D
         LA     R1,6
CP41E    LA     R2,CP41Z-1(R1)
CP41C    CLI    0(R2),0                UPDATED INSTRUCTION
         BER    R5                     ZERO, BRANCH TO SUBSTART
         BCT    R1,CP41E
         BAL    R4,SERR1
         DC     H'181'                 ERROR 181
*
         MVC    15(5,R9),API
         BR     R5                     RETURN TO SUBSTART
*
CP41G    MVC    0(5,R9),API
         B      CP41A
*
CP41B    BAL    R4,SERR3
         DC     H'184'                 ERROR 184
*
         B      CP41G
*
CP41D    MVI    5(R9),X'00'
         MVC    6(9,R9),5(R9)
         MVI    13(R9),X'01'
         SR     R1,R1
         IC     R1,18(,R9)
         SRL    R1,4
         LA     R1,1(,R1)
         STC    R1,12(R9)
         NI     18(R9),X'0F'
         TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?
         BOR    R5                     YES, RETURN TO SUBSTART
         MVI    11(R9),X'10'
         TM     16(R9),X'30'
         BNM    CP41H
         AH     R7,ONEENTRY
         LA     R9,15(,R9)
         BAL    R4,OPDREC
         SH     R9,KH15
         SH     R7,ONEENTRY
         SH     R7,ONEENTRY
CP41H    TM     RII,X'01'
         BO     CP41I
         LA     R14,8
         AH     R7,ONEENTRY
         OI     RII,X'01'
         B      CP41J
*
CP41I    BAL    R4,ROUTINE7
CP41J    LA     R2,5(R9)
         SLL    R14,2
         ST     R2,RUTI(R14)
         SLL    R14,2
         STC    R14,CP41K+1            UPDATE GENERATED INSTRUCTION
         STH    R7,SPBNST+2
         MVZ    SPBNST+2(1),CP41K+1    UPDATE GENERATED INSTRUCTION
         MVC    7(3,R9),SPBNST+1
         MVC    5(2,R9),CP41L
         NC     6(1,R9),16(R9)
         OI     6(R9),X'30'
         TM     16(R9),X'30'
         BM     CP41M
         LA     R3,CBVTAB+39
         LR     R1,R8
         S      R1,SOURCEB
         STH    R1,NUMBBL+1
CP41P    LA     R3,9(R3)
         C      R3,SUTABCA
         BNH    CP41N
         ST     R9,CP41Q
         LA     R9,15(,R9)
         BAL    R4,ROUTINE1
         LA     R1,4
         AH     R1,WPLACE
         STH    R1,WPLACE
         B      CP41S
*
CP41N    CLC    1(3,R3),NUMBBL
         BNE    CP41P
         MVC    0(5,R9),4(R3)
         MVI    14(R9),X'01'
         TM     3(R9),X'80'
         BZ     CP41R
         OI     COMPFLGS,SUBSCOPT
CP41R    MVC    WORKPL+1(3),0(R9)
         L      R1,WORKPL
         TM     0(R1),X'40'
         BO     CP41U
         IC     R1,3(R1)
         SRA    R1,4
         STC    R1,CP41V+1
         MVZ    CP41V+1(1),CP41K+1     UPDATE GENERATED INSTRUCTION
         BAL    R2,GENTXT2             GENERATE 2 BYTES
CP41V    LR     R0,R0                  *** GENERATED CODE ***
         BR     R5                     RETURN TO SUBSTART
*
CP41U    ST     R9,CP41Q
         LR     R9,R1
         BAL    R4,ROUTINE1
CP41S    L      R9,CP41Q
         MVC    CP41K+2(2),WPLACE
         MVZ    CP41K+2(1),VPLACE
         B      CP41X
*
CP41M    AH     R7,ONEENTRY
         MVC    CP41K+2(2),CP41W       UPDATE GENERATED CODE
CP41X    BAL    R2,GENTXT4             GENERATE 4 BYTES
CP41K    L      R0,0                   *** GENERATED CODE ***
         BR     R5                     RETURN TO SUBSTART
*
CP41Z    DC     X'1E1F2E170629'
CP41Q    DC     F'0'                   SAVE AREA FOR R9
CP41W    DC     X'8004'                CODE UPDATES
CP41L    DC     X'A003'                CODE UPDATES
*
***********************************************************************
*
*        END OF SOURCE RECOVERED FROM DISASMBLY
*
***********************************************************************
*
./ ADD NAME=IEX50002 0201-12230-12230-1200-01218-01218-00000-LEVEL
         TITLE  'IEX50002 - CP6, CP40, CP43, CP45, CP47, CP49, CP81'
*
***********************************************************************
*
*        THIS SOURCE FOR IEX50002 WAS RECOVERED BY DISASSEMBLY OF
*        THE CSECT IEX50002 IN LOAD MODULE IEX50
*
***********************************************************************
*
IEX50000 CSECT
*
*        NOTE -
*        ALL THE CP PROGRAMS IN THIS CSECT IEX50002 ESTABLISH
*        ADDRESSABILITY FOR BASE (R12) FROM THE FIRST CP IN THE
*        CSECT WHICH IS CP6
*        ALL SUBSEQUENT CPS OTHER THAN CP6 RESET BASE BACK TO
*        CP6 BY LOADING R12. THIS IS ONLY DONE IN IEX50002, NO
*        OTHER MODULES USE THIS TECHNIQUE
*        ROUTINES AND DATA AREAS ARE SHARED ACROSS ALL THE CPS
*        IN THIS CSECT WITH BRANCHES INTO AND OUT OF THE CPS
*
***********************************************************************
*
*        COMPILER PROGRAM - CP6
*
***********************************************************************
*
         CNOP   0,8
         USING  CP6,R12
CP6      TM     COMPFLGS,OPERAND
         BZ     CP6A
         BAL    R4,SERR4
         DC     H'164'                 ERROR 164
*
         LA     R9,5(,R9)
CP6A     BAL    R4,MOVEOPTK
         MVC    0(1,R10),0(R8)
         LA     R11,290(R11)
CP6B     CLI    0(R10),X'18'
         BNER   R5                     ¬=, RETURN TO SUBSTART
         SH     R9,KH10
         BAL    R4,MOVEOPDK
         SR     R1,R1
         IC     R1,CFSN
         STC    R1,0(R9)
         LA     R1,1(R1)
         STC    R1,CFSN
         IC     R1,SYSIN+95(R1)
         STC    R1,1(R9)
         BR     R5                     RETURN TO SUBSTART
*
***********************************************************************
*
*        COMPILER PROGRAM - CP40
*
***********************************************************************
*
CP40     L      R12,SCPTAB+4*6         R12 -> CP6
         LA     R4,CP40A
         BAL    R3,OPDTEST
         TM     0(R9),X'08'
         BO     CP40B
         TM     1(R9),X'C0'
         BZ     CP40C
         TM     0(R9),X'10'
         BO     CP40C
CP40B    BAL    R4,SERR1
         DC     H'190'                 ERROR 190
*
CP40E    MVC    0(5,R9),API
CP40C    BAL    R4,TARITHM
         B      CP40A                  +00 NO ERROR
         B      CP40E                  +04 ERROR 163
*
CP40A    BAL    R4,MOVEOPTK
         MVI    0(R10),X'2D'
         TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?
         BOR    R5                     YES, RETURN TO SUBSTART
         TM     1(R9),X'30'
         BNM    CP40F
         TM     1(R9),X'20'
         BO     CP40F
         BAL    R4,ROUTINE1
         LH     R1,WPLACE
         LA     R1,4(R1)
         STH    R1,CP40G+2
         MVZ    CP40G+2(1),VPLACE
         LA     R2,CP40G
         BAL    R14,GENTXTS
         DC     H'8'                   GENERATE 8 BYTES
*
         BAL    R4,OPDREC
         MVC    2(1,R9),SPBNST+1
CP40F    BAL    R4,CLEARRG
         BAL    R4,CP40H
         MVC    7(2,R9),9(R9)
CP40I    BAL    R4,CP40H
         AH     R7,ONEENTRY
         STH    R7,WORKPL
         MVC    11(2,R9),WORKPL
         TM     6(R9),X'0C'
         BZ     CP40J
CP40K    L      R1,AOPTABE
         CLC    0(1,R1),5(R9)
         BH     CP40M
         BE     CP40L
         BAL    R4,NXTOPT
         B      CP40K
*
CP40L    OI     6(R9),X'02'
         MVI    WA2_B,X'00'
         MVC    WA2_C,ZEROHW
         BAL    R14,CP40Q
CP40M    TM     6(R9),X'08'
         BO     CP40R
         B      CP40S
*
CP40R    AH     R7,ONEENTRY
         STH    R7,WORKPL
         TM     6(R9),X'F0'
         BZ     CP40T
         BO     CP40U
         AH     R7,ONEENTRY
CP40U    STH    R7,WORKPL+2
CP40V    MVC    13(4,R9),WORKPL
         BO     CP40W
         AH     R7,ONEENTRY
CP40S    TM     6(R9),X'02'
         BZ     CP40W
         AH     R7,ONEENTRY
         STH    R7,WORKPL
         MVC    17(2,R9),WORKPL
         BAL    R14,CP40X
CP40W    ST     R6,WA2_A+2
         B      CP40J
*
CP40T    EX     R0,CP40V
         MVI    18(R9),0
CP40J    STH    R7,WORKPL
         BAL    R4,MAXCH
         BR     R5
*
CP40G    TM     0(R10),X'08'           *** GENERATED CODE ***
         BO     548(R13)               *** GENERATED CODE ***
*
***********************************************************************
*
*        COMPILER PROGRAM - CP43
*
***********************************************************************
*
CP43     L      R12,SCPTAB+4*6         R12 -> CP6
         LA     R4,CP43A
         BAL    R3,OPDTEST
         BAL    R4,TARITHM
         B      CP43B                  +00
         B      CP43A                  +04 ERROR
*
CP43B    TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?
         BO     CP43A                  YES, BRANCH
         LR     R1,R10
         BCTR   R1,R0
         CLI    0(R1),X'18'
         BNE    CP43C
         TM     11(R9),X'F2'
         BZ     CP43D
CP43C    L      R1,CP43E
         L      R12,SCPTAB+4*20        R12 -> CP20
         MVI    0(R10),X'16'
         BR     R1
*
DJH1E43  LA     R10,1(R10)             ENTRY FROM CP20 VIA ADCON
         MVI    0(R10),X'2D'
         TM     0(R9),X'80'
         BO     CP43F
         AH     R7,ONEENTRY
CP43F    CLI    0(R8),X'1C'
         BE     CP43G
         CLI    0(R8),X'19'
         BE     CP43H
         CLI    0(R8),X'1B'
         BE     CP43P
         OI     6(R9),X'01'
         MVC    CP43I+2(2),7(R9)
         BAL    R2,GENTXT4
CP43I    L      R15,0(R12)             *** GENERATED CODE ***
         TM     6(R9),X'F0'
         BZ     CP43J
         BAL    R14,CP43K
         MVC    CP43L1+2(2),11(R9)
         LA     R2,CP43L
         BAL    R14,GENTXTS
         DC     H'12'                  GENERATE 12 BYTES
*
         TM     6(R9),X'02'
         BZ     CP43M
         BAL    R14,CP40X
CP43M    ST     R6,WA2_A+2
         B      CP43N
*
CP43K    TM     6(R9),X'0A'
         BNOR   R14
         MVC    CP43Q+2(2),13(R9)
         BAL    R2,GENTXT6
         SR     R14,R14                *** GENERATED CODE ***
CP43Q    ST     R14,0(R10)             *** GENERATED CODE ***
         BR     R14
*
CP43J    LA     R14,CP43R
CP43S    TM     6(R9),X'08'
         BZR    R14
         BAL    R2,GENTXT4
         LA     R0,1                   *** GENERATED CODE ***
         B      CP43K
*
CP43R    BAL    R2,GENTXT2
         BALR   R15,R15                *** GENERATED CODE ***
         B      CP43N
*
CP43H    TM     6(R9),X'F0'
         BNO    CP43N
         MVC    CP43T+2(2),11(R9)
         LA     R2,CP43U
         BAL    R14,GENTXTS
         DC     H'10'                  GENERATE 10 BYTES
*
         MVI    GPBN+1,X'FF'
         B      CP43N
*
CP43U    BALR   R14,R0                 *** GENERATED CODE ***
         LA     R14,8(R14)             *** GENERATED CODE ***
CP43T    ST     R14,0(R10)             *** GENERATED CODE ***
*
CP43P    BAL    R4,CP40H
         A      R1,LATAB
         MVC    0(4,R1),WA2_A+2
         MVC    CP43V+2(2),11(R9)
         MVC    CP43V+4(2),9(R9)
         OI     CP43V+4,X'C0'
         OI     CP43V+2,X'A0'
         BAL    R2,GENTXT6             GENERATE 6 BYTES
CP43V    MVC    0(4,R10),0(R12)        *** GENERATED CODE ***
         BAL    R14,CP43K
         B      CP43N
*
CP43G    TM     6(R9),X'01'
         BO     CP43W
         CLC    LN(2),9(R9)
         BNE    CP43N
         LH     R1,LN
         SH     R1,KH8
         STH    R1,LN
         B      CP43N
*
CP43W    TM     6(R9),X'F0'
         LA     R10,1(R10)
         LA     R14,CP43X
         BZ     CP43S
         BAL    R14,CP43K
         BAL    R4,CP43Y
         STH    R1,CP43Z+4
         OI     CP43Z+4,X'C0'
         MVC    CP43Z+2(2),11(R9)
         OI     CP43Z+2,X'A0'
         BAL    R2,GENTXT6             GENERATE 6 BYTES
CP43Z    MVC    0(4,R10),0(R12)        *** GENERATED CODE ***
         B      CP49_X
*
CP43D    TM     11(R9),X'08'
         BZ     CP43C
         MVC    5(5,R9),0(R9)
         LA     R9,5(R9)
         B      CP43F
*
CP43L    BALR   R14,R0                 *** GENERATED CODE ***
         LA     R14,10(R14)            *** GENERATED CODE ***
CP43L1   ST     R14,0(R10)             *** GENERATED CODE ***
         BR     R15
*
CP43E    DC     A(BIC2)                INTERNAL ENTRY TO CP20
*
***********************************************************************
*
*        COMPILER PROGRAM - CP45
*
***********************************************************************
*
CP45     L      R12,SCPTAB+4*6         R12 -> CP6
         LA     R4,CP45A
         BAL    R3,OPDTEST
         BAL    R4,TARITHM
         B      CP45B                  +00
         B      CP45A                  +04 ERROR
*
CP45B    TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?
         BO     CP45A                  YES, BRANCH
         BAL    R4,OPDREC
         TM     11(R9),X'F0'
         BZ     CP45A
         TM     1(R9),X'02'
         BO     CP45C
         BAL    R4,CP45D
         BAL    R2,GENTXT4             GENERATE 4 BYTES
         L      R14,0                  *** GENERATED CODE ***
         MVI    CP45F+1,X'EE'
         BAL    R2,GENTXT2             GENERATE 2 BYTES
CP45F    LTR    R14,R0                 *** GENERATED CODE ***
CP45G    MVC    CP45H+2(2),20(R9)
         TM     11(R9),X'F0'
         BM     CP45K
         LA     R9,5(R9)
         BAL    R4,CP40H
         SH     R9,KH5
         MVC    CP45I+2(2),14(R9)
         MVC    CP45J+2(2),16(R9)
         OI     CP45J+2,X'A0'
         LA     R2,CP45L
         BAL    R14,GENTXTS            GENERATE 28 BYTES
         DC     H'28'
*
CP45M    TM     1(R9),X'02'
         BO     CP45N
         TM     6(R9),X'02'
         BZ     CP45P
         BAL    R2,GENTXT4             GENERATE 4 BYTES
         BAL    R8,288(R13,0)          *** GENERATED CODE ***
CP45N    TM     6(R9),X'02'
         BZ     CP45Q
         TM     11(R9),X'F0'
         BM     CP45R
CP45S    BAL    R4,CP45T
         BAL    R2,GENTXTP4            GENERATE 4 BYTES
CP45U    AD     R0,0                   *** GENERATED CODE ***
         MVC    CP45V+2(2),CP45U+2
         BAL    R2,GENTXTP4            GENERATE 4 BYTES
CP45V    STD    R0,0                   *** GENERATED CODE ***
CP45W    TM     11(R9),X'F0'
         BM     CP45X
         MVC    CP45XA+2(2),16(R9)     UPDATE GENERATED CODE
         BAL    R2,GENTXT6             GENERATE 6 BYTES
CP45XA   L      R15,0(R10)             *** GENERATED CODE ***
         BR     R15
*
         MVC    WORKPL(2),14(R9)
         BAL    R4,CP45XB
         MVI    GPBN+1,X'FF'
         B      CP45A
*
CP45Q    BAL    R2,GENTXT4             GENERATE 4 BYTES
         BAL    R8,332(R13,0)          *** GENERATED CODE ***
CP45P    TM     11(R9),X'F0'
         BM     CP45XC
CP45XD   BAL    R4,CP45T
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP45XF   A      R14,0                  *** GENERATED CODE ***
         MVC    CP45XG+2(2),CP45XF+2
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP45XG   ST     R14,0                  *** GENERATED CODE ***
         B      CP45W
*
CP45C    BAL    R4,CP45D
         BAL    R2,GENTXTP4            GENERATE 4 BYTES
         LD     R0,0                   *** GENERATED CODE ***
         MVI    CP45XH+1,0
         BAL    R2,GENTXTP2            GENERATE 2 BYTES
CP45XH   LTDR   R0,R0                  *** GENERATED CODE ***
         B      CP45G
*
CP45K    TM     11(R9),X'20'
         BO     CP45XI
         BAL    R2,GENTXT6             GENERATE 6 BYTES
         BZ     528(R13)               *** GENERATED CODE ***
         BALR   R15,R0                 *** GENERATED CODE ***
         LA     R2,CP45XJ
         BAL    R14,GENTXTS            GENERATE 8 BYTES
         DC     H'8'
*
         B      CP45M
*
CP45XI   LA     R2,CP45L
         BAL    R14,GENTXTS            GENERATE 18 BYTES
         DC     H'18'
*
         B      CP45M
*
CP45R    MVC    CP45XK+2(2),18(R9)
         BAL    R2,GENTXTP4            GENERATE 4 BYTES
CP45XK   STD    R0,0(R10)              *** GENERATED CODE ***
         B      CP45A
*
CP45XC   MVC    CP45XL+2(2),18(R9)
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP45XL   ST     R14,0(R10)             *** GENERATED CODE ***
         B      CP45A
*
CP45L    BALR   R15,R0                 *** GENERATED CODE ***
         BNZ    8(R15)                 *** GENERATED CODE ***
         SR     R15,R15                *** GENERATED CODE ***
         BCTR   R15,R0                 *** GENERATED CODE ***
CP45XJ   SLL    R15,1                  *** GENERATED CODE ***
CP45H    ST     R15,0(R10)             *** GENERATED CODE ***
CP45I    L      R15,0(R12)             *** GENERATED CODE ***
CP45J    XI     0(R10),X'80'           *** GENERATED CODE ***
         BMR    R15                    *** GENERATED CODE ***
*
***********************************************************************
*
*        COMPILER PROGRAM - CP47
*
***********************************************************************
*
CP47     L      R12,SCPTAB+4*6         R12 -> CP6
         LA     R4,CP47A
         BAL    R3,OPDTEST
         BAL    R4,TARITHM
         B      CP47B                  +00
         B      CP47A                  +04 ERROR
*
CP47B    TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?
         BO     CP47A                  YES, BRANCH
         TM     16(R9),X'F0'
         BZ     CP47C
         BAL    R4,OPDREC
         CLI    0(R8),X'1C'
         BNE    CP47D
         TM     16(R9),X'02'
         BO     CP47D
         MVC    CP47E+2(2),25(R9)      UPDATE GENERATED CODE
         OI     CP47E+2,X'A0'
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP47E    XI     0(R10),X'E0'           *** GENERATED CODE ***
CP47D    TM     16(R9),X'F0'
         BM     CP47F
         LA     R9,5(R9)
         TM     6(R9),X'02'
         BO     CP47G
         BAL    R4,CP45T
         BAL    R2,GENTXT4             GENERATE 4 BYTES
         L      R14,0                  *** GENERATED CODE ***
CP45X    SH     R9,KH5
         TM     1(R9),X'02'
         BO     CP47GA
         BAL    R4,CP45D
         BAL    R2,GENTXT4             GENERATE 4 BYTES
         C      R14,0                  *** GENERATED CODE ***
         B      CP47H
*
         BAL    R2,GENTXT2             GENERATE 2 BYTES
         CR     R14,R0                 *** GENERATED CODE ***
CP47H    MVC    CP47I+2(2),25(R9)
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP47I    IC     R8,0(R10)              *** GENERATED CODE ***
         LA     R9,5(R9)
         B      CP47J
*
CP47GA   TM     0(R9),X'40'
         BO     CP47K
         BAL    R4,CP45D
         BAL    R2,GENTXTP4            GENERATE 4 BYTES
         LD     R2,0                   *** GENERATED CODE ***
         B      CP47L
*
         BAL    R2,GENTXTP2            GENERATE 2 BYTES
         LDR    R2,R0                  *** GENERATED CODE ***
CP47L    BAL    R2,GENTXT4             GENERATE 4 BYTES
         BAL    R8,288(R13)            *** GENERATED CODE ***
         BAL    R2,GENTXTP2            GENERATE 2 BYTES
         CDR    R0,R2                  *** GENERATED CODE ***
         B      CP47H
*
CP47G    BAL    R4,CP45T
         BAL    R2,GENTXTP4            GENERATE 4 BYTES
         LD     R6,0                   *** GENERATED CODE ***
         SH     R9,KH5
         TM     1(R9),X'02'
         BO     CP47M
         BAL    R4,TRINRE
CP47M    BAL    R4,CP45D
         BAL    R2,GENTXTP4            GENERATE 4 BYTES
         CD     R6,0                   *** GENERATED CODE ***
         B      CP47H
*
         BAL    R2,GENTXTP2            GENERATE 4 BYTES
         CDR    R6,R0                  *** GENERATED CODE ***
         B      CP47H
*
CP47F    MVC    CP47N+2(2),25(R9)
         LH     R1,ONEENTRY
         AH     R1,CP47N+2
         STH    R1,CP47N+2
         TM     1(R9),X'02'
         BO     CP47P
         TM     11(R9),X'02'
         BZ     CP47P
         BAL    R4,TRINRE
CP47P    BAL    R4,CP45D
         B      CP47Q
*
         DC     X'0000'
CP47R    DC     X'0000'
         NOP    0
         B      CP47S
*
         DC     X'0000'
*
CP47S    TM     1(R9),X'02'
         MVZ    CP47N+1(1),3(R9)
         BO     CP47T
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP47N    ST     R0,0(R10)              *** GENERATED CODE ***
CP47U    MVI    0(R9),X'C0'
         MVC    3(2,R9),CP47N+2
         MVC    2(1,R9),SPBNST+1
         MVI    GPBN+1,X'FF'
         LA     R9,5(R9)
         TM     6(R9),X'02'
         BO     CP47V
         BAL    R4,CP45T
         BAL    R2,GENTXT4             GENERATE 4 BYTES
         L      R14,0                  *** GENERATED CODE ***
CP47W    LA     R1,12
         TM     GPBN+1,X'FF'
         BO     CP47Y
         LA     R1,4(R1)
         MVI    GPBN+1,X'FF'
CP47Y    LA     R2,CP47ZB
         STH    R1,CP47ZA+2
         MVC    CP47ZC+2(2),16(R9)
         BAL    R14,GENTXTS            GENERATE 14 BYTES
         DC     H'14'
*
         TM     6(R9),X'02'
         BO     CP47ZD
         MVC    CP47ZE+2(2),18(R9)
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP47ZE   L      R14,0(R10)             *** GENERATED CODE ***
         B      CP45XD
*
CP47ZD   MVC    CP47ZF+2(2),18(R9)
CP47ZG   BAL    R2,GENTXTP4            GENERATE 4 BYTES
CP47ZF   LD     R0,0(R10)              *** GENERATED CODE ***
         B      CP45S
*
CP47V    BAL    R4,CP45T
         BAL    R2,GENTXTP4            GENERATE 4 BYTES
         LD     R0,0                   *** GENERATED CODE ***
         B      CP47W
*
CP47T    MVC    CP47ZH+1(3),CP47N+1
         BAL    R2,GENTXTP4            GENERATE 4 BYTES
CP47ZH   STD    R0,0(R10)              *** GENERATED CODE ***
         B      CP47U
*
CP47Q    LH     R1,ONEENTRY
         BCTR   R1,R0
         STC    R1,CP47ZI+1
         MVC    CP47ZI+4(2),CP47R
         MVC    CP47ZI+2(2),CP47N+2
         OI     CP47ZI+2,X'A0'
         BAL    R2,GENTXT6             GENERATE 6 BYTES
CP47ZI   MVC    0(1,R10),0             *** GENERATED CODE ***
         B      CP47U
*
CP47K    TM     11(R9),X'02'
         BO     CP47ZJ
         BAL    R2,GENTXT4             GENERATE 4 BYTES
         BAL    R8,288(R13)            *** GENERATED CODE ***
CP47ZJ   BAL    R4,CP45D
         BAL    R2,GENTXTP4            GENERATE 4 BYTES
         CD     R0,0                   *** GENERATED CODE ***
         B      CP47H
*
CP47ZB   BALR   R15,R0                 *** GENERATED CODE ***
         LA     R15,12(R15)            *** GENERATED CODE ***
CP47ZC   ST     R15,0(R10)             *** GENERATED CODE ***
CP47ZA   B      0(R15)                 *** GENERATED CODE ***
*
CP47C    LA     R9,5(R9)
         MVI    CP47ZK+1,X'70'
         MVI    CP47ZL+1,X'E7'
         BAL    R4,CP45D
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP47ZK   L      R0,0                   *** GENERATED CODE ***
         B      CP47ZM
*
CP47ZM   BAL    R2,GENTXT2             GENERATE 2 BYTES
CP47ZL   LTR    R14,R0                 *** GENERATED CODE ***
         TM     COMPFLGS+2,NOTEST
         BO     CP47ZN
         BAL    R2,GENTXT4             GENERATE 4 BYTES
         BZ     528(R13)               *** GENERATED CODE ***
CP47ZN   TM     11(R9),X'02'
         BZ     CP47ZP
         MVC    CP47ZQ+2(2),18(R9)
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP47ZQ   ST     R14,0(R10)             *** GENERATED CODE ***
CP47ZP   SH     R9,KH5
         BAL    R4,CP45D
         BAL    R2,GENTXT4             GENERATE 4 BYTES
         A      R14,0                  *** GENERATED CODE ***
         B      CP47ZR
*
         BAL    R2,GENTXT2             GENERATE 2 BYTES
         AR     R14,R0                 *** GENERATED CODE ***
CP47ZR   LA     R9,10(R9)
         BAL    R4,CP45D
         BAL    R2,GENTXT4             GENERATE 4 BYTES
         S      R14,0                  *** GENERATED CODE ***
         B      CP47ZS
*
         BAL    R2,GENTXT2             GENERATE 2 BYTES
         SR     R14,R0                 *** GENERATED CODE ***
CP47ZS   MVC    CP47ZT+1(1),CP47ZL+1
         BAL    R2,GENTXT6             GENERATE 6 BYTES
         SRDA   R14,32                 *** GENERATED CODE ***
CP47ZT   DR     R14,R0                 *** GENERATED CODE ***
         BAL    R2,GENTXT2             GENERATE 2 BYTES
         LR     R0,R15                 *** GENERATED CODE ***
         CLI    0(R8),X'1C'
         BE     CP43X
         OI     6(R9),X'01'
         MVC    CP47ZU+2(2),7(R9)
         BAL    R2,GENTXT6             GENERATE 6 BYTES
CP47ZU   L      R15,0(R12)             *** GENERATED CODE ***
         BALR   R15,R15                *** GENERATED CODE ***
         B      CP47ZW
*
CP43X    BAL    R4,CP43Y
         STH    R1,CP47ZV+2
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP47ZV   L      R15,0(R12)             *** GENERATED CODE ***
         MVC    WORKPL(2),7(R9)
         BAL    R4,CP45XB
         MVC    CP47YA+2(2),11(R9)
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP47YA   ST     R15,0(R10)             *** GENERATED CODE ***
         TM     6(R9),X'08'
         BZ     CP47ZW
         BAL    R4,ROUTINE7
         STH    R7,SPBNST+2
         MVC    17(3,R9),SPBNST+1
         MVC    15(2,R9),CP47YB
         BAL    R2,GENTXT4             GENERATE 4 BYTES
         LTR    R0,R0                  *** GENERATED CODE ***
         BNPR   R15                    *** GENERATED CODE ***
         TM     6(R9),X'02'
         MVI    CP47YC,X'10'
         BO     CP47YD
CP47YE   BAL    R4,CP40H
         BAL    R4,CP47YF
CP47YG   LA     R1,15(R9)
         ST     R1,RUTI
         B      CP47ZW
*
CP47YH   BAL    R4,CP40H
         STH    R1,CP47YI+2            UPDATE GENERATED CODE
         BAL    R2,GENTXT6             GENERATE 6 BYTES
CP47YI   L      R15,0(R12)             *** GENERATED CODE ***
         BR     R15                    *** GENERATED CODE ***
*
         BAL    R4,CP40H
         BAL    R4,CP47YF
         B      CP47YJ
*
CP47YK   L      R1,LATAB
         AH     R1,CP47YI+2
         ST     R6,0(R1)
         B      CP47YG
*
***********************************************************************
*
*        COMPILER PROGRAM - CP49
*
***********************************************************************
*
CP49     L      R12,SCPTAB+4*6         R12 -> CP6
         LA     R4,CP49A
         BAL    R3,OPDTEST
         BAL    R4,ARRTEST1
         TM     1(R9),X'03'
         BO     CP49B
         BAL    R4,SERR2
         DC     H'182'                 ERROR 182
*
         B      CP49A
*
CP49B    TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?
         BO     CP49A                  YES, BRANCH
         BAL    R4,OPDREC
         BAL    R4,CP45D
         BAL    R2,GENTXT4             GENERATE 4 BYTES
         TM     0,X'01'                *** GENERATED CODE ***
CP47J    LA     R9,5(R9)
         TM     6(R9),X'02'
         BZ     CP49C
         MVC    CP49D+2(2),17(R9)
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP49D    L      R15,0(R10)             *** GENERATED CODE ***
         CLI    0(R10),X'1B'
         BE     CP49E
         BAL    R2,GENTXT4             GENERATE 4 BYTES
         EX     R8,274(R13)            *** GENERATED CODE ***
         B      CP49F
*
CP49E    BAL    R2,GENTXT2             GENERATE 2 BYTES
         BOR    R15                    *** GENERATED CODE ***
CP49F    CLI    0(R8),X'1C'
         BNE    CP49H
         BAL    R4,CP43Y
         STH    R1,CP49G+2
         BAL    R2,GENTXT6             GENERATE 6 BYTES
CP49G    L      R15,0(R12)             *** GENERATED CODE ***
         BR     R15                    *** GENERATED CODE ***
*
         B      CP49_X
*
CP49H    BAL    R14,CP40X
CP49I    ST     R6,WA2_A+2
         OI     6(R9),X'01'
         B      CP47ZW
*
CP49C    CLI    0(R8),X'1C'
         BE     CP49J
         MVC    CP49K+2(2),7(R9)
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP49K    L      R15,0(R12)             *** GENERATED CODE ***
         CLI    0(R10),X'1B'
         BE     CP49L
         BAL    R2,GENTXT4             GENERATE 4 BYTES
         EX     R8,274(R13)            *** GENERATED CODE ***
         B      CP49M
*
CP49L    BAL    R2,GENTXT2             GENERATE 2 BYTES
         BOR    R15                    *** GENERATED CODE ***
CP49M    B      CP49I
*
CP49J    BAL    R4,CP43Y
         STH    R1,CP49N+2
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP49N    L      R15,0(R12)             *** GENERATED CODE ***
         CLI    0(R10),X'1B'
         BE     CP49P
         BAL    R2,GENTXT4             GENERATE 4 BYTES
         EX     R8,274(R13)            *** GENERATED CODE ***
         B      CP49_X
*
CP49P    BAL    R2,GENTXT2             GENERATE 2 BYTES
         BER    R15                    *** GENERATED CODE ***
CP49_X   MVC    WORKPL(2),7(R9)
         BAL    R4,CP45XB
         TM     6(R9),X'02'
         BZ     CP47ZW
         MVI    CP47YC,X'00'
         B      CP47YD
*
CP49Q    MVC    CP49R+2(2),17(R9)
         LA     R2,CP49S
         TM     WA2_B,X'01'
         BO     CP49T
         MVI    CP49U+3,X'08'          UPDATE GENERATED CODE
         BAL    R14,GENTXTS            GENERATE 10 BYTES
         DC     H'10'
*
         B      CP47ZW
*
CP49T    BAL    R4,CP40H
         STH    R1,CP49V+2
         MVI    CP49U+3,X'0E'
         BAL    R14,GENTXTS            GENERATE 16 BYTES
         DC     H'16'
*
         B      CP47YJ
*
CP49W    BAL    R4,CP47YF
         B      CP47ZW
*
CP49S    BALR   R14,R0                 *** GENERATED CODE ***
CP49U    LA     R14,0(R14)             *** GENERATED CODE ***
CP49R    ST     R14,0(R10)             *** GENERATED CODE ***
CP49V    L      R15,0(R12)             *** GENERATED CODE ***
         BR     R15                    *** GENERATED CODE ***
*
***********************************************************************
*
*        COMPILER PROGRAM - CP81
*
***********************************************************************
*
CP81     L      R12,SCPTAB+4*6         R12 -> CP6
         TM     COMPFLGS,OPERAND
         BO     CP81A
CP81B    TM     COMPFLGS,COMPMODE      SYNTAX CHECK MODE ?
         BZ     CP81C                  NO, BRANCH
CP81D    BCTR   R10,R0
         SR     R1,R1
         TM     6(R9),X'02'
         BZ     CP81E
         MVC    WORKPL(2),23(R9)
         LH     R1,WORKPL
CP81E    LA     R9,20(R1,R9)
         MVI    GPBN+1,X'FF'
         BR     R5                     RETURN TO SUBSTART
*
CP81A    BAL    R4,PLPRST
         LA     R9,5(R9)
         B      CP81B
*
CP81C    MVC    WORKPL(2),11(R9)
         LH     R7,WORKPL
         SH     R7,ONEENTRY
         TM     0(R9),X'20'
         BZ     CP81F
         SH     R7,ONEENTRY
CP81F    TM     6(R9),X'02'
         BZ     CP81G
         LA     R1,CBVTAB+39           ### CHECK ###
         L      R2,SUTABCA
CP81H    CR     R1,R2
         BE     CP81I
         CLC    0(1,R2),5(R9)
         BL     CP81I
         SH     R2,KH9
         B      CP81H
*
CP81I    ST     R2,SUTABCA
         MVI    CP81J+1,X'0A'
         TM     6(R9),X'F0'
         BNZ    CP81K
         MVI    CP81J+1,X'1A'
CP81K    MVC    WORKPL(2),23(R9)
         LH     R14,WORKPL
         LA     R14,20(R14,R9)
         TM     6(R9),X'04'
         BO     CP81G
CP81L    SH     R14,KH5
         TM     2(R14),X'FF'
         BZ     CP81G
         TM     CP81J+1,X'70'
         BNO    CP81M
         LA     R14,25(R9)
CP81M    TM     0(R14),X'40'
         BZ     CP81N
         MVC    CP81J+2(2),3(R14)
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP81J    L      R0,0(R10)              *** GENERATED CODE ***
CP81N    LH     R1,CP81J
         LA     R1,16(R1)
         STH    R1,CP81J
         B      CP81L
*
CP81G    MVI    CII+1,X'07'
         MVC    RII(2),ZEROHW
         TM     6(R9),X'08'
         BO     CP81P
         TM     6(R9),X'05'
         BZ     CP81D
CP81Q    MVC    CP81R+2(2),11(R9)
         BAL    R2,GENTXT6             GENERATE 6 BYTES
CP81R    L      R15,0(R10)             *** GENERATED CODE ***
         BR     R15                    *** GENERATED CODE ***
*
         BAL    R4,CP43Y
         BAL    R4,CP81S
         B      CP81D
*
CP81P    TM     6(R9),X'F0'
         BNZ    CP81Q
         TM     15(R9),X'40'
         BZ     CP81T
         MVC    CP81U+2(2),18(R9)
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP81U    L      R0,0(R10)              *** GENERATED CODE ***
CP81T    MVC    CP81UA+2(2),9(R9)
         BAL    R2,GENTXT6             GENERATE 6 BYTES
CP81UA   L      R15,0(R12)             *** GENERATED CODE ***
         BCTR   R0,R15                 *** GENERATED CODE ***
         B      CP81Q
*
CP47YB   DC     X'8031'
CP43A    LA     R9,5(R9)
         B      CP43N
*
CP47A    LA     R9,5(R9)
CP49A    LA     R9,5(R9)
CP47ZW   BCTR   R10,R0
CP43N    CLI    0(R8),X'25'
         BNE    CP81WA
         MVI    GPBN+1,X'FF'
         BR     R5                     RETURN
*
CP81WA   CLI    0(R8),X'1C'
         BNE    CP81WB
         MVI    GPBN+1,X'FF'
         SH     R11,KH290
         BCTR   R10,R0
CP45A    BCTR   R10,R0
CP81WB   LA     R10,1(R10)
         MVC    0(1,R10),0(R8)
         BR     R5
*
CP47YF   MVC    WORKPL(2),9(R9)
CP45XB   LH     R1,WORKPL
CP81S    A      R1,LATAB
         ST     R6,0(R1)
         BR     R4
CP40H    ST     R4,CP81SA
         BAL    R4,LATRES
         MVC    9(2,R9),LN
         L      R4,CP81SA
         BR     R4
*
CP43Y    MVC    WORKPL(2),7(R9)
         LH     R1,WORKPL
         LA     R1,4(R1)
         BR     R4
*
CP40X    MVC    CP81WE+2(2),17(R9)
         MVC    CP81WE+4(2),7(R9)
         OI     CP81WE+2,X'A0'
         OI     CP81WE+4,X'C0'
         BAL    R2,GENTXT6             GENERATE 6 BYTES
CP81WE   MVC    0(4,R10),0(R12)        *** GENERATED CODE ***
         BR     R14
*
CP45T    LA     R9,5(R9)
         ST     R4,CP81SA
         TM     0(R9),X'20'
         BO     CP81WF
         BAL    R4,ROUTINE1
         B      CP81WG
*
CP81WF   BAL    R4,ROUTINE3
         AH     R7,ONEENTRY
CP81WG   SH     R9,KH5
CP81WH   L      R4,CP81SA
         MVC    6(2,R4),WPLACE
         MVZ    6(1,R4),VPLACE
         BR     R4
*
CP81SA   DC     F'0'                    SAVEAREA FOR R4
*
CP45D    ST     R4,CP81SA
         LA     R4,CP81WH
         BAL    R3,ROUTIN15
         L      R4,CP81SA
         LA     R4,12(R4)
         MVN    5(1,R4),VPLACE
         TM     1(R9),X'02'
         BO     ROUTIN12
         B      ROUTINE8
*
CP81WI   BAL    R4,NXTOPT
CP47YD   MVI    GPBN+1,X'FF'
         L      R2,AOPTABE
         CLC    5(1,R9),0(R2)
         BE     CP81WJ
         OI     20(R9),X'01'
         B      CP81WK
*
CP81WJ   MVZ    2(1,R2),CP81WL
         LA     R1,CBVTAB+39
CP81WM   LA     R1,9(R1)
         C      R1,SUTABCA
         BH     CP81WN
         CLC    11(3,R2),1(R1)
         BNE    CP81WM
         CLC    0(1,R2),0(R1)
         BNE    CP81WP
CP81WQ   MVN    CP81WL(1),10(R2)
         SR     R3,R3
         IC     R3,CP81WL
         L      R4,CP81WR
         SRL    R4,0(R3)
         STH    R4,WORKPL
         OC     7(2,R1),WORKPL
         SLL    R3,2
         LA     R3,20(R3)
         AH     R3,2(R2)
         STH    R3,2(R2)
         BAL    R3,CP81WS
         DC     H'7'
*
         AR     R1,R11
*
CP47YC   DC     X'0040'
         CLC    ZEROHW(2),5(R2)
         BE     CP81WI
         TM     25(R9),X'02'
         BZ     CP81WT
         BAL    R3,CP81WS
*
         DC     X'0004'
         AR     R1,R11
*
         DC     X'8080'
*
         B      CP81WI
*
CP81WT   OI     25(R9),X'02'
         TM     10(R2),X'80'
         BZ     CP81WU
         BAL    R2,GENTXT2             GENERATE 2 BYTES
         SR     R8,R8                  *** GENERATED CODE ***
         L      R2,CP81WV
CP81WU   BAL    R3,CP81WS
*
         DC     X'0004'
*
         LR     R1,R11
*
         DC     X'8080'
*
         B      CP81WI
*
CP81WN   LA     R3,SUTABC+L'SUTABC
         CR     R1,R3
         BNL    CP81WI
         ST     R1,SUTABCA
         MVC    1(3,R1),11(R2)
         MVC    7(2,R1),ZEROHW
         LA     R3,4
         AH     R3,2(R2)
         STH    R3,WA2_B+2
         MVC    WA2_B+1(1),1(R2)
CP81YA   MVC    0(1,R1),5(R9)
CP81WK   STM    R1,R2,CP81WV
         CLC    WA2_C,KH5
         BE     CP81YB
         TM     25(R9),X'02'
         BZ     CP81YC
         BAL    R4,ROUTINE1
         MVC    CP81YD+2(2),WPLACE
         MVZ    CP81YD+2(1),VPLACE
         MVZ    CP81YE+1(1),CP47YC
         LA     R2,CP81YF
         BAL    R14,GENTXTS            GENERATE CODE
         DC     H'8'                   GENERATE 8 BYTES
*
         TM     6(R9),X'08'
         BZ     CP81YC
         MVI    WA2_B,X'01'
         MVC    CP81YG+2(2),13(R9)
         LA     R2,CP81YH
         BAL    R14,GENTXTS            GENERATE CODE
         DC     H'10'                  GENERATE 10 BYTES
*
CP81YC   TM     6(R9),X'04'
         BO     CP81YI
CP81YB   TM     20(R9),X'01'
         BO     CP81YJ
         TM     CP47YC,X'70'
         BO     CP81YI
         BAL    R4,ROUTINE7
         SLL    R14,4
         STC    R14,CP47YC
         B      CP81YK
*
CP81YL   AH     R7,ONEENTRY
CP81YK   BAL    R14,CP40Q
         STH    R7,SPBNST+2
         MVC    27(3,R9),SPBNST+1
         MVZ    28(1,R9),CP47YC
         LA     R3,4(R7)
         STH    R3,CP81YM+2
         LA     R7,8(R7)
         SH     R7,ONEENTRY
         SR     R3,R3
         IC     R3,CP47YC
         SRL    R3,2
         LA     R4,25(R9)
         ST     R4,RUTI(R3)
         LM     R1,R2,CP81WV
         LA     R3,RUTI+1(R3)
         MVC    4(3,R1),0(R3)
         MVC    CP81YNA+1(1),CP47YC
         LR     R3,R1
         LA     R1,WA2_B+1
         BAL    R4,CP81YN
CP81YNA  L      R0,0
         LR     R1,R3
         B      CP81WQ
*
CP81YI   SR     R14,R14
         IC     R14,CP47YC
         SRL    R14,4
         BAL    R4,ROUTINE9
         TM     20(R9),X'01'
         BZ     CP81YL
CP81YJ   TM     6(R9),X'F0'
         BNZ    CP49Q
         TM     WA2_B,X'01'
         BO     CP47YH
         B      CP47YE
*
CP81YF   LR     R15,R8
CP81YD   M      R14,0
CP81YE   AR     R0,R15
CP81YH   LR     R15,R8
CP81YG   M      R14,0(R10)
CP81YM   ST     R15,0(R10)
CP81WP   MVC    WORKPL(4),3(R1)
         L      R3,WORKPL
         MVC    WA2_B+1(3),2(R3)
         B      CP81YA
*
CP40Q    BAL    R4,MOVEOPDK
         MVC    0(20,R9),5(R9)
         LH     R3,WA2_C
         LA     R3,5(R3)
         STH    R3,WA2_C
         MVC    20(5,R9),CP81YQ
         BR     R14
*
CP81YN   STM    R2,R4,CP81WV
         ST     R9,CP81YR+2
         LR     R9,R1
         SH     R9,KH2
         BAL    R4,ROUTINE1
         L      R2,CP81YS+2
         MVC    2(2,R2),WPLACE
         MVZ    2(1,R2),VPLACE
         BAL    R14,GENTXTS            GENERATE CODE
         DC     H'4'                   GENERATE 4 BYTES
*
         LM     R2,R4,CP81WV
         L      R9,CP81YR+2
         B      4(R4)
*
CP81WS   LR     R1,R2
         AH     R1,0(R3)
         CLC    ZEROHW(2),1(R1)
         BE     6(R3)
         MVC    CP81YT+1(1),5(R3)
         MVC    CP81YU(2),3(R3)
         OI     CP81YU+1,X'0F'
CP81YT   TM     10(R2),X'00'
         BO     CP81YV
         MVC    CP81YU(1),2(R3)
CP81YV   CLC    366(2,R5),1(R1)
         BE     CP81YW
         BAL    R4,CP81YN
         L      R15,0
         LA     R1,1(R2)
         BAL    R4,CP81YN
         M      R14,0
         BAL    R2,GENTXT2             GENERATE 2 BYTES
CP81YU   AR     R0,R15                 *** GENERATED CODE ***
         LM     R2,R3,CP81WV
         B      6(R3)
*
CP81YW   LA     R1,1(R2)
         MVC    CP81ZA(2),CP81YU
         OI     CP81ZA,X'40'
         NI     CP81ZA+1,X'F0'
         BAL    R4,CP81YN
CP81ZA   L      R0,0
         B      6(R3)
*
CP47YJ   MVC    WORKPL(2),23(R9)
         LH     R1,WORKPL
         LA     R1,15(R1,R9)
CP81ZB   TM     0(R1),X'02'
         BZ     CP81ZC
         ST     R1,CP81WV
         MVC    WORKPL(2),3(R1)
         NI     WORKPL,X'0F'
         LH     R2,WORKPL
         STH    R2,CP81ZD+2
         STH    R2,CP81ZE+2
         LA     R4,8(R2)
         SH     R4,ONEENTRY
         STH    R4,WORKPL
         BAL    R4,MAXCH
         LA     R2,4(R2)
         TM     0(R1),X'40'
         BO     CP81ZF
         STH    R2,CP81ZG+2
         MVZ    CP81ZG+1(1),3(R1)
         BAL    R2,GENTXT4             GENERATE 4 BYTES
CP81ZG   A      R0,0(R10)              *** GENERATED CODE ***
         B      CP81ZH
*
CP81ZF   STH    R2,CP81ZI+2
         LA     R2,CP81ZD
         BAL    R14,GENTXTS            GENERATE CODE
         DC     H'12'                  GENERATE 12 BYTES
*
CP81ZH   L      R1,CP81WV
CP81ZC   SH     R1,KH5
         TM     2(R1),X'FF'
         BNZ    CP81ZB
         TM     6(R9),X'F0'
         BZ     CP47YK
         B      CP49W
*
         DC     0F'0'
CP81ZD   L      R14,0(R10)             *** GENERATED CODE ***
CP81ZI   A      R14,0(R10)             *** GENERATED CODE ***
CP81ZE   ST     R14,0(R10)             *** GENERATED CODE ***
CP81WR   DC     X'00008000'
CP81WV   BNZ    594(,R4)               *** GENERATED CODE ***
         SR     R15,R15                *** GENERATED CODE ***
CP81YS   ST     R15,CP47ZG+2
CP81YR   L      R6,CP6B
WA2_A    MVC    0(4,R6),220(R12)
WA2_B    B      614(,R4)
CP81WL   DC     X'00'
CP81YQ   DC     X'80'                  *
         DC     X'31'                  |
         DC     X'00'                  |
WA2_C    DC     H'0'                   V
*
***********************************************************************
*
*        END OF IEX50002
*
***********************************************************************
*
./ ADD NAME=IEX50003 0201-12230-12230-1200-00582-00582-00000-LEVEL
    TITLE 'IEX50003 - CP51, CP52, CP54, CP56, CP59, CP62, CP85, CP34'
*
***********************************************************************
*
*        COMPILER PROGRAM - CP51
*
***********************************************************************
*
*   UPPER BOUND HANDLING
*        CONTEXT              STATEMENT
*        SOURCE OPERATOR      COMMA, RIGHT BRACKET
*        STACK OPERATOR
*        OPERANDS             UPPER BOUNDARY
*                             LOWER BOUNDARY IN STACK
*                             ARRAY IDENTIFIER
*
*        BIT PATTERNS
*
BOOTYPEM EQU   X'03'                   BOOLEAN TYPE MASK
REALTYPM EQU   X'02'                   REAL TYPE
*
         USING CP51,R12
CP51     LA    R4,EQD2                 RETURN IF OPERAND MISSING
         BAL   R3,OPDTEST              OPERAND TEST
         BAL   R4,TARITHM              OPERAND ARITHMETIC ?
         B     EQD1                    +00 ARITHMETIC
*
EQD2     LA    R9,5(,R9)               +04 CLOPD
EQD3     CLI   0(R8),XFRSQBR           RIGHT SQUARE BRACKET ?
         BE    EQD4                    YES, BRANCH
         BCTR  R10,R5                  CLOPT SUBSTART
EQD4     LA    R9,10(,R9)              CLEAR TWO OPERANDS
         SH    R10,KH2                 CLEAR TWO OPERATORS
         MVC   KONSUM,0(R9)            R9,= R9+C(R9)
         AH    R9,KONSUM               REMOVE STACKED ARRAY IDENTIFIER
ETB3     LA    R9,5(,R9)               CLOPD
         NI    COMPFLGS,255-OPERAND    RESET OPERAND
ETE3     CLI   1(R8),XFZETA            R8+1 = ZETA ?
         MVC   GREGN(2),ZEROHW         CLEAR COUNTER
         BL    ETF2                    LOW, OPERATOR
         BH    ETF4                    HIGH, OPERAND
         BAL   R4,JBUFFER              ZETA, CHANGE BUFFER
         B     ETE3
*
ETF2     LA    R8,1(,R8)               INCR R8
         CLI   0(R8),XFCOMMA           COMMA ?
         BNE   COMP                    NO, BRANCH
ETH2     BR    R5                      RETURN TO SUBSTART
*
ETF4     BAL   R4,SERR1
         DC    H'191'                  ERROR 191
         BR    R5                      RETURN TO SUBSTART
*
EQD1     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    EQD2                    YES, BRANCH
         BAL   R4,OPDREC               OPERAND RECOGNIZER
         TM    1(R9),X'01'             OPERAND INTEGER
         BO    EQG1                    YES
         BAL   R4,TRREIN               GENERATE A CALL TO CONVERSION
*                                      REAL INTEGER
         AH    R7,ONEENTRY             RESERVE PLACE FOR OPERAND
         STH   R7,WORKPL
         BAL   R4,MAXCH                CHECK MAX
         STH   R7,EQF2+2               INSERT DISPL IN STORE INSTRUCT
         BAL   R2,GENTXT4              GENERATE 4 BYTES
EQF2     ST    R14,0(CDSA,0)           *** GENERATED CODE ***
         MVC   0(2,R9),INTEGTYP        INTERNAL NAME, INTEGER IN STACK
         STH   R7,SPBNST+2
         MVC   2(3,R9),SPBNST+1
EQG1     BAL   R4,MOVEOPDK             RESERVE ONE OPDK ENTRY
         MVC   0(5,R9),10(R9)          MOVE LOWER BOUNDRY
         MVI   10(R9),X'C0'            ITAB IDENTIFIER
         MVI   11(R9),X'31'            INTEGER VARIABLE
         MVC   12(1,R9),SPBNST+1       CURRENT PBN AND LAST
         MVC   13(2,R9),USPEI2         ENTRY IN SMF TO OPERAND
         MVC   0(2,R10),FORMINUS       FOR.= AND - TO OPERATOR STACK
         BAL   R4,MOVEOPTK             RESERVE ONE OPTK ENTRY
         ST    R8,HHSOURCE             SAVE SOURCE POINTER
         LA    R8,HTRICK               SET R8 TO HTRICK
         LA    R11,324(,R11)           SWITCH TO EXPRESSION CONTEXT
         L     R1,ADDHZB1
         L     R12,SCPTAB+4*69         R12 -> CP69
         BR    R1                      BRANCH TO CP 69
*
*        RETURN FROM CP20 AFTER ASSIGNMENT OF UPPER-LOWER
*        BOUNDRY+1 TO SMF
*
DERE2    L     R8,HHSOURCE             RESET R8
         TM    COMPFLGS+2,NOTEST
         BO    ERE2                    NO ARRAY BOUND TEST GENERATED
*                                      TEST FOR ARRAY BOUNDRY ERROR
         BAL   R2,GENTXT4              GENERATE 4 BYTES
         BNH   ARRAYBD(,FSA)           *** GENERATED CODE ***
ERE2     LH    R1,USPEI2               COMPUTE AND
         LA    R1,4(,R1)               STORE NEXT ENTRY IN
         STH   R1,USPEI2               SMF IN USPEI2
         CLI   0(R8),XFCOMMA           MORE BOUND PAIRS LEFT IN ARRAY?
         BNE   ERE3                    NO
         MVC   0(2,R9),INTEGTYP        OPERAND INTEGER VALUE
         AH    R7,ONEENTRY
         STH   R7,SPBNST+2             CURRENT PBN AND NEXT OBJECT
         MVC   2(3,R9),SPBNST+1        TIME STACK DISPLACEMENT TO
         SH    R7,ONEENTRY             OPERAND IN STACK
         BR    R5                      SCAN TO NEXT OPERATOR
*
*        LAST BOUND PAIR IN THIS ARRAY
*
ERE3     LA    R9,5(,R9)               REMOVE ONE OPERAND
         MVI   ERJ4+3,X'01'            DETERMINE AND INSERT
         TM    1(R9),BOOTYPEM          Z=8,4 OR 1 INTO
         BO    ERJ41                   LOAD
         MVC   ERJ4+2(2),ONEENTRY      GPRA
         TM    1(R9),REALTYPM          INSTRUCTION
         BO    ERJ41
         MVI   ERJ4+3,X'04'            UPDATE GENERATED CODE
ERJ41    BAL   R2,GENTXT6              GENERATE 6 BYTES
*                                      *** GENERATED CODE ***
         SR    GPRC,GPRC               CLEAR REG
ERJ4     LA    GPRA,0(0,0)             LOAD GPRA INSTRUCTION
*                                      *** GENERATED CODE ***
         SR    R1,R1                   CALCULATE
         IC    R1,USPEI4+1             LENGTH OF SMF P-PART
         STC   R1,ESE4+1               NUMBER OF SUBSCRIPTS TO CODE
         LA    R1,1(,R1)
         SLL   R1,2                    INSERT
         BCTR  R1,0                    IN CODE FOR COPY OF
         STC   R1,ESF4+1               SMF
ESB1     LH    R1,USPEI2
         STH   R1,ESD1+2               DISP IN SMF TO INSTRUCTION
         SH    R1,KH4                  NEXT ENTRY IN SMF
         STH   R1,USPEI2               CALCULATED DOWNWARDS
         STH   R1,ESK1+2               INSERT IN CODE
         BAL   R2,GENTXT4              GENERATE 4 BYTES
ESD1     ST    GPRA,0(CDSA,0)          *** GEN CODE *** STORE OF P(4)
         LH    R1,USPEI4               REDUCE DIMENSION
         BCTR  R1,0                    COUNT
         LTR   R1,R1                   CODE FOR LAST ENTRY P(1) GEN ?
         BL    ESC2                    YES
         STH   R1,USPEI4               STORE DIMENSION VALUE
         STH   R7,ESH1+2               INSERT DISPL OF LOWER BOUND
         SH    R7,ONEENTRY             RELEASE OBJECT TIME STACK
         LA    R2,ESE1                 GENERATE CODE FOR
         BAL   R14,GENTXTS             DETERMINE OF SMF
         DC    H'12'                   GENERATE 12 BYTES
*
         B     ESB1                    CONTINUE TO NEXT ENTRY IN SMF
*
ESC2     LA    R9,5(,R9)               REMOVE ARRAY IDENTIFIER
         BCTR  R10,0                   REMOVE ARRAY OPERATOR
         MVC   USPEI4(2),0(R9)         NUMBER OF PREVIOUSLY
*                                      STACKED ARRAY IDENT TO WORKAR
ESE21    LH    R14,USPEI2
ESE22    STH   R14,ESE3+2              SMF DISPL FOR LAST ELEMENT+1
         SH    R14,KH4
         STH   R14,ESJ2+2              SMF DISPL FOR FIRST ELEMENT
         SH    R14,KH4
         STH   R14,ESC3+2              SMF DISPL FOR ZERO ELEMENT
         SH    R14,KH4                 SMF DISPL FOR START OF SMF
         STH   R14,ESE5+8              TO CODE
         STH   R14,ESE5+2
         MVZ   ESE5+2(1),ESE5+4
         MVC   ESE4+2(2),ESE5+2
         LA    R2,ESE2                 GENERATE CODE FOR RESERVATION
         BAL   R14,GENTXTS             OF MAIN STORAGE FOR ARRAY
         DC    Y(ESE4-ESE2+4)          LENGTH OF GENERATED CODE
*                                      STACKED ARRAY IDENT TO WORKAREA
         LH    R1,USPEI4               ANY ARRAY IDENT WITH SAME
         SH    R1,KH5                  DIMENSIONS LEFT IN STACK ?
         BM    ETB3                    NO
         STH   R1,USPEI4               SAVE NUMBER OF ARRAYS LEFT
         LA    R9,5(,R9)               CLEAR OPERAND
         NC    ESF4+4(2),CLEARDIS      SMF+16 OF ORIGINAL ARRAY
         OC    ESF4+4(2),ESD1+2        INSERTED AS DISPLACEMENT
         MVC   WORKPL(2),3(R9)
         NI    WORKPL,X'0F'
         LH    R1,WORKPL
         LA    R14,16(,R1)
         STH   R14,ESF4+2              NEW SMF DISP +16
         OI    ESF4+2,CDSA*16          REGISTER CDSA TO CODE
         BAL   R2,GENTXT6              GENERATE 6 BYTES
ESF4     MVC   0(0,CDSA),0(CDSA)       *** GENERATED CODE ***
         SH    R14,KH4                 NEW USPEI4 TO R1=SMF-DISP+12
         B     ESE22
*
*        CODE FOR RESERVATION OF MAIN STORAGE FOR ARRAY
*
ESE2     LR    0,GPRA               *  *** GENERATED CODE ***
         BAL   ADR,GETMSTO(FSA)     |  CALL GETMAIN ROUTINE IN FSA
ESJ2     ST    1,0(CDSA,0)          |
         LR    R14,1                |
         SR    1,GPRC               |
ESC3     ST    1,0(CDSA,0)          |
         AR    R14,GPRA             |
ESE3     ST    R14,0(CDSA,0)        |
ESE5     MVC   0(4,CDSA),12(CDSA)   |  MOVE CHAINING ADDR
         LA    ADR,0(0)             |  STORE DISPL OF LAST SMF
         ST    ADR,12(CDSA)         |  IN DSA
ESE4     MVI   0(CDSA),0            |  NUMBER OF SUBSCRIPTS TO SMF
ESE1     LR    GPRB,GPRA            |  CODE FOR DETERMINE OF
ESH1     M     GPRB-1,0(CDSA,0)     |  SMF
         AR    GPRC,GPRB            |
ESK1     M     GPRA-1,0(CDSA,0)     V
*
*        CONSTANTS AND VARIABLES
*
FORMINUS DC    X'2D01'                 FOR := AND - OPERATORS
HTRICK   DC    X'00'                   +
         DC    X'C801000004'           1 AS INTEGER CONSTANT
         DC    X'1C'                   DO
HHSOURCE DC    F'0'                    SAVE AREA FOR R8
ADDHZB1  DC    A(DHZB1)                ADDR IN CP 69
*
***********************************************************************
*
*        COMPILER PROGRAM  - CP52
*
***********************************************************************
*
*   ARRAY DECLARATION, BEGINNING
*        CONTEXT              STATEMENT
*        SOURCE OPERATOR      LEFT BRACKET, COMMA
*        STACK OPERATOR       ARRAY
*        OPERAND              ARRAY IDENTIFIER
*
         USING CP52,R12
CP52     CLI   0(R8),XFCOMMA           COMMA ?
         BNE   EWF1                    NO,LAST ARRAY IDENTIFIER
         LH    R14,GREGN
         LA    R14,5(R14)              COUNT ARRAY IDENTIFIERS
         STH   R14,GREGN
         BR    R5                      RETURN TO SUBSTART
*
EWF1     BAL   R4,MOVEOPTK             RESERVE ONE OPTK ENTRY
         MVI   0(R10),X'2C'            OPTH (SPEC BRACKET)
         SH    R9,KH10                 R9 IS DECREASED BY TEN
         CR    R10,R9                  CHECK OVERFLOW
         BNL   STACKOFL
         MVC   5(5,R9),10(R9)          MOVE ARRAY IDENTIFIER
         MVC   10(2,R9),GREGN          NUMBER OF ARRAY IDENTIFIERS-1
*                                      TO OPERAND STACK
*
*        CALCULATE AND SAVE NUMBER OF SUBSCRIPTS IN USPE14
*
         SR    R1,R1
         IC    R1,8(R9)
         SRL   R1,4
         LA    R1,1(R1)
         STH   R1,USPEI4
*
*        CALCULATE AND SAVE SMF DISPL +16 IN USPE12
*
         MVC   USPEI2(2),8(R9)
         NI    USPEI2,X'0F'
         LH    R1,USPEI2
         LA    R1,16(R1)
         STH   R1,USPEI2
         MVC   0(2,R9),INTEGTYP        OPERAND INTEGER VALUE IN STACK
         AH    R7,ONEENTRY             NEXT OBJECT TIME ENTRY
         STH   R7,SPBNST+2             CURRENT PBN AND
         MVC   2(3,R9),SPBNST+1        DISPL TO OPERAND STACK
         SH    R7,ONEENTRY             RELEASE OBJECT TIME STACK
         BR    R5                      SCAN TO NEXT OPERATOR (SUBSTART)
*
*        CONSTANTS AND VARIABLES
*
INTEGTYP DC    X'4031'                 INTEGER TYPE VARIABLE
*
***********************************************************************
*
*        COMPILER PROGRAM - CP54
*
***********************************************************************
*
*   ARRAY DECLARATION, TERMINATION
*        CONTEXT              STATEMENT
*        SOURCE OPERATOR      DELTA
*        STACK OPERATOR       ARRAY
*        OPERAND              NONE
*
         USING CP54,R12
CP54     TM    COMPFLGS,OPERAND         OPDT
         BO    FAC2                     YES, BRANCH
FAE2     BCTR  R10,0                    CLOPT
         BAL   R4,SCHDL                 SEMICOLON HANDLING
         SH    R11,KH290                SWITCH TO PROGRAM CONTEXT
         BR    R5                       RETURN TO SUBSTART
*
FAC2     BAL   R4,SERR4
         DC    H'164'                   ERROR 164
         LA    R9,5(,R9)                CLOPD
         B     FAE2
*
***********************************************************************
*
*        COMPILER PROGRAM - CP56
*
***********************************************************************
*
*   DESIGNATIONAL EXPRESSIONS
*        CONTEXT              STATEMENT
*        SOURCE OPERATOR      (
*        STACK OPERATOR       GOTO, SWITCH =
*        OPERAND              NONE
*
         USING CP56,R12
CP56     TM    COMPFLGS,OPERAND        OPDT
         BO    FEB2
FEC1     LA    R11,324(,R11)           CSW(EXP)
         BAL   R4,MOVEOPTK             OPTH(SOURCE)
         MVC   0(1,R10),0(R8)
         BR    R5                      RETURN TO SUBSTART
*
FEB2     BAL   R4,SERR4
         DC    H'164'                  ERROR 164
         LA    R9,5(,R9)               CLOPD
         NI    COMPFLGS,255-OPERAND    RESET OPERAND
         B     FEC1
*
***********************************************************************
*
*        COMPILER PROGRAM - CP59
*
***********************************************************************
*
*   SWITCH LIST HANDLING
*        CONTEXT              STATEMENT
*        SOURCE OPERATOR      COMMA, DELTA
*        STACK OPERATOR       SWITCH =
*        OPERANDS             DESIGNATIONAL OPERAND (NTH PARAMETER)
*                             PARAMETERCOUNT AND PRPOINT (N-1 ENTRIES)
*                             SWITCH IDENTIFIER
*                             LABEL OPERAND
*
         USING CP59,R12
CP59     LA    R4,FKJ2                 RETURN IF OPERAND MISSING
         BAL   R3,OPDTEST              OPERAND TEST
         TM    1(R9),X'08'             OPERAND A LABEL ?
         BZ    FKC2                    NO, BRANCH TO ERROR 175
         TM    0(R9),APIMASK
         BO    FKJ2
         TM    1(R9),X'04'             SWITCH IDENTIFIER ?
         BO    FKC2                    YES, ERROR
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    FKJ2                    YES, BRANCH
         BAL   R4,OPDREC               OPERAND RECOGNIZER
         TM    3(R9),ADR*16            DESIGNATIONAL EXPRESSION ?
         BO    FKH2                    YES, BRANCH
*
*        GENERATE LLC (LOAD LABEL COMMON)
*
         MVN   FKG15+2(1),3(R9)
         MVC   FKG15+3(1),4(R9)
         BAL   R2,GENTXT4              GENERATE 4 BYTES
FKG15    L     ADR,0(LAT)              *** GENERATED CODE ***
         SR    R15,R15
         IC    R15,2(,R9)
         CH    R15,SPBNST              CURRENT BLOCK ?
         BNE   FKG14                   NO
         BAL   R2,GENTXT2              GENERATE 2 BYTES
*                                      LOAD GDSA WITH CDSA
         LR    GDSA,CDSA               *** GENERATED CODE ***
         B     FKH1
*
FKG14    SLL   R15,3
         STH   R15,FKG16+2
         BAL   R2,GENTXT4              GENERATE 4 BYTES
FKG16    L     GDSA,0(PBT)             *** GENERATED CODE ***
FKH1     BAL   R2,GENTXT4              GENERATE 4 BYTES
*                                      GENERATE BRANCH TO CSWE ROUTINE
         B     CSWE2(FSA)              *** GENERATED CODE ***
*
         ST    R6,WORKPL               NEXT THUNK ADDR
         MVC   2(3,R9),WORKPL+1        TO OPERAND STCK
FKJ2     IC    R15,6(,R9)
         LA    R15,5(,R15)             UPDATE SLSWE
         STC   R15,1(,R9)               STORE IN STACK
         MVI   0(R9),0
         CLI   0(R8),XFDELTA           OPERATOR DELTA ?
         BNER  R5                      NO, BRANCH TO SUBSTART
FKF3     SR    R15,R15
         IC    R15,1(,R9)              R15 = NR OF ELEMENTS * 5
         LA    R15,5(R15,R9)           R15 POINTS AT SWITCH ID
         ST    R15,WORKPL
         ST    R15,STENTRY
         MVC   HALFW,3(R15)            GET
         LH    R14,HALFW                   LABEL
         N     R14,HEXFFF                        NUMBER
         A     R14,LATAB               GET LAT ENTRY OF SWITCH
         ST    R6,0(,R14)              STORE PRPOINT IN LAT
FKF41    SR    R1,R1
         IC    R1,3(,R15)              GET
         SRL   R1,4                        ELEMENT
         LA    R1,1(,R1)                            COUNT
         STH   R1,FKF42+2              STORE IN GENERATED CODE
         TM    3(R14),X'02'            LIST ON WORD BOUNDRY ?
         BZ    FKF42A                  YES
         BAL   R2,GENTXT2              GENERATE 2 BYTES
         NOPR  0                       *** GENERATED CODE ***
         ST    R6,0(R14)               ADJUST LAT ENTRY
FKF42A   BAL   R2,GENTXT4              GENERATE 4 BYTES
*                                      GENERATE ELEMENT COUNT
FKF42    DC    H'0',H'0'               *** GENERATED CODE ***
         MVC   HALFW,0(R9)             INITIALIZE PARAM COUNT
*
*        GENERATE ONE THUNK ADDR
*
FKF45    L     R15,STENTRY
         SH    R15,KH5
         ST    R15,STENTRY
         ST    R6,FKF48                SAVE PRPOINT
         MVC   FKF46+1(3),2(R15)
         CNOP  0,4
         BAL   R2,GENTXT4              GENERATE 4 BYTES
FKF46    DC    F'0'                    *** GENERATED CODE ***
         L     R2,FKF48
         BAL   R14,GENRLD              GENERATE RLD RECORD
         DC    H'4'
         DC    H'1'
         DC    H'1'
*
         LH    R15,HALFW               DECREASE
         SH    R15,KH5                          PARAM
         STH   R15,HALFW                              COUNT
         BP    FKF45                   COUNT ¬ ZERO, BRANCH
         L     R15,WORKPL
         LA    R9,15(,R15)             CLEAR OPERAND STACK
         MVC   HALFW,8(R15)            GET
         LH    R15,HALFW                   LAT
         A     R15,LATAB                       ENTRY
         ST    R6,0(R15)               STORE PRPOINT IN LAT
         BCTR  R10,0                   CLOPT
         BAL   R4,SCHDL                SEMIC COUNTER HANDLING
         L     R11,DECAADD             SWITCH TO PROGRAM CONTEXT
         BR    R5                      RETURN TO SUBSTART
*
FKH2     SH    R7,ONEENTRY
         MVI   RII,0                   REGISTER ADR FREE
         B     FKH1
*
FKB25    BAL   R4,STACKAPI             INTRODUCE API
         B     FKJ2
*
FKC2     BAL   R4,SERR2
         DC    H'175'                  ERROR 175
         LA    R9,5(R9)                PREPARE FOR INSERTING API
         B     FKB25
*
*        WORKAREAS
*
STENTRY  DC    F'0'                    WORK AREA
FKF48    DC    F'0'
*
***********************************************************************
*
*        COMPILER PROGRAM - CP62
*
***********************************************************************
*
*   GOTO STATEMENT
*        CONTEXT              STATEMENT
*        SOURCE OPERATOR      EPSILON, ETA, ;, END, ELSE
*        STACK OPERATOR       GOTO
*        OPERAND              DESIGNATIONAL OPERAND
*
         USING CP62,R12
CP62     LA    R4,FXJ1                 RETURN IF OPERAND MISSING
         BAL   R3,OPDTEST              OPERAND TEST
         TM    1(R9),X'08'             OPD LABEL ?
         BZ    FXC2                    NO, BRANCH
         TM    1(R9),X'04'
         BO    FXC2
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    FXJ1                    YES, BRANCH
         BAL   R4,OPDREC
         TM    3(R9),ADR*16            DESIGNATIONAL EXPRESSION ?
         BO    FXE4                    YES, BRANCH
         CLC   SPBNST+1(1),2(R9)       CURRENT PBN ?
         BNE   FXG3                    NO, BRANCH
         MVN   FXH15+2(1),3(R9)
         MVC   FXH15+3(1),4(R9)
         BAL   R2,GENTXT6              GENERATE 6 BYTES
*                                      GENERATE BRANCH TO LABEL
FXH15    L     BRR,0(LAT)              *** GENERATED CODE ***
         BR    BRR                     *** GENERATED CODE ***
         B     FXJ1
*
*        GENERATE LLC (LOAD LABEL COMMON)
*
FXG3     MVN   FXG35+2(1),3(R9)
         MVC   FXG35+3(1),4(R9)
         BAL   R2,GENTXT4              GENERATE 4 BYTES
FXG35    L     ADR,0(LAT)              *** GENERATED CODE ***
         SR    R15,R15
         IC    R15,2(R9)
         SLL   R15,3
         STH   R15,FXG36+2
         BAL   R2,GENTXT4              GENERATE 4 BYTES
FXG36    L     GDSA,0(PBT)             *** GENERATED CODE ***
         B     FXH2
*
FXJ1     LA    R9,5(,R9)               CLOPD
         NI    COMPFLGS,255-OPERAND    RESET OPERAND
         MVI   GPBN+1,X'FF'            GDSA UNDEFINED
         BCT   R10,COMP                CLOPT AND COMP
FXC2     TM    0(R9),APIMASK           ALL PURPOUSE IDENTIFIER
         BO    FXJ1                    YES
         BAL   R4,SERR2
         DC    H'175'                  ERROR 175
*
         B     FXJ1
*
FXE4     SH    R7,ONEENTRY             RELEASE STACK
         XI    RII,RIIADRM             REG ADR FREE
*
*        GENERATE UNCONDITIONAL JUMP TO COMMON LABEL 'UJTCL'
*
FXH2     BAL   R2,GENTXT4              GENERATE 4 BYTES
         B     RETPROG(FSA)            *** GENERATED CODE ***
         B     FXJ1
*
***********************************************************************
*
*        COMPILER PROGRAM - CP85
*
***********************************************************************
*
*   BEGIN OF SWITCH LIST
*        CONTEXT              PROGRAM
*        SOURCE OPERATOR       =
*        STACK OPERATOR       SWITCH
*        OPERANDS             NR OF SWITCH EL * 5 AND PRPOINT
*                             SWITCH IDENTIFIER
*                             LABEL OPERAND
*
         USING CP85,R12
CP85     BAL   R4,MOVEOPDK             RESERVE ONE MORE OPDK ENTRY
         MVC   0(2,R9),ZEROHW          INITIAL ZERO TO SLSWE
         ST    R6,WORKPL
         MVC   2(3,R9),WORKPL+1        FIRST THUNKADDR TO STACK
         L     R11,STC                 SWITCH TO STATEMENT CONTEXT
         MVC   13(2,R9),LN             STORE LN IN R9
         MVI   0(R10),X'2E'            'SWITCH.=' REPLACES 'SWITCH'
         BR    R5                      RETURN TO SUBSTART
*
***********************************************************************
*
*        COMPILER PROGRAM - CP34
*
***********************************************************************
*
*   IF IN STATEMENT CONTEXT
*        CONTEXT              STATEMENT
*        SOURCE OPERATOR      IF
*        STACK OPERATOR       GOTO, SWITCH =, PROCEDURE BRACKET,LEFT
*                             BRACKET  ST PROC BRACKET, FOR =, STEP,
*                             UNTIL, WHILE,  , ARRAY DECL BRACKET,
*                             SE (SEE MATRIX)
*        OPERAND              NONE
*
         USING CP34,R12
CP34     TM    COMPFLGS,OPERAND        OPDT
         BZ    CKD1                    OFF, BRANCH
         BAL   R4,SERR4
         DC    H'164'                  ERROR 164
*
         LA    R9,5(,R9)               CLOPD
CKD1     BAL   R4,MOVEOPTK             OPTH(SOURCE)
         MVC   0(1,R10),0(R8)
         LA    R11,324(,R11)           CSW(EXP)
         CLI   0(R10),X'1D'
         BNER  R5                      NO, RETURN TO SUBSTART
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BOR   R5                      YES, RETURN TO SUBSTART
         BAL   R4,CLEARRG
         BR    R5                      RETURN TO SUBSTART
*
***********************************************************************
*
*        END OF IEX50003
*
***********************************************************************
*
./ ADD NAME=IEX50004 0201-12230-12230-1200-01476-01476-00000-LEVEL
         TITLE 'IEX50 - COMPILATION PHASE - CP12'
*
*        CP12, CP19, CP20, CP21, CP22, CP23, CP33, CP57, CP61
*        CP64, CP71, CP83, CP84
*
*        DEFINITIONS WITHIN CSECT IEX50004
*
NOASSIGN EQU   X'08'
INREGBIT EQU   X'40'
ENTIER   EQU   X'140'                  OFFSET INTO FSA FOR ENTIER RTN
*
***********************************************************************
*
*        COMPILER PROGRAM - CP12
*
***********************************************************************
*
*        ASSIGNMENT
*        CONTEXT              PROGRAM
*        SOURCE OPERATOR      =
*        STACK OPERATOR       BEGIN, ;, THENS, ELSES, DO
*        OPERAND              LEFT SIDE VARIABLE
*
         USING CP12,R12
CP12     TM    COMPFLGS,OPERAND        OPDT ?
         BZ    AWC2                    NO, BRANCH
*
*        ENTRY FROM CP21
*
AWD1     TM    0(R9),X'08'             ASSIGMENT POSSIBLE ?
         BO    AWD2                    NO, BRANCH TO AWD2
         TM    0(R9),INREGBIT          OPD IN REGISTER ?
         BZ    AWJ1                    YES, BRANCH
         TM    1(R9),X'C0'             OPD TYPE PROCEDURE IDENT ?
         BO    AWF2                    YES, BRANCH
         TM    1(R9),X'20'             OPD CALLED BY NAME ?
         BO    AWJ1                    NO, BRANCH IF NOT
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    AWJ1                    YES, BRANCH
*
*        GENERATE ASSIGNMENT CONTROL
*
         BAL   R4,ROUTINE1             LOAD VPLACE,WPLACE
         LH    R1,WPLACE
         LA    R1,4(,R1)
         STH   R1,AWE45+2
         MVZ   AWE45+2(1),VPLACE       INSERT REG INTO CODE
         LA    R2,AWE45
         BAL   R14,GENTXTS
         DC    H'8'                    GENERATE 8 BYTES
*
         BAL   R4,OPDREC
         MVC   2(1,R9),SPBNST+1        CURRENT BLOCK, NEVER FCTVA
*                                      ALWAYS ADDR, NEVER VALUE
AWJ1     BAL   R4,MOVEOPTK             OPTH(SOURCE)
         MVC   0(1,R10),0(R8)
         BR    R5
*
AWC2     BAL   R4,SERR3
         DC    H'176'                  ERROR 176
*
*        ENTRY FROM CP21
*
AWC4     BAL   R4,STACKAPI
         B     AWJ1
*
AWD2     BAL   R4,SERR1
         DC    H'190'                  ERROR 190
*
         LA    R9,5(R9)                TO PREPARE STACKAPI
         B     AWC4                    BRANCH
*
*        CHANGE INT NAME TO OBJECT STACK NAME
*
AWF2     MVI   0(R9),X'C0'
         NI    1(R9),X'03'
         OI    1(R9),X'30'
         MVI   3(R9),X'00'
         MVI   4(R9),X'18'             DISPL IS 24
         B     AWJ1
*
AWE45    TM    0(CDSA),X'08'           *** GENERATED CODE ***
         BO    OERR22(FSA)             *** GENERATED CODE ***
*
***********************************************************************
*
*        COMPILER PROGRAM - CP19
*
***********************************************************************
*
*        IF IN ASSIGNMENT STATEMENT
*        CONTEXT              PROGRAM
*        SOURCE OPERATOR      IF
*        STACK OPERATOR        =
*        OPERAND              NONE
*
         USING CP19,R12
CP19     LA    R11,290(,R11)           CSW(STC)
         B     COMP                    COMPARE
*
***********************************************************************
*
*        COMPILER PROGRAM - CP20
*
***********************************************************************
*
*        ASSIGNMENT
*        CONTEXT              PROGRAM
*        SOURCE OPERATOR      ;, EPSILON, ETA, END, ELSE
*        STACK OPERATOR        =
*        OPERAND              RIGHT SIDE OPERAND
*
         USING CP20,R12
CP20     LA    R4,BIG2
         BAL   R3,OPDTEST
         BAL   R4,ARRTEST1
         TM    1(R9),X'03'             OPD BOOL, REAL OR INTEGER ?
         BZ    BIE3                    NO, ERROR
BIC2     TM    1(R9),X'04'
         BO    BIE32
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    BIE4                    YES, BRANCH
         TM    0(R9),INREGBIT          OPD IN REGISTER ?
         BZ    BID4                    YES, BRANCH
         BAL   R4,OPDREC               OPERAND RECOGNIZER
         B     BID4
*
*        ENTRY FROM CP69
*
BIG2     BCTR  R10,0                   CLEAR OPERATOR
         CLI   0(R10),X'18'            'FOR' ?
         BNE   BIJ2                    NO, BRANCH
         LA    R9,5(,R9)               RELEASE OPERAND
         L     R1,AJMPCP43             R1 -> CP43 ENTRY POINT
         L     R12,SCPTAB+4*6          R12 -> CP6 FOR ADRESSABILITY
         BR    R1                      BRANCH TO CP 43
*
BIJ2     CLI   0(R10),X'2C'            ARRAY BRACKET ?
         BNE   BIK2                    NO, BRANCH
         LA    R9,5(,R9)               CLEAR OPERAND
         L     R1,ADERE2               R1 -> CP51 ENTRY POINT
         L     R12,SCPTAB+4*51         R12 -> CP51
         BR    R1                      BRANCH TO CP51 ENTRY POINT
*
BIK2     CLI   0(R10),XFASSIGN         OPERATOR IS 'ASSIGN' ?
         BE    BIK1                    YES, BRANCH
BIK5     NI    COMPFLGS,255-OPERAND    RESET OPERAND
         LA    R9,10(,R9)              CLEAR OPERAND TWICE
         B     COMP                    BRANCH TO COMP
*
*        RESTORE R7, RII, RIR, CII, CIR
*
BIK1     LH    R7,STRDP
         MVC   CII(8),STRDCIRI
         MVC   5(5,R9),0(R9)           MOVE LAST OPD TO NEXT LAST SPOT
         LA    R9,5(,R9)               CLEAR OPERAND
         TM    RII,RIIADRM             ADR OCCUPIED ?
         BZ    BIK3                    NO
         C     R9,RUTI+32
         BNE   BIK3
         MVI   RII,0                   RELEASE 'ADR' IN REG USE TABLE
BIK3     TM    0(R9),X'20'
         BZ    BIC2
         TM    0(R9),X'40'
         BO    BIC2
         MVI   RII,X'01'
         ST    R9,RUTI+32
         B     BIC2
*
BID4     TM    5(R9),NOASSIGN          TEST NO ASSIGNMENT BIT
         BO    BIE31                   ERROR IF NO ASSIGNMENT BIT
BIE4     TM    1(R9),X'03'             TEST TYPE BITS
         BZ    BIE3                    ERROR IF ZEROES IN TYPE FIELD
         BM    BIAE2                   BRANCH MIXED (=NOT BOOLEAN)
         TM    6(R9),X'03'             NEXT LAST OPD BOOLEAN ?
         BNO   BIE34                   BRANCH IF NOT BOOLEAN
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    BIG2                    YES, BRANCH
*
*        GENERATE BOOLEAN ASSIGN
*
BIG5     TM    0(R9),X'C0'
         BNO   BIBG1
         TM    1(R9),X'30'             TEST IF RIGHT OPD BOOL CONST
         BNZ   BIBG1                   BRANCH IF NOT A CONSTANT
*
*        GENERATE ASSIGN, RIGHT OPD BOOL CON
*
BIAH16   BAL   R4,SAVECIRI
         LA    R9,5(,R9)
         TM    0(R9),X'20'
         BO    BIAH161
         BAL   R4,ROUTINE1
BIAH162  SH    R9,KH5
         MVC   BIAH18+2(2),WPLACE
         MVZ   BIAH18+2(1),VPLACE
         NI    4(R9),X'01'
         MVC   BIAH18+1(1),4(R9)       INSERT CONSTANT TO CODE
         BAL   R2,GENTXT4              GENERATE 4 BYTES
BIAH18   MVI   0(0),X'00'              *** GENERATED CODE ***
         B     BIG2
*
BIAH161  BAL   R4,ROUTINE3
         B     BIAH162
*
BIAE2    TM    6(R9),X'03'             LAST OPD NONBOOLEAN
         BM    BIBA1                   BR IF MIXED, ERROR OTHERWISE
         TM    5(R9),APIMASK           BLO AN API ?
         BO    BIG2                    YES, BRANCH
BIE33    BAL   R4,SERR1
         DC    H'193'                  ERROR 193
*
         B     BIG2
*
BIE34    TM    0(R9),APIMASK           LO AN API ?
         BO    BIG2                    YES, BRANCH
         B     BIE33
*
BIE31    TM    5(R9),APIMASK           BLO AN API ?
         BO    BIG2                    YES, BRANCH
BIE3     BAL   R4,SERR1
         DC    H'192'                  ERROR 192
*
         B     BIG2
*
BIE32    TM    0(R9),APIMASK           LO AN API ?
         BO    BIG2                    YES, BRANCH
         B     BIE3
*
BIBA1    TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    BIG2                    YES, BRANCH
         TM    6(R9),X'02'             NEXT LAST OPD 'REAL' ?
         BZ    BICA1                   NO, BRANCH
         TM    1(R9),X'02'             LAST OPERAND 'REAL' ?
         BO    BIBG1                   YES, BRANCH
         BAL   R4,TRINRE               GENERATE INTEGER REAL CONVERSION
*
*        GENERATE 'ASSIGN REAL'
*
BIBG1    BAL   R4,SAVECIRI
         L     R1,ADHEB2               R1 -> DHEB2 ENTRY IN CP69
         L     R12,SCPTAB+4*69         R12 -> CP69
         BR    R1                      BRANCH TO DHEB2 IN CP69
*
BICA1    TM    1(R9),X'02'             LAST (RIGHT) OPERAND 'REAL'
         BZ    BICF1                   NO, BRANCH
         BAL   R4,TRREIN               GENERATE REAL INTEGER CONVERSION
         BAL   R4,ROUTINE7             GET NEXT FREE REGISTER
         SLA   R14,2
         ST    R9,RUTI(R14)            R9 TO REG USAGE TABLE
         SLA   R14,2
         LA    R14,14(R14)
         STC   R14,BICA15+1            REG NUMBER TO INSTRUCTION
         BAL   R2,GENTXT2              GENERATE 2 BYTES
BICA15   LR    0,0                     *** GENERATED CODE ***
         MVI   0(R9),X'88'
         MVI   1(R9),X'31'
         MVC   2(1,R9),SPBNST+1
         STH   R7,HALFW
         MVC   3(2,R9),HALFW
         MVZ   3(1,R9),BICA15+1
*
*        GENERATE 'ASSIGN INTEGER'
*
BICF1    BAL   R4,SAVECIRI
         L     R1,ADHZB1               R1 -> DHZB1 ENTRY IN CP69
         L     R12,SCPTAB+4*69         R12 -> CP69
         BR    R1                      BRANCH TO DHZB1 ENTRY IN CP69
*
*        RELEASE OBJECT T STACK ENTRY AND REG
*
RELOSREG TM    0(R9),X'C0'
         BOR   R4                      RETURN IF IDENT FROM ITAB
         SH    R7,ONEENTRY             RELEASE ONE OBJ T STACK ENTRY
         TM    0(R9),INREGBIT
         BOR   R4                      RETURN IF OPD NOT 'IN REG'
         NI    RII,X'FE'               RELEASE 'ADR' IN REG USE TABLE
         BR    R4
*
*        SAVE R7, CII, CIR, RII, RIR
*
SAVECIRI STH   R7,STRDP
         MVC   STRDCIRI(8),CII
         BR    R4
*
STRDP    DC    H'0'
STRDCIRI DC    8C' '
*
ADHEB2   DC    A(DHEB2)                ENTRY TO CP69
ADHZB1   DC    A(DHZB1)
ADERE2   DC    A(DERE2)                ENTRY TO CP51, BASE CP51
AJMPCP43 DC    A(DJH1E43)              ENTRY TO CP43, BASE CP6
*
***********************************************************************
*
*        COMPILER PROGRAM - CP21
*
***********************************************************************
*
*        MULTIPLE ASSIGNMENT
*        CONTEXT              PROGRAM
*        SOURCE OPERATOR       =
*        STACK OPERATOR        =
*        OPERAND              LEFT SIDE VARIABLE
*
         USING CP21,R12
CP21     TM    COMPFLGS,OPERAND        OPERAND ON ?
         BZ    BKB2                    NO, BRANCH
         IC    R0,1(,R9)               LOAD R0,R9+1
         IC    R1,6(,R9)               LOAD R1,R9+6
         N     R0,TYPETEST             CLEAR FIRST 3O BITS OF GPR0
         N     R1,TYPETEST             CLEAR FIRST 3O BITS OF GPR1
         L     R12,SCPTAB+4*12         R12 -> CP12
         SR    R0,R1                   SUBTRACT
         BZ    AWD1-CP12(R12)          ZERO, BRANCH TO AWD1 IN CP12
         TM    0(R9),APIMASK           LO AN API ?
         BOR   R5                      YES, BRANCH TO SUBSTART
         TM    5(R9),APIMASK           BLO AN API ?
         BOR   R5                      YES, BRANCH TO SUBSTART
         BAL   R4,SERR1
         DC    H'172'                  ERROR 172
*
         B     AWC4-CP12(R12)          BRANCH TO AWC4 IN CP12
*
BKB2     BAL   R4,SERR4
         DC    H'162'                  ERROR 162
*
         BR    R5                      RETURN TO SUBSTART
*
***********************************************************************
*
*        COMPILER PROGRAM - CP22
*
***********************************************************************
*
*        ARITHM OR BOOL EXPRESSION IN ASSIGNMENT STATEMENT
*        CONTEXT              PROGRAM
*        SOURCE OPERATOR      (, ARITHM OP, BOOL OP, REL OP
*        STACK OPERATOR        =
*        OPERAND              ARRAY OR PROCEDURE IDENTIFIER OR
*                             ARITHMETIC OR BOOLEAN OPERAND OR NONE
*
         USING CP22,R12
CP22     L     R11,EXC                 CSW(EXP)
         B     COMP                    COMPARE
*
***********************************************************************
*
*        COMPILER PROGRAM - CP23
*
***********************************************************************
*
*        PARAMETERLESS PROCEDURE STATEMENT OR STATEMENT END
*        CONTEXT              PROGRAM
*        SOURCE OPERATOR      ;, EPSILON, ETA, END
*        STACK OPERATOR       ;
*        OPERAND              PROCEDURE IDENTIFIER OR NONE
*
         USING CP23,R12
CP23     TM    COMPFLGS,OPERAND        OPDT
         BZ    BOD1                    OFF, BRANCH
         BAL   R4,PLPRST
         LA    R9,5(,R9)
         NI    COMPFLGS,255-OPERAND    RESET OPERAND
BOD1     CLI   0(R8),XFSCOLON          SOURCE SEMICOLON ?
         BNE   BOE1                    NO, BRANCH
         BAL   R4,SCHDL                YES, ENTER SEMICOLON HANDLING
         BR    R5                      RETURN TO SUBSTART
*
BOE1     BCT   R10,COMP                CLOPT AND COMP
*
***********************************************************************
*
*        COMPILER PROGRAM - CP33
*
***********************************************************************
*
*        ARITHMETIC OR BOOLEAN EXPRESSIONS IN STATEMENT CONTEXT
*        CONTEXT              STATEMENT
*        SOURCE OPERATOR      ARITHM OR BOOLEAN OR RELATIONAL OPERATOR
*        STACK OPERATOR       PROCEDURE BRACKET, LEFT BRACKET,
*                             ST PROC BRACKET,FOR =, STEP, UNTIL,
*                             WHILE,  , ARRAY DECL BRACKET
*        OPERAND              ARITHMETIC OR BOOLEAN OPERAND
*
         USING CP33,R12
CP33     LA    R11,324(,R11)           CSW(EXP)
         B     COMP                    COMPARE
*
***********************************************************************
*
*        COMPILER PROGRAM - CP57
*
***********************************************************************
*
*        PROCEDURE CALL
*        CONTEXT              STATEMENT
*        SOURCE OPERATOR      , OR )
*        STACK OPERATOR       PROCEDURE BRACKET
*        OPERANDS             ACTUAL PARAMETER
*                             PARAMETER COUNT AND PRPOINTER AT CALL
*                             PAR CHAR AND PRPOINTER AT NEXT THUNK ADR
*                             LABEL NUMBER
*                             PROCEDURE IDENTIFIER
*
*        COMPUTE FOR LATER REFERENCE (FROM SLPAR IN STACK)
*        STACK ADDR WHICH POINTS TO ENTRY CONTAINING LN
*        (=ONE ENTRY AFTER PROCEDURE IDENTIFIER ENTRY)
*        STORE SLPAR (NUMBER OF PARAMETERS TIMES FIVE)
*
         USING CP57,R12
CP57     TM    COMPFLGS,OPERAND        OPDTEST
         BZ    FGAB2                   FALSE
         MVC   STACKST(2),5(R9)
         LH    R15,STACKST
         LA    R15,10(R15,R9)
         ST    R15,STACKST
         MVC   STSLPAR(2),5(R9)        MOVE SLPAR
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    FGAG1                   YES, BRANCH
         OI    PROCWPS,X'80'           NO PARAMETERLESS PROC CHECK
         BAL   R4,OPDREC               OPERAND RECOGNIZER
         XI    PROCWPS,X'80'           SWITCH OFF
*
*        LOAD ACTUAL PARAMETER ADDR LAPA
*
FGCA1    TM    0(R9),X'20'             OPD REPRESENTS ADDR ?
         BO    FGCB3                   YES
         BAL   R4,CLEARRG              STORE REGS IN OBJ TIME STACK
         BAL   R4,DECOMP               DECOMPOSE OPERAND
         LH    R15,OPDPBN              GET
         SLA   R15,3                       PBN
         STH   R15,FGCD35+2                   TIMES EIGHT TO GEN CODE
         LH    R15,OPDLN               LN
         STH   R15,FGCD34+2               TO GENERATED
         STH   R15,FGCF34+2                            CODE
         TM    1(R9),X'08'             OPERAND LABEL OR SWITCH ?
         BO    FGCD3                   YES
         TM    1(R9),X'C0'             OPERAND PROCEDURE ?
         BZ    FGCF21                  NO PROCEDURE
         TM    0(R9),X'80'
         BO    FGCE3
FGCF21   BAL   R4,ROUTINE1             FIND DISPL AND REG
         MVC   FGCF25+2(2),WPLACE      INSERT DISPLACEMENT IN CODE
         MVZ   FGCF25+2(1),VPLACE      INSERT REG IN CODE
         BAL   R2,GENTXT4              GENERATE 4 BYTES
FGCF25   LA    ADR,0(0)                *** GENERATED CODE ***
         TM    0(R9),X'C0'             IDENTIFIER FROM ITAB ?
         BO    FGAF1                   YES
         SH    R7,ONEENTRY             RELEASE STACK ENTRY
         B     FGAF1                   EXIT FROM LAPA
*
FGCB3    BAL   R4,ROUTINE3             LOAD REG ADR
         B     FGAF1                   EXIT FROM LAPA
*
*        LABEL OR SWITCH IDENTIFIER
*
FGCD3    BAL   R2,GENTXT4              GENERATE 4 BYTES
FGCD34   L     ADR,0(LAT)              *** GENERATED CODE ***
         BAL   R2,GENTXT4              GENERATE 4 BYTES
FGCD35   L     GDSA,0(PBT)             *** GENERATED CODE ***
         B     FGAF1                   EXIT FROM LAPA
*
*        PROCEDURE IDENTIFIER
*
FGCE3    TM    1(R9),X'40'             STANDARD PROCEDURE ?
         BZ    FGCF4                   YES
         TM    3(R9),X'F0'             PARAMETERLESS PROCEDURE ?
         BZ    FGCF33                  YES
         MVC   FGCF35+1(1),2(R9)
         LA    R2,FGCF34
         BAL   R14,GENTXTS
         DC    H'12'                   GENERATE 12 BYTES
*
         B     FGAF1                   EXIT FROM LAPA
*
FGCF33   TM    1(R9),X'20'             CALLED BY VALUE ?
         BZ    FGAF1                   NO
         B     FGCF21                  YES
*
FGCF34   L     ADR,0(LAT)              *** GENERATED CODE ***
FGCF35   MVI   PROLPBN(FSA),X'00'      *** GENERATED CODE ***
         STM   PBT,LAT,PROLREG(FSA)    *** GENERATED CODE ***
*
*        STANDARD PROCEDURE IDENTIFIER
*
FGCF4    TM    4(R9),X'80'             ABS, SIGN, LENGTH, OR ENT ?
         BO    FGCF41                  YES, NO LAT ENTRY
         IC    R15,4(R9)               GET
         N     R15,FGXFC                   ENTRY
         A     R15,LATAB                         IN LAT
         NI    0(R15),X'7F'            INSERT ZERO BIT
         OI    IOTAB+16,X'01'          ALL DATASETS MAY BE NEEDED
FGCF41   LA    R15,2
         NR    R15,R6                  PRPOINT ON HALFWORD BOUNDARY ?
         BNZ   FGCF42                  YES
         BAL   R2,GENTXT2              GENERATE 2 BYTES
         LR    R1,R1                   *** GENERATED CODE ***
*                                      GENERATED NO OP CODE
FGCF42   MVC   FGCF45(4),1(R9)         INSERT 1ST PART OF STD PROC ID
         LA    R2,FGCF44
         BAL   R14,GENTXTS
         DC    H'22'                   GENERATE 22 BYTES
*
         B     FGAF1                   EXIT FROM LAPA
*
         CNOP  2,4
FGCF44   BALR  BRR,0                   *** GENERATED CODE ***
         L     ADR,8(BRR)              *** GENERATED CODE ***
         B     12(BRR)                 *** GENERATED CODE ***
*
FGCF45   DC    F'0'                    *** GENERATED CODE ***
         MVI   PROLPBN(FSA),X'00'      *** GENERATED CODE ***
         STM   PBT,LAT,PROLREG(FSA)    *** GENERATED CODE ***
*
*        GENERATE CALL OF CAP2
*
FGAF1    BAL   R2,GENTXT4              GENERATE 4 BYTES
         B     CAP2(FSA)               *** GENERATED CODE ***
         MVI   GPBN+1,X'FF'            GDSA IS NOT CONTROLLED
FGAG1    MVC   5(2,R9),0(R9)           PAR CHAR OF LO INTO NEXT L OPD
         ST    R6,WORKPL               NEXT THUNK ADDR
         MVC   2(3,R9),WORKPL+1        TO LAST OPD
         LH    R15,STSLPAR             UPDATE SLPAR
         LA    R15,5(R15)
         STH   R15,STSLPAR
         MVC   0(2,R9),STSLPAR         SLPAR TO LAST OPERAND
*
FGBA1    CLI   0(R8),XFRBRAC           RIGHT BRACKET IN SOURCE ?
         BNER  R5                      NO, BRANCH TO SUBSTART
         L     R15,STACKST             GET ADDR OF PROCED ID - 5
         TM    5(R15),X'10'            PROCEDURE IDENTIFIER API ?
         BO    FGBD1                   YES, NO PARAMETER NR CHECK
         SR    R4,R4
         IC    R4,8(R15)               GET NUMBER OF PARM IN PROC IDENT
         SRL   R4,4
         LH    R0,STSLPAR              GET NUMBER OF PARAMS TIMES FIVE
         SRDA  R0,32
         LH    R2,KH5
         DR    R0,R2                   CALC NUMBER OF PARAMETERS
         STH   R1,FGOUTPAR+6           NUMBER TO GENERATED CODE
         CR    R1,R4                   PARAMETER COUNT COMPARE
         BE    FGBD1                   CORRECT NUMBER
         TM    6(R15),X'30'            PROCEDURE FORMAL PARAMETER ?
         BM    FGBD1                   YES, NO ERROR
         BAL   R4,SERR1
         DC    H'187'                  ERROR 187
*
FGBD1    L     R9,STACKST              CLEAR R9 FROM ALL PARAM ENTRY
         LA    R9,5(R9)
         NI    3(R9),X'0F'             CLEAR PARAMETER COUNT
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    FGBH1                   YES, BRANCH
         L     R15,STACKST             GET
         MVC   HALFW(2),3(R15)         ADDR OF
         LH    R4,HALFW                            LAT
         A     R4,LATAB                                ENTRY
         ST    R6,0(R4)                VALUE OF PRPOINT TO LAT ENTRY
*
*        GENERATE PROCEDURE CALL
*
FGBD11   TM    1(R9),FORMPM            PROCEDURE FORMAL ?
         BNM   FGBD11A                 NO
         BAL   R2,GENTXT4              GENERATE 4 BYTES
         MVI   PROLPBN-1(FSA),X'FF'    *** GENERATED CODE ***
*
*        SET SW IN FSA TO DETECT WHEN ACT PROCEDURE IS
*        PARAMETERLESS
*
FGBD11A  OI    PROCWPS,X'80'           SET SWITCH IN OPERAND RECOGNIT
         BAL   R4,OPDREC
         XI    PROCWPS,X'80'           SWITCH OFF
         NI    1(R9),X'3F'             CLEAR PROCEDURE BITS
         TM    1(R9),FORMPM            FORMAL PARAMETER ?
         BNM   FGBG1                   NO
         BAL   R2,GENTXT4              GENERATE 4 BYTES
*                                      GENERATE CALL PROCEDURE FORMAL
         BAL   BRR,PROLOGFP(FSA)       *** GENERATED CODE ***
FGBG1    SR    R15,R15
         STH   R15,PARCOUNT            INITIALIZE PARAMETER COUNT
FGBG12   LH    R15,PARCOUNT
         CH    R15,STSLPAR             ALL PARAMS BEEN PROCESSED ?
         BE    FGBH1                   YES, BRANCH
*
*        GENERATE ONE ENTRY IN PARAMETER LIST
*
FGBG13   LA    R15,5(R15)
         STH   R15,PARCOUNT
         L     R4,STACKST              FIND PARAMETERS IN STACK
         SR    R4,R15
         MVC   FGOUTPAR+4(2),0(R4)     CHARACTER BYTES TO GENER CODE
         MVC   FGOUTPAR+1(3),2(R4)     ADDR OF THUNK TO GENER CODE
         ST    R6,THUNKADR             SAVE PRPOINT FOR RLD RECORD
         LA    R2,FGOUTPAR
         BAL   R14,GENTXTS
         DC    H'8'                    GENERATE 8 BYTES
         L     R2,THUNKADR
         BAL   R14,GENRLD              GENERATE RLD RECORD
         DC    H'4'
         DC    H'1'
         DC    H'1'
         MVI   FGOUTPAR+7,0            ZERO TO NEXT PARM NUMBER FIELD
         B     FGBG12
*
*        CHECK FOR THE PRESENCE OF 'FOR', 'IF' OR 'GOTO'
*        IMMEDIATELY AFTER PROCEDURE CALLS
*        CALLED BY CP57 AND CP61
*
         DROP  R12
FGBG20   LR    R0,R12
         BALR  R12,0
         USING *,R12
         ST    R0,FGBG29               SAVE OLD BASE REG
         ST    R4,FGBG28
         CLI   1(R8),XFZETA            SOURCE BUFFER EMPTY?
         BNE   FGBG22                  NO
         BAL   R4,JBUFFER
FGBG22   CLI   1(R8),XFFOR             NEXT OPERATOR 'FOR' ?
         BE    FGBG27                  YES
         CLI   1(R8),XFIF              NEXT OPERATOR 'IF' ?
         BE    FGBG27                  YES
         CLI   1(R8),XFGOTO            NEXT OPERATOR 'GOTO' ?
         BE    FGBG27                  YES
FGBG25   L     R4,FGBG28
         L     R12,FGBG29              RESTORE OLD BASE REG
         BCTR  R10,R4                  CLOPT AND RETURN
FGBG27   LA    R8,1(,R8)               INCREASE SOURCE PTR
         BAL   R4,SERR3
         DC    H'194'                  ERROR 194
*
         BCT   R8,FGBG25               DECREASE SOURCE PTR
*
FGBG28   DC    F'0'
FGBG29   DC    F'0'
         DROP  R12
*
*        RE-ESTABLISH BASE REG FOR CONTINUATION OF CP57
*
         USING CP57,R12
FGBH1    BAL   R4,FGBG20               CHECK NEXT OPERATOR
         CLI   0(R10),X'30'            PROG CONTEXT OP IN STACK ?
         BNE   FGBG4                   NO, BRANCH
         NI    COMPFLGS,255-OPERAND    RESET OPERAND
         L     R11,DECAADD             SWITCH TO PROGRAM CONTEXT
         TM    3(R9),REGADRM           OPERAND IN ADR ?
         BZ    FGBH1A                  NO
         SH    R7,ONEENTRY             RELEASE STACK
         XI    RII,RIIADRM             ADR NOT OCCUPIED
FGBH1A   LA    R9,5(R9)                RELEASE PROCEDURE IDENT
FGBK5    BCT   R10,SPECTEST            CLOPT, BRANCH TO SPECIAL TEST
FGBG4    CLI   0(R10),X'33'            STMT CONTEXT OP IN STACK ?
         BE    FGBK5                   YES
         L     R11,EXC                 SWITCH TO EXPRESSION CONTEXT
         BCT   R10,SPECTEST            CLOPT, BRANCH TO SPECIAL TEST
FGAB2    BAL   R4,SERR3
         DC    H'176'                  ERROR 176
*
         BAL   R4,STACKAPI             INSERT API
         OI    COMPFLGS,OPERAND        SET OPERAND ON
         B     CP57
*
*        CONSTANTS AND WORKAREAS
*
         DC    0F'0'
FGXFC    DC    X'000000FC'             TO EXTRACT LN FROM OPERAND
FGOUTPAR DC    F'0'                    *** GENERATED CODE ***
         DC    F'0'                    *** GENERATED CODE ***
STACKST  DC    F'0'                    PTR TO R9 ENTRY NEXT TO PROC
STSLPAR  DC    H'0'                    NUMBER OF PARAMETERS TIMES FIVE
PARCOUNT DC    H'0'                    TEMPORARY STORAGE TO COUNT PARMS
THUNKADR DC    F'0'                    TEMPORARY STORAGE
*
***********************************************************************
*
*        COMPILER PROGRAM - CP61
*
***********************************************************************
*
*        CALL OF STANDARD PROCEDURES
*        CONTEXT              STATEMENT
*        SOURCE OPERATOR      , OR )
*        STACK OPERATOR       STANDARD PROCEDURE BRACKET
*        OPERANDS             ACTUAL PARAMETER
*                             PARAMETER COUNT AND PRPOINTER AT CALL
*                             PROCEDURE IDENTIFIER
*
         USING CP61,R12
CP61     LA    R4,FOC2                 OPERAND
         BAL   R3,OPDTEST                      TEST
FOC2     BAL   R4,MOVEOPDK
         MVC   0(5,R9),5(R9)           COPY PARAMETER ENTRY
         SR    R1,R1
         IC    R1,10(R9)                            -
         LA    R1,4(R1)                INCR PARAMETER COUNTER
         STC   R1,10(R9)
         TM    15(R9),X'10'            PROCEDURE IDENTIFIER API
         BO    FOF4                    YES, NO CHECKING
         MVC   FOE2PCH(2),17(R9)       GET
         LH    R2,FOE2PCH                  PAR CHAR
         SRL   R2,0(R1)                             FROM
         STC   R2,FOE2PCH                                PROCED IDENT
         BAL   R4,FQA2                 TEST TYPE
FOH2     TM    16(R9),X'03'            STAND FUNCTION HANDLED ?
         BNZ   FTB2                    YES
FOB4     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    FOD4                    YES, BRANCH
         BAL   R4,ADRTRANS             GENERATE ADDR TRANSFER
FOC4     BAL   R4,FRA3                 CONSTRUCT FLAGS
FOD4     TM    18(R9),X'0F'            SPECIAL ACTIONS REQUIRED ?
         BNZ   FSB1                    YES
FOF4     LA    R9,10(R9)               RELEASE TWO ENTRIES IN OPDSTACK
         CLI   0(R8),XFCOMMA           SOURCE A COMMA ?
         BER   R5                      YES, BRANCH TO SUBSTART
FPA21    SR    R1,R1
         IC    R1,0(R9)                GET NUMBER OF PARAMETERS HANDLED
         TM    9(R9),X'03'             HOW MANY INDICATED IN PROC ID ?
         BZ    FPA23                   ONE
         BM    FPA22                   TWO
         SH    R1,KH4                  THREE
FPA22    SH    R1,KH4
FPA23    SH    R1,KH4
         BNZ   FPA1                    ERROR IF NUMBER DOES NOT CHECK
FPB2     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    FPG2                    YES, BRANCH
         BAL   R4,LOADR1               GENERATE CALL OF STAND PROCEDURE
FPG2     L     R3,FGBGADR
         BALR  R4,R3                   CHECK NEXT OPERATOR
         CLI   0(R10),X'30'            CHECK CONTEXT OPERATOR
         BNE   FPC5                    NOT PROGRAM CONTEXT
         L     R11,DECAADD             SWITCH TO PROGRAM CONTEXT
         NI    COMPFLGS,255-OPERAND    RESET OPERAND
         LA    R9,10(R9)               CLEAR TWO OPERANDS
FPG3     BCT   R10,SPECTEST            CLOPT, BRANCH TO SPECIAL TEST
FPC5     TM    6(R9),X'03'             STANDARD FUNCTION HANDLED ?
         BNZ   FPD5                    YES
FPD4     BAL   R4,SERR3                NO, ERROR
         DC    H'168'                  ERROR 168
*
FPD5     CLI   0(R10),X'33'            STATEMENT CONTEXT ?
         BE    FPE4                    YES
         L     R11,EXC                 NO, SWITCH TO EXPR CONTEXT
FPE4     LA    R9,10(R9)               CLOPD TWICE
         BAL   R4,STACKAPI             INTRODUCE API
         B     FPG3
*
*        SUBROUTINE FOR TYPE TEST OF CURR PAR
*
FQA2     ST    R4,LOADR1R
         TM    0(R9),X'10'             CHECK IF OPERAND IS API
         BO    FOH2                    YES
         TM    1(R9),X'08'             PAR LABEL ?
         BO    FQJ1                    YES
         TM    FOE2PCH,X'03'           STRING OR PROCEDURE ?
         BZ    FQD3                    YES
         TM    1(R9),X'04'             PARAMETER ARRAY IDENTIFIER ?
         BO    FQA2A                   YES, BYPASS NEXT TEST
         BAL   R4,ARRTEST1             TEST FOR PROCEDURE IDENTIFIER
FQA2A    XC    FOE2PCH(1),1(R9)        COMP ACT PAR WITH CHAR FROM PRI
         TM    FOE2PCH,X'07'           TEST ARRAY AND TYPE BITS
         L     R4,LOADR1R
         BZR   R4                      RETURN IF ZEROES
         BO    FQJ1                    ERROR IF ONESS
         TM    FOE2PCH,X'08'           CALL BY NAME INDIC IN CHAR
         BO    FQJ1                    YES, BRANCH TO ERROR
         TM    FOE2PCH,X'03'           TEST TYPE BITS
         BNO   FQJ1                    ERROR IF ZEROES OR MIXED
         TM    1(R9),X'03'             TEST TYPE OF PAR
         BNM   FQJ1                    ERROR IF NOT ARITHM TYPE
         BR    R4                      RETURN
*
FQD3     TM    FOE2PCH,X'0C'           STRING INDIC BY PROCEDURE ID ?
         BNZ   FQE3                    NO
         TM    0(R9),X'01'             PAR STRING ?
         BZ    FQJ1                    NO, ERROR
         BR    R4                      RETURN
*
FQE3     TM    1(R9),X'C0'             PAR PROCEDURE  ?
         BZ    FQJ1                    NO, ERROR
         BO    FQF3                    IF PROCEDURE
         TM    1(R9),X'80'             PAR STAND PROCEDURE ?
         BO    FQJ1                    YES, ERROR
FQF3     TM    1(R9),X'30'             PAR FORMAL PARAMETER ?
         BNM   FQG3                    NO
         TM    1(R9),X'20'             YES, IS IT CALLED BY VALUE
         BO    FQJ1                    ERROR IF YES
FQG3     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    FOF4                    YES, BRANCH
         TM    1(R9),X'10'             FORMAL PAR CALLED BY NAME ?
         BO    FQH4                    YES
         TM    3(R9),X'E0'             MORE THAN ONE PARAMETER ?
         BNZ   FQJ1                    YES, ERROR
         TM    3(R9),X'10'             DOES IT HAVE ONE PARAMETER
         BZ    FQJ1                    ERROR IF NOT
         MVC   FQG35+1(1),2(R9)        PBN TO GENERATED CODE
         MVN   FQG36+4(1),8(R9)
         MVC   FQG36+5(1),9(R9)        MOVE LABEL NUMBER
         BAL   R4,GETPARP
         STH   R15,FQG36+2             STORE DISP IN GENERATED CODE
         OI    FQG36+2,X'A0'           REG CDSA TO GENERATED CODE
         LA    R2,FQG35
         BAL   R14,GENTXTS
         DC    H'14'                   GENERATE 14 BYTES
         B     FOF4
*
FQG35    MVI   PROLPBN(FSA),X'0'       *** GENERATED CODE ***
         STM   PBT,LAT,PROLREG(FSA)    *** GENERATED CODE ***
FQG36    MVC   0(4,CDSA),0(LAT)        *** GENERATED CODE ***
*
FQH4     NI    1(R9),X'3F'             REMOVE PROCEDURE BITS FOR OPDREC
         BAL   R4,ADRTRANS             ADDRESS TRANSFER (CALL ACT PAR)
         B     FOF4
*
FPA1     BAL   R4,SERR1                ERROR PATTERN ENTRIES
         DC    H'187'                  ERROR 187
*
         B     FPG2
*
FQJ1     BAL   R4,SERR1
         DC    H'188'                  ERROR 188
*
         B     FOH2
*
*        CONSTRUCT FLAGS
*
FRA3     TM    FOE2PCH,X'08'           PROCEDURE SPECIFY 'NAME' ?
         BZ    FOD4                    NO
         TM    1(R9),X'04'             CURRENT PARAMETER ARRAY ?
         BO    FOD4                    YES
         TM    1(R9),X'30'             FORMAL PAR
         BNM   FRF3                    NO
         TM    1(R9),X'20'             YES, CALLED BY NAME ?
         BO    FRF3                    NO
         LA    R9,5(,R9)               ADJUST R9 FOR ROUT 1
         BAL   R4,ROUTINE1             GET ADDR OF FORMAL PARAMETER
         SH    R9,KH5                  RESTORE R9
         LH    R1,WPLACE               GET ADDR OF
         LA    R1,4(,R1)                           CHAR BYTES
         STH   R1,FRE24+2                                     TO GEN C
         MVZ   FRE24+2(1),VPLACE
         BAL   R2,GENTXT4              GENERATE 4 BYTES
*                                      GENERATE 'NO ASSIGNMENT TEST'
FRE24    TM    0(0),X'08'              *** GENERATED CODE ***
         TM    18(R9),X'02'            PROCEDURE IDENTIFIER SYSACT ?
         BO    FRG2                    YES
         BAL   R2,GENTXT4              NO, GENERATE BR TO OBJ T ERROR
         BO    OERR22(FSA)             *** GENERATED CODE ***
         MVC   2(1,R9),SPBNST+1        CURR PBN TO PARAMETER
         B     FOD4
*
FRG2     BAL   R4,GETPARP              GET DISP IN OBJ TIME STACK
         STH   R15,FRG25+2             STORE IT IN GENERATED CODE
         OI    FRG25+2,X'A0'           INSERT REG NUMBER
         LA    R2,FRG24                GEN INSERTION OF NO-ASS-FLAG
         BAL   R14,GENTXTS             IF PROC ID IS SYSACT
         DC    H'10'                   GENERATE 10 BYTES
*
         B     FOD4
*
FRG24    BALR  R14,0                   *** GENERATED CODE ***
         BZ    8(R14)                  *** GENERATED CODE ***
FRG25    MVI   0(CDSA),X'40'           *** GENERATED CODE ***
*
FRF3     TM    0(R9),X'08'             NO ASSIGNM FLAG IN PARAMETER ?
         BZ    FOD4                    NO
         TM    18(R9),X'02'            PROCEDURE ID SYSACT ?
         BZ    FRH3                    NO, ERROR
         BAL   R4,GETPARP              DISP IN OBJ T ST
         STH   R15,FRG45+2                              TO GENER CODE
         OI    FRG45+2,X'A0'           INSERT REG NUMBER
         BAL   R2,GENTXT4              GENERATE 4 BYTES
*                                      GENER INSERTION OF NO-ASS-FLAG
FRG45    MVI   0(CDSA),X'40'           *** GENERATED CODE ***
         B     FOD4
*
FRH3     BAL   R4,SERR1                ERROR PATTERN ENTRY
         DC    H'188'                  ERROR 188
*
         B     FOF4
*
*        SPECIAL ACTIONS, I/O PROCEDURES
*
FSB1     TM    18(R9),X'0C'            INPUT OR OUTPUT ?
         BZ    FSB3                    NEITHER, BRANCH
         CLI   10(R9),X'04'            CURRENT PARAMETER THE FIRST ?
         BNE   FOF4                    NO
         BAL   R14,FSSUBR              TEST RANGE OF DATASETNR ETC
*
*        MAKE INSERTION IN I/O TAB
*
FSD2     TM    18(R9),X'08'            INPUT ?
         BZ    FSD4                    NO
         TM    1(R9),X'FC'             INTEGER CONST, 1ST TEST ?
         BNZ   FSD3                    NO
         TM    0(R9),X'C0'             INTEGER CONST, 2ND TEST
         BNO   FSD3                    NO
         CLI   9(R9),X'04'             DSN = 1 ?
         BE    FRH3                    YES, ERROR
FSD3     OI    0(R2),X'80'             NO, INDICATE INPUT
FSD4     TM    18(R9),X'04'            OUTPUT ?
         BZ    FSD6                    NO
         TM    1(R9),X'FC'             INTEGER CONST, 1ST TEST ?
         BNZ   FSD5                    NO
         TM    0(R9),X'C0'             INTEGER CONST, 2ND TEST
         BNO   FSD5                    NO
         CLI   9(R9),X'00'             DSN = 0 ?
         BE    FRH3                    YES, ERROR
FSD5     OI    0(R2),X'40'             NO, INDICATE OUTPUT
FSD6     B     FOF4
*
FSB3     TM    18(R9),X'01'            PUT/GET ?
         BZ    FSB3A                   NO
         OI    IOTAB+17,X'FF'          YES
FSB3A    TM    18(R9),X'02'            SYSACT ?
         BZ    FOF4                    NO
*
*        SPECIAL ACTIONS - SYSACT
*
FSF3     CLI   10(R9),X'08'            TEST PARAMETER COUNT
         BH    FOF4                    BRANCH IF THIRD PARAMETER
         BL    FSG4                    BRANCH IF FIRST PARAMETER
         TM    1(R9),X'FC'             INTEGER CONST, 1ST TEST
         BNZ   FSF3A                   NO
         TM    0(R9),X'C0'             INTEGER CONST, 2ND TEST
         BO    FSJ2                    YES
FSF3A    MVI   SYSACTF,X'08'           INDICATE UNDETERMINED FUNCTION
FSFJ35   SR    R15,R15                 GET
         IC    R15,11(R9)                  ENTRY
         SRA   R15,2                              IN
         LA    R15,IOTAB(R15)                        I/O TAB
         OC    0(1,R15),SYSACTF        INSERT SYSACT BIT
         B     FOF4
*
FSJ2     BAL   R14,FSSUBR              INTEGER CONST TEST ETC
         CLI   4(R9),X'00'             SYSACT FUNCTION ZERO?
         BE    FSE1                    YES, ERROR
         MVI   SYSACTF,X'20'
         CLI   4(R9),X'10'             FUNCTION = 4 ?
         BE    FSAA                    YES
         CLI   4(R9),X'34'             NO, FUNCTION = 13 ?
         BNE   FSBB                    NO
*
*        FUNCTION IS 4 OR 13
*
FSAA     CLI   11(R9),X'04'            DSN = 0 OR 1 ?
         BNH   FRH3                    YES, ERROR
         B     FSFJ35                  NO, OK
*
FSBB     CLI   4(R9),X'20'             FUNCTION = 8 ?
         BE    FSBB1                   YES
         MVI   SYSACTF,X'04'           NO, INDICATE OTHER FUNCTION
         B     FSFJ35
*
FSBB1    CLI   11(R9),X'00'            DSN = 0 ?
         BE    FRH3                    YES, ERROR
         MVI   SYSACTF,X'10'           NO, OK
         B     FSFJ35
*
*        HANDLE FIRST SYSACT PARAMETER
*
FSG4     BAL   R14,FSSUBR              CHECK OF INTEGER CONST ETC
         MVC   11(1,R9),OPDADR+1       STORE DATASETNUMBER IN PTR+1
         B     FOF4
*
*        CHECK PARAMETER
*
FSSUBR   TM    1(R9),X'FC'             INTEGER CONST, 1ST TEST
         BNZ   FSSUBR1                 NO, BRANCH
         TM    0(R9),X'C0'             INTEGER CONST, 2ND TEST
         BNO   FSSUBR1                 NO, BRANCH
         TM    2(R9),X'FF'             CONST IN CONST POOL ZERO ?
         BNZ   FSE1                    ERROR IF NOT CONSTPOOL ZERO
         BAL   R4,DECOMP               DECOMPOSE OPERAND
         LH    R15,OPDADR              GET DISP IN CONST POOL ZERO
         SRA   R15,6
         BZ    FSSUBR2                 CONST < 16, BRANCH
FSE1     BAL   R4,SERR1                ERROR IF NOT
         DC    H'189'                  ERROR 189
*
         B     FOF4
*
FSSUBR1  MVI   OPDADR+1,X'40'          4*16 INTO OPDADR+1
FSSUBR2  MVI   OPDADR,0                ZERO TO OPDADR FIRST BYTE
         LH    R15,OPDADR
         SRA   R15,2
         LA    R2,IOTAB(R15)           ADDR OF IOTAB ENTRY
         BR    R14                     RETURN
*
*        PROCESS ACTUAL PARAMETER FOR STANDARD FUNCTION PROCEDURE
*
FTB2     CLI   0(R8),XFRBRAC           SOURCE RIGHT BRACKET ?
         BE    FTC2                    YES, BRANCH
         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         B     FOF4
*
FTC2     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    FOF4                    YES
         BCTR  R10,0                   NO, CLEAR ONE OPERATOR
         CLI   0(R10),X'33'            TEST CONTEXT OPERATOR
         BL    FTD3                    PRC OPT, BRANCH
         BE    FTE1                    STC OPT, BRANCH
         L     R11,EXC                 SWITCH TO EXPR CONTEXT
FTE1     BCTR  R10,0                   CLOPT
         TM    19(R9),X'80'            ABS, SIGN, LENGTH, ENTIER ?
         BZ    FUB2                    NO
         BAL   R4,OPDREC               EXAMINE PARAMETER
         CLI   19(R9),X'E0'            PROCEDURE ID 'LENGTH' ?
         BE    FTG1                    YES
         CLI   19(R9),X'F0'            PROCURE 'ENTIER' ?
         BE    FUD1                    YES
FTH2     TM    1(R9),X'02'             PARAMETER OF TYPE REAL ?
         BO    FUB2                    YES
         BAL   R4,TRINRE               NO, GENERATE INTEGER REAL CONV
         B     FUB2
*
FTD3     L     R11,DECAADD             SWITCH TO PROGRAM CONTEXT
         MVC   HALFW,13(R9)
         LH    R7,HALFW                RESTORE OBJ TIME STACK PTR
         NI    COMPFLGS,255-OPERAND    RESET OPERAND
         LA    R9,20(R9)               CLEAR FOUR OPERANDS
         BCT   R10,SPECTEST            CLOPT, BRANCH TO SPECIAL TEST
*
*        GENERATE CODE FOR 'LENGTH'
*
FTG1     BAL   R4,ROUTIN15             LOAD VW-PLACE
         MVC   FTG12+4(2),WPLACE       ADDR OF STRING TO GEN CODE
         MVZ   FTG12+4(1),VPLACE
         BAL   R4,ROUTINE7             FIND NEXT GPR
         LR    R15,R14
         SLL   R14,4                   STORE
         STC   R14,FTG13+1                   REG NR
         STC   R14,FTG13+5                          IN
         STC   R14,FTG13+7                             GENER CODE
         OR    R15,R14
         STC   R15,FUOTRG              SAVE REG NUMBER USED
         LA    R2,FTG12
         BAL   R14,GENTXTS
         DC    H'14'                   GENERATE 14 BYTES
*
         B     FUF1
*
FTG12    MVC   HW(2,FSA),0(0)          *** GENERATED CODE ***
FTG13    LH    0,HW(0,FSA)             *** GENERATED CODE ***
         BCTR  0,0                     *** GENERATED CODE ***
         BCTR  0,0                     *** GENERATED CODE ***
*
*        GENERATE CODE FOR 'SIGN'
*
FTG3     LA    R3,FTG35                RETURN ADDR IF VALUE IN REG
         BAL   R4,ROUTIN15             LOAD VW-PLACE IF NOT VAL IN REG
         BAL   R4,ROUTIN11             FIND NEXT FPR
         LR    R15,R14                 REG
         SLL   R15,4                       NR
         STC   R15,FTG31+1                    TO
         OR    R15,R14                          GENER
         STC   R15,FTG33+1                             CODE
         BAL   R4,ROUTIN12             REG NOT OCCUPIED
         MVC   FTG31+2(2),WPLACE
         MVZ   FTG31+2(1),VPLACE       ADDR TO GENER CODE
         BAL   R2,GENTXTP4             GENERATE 4 BYTES
FTG31    LD    0,0(0)                  *** GENERATED CODE ***
FTG32    BAL   R2,GENTXTP2             GENERATE 2 BYTES
FTG33    LTDR  0,0                     *** GENERATED CODE ***
         B     FTH4
*
FTG35    MVC   FTG33+1(1),VPLACE       REG NUMBER TO GENER CODE
         BAL   R4,ROUTIN12             REG NOT OCCUPIED
         B     FTG32
*
FTH4     BAL   R4,ROUTINE7             FIND NEXT GPR
         LR    R15,R14
         SLL   R14,4
         OR    R15,R14
         STC   R15,FUOTRG              SAVER REG NUMBER
         STC   R14,FTH42+3             REG
         STC   R14,FTH43+1                 NUMBER TO
         STC   R14,FTH43+7                           GENER CODE
         LA    R2,FTH42
         BAL   R14,GENTXTS
         DC    H'18'                   GENERATE 18 BYTES
*
         B     FUF1
*
FTH42    BALR  BRR,0                   *** GENERATED CODE ***
         LA    0,1                     *** GENERATED CODE ***
         BP    16(,BRR)                *** GENERATED CODE ***
FTH43    BCTR  0,0                     *** GENERATED CODE ***
         BZ    16(,BRR)                *** GENERATED CODE ***
         BCTR  0,0                     *** GENERATED CODE ***
*
FUB2     CLI   19(R9),X'80'            PROCEDURE ID 'ABS' ?
         BE    FUB3                    YES
         CLI   19(R9),X'C0'            'SIGN' ?
         BE    FTG3                    YES
         B     FUD2
*
*        GENERATE CALL OF 'ENTIER'
*
FUD1     TM    1(R9),X'03'             OPERAND INTEGER ?
         BNM   FUD12
         TM    1(R9),X'01'
         BO    FUD14                   YES
FUD12    LA    R3,FUD13                RETURN ADDR IF VALUE IN REG
         BAL   R4,ROUTIN15             LOAD VW-PLACE IF NOT VAL IN REG
         TM    RIR+1,X'01'             FPR0 FREE ?
         BZ    FUD10                   YES
         BAL   R4,ROUTIN14             NO, CLEAR IT
         NI    RIR+1,X'FE'             SET FPR0 NOT OCCUPIED
FUD10    MVC   FUD15+2(2),WPLACE
         MVZ   FUD15+2(1),VPLACE       ADDR OF VALUE TO GEN CODE
         BAL   R2,GENTXTP4             GENERATE 4 BYTES
FUD15    LD    0,0(0,0)                *** GENERATED CODE ***
FUD11    BAL   R4,ROUTINE7             INDICATE NEXT GPR
         LR    R15,R14
         SLL   R14,4
         STC   R14,FUD16+1             REG NUMBER TO GEN CODE
         OI    FUD16+1,X'0E'           REG R14 TO GEN CODE
         OR    R15,R14
         STC   R15,FUOTRG              SAVE REG NUMBER USED
         TM    RII,X'01'               ADR FREE ?
         BZ    FUD17                   YES
         BAL   R4,ROUTIN10             NO, CLEAR IT
FUD17    BAL   R2,GENTXT6              GENERATE 6 BYTES
         BAL   ADR,ENTIER(FSA)         *** GENERATED CODE ***
FUD16    LR    0,R14                   *** GENERATED CODE ***
         B     FUF1
*
FUD13    TM    3(R9),X'F0'             VALUE IN FPR0 ?
         BZ    FUD18                   YES
         TM    RIR+1,X'01'             NO, FPR0 FREE ?
         BZ    *+12                    YES
         BAL   R4,ROUTIN14             NO, CLEAR IT
         NI    RIR+1,X'FE'             SET FPR0 NOT OCCUPIED
         MVN   FUD19+1(1),VPLACE       REG NUMBER TO GENER CODE
         BAL   R2,GENTXTP2
FUD19    LDR   0,0                     *** GENERATED CODE ***
         BAL   R4,ROUTIN12             REG NOT OCCUPIED
         B     FUD11
*
FUD18    NI    RIR+1,X'FE'             SET FPR0 NOT OCCUPIED
         B     FUD11
*
FUD14    MVC   15(5,R9),0(R9)          PARAMETER IS INSERTED AS RESULT
         TM    0(R9),X'40'             VALUE OR ADDR IN REG
         BO    FUG3                    NO
         SR    R4,R4
         IC    R4,3(R9)                GET
         SRL   R4,4                        REG NUMBER
         SLL   R4,2                    4 TIMES REG NUMBER
         LA    R9,15(,R9)              ADJUST R9
         ST    R9,RUTI(R4)             INTRODUCE CORRECT R9 ADDR
         B     SPECTEST                BRANCH TO SPECIAL TEST
*
*        GENERATE CODE FOR 'ABS'
*
FUB3     LA    R3,FUB4                 RETURN ADDR IF VALUE IN REG
         BAL   R4,ROUTIN15             LOAD VW-PLACE IF NOT VAL IN REG
         BAL   R4,ROUTIN11             FIND NEXT FPR
         LR    R15,R14
         SLL   R15,4
         STC   R15,FUB31+1             REG NUMBER TO GEN CODE
         OR    R15,R14                 SAVE REG NUMBER
         STC   R15,FUOTRG              IN TWO HALF BYTES
         MVC   FUB31+2(2),WPLACE       ADDR OF VALUE TO GENER CODE
         MVZ   FUB31+2(1),VPLACE
         BAL   R2,GENTXTP4             GENERATE 4 BYTES
FUB31    LD    0,0(0)                  *** GENERATED CODE ***
         MVC   FUB41+1(1),FUOTRG       REG NUMBER TO NEXT GENER INSTR
         B     FUB42
*
FUB4     IC    R15,VPLACE              REG NUMBER TO GENER CODE
         STC   R15,FUB41+1
         STC   R15,FUOTRG              SAVE BYTE
FUB42    BAL   R2,GENTXTP2             GENERATE 2 BYTES
FUB41    LPDR  0,0                     *** GENERATED CODE ***
         B     FUF2
*
*        GENERATE CALL FOR REMAINING FUNCTIONS
*
FUD2     BAL   R4,ADRTRANS             GENERATE ADDR TRANSFER
         LA    R9,10(R9)               ADJUST R9 FOR SUBROUTINE
         BAL   R4,LOADR1               GEN LOAD OF PARREG AND FNC CALL
         SH    R9,KH10                 RESTORE R9
         MVI   FUOTRG,X'00'            INDICATE FPR0
         OI    RIR+1,X'01'             INDICATE FPR0 OCCUPIED
         MVI   CIR+1,X'00'
*
*        A FLOATING POINT REG IS USED
*
FUF2     SR    R15,R15                 GET
         IC    R15,FUOTRG              GET REG NUMBER USED
         SRL   R15,4
         SLL   R15,1                   MULT BY 2
         LA    R1,15(,R9)              ADDR OF OPERAND
         ST    R1,RUTR(R15)            TO RUTR
*
*        REPLACE PROCEDURE ID BY RESULT
*
FUG2     MVC   HALFW,13(R9)            RESTORE OBJ TIME ST POINTER
         LH    R7,HALFW
         AH    R7,ONEENTRY             ADD SIZE OF ONE ENTRY
         STH   R7,FUOTSC+4             OBJ T STACK DISP TO GEN CODE
         MVZ   FUOTSC+4(1),FUOTRG      INSERT REGISTER NUMBER
         MVC   FUOTSC+3(1),SPBNST+1    CURRENT PBN
         MVC   15(5,R9),FUOTSC+1       INSERT OPERAND INTO STACK
         MVI   FUOTSC+2,X'32'          RESTORE TYPE 'REAL'
FUG3     LA    R9,15(R9)               CLEAR THREE OPERANDS
         B     SPECTEST                BRANCH TO SPECIAL TEST
*
*        A GENERAL REGISTER IS USED
*
FUF1     MVI   FUOTSC+2,X'31'          INSERT TYPE 'INTEGER'
         SR    R15,R15                 GET
         IC    R15,FUOTRG                  REG
         SRL   R15,4                           NR
         SLL   R15,2                   MULTIPLY BY 4
         LA    R1,15(,R9)              GET ADDR OF OPERAND
         ST    R1,RUTI(R15)            STORE ADDR IN RUTI
         B     FUG2
*
*        GEN LOAD PARREG AND STAND PROC CALL
*
LOADR1   ST    R4,LOADR1R              SAVE RETURN ADDR
         TM    FUOTFP,X'80'            FPR0 USED BUT NOT CLEARED ?
         BZ    LOADR2                  NO
         NI    FUOTFP,X'7F'            RESET INDICATOR
         BAL   R4,CLEARRG              SAVE ALL REGS
LOADR2   MVC   HALFW,3(R9)             GET
         LH    R7,HALFW                    ADDR OF
         LH    R15,ONEENTRY                        PARAMETER
         AR    R15,R7                                        LIST
         STH   R15,FPB21+2             ADDR TO GENERATED CODE
         NI    9(R9),X'FC'             LAT DISP TO GENERATED CODE
         MVC   FPB22+3(1),9(R9)
         BAL   R2,GENTXT4              GENERATE 4 BYTES
FPB21    LA    R1,0(CDSA)              *** GENERATED CODE ***
         BAL   R2,GENTXT6              GENERATE 6 BYTES
FPB22    L     ENTRY,0(LAT)            *** GENERATED CODE ***
         BALR  R14,ENTRY               *** GENERATED CODE ***
         L     R4,LOADR1R
         BR    R4
*
*        GENERATE TRANSFER OF PARAM ADDR
*
ADRTRANS ST    R4,LOADR1R              SAVE RETURN ADDR
         BAL   R4,GETPARP              GET DISP IN OBJ T STACK FOR PAR
         STH   R15,ADRTR2+2            DISP
         STH   R15,ADRTR4+2                 TO
         STH   R15,ADRTR6+2                    GENERATED
         STH   R15,ADRTR8+2                              CODE
         TM    16(R9),X'02'            STANDARD FUNCTION HANDLED ?
         BZ    ADRTR0                  NO
         TM    1(R9),X'02'             YES, PARAMETER OF TYPE REAL ?
         BO    ADRTR0                  YES
         BAL   R4,OPDREC               NO, GENERATE CONVERSION
         BAL   R4,TRINRE
ADRTR0   BAL   R4,LDVWPLC              LOAD VWPLACE
         TM    0(R9),X'20'             ADDR OR VALUE ?
         BO    ADRTR3                  ADDR
         MVC   ADRTR1+2(2),WPLACE      MOVE ADDR OF VALUE TO GEN CODE
         MVZ   ADRTR1+2(1),VPLACE
         BAL   R2,GENTXT4              GENERATE 4 BYTES
ADRTR1   LA    R14,0(0)                *** GENERATED CODE ***
         BAL   R2,GENTXT4              GENERATE 4 BYTES
ADRTR2   ST    R14,0(CDSA)             *** GENERATED CODE ***
         B     ADRTR7
*
ADRTR3   OI    FUOTFP,X'80'            INDICATE ADDR FROM ADR
ADRTR31  CLI   VPLACE,X'AA'            ADDR IN STACK ?
         BE    ADRTR5                  YES
         BAL   R2,GENTXT4              GENERATE 4 BYTES
ADRTR4   ST    ADR,0(CDSA)             *** GENERATED CODE ***
         BAL   R4,RELADR               RELEASE REG ADR
         B     ADRTR61
*
ADRTR5   MVC   ADRTR6+4(2),WPLACE      DISP IN STACK TO GENER CODE
         OI    ADRTR6+4,X'A0'          REG CDSA TO GENERATED CODE
         OI    ADRTR6+2,X'A0'
         SH    R7,ONEENTRY             RELEASE STACK
         BAL   R2,GENTXT6              GENERATE 6 BYTES
ADRTR6   MVC   0(4,0),0(0)             *** GENERATED CODE ***
ADRTR61  BAL   R4,CLEARRG              RESTORE ALL REGISTERS USED
ADRTR7   TM    16(R9),X'03'            STAND FUNCTION HANDLED ?
         BNZ   ADRTR9                  YES, CONV ALREADY MADE IF NEC
         TM    FOE2PCH,X'03'           CONVERSION NECESSARY ?
         BZ    ADRTR9                  NO
         OI    ADRTR8+2,X'A0'          REG CDSA TO GENERATED CODE
         BAL   R2,GENTXT4              GENERATE 4 BYTES
ADRTR8   OI    0(0),X'80'              *** GENERATED CODE ***
ADRTR9   L     R4,LOADR1R              LOAD RETURN ADDR
         BR    R4
*
*        RELEASE OF REGISTER ADR
*
RELADR   SH    R7,ONEENTRY             RELEASE STACK
         XI    RII,RIIADRM             ADR NOT OCCUPIED
         BR    R4
*
*        COMPUTE OBJ TIME ST DISP FOR PARAMETER
*
GETPARP  MVC   HALFW,13(R9)            GET STORED P-VALUE
         SR    R15,R15
         IC    R15,10(R9)              GET NR OF PARAMS TIMES FOUR
         AH    R15,HALFW               ADD TO STORED P
         AH    R15,ONEENTRY            ADD SIZE OF ONE ENTRY
         SH    R15,KH4                 SUBTRACT SIZE OF ONE PAR ENTRY
         BR    R4
*
*        CONSTANTS AND AREAS
*
FOE2PCH  DC    H'0'                    SAVE PARAM CHAR FROM PROC ID
SYSACTF  DC    H'0'                    TEMPORARY STORE OF SYSACT FUNCT
FUOTSC   DC    X'0088'                 AREA TO BUILD
         DC    X'3200'                                OPD REPR
         DC    X'0000'                                         RESULT
FUOTRG   DC    X'00'                   REGISTER NUMBER USED
FUOTFP   DC    X'00'                   TO IND ADDR FROM ADR IF ST FUNC
FGBGADR  DC    A(FGBG20)
LOADR1R  DC    F'0'                    TO SAVE RETURN ADDR
*
***********************************************************************
*
*        COMPILER PROGRAM - CP64
*
***********************************************************************
*
*        OPENING BRACKET
*        CONTEXT              PROGRAM, STATEMENT, EXPRESSION
*        SOURCE OPERATOR      (
*        STACK OPERATOR       ANY
*        OPERAND              NONE OR PROCEDURE IDENTIFIER
*
         USING CP64,R12
CP64     TM    COMPFLGS,OPERAND        OPERAND ON ?
         BO    GDAE1                   YES, BRANCH
         C     R11,DECAADD             TEST CONTEXT
         BNE   GDAB3                   NOT PROGRAM CONTEXT, BRANCH
         BAL   R4,SERR3                ERROR
         DC    H'176'                  ERROR 176
*
         BAL   R4,STACKAPI             API TO OPERAND STACK
GDAE1    BAL   R4,MOVEOPTK             CURRENT CONTEXT OPERATOR TO R10
         MVC   0(1,R10),99(R11)
         C     R11,DECAADD             PROGRAM CONTEXT ?
         BE    GDAG1                   YES
         TM    0(R9),X'10'             PROC API ?
         BO    GDAG1                   YES
         TM    1(R9),X'03'             'TYPE' PROCEDURE ?
         BNZ   GDAG1                   YES
         BAL   R4,SERR3                NO, ERROR
         DC    H'168'                  ERROR 168
*
         B     GDAH11
*
GDAG1    L     R11,STC                 SWITCH TO STATEMENT CONTEXT
GDAH1    TM    1(R9),X'C0'             OPERAND PROCEDURE IDENTIFIER ?
         BNZ   GDAJ1                   YES
         BAL   R4,SERR3                NO, ERROR
         DC    H'183'                  ERROR 183
*
GDAH11   BAL   R4,MOVEOPDK             GET ONE R9 ENTRY
         B     GDBC2
*
GDAJ1    BAL   R4,MOVEOPDK             GET ONE R9 ENTRY
         TM    6(R9),X'40'             STANDARD PROCEDURE ?
         BZ    GDCA1                   YES
GDBA1    TM    5(R9),X'10'             PROC API ?
         BO    GDBA3                   YES
         TM    8(R9),X'F0'             NUMBER OF PARAMETERS ZERO ?
         BNZ   GDBA2                   NO
         TM    6(R9),X'30'             IS PROCED FORMAL PARAMETER
         BNM   GDBA1A                  NO, ERROR
         TM    6(R9),X'10'             CALLED BY NAME
         BO    GDBA3                   YES, OK
GDBA1A   BAL   R4,SERR1
         DC    H'187'                  ERROR 187
*
GDBB15   EQU   *
GDBC2    MVC   5(5,R9),API             API REPLACES NEXT LAST ST ENTRY
GDBA3    BAL   R4,MOVEOPDK             INCR OPERAND STACK
GDBA4    BAL   R4,LATRES               RESERVE ONE LAT ENTRY
GDBB4    MVC   8(2,R9),LN              LN TO R9
         MVC   0(2,R9),ZEROHW          SET PARAM NUMBER TO ZERO
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    GDBH4                   YES, BRANCH
         BAL   R4,CLEARRG              STORE ALL REGS USED
         MVC   GDBG45+2(2),LN          GENERATE BRANCH PAST THUNKS
         BAL   R2,GENTXT4              GENERATE 4 BYTES
GDBG45   L     ADR,0(LAT)              *** GENERATED CODE ***
         BAL   R2,GENTXT2              GENERATE 2 BYTES
         BR    ADR                     *** GENERATED CODE ***
GDBH4    ST    R6,WORKPL
         MVC   2(3,R9),WORKPL+1        PRPOINT TO R9
         MVI   1(R10),XFDELTA          PROCEDURE BRACKET TO R10
GDBH42   BAL   R4,MOVEOPTK             INCREASE R10
         BR    R5                      BRANCH TO SUBSTART
*
GDBA2    TM    5(R9),X'C0'             OPND IN REG OR OBJ TIME ST ?
         BM    GDBA3                   YES (NOT FORMAL PARAMETER)
         TM    6(R9),X'30'             OPND FORMAL PARAMETER ?
         BNM   GDBA3                   NO
         TM    6(R9),X'20'             YES, CALLED BY VALUE ?
         BZ    GDBA3                   NO
GDBB2    BAL   R4,SERR1                YES, ERROR
         DC    H'174'                  ERROR 174
*
         B     GDBB15
*
*        OPERAND IS STANDARD PROCEDURE ID
*
GDCA1    TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    GDCG1                   YES, BRANCH
         TM    9(R9),X'80'             ABS, SIGN, LENGTH, ENTIER ?
         BO    GDCC1                   YES
         IC    R15,9(R9)               MOVE 0-BIT
         N     R15,HEXFC                          INTO
         A     R15,LATAB                               CORR
         NI    0(R15),X'7F'                                 LAT ENTRY
GDCC1    STH   R7,HALFW                STORE P-VALUE IN R9
         MVC   3(2,R9),HALFW
         AH    R7,ONEENTRY             RESERVE SPACE FOR PARAM-LIST
         LA    R7,8(R7)
         STH   R7,WORKPL               CHECK FOR P-OVERFLOW
         BAL   R4,MAXCH
GDCG1    MVC   0(2,R9),ZEROHW          ZERO PARAM COUNT FIELD
         MVI   1(R10),X'2A'            STAND PROCEDURE BRACKET TO R10
         B     GDBH42
*
GDAB3    L     R11,EXC                 SWITCH TO EXPR CONTEXT
         BAL   R4,MOVEOPTK             SOURCE OPERATOR TO STACK
         MVC   0(1,R10),0(R8)
         BR    R5                      BRANCH TO SUBSTART
*
*        CONSTANT
*
         DC    0F'0'
HEXFC    DC    X'000000FC'             EXTRACT DISP IN LAT
*
***********************************************************************
*
*        COMPILER PROGRAM - CP71
*
***********************************************************************
*
*        STATEMENT END
*        CONTEXT              STATEMENT
*        SOURCE OPERATOR      EPSILON, ETA, END, ELSE, ;, S.E. STC
*                             (SEE MATRIX)
*        STACK OPERATOR       S.E. STC (SEE MATRIX)
*        OPERAND              NOT DECISIVE
*
         USING CP71,R12
CP71     L     R11,DECAADD             SWITCH TO PROGRAM CONTEXT
         B     COMP                    GOTO COMP
*
***********************************************************************
*
*        COMPILER PROGRAM - CP84
*
***********************************************************************
*
*        NOT PERMITTED OPERATOR PAIR
*        SOURCE AND STACK OPERATOR     SEE MATRIXES
*        OPERAND                       NONE OR ONE
*
         USING CP84,R12
CP84     BAL   R4,SERR1                TERMINATING ERROR
         DC    H'173'                  ERROR 173
*
         B     CPERR1                  BRANCH TO TERMINATION
*
***********************************************************************
*
*        END OF IEX50004
*
***********************************************************************
*
./ ADD NAME=IEX50005 0201-12230-12230-1200-01490-01490-00000-LEVEL
         TITLE 'IEX50 - COMPILATION PHASE - CP17'
*
*        CP17, CP18, CP26, CP27, CP28, CP29, CP30, CP31, CP63,
*        CP65, CP66, CP67, CP68, CP70, CP72, CP73, CP74, CP75,
*        CP76, CP77, CP78, CP79, CP80, CP86, CP87
*
***********************************************************************
*
*        COMPILER PROGRAM - CP17
*
***********************************************************************
*
*        IF STATEMENT WITH ALTERNATIVE
*        CONTEXT              PROGRAM
*        SOURCE OPERATOR      ELSE
*        STACK OPERATOR       THENS
*        OPERANDS             CASE I)   LABEL NUMBER
*                             CASE II)  PROCEDURE IDENTIFIER
*                                       LABEL NUMBER
*
         USING CP17,R12
CP17     TM    COMPFLGS,OPERAND        OPERAND ON ?
         BZ    BCB2                    NO, BRANCH
         BAL   R4,PLPRST               BRANCH TO PLPRST HANDLE
         LA    R9,5(,R9)               CLOPD
BCB2     MVI   0(R10),X'28'            STACK 'ELSES'
         MVI   GPBN+1,X'FF'            DESTROY GLOBAL PBN
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BOR   R5                      YES, RETURN TO SUBSTART
         BAL   R4,LATRES               RESERVE LABEL
         MVC   BCD2+2(2),LN            INTR LABEL NO AS DISPLACEMENT
         BAL   R2,GENTXT6              GENERATE 6 BYTES
BCD2     L     BRR,0(LAT,0)            *** GENERATED CODE ***
         BR    BRR                     *** GENERATED CODE ***
         L     R1,LATAB                LOAD ADDR OF LAT
         MVC   WORKPL(2),3(R9)         LOAD LABEL NUMBER
         LH    R2,WORKPL
         ST    R6,0(R1,R2)             STORE PRPOINTER INTO LAT
         MVC   3(2,R9),LN              KEEP NEW LABEL
         BR    R5                      RETURN TO SUBSTART
*
***********************************************************************
*
*        COMPILER PROGRAM - CP83
*
***********************************************************************
*
*        CODE PROCEDURE DECLARATION (IN CALLING PROGRAM)
*        CONTEXT              PROGRAM
*        SOURCE OPERATOR      GAMMA
*        STACK OPERATOR       PI, PHI, BETA
*        OPERANDS             LABEL NUMBER
*                             PROCEDURE IDENTIFIER
*
         USING CP83,R12
CP83     BAL   R4,DECOMP               DECOMPOSE OPERAND
         LH    R4,OPDLN                GET ADDR OF LAT ENTRY
         L     R15,LATAB
         ST    R6,0(R4,R15)            STORE PRPOINT IN LAT
         MVC   KOC15,1(R8)             PROCEDURE NAME TO GENER CODE
         LH    R15,SPBNST              GET CURRENT PBN
         SLL   R15,3                   DISP IN PBTAB TO GENER CODE
         STH   R15,KOC16
         LA    R2,KOC14
         BAL   R14,GENTXTS
         DC    H'14'                   GENERATE 14 BYTES
*
         OI    IOTAB+16,X'01'          ALL DATASETS MAY BE NEEDED
KOG1     LA    R8,8(,R8)               INCREASE SOURCE BY 8
         BR    R5                      RETURN TO SUBSTART
*
KOC14    BAL   ADR,LOADPP(FSA)         *** GENERATED CODE ***
KOC15    DC    CL8' '                  *** GENERATED CODE ***
KOC16    DC    H'0'                    *** GENERATED CODE ***
*
***********************************************************************
*
*        COMPILER PROGRAM - CP18
*
***********************************************************************
*
*        END OF CONDITIONAL STATEMENT
*        CONTEXT              PROGRAM
*        SOURCE OPERATOR      SEMICOLON,EPSILON, ETA, END
*        STACK  OPERATOR      ELSES
*        OPERANDS             CASE I)   LABEL NUMBER
*                             CASE II)  PROCEDURE IDENTIFIER
*                                       LABEL NUMBER
         USING CP18,R12
CP18     TM    COMPFLGS,OPERAND        OPERAND ON ?
         BZ    BEB2                    NO, BRANCH
         BAL   R4,PLPRST               BRANCH TO PLPRST HANDLE
         LA    R9,5(,R9)               CLOPD
         NI    COMPFLGS,255-OPERAND    RESET OPERAND
BEB2     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    BEE2                    YES, BRANCH
         MVC   WORKPL(2),3(R9)         LOAD LABEL NUMBER
         LH    R2,WORKPL
         L     R1,LATAB                LOAD ADDR OF LATAB
         ST    R6,0(R1,R2)             STORE PRPOINTER IN TO LAT
BEE2     LA    R9,5(,R9)               CLOPD
         MVI   GPBN+1,X'FF'            DESTROY GLOBAL DSA
         BCT   R10,COMP                CLOPT AND COMPARE
*
***********************************************************************
*
*        COMPILER PROGRAM - CP26
*
***********************************************************************
*
*        ERRONEOUS CASE
*        CONTEXT              PROGRAM
*        SOURCE OPERATOR      ARRAY, SWITCH, PHI, PI
*        STACK OPERATOR       .=, SEMICOLON,THENS, ELSES
*        OPERANDS
*
         USING CP26,R12
CP26     BAL   R4,ERR166               OPDT AND ERR 166/7
BUE2     BCTR  R10,0                   RELEASE ONE OPERATOR
         CLI   1(R10),X'1C'            'DO' ?
         BE    BUE3                    YES, BRANCH
         BL    BUG3                    BRANCH IF '= OR '
BUC3     LA    R9,5(,R9)               RELEASE ONE OPERAND
BUG4     B     COMP                    BRANCH TO COMPARE
*
BUE3     SR    R0,R0                   CLEAR 4 OPERANDS +
         TM    6(R9),X'02'
         LA    R9,20(,R9)
         BZ    COMP
         MVC   WORKPL(2),3(R9)
         LH    R0,WORKPL
         AR    R9,R0
         B     COMP
*
BUG3     CLI   1(R10),XFSCOLON         SEMICOLON ?
         BE    COMP                    YES, BRANCH
         B     BUC3                    ASSIGMENT, BRANCH
*
***********************************************************************
*
*        COMPILER PROGRAM - CP27
*
***********************************************************************
*
*        ERRONEOUS CASE
*        CONTEXT              PROGRAM, STATEMENT
*        SOURCE OPERATOR      SEE MATRICES
*        STACK OPERATOR       SEE MATRICES
*        OPERANDS             VARIABLE NUMBER OF OPERANDS ACCORDING TO
*                             THE OPERATOR
*
         USING CP27,R12
CP27     TM    COMPFLGS,OPERAND        OPERAND ON ?
         BZ    BWB2                    NO, BRANCH
         BAL   R4,SERR3
         DC    H'195'                  ERROR 195
*
         LA    R9,5(,R9)               RELEASE ONE OPERAND
         NI    COMPFLGS,255-OPERAND    RESET OPERAND
BNE2     BCTR  R10,0                   RELEASE ONE OPERATOR
         SR    R1,R1
         IC    R1,1(,R10)              LOAD OPERATOR IN R1
         SLL   R1,2                    MULTIPLY BY FOUR
         B     LISTE-24(R1)
LISTE    B     COMP                    LEFT BRACKET
         B     BWF4C                   COLON
         B     BWH3                    BRACKET
         B     BWJ3                    ARRAY
         B     BWJ41                   SWITCH
         B     BWJ41                   SEMICOLON
         B     BWJ41                   BEGIN
         B     BWJ41                   BETHA
         B     BWJ41                   PHI
         B     BWJ41
         B     BWJ41                   EQUAL
         B     BWJ41                   LESS
         B     BWJ41                   GREATER
         B     BWJ41                   NOTEQUAL
         B     BWJ41                   NOTGREATER
         B     BWJ41                   NOLLESS
         B     BWF4                    ASSIGMENT
         B     COMP                    GOTO
         B     BWK7                    FOR
         B     BWK5                    STEP
         B     BWK4                    UNTIL
         B     BWK5                    WHILE
         B     BWJ41                   DO
         B     COMP                    IF
         B     BWF4                    THEN
         B     BWJ41                   ELSE
         B     BWJ41                   NOT
         B     BWJ41                   IMPLICATION
         B     BWJ41                   OR
         B     BWJ41                   AND
         B     BWJ41                   EQUIVALENT
         B     BWJ41                   ALPHA
         B     COMP                    IFS
         B     BWJ41                   THENS
         B     BWJ41                   ELSES
         B     BWG3                    PARENT IN PROCEDURE
         B     BWG4                    PARENT IN STANDARD FUNCTION
         B     BWJ41                   MONODIC MINUS
         B     BWF4B                   BRACKET  RECL
         B     BWK6                    FOR.=
         B     BWK3                    SWITCH.=
*
BWK4     LA    R9,5(,R9)               CLOPT
BWK5     BCTR  R10,0                   CLOPT
BWK6     BCTR  R10,0                   CLOPT
BWK8     LA    R10,1(R10)              RESERVE ONE PLACE IN STACK
         MVI   0(R10),X'1C'            STACK 'DO'
         B     COMP                    BRANCH TO COMPARE
*
BWK7     BAL   R4,STACKAPI             STACK API
         B     BWK8
*
BWF4     LA    R9,5(,R9)               RELEASE ONE OPERAND
         B     COMP                    BRANCH TO COMPARE
*
BWH3     LA    R9,15(0,R9)             RELEASE THREE OPERANDS
         B     BWG31                   BRANCH
*
BWJ4     CLI   0(R8),XFSCOLON          SEMICOLON IN SOURCE ?
         BE    BWJ41
         B     COMP
*
BWG4     LA    R9,20(,R9)              RELEASE FOUR OPERANDS
         B     BWG31                   BRANCH
*
BWG3     SR    R0,R0                   RELEASE
         IC    R0,0(R9)                        N
         SLL   R0,8                              +
         IC    R0,1(R9)                            2
         LA    R9,10(R0,R9)                          OPERANDS
BWG31    TM    0(R10),X'30'            CHECK IF IN STACK CONT OPT
         BNO   COMP                    NO, BRANCH
         BCTR  R10,0                   RELEASE ONE OPERATOR
         L     R11,DECAADD             LOAD R11 WITH PROG CONT MA
         CLI   1(R10),X'30'            CHECK IF PROG CONT OPT
         BE    COMP                    BRANCH IF PCO TO COMPARE
         L     R11,STC                 LOAD R11 WITH STAT CONT MA
         CLI   1(R10),X'33'            CHECK IF STAT CONT OPT
         BE    COMP                    BRANCH IF STC TO COMPARE
         L     R11,EXC                 LOAD R11 WITH EXP CONT MAT
         B     COMP                    BRANCH TO COMPARE
*
BWK3     SR    R1,R1
         IC    R1,1(R9)                NO OF SWITCH ELEMENT OPERANDS
         LA    R9,20(R9,R1)            CLEAR OPERANDS
         B     COMP                    BRANCH TO COMPARE
*
BWF4C    BCTR  R10,0                   COLON
BWF4B    BCTR  R10,0                   ARRAY BRACKET
         LA    R9,15(R9)               RELEASE 3 OPERANDS
BWJ3     AH    R9,GREGN                CLEAR NUMBER OF ARRAY IDENT
         MVC   GREGN(2),ZEROHW         CLEAR COUNTER
         B     COMP
*
BWB2     BAL   R4,SERR3                ERROR PATTERN ENTRY
         DC    H'194'                  ERROR 194
*
         B     BNE2
*
BWJ41    L     R12,SCPTAB+4*84         R12 -> CP84
         BR    R12                     BRANCH TO CP84
*
***********************************************************************
*
*        COMPILER PROGRAM - CP28
*
***********************************************************************
*
*   ERRONEOUS CASE - DECLARATION IN WRONG  POSITION
*        CONTEXT              PROGRAM
*        SOURCE OPERATOR      S
*        STACK OPERATOR       SEE PROGRAM CONTEXT  MATRIX
*        OPERANDS             VARIABLE NUMBER OF OPERANDS ACCORDING TO
*                             THE OPERATOR
*
         USING CP28,R12
CP28     BAL   R4,ERR166
         BAL   R4,SCHDL                SEMICOLON HANDLING
         CLI   0(R10),XFCOLON          STACK OPERATOR COLON ?
         BE    BYF1                    YES
         CLI   0(R10),X'2C'            ARRAY BRACKET IN STACK
         BE    BYF1+2                  YES
         CLI   0(R10),X'0A'            SWITCH  IN STACK
         BE    BYF2                    YES
         BR    R5                      RETURN TO SUBSTART
*
BYF1     BCTR  R10,0                   RELEASE COLON
         SH    R10,KH2                 RELEASE BRACKET AND ARRAY
         LA    R9,15(R9)               RELEASE 3 OPERANDS
         AH    R9,GREGN                CLEAR NUMBER OF ARRAY IDENT
         MVC   GREGN(2),ZEROHW         CLEAR COUNTER
         BR    R5                      RETURN TO SUBSTART
*
BYF2     LA    R9,10(R9)               CLEAR TWO OPERANDS
         BCTR  R10,R5                  CLEAR SWITCH, SUBSTART
*
***********************************************************************
*
*        COMPILER PROGRAM - CP29
*
***********************************************************************
*
*        ERRONEOUS CASE  - BEGIN OF DECLARATION
*        CONTEXT              PROGRAM
*        SOURCE OPERATOR      ARRAY,SWITCH,PI,PHI
*        STACK OPERATOR       BEGIN, DO
*        OPERANDS             NONE OR ONE
*
         USING CP29,R12
CP29     BAL   R4,ERR166
CAF1     L     R12,SCPTAB+4*4          R12 -> CP4
         BR    R12                     BRANCH TO CP4
*
***********************************************************************
*
*        COMPILER PROGRAM - CP30
*
***********************************************************************
*
*        ERRONEOUS CASE  - LABEL IN INCORRECT POSITION
*        CONTEXT              PROGRAM
*        SOURCE OPERATOR      LABEL OPERATOR
*        STACK OPERATOR       SEE PROGRAM CONTEXT MATRIX
*        OPERANDS             LABEL IDENTIFIER
*
         USING CP30,R12
CP30     TM    COMPFLGS,OPERAND        OPERAND ON ?
         BZ    BKQB1                   NO, BRANCH
         BAL   R4,SERR2
         DC    H'169'                  ERRO 169
*
         LA    R9,5(,R9)               RELEASE ONE OPERAND
         BR    R5                      BRANCH TO SUBSTART
*
BKQB1    L     R12,SCPTAB+4*84         R12 -> CP84
         BR    R12                     BRANCH TO CP84
*
***********************************************************************
*
*        COMPILER PROGRAM - CP31
*
***********************************************************************
*
*        ERRONEOUS CASE  - INCORRECT CONBINATION OF OPERATORS IN
*                          PROGRAM CONTEXT
*        SOURCE OPERATOR      SEE PROGRAM CONTEXT MATRIX
*        STACK  OPERATOR      SEE PROGRAM CONTEXT MATRIX
*        OPERANDS             NONE OR ONE
*
         USING CP31,R12
CP31     LA    R11,614(,R11)           SWITCH TO EXPRESSION CONTEXT
         TM    COMPFLGS,OPERAND        OPERAND ON ?
         BZ    CEB2                    NO, BRANCH
         BAL   R4,SERR4
         DC    H'161'                  ERROR 161
*
         B     COMP                    BRANCH TO COMPARE
*
CEB2     BAL   R4,SERR4
         DC    H'160'                  ERROR 160
*
         B     COMP                    BRANCH TO COMPARE
*
***********************************************************************
*
*        COMPILER PROGRAM - CP63
*
***********************************************************************
*
*        MONADIC MINUS SIGN
*        CONTEXT              EXPRESSION
*        SOURCE OPERATOR      ALL EXCEPT 'NOT',C,1),'IF','POWER'
*        STACK OPERATOR       MONADIC MINUS
*        OPERANDS             ARITHMETIC OPERAND
*
         USING CP63,R12
CP63     LA    R4,GBD4                 LOAD RETURN ADD FOR ERROR
         BAL   R3,OPDTEST              OPDT AND ERROR NUMBER 162
         BAL   R4,ARRTEST1             ARRAY AND PROC TEST
         TM    1(R9),X'03'             OPERAND ARITHMETIC ?
         BM    GAD1                    YES, BRANCH
         TM    0(R9),APIMASK           OPERAND API ?
         BZ    GAC2                    NO, BRANCH
GBD4     BCT   R10,COMP                RELEASE 1 OPT AND COMPARE
GAD1     TM    COMPFLGS,COMPMODE+SUBSCOPT  SYNTAX OR SUBSC OPTIMIZED ?
         BNZ   GBD4                    NO, BRANCH
         BAL   R4,OPDREC               OPERAND RECOGNIZER
         TM    1(R9),X'02'             OPERAND REAL ?
         BZ    GBE1                    NO, INTEGER, BRANCH
         TM    0(R9),X'20'             OPERAND A VALUE ?
         BO    GAH3                    AN ADDR, BRANCH
         TM    0(R9),X'40'             OPERAND IN A REGISTER ?
         BO    GAH2                    NO, IN STORAGE, BRANCH
         IC    R14,3(R9)               INSERT
GBC5     STC   R14,GAJ1+1              REGISTER
         SRL   R14,4                   INTO
         STC   R14,WORKPL              GENERATED
         MVN   GAJ1+1(1),WORKPL
         BAL   R2,GENTXTP2             GENERATE 2 BYTES
GAJ1     LCDR  0,0                     *** GENERATED CODE ***
GAJ11    OI    0(R9),X'08'             INSERT NO ASSIGMENT BIT
         BCT   R10,COMP                DELEASE OPERATOR AND COMP
GAH2     TM    0(R9),X'80'             LO IN A REG BEFORE ?
         BO    GAH3                    NO, BRANCH
         SH    R7,ONEENTRY             RELEASE 1 OBJ STACK ENTRY
GAH3     BAL   R4,ROUTIN11             RESERVE A FLOATING POINT REG
         SH    R9,KH5                  INCREASE OPERAND STACK
         TM    5(R9),X'20'             LO A VALUE ?
         BZ    GBC2                    YES, BRANCH
         BAL   R4,ROUTINE2             CALL ROUTINE NUMBER 2
GBC4     LA    R9,5(,R9)               DECREASE OPERAND STACK
         SLL   R14,4
         B     GBC5                    BRANCH
*
GBC2     BAL   R4,ROUTINE4             GENERATE LOADING INTO FPR
         B     GBC4                    BRANCH
*
GBE1     TM    0(R9),X'20'             OPERAND A VALUE ?
         BO    GBF3                    ADDR, BRANCH
         TM    0(R9),X'40'             OPERAND IN A REGISTER ?
         BO    GBF2                    IN STORAGE, BRANCH
         IC    R14,3(R9)               INSERT
GBG11    STC   R14,GBG1+1              REGISTER
         SRL   R14,4                   INTO
         STC   R14,WORKPL              GENERATED
         MVN   GBG1+1(1),WORKPL        CODE
         BAL   R2,GENTXT2              GENERATE 2 BYTES
GBG1     LCR   0,0                     *** GENERATED CODE ***
         B     GAJ11
*
GBF2     TM    0(R9),X'80'             LO IN A REG BEFORE ?
         BO    GBF3                    DECREASE
         SH    R7,ONEENTRY             RELEASE 1 OBJ STACK ENTRY
GBF3     BAL   R4,ROUTINE7             RESERVE GENERAL PURPOSE REG
         SH    R9,KH5                  INCREASE OPERAND STACK
         TM    5(R9),X'20'             LO A VALUE ?
         BO    GBH5                    AN ADDR, BRANCH
         BAL   R4,ROUTINE5             GENERATE LOADING INTO GPR
GBK4     LA    R9,5(,R9)               DECREASE OPERAND STACK
         SLL   R14,4                   SHIFT REGISTER NUMBER
         B     GBG11                   BRANCH
*
GBH5     BAL   R4,ROUTINE6             GENERATE LOADING INTO GPR
         B     GBK4                    BRANCH
*
GAC2     BAL   R4,SERR2
         DC    H'163'                  ERROR 163
*
GAC4     MVC   0(5,R9),API             MOVE API
         BCT   R10,COMP                RELEASE OPERATOR AND COMP
*
***********************************************************************
*
*        COMPILER PROGRAM - CP65
*
***********************************************************************
*
*        HANDLING OF 'NOT' AND 'IF'
*        CONTEXT              EXPRESSION
*        SOURCE OPERATOR      CASE I 'NOT'
*                             CASE II 'IF'
*
*        STACK OPERATOR       CASE I  ALL EXCEPT  'NOT',ARITHMETICAL
*                                     OPERATORS,RELATIONAL OPERATORS
*        CASE II 'IF','IFS'
*
*        OPERANDS             NONE
*
         USING CP65,R12
CP65     TM    COMPFLGS,OPERAND        OPERAND ON ?
         BZ    GFC2                    NO, BRANCH
         BAL   R4,SERR4
         DC    H'164'                  ERROR 164
*
         LA    R9,5(,R9)               RELEASE ONE OPERAND
GFC2     BAL   R4,MOVEOPTK             INCREASE OPT STACK POINTER
         MVC   0(1,R10),0(R8)          INSERT SOURCE INTO STACK
         BR    R5                      RETURN TO SUBSTART
*
***********************************************************************
*
*        COMPILER PROGRAM - CP66
*
***********************************************************************
*
*        HANDLING OF PLUS AND MINUS
*        CONTEXT              EXPRESSION
*        SOURCE OPERATOR      +,-
*        STACK  OPERATOR      ALL EXCEPT ARITHMETIC  OPERATORS
*        OPERANDS             NONE OR ONE ARITHMETIC OPERAND.
*
         USING CP66,R12
CP66     BAL   R4,MOVEOPTK                   INCREASE OPT STACK POINTER
         TM    COMPFLGS,OPERAND              OPDT
         BZ    GHC2                          BRANCH IF FALSE
         MVC   0(1,R10),0(R8)                INSERT SOURCE INTO STACK
         BR    R5                            BRANCH TO SNOT
GHC2     CLI   0(R8),XFMINUS                 MINUS IN SOURCE ?
         BNE   GHC3                          NO, BRANCH
         MVI   0(R10),X'2B'                  STACK MONADIC MINUS
         BR    R5                            BRANCH TO SUBSTART
*
GHC3     MVI   SWVAL,X'FF'                   SET SWITCH TO ONE
         BCTR  R10,0                         DECREASE OPT STACK POINTER
GHC4     CLI   1(R8),XFZETA                  END OF SOURCE BUFFER ?
         BL    GHC5                          BRANCH IF OPERATOR
         BHR   R5                            OPERAND, BR TO SUBSTART
         BAL   R4,JBUFFER
         B     GHC4
*
GHC5     CLI   1(R8),XFLBRAC                 LEFT BRACKET IN SOURCE ?
         BER   R5                            YES, BRANCH TO SUBSTART
         BAL   R4,SERR4                      ERROR PATTERN ENTRY
         DC    H'160'                        ERROR 160
*
         BR    R5                            BRANCH TO SUBSTART
*
***********************************************************************
*
*        COMPILER PROGRAM - CP67
*
***********************************************************************
*
*        STACKING OF ARITHMETIC, RELATIONAL OR BOOLEAN OPERATORS
*        CONTEXT              EXPRESSION
*        SOURCE OPERATOR      SEE EXPRESSION CONTEXT  MATRIX
*        STACK  OPERATOR      SEE EXPRESSION CONTEXT  MATRIX
*        OPERANDS             ONE OPERAND
*
         USING CP67,R12
CP67     TM    COMPFLGS,OPERAND        OPERAND ON ?
         BZ    GJC2                    NO, BRANCH
         BAL   R4,MOVEOPTK             INCREASE OPT STACK POINTER
         MVC   0(1,R10),0(R8)          INSERT SOURCE INTO STACK
         CLI   0(R10),XFPOWER          OPT POWER ?
         BNER  R5                      NO, RETURN TO SUBSTART
         MVI   SWVAL,0                 SET SWITCH TO ZERO
         BR    R5                      RETURN TO SUBSTART
*
GJC2     BAL   R4,SERR4                ERROR PATTERN ENTRY
         DC    H'162'                  ERROR 162
*
         BR    R5                      RETURN TO SUBSTART
*
***********************************************************************
*
*        COMPILER PROGRAM - CP68
*
***********************************************************************
*
*        OPENING AND CLOSING PARENTHESIS
*        CONTEXT              EXPRESSION
*        SOURCE OPERATOR      )
*        STACK OPERATOR       (
*        OPERANDS             ONE
*
         USING CP68,R12
CP68     LA    R4,GLF2                 LOAD RETURN ADDR
         BAL   R3,OPDTEST              OPDT AND ERROR 162
GLF2     BCT   R10,SPECTEST            RELEASE OPT AND SPECIAL TEST
*
***********************************************************************
*
*        COMPILER PROGRAM - CP70
*
***********************************************************************
*
*        CONTEXT SWITCH,EXPRESSION CONTEXT
*        CONTEXT              EXPRESSION
*        SOURCE OPERATOR      ),'ELSE' ALL OPERATORS NOT SPECIFIED IN
*                             EXPRESSION CONTEXT
*        STACK OPERATOR       ALL OPERATORS NOT SPECIFIED IN
*                             EXPRESSION CONTEXT
*        OPERANDS             NOT TREATED
*
         USING CP70,R12
CP70     SH    R11,KH324               SWITCH TO STMT  CONTEXT
         B     COMP                    BRANCH TO COMPARE
*
***********************************************************************
*
*        COMPILER PROGRAM - CP72
*
***********************************************************************
*
*        NESTED CONDITIONAL EXPRESSIONS
*        CONTEXT              EXPRESSION
*        SOURCE OPERATOR      'ELSE'
*        STACK OPERATOR       'ELSE'
*        OPERANDS             NOT TR
*
         USING CP72,R12
CP72     BCTR  R10,0                   DECREASE OPT STACK POINTER
         CLI   0(R10),XFASSIGN         OPT ASSIGMENT ?
         BE    JAF2                    YES, BRANCH
         CLI   0(R10),XFGOTO           OPT GOTO ?
JAF2     LA    R10,1(,R10)             INCR OPT STACK POINTER
         L     R12,SCPTAB+4*75         R12 -> CP75
         BNE   0(R12)                  NOT ASSIGMENT, BRANCH
         L     R12,SCPTAB+4*79         R12 -> CP79
         BR    R12                     BRANCH TO CP79
*
***********************************************************************
*
*        COMPILER PROGRAM - CP73
*
***********************************************************************
*
*        ERRONEOUS CASE - THE OPENING PARENTHESIS IS MISSING IN
*                         A CONDITIONAL EXPRESSION
*        CONTEXT              EXPRESSION
*        SOURCE OPERATOR      'IF'
*        STACK OPERATOR       SEE EXPRESSION CONTEXT MATRIX
*        OPERANDS             NONE OR ONE
*
         USING CP73,R12
CP73     TM    COMPFLGS,OPERAND        OPERAND ON ?
         BZ    JGB2                    NO, BRANCH
         BAL   R4,SERR4                ERROR PATTERN ENTRY
         DC    H'161'                  ERROR 161
*
         LA    R9,5(,R9)               RELEASE ONE OPERAND
JGE1     BAL   R4,MOVEOPTK             INCR OPT POINTER
         MVI   0(R10),XFLBRAC          INSERT '(' INTO STACK
         BAL   R4,MOVEOPTK             INCR OPT POINTER
         MVC   0(1,R10),0(R8)          INSERT SOURCE INTO STACK
         BR    R5                      BRANCH TO SUBSTART
*
JGB2     BAL   R4,SERR4                ERROR PATTERN ENTRY
         DC    H'160'                  ERROR 160
*
         B     JGE1
*
***********************************************************************
*
*        COMPILER PROGRAM - CP74
*
***********************************************************************
*
*        ERRONEOUS CASE - CONBINATION OF TWO RELATIONAL OPERATORS
*        CONTEXT              EXPRESSION
*        SOURCE OPERATORS     RELATIONAL OPERATOR
*        STACK OPERATORS      RELATIONAL OPERATOR
*        OPERANDS             NONE OR ONE
*
         USING CP74,R12
CP74     TM    COMPFLGS,OPERAND        OPERAND ON ?
         BZ    JIB2                    NO, BRANCH
         BAL   R4,SERR4                ERROR PATTERN ENTRY
         DC    H'161'                  ERROR 161
*
JIF2     BAL   R4,MOVEOPTK             INCR OPT POINTER
         MVI   0(R10),XFASTER          INSERT * INTO STACK
         BR    R5                      BRANCH TO SUBSTART
*
JIB2     BAL   R4,SERR4                ERROR PATTERN ENTRY
         DC    H'160'                  ERROR 160
*
         BAL   R4,STACKAPI             STACK ALL PURPOSE IDENT
         B     JIF2
*
***********************************************************************
*
*        COMPILER PROGRAM - CP74
*
***********************************************************************
*
*        ERRONEOUS CASE - NOT PERMITED OPERATOR PAIR WHERE THE STACK
*                         OPERATOR IS ASSUMED TO BE THE CORRECT ONE
*        CONTEXT              PROGRAM, STATEMENT, EXPRESSION
*        SOURCE OPERATOR      SEE CONTEXT MATRICES
*        STACK OPERATOR       SEE CONTEXT MATRICES
*        OPERANDS             NONE OR ONE
*
         USING CP75,R12
CP75     TM    COMPFLGS,OPERAND        OPERAND ON ?
         BZ    JKB2                    NO, BRANCH
         BAL   R4,SERR3                ERROR PATTERN ENTRY
         DC    H'195'                  ERROR 195
*
         LA    R9,5(,R9)               RELEASE ONE OPERAND
         BR    R5                      BRANCH TO SUBSTART
*
JKB2     BAL   R4,SERR3                ERROR PATTERN ENTRY
         DC    H'194'                  ERROR 194
*
         BR    R5                      BRANCH TO SUBSTART
*
***********************************************************************
*
*        COMPILER PROGRAM - CP76
*
***********************************************************************
*
*        BOOLEAN OPERATIONS
*        CONTEXT              EXPRESSION
*        SOURCE OPERATOR      SEE EXPRESSION CONTEXT MATRIX
*        STACK  OPERATOR      SEE EXPRESSION CONTEXT MATRIX
*        OPERAND              TWO OPERANDS
*
         USING CP76,R12
CP76     LA    R4,JRF41
         BAL   R3,OPDTEST              OPDT AND ERROR 162
         BAL   R4,ARRTEST2
         TM    6(R9),X'03'             BLO BOOLEAN ?
         BNO   JMC2                    NO, BRANCH
         TM    1(R9),X'03'             LO BOOLEAN ?
         BNO   JMC3                    NO, BRANCH
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    JRF41                   YES, BRANCH
         BAL   R4,OPDREC               OPERAND RECOGNIZER (LO)
         LA    R9,5(,R9)               DECREASE OPERAND POINTER
         BAL   R4,OPDREC               OPERAND RECOGNIZER (BLO)
         SH    R9,KH5                  INCREASE OPERAND POINTER
         TM    5(R9),X'A0'             BLO A VALUE OR IN STACK ?
         BNZ   JOB1                    NO, BRANCH
         MVC   YPLACE(2),8(R9)         Y = DISP(BLO)
         OI    YPLACE,X'A0'            X = CDSA
JNE1     TM    0(R9),X'20'             LO A VALUE ?
         BO    JNE5                    NO, BRANCH
         TM    0(R9),X'80'             LO IN STACK ?
         BO    JNF2                    NO, BRANCH
         MVC   WPLACE(2),3(R9)         W = DISP(LO)
         OI    WPLACE,X'A0'            V = CDSA
JRB3     MVC   JRC3+2(2),YPLACE        PREPARE INSTRUCTION
         MVC   JRC3+4(2),WPLACE
         TM    0(R10),X'02'            OPT 'IMPL' OR 'EQUIV' ?
         BZ    JRC4                    YES, BRANCH
         TM    0(R10),X'01'            OPT AND ?
         BO    JRC2                    YES, BRANCH
JRC22    MVI   JRC3,X'D6'              PREPARE INSTRUCTION
JRC21    BAL   R2,GENTXT6              GENERATE 6 BYTES
JRC3     OC    0(1,0),0(0)             *** GENERATED CODE ***
JRF4     NI    YPLACE,X'0F'            CLEAR REGISTER NUMBER
         LH    R7,YPLACE               LOAD VALUE OF OBJ ST POINT
         OI    5(R9),X'08'             INSERT NO-ASSIGNMENT BIT
JRF41    LA    R9,5(,R9)               CLOPD
JRG4     BCT   R10,COMP                CLOPT AND COMPARE
JRC2     MVI   JRC3,X'D4'              INSERT OPER CODE INTO CODE
         B     JRC21
*
JRC4     MVC   JRC41+2(2),JRC3+2       PREPARE INSTRUCTION
         BAL   R2,GENTXT4              GENERATE 4 BYTES
JRC41    XI    0(0),X'01'              *** GENERATED CODE ***
         CLI   0(R10),X'21'            OPT EQUIV ?
         BE    JRC22                   YES, BRANCH
         MVI   JRC3,X'D7'              INSERT OPER-CODE INTO CODE
         B     JRC21
*
JNF2     TM    2(R9),X'FF'             LO A CONSTANT ?
         BNZ   JNF4                    NO, BRANCH
JSB3     MVC   JSE3+1(1),4(R9)         PREPARE INTRUCTION
         NI    JSE3+1,X'01'
         MVC   JSE3+2(2),YPLACE
         TM    0(R10),X'02'            WHICH OPT
         BZ    JSE4                    EQU OR IMPL, BRANCH
         TM    0(R10),X'01'            OPT AND ?
         BO    JSE2                    YES, BRANCH
JSE22    MVI   JSE3,X'96'              PREPARE INSTRUCTION
JSE21    BAL   R2,GENTXT4              GENERATE 4 BYTES
JSE3     OI    0(0),X'00'              *** GENERATED CODE ***
         B     JRF4
*
JSE2     MVI   JSE3,X'94'              PREPARE INSTRUCTION
         B     JSE21
*
JSE4     MVC   JSE41+2(2),JSE3+2       PREPARE INSTRUCTION
         BAL   R2,GENTXT4              GENERATE 4 BYTES
JSE41    XI    0(0),X'01'              *** GENERATED CODE ***
         CLI   0(R10),X'21'            OPT EQUIV ?
         BE    JSE22                   YES, BRANCH
         MVI   JSE3,X'97'              PREPARE INSTRUCTION
         B     JSE21
*
JNF4     BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1
JNF41    MVZ   WPLACE(1),VPLACE        PREPARE W-V-PLACE
         B     JRB3
*
JNE5     BAL   R4,ROUTINE3             CALL ROUTINE NUMBER 3
         B     JNF41
*
JOB1     TM    0(R9),X'A0'             LO A VALUE AND IN STACK ?
         BNZ   JOC2                    NO, BRANCH
         MVC   YPLACE(2),3(R9)         Y= DISPL(LO)
         OI    YPLACE,X'A0'            X=CDSA
         CLI   0(R10),X'21'            OPT IMPL ?
         BNE   JOE2                    NO, BRANCH
         AH    R7,ONEENTRY             RESERVE OBJECT STACK ENTRY
         STH   R7,WORKPL               CHECK MAX
         BAL   R4,MAXCH
         MVC   JOG1+4(2),YPLACE        PREPARE INSTRUCTION
         MVC   JOG1+2(2),WORKPL
         OI    JOG1+2,X'A0'
         BAL   R2,GENTXT6              GENERATE 6 BYTES
JOG1     MVC   0(1,CDSA),0(0)          *** GENERATED CODE ***
         MVC   3(2,R9),WORKPL          ADJUST OPERAND
         B     JPB1
*
JOE2     MVC   WORKPL(5),0(R9)         CHANGE LO AND BLO
         MVC   0(5,R9),5(R9)
         MVC   5(5,R9),WORKPL
         B     JNE1
*
JOC2     AH    R7,ONEENTRY             INCREASE P
         STH   R7,WORKPL               CHECK MAX
         BAL   R4,MAXCH
         STH   R7,YPLACE               Y = DISPL
         OI    YPLACE,X'A0'            X = CDSA
JPB1     TM    5(R9),X'20'             BLO A VALUE ?
         BO    JQB2                    AN ADDR, BRANCH
         TM    7(R9),X'FF'             BLO A CONSTANT ?
         BNZ   JQB2                    NO, BRANCH
         MVC   JQE1+1(1),9(R9)         PREPARE INSTRUCTION
         NI    JQE1+1,X'01'
         MVC   JQE1+2(2),YPLACE
         BAL   R2,GENTXT4              GENERATE 4 BYTES
JQE1     MVI   0(CDSA),X'00'           *** GENERATED CODE ***
         OI    6(R9),X'30'             ADJUST R9 ENTRY OF BLO
JQE2     NI    5(R9),X'5F'
         MVC   7(1,R9),SPBNST+1
         MVC   8(2,R9),YPLACE
         NI    8(R9),X'0F'
         B     JNE1
*
JMC2     BCTR  R10,0                   DECR OPT ST POINTER
         BAL   R4,SERR2                ERROR PATTERN ENTRY
         DC    H'182'                  ERROR 182
*
         LA    R10,1(,R10)             INCR OPT ST POINT
JMC31    MVC   5(5,R9),API             INSERT ALL PURPOSE IDENT
         B     JRF41
*
JMC3     BAL   R4,SERR2                ERROR PATTERN ENTRY
         DC    H'182'                  ERROR 182
*
         B     JMC31
*
JQB2     LA    R9,5(,R9)               INCREASE R9
         TM    0(R9),X'20'             BLO A VALUE ?
         BO    JQB4
         BAL   R4,ROUTINE1             LOAD W-V-PLACE FOR VALUE
JQD3     SH    R9,KH5                  INCREASE OPERAND ST POINTER
         MVC   JQE3+2(2),YPLACE        PREPARE INSTRUCTION
         MVC   JQE3+4(2),WPLACE
         MVZ   JQE3+4(1),VPLACE
         BAL   R2,GENTXT6              GENERATE 6 BYTES
JQE3     MVC   0(1,0),0(0)             *** GENERATED CODE ***
         B     JQE2
*
JQB4     BAL   R4,ROUTINE3
         OI    0(R9),X'40'             ADJUST OPERAND
         B     JQD3
*
***********************************************************************
*
*        COMPILER PROGRAM - CP77
*
***********************************************************************
*
*        LOGICAL OPERATION NOT
*        CONTEXT              EXPRESSION
*        SOURCE OPERATOR      ALL EXCEPT 'NOT',(,(/,'IF',ARITHMETIC
*                             AND RELATIONAL OPERATORS
*        STACK OPERATOR       'NOT'
*        OPERANDS             ONE BOOLEAN
*
         USING CP77,R12
CP77     LA    R4,JWB2                 LOAD RETURN ADDR
         BAL   R3,OPDTEST              OPDT AND ERROR 162
         BAL   R4,ARRTEST1             ARRAY AND PROC TEST
         TM    1(R9),X'03'             OPERAND BOOLEAN ?
         BO    JWD1                    YES, BRANCH
         BAL   R4,SERR2                ERROR PATTERN ENTRY
         DC    H'182'                  ERROR 182
*
JWC4     MVC   0(5,R9),API             INTRODUCE API
JWK3     BCT   R10,COMP                RELEASE OPERATOR AND COMP
JWD1     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    JWK3                    YES, BRANCH
         BAL   R4,OPDREC               OPERAND RECOGNIZER
         TM    0(R9),X'20'             OPERAND A VALUE ?
         BO    JWF2                    AN ADDR, BRANCH
         TM    2(R9),X'FF'             OPERAND A VARIABLE ?
         BZ    JWH1                    CONSTANT, BRANCH
         TM    0(R9),X'80'             OPERAND IN OBJ STACK ?
         BO    JWG3                    NO, BRANCH
JWH21    MVC   JWH2+2(2),3(R9)         PREPARE INSTRUCTION
         OI    JWH2+2,X'A0'            INTRODUCE CDSA
         BAL   R2,GENTXT4              GENERATE 4 BYTES
JWH2     XI    0(CDSA),X'01'           *** GENERATED CODE ***
JWH3     OI    0(R9),X'08'             INSERT NO ASSIGMENT BIT
JWB2     BCT   R10,COMP                RELEASE OPERATOR AND COMP
JWG3     BAL   R4,ROUTINE1             LOAD W-V-PLACE FOR VALUE
JWG31    AH    R7,ONEENTRY             RESERVE OBJECT STACK ENTRY
         STH   R7,WORKPL               STORE P INTO WORKPL
         BAL   R4,MAXCH                CHECK MAXIMUM
         NI    0(R9),X'5F'             ADJUST OPERAND
         MVC   3(2,R9),WORKPL          INSERT OBJ STACK DISPLACEMENT
         MVC   2(1,R9),SPBNST+1        INSERT BLOCK NUMBER
         MVC   JWJ3+2(2),WORKPL        PREPARE INSTRUCTION
         OI    JWJ3+2,X'A0'            INSERT CDSA
         MVC   JWJ3+4(2),WPLACE        INSERT W-PLACE
         MVZ   JWJ3+4(1),VPLACE        INSERT V-PLACE
         BAL   R2,GENTXT6              GENERATE 6 BYTES
JWJ3     MVC   0(1,CDSA),0(0)          *** GENERATED CODE ***
         B     JWH21
*
JWH1     AH    R7,ONEENTRY             INCREASE P
         STH   R7,WORKPL               STORE P INTO WORKPL
         BAL   R4,MAXCH                CHECK MAXIMUM
         MVC   JWK1+2(2),WORKPL        PREPARE INSTRUCTION
         OI    JWK1+2,X'A0'            INSERT CDSA
JWK11    MVI   JWK1+1,X'00'            INSERT FALSE
         TM    4(R9),X'01'             CONSTANT TRUE ?
         BO    JWK12                   YES, BRANCH
         MVI   JWK1+1,X'01'            INSERT TRUE
JWK12    BAL   R2,GENTXT4              GENERATE 4 BYTES
JWK1     MVI   0(CDSA),X'00'           *** GENERATED CODE ***
         MVC   3(2,R9),WORKPL          INSERT OBJ DISPLACEMENT
         NI    0(R9),X'5F'             ADJUST OPERAND
         OI    1(R9),X'30'             SET OPERAND AS VARIABLE
         MVC   2(1,R9),SPBNST+1        INSERT BLOCK NUMBER
         B     JWH3
*
JWF2     BAL   R4,ROUTINE3             LOAD V-W-PLACE FOR ADDR
         OI    0(R9),X'40'             ADJUST OPERAND
         B     JWG31
*
***********************************************************************
*
*        COMPILER PROGRAM - CP78
*
***********************************************************************
*
*        IF CLAUSE
*        CONTEXT              EXPRESSION
*        SOURCE OPERATOR      'THEN'
*        STACK OPERATOR       'IF','IFS'
*        OPERANDS             BOOLEAN OPERANDS
*
         USING CP78,R12
CP78     LA    R4,JZB1
         BAL   R3,OPDTEST              OPDT AND ERROR 162
         BAL   R4,ARRTEST1
         TM    1(R9),X'03'             OPERAND BOOLEAN ?
         BO    JYD1                    YES, BRANCH
         BAL   R4,SERR2                ERROR PATTERN ENTRY
         DC    H'182'                  ERROR NR 182
*
JZB1     CLI   0(R10),X'26'            OPERATOR IFS
         MVC   0(1,R10),0(R8)          INSERT SOURCE INTO STACK
         BNER  R5                      NO, BRANCH TO SUBSTART
         MVI   0(R10),X'27'            INSERT THENS INTO STACK
         SH    R11,KH614               SWITCH TO PROGRAM CONTEXT
         BR    R5                      BRANCH TO SUBSTART
*
JYD1     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    JZB1                    YES, BRANCH
         BAL   R4,OPDREC               OPERAND RECOGNIZER
         TM    0(R9),X'20'             OPERAND A VALUE ?
         BO    JYF2                    AN ADDR, BRANCH
         TM    0(R9),X'80'             OPERAND IN OBJECT STACK ?
         BO    JYH12                   NO, BRANCH
         SH    R7,ONEENTRY             RELEASE OBJ STACK ENTRY
JYH12    BAL   R4,ROUTINE1             LOAD V-W-PLACE FOR VALUE
JYH11    MVC   JYH1+2(2),WPLACE        INTRODUCE DISPLACEMENT
         MVZ   JYH1+2(1),VPLACE        INSERT V-PLACE INTO CODE
         BAL   R2,GENTXT4              GENERATE 4 BYTES
JYH1     TM    0(0),X'FF'              *** GENERATED CODE ***
         BAL   R4,LATRES               RESERVE LABEL
         MVC   3(2,R9),LN              INSERT LABEL INTO OPERAND
         MVC   JYJ3+2(2),LN            INSERT LABEL INTO CODE
         BAL   R2,GENTXT6              GENERATE 6 BYTES
JYJ3     L     BRR,0(LAT,0)            *** GENERATED CODE ***
         BZR   BRR                     *** GENERATED CODE ***
         B     JZB1
*
JYF2     BAL   R4,ROUTINE3             LOAD W-V-PLACE FOR ADDR
         B     JYH11
*
***********************************************************************
*
*        COMPILER PROGRAM - CP78
*
***********************************************************************
*
*        END OF CONDITIONAL EXPRESSION
*        CONTEXT              EXPRESSION
*        SOURCE OPERATOR      SEE EXPTESSION CONTEXT  MATRIX
*        STACK OPERATOR       'ELSE'
*        OPERANDS             TWO OPERANDS AND ONE LABEL
*
         USING CP79,R12
CP79     LA    R4,KBB2                 LOAD RETURN ADDR
         BAL   R3,OPDTEST              OPDT AND ERROR 162
         BAL   R4,ARRTEST1
         TM    1(R9),X'03'             LO BOOLEAN ?
         BO    KBD1                    YES, BRANCH
         BM    KCB11
         TM    1(R9),X'08'             LO A LABEL ?
         BZ    KFB2                    NO, BRANCH
         TM    6(R9),X'08'             BLD A LABEL ?
         BZ    KBD2                    NO, BRANCH
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    KBD31                   YES, BRANCH
         BAL   R4,OPDREC
         TM    1(R9),X'40'
         BO    KBD2
         TM    3(R9),X'80'
         BO    KBH1                    YES, BRANCH
KFE1     MVC   KFE11+2(2),3(R9)        PREPARE INSTRUCTION
         OI    RII,X'01'
         SR    R15,R15                 PREPARE INSTRUCTION
         IC    R15,2(R9)
         SLL   R15,3
         STH   R15,WORKPL
         MVC   KFE12+2(2),WORKPL
         LA    R2,KFE11
         BAL   R14,GENTXTS
         DC    H'8'                    GENERATE 8 BYTES
*
         B     KBH1
*
KFE11    L     ADR,0(LAT,0)            *** GENERATED CODE ***
KFE12    L     GDSA,0(PBT,0)           *** GENERATED CODE ***
*
KFB2     BAL   R4,SERR1
         DC    H'178'                  ERROR 178
*
         B     KBD3
*
KBB2     LA    R9,10(,R9)              CLEAR TWO OPERANDS
KBD4     MVC   0(5,R9),API             INTRODUCE API
KBJ4     BCT   R10,COMP                CLOPT AND COMPARE
KBD1     TM    6(R9),X'03'             BLO BOOLEAN ?
         BO    KBE1                    YES, BRANCH
         TM    0(R9),APIMASK           LO AN API ?
         BO    KBD3                    YES, BRANCH
KBD2     BAL   R4,SERR1
         DC    H'165'                  ERROR 165
*
KBD3     LA    R9,10(,R9)              CLEAR TWO OPERANDS
         B     KBD4
*
KBE1     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    KBD31                   YES, BRANCH
         BAL   R4,OPDREC               OPERAND RECOGNIZER
         TM    0(R9),X'20'
         BO    KBF4
         TM    0(R9),X'80'             LO IN STACK ?
         BO    KBF3                    NO, BRANCH
         CLC   3(2,R9),8(R9)           LO AND BLO IN=PLACE ?
         BNE   KBG2                    NO, BRANCH
KBH1     MVC   WORKPL(2),8(R9)         LOAD LAST P
         NI    WORKPL,X'0F'
         LH    R7,WORKPL
KBH11    MVC   WORKPL(2),13(R9)        TRANSFER PRPOINT TO LAT
         LH    R15,WORKPL              ENTRY INDICATED BY R9+13
         L     R14,LATAB
         ST    R6,0(R14,R15)
KBD31    MVC   10(5,R9),5(R9)          C(R9+10)=C(R9+5)
         LA    R9,10(,R9)              CLEAR TWO OPERANDS
         MVI   GPBN+1,X'FF'
         OI    0(R9),X'08'
         BCT   R10,COMP                CLOPT AND COMPARE
KBG2     MVC   KBG21+4(2),3(R9)        PREPARE INSTRUCTION
         OI    KBG21+4,X'A0'
KBG22    MVC   KBG21+2(2),8(R9)
         OI    KBG21+2,X'A0'
         BAL   R2,GENTXT6              GENERATE 6 BYTES
KBG21    MVC   0(1,CDSA),0(CDSA)       *** GENERATED CODE ***
         B     KBH1
*
KBF3     TM    2(R9),X'FF'             LO A CONSTANT ?
         BZ    KBG3                    YES, BRANCH
         BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1
KBH3     MVC   KBG21+4(2),WPLACE       PREPARE INSTRUCTION
         MVZ   KBG21+4(1),VPLACE
         B     KBG22
*
KBF4     BAL   R4,ROUTINE3             CALL ROUTINE NUMBER 3
         B     KBH3
*
KBG3     MVC   KBG31+1(1),4(R9)        PREPARE INSTRUCTION
         NI    KBG31+1,X'01'
         MVC   KBG31+2(2),8(R9)
         OI    KBG31+2,X'A0'
         BAL   R2,GENTXT4              GENERATE 4 BYTES
KBG31    MVI   0(CDSA),X'00'           *** GENERATED CODE ***
         B     KBH1
*
KCB11    TM    5(R9),X'40'
         BZ    KCB1
         MVZ   8(1,R9),10(R9)
         SR    R14,R14
         LA    R15,1
         XI    5(R9),X'C0'
         IC    R14,8(R9)
         SRL   R14,4
         TM    6(R9),X'02'
         BZ    KCB12
         STC   R14,CIR+1
         SRL   R14,1
         SLL   R15,0(R14)
         STC   R15,KCE112+1            SET OR MASK
KCE112   OI    RIR+1,X'00'
         B     KCB1
*
KCB12    SLL   R15,0(R14)
         STC   R15,KCB13+1
KCB13    OI    RII+1,X'00'
         STC   R14,CII+1
KCB1     TM    6(R9),X'03'             BLO REAL OR INTEGER ?
         BNM   KBD21                   NO, BRANCH
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    KBD31                   YES, BRANCH
KCE1     BAL   R4,OPDREC               OPERAND RECOGNIZER
         TM    1(R9),X'02'             LO REAL ?
         BZ    KEB1                    YES, BRANCH
         TM    6(R9),X'02'             BLO REAL ?
         BZ    KDB1                    INTEGER, BRANCH
         LA    R4,KCF4
         BAL   R3,ROUTIN15             CALL ROUTINE NUMBER 15
KCE11    MVC   WORKPL(2),ZEROHW
         MVZ   WORKPL(1),8(R9)         CHECK IF LO AND BLO ARE
         MVZ   WORKPL+1(1),3(R9)       LOADED IN THE SAME FPR
         CLC   WORKPL(1),WORKPL+1
         BNE   KCF2                    NO, BRANCH
         SR    R14,R14                 INTRODUCE R9 ADD IN RUTR
         IC    R14,WORKPL
         SRL   R14,3
KCG11    LA    R9,10(0,R9)
         ST    R9,RUTR(R14)
         SH    R9,KH10
         B     KBH1
*
KCF2     SR    R14,R14                 LOAD FPR NUMBER OF LO
         IC    R14,WORKPL+1
         SRL   R14,5                   PREPARE MASK TO SET RIR
         LA    R15,1
         SLL   R15,0(R14)
         STC   R15,KCF21+1
         XI    KCF21+1,X'FF'
KCF21    NI    RIR+1,X'00'
         SLL   R14,1                         PREPARE INSTRUCTION
         STC   R14,KCG2+1
         OC    KCG2+1(1),WORKPL
         BAL   R2,GENTXTP2             GENERATE 2 BYTES
KCG2     LDR   0,0                     *** GENERATED CODE ***
KCH21    SR    R14,R14
         IC    R14,8(R9)               SET TO ONE RIR
         SRL   R14,5
         LA    R15,1
         SLL   R15,0(R14)
         STC   R15,KCH2+1
KCH2     OI    RIR+1,X'00'
         SLL   R14,1                   SET CIR
         STC   R14,CIR+1
         SLL   R14,1
         B     KCG11
*
KCE4     BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1
KCF4     MVZ   KCH4+1(1),8(R9)         PREPARE INSTRUCTION
         MVN   KCH4+1(1),VPLACE
         MVC   KCH4+2(2),WPLACE
         BAL   R2,GENTXTP4             GENERATE 4 BYTES
KCH4     LD    0,0(0,0)                *** GENERATED CODE ***
         B     KCH21
*
KDB1     LA    R4,KDC41
         BAL   R3,ROUTIN15
         TM    3(R9),X'F0'             LO IN FPR0 ?
         BNZ   KDE31                   NO, BRANCH
KDG11    BAL   R2,GENTXT6              GENERATE 6 BYTES
         BALR  BRR,0                   *** GENERATED CODE ***
         B     10(,BRR)                *** GENERATED CODE ***
         MVC   WORKPL(2),13(R9)
         LH    R15,WORKPL
         L     R14,LATAB
         ST    R6,0(R14,R15)
         LA    R9,5(,R9)
         NI    RIR+1,X'FE'
         BAL   R4,TRINRE
         LA    R9,5(,R9)
         ST    R9,RUTR
         SH    R9,KH10
         B     KBD31
*
KDE31    SR    R14,R14                 PREPARE INSTRUCTION
         IC    R14,3(R9)
         SRL   R14,4
         STC   R14,KDF3+1
         SRL   R14,1
         LA    R15,1
         SLL   R15,0(R14)
         STC   R15,WORKPL
         XI    WORKPL,X'FF'
         NC    RIR+1(1),WORKPL
         BAL   R2,GENTXTP2             GENERATE 2 BYTES
KDF3     LDR   0,0                     *** GENERATED CODE ***
         B     KDG11
*
KDC41    MVC   KDC4+2(2),WPLACE        PREPARE INSTRUCTION
         MVN   KDC4+1(1),VPLACE
         BAL   R2,GENTXTP4             GENERATE 4 BYTES
KDC4     LD    0,0(0,0)                *** GENERATED CODE ***
         AH    R7,ONEENTRY
         B     KDG11
*
KEB1     TM    6(R9),X'01'             BLO INTEGER ?
         BZ    KEC2                    NO, BRANCH
         LA    R4,KEF31
         BAL   R3,ROUTIN15             CALL ROUTINE NUMBER 15
         MVC   WORKPL(2),ZEROHW
         MVZ   WORKPL(1),8(R9)
         MVZ   WORKPL+1(1),3(R9)
         CLC   WORKPL(1),WORKPL+1      LO AND BLO ARE IN THE SAME GPR ?
         BNE   KEF2                    NO, BRANCH
         SR    R14,R14                 INTRODUCE R9 ADD IN RUTI
         IC    R14,WORKPL
         SRL   R14,2
KEG1     LA    R9,10(0,R9)
         ST    R9,RUTI
         SH    R9,KH10
         B     KBH1
*
KEF2     SR    R14,R14                 LOAD GPR NR OF LO
         IC    R14,WORKPL+1
         SRL   R14,4                   PREPARE MASK TO SET RII
         LA    R15,1                   TO ZERO
         SLL   R15,0(R14)
         STC   R15,KEF21+1
         XI    KEF21+1,X'FF'
KEF21    NI    RII+1,X'00'
         STC   R14,KEG21+1
         OC    KEG21+1(1),WORKPL
         BAL   R2,GENTXT2              GENERATE 2 BYTES
KEG21    LR    0,0                     *** GENERATED CODE ***
KEH21    SR    R14,R14                 SET TO ONE RII
         IC    R14,8(R9)
         SRL   R14,4
         LA    R15,1
         SLL   R15,0(R14)
         STC   R15,KEH2+1
KEH2     OI    RII+1,X'00'
         STC   R14,CII+1               SET CII
         SLL   R14,2
         B     KEG1
*
KEF31    MVZ   KEG3+1(1),8(R9)         PREPARE INSTRUCTION
         MVN   KEG3+1(1),VPLACE
         MVC   KEG3+2(2),WPLACE
         BAL   R2,GENTXT4              GENERATE 4 BYTES
KEG3     L     0,0(0,0)                *** GENERATED CODE ***
         B     KEH21
*
KEC2     NI    RIR+1,X'FE'
         BAL   R4,TRINRE
         B     KCE11
*
KBD21    TM    5(R9),APIMASK           BLO AN API ?
         BO    KBD2+6                  YES, BRANCH
         B     KBD2
*
***********************************************************************
*
*        COMPILER PROGRAM - CP80
*
***********************************************************************
*
*        BEGIN OF CONDITIONAL EXPRESSION
*        CONTEXT              EXPRESSION
*        SOURCE OPERATOR      'IF'
*        STACK OPERATOR       (
*        OPERANDS             NONE
*
         USING CP80,R12
CP80     TM    COMPFLGS,OPERAND        OPERAND ON ?
         BZ    KIB2                    NO, BRANCH
         BAL   R4,SERR4                ERROR PATTERN ENTRY
         DC    H'164'                  ERROR 164
*
         LA    R9,5(,R9)               CLOPD
KIF2     BAL   R4,MOVEOPTK             RESERVE OPERATOR STACK FNT
         MVC   0(1,R10),0(R8)          INSERT SOURCE INTO STACK
         BR    R5                      BRANCH TO SUBSTART
*
KIB2     TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    KIF2                    YES, BRANCH
         BAL   R4,CLEARRG              CLEAR REGISTERS
         B     KIF2                    BRANCH
*
***********************************************************************
*
*        COMPILER PROGRAM - CP86
*
***********************************************************************
*
*        ERRONEOUS CASE - WRONG CONDITIONAL EXPRESSION  OR STATEMENT
*        CONTEXT              EXPRESSION
*        SOURCE OPERATOR      'ELSE'
*        STACK OPERATOR       'IF','IFS'
*        OPERANDS             NONE OR ONE
*
         USING CP86,R12
CP86     TM    COMPFLGS,OPERAND        OPERAND ON ?
         BZ    KUB2                    NO, BRANCH
         BAL   R4,SERR4                ERROR PATTERN ENTRY
         DC    H'161'                  ERROR 161
*
KUE1     CLI   0(R10),X'1D'            OPERATOR STACK 'IF' ?
         BNE   KUE2                    NO, BRANCH
         MVC   0(1,R10),0(R8)          INSERT SOURCE INTO STACK
         BAL   R4,STACKAPI
         BR    R5                      BRANCH TO SUBSTART
*
KUB2     BAL   R4,SERR4                ERROR PATTERN ENTRY
         DC    H'160'                  ERROR 160
*
         SH    R9,KH5                  RESERVE OPERAND STACK ENT
         B     KUE1
*
KUE2     SH    R11,KH614               CSW(PC)
         MVI   0(R10),X'27'            INSERT THENS INTO STACK
         BR    R5                      BRANCH TO SUBSTART
*
***********************************************************************
*
*        COMPILER PROGRAM - CP87
*
***********************************************************************
*
*        FIRST ALTERNATIVE IN CONDITIONAL  EXPRESSION
*        CONTEXT              EXPRESSION
*        SOURCE OPERATOR      'ELSE'
*        STACK OPERATOR       'THEN'
*        OPERANDS             ONE OPERAND AND ONE LABEL
*
         USING CP87,R12
CP87     LA    R4,KWJ3                 LOAD RETURN ADDR
         BAL   R3,OPDTEST              OPDT AND ERROR 162
         BAL   R4,ARRTEST1
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    KWJ3                    YES, BRANCH
         BAL   R4,OPDREC               CALL OPERAND RECOGNITION
         TM    1(R9),X'03'             LO BOOLEAN ?
         BO    KWE1                    YES, BRANCH
         BM    KXB1
         TM    1(R9),X'08'             LO LABEL ?
         BZ    KYB2
         TM    1(R9),X'04'
         BO    KYB2
         TM    3(R9),X'80'
         BO    KWG13
         TM    RII,X'01'               ADR OCCUPIED ?
         BZ    KYF1                    NO, BRANCH
         BAL   R4,ROUTIN10             STADR
KYF1     MVC   KYF11+2(2),3(R9)        PREPARE INSTRUCTION
         SR    R15,R15                 PREPARE INSTRUCTION
         IC    R15,2(,R9)
         SLL   R15,3
         STH   R15,WORKPL
         MVC   KYF12+2(2),WORKPL
         LA    R2,KYF11
         BAL   R14,GENTXTS
         DC    H'8'                    GENERATE 8 BYTES
*
         AH    R7,ONEENTRY
         STH   R7,WORKPL
         MVC   3(2,R9),WORKPL
         OI    3(R9),X'80'
         NI    0(R9),X'0F'
         OI    0(R9),X'A0'
KWG13    MVI   RII,X'00'
         B     KWG12
*
KYF11    L     ADR,0(LAT,0)            *** GENERATED CODE ***
KYF12    L     GDSA,0(PBT,0)           *** GENERATED CODE ***
*
KYB2     BAL   R4,SERR1
         DC    H'178'                  ERROR 178
*
         MVC   0(5,R9),API
         B     KWJ3
*
KWJ3     MVC   0(1,R10),0(R8)          C(R10)=C(R8)
         MVI   GPBN+1,X'FF'
         BR    R5                      RETURN TO SUBSTART
*
KWE1     TM    0(R9),X'20'             LO A VALUE ?
         BO    KWE3                    NO, BRANCH
         TM    0(R9),X'80'             LO IN OBJECT STACK ?
         BO    KWF2                    NO, BRANCH
KWG12    SH    R7,ONEENTRY
KWG1     BAL   R4,LATRES
         MVC   KWH1+2(2),LN            PREPARE INSTRUCTION
         BAL   R2,GENTXT6              GENERATE 6 BYTES
KWH1     L     BRR,0(LAT,0)            *** GENERATED CODE ***
         BR    BRR                     *** GENERATED CODE ***
         MVC   WORKPL(2),8(R9)         TRANSFER PRPOINT TO LAT ENTRY
         LH    R15,WORKPL              INDICATED BY R9+8
         L     R14,LATAB
         ST    R6,0(R15,R14)
         MVC   8(2,R9),LN              TRANSFER LNR TO R9+5 ENTRY
         B     KWJ3
*
KWF2     TM    2(R9),X'FF'             LO A CONSTANT?
         BZ    KWF21                   YES, BRANCH
         BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1
KWG2     AH    R7,ONEENTRY             INCREASE P
         STH   R7,WORKPL
         BAL   R4,MAXCH                CHECK MAXIMUM
         MVC   KWH2+2(2),WORKPL        PREPARE INSTRUCTION
         OI    KWH2+2,X'A0'
         MVC   KWH2+4(2),WPLACE
         MVZ   KWH2+4(1),VPLACE
         BAL   R2,GENTXT6              GENERATE 6 BYTES
KWH2     MVC   0(1,CDSA),0(0)          *** GENERATED CODE ***
KWF23    MVC   3(2,R9),WORKPL          ADJUST R9 ENTRY
         NI    0(R9),X'5F'
         MVC   2(1,R9),SPBNST+1
         B     KWG12
*
KWF21    AH    R7,ONEENTRY             INCREASE P
         STH   R7,WORKPL
         BAL   R4,MAXCH                CHECK MAX
         NI    4(R9),X'01'
         MVC   KWF22+2(2),WORKPL       PREPARE INSTRUCTION
         OI    KWF22+2,X'A0'
         MVC   KWF22+1(1),4(R9)
         BAL   R2,GENTXT4              GENERATE 4 BYTES
KWF22    MVI   0(CDSA),X'00'           *** GENERATED CODE ***
         OI    1(R9),X'30'             ADJUST R9 ENTRY
         B     KWF23
*
KWE3     BAL   R4,ROUTINE3             CALL ROUTINE NUMBER 3
         XI    0(R9),X'60'
         B     KWG2
*
KXB1     TM    1(R9),X'02'             LO REAL ?
         BZ    KXB3                    INTEGER, BRANCH
         TM    0(R9),X'20'             LO A VALUE ?
         BO    KXC2                    NO, BRANCH
         TM    0(R9),X'40'             LO IN A FPR ?
         BZ    KXH22
         TM    0(R9),X'80'             LO IN A FPR BEFORE ?
         BO    KXC2                    NO, BRANCH
         SH    R7,ONEENTRY             REDUCE O
KXC2     BAL   R4,ROUTIN11             BRANCH TO ROUTINE 11
         SH    R9,KH5                  REDUCE R9
         TM    5(R9),X'20'             LO A VALUE ?
         BZ    KXG2                    YES, BRANCH
         BAL   R4,ROUTINE2             LOAD LO INTO A FPR
KXH2     LA    R9,5(,R9)               INCREACE R9
KXH22    BAL   R4,ROUTIN12             CALL ROUTINE NUMBER 12
KWG11    MVC   5(1,R9),3(R9)
         B     KWG1
*
KXG2     BAL   R4,ROUTINE4             LOAD FOR
         B     KXH2
*
KXB3     TM    0(R9),X'20'             LO A VALUE ?
         BO    KXC4                    NO, BRANCH
         TM    0(R9),X'40'             LO IN A GPR ?
         BZ    KXH21
         TM    0(R9),X'80'             LO IN A GPR ?
         BO    KXC4                    NO, BRANCH
         SH    R7,ONEENTRY             REDUCE P
KXC4     BAL   R4,ROUTINE7             BRANCH TO ROUTINE 11
         SH    R9,KH5                  REDUCE R9
         TM    5(R9),X'20'             LO A VALUE ?
         BZ    KXG4                    YES, BRANCH
         BAL   R4,ROUTINE6             LOAD LO INTO GPR
KXH23    LA    R9,5(,R9)
KXH21    BAL   R4,ROUTINE8
         B     KWG11
*
KXG4     BAL   R4,ROUTINE5             LOAD LO IN GPR
         B     KXH23
*
***********************************************************************
*
*        END OF IEX50005
*
***********************************************************************
*
./ ADD NAME=IEX50006 0201-12230-12230-1200-01131-01131-00000-LEVEL
         TITLE 'IEX50 - COMPILATION PHASE - CP69'
*
***********************************************************************
*
*        COMPILER PROGRAM - CP69
*
***********************************************************************
*
*        ARITHMETIC AND RELATIONAL OPERATIONS
*        CONTEXT              EXPRESSION
*        SOURCE OPERATOR      SEE EXPRESSION CONTEXT  MATRIX
*        STACK OPERATOR       SEE EXPRESSION CONTEXT  MATRIX
*        OPERANDS             TWO OPERANDS
*
         USING CP69,R12
CP69     TM    COMPFLGS,OPERAND        OPERAND ON ?
         BZ    GNB2                    NO, BRANCH
         BAL   R4,ARRTEST2
         TM    1(R9),X'03'             LO ARITHMETIC ?
         BNM   GND2                    NO, BRANCH
         TM    6(R9),X'03'             BLO ARITHMETIC ?
         BNM   GND22                   NO, BRANCH
         TM    COMPFLGS,COMPMODE+SUBSCOPT  SYNTAX + SUBSCRIPT OPT ?
         BNZ   GOE11                   NO, BRANCH
         BAL   R4,OPDREC               OPERAND RECOGNIZER LO
         LA    R9,5(,R9)               INCREASE R9
         BAL   R4,OPDREC               OPERAND RECOGNIZER BLO
         SH    R9,KH5                  DECREASE R9
         TM    1(R9),X'02'             LO REAL ?
         BZ    GOB3                    INTEGER, BRANCH
         TM    6(R9),X'02'             BLO REAL ?
         BZ    HQB1                    INTEGER, BRANCH
HEB1     CLI   0(R10),XFPOWER          OPT POWER ?
         BE    HOB1                    YES, BRANCH
DHEB2    TM    5(R9),X'20'             BLO A VALUE ?
         BO    HFB1                    NO, BRANCH
         TM    5(R9),X'40'             BLO IN A FPR ?
         BO    HEC3                    NO, BRANCH
HEE31    MVZ   UPLACE(1),8(R9)         U=R(BLO)
         LA    R9,5(,R9)
         BAL   R4,CLFPR
         SH    R9,KH5
         CLI   0(R10),X'10'
         BL    HEF2
         SH    R7,ONEENTRY
HEF2     LA    R4,HLD1
         BAL   R3,ROUTIN15             CALL ROUTINE NUMBER 15
         MVN   UPLACE(1),VPLACE
         BAL   R4,CLFPR
         BAL   R4,ROUTIN12             CALL ROUTINE NUMBER 12
         B     HKD1
*
HEC3     TM    5(R9),X'80'             BLO IN A REGISTER ?
         BO    HFB1
         SH    R7,ONEENTRY             REDUCE P
HFB1     TM    0(R9),X'20'             LO A VALUE ?
         BO    HGD1                    AN ADDR, BRANCH
         TM    0(R9),X'40'             LO IN A FPR ?
         BO    HGB1                    NO, BRANCH
         CLI   0(R10),XFSLASH          OPT / ?
         BNE   HFD2                    NO, BRANCH
         TM    RIR+1,X'0F'
         BO    HFB11
         BAL   R4,ROUTIN11             CALL ROUTINE NUMBER 11
         SH    R7,ONEENTRY
         BAL   R4,CLFPR
         SLL   R3,1
         SLL   R14,4
         OR    R3,R14
         SRL   R14,4
         STC   R3,HFB12+1
         STC   R3,UPLACE
         TM    5(R9),X'20'
         BO    HFB13
         BAL   R4,ROUTINE4             CALL ROUTINE NUMBER 4
HFB14    BAL   R2,GENTXTP2             GENERATE 2 BYTES
HFB12    DDR   0,0                     *** GENERATED CODE ***
         B     GOE2
*
CLFPR    SR    R3,R3
         IC    R3,3(R9)
         SRL   R3,5
         LA    R15,1
         SLL   R15,0(R3)
         STC   R15,HEE3+1
         XI    HEE3+1,X'FF'
HEE3     NI    RIR+1,X'00'
         BR    R4
*
HFB13    BAL   R4,ROUTINE2             CALL ROUTINE NUMBER 2
         B     HFB14
*
HFB11    SR    R14,R14                 STORE LO
         IC    R14,3(R9)
         STC   R14,UPLACE              U=R(BLO)
         SRL   R14,4
         BAL   R4,ROUTIN13             CALL ROUTINE NUMBER 13
         TM    5(R9),X'20'             BLO A VALUE ?
         BO    HFF2                    AN ADDR, BRANCH
         BAL   R4,ROUTINE4             CALL ROUTINE NUMBER 4
HFG2     BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1
         B     HLD1
*
HFF2     BAL   R4,ROUTINE2             CALL ROUTINE NUMBER 2
         B     HFG2
*
HFD2     MVZ   UPLACE(1),3(R9)         V=R(LO)
         CLI   0(R10),XFASSIGN         OPT .= ?
         BNE   HFD3                    NO, BRANCH
         BAL   R4,ROUTIN12             CALL ROUTINE NUMBER 12
         LA    R9,5(,R9)               INCREASE R9
         BAL   R4,ROUTIN15             CALL ROUTINE NUMBER 15
HFC51    SH    R9,KH5                  DECREASE R9
         B     HLD1
*
HFD3     MVC   KONSUM(5),0(R9)
         MVC   0(5,R9),5(R9)
         MVC   5(5,R9),KONSUM
         TM    0(R10),X'10'            OPT ARITHMETIC ?
         BO    HFE4                    RELATIONAL, BRANCH
HFH3     MVI   SWREL,X'FF'             SWREL=FF
HGG11    TM    0(R9),X'20'             LO A VALUE ?
         LA    R4,HLD1
         BO    HFJ3                    AN ADDR, BRANCH
         B     ROUTINE1
*
HFJ3     B     ROUTINE3
*
HFE4     BAL   R4,ROUTIN12             CALL ROUTINE NUMBER 12
         B     HFH3
*
HGB1     TM    0(R9),X'80'             LO IN A REGISTER ?
         BO    HGD1                    NO, BRANCH
         SH    R7,ONEENTRY
HGD1     CLI   0(R10),XFASSIGN         OPT .= ?
         BE    HGD2                    YES, BRANCH
         BAL   R4,ROUTIN11             CALL ROUTINE NUMBER 11
         TM    5(R9),X'20'             IS BLO A VALUE
         BZ    HGG1                    YES, BRANCH
         BAL   R4,ROUTINE2             CALL ROUTINE NUMBER 2
HGH1     SLL   R14,4                   1=R(BLO)
         STC   R14,UPLACE
         CLI   0(R10),X'10'            OPT ARITHMETIC ?
         BL    HGG11                   YES, BRANCH
         BAL   R4,ROUTIN12             CALL ROUTINE NUMBER 12
         B     HGG11
*
HGG1     BAL   R4,ROUTINE4             ROUTINE NR.4
         B     HGH1
*
HGD2     TM    5(R9),X'20'             BLO A VALUE ?
         BO    HJB1                    AN ADDR, BRANCH
         TM    0(R9),X'20'             LO A VALUE ?
         BO    HGB2                    AN ADDR, BRANCH
         BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1
         MVC   HJH11+2(2),8(R9)        PREPARE INSTRUCTION
         CLC   SPBNST+1(1),7(R9)       DSA OF BLO CDSA  ?
         BNE   HGB4                    NO, BRANCH
         OI    HJH11+2,X'A0'           PREPARE INSTRUCTION
         B     HJH1
*
HGB4     CLI   GPBN+1,X'FF'            GDSA DESTROYED ?
         BE    HGB41                   YES, BRANCH
         CLC   GPBN(1),7(R9)           DSA OF BLO IN GPBN ?
         BNE   HGB5                    NO, BRANCH
HGC4     OI    HJH11+2,X'90'           PREPARE INSTRUCTION
         B     HJH1
*
HGB41    MVI   GPBN+1,0                SFT TO ZERO
HGB5     SR    R1,R1                   PREPARE INSTRUCTION
         IC    R1,7(R9)
         SLL   R1,3
         STH   R1,WORKPL
         CLI   VPLACE,X'99'            DSA OF LO IN GDSA ?
         BE    HGE5                    YES, BRANCH
         MVC   HGA5+2(2),WORKPL
         BAL   R2,GENTXT4              GENERATE 4 BYTES
HGA5     L     GDSA,0(PBT,0)           *** GENERATED CODE ***
         MVC   GPBN(1),7(R9)           STORE NEW GDSA
         B     HGC4
*
HGE5     MVC   HGF5+2(2),WORKPL
         BAL   R2,GENTXT4              GENERATE 4 BYTES
HGF5     L     R14,0(PBT,0)            *** GENERATED CODE ***
         OI    HJH11+2,X'E0'           PREPARE INSTRUCTION
         B     HJH1
*
HGB2     BAL   R4,ROUTINE3             CALL ROUTINE NUMBER 3
         MVC   HJH11+4(2),WPLACE
         MVZ   HJH11+4(1),VPLACE
         LA    R9,5(0,R9)              INCREASE R9
         BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1
         SH    R9,KH5                  DECREASE R9
         MVC   HJH11+2(2),WPLACE
         MVZ   HJH11+2(1),VPLACE
         B     HJH111
*
HJB1     LA    R9,5(0,R9)              INCREASE R9
         BAL   R4,ROUTINE3             CALL ROUTINE NUMBER 3
         MVC   HJH11+2(2),WPLACE
         MVZ   HJH11+2(1),VPLACE
         SH    R9,KH5                  DECREASE R9
         TM    0(R9),X'20'             LO A VALUE ?
         BO    HJC1                    AN ADDR, BRANCH
         BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1
HJH1     MVC   HJH11+4(2),WPLACE
         MVZ   HJH11+4(1),VPLACE
HJH111   MVI   HJH11+1,0
         TM    1(R9),X'03'
         BO    HJH13
         MVI   HJH11+1,X'03'
         TM    1(R9),X'01'
         BO    HJH13
         LH    R14,ONEENTRY
         BCTR  R14,0
         STC   R14,HJH11+1
HJH13    BAL   R2,GENTXT6              GENERATE 6 BYTES
HJH11    MVC   0(8,0),0(0)             *** GENERATED CODE ***
HLE21    L     R1,ABIG2                R1 -> ABIG2 ENTRY IN CP20
         MVI   SWREL,X'00'
         L     R12,SCPTAB+4*20         R12 -> CP20 FOR ADDRESSABILITY
         BR    R1                      BRANCH TO CP20
*
ABIG2    DC    A(BIG2)
*
HJC1     MVC   HJC11+2(2),3(R9)
         BAL   R2,GENTXT4              GENERATE 4 BYTES
HJC11    L     R14,0(CDSA,0)           *** GENERATED CODE ***
         MVI   VPLACE,X'E0'
         B     HJH1
*
HKD1     MVC   HKH4+1(1),UPLACE
         MVI   HKH4,X'2A'
         CLI   0(R10),XFMINUS          OPT MINUS ?
         BL    HKH41                   OPT PLUS, BRANCH
         BE    HKF2                    OPT MINUS, BRANCH
         MVI   HKH4,X'2C'
         CLI   0(R10),XFSLASH          OPT REAL DIVISION ?
         BL    HKH41                   OPT MULTIPLICATION, BRANCH
         BE    HKD2                    OPT DIVISION, BRANCH
         TM    0(R10),X'10'            OPT RELATIONAL ?
         BO    HKA2                    YES, BRANCH
HKG22    CLI   0(R10),X'04'
         BE    GOE112
HKG2     BAL   R4,SERR2
         DC    H'194'                  ERROR 194
*
GOE1     LA    R9,5(,R9)
GOEZ     STH   R7,WORKPL
         MVN   3(1,R9),WORKPL
         MVC   4(1,R9),WORKPL+1
         OI    0(R9),X'08'
GOF1     BCT   R10,COMP                CLOP AND COMPARE
HKA2     MVI   HKH4,X'29'              PREPARE INSTRUCTIONS
HKH41    BAL   R2,GENTXTP2             GENERATE 2 BYTES
HKH4     ADR   0,0                     *** GENERATED CODE ***
         CLI   0(R10),XFEQUAL
         BL    GOE2
IMB1     AH    R7,ONEENTRY
         STH   R7,WORKPL               CHECK MAX
         BAL   R4,MAXCH
         MVC   8(2,R9),WORKPL
         MVC   IMD2+2(2),WORKPL        PREPARE INSTRUCTION
         OI    IMD2+2,X'A0'
         NI    IMH4+1,X'0F'
         TM    SWREL,X'FF'
         BO    INE2
         CLI   0(R10),XFLT             OPT < ?
         BL    IME4                    =, BRANCH
         BE    IMG4                    YES, BRANCH
         CLI   0(R10),X'13'
         BE    IMH41                   BRANCH ON NOT EQUAL
         BL    IMC4                    BRANCH ON GREATER
         CLI   0(R10),X'15'
         BE    IMD4                    BRANCH ON NOT LOW
         BH    HKG2                    BRANCH ON ERROR
IMF4     OI    IMH4+1,X'D0'            PREPARE INSTRUCTION
IMH51    MVC   IMH5+2(2),IMD2+2
         LA    R2,IMD2
         BAL   R14,GENTXTS
         DC    H'14'                   GENERATE 14 BYTES
         OI    6(R9),X'03'             ADJUST R9 ENTRY OF BLO
         OI    5(R9),X'40'
         NI    5(R9),X'5F'
         B     GOE1                    RETURN
*
IMD2     MVI   0(CDSA),X'01'           *** GENERATED CODE ***
         BALR  BRR,0                   *** GENERATED CODE ***
IMH4     NOP   8(0,BRR)                *** GENERATED CODE ***
IMH5     MVI   0(CDSA),X'00'           *** GENERATED CODE ***
HKD2     MVI   HKH4,X'2D'
         B     HKH41
*
HKF2     MVI   HKH4,X'2B'
         B     HKH41
*
IMC4     OI    IMH4+1,X'20'            SET BRANCH CONDITION IN GEN INST
         B     IMH51
*
IMD4     OI    IMH4+1,X'B0'            SET BRANCH CONDITION IN GEN INST
         B     IMH51
*
IME4     OI    IMH4+1,X'80'            SET BRANCH CONDITION IN GEN INST
         B     IMH51
*
IMG4     OI    IMH4+1,X'40'            SET BRANCH CONDITION IN GEN INST
         B     IMH51
*
IMH41    OI    IMH4+1,X'70'            SET BRANCH CONDITION IN GEN INST
         B     IMH51
*
INE2     MVI   SWREL,0                 ZERO SWREL
         CLI   0(R10),XFLT             WHICH OPT
         BL    IME4                    =, BRANCH
         BE    IMC4                    <, BRANCH
         CLI   0(R10),X'13'
         BE    IMH41                   BRANCH ON NOT EQUAL
         BL    IMG4                    BRANCH ON GREATER
         CLI   0(R10),X'15'
         BE    IMF4                    BRANCH ON NOT LOW
         BH    HKG2                    BRANCH ON ERROR
         B     IMD4                    PREPARE INSTRUCTION
*
GNB2     BAL   R4,SERR4
         DC    H'162'                  ERROR 162
*
         OI    COMPFLGS,OPERAND        SET OPERAND ON
GNE3     MVC   0(5,R9),API             INSTRUCTION API
         BCT   R10,COMP                CLOPT AND COMPARE
GND2     TM    0(R9),APIMASK           LO AN API ?
         BZ    GND21                   LO IS NOT AN API, BRANCH
GND3     LA    R9,5(,R9)               INCREASE R9
         B     GNE3
*
GND21    BAL   R4,SERR2
         DC    H'163'                  ERROR 163
*
         B     GND3
*
GND22    TM    5(R9),APIMASK           BLO AN API ?
         BO    GND3                    YES, BRANCH
         BCTR  R10,0                   REDUCE R10
         BAL   R4,SERR2
         DC    H'163'                  ERROR  163
         LA    R10,1(,R10)             INCREASE R10
         B     GND3
*
GOE11    CLI   0(R10),X'04'            OPT IN STACK INT# DIV ?
         BNE   GOE111                  NO, BRANCH
         TM    1(R9),X'02'             LO REAL ?
         BO    GOE112
         TM    6(R9),X'02'             BLO REAL ?
         BO    GOE112                  YES, BRANCH
GOE111   TM    0(R10),X'10'            OPT RELATIONAL ?
         BZ    GOE1                    NO, BRANCH
         OI    6(R9),X'03'             ADJUST R9 ENTRY OF BLO
         B     GOE1
*
GOE2     SR    R14,R14
         NI    UPLACE,X'F0'
         IC    R14,UPLACE
         SRL   R14,3
         LA    R9,5(,R9)
         ST    R9,RUTR(R14)
         SRL   R14,1
         STH   R14,CIR
         SRL   R14,1
         LA    R15,1
         SLL   R15,0(R14)
         STC   R15,HEF21+1
HEF21    OI    RIR+1,X'00'
         B     GOEZ
*
HLD1     MVC   HLJ4+1(1),UPLACE        PREPARE INSTRUCTION
         MVN   HLJ4+1(1),VPLACE
         MVC   HLJ4+2(2),WPLACE
         MVI   HLJ4,X'6A'
         CLI   0(R10),XFMINUS          OPT MINUS ?
         BL    HLJ41                   +, BRANCH
         BE    HLF2                    MINUS, BRANCH
         MVI   HLJ4,X'6C'
         CLI   0(R10),X'03'            DIVISION ?
         BL    HLJ41
         BE    HLB2                    YES, BRANCH
         TM    0(R10),X'10'            A RELATIONAL OPT ?
         BZ    HKG22
         MVI   HLJ4,X'60'
         CLI   0(R10),XFASSIGN         OPT .= ?
         BE    HLJ41                   YES, BRANCH
HLA2     MVI   HLJ4,X'69'              PREPARE INSTRUCTION
HLJ41    BAL   R2,GENTXTP4             GENERATE 4 BYTES
HLJ4     AD    0,0(0,0)                *** GENERATED CODE ***
         CLI   0(R10),XFMINUS          OPT MINUS ?
         BE    HLF3                    YES, BRANCH
         CLI   0(R10),XFASSIGN         OPT ASSIGNMENT?
         BE    HLE21                   YES, BRANCH
         TM    0(R10),X'10'            OPT RELATIONAL ?
         BO    IMB1                    NO, BRANCH
         MVI   SWREL,0
         B     GOE2
*
GOE112   BAL   R4,SERR3
         DC    H'185'
*
         B     GOE1
*
HLF3     TM    SWREL,X'FF'
         BZ    GOE2
         MVI   SWREL,X'00'              SET TO ZERO SWREL
         MVC   HLH3+1(1),UPLACE         PREPARE INSTRUCTION
         SR    R14,R14
         IC    R14,UPLACE
         SRL   R14,4
         STC   R14,WORKPL
         MVN   HLH3+1(1),WORKPL
         BAL   R2,GENTXTP2              GENERATE 2 BYTES
HLH3     LCDR  0,0                      *** GENERATED CODE ***
         B     GOE2
*
HLB2     MVI   HLJ4,X'6D'
         B     HLJ41
*
HLF2     MVI   HLJ4,X'6B'
         B     HLJ41
*
GOB3     TM    6(R9),X'02'             BLO REAL ?
         BO    HTB1                    YES, BRANCH
         CLI   0(R10),XFASTER          OPT * ?
         BL    DHZB1
         BE    IPB1                    YES, BRANCH
         TM    0(R10),X'10'            OPT RELATIONAL ?
         BO    DHZB1
         CLI   0(R10),X'04'            OPT INTEGER DIV ?
         BE    ISB1                    YES, BRANCH
         BH    IUB1                    OPT IS POWER, BRANCH
HWB1     BAL   R4,TRINRE               CALL CONVERT ROUTINE
         MVC   HYG2+2(2),3(R9)
         LA    R9,5(,R9)               INCREASE R9
         BAL   R4,TRINRE
         BAL   R2,GENTXTP4             GENERATE 4 BYTES
HYG2     DD    0,0(CDSA,0)             *** GENERATED CODE ***
         SH    R7,ONEENTRY             REDUCE P
         B     GOEZ
*
DHZB1    TM    5(R9),X'20'             BLO A VALUE ?
         BO    IAB1                    AN ADDR, BRANCH
         TM    5(R9),X'40'             BLO IN A REGISTER ?
         BO    HZC2                    IN STORAGE, BRANCH
         MVZ   UPLACE(1),8(R9)         V=R(BLO)
         TM    0(R10),X'10'            OPT RELATIONAL ?
         BZ    HZF1                    ARITHMETIC, BRANCH
         BAL   R4,ROUTINE8             CALL ROUTINE NUMBER 8
HZF1     LA    R4,IFC3
         BAL   R3,ROUTIN15             CALL ROUTINE NUMBER 15
         MVN   UPLACE(1),VPLACE        PREPARE INSTRUCTION
         BAL   R4,ROUTINE8             RELILO
         B     IEC3
*
HZC2     TM    5(R9),X'80'             BLO IN A REGISTER ?
         BO    IAB1                    NO, BRANCH
         SH    R7,ONEENTRY             REDUCE P
IAB1     TM    0(R9),X'20'             LO A VALUE ?
         BO    IAD3                    AN ADDR, BRANCH
         TM    0(R9),X'40'             LO IN A REGISTER ?
         BO    IAC2                    IN STORAGE, BRANCH
         MVZ   UPLACE(1),3(R9)         U=R(LO)
         CLI   0(R10),XFASSIGN         OPT.= ?
         BNE   IAE1                    NO, BRANCH
         BAL   R4,ROUTINE8             CALL ROUTINE NUMBER 8
         LA    R9,5(,R9)               INCREASE R9
         BAL   R4,ROUTIN15             CALL ROUTINE NUMBER 15
IAE21    SH    R9,KH5                  REDUCE R9
         B     IFC3
*
IAE1     MVC   KONSUM(5),0(R9)         INTERCHANGE PLACES
         MVC   0(5,R9),5(R9)
         MVC   5(5,R9),KONSUM
         TM    0(R10),X'10'            OPT ARITHMETIC ?
         BO    IAG2                    RELATIONAL, BRANCH
         SR    R14,R14                 INTRODUCE R9 ADD IN RUM
         LA    R9,5(,R9)
         IC    R14,3(R9)
         SRL   R14,4
         SLL   R14,2
         ST    R9,RUTI(R14)
         SH    R9,KH5                  DECREASE R9
IAJ1     MVI   SWREL,X'FF'             SWREL= ONE
IAF3     TM    0(R9),X'20'             LO A VALUE ?
         LA    R4,IFC3
         BO    IAK1                    AN ADDR, BRANCH
         B     ROUTINE1                BRANCH TO ROUTINE NUMBER 1
*
IAK1     B     ROUTINE3                BRANCH TO ROUTINE NUMBER 3
*
IAG2     BAL   R4,ROUTINE8             CALL ROUTINE NUMBER 8
         B     IAJ1
*
IAC2     TM    0(R9),X'80'             LO IN A REGISTER ?
         BO    IAD3                    NO, BRANCH
         SH    R7,ONEENTRY             REDUCE P
IAD3     CLI   0(R10),XFASSIGN         OPT.= ?
         BE    HGD2                    YES, BRANCH
         BAL   R4,ROUTINE7             CALL ROUTINE NUMBER 7
         TM    5(R9),X'20'             BLO A VALUE ?
         BO    IAG3                    AN ADDR, BRANCH
         BAL   R4,ROUTINE5             CALL ROUTINE NUMBER 5
IAH3     SLL   R14,4                   U=R(BLO)
         STC   R14,UPLACE
         TM    0(R10),XFEQUAL
         BZ    IAF3
         BAL   R4,ROUTINE8             CALL ROUTINE NUMBER 8
         B     IAF3
*
IAG3     BAL   R4,ROUTINE6             CALL ROUTINE NUMBER 6
         B     IAH3
*
IEC3     MVC   IED3+1(1),UPLACE        PREPARE INSTRUCTION
         MVI   IED3,X'1A'
         CLI   0(R10),XFMINUS          OPT MINUS ?
         BL    IED31                   OPT PLUS, BRANCH
         BH    IED4                    OPT RELATIONAL, BRANCH
         MVI   IED3,X'1B'              PREPARE INSTRUCTION
IED31    BAL   R2,GENTXT2              GENERATE 2 BYTES
IED3     SR    0,0                     *** GENERATED CODE ***
         CLI   0(R10),X'10'
         BL    GOE1
         B     IMB1
*
IED4     MVI   IED3,X'19'
         B     IED31
*
IFC3     MVC   IFD3+1(1),UPLACE        PREPARE INSTRUCTION
         MVN   IFD3+1(1),VPLACE
         MVC   IFD3+2(2),WPLACE
         MVI   IFD3,X'5A'
         CLI   0(R10),XFMINUS          WHICH OPT
         BL    IFD31                   +, BRANCH
         BH    IFD4                    RELATIONAL, BRANCH
         MVI   IFD3,X'5B'              PREPARE  INSTRUCTION
IFD31    BAL   R2,GENTXT4              GENERATE 4 BYTES
IFD3     S     0,0(0,0)                *** GENERATED CODE ***
         CLI   0(R10),XFMINUS          WHICH OPERATOR
         BL    IFG3+2                  +, BRANCH
         BH    IFD41                   RELATIONAL, BRANCH
         CLI   SWREL,X'FF'             SWREL = ONE
         BNE   IFG3+2
         IC    R14,UPLACE              PREPARE INSTRUCTION
         SRL   R14,4
         STC   R14,IFG3+1
         MVZ   IFG3+1(1),UPLACE
         BAL   R2,GENTXT2              GENERATE 2 BYTES
IFG3     LCR   0,0                     *** GENERATED CODE ***
         MVI   SWREL,0
         B     GOE1
*
IFD4     MVI   IFD3,X'59'
         CLI   0(R10),XFASSIGN         OPT.= ?
         BNE   IFD31                   NO, BRANCH
         MVI   IFD3,X'50'              PREPARE INSTRUCTION
         B     IFD31
*
IFD41    CLI   0(R10),XFASSIGN         OPT.= ?
         BE    HLE21                   YES, BRANCH
         B     IMB1                    BRANCH TO RELATIONAL ROUTINE
*
*        INTEGER-INTEGER MULTIPLICATION
*
IPB1     TM    5(R9),X'20'             BLO A VALUE ?
         BO    IRD1                    AN ADDR, BRANCH
         TM    5(R9),X'40'             BLO A IN A REGISTER ?
         BO    IRB1                    IN STORAGE, BRANCH
         SR    R1,R1                   BLO IN AN ODD REG ?
         IC    R1,8(,R9)
         STC   R1,UPLACE
         SRL   R1,4
         SH    R7,ONEENTRY             DECREASE P
         TM    UPLACE,X'10'
         BZ    IPD2                    BLO IN EVEN GPR, BRANCH
         LA    R2,1                    CLEAR RII OF BLO
         SLL   R2,0(R1)
         STC   R2,IPH11+1
         XI    IPH11+1,X'FF'
IPH11    NI    RII+1,0
         BCTR  R1,0                    V=R(BLO-1)
         NI    UPLACE,X'E0'
         SRL   R2,1                    NEXT EVEN GPR FREE ?
         STC   R2,IPH1+1
IPH1     TM    RII+1,0
         BO    IPH31
IPJ1     LA    R4,IQE2
         BAL   R3,ROUTIN15             CALL ROUTINE NUMBER 15
IQC1     BAL   R4,ROUTINE8             CALL ROUTINE NUMBER 8
IQD11    MVZ   IQD1+1(1),UPLACE        PREPARE INSTRUCTION
         SR    R2,R2
         IC    R2,3(R9)
         SRL   R2,4
IQC12    LA    R1,1
         SLL   R1,0(R2)
         STC   R1,IQC13+1
         XI    IQC13+1,X'FF'
IQC13    NI    RII+1,0
         MVN   IQD1+1(1),VPLACE
         BAL   R2,GENTXT2              GENERATE 2 BYTES
IQD1     MR    0,0                     *** GENERATED CODE  ***
IQE11    MVZ   IQE1+1(1),UPLACE        PREPARE INSTRUCTION
         BAL   R2,GENTXT4              GENERATE 4 BYTES
IQE1     SLDA  0,32                    *** GENERATED CODE  ***
IQB1     SR    R1,R1                   SET NEW CII
         IC    R1,UPLACE
         SRL   R1,4
         STC   R1,CII+1
         SLL   R1,4
         STC   R1,8(R9)
         SRL   R1,4
         LA    R2,1                    SET TO ONE RII OF BLO
         SLL   R2,0(R1)
         STC   R2,IQC14+1
IQC14    OI    RII+1,0
         AH    R7,ONEENTRY
         SLL   R1,2
         LA    R9,5(,R9)
         ST    R9,RUTI(R1)
         B     GOEZ
*
IQE2     MVZ   IQE21+1(1),UPLACE       PREPARE INSTRUCTION
         MVN   IQE21+1(1),VPLACE
         MVC   IQE21+2(2),WPLACE
         BAL   R2,GENTXT4              GENERATE 4 BYTES
IQE21    M     0,0(0,0)                *** GENERATED CODE  ***
         B     IQE11
*
IPH31    TM    0(R9),X'20'             LO AN ADDR ?
         BO    IPH4                    YES, BRANCH
         TM    0(R9),X'40'
         BO    IPH4
IPH3     MVZ   WORKPL(1),3(R9)         LO IN THAT GPR ?
         NI    WORKPL,X'F0'
         NI    UPLACE,X'F0'
         CLC   UPLACE(1),WORKPL
         BNE   IPH4                    BRANCH IF NOT IN THAT GPR
         SH    R7,ONEENTRY             INCREASE P
         B     IQD11
*
IPH4     LA    R1,2(,R1)               NEXT EVEN FREE
         CH    R1,KH8                  NEXT EVEN GPR8 ?
         BE    IPH41                   YES, BRANCH
         SLL   R2,2
IPH43    STC   R2,IPH42+1
IPH42    TM    RII+1,0
         BZ    IPD3                    BRANCH IN FREE
         TM    0(R9),X'20'             LO A VALUE ?
         BO    IPH44
         TM    0(R9),X'40'
         BO    IPH44
         SR    R3,R3                   LO IN THAT GPR ?
         IC    R3,3(0,R9)
         SRL   R3,4
         CR    R3,R1
         BE    IPD3                    YES, BRANCH
IPH44    LR    R14,R1
         ST    R2,RETADR+56            SAVE CONTENTS OF R2 ACROSS RTN9
         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9
         L     R2,RETADR+56
         LR    R1,R14
IPD3     LA    R1,1(,R1)               NEXT ODD FREE ?
         SLL   R2,1
IPD33    STC   R2,IPD31+1
IPD31    TM    RII+1,0
         BZ    IPE3
         LR    R14,R1
         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9
         LR    R1,R14
         XI    IPD31+1,X'FF'           CLEAR RII OF LAST CLEARED
         NC    RII+1(1),IPD31+1
IPE3     SLL   R1,4                    PREPARE INSTRUCTION
         STC   R1,UPLACE
         MVC   IPE31+1(1),UPLACE
         NI    UPLACE,X'E0'
         IC    R2,8(,R9)
         SRL   R2,4
         STC   R2,WORKPL
         MVN   IPE31+1(1),WORKPL
         BAL   R2,GENTXT2              GENERATE 2 BYTES
IPE31    LR    0,0                     *** GENERATED CODE ***
         B     IPJ1
*
IPH41    SR    R1,R1
         LA    R2,1
         B     IPH43
*
IPD2     SR    R2,R2                   LO IN NEXT GPR ?
         LA    R1,1(0,R1)
         TM    0(R9),X'20'
         BO    IPD21
         TM    0(R9),X'40'
         BO    IPD21
         IC    R2,3(,R9)
         SRL   R2,4
         CR    R1,R2
         BE    IQC11                   YES,  BRANCH
IPD21    LA    R2,1
         SLL   R2,0(R1)
         B     IPD33
*
IRB1     TM    5(R9),X'80'             BLO IN A GPR ?
         BO    IRD1
         SH    R7,ONEENTRY
IRD1     TM    CII+1,X'01'             LAST OCCUPIED REG ODD ?
         BO    IRD11                   YES, BRANCH
         TM    CII+1,X'06'             LAST OCCUPIED R6 ?
         BO    IRD12                   YES, BRANCH
         SR    R1,R1
         IC    R1,CII+1                NEXT EVEN REG FREE ?
         LA    R1,2(,R1)
IRD14    LA    R2,1
         STC   R1,CII+1
         SLL   R2,0(R1)
         LR    R14,R1
         STC   R2,IRD13+1
IRD13    TM    RII+1,0
         BZ    IRF1                    FREE, BRANCH
         ST    R2,RETADR+52
         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9
         L     R2,RETADR+52
         LR    R1,R14
IRF1     SLL   R2,1                    NEXT ODD FREE ?
         OC    RII+1(0),IRD13+1
         SLL   R14,4
         STC   R14,UPLACE
         STC   R2,IRF11+1
         LA    R1,1(,R1)
         LR    R14,R1
IRF11    TM    RII+1,0
         BZ    IRG1                    BRANCH IF FREE
         XI    IRF11+1,X'FF'
         NC    RII+1(1),IRF11+1
         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9
IRG1     TM    5(R9),X'20'             BLO A VALUE ?
         BO    IRA1                    AN ADDR, BRANCH
         BAL   R4,ROUTINE5             CALL ROUTINE NUMBER 5
         B     IPJ1
*
IRA1     BAL   R4,ROUTINE6             CALL ROUTINE NUMBER 6
         B     IPJ1
*
IRD12    SR    R1,R1
         B     IRD14
*
IRD11    TM    CII+1,X'07'             LAST OCCUPIED R7 ?
         BO    IRD12
         SR    R1,R1
         IC    R1,CII+1
         LA    R1,1(,R1)               INCR
         B     IRD14
*
IQC11    BCTR  R2,0
         STC   R2,VPLACE
         SH    R7,ONEENTRY
         B     IQD11
*
*        INTEGER-INTEGER DIVISION
*
ISB1     TM    5(R9),X'20'             BLO A VALUE ?
         BO    ISB4                    AN ADDR, BRANCH
         TM    5(R9),X'40'             BLO IN A GPR ?
         BO    ISC2                    IN STORAGE, BRANCH
         SR    R14,R14                 CLEAR RII OF BLO
         IC    R14,8(R9)
         SRL   R14,4
         LA    R2,1
         SLL   R2,0(R14)
         STC   R2,ISE3+1
         XI    ISE3+1,X'FF'
ISE3     NI    RII+1,X'00'
         SH    R7,ONEENTRY
         TM    8(R9),X'10'             BLO IN AN EVEN GPR ?
         BO    ISG4                    ODD, BRANCH
ISH11    SLL   R2,1                    NEXT ODD FREE ?
         LA    R14,1(,R14)
         STC   R2,ISH1+1
ISH1     TM    RII+1,0
         BO    ISH2                    OCCUPIED, BRANCH
ISJ11    MVZ   ISJ1+1(1),8(R9)         PREPARE INSTRUCTION
         BAL   R2,GENTXT4              GENERATE 4 BYTES
ISJ1     SRDA  0,32                    *** GENERATED CODE ***
         LA    R4,ITF21
         BAL   R3,ROUTIN15             CALL ROUTINE NUMBER 5
         BAL   R4,ROUTINE8             CALL ROUTINE NUMBER 8
         MVZ   ITE1+1(1),8(R9)         PREPARE INSTRUCTION
         MVN   ITE1+1(1),VPLACE
         BAL   R2,GENTXT2              GENERATE 2 BYTES
ITE1     DR    0,0                     *** GENERATED CODE ***
ITZZ     MVZ   UPLACE(1),8(R9)
         OI    UPLACE,X'10'
         B     IQB1
*
ITF21    MVZ   ITF2+1(1),8(R9)         PREPARE INSTRUCTION
         MVN   ITF2+1(1),VPLACE
         MVC   ITF2+2(2),WPLACE
         BAL   R2,GENTXT4              GENERATE 4 BYTES
ITF2     D     0,0(0,0)                *** GENERATED CODE ***
         B     ITZZ
*
ISH2     TM    0(R9),X'20'             LO A VALUE ?
         BO    ISH3                    AN ADDR, BRANCH
         TM    0(R9),X'40'             LO IN A GPR ?
         BO    ISH3
         SR    R3,R3                   LO IN THAT GPR ?
         IC    R3,3(R9)
         SRL   R3,4
         STC   R3,VPLACE
         CR    R3,R14
         BNE   ISH3                    NO THERE, BRANCH
         MVN   ISJ2+1(1),VPLACE        PREPARE INSTRUCTION
         BAL   R2,GENTXT2              GENERATE 2 BYTES
ISJ2     LR    R14,0                   *** GENERATED CODE ***
         NI    3(R9),X'0F'             ADJUST R9 ENTRY
         OI    3(R9),X'E0'
         B     ISJ11
*
ISH3     BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 8
         B     ISJ11
*
ISG4     LA    R14,1(,R14)             NEXT EVEN FREE ?
         TM    CII+1,X'07'             NEXT EVEN GPR7
         BO    ISG401                  YES
         SLL   R2,1
         STC   R2,ISG41+1
ISG41    TM    RII+1,0
         BZ    ISH4                    BRANCH IF FREE
         ST    R2,RETADR
         BAL   R4,ROUTINE9             STOPINT
         XI    ISG41+1,X'FF'
         NC    RII+1(1),ISG41+1
ISH4     SLL   R14,4                   PREPARE INSTRUCTION
         STC   R14,ISH41+1
         IC    R1,8(R9)
         SRL   R1,4
         STC   R1,WORKPL
         MVN   ISH41+1(1),WORKPL
         BAL   R2,GENTXT2              GENERATE 2 BYTES
ISH41    LR    0,0                     *** GENERATED CODE ***
         L     R2,RETADR
         MVZ   8(1,R9),ISH41+1         ADJUST R9 ENTRY
         SRL   R14,4
         B     ISH11
*
ISC2     TM    5(R9),X'80'             BLO IN A REG ?
         BO    ISB4                    NO, BRANCH
         SH    R7,ONEENTRY             REDUCE P
ISB4     TM    CII+1,X'01'             LAST OCCUPIED EVEN ?
         BO    ISD5                    ODD, BRANCH
         TM    CII+1,X'06'             LAST OCCUPIEN R6 ?
         BO    ISD51                   YES, BRANCH
         SR    R1,R1
         IC    R1,CII+1
         LA    R1,2(,R1)
ISD52    LA    R2,1
         SLL   R2,0(R1)
         STC   R2,ISE4+1
         LR    R14,R1
ISE4     TM    RII+1,0
         BZ    ISF4                    BRANCH IF FREE
         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9
ISF4     TM    5(R9),X'20'             BLO A VALUE ?
         BO    ISF41                   AN ADDR, BRANCH
         BAL   R4,ROUTINE5             CALL ROUTINE NUMBER 5
ISF42    SR    R2,R2
         IC    R2,ISE4+1
         B     ISH11
*
ISF41    BAL   R4,ROUTINE6             LOAD BLO
         B     ISF42
*
ISD51    SR    R1,R1                   CLEAR R1
         B     ISD52
*
ISD5     TM    CII+1,X'07'             LAST OCCUPIED R7 ?
         BO    ISD51                   YES, BRANCH
         LH    R1,CII
         LA    R1,1(,R1)
         B     ISD52
*
ISG401   SR    R14,R14                 CLEAR R14
         LA    R2,1
         STC   R2,ISG41+1
         B     ISG41
*
HQB1     BAL   R4,I1B13
         B     HEB1
*
HTB1     CLI   0(R10),XFPOWER          OPT POWER ?
         BE    I1B1
HTB11    BAL   R4,TRINRE               CONVERTION ROUTINE
         B     DHEB2
*
*        INTEGER-INTEGER POWER
*
IUB1     TM    0(R9),X'C0'
         BNO   IUB2
         TM    1(R9),X'30'
         BNZ   IUB2                    NOT CONSTANT, BRANCH
         TM    SWVAL,X'FF'
         BO    IUB2
         TM    RII+1,X'01'             R0 FREE ?
         BZ    IUC1                    YES, BRANCH
         SR    R14,R14                 R14=0
         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9
IUC1     TM    RII+1,X'02'             R1 FREE ?
         BZ    IUC11                   YES, BRANCH
         LA    R14,1
         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9
         NI    RII+1,X'FD'
IUC11    AH    R7,ONEENTRY             INCREASE P
         STH   R7,IUG2+2               PREPARE INSTRUCTION
         AH    R7,ONEENTRY             INCREASE P
         STH   R7,WORKPL               CHECK MAX
         BAL   R4,MAXCH
         SH    R7,ONEENTRY
         LA    R9,5(,R9)
         LA    R4,IUH21
         BAL   R3,ROUTIN15             CALL ROUTINE NUMBER 15
         SR    R14,R14                 STORE BLO
         SH    R7,ONEENTRY
         IC    R14,3(,R9)
         SRL   R14,4
         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9
         BAL   R4,ROUTINE8             CALL ROUTINE NUMBER 8
         MVC   WPLACE(2),3(R9)
         MVI   VPLACE,X'AA'            V=CDSA
IUH21    MVC   IUH2+2(2),WPLACE        PREPARE INSTRUCTION
         MVN   IUH2+1(1),VPLACE
         SH    R9,KH5
         LA    R2,IUG2
         BAL   R14,GENTXTS
         DC    H'8'                    GENERATE 8 BYTES
*
         BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1
         MVC   IUH2+6(2),WPLACE
         MVN   IUH2+5(1),VPLACE
         LA    R2,IUH2+4
         BAL   R14,GENTXTS
         DC    H'14'                   GENERATE 14 BYTES
*
         OI    RII+1,X'01'             SET TO ONE RII OF GPR0
         MVI   CII+1,0
         STH   R7,WORKPL               ADJUST R9 ENTRY
         MVC   8(2,R9),WORKPL
         LA    R9,5(0,R9)
         ST    R9,RUTI                 INTRODUCE R9 ADD IN RUT
         MVC   2(1,R9),SPBNST+1        ADJUST R9 ENTRY
         OI    1(R9),X'30'
         NI    0(R9),X'90'
         OI    0(R9),X'88'
         L     R14,LATAB
         NI    96(R14),X'7F'
         BCT   R10,COMP
IUG2     LA    R1,R7(CDSA,0)           *** GENERATED CODE ***
IUH2     LA    R14,0(0,0)              *** GENERATED CODE ***
         LA    BRR,0(0,0)              *** GENERATED CODE ***
         STM   R14,BRR,0(R1)           *** GENERATED CODE ***
         L     ENTRY,96(LAT,0)         *** GENERATED CODE ***
         BALR  R14,ENTRY               *** GENERATED CODE ***
*
IUB2     LA    R4,I1B1
         TM    0(R9),X'20'
         BO    I1B13
         TM    0(R9),X'40'
         BO    I1B13
         TM    5(R9),X'20'
         BO    I1B13
         TM    5(R9),X'40'
         BO    I1B13
         SR    R14,R14
         IC    R14,8(R9)
         SRL   R14,4
         LA    R15,1
         SLL   R15,0(R14)
         STC   R15,IUB3+1
         XI    IUB3+1,X'FF'
IUB3     NI    RII+1,0
         SR    R14,R14
         TM    CII+1,X'07'
         BO    IUB13
         LH    R14,CII
         LA    R14,1(,R14)
IUB13    STH   R14,CII
         BAL   R4,I1B13
*
*        REAL-INTEGER POWER
*
I1B1     BAL   R3,HOB11
         LA    R4,I1C11
         BAL   R3,ROUTIN15             CALL ROUTINE NUMBER 15
         SR    R14,R14
         IC    R14,3(,R9)
         SRL   R14,4
         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9
         BAL   R4,ROUTINE8             CALL ROUTINE NUMBER 8
         MVC   WPLACE(2),3(R9)         PREPARE INSTRUCTION
         MVI   VPLACE,X'AA'
I1C11    BAL   R3,HOD1
         L     R14,LATAB
         NI    100(R14),X'7F'
         BAL   R2,GENTXT6              GENERATE 6 BYTES
         L     ENTRY,100(LAT,0)        *** GENERATED CODE ***
         BALR  R14,ENTRY               *** GENERATED CODE ***
         BCT   R10,COMP
*
*        REAL-REAL POWER
*
HOB1     BAL   R3,HOB11
         LA    R4,HOC31
         BAL   R3,ROUTIN15             CALL ROUTINE NUMBER 15
         SR    R14,R14
         IC    R14,3(,R9)
         SRL   R14,4
         STC   R14,CIR+1
         BAL   R4,ROUTIN13             CALL ROUTINE NUMBER 13
         BAL   R4,ROUTIN12             CALL ROUTINE NUMBER 12
         MVC   WPLACE(2),3(R9)         PREPARE INSTRUCTION
         MVI   VPLACE,X'AA'
HOC31    BAL   R3,HOD1
         L     R14,LATAB
         NI    104(R14),X'7F'
         BAL   R2,GENTXT6              GENERATE 6 BYTES
         L     ENTRY,104(LAT,0)        *** GENERATED CODE ***
         BALR  R14,ENTRY               *** GENERATED CODE ***
         BCT   R10,COMP
HOB11    TM    RIR+1,X'01'             FPR0 FREE ?
         ST    R3,RETADR+52
         BZ    HOB21                   YES, BRANCH
         BAL   R4,ROUTIN14             CALL ROUTINE NUMBER 14
HOB21    TM    RIR+1,X'02'             FPR2 FREE ?
         BZ    HOB2
         LA    R14,2
         BAL   R4,ROUTIN13             CALL ROUTINE NUMBER 13
         NI    RIR+1,X'FD'
HOB2     TM    RII+1,X'02'             GPR1 FREE ?
         BZ    HOB3                    YES, BRANCH
         LA    R14,1
         BAL   R4,ROUTINE9             CALL ROUTINE NUMBER 9
         NI    RII+1,X'FD'
HOB3     AH    R7,ONEENTRY             INCREASE P
         STH   R7,HOB4+2               PREPARE INSTRUCTION
         AH    R7,ONEENTRY             INCREASE P
         STH   R7,WORKPL               CHECK MAX
         BAL   R4,MAXCH
         SH    R7,ONEENTRY             REDUCE P
         LA    R9,5(,R9)
         LA    R4,HOC11
         BAL   R3,ROUTIN15
         SH    R7,ONEENTRY
         SR    R14,R14
         IC    R14,3(,R9)
         SRL   R14,4
         BAL   R4,ROUTIN13             CALL ROUTINE NUMBER 13
         SRL   R14,1
         LA    R15,1
         SLL   R15,0(R14)
         STC   R15,WORKPL
         XI    WORKPL,X'FF'
         NC    RIR+1(1),WORKPL
         MVC   WPLACE(2),3(R9)         W = DISPL
         MVI   VPLACE,X'AA'            V = CDSA
HOC11    MVC   HOB5+2(2),WPLACE        PREPARE INSTRUCTION
         MVN   HOB5+1(1),VPLACE
         SH    R9,KH5
         LA    R2,HOB4
         BAL   R14,GENTXTS
         DC    H'8'                    GENERATE 8 BYTES
*
         L     R3,RETADR+52
         BR    R3
*
HOD1     MVC   HOB5+6(2),WPLACE
         ST    R3,RETADR+52
         MVN   HOB5+5(1),VPLACE
         LA    R2,HOB4+8
         BAL   R14,GENTXTS
         DC    H'8'                    GENERATE 8 BYTES
         OI    RIR+1,X'01'             SET TO ONE RIR OF FPR0
         MVI   CIR+1,0
         STH   R7,WORKPL               ADJUST R9 ENTRY
         MVC   8(2,R9),WORKPL
         LA    R9,5(,R9)
         ST    R9,RUTR                 INTRODUCE R9 ADD IN RUTR
         MVC   2(1,R9),SPBNST+1        USE R9 ENTRY
         OI    1(R9),X'30'
         NI    0(R9),X'90'
         OI    0(R9),X'88'
         L     R3,RETADR+52
         BR    R3
*
HOB4     LA    R1,7(CDSA,0)            *** GENERATED CODE ***
HOB5     LA    R14,0(0,0)              *** GENERATED CODE ***
         LA    BRR,0(0,0)              *** GENERATED CODE ***
         STM   R14,BRR,0(R1)           *** GENERATED CODE ***
I1B13    ST    R4,RET69
         TM    0(R9),X'20'
         BO    I1B14
         TM    0(R9),X'C0'
         BO    I1B15
I1B14    TM    5(R9),X'20'
         BO    I1B16
         TM    5(R9),X'C0'
         BO    I1B15
I1B16    STH   R7,RET691
         MVC   WORKPL(2),8(R9)
         NI    WORKPL,X'0F'
         LH    R7,WORKPL
         LA    R9,5(,R9)
         BAL   R4,TRINRE
         LH    R7,RET691
         B     I1B17
*
I1B15    LA    R9,5(,R9)
         BAL   R4,TRINRE
I1B17    SH    R9,KH5
         L     R4,RET69
         BR    R4
*
RET69    DC    F'0'
RET691   DC    H'0'
*
***********************************************************************
*
*        END OF IEX50006
*
***********************************************************************
*
./ ADD NAME=IEX51    0201-12230-12230-1200-01113-01113-00000-LEVEL
X51      TITLE 'IEX51 - TERMINATION OF COMPILATION, ALGOL F'
*
*        FUNCTION/OPERATION -
*        THE TABLES NEEDED AT OBJECT TIME ARE PREPARED AND
*        INCLUDED IN THE OBJECT MODULE. THEY ARE PROGRAM BLOCK
*        TABLE, LABEL ADDRESS TABLE, AND DATASET TABLE. ESD
*        RECORDS FOR THE REQUIRED LIBRARY ROUTINES ARE GENERATED.
*        THE INFORMATION REQUIRED TO START THE EXECUTION,
*        INCLUDING THE END STMT, IS GENERATED. A TABLE CONTAINING
*        THE DSA SIZES FOR THE PROGRAM BLOCKS IS PREPARED AND
*        TOGETHER WITH THE OBJECT MODULE SIZE OUTPUT TO
*        SYSPRINT
*
*        CSECT IEX60000 -
*        THE ERROR PATTERNS GENERATED DURING COMPILATION PHASE
*        ARE HANDLED AND THE CORRESPONDING DIAGNOSTIC MESSAGES
*        ARE GENERATED
*
*        CSECT IEX51002 -
*        ALL AREAS RESERVED ARE RELEASED AND THE DCBS
*        NOT CLOSED EARLIER ARE CLOSED, THE ORIGINAL PICA IS
*        RESTORED, THE RETURN CODE IS FOUND. CONTROL IS
*        RETURNED TO COMPILER DIRECTORY IEX00
*
*        ENTRY POINTS -
*        IEX51000 - NORMAL END OF COMPILATION
*                   XCTL EP=IEX51000 THE MODULE IS
*                   NORMALLY ENTERED FROM IEX40
*        IEX51ER1 - ABNORMAL END OF COMPILATION
*                   XCTL EP=IEX51ER1 IS USED BY IEX40
*                   AND IEX50
*        IEX51ER2 - ABNORMAL END OF COMPILATION
*                   XCTL EP=IEX51ER2 IS USED BY IEX40
*        IEX51002 - ABNORMAL END OF COMPILATION
*                   XCTL EP=IEX51002 IS USED BY IEX00,
*                   IEX21, AND IEX31
*
*        INPUT - N/A
*
*        OUTPUT -
*        PART OF THE OBJECT MODULE IS GENERATED AND OUTPUT ON
*        SYSLIN AND/OR SYSPUNCH
*        STORAGE REQUIREMENTS AND DIAGNOSTIC MESSAGES ARE
*        OUTPUT ON SYSPRINT
*
*        EXTERNAL ROUTINES -
*        THE PRINT ROUTINE IN IEX00 IS USED
*
*        EXIT - NORMAL-
*        CONTROL IS GIVEN TO COMPILER DIRECTORY, IEX00, BY MEANS
*        OF THE RETURN MACRO INSTRUCTION
*
*        EXIT - ERROR -
*        AFTER PROGRAM INTERRUPTS AND I/O ERRORS THE MODULE GETS
*        CONTROL BACK AND EXITS NORMALLY
*
*        TABLES/WORKAREAS -
*        THE MESSAGE TEXTS WITH CORRESPONDING ADDRESS TABLE ARE
*        IN THE LOAD MODULE IEX51M
*        THE ERROR MESSAGE EDITING ROUTINE, CSECT IEX60000, ALSO
*        USES THE FOLLOWING TABLES -
*        WINTEBC  - TRANSLATION OF INTERNAL CHARACTERS TO EBCDIC
*        WSYMBSRC - TRANSLATION OF SOURCE OPERATORS
*        WSYMBSTK - TRANSLATION OF INTERNAL SYMBOLS TO EBCDIC
*        WORDSEBC - TRANSLATION OF COMPOUND SYMBOLS IF SOURCE IN
*                   EBCDIC
*        WORDSISO - TRANSLATION OF COMPOUND SYMBOLS IF SOURCE IN
*                   ISOCODE
*        WEBCDIC  - TRANSLATION EBCDIC-EBCDIC
*        A WORKAREA OF 270 BYTES, WAREA, IS USED FOR BUILDING
*        THE MESSAGES
*
*        FOR THE EXTERNAL REFERENCES TO THE LIBRARY ROUTINES ONE
*        OF THE TABLES SHRTAB AND LNGTAB, CONTAINING THE MODULE
*        NAMES, IS USED. THE GENERATE ROUTINE USES THREE TABLES,
*        ESDT, TXTT, AND RLDT, FOR GENERATION OF THE DIFFERENT
*        TYPES OF OBJECT RECORDS.
*
*        THE PART OF COMMON WORKAREA STARTING AT SYSUT1 IS
*        INITIALIZED BY THE LOAD MODULE IEX40 AND IS USED BY THIS
*        AND THE PRECEDING LOAD MODULE
*
*        ATTRIBUTES - NONE
*
*        NOTES -
*        CHARACTER CODE DEPENDENCE -
*
*        CSECT IEX51000 -
*        THE OPERATION OF THE ROUTINES GENERATE AND PRINT
*        STORAGE REQUIREMENTS DEPENDS UPON AN INTERNAL
*        REPRESENTATION OF THE EXTERNAL CHARACTER SET WHICH IS
*        EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME.
*
*        CSECT IEX60000 -
*        FOR THE BUILDING OF A MESSAGE (CODE PART BETWEEN COT03
*        AND COT12) THE FOLLOWING APPLIES -
*        IN CASE NO SOURCE INFORMATION IS TO BE INSERTED
*        (COT31), OR IF THE INFORMATION IS EBCDIC-CHARACTERS
*        (COT07), THE OPERATION OF CSECT IEX60000 DEPENDS UPON AN
*        INTERNAL REPRESENTATION OF THE EXTERNAL CHARACTER SET
*        WHICH IS EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME.
*        IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL
*        CHARACTERS (COT33) THE OPERATION OF CSECT IEX60000
*        DEPENDS UPON A TRANSLATION FROM THE INTERNAL
*        REPRESENTATION TO THE EBCDIC CHARACTER SET BY MEANS OF
*        THE TABLE 'WINTEBC'.
*        IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL
*        ALGOL SYMBOLS (COT10) THE OPERATION OF CSECT IEX60000
*        DEPENDS UPON A TRANSLATION FROM THE INTERNAL
*        REPRESENTATION TO THE EBCDIC CHARACTER SET BY MEANS OF
*        THE TABLES 'WSYMBSTK'/'WSYMBSRC' AND 'WORDSISO'/
*        'WORDSEBC'.
*
*        FOR THE OUTPUT OF A MESSAGE (CODE PART BETWEEN COT12
*        AND COT21) THE FOLLOWING APPLIES -
*        WHEN A MESSAGE HAS BEEN BUILT IN EBCDIC, AN EBCDIC-
*        EBCDIC TRANSLATION IS PERFORMED BEFORE OUTPUT BY MEANS
*        OF THE TABLE 'WEBCDIC'. THUS THE OUTPUT MAY BE MODIFIED
*        BY MAKING CHANGES IN THIS TABLE.
*
*        THE OPERATION OF THE OTHER PARTS DOES NOT DEPEND UPON A
*        PARTICULAR INTERNAL REPRESENTATION OF THE EXTERNAL
*        CHARACTER SET.
*
*        THIS MODULE WILL BE LINKED TOGETHER WITH THE MODULE
*        IEX51M TO FORM THE MODULE IEX51
*
*        THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN
*        CONNECTION WITH THE OTHER MODULES OF THE ALGOL COMPILER
*        IN PARTICULAR IT REQUIRES THE COMMON WORKAREA
*
IEX51000 CSECT
*
*        DEFINITIONS
*
RASLGT   EQU   2048                    LENGTH OF RETURN ADDR STACK
LPGCF    EQU   28                      LENGTH OF PUT/GET CONTROL FIELD
*
*        ENTRY POINTS
*
         ENTRY IEX51ER1
         ENTRY IEX51ER2
*
         IEXENTRY 'IEX51000 LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IEX51000,R10
         USING WORKAREA,R13
*
         LR    R10,R15
         SR    R8,R8
*
*        TEST MODE
*
TRM1     LA    R2,IEX51ER1             GIVE DIRECTORY
         ST    R2,ERET                 RETURN ADDR
         OI    COMPFLGS+2,NOSC         INDICATE NO SC AVAILABLE
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    TRM10                   YES, BYPASS ALL CODE GENERATION
         TM    COMPFLGS+1,NLOAD+NDECK  NOLOAD AND NODECK SPECIFIED ?
         BO    TRM10                   YES, NO CODE GENERATION
*
*        GENERATE LAT, TXT RECORDS
*
TRM8     ST    R6,PRPTAR               SET
         TM    PRPTAR+3,X'02'          PRPOINTER
         BZ    TRM4                    TO
         LA    R2,ZEROHW               FULL WORD BOUNDARY
         BAL   R14,GENTXTS
         DC    H'2'                    GENERATE 2 BYTES
*
TRM4     ST    R6,ALAT                 SAVE PRPOINTER AT LAT-BEGIN
         L     R2,LATAB                GET ADDR OF LAT
         LH    R3,LN                   GET DISPLACEMENT OF LAST LABEL
         LA    R3,4(,R3)               LENGTH OF LAT
         STH   R3,TRM39                STORE LENGTH IN TRM39
         BAL   R14,GENTXTS             GENERATE TXT RECORDS
TRM39    DC    H'0'                    LENGTH OF LAT
*
*        RLD RECORDS FOR LAT
*
TRM40    LH    R3,TRM39                GET LENGTH OF LAT
         LA    R4,LATBEG+4             GET LENGTH OF 1ST PART
         SR    R3,R4                   GET LENGTH OF LAST PART
         BNP   TRM42                   ¬> ZERO, BRANCH
         STH   R3,TRM41                STORE LENGTH OF LAST PART
         L     R2,ALAT                 GET PRPOINTER AT LAT BEGIN
         LA    R2,LATBEG+4(,R2)        PRPOINTER AT LAST PART
         BAL   R14,GENRLD              GENERATE RLD RECORD
TRM41    DC    H'0'                    LENGTH OF LAST PART
         DC    H'1'
         DC    H'1'
*
*        ESD RECORDS FOR LAT
*
TRM42    L     R5,LATAB                GET ADDR OF LAT
         LA    R7,LATNR                GET NO OF ENTRIES FOR ST FUNCTS
         LA    R9,SHRTAB               ADDR TABLE FOR SHORT PREC
         TM    COMPFLGS,LNG            LONG PRECISION  ?
         BZ    TRM44                   NO, BRANCH
         LA    R9,LNGTAB               LONG, CHANGE ADDR
TRM44    CLI   0(R5),0                 ROUTINE USED ?
         BNE   TRM45                   NO
         MVC   TRM43+3(5),0(R9)        YES, MOVE NAME TO ESD CALL
         BAL   R2,GENESD               GENERATE ESD RECORD
TRM43    DC    CL8'IHI     '
         DC    X'02'
*
TRM45    LA    R5,4(,R5)               STEP
         LA    R9,5(,R9)               ADDRS
         BCT   R7,TRM44                HANDLE NEXT ENTRY IF ANY
*
*        RLD RECORDS FOR ESD ENTRIES IN LAT
*
TRM46    L     R11,ALAT                GET PRPOINTER AT LAT BEGIN
         L     R5,LATAB                GET ADDR OF LAT
         LA    R7,LATNR                GET NO OF ENTRIES FOR ST FUNCS
         LA    R9,1                    INIT REG FOR R ESID FOR RLDCALL
*
TRM49    CLI   0(R5),0                 ROUTINE USED ?
         BNE   TRM48                   NO
         LA    R9,1(,R9)               YES, GET ESID FOR R
         STH   R9,TRM47                GIVE TO RLD-CALL
         LR    R2,R11
         BAL   R14,GENRLD              GENERATE RLD RECORD
         DC    H'4'                    LENGTH OF ADDR TABLE
TRM47    DC    H'0'                    ESID OF RELOC FACTOR R
         DC    H'1'                    ESID OF POSITION IDENTIFIER P
*
TRM48    LA    R11,4(,R11)             STEP
         LA    R5,4(,R5)               ADDRS
         BCT   R7,TRM49                HANDLE NEXT ENTRY IF ANY
*
*        GENERATE PBTAB, 4TH VERSION, TXT RECORDS
*
TRM2     ST    R6,APBT                 STORE PRPOINTER
         LA    R3,PBTAB3+4             GET START
         L     R4,APBTAB4              ADDRS
         ST    R8,0(,R4)               SET ZEROES
         LH    R2,PBN                  GET NUMBER OF PROGRAM BLOCKS
         LA    R4,4(,R4)               STEP ADDR
         MVC   0(4,R4),PIDENT          INSERT PROGRAM IDENTIFICATION
TRM5     ST    R8,4(,R4)               INSERT ZEROES
         LA    R4,8(,R4)               STEP ADDR
         L     R11,0(,R3)              TAKE PBTAB3 ENTRY
         LH    R5,ONEENTRY             ADD
         SLL   R5,16                   SIZE OF
         AR    R11,R5                  ONE ENTRY
         ST    R11,0(,R4)              IN DSA
         LA    R3,4(,R3)               STEP ADDR
         BCT   R2,TRM5                 MOVE NEXT IF ANY
         LA    R4,4(,R4)
         LH    R2,KBN                  GET NUMBER
         LTR   R2,R2                   OF LAST CONST BLOCK
         BZ    TRM7                    NO MORE BLOCK THAN NR ZERO
         SH    R2,PBN                  GET NO OF CONST BLKS EXCEPT 0
         LH    R3,KH4096               GET LENGTH OF CONST BLOCK
         LR    R5,R3
         ST    R8,4(,R4)               INSERT ZEROES
TRM6     ST    R3,0(,R4)               STORE DISP OF CONST BLOCK
         LA    R4,8(,R4)               STEP ADDR
         AR    R3,R5                   INCREASE DISPLACEMENT
         BCT   R2,TRM6                 STORE NEXT IF ANY
*
TRM7     L     R2,APBTAB4              GET ADDR OF PBTAB4
         LR    R5,R4                   COMPUTE
         SR    R5,R2                   LENGTH OF
         STH   R5,TRM7AA               PBTAB4
         BAL   R14,GENTXTS             GENERATE TXT RECORDS
TRM7AA   DC    H'0'                    LENGTH OF PBTAB4
*
*        RLD RECODS FOR PBTAB4
*
TRM52    L     R7,APBT                 GET PRPOINTER AT PBTAB4 BEGIN
         B     TRM53                   GENERATE RLD RECORD
*
TRM70    NI    TRM71+1,X'0F'           CHANGE BRANCH CONDITION
         LH    R5,KBN                  GET NUMBER OF LAST CONST BLOCK
         CR    R8,R5                   ZERO ?
         BE    TRM10                   YES
         LH    R2,PBN                  NO, GET NUMBER OF
         SR    R5,R2                   CONST BLKS EXC 0
         SLL   R2,3                    GET PRPOINTER
         LA    R7,8(R2,R7)             AT SECOND CONST BLK
TRM53    LR    R2,R7
         BAL   R14,GENRLD
         DC    H'4'
         DC    H'1'
         DC    H'1'
*
TRM71    B     TRM70                   BRANCH AFTER FIRST RECORD
         LA    R7,8(,R7)               STEP ADDR
         BCT   R5,TRM53                HANDLE NEXT ENTRY IF ANY
*
*        CONSTRUCT DATASET TABLE
*
TRM10    LA    R2,DSTAB                GET ADDR OF DSTAB
         ST    R6,DSTABPRP             STORE PRPOINTER
         LA    R7,IOTAB                GET ADDR OF IOTAB
         LA    R5,15                   LOAD MAX DS NUMBER
         TM    16(R7),X'FF'            UNDET DS NO OCCURRED ?
         BNZ   TRM12A                  YES, MDSN=15
         LA    R3,15                   DETERMINE
         LA    R11,1
TRM11    LA    R4,0(R3,R7)
         CLI   0(R4),0
         BNE   TRM11A                  MAX
         BCTR  R3,0                    DS
         CR    R3,R11
         BNE   TRM11
TRM11A   LR    R5,R3                   NUMBER USED
         STH   R3,MDSN                 USED
TRM12A   BCTR  R5,0                    GET MAX DS NUMBER MINUS ONE
TRM12    LA    R3,36                   CALC
         MH    R3,MDSN                 LGT OF DSTAB
         LA    R3,40(,R3)              WITHOUT PGCF
         STH   R3,DSTABLGT
         LA    R3,0(R3,R6)             STORE
         ST    R3,0(,R2)               PGCF-POINTER
         SR    R11,R11                 LOAD DS NO FOR ERROR PATTERN
         TM    0(R7),X'70'             CORRECT SPEC FOR SYSIN
         LA    R14,TRM19               GET RETURN ADDR FOR ERROR RTN
         BNZ   ERR188                  NO, GENERATE ERROR PATTERN
         MVC   4(DSTABLEL,R2),DSTABLE  YES, INSERT STANDARD DSTABLE
         LA    R11,1                   LOAD DS NR FOR ERROR PATTERN
         TM    1(R7),X'A0'             CORRECT SPEC FOR SYSPRINT
         BNZ   ERR188                  NO, GENERATE ERROR PATTERN
         MVC   40(DSTABLEL,R2),DSTABLE YES, INSERT STANDARD DSTABLE
         MVI   66(R2),X'02'            CHANGE DS FIELD
         MVI   74(R2),X'02'
TRM19    LR    R3,R5                   GET MAX DS NUMBER MINUS ONE
         LTR   R3,R3                   ZERO ?
         BZ    TRM22                   YES, BYPASS MANIP ON BYTES 2-15
         NI    16(R7),X'EF'            RESET SYSACT8 BIT
         TM    16(R7),X'01'            PRE COMP PROCEDURE ?
         BZ    TRM192                  NO
         LA    R4,76(,R2)              GET ADDR OF DS2 IN DSTAB
TRM191   MVC   0(DSTABLEL,R4),DSTABLE  MOVE STANDARD DSTABLE
         MVI   26(R4),X'42'            CHANGE DS FIELD
         MVI   34(R4),X'42'
         LA    R4,DSTABLEL(,R4)        NEXT DS NUMBER IN DSTAB
         BCT   R3,TRM191
         B     TRM22
*
TRM192   TM    16(R7),X'FF'            BYTE 16 ZERO ?
         BZ    TRM15                   YES
TRM14    LA    R4,1(R3,R7)             NO, OR
         TM    0(R4),X'10'                    BYTE 16
         BO    TRM14A                                 INTO BYTES NOT
         OC    0(1,R4),16(R7)          CONTAINING
TRM14A   BCT   R3,TRM14                           SYSACT8 INDICATION
TRM15    LR    R3,R5                   GET MAX DS NUMBER MINUS ONE
TRM16    LA    R4,1(R3,R7)             INDICATE
         TM    0(R4),X'C0'                      SYSACT4/13
         BNO   TRM16A                                   IN BYTES
         OI    0(R4),X'20'             WITH INPUT AND OUTPUT INDIC
TRM16A   BCT   R3,TRM16
         LR    R3,R5                   GET MAX DS NR MINUS ONE
TRM17    LA    R4,1(R3,R7)
         LA    R11,1(,R3)              LOAD DS NUMBER FOR ERROR PATTERN
         TM    0(R4),X'10'             SYSACT8 INDICATED ?
         BZ    TRM18                   NO
         TM    0(R4),X'A0'             YES, INPUT OR SYSACT4/13 IND ?
         BZ    TRM17A                  NO
         LA    R14,TRM18               YES, GENERATE ERROR PATTERN
         B     ERR188
*
TRM17A   NI    0(R4),X'F7'             RESET UNDET SYSACT BIT
TRM18    BCT   R3,TRM17                EXAMINE NEXT BYTE IF ANY
         LR    R3,R5                   GET MAX DS NR MINUS ONE
         LA    R4,76(,R2)              GET ADDR OF DS2 IN DSTAB
         LA    R1,2(,R7)               GET ADDR OF 2ND BYTE IN IOTAB
TRM20    MVC   0(DSTABLEL,R4),DSTABLE  MOVE STANDARD MASK
         TM    0(R1),X'28'             SYSACT4/13 OR UND SA IND ?
         BNZ   TRM21                   YES
         TM    0(R1),X'40'             NO, OUTPUT INDICATED ?
         BZ    TRM211
         MVI   26(R4),X'02'            YES, CHANGE DS FIELD
         MVI   34(R4),X'02'
         B     TRM211
*
TRM21    TM    0(R1),X'40'             OUTPUT INDICATED ?
         BO    TRM21A                  YES
         MVI   26(R4),X'40'            NO, CHANGE DS FIELD
         MVI   34(R4),X'40'
         B     TRM211
*
TRM21A   MVI   26(R4),X'42'            CHANGE DS FIELD
         MVI   34(R4),X'42'
TRM211   LA    R4,36(,R4)              NEXT DS NUMBER IN DSTAB
         LA    R1,1(,R1)               NEXT BYTE IN IOTAB
         BCT   R3,TRM20
TRM22    TM    17(R7),X'FF'            BYTE 17 ZERO ?
         BZ    TRM27                   YES
         LH    R3,DSTABLGT             NO, GET ADDR OF PGCFIELD
         LA    R3,0(R3,R2)
         MVI   0(R3),0                 INSERT ZEROES IN PGCF
         MVC   1(27,R3),0(R3)
         LA    R4,2048                 INITIATE BE-FIELD
         ST    R4,16(,R3)
         B     TRM23
*
TRM27    MVI   0(R2),X'80'             INDICATE NO PUT/GET
*
*        GENERATE DSTABLE, TXT RECORDS
*
TRM23    TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    TRM37                   YES, BYPASS CODE GENERATION
         TM    COMPFLGS+1,NLOAD+NDECK  NOLOAD AND NODECK SPECIFIED ?
         BO    TRM37                   YES, NO CODE GENERATION
         TM    COMPFLGS,PROC           PROCEDURE COMPILATION ?
         BO    TRM24                   YES
         LH    R3,DSTABLGT             GET LEN OF DSTAB WITHOUT PGCF
         CLI   0(R2),X'80'             THERE A PGCF ?
         BE    TRM23A                  NO
         LA    R3,LPGCF(,R3)           YES, ADD PGCF LENGTH
TRM23A   STH   R3,TRM23B               STORE LENGTH IN CALLING SEQ
         BAL   R14,GENTXTS             GENERATE TXT RECORDS
TRM23B   DC    H'0'                    LENGTH OF DSTAB
*
*        RLD RECORD FOR PGCF ADDR IN DSTAB
*
TRM32    L     R2,DSTABPRP             GET PRPOINTER AT DSTAB BEGIN
         BAL   R14,GENRLD              GENERATE RLD RECORD
         DC    H'4'                    LENGTH OF ADDR
TRM32ID  DC    H'1'                    ESD ID
         DC    H'1'
*
*        GENERATE TXT RECORDS ADDR TABLE
*
TRM24    MVC   ASTART(3),PRPT+1        GET PRPOINTER AT FIRST INSTR
         TM    COMPFLGS,LNG            LONG PRECISION ?
         BZ    TRM24A                  NO, SHORT, BRANCH
         MVI   SW,0                    LONG, CHANGE MASK
TRM24A   ST    R6,ADRPRP               STORE PRPOINTER AT ADR TABLE
         LA    R2,APBT                 GET ADDR OF TEXT
         BAL   R14,GENTXTS
         DC    H'12'                   LENGTH OF TEXT
*
*        ESD RECORD FOR FSA ADDR
*
TRM28    TM    COMPFLGS,PROC           PROCEDURE COMPILATION ?
         BO    TRM54                   YES
         BAL   R2,GENESD               GENERATE ESD RECORD
TRM29    DC    C'IHIFSAIN'
         DC    X'0200'
*
*        RLD RECORDS FOR ADDR TABLE
*
TRM54    L     R2,ADRPRP               GET PRPOINTER AT ADDR TABLE
         BAL   R14,GENRLD              GENERATE RLD RECORDS
         DC    H'12'
         DC    H'1'
         DC    H'1'
*
*        ESD RECORD, LD ENTRY, FOR ENTRY INFO
*
TRM25    TM    COMPFLGS,PROC           PROCEDURE COMPILATION ?
         BO    TRM35                   YES, BYPASS NEXT TWO RECORDS
         MVC   TRM26(3),ADRPRP+1       MOVE PRPOINTER TO CALL
         BAL   R2,GENESD
         DC    CL8'IHIENTIF'           NAME
         DC    X'01'
TRM26    DC    X'000000'               PRPOINTER
         DC    C' '
         DC    X'000001'
*
*        ESD RECORD, LD ENTRY, FOR DSTAB
*
TRM56    MVC   TRM57(3),DSTABPRP+1     MOVE PRPOINTER TO CALL
         BAL   R2,GENESD
         DC    CL8'IHIDSTAB'           NAME
         DC    X'01'
TRM57    DC    X'000000'               PRPOINTER
         DC    C' '
         DC    X'000001'
*
*        GENERATE END RECORD
*
TRM35    TIME
*
         ST    R1,SV                   USE A SAVEAREA AS A WORKAREA
         UNPK  ENDRECD,SV+1(3)         DATE OF COMPILE
         ST    R6,ENDRECL              STORE LENGTH OF CSECT IN ENDREC
         TM    COMPFLGS,PROC           PROCEDURE COMPILATION ?
         BO    TRM34                   YES, BRANCH
         MVC   ENDRECN,TRM29           MOVE IN ENTRY POINT ESD NAME
         B     TRM33
*
TRM34    MVC   ENDRECA,ADRPRP+1        ADDR TABLE IS ENTRY POINT
         MVC   ENDRECID,TRM32ID        GET ESD ID FOR ENTRY POINT
TRM33    MVC   ENDRECK,PIDENT          INSERT PROGRAM IDENT
         AP    CARDCNT,KP1             INCR SEQUENCE NUMBER
         UNPK  ENDRECC,CARDCNT         CONVERT TO CHARACTER
         OI    ENDRECC+3,X'F0'         MAKE PRINTABLE
         TM    COMPFLGS+1,NLOAD        NOLOAD ?
         BO    TRM50A                  YES, BRANCH
         L     R1,ALINDCB              R1 -> SYSLIN DCB

         PUT   (R1)                    PUT FOR SYSLIN

         MVC   0(L'ENDREC,R1),ENDREC
TRM50A   TM    COMPFLGS+1,NDECK        NODECK ?
         BO    TRM51                   YES, BRANCH
         L     R1,APCHDCB              R1 -> SYSPUNCH DCB

         PUT   (R1)                    PUT FOR SYSPUNCH

         MVC   0(L'ENDREC,R1),ENDREC
*
*        PRINT STORAGE REQUIREMENTS
*
TRM51    MVI   LINCNT+1,255            FORCE HEADINGS TO BE PRINTED
         MVI   PAGEHD1C+1,C' '         BLANK FIRST HEADING LINE
         MVC   PAGEHD1C+2(109),PAGEHD1C+1
         MVC   PAGEHD2D(L'PAGEHD2D),PAGEHD1D  BLANK SEC HEADING LINE
         MVC   PAGEHD3D(L'PAGEHD3D),PAGEHD1D  BLANK 3RD HEADING LINE
         MVC   PAGEHD1D+35(L'HEAD1),HEAD1
         CVD   R6,DEC                  CONVERT LENGTH OF OBJECT MODULE
         BAL   R14,EDNR                EDIT TO PRINTABLE FORMAT
         MVC   KOBJSZB,EDAREA+2        MOVE OBJ SIZE INTO MSG
         BAL   R14,PRINTT              OBTAIN OUTPUT BUFFER
         MVC   0(KOBJSZL,R1),KOBJSZ    MOVE MSG INTO BUFFER
         BAL   R14,PRINTT              OBTAIN OUTPUT BUFFER
         MVC   0(L'KDSA,R1),KDSA       SECOND PRINT LINE
         BAL   R14,PRINTT              OBTAIN OUTPUT BUFFER
         LA    R2,5                    GET NO OF ENTRIES IN ONE LINE
TRM60    MVC   0(L'KPBN,R1),KPBN       BUILD THIRD PRINT LINE
         LA    R1,L'KPBN+7(,R1)        BUMP BUFFER POINTER
         BCT   R2,TRM60                LOOP 5 TIMES
         BAL   R14,PRINTT
         L     R3,APBTAB4              INITIATE
         LH    R8,PBN                           REGISTERS
         SR    R4,R4                                      FOR TABLE
TRM62    LA    R2,5                    INITIATE FOR EACH PRINT LINE
TRM61    LA    R4,1(,R4)                                 ENTRY
         CVD   R4,DEC                  CONVERT
         UNPK  BLNR,DEC+6(2)                   AND MOVE
         OI    BLNR+2,X'F0'                             BLOCK
         MVC   0(L'BLNR,R1),BLNR                              NUMBER
         LA    R3,8(,R3)               GET PBTAB ENTRY
         LH    R11,4(,R3)              GET DSA SIZE
         CVD   R11,DEC                 CONVERT TO DECIMAL
         BAL   R14,EDNR                EDIT
         MVC   6(5,R1),EDAREA+3        MOVE IN VALUE
TRM65    BCTR  R8,0
         LTR   R8,R8                   ALL PBTAB ENTRIES HANDLED ?
         BZ    TRM37                   YES
         LA    R1,18(,R1)              MAKE NEXT ENTRY
         BCT   R2,TRM61                IF LINE NOT FULL
         BAL   R14,PRINTT              OBTAIN PRINT BUFFER
         B     TRM62
*
*        OBTAIN OUTPUT BUFFER
*
*        ON RETURN R1 -> BUFFER
*
PRINTT   STM   R14,R15,SV              SAVE R14 AND R15
         L     R15,PRTRTADD
         BALR  R14,R15                 CALL PRINT ROUTINE
         LM    R14,R15,SV              RESTORE REGS
         BR    R14
*
*        EDIT DECIMAL NUMBER
*
EDNR     MVC   EDAREA,EDPTRN           MOVE PATTERN
         ED    EDAREA,DEC+4            EDIT
         BR    R14
*
*        DIRECTORY RETURN BEFORE FREEMAIN
*
IEX51ER1 EQU   *
TRM37    L     R2,FREEMSIZ             GET INFO FOR AREA RELEASE
         L     R1,FREEMADR
*
         FREEMAIN R,LV=(2),A=(1)       RELEASE AREA
*
         BALR  R15,0                   LOAD NEW BASE REGISTER
*
IEX51ER2 EQU   *                       TERMINATION
         USING *,R15
*
TRM38    L     R2,=A(IEX60000)         R2 -> IEX60000
         L     R14,=A(IEX51002)        LOAD RETURN ADDR
         LA    R1,ERRINFO              ADDR INFO FOR ERROR ED ROUT
         BR    R2                      GOTO ERROR MESSAGE EDITING
*
*        LTORG
*
         LTORG
*
         DROP  R15
*
*        GENERATE A PATTERN FOR ERROR MSG 188
*
ERR188   SR    R9,R9
         LA    R9,10
         CR    R11,R9                  DS NUMBER 9 OR LOWER
         BL    ER1                     YES
         SR    R11,R9                  NO, SUBTRACT 10
         STC   R11,EP188+11            STORE
         TR    EP188+11(1),NRTRA       CONVERT TO CHARACTER
         MVI   EP188+10,C'1'           INSERT FIRST DIGIT
         LA    R9,13                   GET L'ENTRY
         B     ER2
*
ER1      STC   R11,EP188+10            STORE NUMBER
         TR    EP188+10(1),NRTRA       CONVERT IT
         MVI   EP188+11,C'.'           INSERT PERIOD
         LA    R9,12                   GET LENGTH OF ENTRY
ER2      STC   R9,EP188                INSERT LENGTH OF ENTRY
         OI    EP188,X'80'             PUT A TAG FOR BLANK SC
         BCTR  R9,0                    DECREASE BY ONE
         STC   R9,ER3+1                STORE LENGTH IN MOVE INSTR
         L     R11,NEXTERR             GET NEXT ENTRY IN POOL
ER3      MVC   0(0,R11),EP188          MOVE PATTERN
         LA    R11,1(R9,R11)           UPDATE PTR TO NEXT FREE ENTRY
         ST    R11,NEXTERR
         C     R11,ENDPOOL             POOL FULL ?
         BH    ER4                     YES
         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         BR    R14                     RETURN
*
ER4      MVC   0(4,R11),EP0            MOVE PATTERN EP0
         LA    R11,4(,R11)             UPDATE PTR
         ST    R11,NEXTERR             STORE IT
         B     TRM37                   TERMINATE COMPILATION
*
*        CONSTANTS AND AREAS
*
PRPTAR   DC    A(0)                    AREA TO HANDLE PRPOINTER
DSTABPRP DC    A(0)                    PRPOINTER AT DSTAB BEGIN
AFSAPRP  DC    A(0)                    PRPOINTER AT AFSA
ADRPRP   DC    A(0)                    PRPOINTER AT APBT
MDSN     DC    H'15'                   MAX DS NUMBER
KH4096   DC    H'4096'                 LENGTH OF CONSTANT BLOCK
*
*        GENERATE MODEL DATASET TABLE ENTRY
*
         DSTABLE  DSECT=NO
*
DSTABLGT DC    H'0'                    LENGTH OF DSTAB WITHOUT PGCF
*
*        END RECORD
*
         DC    0F'0'
ENDREC   DC    CL80' '             *   IMAGE FOR END RECORD
         ORG   ENDREC              |   COLS
         DC    X'02'               |   1
         DC    C'END'              |   2-4
         DC    C' '                |   5
ENDRECA  DC    C'   '              |   6-8   ENTRY ADDR
         DC    C'      '           |   9-14
ENDRECID DC    C'  '               |   15-16 ESDID OF ENTRY POINT
ENDRECN  DC    C'        '         |   17-24
         DC    C'    '             |   25-28
ENDRECL  DC    C'    '             |   29-32 CSECT LENGTH
         DC    C'1'                |   33    NUMBER OF IDR ITEMS
         DC    C'360SAL531 '       |   34-43 TRANSLATOR PRODUCT IDR
         DC    C'0201'             |   44-47 VERSION AND RELEASE NUMBER
ENDRECD  DC    C'99999'            |   48-52 PROCESSING DATE
         ORG   ENDREC+72           |
ENDRECK  DC    CL4' '              |   73-76 DECK ID
ENDRECC  DC    CL4' '              V   77-80 RECORD COUNT
         ORG   ,
*
APBT     DC    A(0)                    ADDR OF PBT
ALAT     DC    A(0)                    ADDR OF LAT
SW       DC    X'20'                   SWITCH FOR LONG/SHORT PREC
ASTART   DC    AL3(0)                  ADDR OF FIRST INSTRUCTION
*
HEAD1    DC    C'STORAGE REQUIREMENTS (DECIMAL)'
*
KOBJSZ   DC    C'OBJECT MODULE SIZE'
KOBJSZB  DC    CL6' '
         DC    C' BYTES'
KOBJSZL  EQU   *-KOBJSZ                L'OBJECT SIZE MESSAGE
*
KDSA     DC    C'DATA STORAGE AREA SIZES'
KPBN     DC    C'PBN   BYTES'
DEC      DC    D'0'                    FOR CONVERSION OF NUMBERS
EDPTRN   DC    X'4020202020202020'     PATTERN FOR EDITING
EDAREA   DC    CL8' '                  EDITING OF NUMBERS
BLNR     DC    CL3' '                  FOR CONVERSION OF BLOCK NUMBER
SV       DC    2F'0'                   SAVE AREA
*
EP188    DC    X'00BC0000'             ERROR PATTERN FOR MESSAGE 188
         DC    C'DSN = 00.'
*
EP0      DC    X'04000000'             ERROR PATTERN FOR MESSAGE 0
*
NRTRA    DC    C'0123456789'           TRANSLATION OF DS NUMBER
*
ERRINFO  DC    V(IEX51M00)             ADDR OF MESSAGE TEXTS
         DC    V(IEX51M01)             ADDR OF ADDR TABLE
         DC    H'12'                   MODIFICATION NUMBER
*
         DC    0F'0'
*
*        LIBRARY ROUTINES - SHORT
*
SHRTAB   DC    C'SYSCT'
         DC    C'SSQ  '
         DC    C'SSCS '
         DC    C'SSCC '
         DC    C'SAT  '
         DC    C'SLO  '
         DC    C'SEX  '
         DC    C'ISYMB'
         DC    C'IDEIR'
         DC    C'IDEII'
         DC    C'IBOOL'
         DC    C'IARRY'
         DC    C'IARRT'
         DC    C'IBARR'
         DC    C'OSYMB'
         DC    C'SOREL'
         DC    C'OINTG'
         DC    C'OBOOL'
         DC    C'OARRY'
         DC    C'OTARR'
         DC    C'OBARR'
         DC    C'OSTRG'
         DC    C'GPRPT'
         DC    C'GPRGT'
         DC    C'FII  '
         DC    C'FRI  '
         DC    C'FRR  '
*
*        LIBRARY ROUTINES - LONG
*
LNGTAB   DC    C'SYSCT'
         DC    C'LSQ  '
         DC    C'LSCS '
         DC    C'LSCC '
         DC    C'LAT  '
         DC    C'LLO  '
         DC    C'LEX  '
         DC    C'ISYMB'
         DC    C'IDEIR'
         DC    C'IDEII'
         DC    C'IBOOL'
         DC    C'IARRY'
         DC    C'IARRT'
         DC    C'IBARR'
         DC    C'OSYMB'
         DC    C'LOREL'
         DC    C'OINTG'
         DC    C'OBOOL'
         DC    C'OARRY'
         DC    C'OTARR'
         DC    C'OBARR'
         DC    C'OSTRG'
         DC    C'GPRPT'
         DC    C'GPRGT'
         DC    C'FII  '
         DC    C'FDI  '
         DC    C'FDD  '
*
***********************************************************************
*
*        S U B R O U T I N E   G E N E R A T E
*
***********************************************************************
*
*        REGISTER DEFINITIONS
*
*        R1                            OUTPUT RECORD POINTER
*        R2                            ADDR OF DATA
*        R3                            TYPE OF RECORD TO BE GENERATED
*        R4                            RETURN REGISTER
*        R14                           LENGTH OF DATA FROM CALL
*        R15                           LENGTH WITHIN RECORD
*
*        BIT PATTERNS
*
SDENTRY  EQU   X'00'                   SD ENTRY IDENTIFICATION
LDENTRY  EQU   X'01'                   LD ENTRY IDENTIFICATION
RLDFLAG  EQU   B'00001100'             FLAG USED IN RLD ENTRY
*
*        GENERATE ESD RECORDS
*
GENESD   LA    R14,16                  LENGTH ALWAYS 16
         LA    R3,ESDT                 INDICATE ESD CALL
         B     GEN1
*
*        GENERATE TXT RECORDS
*
GENTXTS  LA    R4,2(,R14)              COMPUTE RETURN ADDR
         LH    R14,0(,R14)             LOAD LENGTH GIVEN IN CALL
GEN2     LA    R3,TXTT                 INDICATE TXT CALL
         B     GEN1                    CONTINUE COMMON PART
*
*        GENERATE RLD RECORDS
*
GENRLD   LA    R4,6(,R14)              COMPUTE RETURN ADDR
         LA    R3,RLDT                 INDICATE RLD CALL
         MVC   RANDP(4),2(R14)         INSERT NEW R AND P
         LH    R14,0(,R14)             LOAD LENGTH GIVEN IN CALL
         SLL   R14,1                   DOUBLE LENGTH
GEN1     L     R1,SAVOUTA              LOAD ADDR OF OUT RECORD
         CLC   1(3,R1),1(R3)           RECORD RIGHT TYPE ?
         BNE   GEN3                    NO, CALL FOR NEW
         CLC   10(2,R1),12(R3)         RECORD FILLED ?
         BNL   GEN3                    YES, CALL FOR NEW
GEN6     LA    R15,56
         LH    R0,10(,R1)              R0=LENGTH OF DATA IN REC
         SR    R15,R0                  R15=EMPTY POS LEFT IN RECORD
         CR    R15,R14                 ENOUGH SPACE LEFT ?
         BL    *+6                     NO
         LR    R15,R14                 YES, R15=LENGTH FROM CALL
         AR    R15,R0
         STH   R15,10(,R1)             INSERT NEW LENGTH INTO RECORD
         SR    R15,R0
         AR    R1,R0                   START ADDR WITHIN RECORD
         SR    R14,R15                 REMAINING LENGTH
         B     14(,R3)                 TO DIFFERENT MOVE ROUTINES
*
GEN4     LTR   R14,R14                 MORE INFORMATION MUST BE MOVED ?
         BH    GEN3                    YES
         BR    R4                      NO, RETURN
*
*        CALL FOR NEW OUTPUT RECORD
*
GEN3     ST    R14,SAVELT              SAVE LENGTH
         TM    COMPFLGS+1,NLOAD+NDECK  DECK AND LOAD SPECIFIED ?
         BZ    BOTH                    YES
         TM    COMPFLGS+1,NDECK        ONLY DECK ?
         L     R1,APCHDCB              R1 -> SYSPUNCH DCB
         BZ    PUT1                    YES
PUT1A    L     R1,ALINDCB              R1 -> SYSLIN DCB
*
PUT1     PUT   (R1)                    PUT FOR SYSLIN AND SYSPUNCH IF
*
         ST    R1,SAVOUTA              ONLY SYSPUNCH SPECIFIED
         L     R14,SAVELT              RESTORE LENGTH
         B     PUNCHOUT
*
BOTH     L     R14,OUTAREA2            COPY SYSLIN BUFFER TO SYSPUNCH
         L     R1,SAVOUTA
         MVC   0(80,R14),0(R1)         BUFFER
PUT2     L     R1,APCHDCB              R1 -> SYSPUNCH DCB
*
         PUT   (R1)                    PUT FOR SYSPUNCH WHEN BOTH HAS
*
         ST    R1,OUTAREA2             BEEN SPECIFIED
         B     PUT1A                   GOTO PUT SYSLIN
*
PUNCHOUT MVC   0(4,R1),0(R3)           INSERT FIRST 4 BYTES
         MVI   4(R1),C' '              INSERT ONE BLANK
         MVC   5(67,R1),4(R1)          BLANK OUTPUT RECORD
         MVC   72(4,R1),PIDENT         INSERT PROGRAM IDENT
         AP    CARDCNT,KP1             INCR SEQUENCE NUMBER
         UNPK  76(4,R1),CARDCNT        CONVERT TO CHARACTER
         OI    79(R1),X'F0'            MAKE PRINTABLE
         MVC   10(2,R1),4(R3)          INSERT INITIAL LENGTH
         MVC   14(6,R1),6(R3)          INSERT ESID + R AND P
         CLC   TXTT+1(3),1(R3)         TXT RECORD PROCESSED ?
         BNE   GEN6                    NO
         ST    R6,4(R1)                YES, INSERT R6
         MVI   4(R1),C' '
         B     GEN6
*
*        ESD RECORD
*
         DC    0H'0'
ESDT     DC    X'02'                   RECORD CODE
         DC    C'ESD'                  IDENTIFICATION
         DC    H'0'                    INITIAL LENGTH 0
         DC    C'      '
         DC    H'48'                   MAXIMUM LENTH IN RECORD
*
*        MOVE ESD INFORMATION TO OUTAREA
*
GEN7     MVC   16(16,R1),0(R2)         MOVE DATA TO OUTAREA
         CLI   8(R2),LDENTRY           LD ENTRY MOVED ?
         BE    16(R2)                  YES, RETURN TO CALLING ROUTINE
         MVC   25(L'ESDCON,R1),ESDCON  CHANGE LAST PART OF ENTRY
         LH    R3,ESID
         LA    R3,1(,R3)               INCR ESD ID
         STH   R3,ESID                 STORE NEW ESID NUMBER
         SR    R1,R0
         CLI   14(R1),C' '             FIRST SD OR ER ENTRY ?
         BNE   10(R2)                  NO, RETURN TO CALLING ROUTINE
         STH   R3,14(R1)               YES, INSERT ESID NUMBER
         B     10(R2)                  RETURN TO CALLING ROUTINE
*
*        TXT RECORD
*
         DC    0H'0'
TXTT     DC    X'02'                   RECORD CODE
         DC    C'TXT'                  IDENTIFICATION
         DC    H'0'                    INITIAL LENGTH 0
         DC    H'1'                    ESID
         DC    C'    '
         DC    H'56'                   MAXIMUM LENGTH
*
*        MOVE TXT INFORMATION OUTAREA
*
GEN8     BCTR  R15,0                   DECR LENGTH
         STC   R15,*+5                 INSERT PROPER LENGTH TO MOVE
         MVC   16(0,R1),0(R2)          MOVE DATA TO OUTAREA
         LA    R6,1(R15,R6)            INCREASE PROGRAM POINTER
         LA    R2,1(R15,R2)            MODIFY DATA ADDR
         B     GEN4                    OUT OF MOVE TXT ROUTINE
*
*        RLD RECORD
*
         DC    0H'0'
RLDT     DC    X'02'                   RECORD CODE
         DC    C'RLD'                  IDENTIFICATION
         DC    H'0'
         DC    C'  '
RANDP    DC    C'    '                 R AND P
         DC    H'56'                   MAXIMUM LENGTH IN RECORD
*
*        MOVE RLD INFORMATION TO OUTAREA
*
GEN9     AR    R15,R1                  INDICATE LAST ENTRY
GEN5     MVC   16(4,R1),RANDP          INSERT R AND P
         ST    R2,20(,R1)              MOVE PROGRAM POINTER VALUE
         MVI   20(R1),RLDFLAG          FLAG TO OUTAREA
         LA    R1,8(,R1)               NEXT ENTRY
         LA    R2,4(,R2)               NEXT PROGRAM POINTER VALUE
         CR    R1,R15                  LAST COLUMN FILLED ?
         BL    GEN5                    NO, CONTINUE
         B     GEN4                    OUT OF MOVE RLD ROUTINE
*
*        VARIABLES AND CONSTANTS
*
SAVELT   DC    F'0'                    SAVE AREA FOR LENGTH
ESID     DC    H'1'                    ESID VARIABLE 1 AT START
ESDCON   DC    X'00000040404040'       ESD CONSTANT 7 BYTES
KP1      DC    PL1'1'                  INCREMENT CARD COUNTER
*
         TITLE 'IEX51 - TERMINATION OF COMPILATION, ERROR MSG EDITING'
*
         COPY  IEX60000
*
         TITLE 'IEX51 - TERMINATION OF COMPILATION'
*
IEX51002 CSECT
*
         BALR  R2,0
         USING *,R2
*
         OI    COMPFLGS+1,TERM         INDICATE THIS ROUTINE IS ENTERED
         LA    R0,CLOSEDCB             PROVIDE DIRECTORY
         ST    R0,ERET                 RETURN ADDR
*
*        FREE THE STORAGE OF THE ERROR POOL AND SOURCE PROG
*        BUFFER 1
*
         TM    COMPFLGS+1,NOBUF        GETMAIN FOR BUFFERS ISSUED ?
         BO    CLOSEDCB                NO, BRANCH
         L     R0,POOLS                SIZE OF ERROR POOL
         A     R0,SRCE1S               SIZE OF SOURCE PROG BUFFER 1
         L     R1,ERRPOOL              ADDR OF ERROR POOL
*
         FREEMAIN R,LV=(0),A=(1)
*
*        CLOSE THE DCBS AND FREE THE BUFFER POOLS
*
CLOSEDCB BALR  R2,0
         USING *,R2
         LA    R0,SPIE                 PROVIDE NEW DIR RETURN ADDR
         ST    R0,ERET
         LM    R3,R12,DCBTABLE         LOAD DCB ADDRS
         USING IHADCB,R8               R8 -> SYSPRINT DCB
         TM    DCBOFLGS,DCBOFOPN       SYSPRINT OPEN ?
         DROP  R8
         BO    CLOSEB                  YES, BRANCH
         OI    SWITCH+1,X'F0'
*
CLOSEB   CLOSE ((3),,(8),,(9),,(11),,(12))
*
         TM    COMPFLGS+1,NLOAD
         BO    FRPPCH                  IF NOLOAD OPTION
         LR    R1,R3                   R1 -> SYSLIN DCB
*
         FREEPOOL (1)                  FREE SYSLIN BUFFERS
*
FRPPCH   TM    COMPFLGS+1,NDECK
         BO    FRPPRT                  IF NODECK OPTION
         LR    R1,R9                   R1 -> SYSPUNCH DCB
*
         FREEPOOL (1)                  FREE SYSPUNCH BUFFERS
*
FRPPRT   LR    R1,R8                   R1 -> SYSIN DCB
SWITCH   NOP   SPIE
*
         FREEPOOL (1)                  FREE SYSIN BUFFERS
*
*        EXECUTE SPIE MACRO
*
SPIE     BALR  R2,0
         USING *,R2
         L     R4,PICAADD
*
         SPIE  MF=(E,(R4))
*
*
*        FIND THE RETURN CODE AND RETURN TO IEX00
*
RTNCODE  TM    COMPFLGS,TERR
         BZ    NOTERM                  IF NO TERMINAL ERROR
         LA    R15,16
         B     RETURNN
*
NOTERM   TM    COMPFLGS,SERR
         BZ    NOSER                   IF NO SERIOUS ERROR
         LA    R15,8
         B     RETURNN
*
NOSER    SR    R15,R15
         TM    COMPFLGS,WERR
         BZ    RETURNN
         LA    R15,4
RETURNN  L     R13,SAVEAREA+4
*
         RETURN (14,12),RC=(15)
*
         LTORG
*
*        DCB
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(DA)
*
         PRINT GEN
*
WORKAREA DSECT
*
         COPY  WORKAREA
*
*        AREA USED BY COMPILATION PHASE
*
         ORG   SYSUT1
*
RETADR   DS    17F                     SAVE AREA
PLACE14  DS    F                          -''-
RUTI     DS    9F                      GPR CONTROL
RUTR     DS    4F                      FLREG CONTROL
GPROLN   DS    H                       LABEL NR OF OBJ PRG ENTRY POINT
KONSUM   DS    H                       WORKPLACE
WORKPL   DS    F                       WORKPLACE
IBUF1    EQU   SRCE1ADD                ADDR OF FIRST SOURCE BUFFER
IBUF2    DS    A                         -''  SECOND    -''-
SOURCEB  DS    A                         -''  CURRENT   -''-
RSRCB    DS    A                         -''  READ      -''-
OPBUF1   DS    A                       ADDR OF FIRST OPTAB BUFFER
OPBUF2   DS    A                         -''-  SECOND    -''-
OPBUFB   DS    A                         -''-  CURRENT   -''-
ROPTB    DS    A                         -''-  READ      -''-
AOPTABE  DS    A                       ADDR OF CURRENT OPTAB ENTRY
LATAB    DS    A                       ADDR OF LABEL ADDR TABLE
APBTAB4  EQU   LATAB                   ADDR OF PBTAB4
SUTABCA  DS    A                       ADDR OF LAST USED SUTAB ENTRY
STRETURN DS    F                       RETURN ADDR
FREEMADR DS    A                       ADDR FOR FREEMAIN IN 50000
FREEMSIZ DS    F                       SIZE          -''-
*
PBTAB3   DS    1024C                   PROGRAM BLOCK TABLE, 3RD VERS
*
IOTAB    DC    18X'00'                 LIST OF DATASETS
CII      DC    H'0'                    REGISTER CONTROL
CIR      DC    H'0'                         -''-
RII      DC    H'0'                         -''-
RIR      DC    H'0'                         -''-
OPDPBN   DC    H'0'                    PROGRAM BLOCK NR (BYTE 2 OF OPD
OPDADR   DC    H'0'                    BYTES 3 AND 4 OF OPERAND
OPDLN    DC    H'0'                    LABEL NUMBER TIMES FOUR
ZEROHW   DC    H'0'                    ZEROES
CFSN     DC    X'00'                   CURRENT FS NUMBER
MAXFSN   DC    X'FF'                   MAX FS NUMBER
CLEARDIS DC    X'F000'                 FOR CLEARING OF DISPLACEMT PART
ONEENTRY DC    H'4'                    SHORT, FOR INCR OF OT STACK PTR
         ORG   ONEENTRY
         DC    H'8'                    LONG            -''-
PRECMASK DC    X'10'                   SHORT, TO MODIFY INSTRUCTIONS
         ORG   PRECMASK
         DC    X'00'                   LONG            -''-
NUMBBL   DC    X'00'                   RECORD COUNTER
         DS    H
SPBNST   DC    H'0'                    CURRENT PBN
         DS    H                                   AND DISPLACEMENT
GPBN     DC    H'255'                  GLOBAL DSA CONTROL
MAXOVERF DC    H'4092'                 SHORT, TO CHECK OT STACK OVERFL
         ORG   MAXOVERF
         DC    H'4088'                 LONG            -''-
HALFW    DS    H                       WORKPLACE
USPEI2   DS    H                       FOR ARRAY DECLA-
USPEI4   DS    H                                       RATION HANDLING
WPLACE   DS    H                       FOR INSTRUCTION GENERATION
XPLACE   DS    H
YPLACE   DS    H
UPLACE   DS    H
VPLACE   DS    C                                   -''-
STRDNAME DS    5C                      TO STORE OPERAND
CBVTAB   DS    48C                     CALLED-BY-VALUE TABLE
SUTABC   DS    768C
         ORG   SUTABC
DSTAB    DS    608C                    DATASET TABLE
*
*        REGISTER EQUATES
*
         IEZREGS
*
*        CHARACTER EQUATES
*
         IEXCHAR
*
         END
./ ADD NAME=IEX51M   0201-12230-12230-1200-00239-00239-00000-LEVEL
X51M     TITLE 'IEX51M - ERROR MESSAGE TEXT POOL 3, ALGOL F'
*
*        FUNCTION/OPERATION -
*        THIS MODULE CONTAINS MESSAGE TEXTS FOR ALL ERRORS THAT
*        MAY BE DETECTED BY IEX00, IEX50, AND IEX51, AND THE
*        CORRESPONDING ADDRESS TABLE
*
*        ENTRY POINT - N/A
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXITS - NORMAL - N/A
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORKAREAS - N/A
*
*        ATTRIBUTES - N/A
*
*        NOTES -
*        AT SYSTEM GENERATION THIS MODULE WILL BE LINKED
*        TOGETHER WITH THE MODULE IEX51 TO FORM THE MODULE IEX51
*
IEX51M00 CSECT
*
         ENTRY IEX51M01
*
*        ERROR MESSAGE POOL 3
*
WEMPOOL3 EQU   *
*
W160     DC    X'280500081244001B00001B45001C000C1C'
         DC    CL24'SSEQUENCE   NOT ALLOWED.'
*
W161     DC    X'300500081244001B00081B450024000C24'
         DC    CL32'SSEQUENCE  OPERAND  NOT ALLOWED.'
*
W162     DC    X'2F0500171244002A00042A45002F00002F'
         DC    CL31'SOPERAND MISSING BETWEEN  AND .'
*
W163     DC    X'3B0300110C44001E001D1E'
         DC    CL49'SOPERAND FOLLOWING  MUST BE OF ARITHMETICAL TYPE.'
*
W164     DC    X'3205001A1244002D00042D450032000032'
         DC    CL34'SNO OPERAND ALLOWED BETWEEN  AND .'
*
W165     DC    X'3500'
         DC    CL52'SEXPRESSIONS BEFORE AND AFTER ''ELSE'''
         DC    C'NOT COMPATIBLE.'
*
W166     DC    X'2100'
         DC    CL32'SDECLARATOR IN ILLEGAL POSITION.'
*
W167     DC    X'3202440009002909'
         DC    CL43'S AND OPERAND PRECEDING DECLARATOR ILLEGAL.'
*
W168     DC    X'330300110C44001E00151E'
         DC    CL41'SOPERAND PRECEDING  CANNOT POSSESS VALUE.'
*
W169     DC    X'2403000F0C44001C00081C'
         DC    CL26'SLABEL FOLLOWING  ILLEGAL.'
*
W172     DC    X'2400'
         DC    CL35'SDIFFERENT TYPES IN LEFT PART LIST.'
*
W173     DC    X'3C00'
         DC    CL59'TCOMPILATION UNSUCCESSFUL DUE TO COMPILER OR MACHINX
               E ERROR.'
*
W174     DC    X'3C00'
         DC    CL59'SPARAMETERS NOT ALLOWED FOR TYPE PROCEDURE CALLED BX
               Y VALUE.'
*
W175     DC    X'360300120C44001E00181E'
         DC    CL44'SOPERAND FOLLOWING  MUST BE LABEL OR SWITCH.'
*
W176     DC    X'230300160C440023000023'
         DC    CL25'SOPERAND MISSING BEFORE .'
*
W177     DC    X'2703001A0C440027000027'
         DC    CL29'SOPERAND NOT ALLOWED BEFORE .'
*
W178     DC    X'3700'
         DC    CL54'SILLEGAL OPERAND IN EXPRESSION BEFORE OR AFTER ''ELX
               SE''.'
*
W179     DC    X'6100'
         DC    CL96'SNUMBER OF SUBSCRIPT EXPRESSIONS DIFFERS FROM DIMENX
               SION IN ARRAY       DECLARATION FOR VARIABLE.'
*
W180     DC    X'1C00'
         DC    CL27'SINVALID SWITCH DESIGNATOR.'
*
W181     DC    X'2800'
         DC    CL39'SSWITCH DESIGNATOR IN ILLEGAL POSITION.'
*
W182     DC    X'2E0300110C44001E00101E'
         DC    CL36'SOPERAND FOLLOWING  MUST BE BOOLEAN.'
*
W183     DC    X'3D0300110C44001E001F1E'
         DC    CL51'SOPERAND PRECEDING  MUST BE A PROCEDURE IDENTIFIER.X
               '
*
W184     DC    X'440300110C44001E00261E'
         DC    CL58'SOPERAND PRECEDING  MUST BE AN ARRAY OR SWITCH IDENX
               TIFIER.'
*
W185     DC    X'440300160C440023002123'
         DC    CL58'SREAL OPERAND PRECEDING  NOT ALLOWED FOR INTEGER DIX
               VISION.'
*
W186     DC    X'3B00'
         DC    CL58'TSYNTACTICAL STRUCTURE TOO COMPLICATED. INTERNAL OVX
               ERFLOW.'
*
W187     DC    X'2800'
         DC    CL39'SINCORRECT NUMBER OF ACTUAL PARAMETERS.'
*
W188     DC    X'3902003009800004'
         DC    CL50'SINVALID ACTUAL PARAMETER FOR STANDARD PROCEDURE. '
*
W189     DC    X'3D00'
         DC    CL60'SDATA SET NUMBER OR FUNCTION OF SYSACT OUT OF ALLOWX
               ED RANGE.'
*
W190     DC    X'1A00'
         DC    CL25'SASSIGNMENT NOT POSSIBLE.'
*
W191     DC    X'2E0300200C44002D00012D'
         DC    CL36'SNO OPERAND ALLOWED BETWEEN ) AND  .'
*
W192     DC    X'2D00'
         DC    CL44'SINVALID RIGHT PART IN ASSIGNMENT STATEMENT.'
*
W193     DC    X'2D00'
         DC    CL44'SINCOMPATIBLE TYPES IN ASSIGNMENT STATEMENT.'
*
W194     DC    X'1502440009000C09'
         DC    CL14'S NOT ALLOWED.'
*
W195     DC    X'290300100C44001D000C1D'
         DC    CL31'SSEQUENCE OPERAND  NOT ALLOWED.'
*
W196     DC    X'3303001A0C440027000C27'
         DC    CL41'SARRAY IDENTIFIER PRECEDING  NOT ALLOWED.'
*
*        DIRECTORY MESSAGES
*
W209     EQU   *
W197     DC    X'460400360FF00000840046000046'
         DC    CL57'TCOMPILATION UNSUCCESSFUL DUE TO PROGRAM INTERRUPT.X
                PSW .'
*
W210     EQU   *
W198     DC    X'300300270C840030000030'
         DC    CL38'TUNRECOVERABLE I/O ERROR ON DATA SET .'
*
W211     EQU   *
W199     DC    CL56'PROGRAM INTERRUPT IN ERROR MESSAGE EDITING ROUTINE.X
                PSW '
*
*        MESSAGES USED BY MORE THAN ONE PHASE
*
W212     EQU   *
W200     DC    X'1200'
         DC    CL17'TTOO MANY ERRORS.'
*
W213     EQU   *
W201     DC    X'2800'
         DC    CL39'TINTERNAL OVERFLOW OF IDENTIFIER TABLE.'
*
W214     EQU   *
W202     DC    X'3903002D0C84003A00003A'
         DC    CL48'SDATA STORAGE AREA EXCEEDED, PROGRAM BLOCK NO. .'
*
W215     EQU   *
W203     DC    X'1A00'
         DC    CL25'TSOURCE PROGRAM TOO LONG.'
*
W216     EQU   *
W204     DC    X'2600'
         DC    CL37'STOO MANY LABELS. LABEL NUMBER RESET.'
*
         DC    0F'0'
*
*        ADDRESS TABLE FOR WEMPOOL3
*
IEX51M01 EQU   *-640
         DC    A(W160)
         DC    A(W161)
         DC    A(W162)
         DC    A(W163)
         DC    A(W164)
         DC    A(W165)
         DC    A(W166)
         DC    A(W167)
         DC    A(W168)
         DC    A(W169)
         DC    A(0)
         DC    A(0)
         DC    A(W172)
         DC    A(W173)
         DC    A(W174)
         DC    A(W175)
         DC    A(W176)
         DC    A(W177)
         DC    A(W178)
         DC    A(W179)
         DC    A(W180)
         DC    A(W181)
         DC    A(W182)
         DC    A(W183)
         DC    A(W184)
         DC    A(W185)
         DC    A(W186)
         DC    A(W187)
         DC    A(W188)
         DC    A(W189)
         DC    A(W190)
         DC    A(W191)
         DC    A(W192)
         DC    A(W193)
         DC    A(W194)
         DC    A(W195)
         DC    A(W196)
         DC    A(W197)
         DC    A(W198)
         DC    A(W199)
         DC    A(W200)
         DC    A(W201)
         DC    A(W202)
         DC    A(W203)
         DC    A(W204)
*
         END
./ ADD NAME=IEX60000 0201-12230-12230-1200-00629-00629-00000-LEVEL
         TITLE 'IEX60000 - ERROR MESSAGE PROCESSING, ALGOL F'
*
*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER
*
IEX60000 CSECT
*
         USING IEX60000,R2
*
*        REGISTER DEFINITIONS
*
*        R1                            POINTS TO PARAMETER LIST
*        R1                            RETURNS ADDR OF PRINT BUFFER
*        R2                            BASE REGISTER FOR COTEMER
*        R4                            BASE REGISTER FOR MESSAGE POOL
*        R5                            POINTER TO ENTRY IN ERROR POOL
*        R6                            POINTER TO INSERTION CODE
*        R7                            POINTER TO ENTRY IN MSG POOL
*        R14                           PTR TO MESSAGE TEXT WORKAREA
*
*        INITIALIZATION
*
         USING WORKAREA,R13            BASEREG FOR WORKAREA DSECT
         MVC   AWEMPOOL(10),0(R1)      GET ADDRS AND MOD NUMBER
COT00    LA    R9,WDIRET1              STORE RETURN ADDR
         ST    R9,ERET                 IN WORKAREA
         STM   R14,R15,SVAR1           SAVE RETURN ADDR AND BASE
         TM    COMPFLGS+2,PRT+PRTNO    SYSPRINT DOWN/NOT OPENED ?
         BNZ   COT18                   YES, GIVE CONSOLE MESSAGE
         L     R5,ERRPOOL              ADDR ERROR POOL
         CL    R5,NEXTERR              ERROR POOL EMPTY ?
         BE    COT28                   YES
         CLC   PAGEHEAD+39(L'HEADD1),HEADD1  HEADINGS ALREADY SET ?
         BE    COT01                   YES, BYPASS HEADINGS
         MVI   LINCNT+1,255            FORCE HEADINGS TO BE PRINTED
         MVI   PAGEHD1C+1,C' '         BLANK FIRST HEADING LINE
         MVC   PAGEHD1C+2(109),PAGEHD1C+1
         MVC   PAGEHD2D(L'PAGEHD2D),PAGEHD1D  BLANK 2ND HEADING LINE
         MVC   PAGEHD3D(L'PAGEHD3D),PAGEHD1D  BLANK 3RD HEADING LINE
         MVC   PAGEHD1D+39(L'HEADD1),HEADD1   MOVE IN HEADD1
         MVC   PAGEHD2D(L'HEADD2),HEADD2      MOVE IN HEADD2
*
*        HANDLING OF THE ENTRIES IN ERROR POOL
*
COT01    L     R4,AWEMPOOL             ADDR ERROR MESSAGE POOL
         SR    R7,R7
         IC    R7,1(,R5)               GET ERROR MSG NUMBER
         LA    R10,200
         CR    R7,R10                  DIRECTORY MESSAGE ?
         BL    COT36                   NO
         LH    R10,MODNUMB             YES, MODIFY NUMBER
         SR    R7,R10
COT36    SLL   R7,2                    GET IT FOUR TIMES
         L     R9,AWADDTAB             ADDR ADDR TABLE
         AR    R7,R9                   GET CORRECT ENTRY
         L     R7,0(,R7)               LOAD ADDR TO ENTRY IN ERMSG POOL
*
*        GET LENGTH OF INSERT CODE PART
*
COT02    LA    R6,2(,R7)               POINT TO FIRST INSERTION CODE
         SR    R9,R9
         IC    R9,1(,R7)               GET NUMBER OF INSERTION CODES
         LR    R10,R9
         LR    R12,R9
         LA    R12,1(,R12)             SET INSERTION CODE COUNTER
         SLL   R9,1                    DOUBLE IT
         AR    R9,R10                  GET IT 3 TIMES
*
*        HANDLE SEVERITY CODE
*
COT03    LA    R10,2(R9,R7)            GET ADDR TO BYTE BEFORE TEXT
         MVC   WAREA+9(1),0(R10)       INSERT SEVERITY CODE
         CLI   0(R10),C'W'
         BNE   COT03A
         OI    COMPFLGS,WERR           SET WARNING MESSAGE
         B     COT04
*
COT03A   CLI   0(R10),C'S'
         BNE   COT03B
         OI    COMPFLGS,SERR           SET SEVERE ERROR
         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         B     COT04
*
COT03B   OI    COMPFLGS,TERR           SET BIT FOR TERMINATING ERROR
*
*        INSERTION OF MSG NUMBER AND SEMICOLON COUNTER
*
COT04    SR    R10,R10                 CLEAR REG
         IC    R10,1(R5)               GET ERROR MSG NUMBER
         CVD   R10,WDEC+8
         UNPK  WAREA+3(3),WDEC+8(8)    CONVERT TO PRINTABLE DECIMAL
         OI    WAREA+5,X'F0'           MAKE CHAR PRINTABLE
         TM    0(R5),X'80'             BLANKS FOR SC ?
         BZ    COT26                   NO
         MVC   WAREA+12(5),BLANKS      YES, MOVE BLANKS
         NI    0(R5),X'7F'             REMOVE TAG
         B     COT31
*
COT26    LH    R10,2(,R5)              GET SEMICOLON COUNTER
         CVD   R10,WDEC+8
         UNPK  WAREA+12(5),WDEC+8(8)   CONVERT TO READABLE DECIMAL
         OI    WAREA+16,X'F0'          MAKE CHAR PRINTABLE
*
*        INSERTION OF FIXED MESSAGE
*
COT31    LA    R14,WAREA+20            POINT TO FIRST TEXTBYTE IN WAREA
         CLI   1(R7),0                 ANY INSERTION CODE ?
         BNE   COT05                   YES
         LA    R10,3(,R7)              GET ADDR OF MSG TXT
         SR    R11,R11
         IC    R11,0(,R7)              GET L'ENTRY
         AR    R11,R7                  GET NEXT ENTRY
         SR    R11,R10                 GET L'MSG TXT
         EX    R11,WMOVE1              MOVE MSG TXT TO WORKAREA
         LA    R14,1(R11,R14)          UPDATE WAREA POINTER
COT05    BCT   R12,COT06               GOTO INS CODE TREATMENT IF ANY
         B     COT12                   ALL INS CODES TREATED
*
*        INSERTION CODE TREATMENT
*
*        TEST ACTION PART OF INSERT CODE
*
COT06    LA    R9,15                   LOAD REG TO ZERO HIGHORDER BITS
         SR    R10,R10
         SR    R11,R11
         TM    0(R6),X'F0'
         BO    COT37                   GOTO 'INSERT BLANKS'
         BZ    COT30                   GOTO 'INSERT MESSAGE TEXT'
         TM    0(R6),X'80'
         BO    COT07                   GOTO 'UNALTERED TEXT'
         TM    0(R6),X'40'
         BO    COT10                   GOTO 'ALGOL SYMBOL'
         TM    0(R6),X'20'
         BO    COT33                   GOTO 'INTERNAL CHARACTERS'
*
*        INSERTION OF BLANKS AT END OF PRTLIN
*
COT37    LA    R3,WAREA+90             CALC FREE SPACE ON 1ST PRT LINE
         SR    R3,R14
         BNP   COT09                   BYPASS BLANKING IF LINE FULL
COT38    MVI   0(R14),C' '             INSERT BLANK
         LA    R14,1(,R14)             STEP WAREA POINTER
         BCT   R3,COT38                BRANCH IF 1ST PRT LINE NOT FULL
         B     COT09                   GOTO NEXT INS CODE
*
*        INSERTION OF MESSAGE TEXT PART
*
COT30    IC    R10,2(,R6)
         LA    R10,0(R10,R7)           GET ADDR OF TEXT PART
         IC    R11,1(,R6)              GET L'TEXT PART
COT08    EX    R11,WMOVE1              MOVE TO WORKAREA
COT35    LA    R14,1(R11,R14)          UPDATE WORKAREA POINTER
COT09    LA    R6,3(,R6)               UPDATE INS CODE POINTER
         B     COT05                   GOTO NEXT INS CODE
*
*        UNALTERED TEXT
*
COT07    IC    R11,0(,R5)              GET LENGTH OF SOURCE TEXT
         LA    R10,5
         SR    R11,R10
         BM    COT09                   NO MOVE IF NO SOURCE TEXT
         LA    R10,4(,R5)              GET ADDR OF SOURCE TEXT
         B     COT08                   MOVE TEXT, GOTO NEXT INS CODE
*
*        ALGOL SYMBOL
*
COT10    TM    COMPFLGS+2,SET60        60 CHARACTER SET USED ?
         BO    COT32                   YES, BRANCH
         LA    R11,WORDSISO            USE ISO TABLE
         B     COT32A
*
COT32    LA    R11,WORDSEBC            USE EBCDIC TABLE
COT32A   LA    R3,WSYMBSTK             TABLE FOR STACK OPERATOR
         IC    R10,0(,R6)              GET ONE BYTE ALGOL SYMBOL
         NR    R10,R9
         IC    R10,0(R10,R5)
         STC   R10,WDEC
         TM    WDEC,X'80'              SOURCE OPERATOR ?
         BZ    COT32B                  NO
         LA    R3,WSYMBSRC             YES, CHANGE TABLE
         NI    WDEC,X'7F'              REMOVE TAG
         IC    R10,WDEC
COT32B   SLL   R10,1                   MULTIPLY BY 2
         LH    R10,0(R10,R3)           CONVERT TO EBCDIC OR DISPLACEMT
         LA    R9,256                  TEST KIND OF SYMBOL
         CLR   R10,R9
         BL    COT11                   ONE CHARACTER SYMBOL
         LA    R10,0(R10,R11)          ADDR WORDS ENTRY
         SR    R11,R11
         IC    R11,0(,R10)             GET LENGTH OF SYMBOL
         LA    R10,1(,R10)             GET ADDR OF SYMBOL
         B     COT08                   MOVE SYMB, GOTO NEXT INS CODE
*
COT11    SR    R11,R11                 GET LENGTH-1 OF ONE-CHAR SYMBOL
         STC   R10,0(,R14)             MOVE SYMBOL TO MSG AREA
         B     COT35                   GOTO NEXT INS CODE
*
*        INTERNAL CHARACTERS
*
COT33    LA    R9,5
         IC    R11,0(,R5)              GET NUMBER OF INT CHARACTERS-1
         SR    R11,R9
         STC   R11,COT34+1             STORE IT IN TRANSLATE INSTR
         LA    R10,4(,R5)              GET ADDR OF SOURCE TEXT
         EX    R11,WMOVE1
COT34    TR    0(0,R14),TRINTEXT       TRANSLATE
         B     COT35                   UPDATE PTR, GOTO NEXT INS CODE
*
*        TRANSLATION AND OUTPUT OF MESSAGE
*
COT12    TM    SWTO,X'80'              MESSAGE TO CONSOLE ?
         BO    COT25                   YES
*
*        MESSAGE TO SYSPRINT
*
COT16    LR    R11,R14
         LA    R9,WAREA+20             GET L'MESSAGE TEXT
         SR    R11,R9
         LA    R9,70                   GET L'TEXT ON FIRST LINE
         SR    R11,R9                  SUBTRACT IT
         LA    R9,89                   GET L'PRINTLINE
         LA    R10,WAREA               GET ADDR OF ERROR MESSAGE
         BAL   R15,COT27               OBTAIN OUTPUT BUFFER, BLANK IT
         LTR   R11,R11                 L'MSG TXT > 70 ?
         BNL   COT17                   YES
         ALR   R9,R11                  OBTAIN PRTLINE LENGTH IF < 90
COT17    EX    R9,WMOVE3               MOVE FIRST PART OF ERROR MSG
COT20    LA    R10,1(R9,R10)           INCREASE ADDR IN WORKAREA
         LTR   R11,R11                 MORE TEXT TO BE MOVED ?
         BNH   COT21                   NO
         LA    R9,70                   YES, GET L'NEXT PRTLINE
         SR    R11,R9                  SUBTRACT IT FROM REMAIN TXTLGT
         BAL   R15,COT27               OBTAIN OUTPUT BUFFER, BLANK IT
         LTR   R11,R11                 LENGTH > 70 ?
         BNL   COT19                   YES
         ALR   R9,R11                  OBTAIN LENGTH IF LESS THAN 70
COT19    LA    R15,1                   MODIFY LENGTH FOR MOVE INSTR
         SR    R9,R15
         EX    R9,WMOVE4               MOVE TEXT TO OUTPUT BUFFER
         B     COT20                   PUT OUT NEXT TEXTLINE IF ANY
*
*        MESSAGE TO WTP
*
COT25    LA    R11,40(,R11)            GET LENGTH FOR MOVE INSTRUCTION
         EX    R11,EXMVC
*
COT24    WTO   '                                                       X
                      ',ROUTCDE=11,DESC=7   ISSUE WTP
*
EXMVC    MVC   COT24+8(0),WAREA        MOVE MESSAGE
*
         B     WDIRET2                 TERMINATE
*
*        OBTAIN OUTPUT BUFFER
*
COT27    STM   R14,R15,SVAR2           SAVE REGS FOR CALL OF PRINT RTN
         L     R15,PRTRTADD            LOAD ADDR OF PRINT ROUTINE
         BALR  R14,R15                 CALL PRINT ROUTINE
         LM    R14,R15,SVAR2           RESTORE REGS
         BR    R15
*
*        GOTO NEXT MESSAGE OR TERMINATE
*
COT21    SR    R9,R9
         IC    R9,0(,R5)               GET L'TREATED ENTRY
         AR    R5,R9                   POINT TO NEXT ENTRY
         L     R9,NEXTERR              GET ADDR OF FIRST FREE ENTRY
         CR    R5,R9                   NEXT ENTRY = FIRST FREE ?
         BL    COT01                   NO, HANDLE NEXT ENTRY
         LA    R10,WDIRET2             LOAD NEW RETURN ADDR
         ST    R10,ERET
         L     R10,ERRPOOL             YES, POOL EXHAUSTED, ZERO PTR
         ST    R10,NEXTERR
         TM    COMPFLGS,TERR           TERMINATING ERROR ?
COT28    LM    R14,R15,SVAR1           LOAD RETURN ADDR AND BASE
         BO    COT29                   YES
         BR    R14                     RETURN
*
COT29    XCTL  EP=IEX51002             BRANCH TO TERMINATION
*
*        ACTION TO BE PERFORMED AFTER I/O ERROR OR PROGRAM
*        INTERRUPTION
*
WDIRET1  TM    COMPFLGS+2,PRT          SYSPRINT ERROR ?
         BZ    COT18A                  NO
COT18    OI    SWTO,X'80'              YES, SET SWITCH ON
         B     LAST
*
COT18A   TM    COMPFLGS+1,ERR          PROGRAM INTERRUPT ?
         BZ    LAST                    NO
         LA    R7,211                  YES, GET MESSAGE NUMBER
         LH    R10,MODNUMB             MODIFY IT
         SR    R7,R10
         SLL   R7,2                    GET ENTRY IN ADDR TABLE
         L     R9,AWADDTAB
         AR    R7,R9                   GET ADDR OF MESSAGE
         L     R7,0(,R7)
         BAL   R15,COT27               GET PRINT BUFFER
         MVC   0(20,R1),CPI            MOVE MSG CODE ETC
         MVC   20(51,R1),0(R7)         MOVE MSG TEXT
         BAL   R15,COT27               GET PRINT BUFFER
         L     R9,NEXTERR              GET ADDR OF PSW
         LA    R10,16
         SR    R9,R10
         MVC   20(16,R1),0(R9)         MOVE PSW
         MVI   37(R1),C'.'             INSERT PERIOD
*
WDIRET2  OI    COMPFLGS+1,NSRCE        SET BIT FOR TERMINATING ERROR
         B     COT29                   BRANCH TO TERMINATION
*
*        HANDLE LAST ERROR PATTERN
*
LAST     L     R5,NEXTERR              GET ADDR OF FIRST FREE ENTRY
         LA    R10,12                  GET ADDR OF LAST PATTERN
         SR    R5,R10
         B     COT01                   GOTO NORMAL TREATMENT
*
*        WORKAREAS AND MOVE INSTRUCTIONS
*
         CNOP  0,4
WMOVE1   MVC   0(0,R14),0(R10)
WMOVE3   MVC   0(0,R1),0(R10)
WMOVE4   MVC   20(0,R1),0(R10)
*
WDEC     DC    2D'0'
WAREA    DC    C'IEX000I  0  00000   '
         DC    250C' '
*
*        HEADINGS AND MESSAGE 211 (PART OF)
*
HEADD1   DC    C'DIAGNOSTICS'
HEADD2   DC    C'CODE    SEV  SC     MESSAGE'
*
CPI      DC    C'IEX211I  T          ' FIRST PART OF MESSAGE 211
*
*        ADDRESSES AND CONSTANT
*
AWEMPOOL DC    F'0'                    ADDR OF MESSAGE TEXTS
AWADDTAB DC    F'0'                    ADDR OF ADDR TABLE
MODNUMB  DC    H'0'                    MODIFICATION NUMBER
*
*        VARIOUS
*
SWTO     DC    X'00'                   SWITCH FOR OUTPUT ON CONSOLE
SVAR2    DC    2F'0'                   TO SAVE LINKREGS FOR PRINT RTN
SVAR1    DC    2F'0'                   TO SAVE RETURN ADDR AND BASE
BLANKS   DC    CL5' '
*
*        TABLES FOR CONVERSION AND TRANSLATION
*
*        TRANSLATE INTERNAL CHARS TO EBCDIC
*
TRINTEXT DC    C'+-*/##(:'             00 -> 07
         DC    C'Ý##;####'             08 -> 0F
         DC    C'=<>#####'             10 -> 17
         DC    C'########'             18 -> 1F
         DC    C'¬#|&&#,):'            20 -> 27
         DC    C'¨## #.''#'            28 -> 2F
         DC    C'01234567'             30 -> 37
         DC    C'89####.'''            38 -> 3F
         DC    C'ABCDEFGH'             40 -> 47
         DC    C'IJKLMNOP'             48 -> 4F
         DC    C'QRSTUVWX'             50 -> 57
         DC    C'YZ$_#@'               58 -> 5D
*
*
*        CONVERSION OF SOURCE OPERATORS
*
         DC    0F'0'
WSYMBSRC DC    X'00'                   00        PLUS
         DC    C'+'
         DC    X'00'                   01        MINUS
         DC    C'-'
         DC    X'00'                   02        MULTIPLY
         DC    C'*'
         DC    X'00'                   03        DIVIDE
         DC    C'/'
         DC    H'256'                  04        INTEGER DIVIDE
         DC    H'260'                  05        'POWER'
         DC    X'00'                   06        LEFT PARENTHESIS
         DC    C'('
         DC    H'268'                  07        COLON
         DC    H'271'                  08        LEFT BRACKET
         DC    H'274'                  09        'ARRAY'
         DC    H'282'                  0A        'SWITCH'
         DC    H'291'                  0B        SEMICOLON
         DC    H'294'                  0C        'BEGIN'
         DC    H'294'                  0D        'BEGIN'
         DC    H'469'                  0E        'PROCEDURE'
         DC    H'469'                  0F        'PROCEDURE'
         DC    H'302'                  10        'EQUAL'
         DC    H'310'                  11        'LESS'
         DC    H'317'                  12        'GREATER'
         DC    H'327'                  13        'NOTEQUAL'
         DC    H'338'                  14        'NOTGREATER
         DC    H'351'                  15        'NOTLESS'
         DC    H'361'                  16        COLON EQUAL
         DC    H'364'                  17        'GOTO'
         DC    H'371'                  18        'FOR'
         DC    H'377'                  19        'STEP'
         DC    H'384'                  1A        'UNTIL'
         DC    H'392'                  1B        'WHILE'
         DC    H'400'                  1C        'DO'
         DC    H'405'                  1D        'IF'
         DC    H'410'                  1E        'THEN'
         DC    H'417'                  1F        'ELSE'
         DC    H'424'                  20        'NOT'
         DC    H'430'                  21        'IMPL'
         DC    H'437'                  22        'OR'
         DC    H'442'                  23        'AND'
         DC    H'448'                  24        'EQUIV'
         DC    X'00'                   25        COMMA
         DC    C','
         DC    X'00'                   26        RIGHT PARENTHESIS
         DC    C')'
         DC    H'268'                  27        COLON
         DC    H'456'                  28        RIGHT SUBSCRIPT BRACK
         DC    H'291'                  29        DELTA
         DC    H'459'                  2A        'END'
         DC    H'291'                  2B        ETA
         DC    H'459'                  2C        'END'
         DC    X'00'                   2D        OMEGA
         DC    C' '
         DC    H'481'                  2E        'CODE'
*
*        CONVERSION OF STACK OPERATORS
*
WSYMBSTK DC    X'00'                   00        PLUS
         DC    C'+'
         DC    X'00'                   01        MINUS
         DC    C'-'
         DC    X'00'                   02        MULTIPLY
         DC    C'*'
         DC    X'00'                   03        DIVIDE
         DC    C'/'
         DC    H'256'                  04        INTEGER DIVIDE
         DC    H'260'                  05        'POWER'
         DC    X'00'                   06        LEFT PARENTHESIS
         DC    C'('
         DC    H'268'                  07        COLON
         DC    H'271'                  08        LEFT BRACKET
         DC    H'274'                  09        'ARRAY'
         DC    H'282'                  0A        'SWITCH'
         DC    H'291'                  0B        SEMICOLON
         DC    H'294'                  0C        'BEGIN'
         DC    H'294'                  0D        'BEGIN'
         DC    H'469'                  0E        'PROCEDURE'
         DC    H'469'                  0F        'PROCEDURE'
         DC    H'302'                  10        'EQUAL'
         DC    H'310'                  11        'LESS'
         DC    H'317'                  12        'GREATER'
         DC    H'327'                  13        'NOTEQUAL'
         DC    H'338'                  14        'NOTGREATER
         DC    H'351'                  15        'NOTLESS'
         DC    H'361'                  16        COLON EQUAL
         DC    H'364'                  17        'GOTO'
         DC    H'371'                  18        'FOR'
         DC    H'377'                  19        'STEP'
         DC    H'384'                  1A        'UNTIL'
         DC    H'392'                  1B        'WHILE'
         DC    H'400'                  1C        'DO'
         DC    H'405'                  1D        'IF'
         DC    H'410'                  1E        'THEN'
         DC    H'417'                  1F        'ELSE'
         DC    H'424'                  20        'NOT'
         DC    H'430'                  21        'IMPL'
         DC    H'437'                  22        'OR'
         DC    H'442'                  23        'AND'
         DC    H'448'                  24        'EQUIV'
         DC    X'00'                   25        ALPHA
         DC    C' '
         DC    H'405'                  26        IFS
         DC    H'410'                  27        THENS
         DC    H'417'                  28        ELSES
         DC    X'00'                   29        LEFT PARENTHESIS
         DC    C'('
         DC    X'00'                   2A        LEFT PARENTHESIS
         DC    C'('
         DC    X'00'                   2B        MONADIC MINUS
         DC    C'-'
         DC    H'271'                  2C        LEFT SUBSCRIPT BRACKET
         DC    H'361'                  2D        COLON EQUAL
         DC    H'361'                  2E        COLON EQUAL
*
*        COMPOUND ALGOL SYMBOLS, EBCDIC
*
         DC    0F'0'
WORDSEBC EQU   *-256
         DC    X'02'                   256       INTEGER DIVIDE
         DC    C'''/'''
         DC    X'01'                   260       POWER
         DC    C'**     '
         DC    X'00'                   268       COLON
         DC    C': '
         DC    X'01'                   271       LEFT BRACKET
         DC    C'(/'
         DC    X'06'                   274       'ARRAY'
         DC    C'''ARRAY'''
         DC    X'07'                   282       'SWITCH'
         DC    C'''SWITCH'''
         DC    X'00'                   291       SEMICOLON
         DC    C'; '
         DC    X'06'                   294       'BEGIN'
         DC    C'''BEGIN'''
         DC    X'00'                   302       EQUAL
         DC    C'=      '
         DC    X'00'                   310       LESSTHAN
         DC    C'<     '
         DC    X'00'                   317       GREATER THAN
         DC    C'>        '
         DC    X'01'                   327       NOT EQUAL
         DC    C'¬=        '
         DC    X'01'                   338       LESS THAN OR EQU
         DC    C'<=          '
         DC    X'01'                   351       GR THAN OR EQU
         DC    C'>=       '
         DC    X'01'                   361       COLON EQUAL
         DC    C':='
         DC    X'05'                   364       'GOTO'
         DC    C'''GOTO'''
         DC    X'04'                   371       'FOR'
         DC    C'''FOR'''
         DC    X'03'                   377       'STEP'
         DC    C'''STEP'''
         DC    X'06'                   384       'UNTIL'
         DC    C'''UNTIL'''
         DC    X'06'                   392       'WHILE'
         DC    C'''WHILE'''
         DC    X'03'                   400       'DO'
         DC    C'''DO'''
         DC    X'03'                   405       'IF'
         DC    C'''IF'''
         DC    X'05'                   410       'THEN'
         DC    C'''THEN'''
         DC    X'05'                   417       'ELSE'
         DC    C'''ELSE'''
         DC    X'00'                   424       NOT
         DC    C'¬    '
         DC    X'05'                   430       'IMPL'
         DC    C'''IMPL'''
         DC    X'00'                   437       OR
         DC    C'|   '
         DC    X'00'                   442       AND
         DC    C'&&    '
         DC    X'06'                   448       'EQUIV'
         DC    C'''EQUIV'''
         DC    X'01'                   456       RIGHT BRACKET
         DC    C'/)'
         DC    X'04'                   459       'END'
         DC    C'''END'''
         DC    X'02'                   465       LEFT STRINGQUOTE
         DC    C'''('''
         DC    X'0A'                   469       'PROCEDURE'
         DC    C'''PROCEDURE'''
         DC    X'05'                   481       'CODE'
         DC    C'''CODE'''
*
         DS    0F
WORDSISO EQU   *-256               LIST OF COMPOUND ALGOL SYMBOLS, ISO
         DC    X'02'                   256       INTEGER DIVIDE
         DC    C'''/'''
         DC    X'06'                   260       'POWER'
         DC    C'''POWER'''
         DC    X'01'                   268       COLON
         DC    C'..'
         DC    X'01'                   271       LEFT BRACKET
         DC    C'(/'
         DC    X'06'                   274       'ARRAY'
         DC    C'''ARRAY'''
         DC    X'07'                   282       'SWITCH'
         DC    C'''SWITCH'''
         DC    X'01'                   291       SEMICOLON
         DC    C'.,'
         DC    X'06'                   294       'BEGIN'
         DC    C'''BEGIN'''
         DC    X'06'                   302       'EQUAL'
         DC    C'''EQUAL'''
         DC    X'05'                   310       'LESS'
         DC    C'''LESS'''
         DC    X'08'                   317       'GREATER'
         DC    C'''GREATER'''
         DC    X'09'                   327       'NOTEQUAL'
         DC    C'''NOTEQUAL'''
         DC    X'0B'                   338       'NOTGREATER'
         DC    C'''NOTGREATER'''
         DC    X'08'                   351       'NOTLESS'
         DC    C'''NOTLESS'''
         DC    X'01'                   361       COLON EQUAL
         DC    C'.='
         DC    X'05'                   364       'GOTO'
         DC    C'''GOTO'''
         DC    X'04'                   371       'FOR'
         DC    C'''FOR'''
         DC    X'03'                   377       'STEP'
         DC    C'''STEP'''
         DC    X'06'                   384       'UNTIL'
         DC    C'''UNTIL'''
         DC    X'06'                   392       'WHILE'
         DC    C'''WHILE'''
         DC    X'03'                   400       'DO'
         DC    C'''DO'''
         DC    X'03'                   405       'IF'
         DC    C'''IF'''
         DC    X'05'                   410       'THEN'
         DC    C'''THEN'''
         DC    X'05'                   417       'ELSE'
         DC    C'''ELSE'''
         DC    X'04'                   424       'NOT'
         DC    C'''NOT'''
         DC    X'05'                   430       'IMPL'
         DC    C'''IMPL'''
         DC    X'03'                   437       'OR'
         DC    C'''OR'''
         DC    X'04'                   442       'AND'
         DC    C'''AND'''
         DC    X'06'                   448       'EQUIV'
         DC    C'''EQUIV'''
         DC    X'01'                   456       RIGHT BRACKET
         DC    C'/)'
         DC    X'04'                   459       'END'
         DC    C'''END'''
         DC    X'02'                   465       LEFT STRINGQUOTE
         DC    C'''('''
         DC    X'0A'                   469       'PROCEDURE'
         DC    C'''PROCEDURE'''
         DC    X'05'                   481       'CODE'
         DC    C'''CODE'''
*
*        END OF IEX60000
*
./ ADD NAME=OPTIONS  0201-12230-12230-1200-00059-00059-00000-LEVEL
X01      TITLE 'ALGOL F COMPILER OPTIONS GENERATION'
*
*        COMPILER OPTIONS FOR THE ALGOL F COMPILER ARE SPECIFIED
*        IN THE STAGE 1 SYSGEN MACRO ALGOL
*
*        THE OUTPUT FROM STAGE 1 SYSGEN IS AN ASSEMBLY STEP
*        INVOKING MACRO SGIEX001 WITH THE APPROPRIATE MACRO
*        PARAMETERS PASSED TO IT FROM THE GLOBAL VARIABLES SET BY
*        THE STAGE 1 ALGOL MACRO
*
*        REFER TO THE MVT 21.8 SYSTEM GENERATION MANUAL FOR ALGOL
*        MACRO SPECIFICATIONS
*
*        THE STAGE 2 PROCESS FOR ALGOL IS THE ASSEMBLY OF
*        SGIEX001 TO GENERATE CSECT IEX00001 WHICH IS LATER LINK
*        EDITED WITH IEX00000 TO PRODUCE THE LOAD MODULE ALGOL
*        WHICH IS THE POINT OF INVOCATION FOR THE COMPILER
*
*        TO AVOID THE COMPLEXITY OF RUNNING A STAGE 1 SYSGEN AND
*        EDITING OUT ONLY THE STAGE 2 STEPS TO GENERATE THE
*        ALGOL COMPILER OPTIONS, THE 2 MACROS HAVE BEEN COMBINED
*        INTO AN ASSEMBLY. A SEPARATE LINK EDIT JOB SUBSEQUENTLY
*        BUILDS ALL THE COMPILER LOAD MODULES.
*
**********************************************************************
*                                                                    *
*        SYSGEN GLOBAL FLAGS UTILIZED BY THE MACROS                  *
*                                                                    *
**********************************************************************
*
         GBLB &SGALGOB(5)
         GBLA &SGALGOA(1)
         GBLB &SGQUITB
*
**********************************************************************
*                                                                    *
*        ALGOL - REFER TO MVT RELEASE 21.8 SYSGEN MANUAL             *
*                                                                    *
*        GC28-6554-13 OS SYSTEM GENERATION RELEASE 21.8              *
*                                                                    *
**********************************************************************
*
         ALGOL SIZE=262144,                                            X
               PUNCH=NODECK,                                           X
               TYPERUN=LOAD,                                           X
               SORCODE=EBCDIC,                                         X
               SORLIST=SOURCE,                                         X
               PRECISN=SHORT

*
**********************************************************************
*                                                                    *
*        SGIEX001 - STAGE 2 MACRO TO ASSEMBLE OPTIONS CSECT IEX00001 *
*                                                                    *
**********************************************************************
*
         SGIEX001 &SGALGOB(5),&SGALGOB(4),&SGALGOB(2),&SGALGOB(1),     X
               &SGALGOB(3),&SGALGOA(1)
         END
