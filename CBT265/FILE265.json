{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011618000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 999362, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE265.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 999362, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 999362, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE265.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x11\\x03'", "DS1TRBAL": "b'\\xc6\\x06'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\xd6\\x00\\n\\x01\\xd7\\x00\\x0c\\x00\\x12'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x92\\x07o\\x00\\x92\\x07o\\x16C\\x00?\\x00?\\x00\\x01\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1992-03-16T00:00:00", "modifydate": "1992-03-16T16:43:00", "lines": 63, "newlines": 63, "modlines": 1, "user": "SALBERT"}, "text": "**  The logon prepromt exit system provides controls and             **\n**  documentation that the default version from IBM does not         **\n**  have. In general the enhancements fall into 4 groups:            **\n**                                                                   **\n**   1. Improved output information                                  **\n**   1.1  Address, room, programmer name in                          **\n**        // output card                                             **\n**   1.2  Ability to change information on menu                      **\n**                                                                   **\n**   2. Improved control of userid                                   **\n**   2.1  CPU time limit                                             **\n**   2.2  Terminal control/logging                                   **\n**                                                                   **\n**   3. Data tracking                                                **\n**   3.1  Last logon time/terminal                                   **\n**                                                                   **\n**   4. Special user controls                                        **\n**   4.1  Group and divisional quotas                                **\n**   4.2  \"Special\" user priviledges                                 **\n**   4.2.1   Any procedure name                                      **\n**   4.2.2   Arbitrary JCL                                           **\n**                                                                   **\n**                                                                   **\n**  I would like to thank Ben Moore of SCHERING-PLOUGH for LOGONXIT  **\n**  from which this started. Also the other programmers in           **\n**  BFGoodrich for helping with their suggestions.                   **\n**                                                                   **\n**  Guy Albertelli                                                   **\n**  BFGoodrich                  216-447-5543                         **\n**  SP&C                                                             **\n**  9911 Brecksville Rd.                                             **\n**  Brecksville, OH   44141                                          **\n**                                                                   **\n**                                                                   **\n**                                                                   **\n**                                                                   **\n**  The following is the new format of the Logon command.            **\n**  It may be entered either from TSO itself, or from VTAM.          **\n**                                                                   **\n**                                                                   **\n**       LOGON   'ID'                    |--                         **\n**               ACCT('ACCOUNT')         |                           **\n**               MAIL/NOMAIL             |  IBM DEFINED PARMS        **\n**               NOTICES/NONOTICES       |                           **\n**               PROC('PROCEDURE')       |                           **\n**               SIZE('REGION SIZE')     |--                         **\n**                                                                   **\n**                                                           ON SCR  **\n**               ADDRESS('ADDRESS')            |--               X   **\n**               COPIES('COPIES')              |                 X   **\n**               FORMS('FORM')                 |                 X   **\n**               JCL                           |                 X   **\n**               LINECT('LINECT')              |  BFG PARMS      X   **\n**               LISTINFO                      |                 X   **\n**               MSGCLASS('MSGCLASS')          |                 X   **\n**               MSGLEVEL('MSGLEVEL')          |                 X   **\n**               NAME('NAME')                  |                     **\n**               PHONE('PHONE NUMBER')         |                     **\n**               PROGNAME('PROGRAMMER NAME')   |                 X   **\n**               ROOM('ROOM')                  |                 X   **\n**               TIME('TIME')                  |--               X   **\n**         or                                                        **\n**       LOGON   'ID'  RECONNECT                                     **\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$FROM": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x07o\\x00\\x92\\x07o\\x164\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-03-16T00:00:00", "modifydate": "1992-03-16T16:34:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "SALBERT"}, "text": "This started life as LOGONXIT from BEN MORE of SCHERING-PLOUGH from\nabout May of 1979. We at BFGoodrich modified it and enhanced it all\nthe way through ESA 3.1.0. At that time CA-Top Secret said that they\nwould not support password prompting with exits installed at IKJEFLD,\nwhen that exit eliminated IBM's security checking code via flags.\n\nWith the installation of ESA 4.2, we decided that the time had come\nto let IBM and CA do the security checking without help from this exit.\nThis implied a major overhaul of the code. At the same time we were\nlooking to reduce the usage of the Authorization SVC in our shop.\nThus we decided to implement the functionality of the original\nLOGONXIT via the new exit points provided by TSO/E 2.3. It allowed\nus to use the normal IBM full screen logon panel, and most of the\nnormal IBM checking.\n\nAs we got into the coding, we realized that modifing the panel would\nbe a good idea and that IBM allowed for modified panels. In SAMPLIB\nare the distributed panels that you normally run with. The panel is\nable to be modified, but the restrictions and coding rules are very\ndifficult. This led to the implementation of the macros in MACLPENU.\nThis made panel writing much easier. With the start of testing, we\nrealized that IBM never fully tested the new exits in TSO/E 2.3.\nSee the comments in IKJEFLDN for the necessary PTFs that must be\napplied for V2.3 (V2.3.1 has different PTF numbers).\n\nThings undone:\n1. Documentation for macros in MACLPENU.\n2. Cleanup and final documentation for IKJEFLDN.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$INSTALL": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x07o\\x00\\x92\\x07o\\x16\"\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-03-16T00:00:00", "modifydate": "1992-03-16T16:22:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SALBERT"}, "text": "To install the logon exit, the following steps are necessary:\n\n1. Adjust the JCL in JCLEFLDN and submit it. The link library should\n   be one in the LPALSTxx or MLPA list.  Note if you MLPA, then all\n   four names should be MLPAed : IKJEFLD1, IKJEFLD3, IKJEFLN1,\n   IKJEFLN2.\n\n2. Adjust the JCL in IKJLPENU and submit it. The link library can be\n   any one. This module MUST be MLPAed with name IKJLPENU to override\n   the one supplied in IBM's LPALIB.\n\n3. Shutdown and reIPL with CLPA. After the IPL, your new exit and\n   panel are active. If they dont work, use your back up facility\n   to rename them or delete they. (You DO have a back up facility\n   don't you).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IKJEFLDN": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x00\\x00\\x91$/\\x00\\x92\\x04/\\x13T\\x18g\\x00%\\x16\\xf2\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "1991-08-30T00:00:00", "modifydate": "1992-02-11T13:54:00", "lines": 6247, "newlines": 37, "modlines": 5874, "user": "SALBERT"}, "text": "**  THE LOGON PREPROMT EXIT SYSTEM PROVIDES CONTROLS AND             **\n**  DOCUMENTATION THAT THE DEFAULT VERSION FROM IBM DOES NOT         **\n**  HAVE. IN GENERAL THE ENHANCEMENTS FALL INTO 4 GROUPS:            **\n**                                                                   **\n**   1. IMPROVED OUTPUT INFORMATION                                  **\n**   1.1  ADDRESS, ROOM, PROGRAMMER NAME IN                          **\n**        // OUTPUT CARD                                             **\n**   1.2  ABILITY TO CHANGE INFORMATION ON MENU                      **\n**                                                                   **\n**   2. IMPROVED CONTROL OF USERID                                   **\n**   2.1  CPU TIME LIMIT                                             **\n**   2.2  TERMINAL CONTROL/LOGGING                                   **\n**                                                                   **\n**   3. DATA TRACKING                                                **\n**   3.1  LAST LOGON TIME/TERMINAL                                   **\n**                                                                   **\n**   4. SPECIAL USER CONTROLS                                        **\n**   4.1  GROUP AND DIVISIONAL QUOTAS                                **\n**   4.2  \"SPECIAL\" USER PRIVILEDGES                                 **\n**   4.2.1   ANY PROCEDURE NAME                                      **\n**   4.2.2   ARBITRARY JCL                                           **\n**                                                                   **\n**                                                                   **\n**  REQUIREMENTS TO USE THIS SYSTEM ARE TO BE AT THE TSO/E V2.3      **\n**  LEVEL AND THE MVS LEVEL REQUIRED TO SUPPORT TSO/E V2.3           **\n**  THE FOLLOWING APARS/PTFS MUST ALSO BE INSTALLED:                 **\n**                                                                   **\n**   OY48170  -  DOC CHANGE - TO EXIT N1 WITHOUT CALLING N2, SET     **\n**                            THE \"NOPROMPT\" SWITCH AND RESET THE    **\n**                            \"INVOKE IKJEFLN2\" SWITCH. (0X250)      **\n**                                                                   **\n**   OY47673  -  UY72068  -  N1 & N2 PARM LIST TERMINATION BITS ON   **\n**                           TOO EARLY IN PARM LIST. (9X440) <---    **\n**                                                                   **\n**   OY49044  -  UY75066  -  SECOND PASS PROMPT IGNORES DATA IN      **\n**                           PARM LIST. (9X441)                      **\n**                                                                   **\n**   OY48881  -  UY75066  -  IKJEFLN2 NOT PASSED TGET BUFFER         **\n**                           AS DOCUMENTED. (0X042)                  **\n**                                                                   **\n**   OY48837  -  UY74066  -  IKJEFLD3 CANNOT PASS BACK NEW BUFFER    **\n**                           AREA FOR JCL AS DOCUMENTED. (0X043)     **\n**                                                                   **\n**   OY48687  -  UY74377  -  IF PROCNAME LOCKED BY IKJEFLN2,         **\n**                           PSCB UNIT AND REGION SIZE ARE SET TO    **\n**                           GARBAGE. (0X148)                        **\n**                                                                   **\n**   OY49074  -  UY75066  -  TGET BUFFER OVERLAID IF USER FIELDS     **\n**                           ARE USED ON PANEL. (7X280)              **\n**                                                                   **\n**   OY49409  -  UY75725  -  IKJEFLD1 SETS COMMAND BUFFER LENGTH     **\n**                           WITH NEW CONTENTS PER DOCUMENTATION,    **\n**                           LENGTH IGNORED. (7X279)                 **\n**                                                                   **\n**   OY51123  -  UY76492  -  0C7 AFTER UY74377 ATTEMPTING TO TAKE    **\n**                           NULL REGION VALUE TO INTEGER. (9X377)   **\n**                                                                   **\n**   OY51130  -  UY76492  -  TGET BUFFER LENGTH ALWAYS SET TO 4.     **\n**                           (9X379)                                 **\n**                                                                   **\n         EJECT\n**                                                                   **\n**  THE FOLLOWING IS THE NEW FORMAT OF THE LOGON COMMAND.            **\n**  IT MAY BE ENTERED EITHER FROM TSO ITSELF, OR FROM VTAM.          **\n**                                                                   **\n**                                                                   **\n**       LOGON   'ID'                    |--                         **\n**               ACCT('ACCOUNT')         |                           **\n**               MAIL/NOMAIL             |  IBM DEFINED PARMS        **\n**               NOTICES/NONOTICES       |                           **\n**               PROC('PROCEDURE')       |                           **\n**               SIZE('REGION SIZE')     |--                         **\n**                                                                   **\n**                                                           ON SCR  **\n**               ADDRESS('ADDRESS')            |--               X   **\n**               COPIES('COPIES')              |                 X   **\n**               FORMS('FORM')                 |                 X   **\n**               JCL                           |                 X   **\n**               LINECT('LINECT')              |  BFG PARMS      X   **\n**               LISTINFO                      |                 X   **\n**               MSGCLASS('MSGCLASS')          |                 X   **\n**               MSGLEVEL('MSGLEVEL')          |                 X   **\n**               NAME('NAME')                  |                     **\n**               PHONE('PHONE NUMBER')         |                     **\n**               PROGNAME('PROGRAMMER NAME')   |                 X   **\n**               ROOM('ROOM')                  |                 X   **\n**               TIME('TIME')                  |--               X   **\n**         OR                                                        **\n**       LOGON   'ID'  RECONNECT                                     **\n         EJECT\n**                                                                   **\n**       CURRENT USE OF THE SYS1.UADS DATASET (NOW DATABASE)         **\n**                                                                   **\n**   THIS EXIT IMPLEMENTS 3 OTHER TYPES OF MEMBERS IN THE UADS DATA- **\n**   SET.  NONE OF THE IBM RECORDS ARE MODIFIED TO PRESERVE SAFETY.  **\n**   THE NEW RECORDS ARE AS FOLLOWS:                                 **\n**                                                                   **\n**   ALL MEMBERS ENDING WITH '$':                                    **\n**         - MEMBER NAME IS USERID$                                  **\n**         - CONTAINS INFORMATION ON THE USER: USERID                **\n**                                             NAME                  **\n**                                             PHONE                 **\n**                                             ADDRESS               **\n**                                             D/T LASTON            **\n**                                             D/T PASSWORD CHANGED  **\n**                                             MAX CPU TIME ALLOWED  **\n**                                             DEFAULT CPU TIME      **\n**                                             PROGRAMMER NAME - JCL **\n**                                             FORMS - JCL           **\n**                                             ROOM - JCL            **\n**                                             LINECT - JCL          **\n**                                                                   **\n**                                                                   **\n**   ALL MEMBERS BEGINNING WITH '#':                                 **\n**         - MEMBER NAME '#@@@@@@@@' IS NAME OF GLOBAL DEFAULT       **\n**           RESTRICTION MEMBER. THIS MEMBER WILL BE USED IF         **\n**           NO OTHER MEMBER NAME IS FOUND                           **\n**         - MEMBER NAME #TERMID@@@ WHERE THE TERMINAL NAME IS       **\n**           TRUNCATED AND PADDED OUT WITH \"@\" IS RESTRICTION        **\n**           MEMBER FOR GROUPS OF TERMINALS.                         **\n**           EX.  #PCI00V     IF EXISTS WILL BE USED NEXT            **\n**                #PCI00@@    IF EXISTS WILL BE USED NEXT            **\n**                #PCI0@@@    IF EXISTS WILL BE USED NEXT            **\n**                #PCI@@@@         \"\"                                **\n**                #PC@@@@@         \"\"                                **\n**                #P@@@@@@         \"\"                                **\n**                #@@@@@@@         \"\"                                **\n**           THE FIRST ONE IN THE ABOVE LIST WILL BE USED            **\n**         - MEMBER NAME IS #TERMID                                  **\n**         - CONTAINS RESTRICTIONS ON USE OF THIS TERMINAL.          **\n**           CURRENT SYNTAX (KEYVAL):                                **\n**                                                                   **\n**              USER(ID,ID,...ID)   1 TO 9 VALID USER IDS            **\n**                                  CAN BE SPECIFIED AS SUBSTRING    **\n**                                  NOTATION AND MUST BE IN QUOTES   **\n**                                  IF SO.  EX:                      **\n**                                                                   **\n**                                      USER('S(1)',COOK,'T(3)')     **\n**                                                                   **\n**                                  ALLOWS ID COOK, ANY ID STARTING  **\n**                                  WITH 'S', OR ANY ID WITH 'T' AS  **\n**                                  THE THIRD CHARACTER.             **\n**                                                                   **\n**              TIME(HHMM,HHMM)     TIME TERMINAL USE IS ALLOWED     **\n**                                                                   **\n**              ASKBACK(LIMIT)      INVOKE ATARI ASKBACK PROCEDURE   **\n**                                  WITH TIME LIMIT OF 'LIMIT'       **\n**                                  SECONDS                          **\n**                                                                   **\n**              SMF | CONSOLE       LOCATION WHERE VIOLATIONS        **\n**                                  ARE TO BE REPORTED.              **\n**                                                                   **\n**              LOG                 IF SUCCESSFUL THEN LOG MESSAGE   **\n**                                  TO EITHER SMF OR CONSOLE IF      **\n**                                  SPECIFIED                        **\n**                                                                   **\n**              REJECT              FAIL ANY ATTEMPT TO LOGON        **\n**                                  WITH THIS TERMINAL               **\n**                                                                   **\n**                                                                   **\n**   ASKBACK MEMBER:                                                 **\n**         - MEMBER NAME IS 'ASKBACK'                                **\n**         - CONTAINS THE EXPECTED ANSWER CODE TO BE ENTERED FROM    **\n**           THE TERMINAL.  CURRENT SYNTAX (KEYVAL):                 **\n**                                                                   **\n**                       |-   -|                                     **\n**               X(VALUE |,PROC|)  WHERE 'X' IS THE FIRST CHARACTER  **\n**                       |-   -|   OF A USERID.                      **\n**                                 'VALUE' IS THE PASSWORD EXPECTED  **\n**                                 BACK.                             **\n**                                 'PROC' IS THE PROCEDURE NAME TO   **\n**                                 BE USED FOR THE JCL (OVERRIDES    **\n**                                 ANY SPECIFIED BY USER.            **\n**                                                                   **\n**                                                                   **\n         EJECT\n         MACRO\n&NAME    PARM  &ID\n&NAME    LA    R1,&ID\n         L     R15,=A(GPENTRY)     GET ENTRY ADDRESS\n         BALR  R14,R15             GO DO FUNCTION\n         MEND\n         MACRO\n&NAME    INFO  &ID\n&NAME    L     R1,=A(&ID)\n         L     R15,=A(FINDINFO)    GET ENTRY ADDRESS\n         BALR  R14,R15             GO DO FUNCTION\n         MEND\n         MACRO\n&NAME    SUBENTRY\n&NAME    SAVE  (14,12),,&NAME\n         LA    R15,72(,R13)        GET TO NEXT SAVE AREA\n         ST    R13,4(,R15)         CHAIN THEM\n         LR    R13,R15             SET NEW SAVE AREA\n         MEND\n         MACRO\n&NAME    SUBEXIT\n&NAME    L     R13,4(,R13)         POINT AT PREV SAVE AREA\n         L     R14,12(,R13)        GET RETURN ADDRESS\n         LM    R2,R12,28(R13)      GET REST OF REGS\n         BSM   0,R14               EXIT AND RESTORE MODE\n         MEND\n         TITLE 'IKJEFLD1 - LOGON PRE-PROMPT EXIT'\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*        IKJEFLD1                                                     *\n*                                                                     *\n* FUNCTION -                                                          *\n*        LOGON PREPROMPT EXIT                                         *\n*                                                                     *\n* OPERATION -                                                         *\n*        THE FOLLOWING FUNCTIONS ARE DONE:                            *\n*               1. DO HOUSEKEEPING                                    *\n*               2. PARSE LOGON COMMAND                                *\n*               3. SAVE ANY INFORMATION ON BFG OPERANDS FROM PARSE    *\n*               4. REBUILD COMMAND BUFFER W/O BFG OPERANDS            *\n*               5. CLEANUP AND RETURN                                 *\n*                                                                     *\n* ENTRY POINTS -                                                      *\n*        IKJEFLD1                                                     *\n*                                                                     *\n* EXTERNAL REFERENCES -                                               *\n*    NONE                                                             *\n*                                                                     *\n* INPUT -                                                             *\n*    NONE                                                             *\n*                                                                     *\n* OUTPUT -                                                            *\n*    NONE                                                             *\n*                                                                     *\n* REGISTER USAGE -                                                    *\n*        R9  = DSAD1 AREA                                             *\n*        R10 = ORIG PARM LIST PTR                                     *\n*        R11 = EXIT-TO-EXIT SAVE AREA                                 *\n*        R12 = BASE                                                   *\n*        R13 = SAVE AREA                                              *\n*                                                                     *\n* MESSAGES -                                                          *\n*    NONE                                                             *\n*                                                                     *\n* COMMENTS -                                                          *\n*    NONE                                                             *\n*                                                                     *\n***********************************************************************\n         EXTRN IKJEXIT\nIKJEFLD1 CSECT\nIKJEFLD1 AMODE 31\nIKJEFLD1 RMODE 24\n         SAVE  (14,12),,IKJEFLD1_&SYSDATE._&SYSTIME\n         LR    R12,R15             SET NEW BASE REGISTER\n         LR    R10,R1              SAVE PARM LIST\n         USING IKJEFLD1,R12        SETUP ADDRESSABILITY\n         EJECT\n***********************************************************************\n*                                                                     *\n*        GET THIS EXIT WORK AREA/SAVE AREA                            *\n*                                                                     *\n***********************************************************************\n         GETMAIN R,LV=DSAD1L,SP=10\n         ST    R13,4(,R1)          SAVE ADDRESS\n         LR    R13,R1              SET NEW SAVE AREA\n         LR    R9,R1               SET NEW SAVE AREA\n         USING DSAD1,R9\n         EJECT\n***********************************************************************\n*                                                                     *\n*        GET THE MAIN EXIT-TO-EXIT COMMUNICATIONS AREA                *\n*                                                                     *\n***********************************************************************\n         GETMAIN R,LV=EXTEXL,SP=21\n         LR    R11,R1\n         USING EXTEX,R11\n         MVC   ETID,=CL7'EXTOEX'   SET EYEBALL FLAG\n         PARM  D1EXTOEX           GET EXIT TO EXIT PARM ENTRY\n         MVC   ETHSKEY(12),0(R15)  SAVE ORIG KEY\n         ST    R11,8(,R15)         SAVE ADDRESS OF AREA\n         MVC   0(8,R15),=A(2,EXTEXL) SET KEY, LENGTH, AND SUBPOOL\n         MVC   ETMYKEY(12),0(R15)  SAVE MY NEW KEY\n         EJECT\n***********************************************************************\n*                                                                     *\n*        DETERMINE IF TEST MODE, SET INDICATORS                       *\n*                                                                     *\n***********************************************************************\nD1$RSTRT DS    0H                  RESTART FROM ATTENTION\n         XC    ETTEST,ETTEST\n         PARM  D1CMDBFR\n         CLI   6(R1),C'#'          IS THIS TEST ID\n         BE    D1$T1\n         CLI   6(R1),C'%'          IS THIS TEST ID\n         BE    D1$T2\n         B     D1$T10              IF NOT A TEST THE LEAVE AT ZERO\n*\n**  '#'  INVOKE TEST VERSION OF EXITS\n*\nD1$T1    MVI   ETTEST,255          FLAG AS TEST\n         MVI   6(R1),C' '          CLEAR INDICATOR\n         PARM  D1EXTOEX\n         MVC   0(12,R15),ETHSKEY   SET TO ORIGINAL\n         LR    R1,R10              GET PARM LIST\n         LINK  EP=ZZZEFLD1,ERRET=D1$T1A   CALL TEST VERSION\n         LR    R2,R15              SAVE RETURN CODE\n         PARM  D1EXTOEX\n         MVC   ETHSKEY(12),0(R15)  SAVE THE TEST PGMS STUFF\n         MVC   0(12,R15),ETMYKEY   MOVE MY STUFF BACK IN\n         B     D1$BYE              RETURN WITH TEST EXIT CODE\nD1$T1A   DS    0H                  TEST MODULE NOT PRESENT\n         MVI   ETTEST,0            RESET TEST FLAG\n         WTO   MF=(E,NOTEST)       TELL CONSOLE\n         LH    R0,NOTEST           GET LENGTH\n         SH    R0,=H'4'            GET TRUE MESSAGE LENGTH\n         LA    R1,NOTEST+4         GET MESSAGE ADDRESS\n         TPUT  (1),(0),R           TELL USER\n         PARM  D1EXTOEX\n         MVC   0(12,R15),ETMYKEY   MOVE MY STUFF BACK IN\n         B     D1$T10              CONTINUE NORMALLY\n*\n**  '%'  INVOKE THIS VERSION WITH FULL REPORTING (IKJEXIT)\n*\nD1$T2    MVI   ETTEST,128          FLAG AS TEST\nD1$T9    MVI   6(R1),C' '          CLEAR INDICATOR\nD1$T10   DS    0H\n         EJECT\n***********************************************************************\n*                                                                     *\n*        MAINLINE                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n*               1. DO HOUSEKEEPING\n         BAS   R14,D1$HSKP\n         LTR   R15,R15\n         BNZ   D1$DENY\n*               2. PARSE LOGON COMMAND                                *\n         BAS   R14,SCAN\n         LTR   R15,R15\n         BNZ   D1$DENY\n         BAS   R14,PARSE\n         LTR   R15,R15\n         BNZ   D1$DENY\n*               3. SAVE ANY INFORMATION ON BFG OPERANDS FROM PARSE    *\n         BAS   R14,D1$SVINF\n         LTR   R15,R15\n         BNZ   D1$DENY\n*               4. REBUILD COMMAND BUFFER W/O BFG OPERANDS            *\n         BAS   R14,D1$MKCMD\n         LTR   R15,R15\n         BNZ   D1$DENY\n         EJECT\n***********************************************************************\n*                                                                     *\n*        FREE THIS EXIT WORK AREA AND EXIT ROUTINE                    *\n*                                                                     *\n***********************************************************************\nD1$EXIT  DS    0H\n         SR    R2,R2               CLEAR RETURN CODE\nD1$BYE   DS    0H\n*               5. CLEANUP AND RETURN                                 *\n         BAS   R14,D1$CLEAN\n*\n         LR    R1,R13\n         L     R13,4(,R13)\n         FREEMAIN R,LV=DSAD1L,A=(1),SP=10\n         LR    R15,R2              SET RETURN CODE\n         L     R14,12(,R13)        RESTORE REGISTERS\n         LM    R0,R12,20(R13)      RESTORE REGISTERS\n         BSM   0,R14               RETURN\nD1$DENY  LA    R2,16               DENY LOGON\n         B     D1$BYE\n         EJECT\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*    D1$HSKP                                                          *\n*                                                                     *\n* FUNCTION -                                                          *\n*    PERFORMS HOUSEKEEPING FUNCTIONS FOR LOGONXIT.                    *\n*                                                                     *\n* OPERATION -                                                         *\n*    1) ISSUES ESTAE.  IF ESTAE IS UNSUCCESSFUL, TELLS TSO USER AND   *\n*       DENIES LOGON.                                                 *\n*    2) MOVES STIMER EXIT TO DYNAMIC AREA AND ISSUES STIMER.\n*    3) ISSUES STAX.  IF STAX IS UNSUCCESSFUL, TELLS TSO USER AND\n*       DENIES LOGON.\n*    4) CHECKS TO SEE IF THIS IS 'USERID ENQ FAIL'.  IF SO, TELLS TSO *\n*       USER AND DENIES LOGON.                                        *\n*    5) CHECKS TO SEE IF THIS IS 'RESOURCE FAILURE'.  IF SO, TELLS TSO*\n*       USER AND DENIES LOGON.                                        *\n*    6) CHECKS TO SEE IF THIS IS 'ABEND'.  IF SO, TELLS TSO USER AND  *\n*       DENIES LOGON.                                                 *\n*    7) ATTEMPTS TO OPEN SYS1.UADS.  IF OPEN IS UNSUCCESSFUL, TELLS   *\n*       TSO USER AND DENIES LOGON.                                    *\n*    8) GETS STORAGE FOR UADS DATA BLOCKS.                            *\n*    9) BUILDS CBUF AND CPPL.                                         *\n*   10) GET APF AUTHORIZED AND GET TERMINAL ID FROM TSB.\n*   11) CLEAR TERMINAL BUFFERS.\n*   12) IF DISPLAY TERMINAL, CLEAR THE SCREEN.\n*   13) DETERMINE IF RACF, OR EQUIVALENT, IS ACTIVE\n*   14) RETURNS TO THE MAINLINE.\n*                                                                     *\n* ENTRY POINTS -                                                      *\n*    D1$HSKP                                                          *\n*                                                                     *\n* EXTERNAL REFERENCES -                                               *\n*    GETAUTH                                                          *\n*                                                                     *\n* INPUT -                                                             *\n*    NONE                                                             *\n*                                                                     *\n* OUTPUT -                                                            *\n*    NONE                                                             *\n*                                                                     *\n* MESSAGES -                                                          *\n*    'ESTAE UNSUCCESSFUL - RC=NNNN'                                   *\n*    'STAX UNSUCCESSFUL - RC=NNNN'\n*    'USERID CURRENTLY LOGGED ON'                                     *\n*    'RESOURCE FAILURE. CONTACT MEMPHIS DATA CENTER'                  *\n*    'LOGON ABEND. CONTACT MEMPHIS TECHNICAL SUPPORT'                 *\n*    'OPEN OF SYS1.UADS UNSUCCESSFUL'                                 *\n*                                                                     *\n***********************************************************************\n         EJECT\nD1$HSKP DS     0H\n         SUBENTRY ,\n         EJECT\n********************************************************************\n*\n*       GET TIME AND DATE OF ENTRY\n*\n********************************************************************\n         TIME  DEC                 GET TIME AND DATE\n         STM   R0,R1,ETLTIME       SAVE TIME AND DATE\n         EJECT\n***********************************************************************\n*                                                                     *\n*       CALL MOTHER TASK TO SETUP STIMER.                             *\n*                                                                     *\n***********************************************************************\n*        XC    STREQECB,STREQECB   CLEAR RESPONSE ECB\n*        L     R0,LOGTIME          GET OVERALL LOGON TIME\n*        POST  MTREQECB,(0)        WAKE UP MOTHER TO SET\n*        WAIT  ECB=STREQECB        WAIT FOR COMPLETION\n         EJECT\n***********************************************************************\n*                                                                     *\n*       ISSUES ESTAE.  IF ESTAE IS UNSUCCESSFUL, TELLS TSO USER AND   *\n*       DENIES LOGON.                                                 *\n*                                                                     *\n***********************************************************************\n         MVC   D1@ESTAE(LGESTAE),LESTAE COPY ESTAE PARM LIST\n         L     R3,=A(GP$ESTAE)     GET ADDRESS OF ESTAE EXIT\n         LA    R4,ETESTPM          GET ADDRESS OF ESTAE PARMS\n         LA    R1,D1$RETRY         POINT TO RETRY ROUTINE\n         ST    R1,0(,R4)           SAVE ADDRESS OF RETRY ROUTINE\n         ST    R9,4(,R4)           SAVE PHASE DSA ADDRESS\n         ST    R11,8(,R4)          SAVE EXTOEX ADDRESSS\n         ST    R10,12(,R4)         SAVE INPUT ADDRESSS\n         ESTAE (3),PARAM=(4),MF=(E,D1@ESTAE) ESTABLISH ESTAE\n         LTR   R15,R15             WAS ESTAE SUCCESSFUL\n         BNZ   D1$HNSTA            NO - GO GIVE MESSAGE\n         EJECT\n*********************************************************************\n*\n*       ISSUES STAX.  IF STAX IS UNSUCCESSFUL, TELLS TSO USER AND\n*       DENIES LOGON.\n*\n*********************************************************************\n         XC    D1@STAX1(LSTAX),D1@STAX1 CLEAR DUMMY STAX PARM LIST\n         STAX  D1$DSTAX,                                               X\n               USADDR=ETESTPM,REPLACE=NO,MF=(E,D1@STAX1)\n         LTR   R15,R15             WAS STAX SUCCESSFUL\n         BNZ   D1$HNSTX            NO - GO GIVE MESSAGE\n         XC    D1@STAX2(LSTAX),D1@STAX2 YES - CLEAR STAX PARM LIST\n         PARM  D1CMDBFR            GET ADDRESS OF INPUT BUFFER DESC\n         LR    R2,R1               SAVE ADDRESS\n         LA    R3,252              GET MAX LENGTH\n*                                    (D1$RSTAX WILL SET REAL LENGTH)\n         STAX  D1$RSTAX,OBUF=(STAXOBUF,L'STAXOBUF),                    X\n               IBUF=((R2),(R3)),                                       X\n               USADDR=ETESTPM,REPLACE=NO,MF=(E,D1@STAX2)\n         LTR   R15,R15             WAS STAX SUCCESSFUL\n         BNZ   D1$HNSTX            NO - GO GIVE MESSAGE\n         EJECT\n***********************************************************************\n*                                                                     *\n*       CHECKS TO SEE IF THIS IS 'USERID ENQ FAIL'.  IF SO, TELLS TSO *\n*       USER AND DENIES LOGON.                                        *\n*                                                                     *\n***********************************************************************\n         PARM  D1SWITCH            GET CALLER'S R1\n         TM    0(R1),KBIT0         WAS THIS 'USERID ENQ FAIL'\n         BO    D1$HDUPU            YES - GO GIVE MESSAGE\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*       CHECKS TO SEE IF THIS IS 'RESOURCE FAILURE'.  IF SO, TELLS TSO*\n*       USER AND DENIES LOGON.                                        *\n*                                                                     *\n***********************************************************************\n         TM    0(R1),KBIT2         WAS THIS 'RESOURCE FAILURE'\n         BO    D1$HRESC            YES - GO GIVE MESSAGE\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*       CHECKS TO SEE IF THIS IS 'ABEND'.  IF SO, TELLS TSO USER AND  *\n*       DENIES LOGON.                                                 *\n*                                                                     *\n***********************************************************************\n         TM    1(R1),KBIT6         WAS THIS 'ABEND'\n         BO    D1$HABND            YES - GO GIVE MESSAGE\n         EJECT\n***********************************************************************\n*                                                                     *\n*       BUILDS CBUF AND CPPL.                                         *\n*                                                                     *\n***********************************************************************\n         PARM  D1CMDBFR            GET ADDRESS OF COMMAND BUFFER\n         L     R14,4(,R15)         GET LENGTH OF INPUT BUFFER\n         LA    R14,4(,R14)         ADD IN LL00 LENGTH\n         STH   R14,D1@CBUF+CBUFLEN-CBUF PUT IN CBUF\n         XC    D1@CBUF+CBUFOFFS-CBUF(2),D1@CBUF+CBUFOFFS-CBUF 0 OFFSET\n         MVC   D1@CBUF+CBUFTEXT-CBUF(252),0(R1) COPY TO CMD BUFFER\n         LA    R1,D1@CBUF          POINT AT BUFFER\n         ST    R1,D1@CPPL+CPPLCBUF-CPPL PUT IN CPPL\n         PARM  D1UPT               GET ADDRESS OF UPT\n         ST    R1,D1@CPPL+CPPLUPT-CPPL PUT IN CPPL\n         PARM  D1PSCB              GET ADDRESS OF MY PSCB\n         ST    R1,D1@CPPL+CPPLPSCB-CPPL PUT IN CPPL\n         PARM  D1ECT               GET ADDRESS OF ECT\n         ST    R1,D1@CPPL+CPPLECT-CPPL PUT IN CPPL\n         EJECT\n*********************************************************************\n*\n*       GET APF AUTHORIZED AND GET TERMINAL ID FROM TSB.\n*\n*********************************************************************\n         MVC   ETTERMID(2),=H'8'\n         MVC   ETTERMID+2(8),=CL8'UNKNOWN' ASSUME 'UNKNOWN'\n         TESTAUTH FCTN=1,STATE=YES,RBLEVEL=1 AUTHORIZED??\n         LTR   R15,R15             CHECK RETURN CODE\n         BNZ   D1$HGTRM            NO - LEAVE UNKNOWN\n         L     R15,PSAAOLD-PSA     YES - GET ADDRESS OF MY ASCB\n         L     R3,ASCBTSB-ASCB(,R15) GET ADDRESS OF MY TSB\n         MODESET MF=(E,KEYZERO)    GET KEY 0 FOR MOVE FROM TSB\n         MVC   ETTERMID+2(8),TSBTRMID-TSB(R3) COPY TERMINAL TO DYN.\n         MODESET MF=(E,NONZERO)    RETURN TO USER KEY\nD1$HGTRM DS    0H\n         LH    R1,ETTERMID         GET LENGTH\n         LA    R2,ETTERMID+2+7     POINT AT LAST CHAR\nD1$HGTB1 CLI   0(R2),C' '          IS THIS A BLANK\n         BNE   D1$HGTB2            NO, SO HAVE LENGTH\n         BCTR  R2,0                BACK UP POINTER\n         BCT   R1,D1$HGTB1         DECR LENGTH AND CONTINUE\nD1$HGTB2 STH   R1,ETTERMID         SAVE CORRECT LENGTH\n         EJECT\n*********************************************************************\n*\n*       GET ASID FOR LATER.\n*\n*********************************************************************\n         L     R15,PSAAOLD-PSA     GET ADDRESS OF MY ASCB\n         UNPK  D1@WORK1(5),ASCBASID-ASCB(3,R15) UNPACK\n         L     R1,=A(TRTABLE-240)\n         TR    D1@WORK1(4),0(R1)   CONVERT TO EBCDIC\n         MVC   ETASIDE,D1@WORK1    COPY TO DYNAMIC AREA\n         EJECT\n*********************************************************************\n*\n*       CLEAR TERMINAL BUFFERS.\n*\n*********************************************************************\n         TCLEARQ INPUT             CLEAR TERMINAL BUFFERS\n         EJECT\n*********************************************************************\n*\n*       IF DISPLAY TERMINAL, CLEAR THE SCREEN.\n*\n*********************************************************************\n         GTSIZE ,                  DETERMINE TERMINAL TYPE\n         LTR   R0,R0               WAS THIS A DISPLAY\n         BZ    D1$HCLR             NO - CONTINUE\n         LA    R0,L'CLRSCRN        YES - GET LENGTH OF MESSAGE\n         LA    R1,CLRSCRN          GET ADDRESS OF MESSAGE\n         ICM   R1,B'1000',=X'03'   INDICATE FULLSCR TPUT\n         TPUT  (1),(0),R           ISSUE TPUT TO CLEAR SCREEN\n         OI    ETBITS2,ET2DSPLY    INDICATE DISPLAY TERMINAL\nD1$HCLR  DS    0H\n         SR    R15,R15             SET GOOD RETURN CODE\n         EJECT\n***********************************************************************\n*                                                                     *\n*       RETURNS TO THE MAINLINE.                                      *\n*                                                                     *\n***********************************************************************\nD1$HEXIT DS    0H\n         SUBEXIT ,\n         EJECT\n***********************************************************************\n*                                                                     *\n*       INFORM USER THAT ESTAE RETURN CODE WAS NOT ZERO AND DENY      *\n*       LOGON.                                                        *\n*                                                                     *\n***********************************************************************\nD1$HNSTA DS    0H                  NON-ZERO RETURN CODE FROM ESTAE\n         LR    R2,R15              PROTECT RETURN CODE\n         MVC   D1@MSGAR(L'ESTAEMSG),ESTAEMSG COPY MESSAGE\n         CVD   R15,D1@WORK1        CONVERT TO DECIMAL\n         OI    D1@WORK1+7,X'0F'    FIX SIGN\n         UNPK  D1@WORK1(5),D1@WORK1+5(3) UNPACK\n         MVC   D1@MSGAR+24(4),D1@WORK1+1 MOVE INTO MESSAGE\n         LA    R0,L'ESTAEMSG       GET LENGTH OF MESSAGE\n         LA    R1,D1@MSGAR         POINT TO MESSAGE\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         LR    R15,R2              RESTORE RETURN CODE\n         OI    ETBITS1,ET1DENY     DENY LOGON\n         B     D1$HEXIT            EXIT\n         EJECT\n*********************************************************************\n*\n*       INFORM USER THAT STAX RETURN CODE WAS NOT ZERO AND DENY\n*       LOGON.\n*\n*********************************************************************\nD1$HNSTX DS    0H                  NON-ZERO RETURN CODE FROM STAX\n         LR    R2,R15              PROTECT RETURN CODE\n         MVC   D1@MSGAR(L'STAXMSG),STAXMSG COPY MESSAGE\n         CVD   R15,D1@WORK1        CONVERT TO DECIMAL\n         OI    D1@WORK1+7,X'0F'    FIX SIGN\n         UNPK  D1@WORK1(5),D1@WORK1+5(3) UNPACK\n         MVC   D1@MSGAR+23(4),D1@WORK1+1 MOVE INTO MESSAGE\n         LA    R0,L'STAXMSG        GET LENGTH OF MESSAGE\n         LA    R1,D1@MSGAR         POINT TO MESSAGE\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         LR    R15,R2              RESTORE RETURN CODE\n         OI    ETBITS1,ET1DENY     DENY LOGON\n         B     D1$HEXIT            EXIT\n         EJECT\n***********************************************************************\n*                                                                     *\n*       INFORM USER THAT USERID IN USE AND DENY LOGON.                *\n*                                                                     *\n***********************************************************************\nD1$HDUPU DS    0H\n         LA    R0,L'DUPUSER        GET LENGTH OF MESSAGE\n         LA    R1,DUPUSER          POINT TO MESSAGE\n         TPUT  (1),(0),R           INFORM USER\n         OI    ETBITS1,ET1DENY     DENY LOGON\n         LA    R15,4               SET RETURN CODE\n         B     D1$HEXIT            AND EXIT\n         EJECT\n***********************************************************************\n*                                                                     *\n*       INFORM USER THAT LOGON HAD A RESOURCE FAILURE AND DENY LOGON. *\n*                                                                     *\n***********************************************************************\nD1$HRESC DS    0H\n         LA    R0,L'RESCFAIL       GET LENGTH OF MESSAGE\n         LA    R1,RESCFAIL         POINT TO MESSAGE\n         TPUT  (1),(0),R           INFORM USER\n         OI    ETBITS1,ET1DENY     DENY LOGON\n         LA    R15,4               SET RETURN CODE\n         B     D1$HEXIT            AND EXIT\n         EJECT\n***********************************************************************\n*                                                                     *\n*       INFORM USER THAT LOGON HAD AN ABEND AND DENY LOGON.           *\n*                                                                     *\n***********************************************************************\nD1$HABND DS    0H\n         LA    R0,L'LOGABEND       GET LENGTH OF MESSAGE\n         LA    R1,LOGABEND         POINT TO MESSAGE\n         TPUT  (1),(0),R           INFORM USER\n         OI    ETBITS1,ET1DENY     DENY LOGON\n         LA    R15,4               SET RETURN CODE\n         B     D1$HEXIT            AND EXIT\n         TITLE 'IKJEFLD1 - CLEANUP RESOURCES'\n*********************************************************************\n*\n* ROUTINE NAME -\n*    D1$CLEAN\n*\n* FUNCTION -\n*    PERFORMS CLEANUP FUNCTIONS.\n*\n* OPERATION -\n*    1) CANCEL STIMER.\n*    2) CANCEL STAX.\n*    4) IF UADS WAS OPENED, CLOSE AND FREE BUFFER.\n*    5) IF ANYTHING WAS ENQ'D ON, DEQ IT\n*    6) IF LOGON IS TO BE DENIED, SET DISCONNECT INDICATOR AND WAIT\n*       5 SECONDS IF THIS IS A DISPLAY TERMINAL TO GIVE THE USER\n*       TIME TO READ THE DIAGNOSTICS.\n*    7) IF ATTENTION WAS HIT, GO CHECK NEW COMMAND.\n*   10) CANCEL ESTAE.\n*\n*\n* ENTRY POINTS -\n*    D1$CLEAN\n*\n* EXTERNAL REFERENCES -\n*    NONE\n*\n* INPUT -\n*    NONE\n*\n* OUTPUT -\n*    NONE\n*\n* MESSAGES -\n*    NONE\n*\n*********************************************************************\n         SPACE 3\nD1$CLEAN DS    0H                  RETURN TO CALLER\n         SUBENTRY ,                PROTECT RETURN CODE\n         EJECT\n********************************************************************\n*\n*       CANCEL STIMER WITH MOTHER TASK.\n*\n********************************************************************\n*        TM    ETBITS1,GABEND      HAS ABEND OCCURED\n*        BO    CLNUP1              IF SO SKIP TTIMER CANCEL\n*        XC    STREQECB,STREQECB   CLEAR ECB\n*        L     R0,=A(X'FFFFFF')    MARK TO CANCEL\n*        POST  MTREQECB,(0)        WAKE UP MOTHER\n*        WAIT  ECB=STREQECB        WAIT TILL DONE\n*LNUP1   DS    0H\n         EJECT\n*********************************************************************\n*\n*       CANCEL STAX.\n*\n*********************************************************************\n         STAX  0                   CANCEL STAX\n         STAX  0                   CANCEL STAX\n         EJECT\n*********************************************************************\n*\n*       IF LOGON IS TO BE DENIED, SET DISCONNECT INDICATOR AND WAIT\n*       5 SECONDS IF THIS IS A DISPLAY TERMINAL TO GIVE THE USER\n*       TIME TO READ THE DIAGNOSTICS.\n*\n*********************************************************************\n         TM    ETBITS1,ET1DENY     IS LOGON TO BE DENIED\n         BNO   D1$COK              NO - CONTINUE\n         PARM  D1SWITCH            GET ADDRESS OF CONTROL SWITCHES\n         OI    0(R1),KBIT3         INDICATE DISCONNECT\n         GTSIZE ,                  DETERMINE TERMINAL TYPE\n         LTR   R0,R0               WAS THIS A DISPLAY\n         BZ    D1$CEND             NO - CONTINUE\n         STIMER WAIT,DINTVL==C'00000500' - WAIT A LITTLE WHILE FIRST\n         B     D1$CEND             THEN CONTINUE\nD1$COK   DS    0H\n         EJECT\n*********************************************************************\n*\n*       IF ATTENTION WAS HIT, GO CHECK NEW COMMAND.\n*\n*********************************************************************\n         TM    ETBITS1,ET1ATTN     WAS ATTENTION HIT\n         BO    D1$CCHEK            YES - GO CHECK NEW COMMAND\n         EJECT\n*********************************************************************\n*\n*       IF DEBUGGING MODE, HANDLE DISPLAYS\n*\n*********************************************************************\nD1$CEND  DS    0H\n         TM    ETBITS3,ET3DEBUG    DEBUG IN PROGRESS??\n         BZ    D1$C999             NOPE, SKIP CODE\n         WTO   'IKJEFLD1: EXITING',ROUTCDE=(2)\n         CLI   ETTEST,128\n         BNE   D1$C999\n         LR    R1,R10\n         L     R15,=A(IKJEXIT+X'80000000')\n         BASR  R14,R15\nD1$C999  DS    0H\n         EJECT\n*********************************************************************\n*\n*       CANCEL ESTAE.\n*\n*********************************************************************\n         ESTAE 0                   CANCEL ESTAE\n         EJECT\n********************************************************************\n*\n*       RETURN TO CALLER\n*\n********************************************************************\n         SUBEXIT ,                 GET RETURN REG\n         EJECT\n*********************************************************************\n*\n*       IF COMMAND WAS NOT 'LOGON' DENY LOGON.  IF COMMAND WAS\n*       'LOGON', REENTER LOGON EXIT WITH NEW COMMAND.\n*\n*********************************************************************\nD1$CCHEK DS    0H\n         BAS   R14,SCAN            CALL SCAN TO SEE IF 'LOGON'\n         LTR   R15,R15             WAS THE NEW COMMAND 'LOGON'\n         BZ    D1$CRENT            YES - REENTER\n         PARM  D1SWITCH            GET ADDRESS OF CONTROL SW DESC\n         OI    0(R1),KBIT3         INDICATE DISCONNECT\n         B     D1$CEND             RETURN\nD1$CRENT DS    0H\n         ESTAE 0                   CANCEL ESTAE\n         L     R13,4(,R13)         UNCHAIN SAVE AREAS\n         LA    R0,D1@WORK1        GET POINTER TO AREA TO CLEAN\n         LA    R1,DSAD1L-D1@WORK1+DSAD1  LENGTH TO CLEAR\n         SLR   R4,R4               ZERO FROM ADDRESS\n         SLR   R5,R5               ZERO FROM LENGTH\n         MVCL  R0,R4               CLEAR DYNAMIC AREA\n         LA    R0,EXTEX            GET POINTER TO AREA TO CLEAN\n         LA    R1,EXTEXL           LENGTH TO CLEAR\n         MVCL  R0,R4               CLEAR DYNAMIC AREA\n         B     D1$RSTRT            REENTER\n         TITLE 'IKJEFLD1 - SCAN COMMAND BUFFER'\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*    SCAN                                                             *\n*                                                                     *\n* FUNCTION -                                                          *\n*    SCAN INPUT BUFFER.                                               *\n*                                                                     *\n* OPERATION -                                                         *\n*    1) BUILDS CSPL AND CALLS IKJSCAN TO SCAN INPUT BUFFER.           *\n*    2) IF SCAN IS UNSUCCESSFUL, TELLS TSO USER AND DENIES LOGON.     *\n*    3) IF COMMAND IS NOT 'LOGON', TELLS TSO USER AND DENIES LOGON.   *\n*    4) RETURNS TO THE MAINLINE.                                      *\n*                                                                     *\n* ENTRY POINTS -                                                      *\n*    SCAN                                                             *\n*                                                                     *\n* EXTERNAL REFERENCES -                                               *\n*    IKJSCAN                                                          *\n*                                                                     *\n* INPUT -                                                             *\n*    COMMAND BUFFER.                                                  *\n*                                                                     *\n* OUTPUT -                                                            *\n*    NONE                                                             *\n*                                                                     *\n* MESSAGES -                                                          *\n*    'IKJSCAN UNSUCCESSFUL - RC=NNNN'                                 *\n*    'COMMAND IS NOT 'LOGON''                                         *\n*                                                                     *\n***********************************************************************\n         EJECT\nSCAN     DS    0H\n         SUBENTRY ,\n         EJECT\n***********************************************************************\n*                                                                     *\n*       BUILDS CSPL AND CALL IKJSCAN TO SCAN INPUT BUFFER.            *\n*                                                                     *\n***********************************************************************\n         LA    R1,D1@CSPL          GET ADDRESS OF CSPL\n         USING CSPL,R1             ESTABLISH ADDRESSABILITY TO CSPL\n         MVC   CSPLUPT,D1@CPPL+CPPLUPT-CPPL COPY UPT ADDRESS\n         MVC   CSPLECT,D1@CPPL+CPPLECT-CPPL COPY ECT ADDRESS\n         LA    R15,D1@ECB          GET ADDRESS OF CP ECB\n         ST    R15,CSPLECB         STORE CP ECB ADDRESS\n         XC    D1@ECB,D1@ECB       CLEAR CP ECB\n         LA    R15,D1@CSPFL        GET ADDRESS OF FLAGS\n         ST    R15,CSPLFLG         STORE FLAG ADDRESS\n         XC    D1@CSPFL,D1@CSPFL   CLEAR FLAGS - REQUEST SYNTAX CHECK\n         LA    R15,D1@CSLOA        GET ADDRESS OF OUTPUT AREA\n         ST    R15,CSPLOA          STORE OUTPUT AREA ADDRESS\n         XC    D1@CSLOA,D1@CSLOA   CLEAR OUTPUT AREA\n         MVC   CSPLCBUF,D1@CPPL+CPPLCBUF-CPPL COPY CMD BUFFER ADDRESS\n         L     R15,CSPLCBUF        GET COMMAND BUFFER ADDRESS\n         USING CBUF,R15            GET CBUF ADDRESSABILITY\n         XC    CBUFOFFS,CBUFOFFS   RESET OFFSET FOR SCAN\n         CALLTSSR EP=IKJSCAN,MF=(E,D1@CSPL) CALL IKJSCAN\n         EJECT\n***********************************************************************\n*                                                                     *\n*       IF SCAN IS UNSUCCESSFUL, TELLS TSO USER AND DENIES LOGON.     *\n*                                                                     *\n***********************************************************************\n         LTR   R15,R15             WAS SCAN SUCCESSFUL\n         BNZ   SCANBSCN            NO - GO ISSUE MESSAGE\n         LA    R1,D1@CSLOA         YES - GET PTR TO SCAN OUTPUT AREA\n         USING CSOA,R1             GET ADDRESSABILITY TO OUTPUT AREA\n         EJECT\n***********************************************************************\n*                                                                     *\n*       IF COMMAND IS NOT 'LOGON', TELLS TSO USER AND DENIES LOGON.   *\n*                                                                     *\n***********************************************************************\n         TM    CSOAFLG,CSOAVWP+CSOAVNP VALID SYNTAX WITH/WITHOUT PARMS\n         BZ    SCANBCMD            NO - BAD COMMAND\n         CLI   CSOALNM+1,5         YES - IS COMMAND LENGTH 5 BYTES\n         BNE   SCANLOGF            NO - MAY BE 'LOGOFF'\n         L     R1,CSOACNM          YES - GET ADDRESS OF COMMAND NAME\n         CLC   =C'LOGON',0(R1)     IS COMMAND NAME 'LOGON'\n         BNE   SCANBCMD            NO - BAD COMMAND\n         SLR   R15,R15             YES - SET RETURN CODE\n         EJECT\n***********************************************************************\n*                                                                     *\n*       RETURNS TO THE MAINLINE.                                      *\n*                                                                     *\n***********************************************************************\nSCANEXIT DS    0H\n         SUBEXIT ,\n         EJECT\n***********************************************************************\n*                                                                     *\n*       INFORM USER THAT IKJSCAN RETURN CODE WAS NOT ZERO AND DENY    *\n*       LOGON.                                                        *\n*                                                                     *\n***********************************************************************\nSCANBSCN DS    0H                  NON-ZERO RETURN CODE FROM IKJSCAN\n         LR    R2,R15              PROTECT RETURN CODE\n         MVC   D1@MSGAR(L'SCANMSG),SCANMSG COPY MESSAGE\n         CVD   R15,D1@WORK1        CONVERT TO DECIMAL\n         OI    D1@WORK1+7,X'0F'    FIX SIGN\n         UNPK  D1@WORK1(5),D1@WORK1+5(3) UNPACK\n         MVC   D1@MSGAR+26(4),D1@WORK1+1 MOVE INTO MESSAGE\n         LA    R0,L'SCANMSG        GET LENGTH OF MESSAGE\n         LA    R1,D1@MSGAR         POINT TO MESSAGE\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         LR    R15,R2              RESTORE RETURN CODE\n         OI    ETBITS1,ET1DENY     DENY LOGON\n         DC    H'0'\n         B     SCANEXIT            EXIT\n         EJECT\n***********************************************************************\n*                                                                     *\n*       INFORM USER THAT COMMAND WAS NOT 'LOGON' AND DENY LOGON.      *\n*                                                                     *\n***********************************************************************\nSCANBCMD DS    0H                  COMMAND IS NOT 'LOGON'\n         LA    R0,L'BCMNDMSG       GET LENGTH OF MESSAGE\n         LA    R1,BCMNDMSG         POINT TO MESSAGE\n         TPUT  (1),(0),R           ISSUE MESSAGE\nSCANBRET DS    0H\n         LA    R15,16              SET RETURN CODE\n         OI    ETBITS1,ET1DENY     DENY LOGON\n         B     SCANEXIT            EXIT\n         EJECT\n*********************************************************************\n*\n*       IF COMMAND WAS 'LOGOFF', DENY LOGON WITHOUT MESSAGE TO USER.\n*\n*********************************************************************\nSCANLOGF DS    0H\n         TM    ETBITS1,ET1ATTN     WAS ATTENTION HIT\n         BZ    SCANBCMD            NO - CONTINUE\n         CLI   CSOALNM+1,6         YES - IS COMMAND LENGTH 6 BYTES\n         BNE   SCANBCMD            NO - BAD COMMAND\n         L     R1,CSOACNM          YES - GET ADDRESS OF COMMAND NAME\n         CLC   =C'LOGOFF',0(R1)    IS COMMAND NAME 'LOGOFF'\n         BNE   SCANBCMD            NO - BAD COMMAND\n         B     SCANBRET            YES - DENY LOGON WITHOUT MESSAGE\n         TITLE 'IKJEFLD1 - PARSE COMMAND BUFFER'\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*    PARSE                                                            *\n*                                                                     *\n* FUNCTION -                                                          *\n*    PARSE INPUT BUFFER.                                              *\n*                                                                     *\n* OPERATION -                                                         *\n*    1) BUILDS PPL AND CALLS IKJPARS TO PARSE INPUT BUFFER.           *\n*    2) IF PARSE IS UNSUCCESSFUL AND IKJPARS ISSUED MESSAGE, DENIES   *\n*       LOGON.  IF IKJPARS DID NOT ISSUE MESSAGE, CALLS GNRLFAIL TO   *\n*       ISSUE MESSAGE.  IF GNRLFAIL IS UNSUCCESSFUL, TELLS TSO USER   *\n*       THAT GNRLFAIL HAD A NOT-ZERO RETURN CODE. IN ALL OF THE ABOVE *\n*       CASES, DENIES LOGON UNLESS ATTENTION HIT.\n*    3) RETURNS TO THE MAINLINE.                                      *\n*                                                                     *\n* ENTRY POINTS -                                                      *\n*    PARSE                                                            *\n*                                                                     *\n* EXTERNAL REFERENCES -                                               *\n*    IKJPARS                                                          *\n*    IKJEFF19 (GNRLFAIL)                                              *\n*                                                                     *\n* INPUT -                                                             *\n*    COMMAND BUFFER.                                                  *\n*                                                                     *\n* OUTPUT -                                                            *\n*    NONE                                                             *\n*                                                                     *\n* MESSAGES -                                                          *\n*    'GNRLFAIL UNSUCCESSFUL - RC=NNNN'                                *\n*                                                                     *\n***********************************************************************\n         EJECT\nPARSE    DS    0H\n         SUBENTRY ,\n         EJECT\n***********************************************************************\n*                                                                     *\n*       BUILDS PPL AND CALLS IKJPARS TO PARSE INPUT BUFFER.           *\n*                                                                     *\n***********************************************************************\n         LA    R1,D1@PPL           GET ADDRESS OF PPL\n         USING PPL,R1              ESTABLISH ADDRESSABILITY TO PPL\n         MVC   PPLUPT,D1@CPPL+CPPLUPT-CPPL COPY UPT ADDRESS\n         MVC   PPLECT,D1@CPPL+CPPLECT-CPPL COPY ECT ADDRESS\n         LA    R15,D1@ECB          GET ADDRESS OF CP ECB\n         ST    R15,PPLECB          STORE CP ECB ADDRESS\n         XC    D1@ECB,D1@ECB       CLEAR CP ECB\n         MVC   PPLPCL,=A(PARMTAB)  STORE PCL ADDRESS\n         LA    R15,D1@PPANS        GET ADDRESS OF PDL\n         ST    R15,PPLANS          STORE PDL ADDRESS\n         MVC   PPLCBUF,D1@CPPL+CPPLCBUF-CPPL COPY CMD BUFFER ADDRESS\n         CALLTSSR EP=IKJPARS,MF=(E,D1@PPL) CALL IKJPARS\n         LTR   R15,R15             WAS PARSE SUCCESSFUL\n         BZ    PARSEXIT            YES - RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*       IF PARSE IS UNSUCCESSFUL AND IKJPARS ISSUED MESSAGE, DENIES   *\n*       LOGON.  IF IKJPARS DID NOT ISSUE MESSAGE, CALLS GNRLFAIL TO   *\n*       ISSUE MESSAGE.  IF GNRLFAIL IS UNSUCCESSFUL, TELLS TSO USER   *\n*       THAT GNRLFAIL HAD A NOT-ZERO RETURN CODE. IN ALL OF THE ABOVE *\n*       CASES, DENIES LOGON UNLESS ATTENTION HIT.\n*                                                                     *\n***********************************************************************\n         TM    ETBITS1,ET1ATTN     WAS ATTENTION HIT\n         BO    PARSATTN            YES - DONT SET DENY BIT\n         OI    ETBITS1,ET1DENY     NO - DENY LOGON\nPARSATTN DS    0H\n         LA    R14,4               GET 4 IN R14 FOR COMPARISON\n         CR    R14,R15             DID PARSE ISSUE MESSAGE\n         BE    PARSEXIT            YES - QUIT\n         LA    R14,8               NO - GET 8 IN R14\n         CR    R14,R15             DID PARSE GET AN ATTENTION KEY\n         BE    PARSEXIT            YES - QUIT\n         LA    R14,20              NO - GET 20 IN R14\n         CR    R14,R15             DID VALIDITY CHECKING ISSUE MSG\n         BE    PARSEXIT            YES - QUIT\n         LR    R2,R15              NO - PROTECT PARSE RETURN CODE\n         XC    D1@GFPRS,D1@GFPRS   CLEAR GNRLFAIL PARAMETER LIST\n         LA    R1,D1@GFPRS         POINT TO GNRLFAIL PARM LIST ADDR\n         ST    R1,D1@GFPRP         STORE IN GNRLFAIL PARM LIST POINTER\n         USING GFDSECTD,R1         ESTABLISH ADDRESSABILITY TO GF PARMS\n         ST    R15,GFRCODE         STORE PARSE RETURN CODE\n         LA    R15,GFPARSE         LOAD CALLER ID FOR PARSE\n         STH   R15,GFCALLID        STORE CALLER ID\n         LA    R15,D1@CPPL         GET ADDRESS OF CPPL\n         ST    R15,GFCPPLP         STORE POINTER TO CPPL\n         LA    R15,D1@ECB          GET ADDRESS OF CP ECB\n         ST    R15,GFECBP          STORE CP ECB POINTER\n         XC    D1@ECB,D1@ECB       CLEAR CP ECB\n         LINK  EP=IKJEFF19,MF=(E,D1@GFPRP) LINK TO GNRLFAIL\n         LTR   R15,R15             WAS GNRLFAIL SUCCESSFUL\n         LR    R15,R2              RESTORE PARSE RETURN CODE\n         BZ    PARSEXIT            YES - EXIT\n         LR    R2,R15              NO - PROTECT GNRLFAIL RETURN CODE\n         MVC   D1@MSGAR(L'GFAILMSG),GFAILMSG COPY MESSAGE\n         CVD   R15,D1@WORK1        CONVERT TO DECIMAL\n         OI    D1@WORK1+7,X'0F'    FIX SIGN\n         UNPK  D1@WORK1(5),D1@WORK1+5(3) UNPACK\n         MVC   D1@MSGAR+27(4),D1@WORK1+1 MOVE INTO MESSAGE\n         LA    R0,L'GFAILMSG       GET LENGTH OF MESSAGE\n         LA    R1,D1@MSGAR         POINT TO MESSAGE\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         LR    R15,R2              RESTORE GNRLFAIL RETURN CODE\n         EJECT\n***********************************************************************\n*                                                                     *\n*       RETURNS TO THE MAINLINE.                                      *\n*                                                                     *\n***********************************************************************\nPARSEXIT DS    0H\n         SUBEXIT ,\n         TITLE 'IKJEFLD1 - SAVE ANY BFG INFO FROM LOGON COMMAND'\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*    D1$SVINF                                                         *\n*                                                                     *\n* FUNCTION -                                                          *\n*    SAVE ANY BFG INFORMATION FROM LOGON COMMAND                      *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*                                                                     *\n* ENTRY POINTS -                                                      *\n*    D1$SVINF                                                         *\n*                                                                     *\n* EXTERNAL REFERENCES -                                               *\n*    NONE                                                             *\n*                                                                     *\n* INPUT -                                                             *\n*    NONE                                                             *\n*                                                                     *\n* OUTPUT -                                                            *\n*    NONE                                                             *\n*                                                                     *\n* MESSAGES -                                                          *\n*    NONE                                                             *\n*                                                                     *\n* COMMENTS -                                                          *\n*    NONE                                                             *\n*                                                                     *\n***********************************************************************\nD1$SVINF DS    0H\n         SUBENTRY ,\n         EJECT\n***********************************************************************\n*                                                                     *\n*       SAVE BFG SELECTED INFO IF PRESENT.                            *\n*                                                                     *\n***********************************************************************\n         L     R4,D1@PPANS         GET ANSWER AREA\n         USING IKJPARMD,R4         SETUP ADDRESSABILITY\n*  SAVE ADDRESS VALUE\n         LA    R1,SADDRESS\n         LA    R3,ETADDRS\n         BAL   R14,D1$SVMOV\n*  SAVE COPIES VALUE\n         LA    R1,SCOPIES\n         LA    R3,ETCOPY\n         BAL   R14,D1$SVMOV\n*  SAVE DEBUG FLAG\n         OC    PDEBUG(2),PDEBUG    WAS 'DEBUG' SPECIFIED\n         BZ    *+8                 IF NOT SKIP SET\n         OI    ETBITS3,ET3DEBUG+ET3LSTIN SET FLAGS\n*  SAVE FORM VALUE\n         LA    R1,SFORMS\n         LA    R3,ETFORM\n         BAL   R14,D1$SVMOV\n*  SAVE JCL FLAG\n         OC    PJCL(2),PJCL        WAS 'JCL' SPECIFIED\n         BZ    *+8                 IF NOT SKIP SET\n         OI    ETBITS3,ET3JCL      SET FLAGS\n*  SAVE LINE COUNT VALUE\n         LA    R1,SLINECT\n         LA    R3,ETLINCT\n         BAL   R14,D1$SVMOV\n*  SAVE LISTINFO FLAG\n         OC    PLIST(2),PLIST      WAS 'LISTINFO' SPECIFIED\n         BZ    *+8                 IF NOT SKIP SET\n         OI    ETBITS3,ET3LSTIN    SET FLAGS\n*  SAVE MESSAGE CLASS VALUE\n         LA    R1,SMSGCLAS\n         LA    R3,ETMSGC\n         BAL   R14,D1$SVMOV\n*  SAVE MESSAGE LEVEL VALUE\n         LA    R1,SMSGLEVL\n         LA    R3,ETMSGL\n         BAL   R14,D1$SVMOV\n         TM    SMSGLEVL+6,X'80'    WAS FIRST ENTRY SPECIFIED\n         BZ    D1$SV10             NO, SO SKIP CODE\n         CLI   SMSGLEVL+8,X'FF'    ANY MORE ENTRIES\n         BE    D1$SV10             NO, SO SKIP CODE\n         SR    R1,R1               CLEAR REGISTER\n         ICM   R1,B'0111',SMSGLEVL+9 GET ADDRESS PORTION\n         LA    R3,D1@WORK1         POINT TO AREA\n         BAL   R14,D1$SVMOV        MOVE IN SECOND ENTRY\n         MVI   ETMSGL+3,C','\n         LH    R1,D1@WORK1         GET LENGTH\n         LTR   R1,R1               ANY VALUE\n         BZ    D1$SV10             IF NOT THEN DONE\n         LH    R15,ETMSGL          GET CURRENT LENGTH\n         LA    R15,ETMSGL+2(R15)   POINT PAST IT\n         MVI   0(R15),C','         SET THE COMMA\n         LA    R15,1(,R15)         POINT TO NEXT CHAR\n         BCTR  R1,0                GET MACHINE LENGTH\n         EX    R1,D1$SV99          MOVE IN SECOND VALUE\n         AH    R1,ETMSGL           ADD IN ORIG LENGTH\n         LA    R1,2(R1)            PLUS ORIG LENGTH & COMMA\n         STH   R6,ETMSGL            WITH THE PREVIOUS VALUE\nD1$SV10  DS    0H\n*  SAVE NAME VALUE\n         LA    R1,SNAME\n         LA    R3,ETNAME\n         BAL   R14,D1$SVMOV\n*  SAVE PHONE VALUE\n         LA    R1,SPHONE\n         LA    R3,ETPHONE\n         BAL   R14,D1$SVMOV\n*  SAVE PROGRAMMER NAME VALUE\n         LA    R1,SPROGNAM\n         LA    R3,ETPRGNM\n         BAL   R14,D1$SVMOV\n*  SAVE ROOM NUMBER VALUE\n         LA    R1,SROOM\n         LA    R3,ETROOM\n         BAL   R14,D1$SVMOV\n*  SAVE CPU TIME VALUE\n         LA    R1,SCPUTIME\n         LA    R3,ETCPTIM\n         BAL   R14,D1$SVMOV\n         DROP  R4\n         EJECT\n***********************************************************************\n*                                                                     *\n*       IF DEBUGGING MODE, HANDLE DISPLAYS                            *\n*                                                                     *\n***********************************************************************\n         TM    ETBITS3,ET3DEBUG    DEBUG IN PROGRESS??\n         BZ    D1$M999             NOPE, SKIP CODE\n         WTO   'IKJEFLD1: INSIDE',ROUTCDE=(2)\n         CLI   ETTEST,128\n         BNE   D1$M999\n         LR    R1,R10\n         L     R15,=A(IKJEXIT+X'80000000')\n         BASR  R14,R15\nD1$M999  DS    0H\n         EJECT\n***********************************************************************\n*                                                                     *\n*       RETURNS TO THE MAINLINE.                                      *\n*                                                                     *\n***********************************************************************\n         SR    R15,R15             SET GOOD RETURN CODE\nD1$SEXIT DS    0H\n         SUBEXIT ,\n         SPACE 3\nD1$SV99  MVC   0(0,R15),D1@WORK1+2 ** EXECUTED\n         EJECT\n***********************************************************************\n*                                                                     *\n*       SUBROUTINE TO MOVE DATA FROM PDE TO MY AREA.                  *\n*                                                                     *\n*              R1 => PDE                                              *\n*              R3 => LENGTH(2), DATA AREA                             *\n*              R14 = RETURN ADDRESS                                   *\n*                                                                     *\n***********************************************************************\nD1$SVMOV TM    6(R1),X'80'         WAS OPERAND PRESENT\n         BZR   R14                 NOT PRESENT\n         ICM   R15,B'0011',4(R1)   GET LENGTH\n         BZR   R14                 EXIT IF ZERO LENGTH\n         STH   R15,0(,R3)          SAVE LENGTH\n         L     R1,0(,R1)           GET ADDRESS\n         BCTR  R15,0               GET MACHINE LENGTH\n         EX    R15,D1$SVM99        MOVE DATA\n         BR    R14\nD1$SVM99 MVC   2(0,R3),0(R1)       ** EXECUTED **\n         TITLE 'IKJEFLD1 - SAVE ANY BFG INFO FROM LOGON COMMAND'\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*    D1$MKCMD                                                         *\n*                                                                     *\n* FUNCTION -                                                          *\n*    CREATE NEW COMMAND BUFFER WITHOUT BFG ONLY OPERANDS.             *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*                                                                     *\n* ENTRY POINTS -                                                      *\n*    D1$MKCMD                                                         *\n*                                                                     *\n* EXTERNAL REFERENCES -                                               *\n*    NONE                                                             *\n*                                                                     *\n* INPUT -                                                             *\n*    NONE                                                             *\n*                                                                     *\n* OUTPUT -                                                            *\n*    NONE                                                             *\n*                                                                     *\n* MESSAGES -                                                          *\n*    NONE                                                             *\n*                                                                     *\n* COMMENTS -                                                          *\n*    NONE                                                             *\n*                                                                     *\n***********************************************************************\nD1$MKCMD DS    0H\n         SUBENTRY ,\n         EJECT\n***********************************************************************\n*                                                                     *\n*       CLEAR OUT ORIGINAL COMMAND BUFFER                             *\n*                                                                     *\n***********************************************************************\n         PARM  D1CMDBFR            GET POINTERS\n         LR    R2,R1               SET R2 => THE CMD BUFFER\n         LA    R3,4(,R15)          SET R3 => LENGTH AREA (4 BYTES)\n         MVC   0(4,R3),=F'6'       INITIAL LENGTH\n         MVC   0(6,R2),=C'LOGON '  AND VALUE\n         L     R5,D1@PPANS         GET ANSWER AREA\n         USING IKJPARMD,R5         SETUP ADDRESSABILITY\n*  USERID AND PASSWORDS\n         LA    R4,PUSERID          POINT TO PDE\n         BAL   R14,D1$MMV90\n         TM    PUSERID+8+6,X'80'   IS PASSWORD PRESENT\n         BZ    D1$MMV09\n         LA    R4,=C'/'\n         LA    R1,1                MACHINE LENGTH\n         BAL   R14,D1$MMV95\n         LA    R4,PUSERID+8        POINT TO PDE\n         BAL   R14,D1$MMV90\n         TM    PUSERID+16+6,X'80'   IS NEW PASSWORD PRESENT\n         BZ    D1$MMV09\n         LA    R4,=C'/'\n         LA    R1,1                MACHINE LENGTH\n         BAL   R14,D1$MMV95\n         LA    R4,PUSERID+16       POINT TO PDE\n         BAL   R14,D1$MMV90\nD1$MMV09 DS    0H\n*  HANDLE MAIL/NOMAIL\n         OC    PMAIL,PMAIL         ANY SPECIFIED\n         BZ    D1$MMV19\n         CLC   PMAIL,=H'1'         IS THIS MAIL\n         BNE   D1$MMV11\n         LA    R4,=C' MAIL'\n         LA    R1,5                MACHINE LENGTH\n         BAL   R14,D1$MMV95\n         B     D1$MMV19\nD1$MMV11 CLC   PMAIL,=H'2'         IS THIS NOMAIL\n         BNE   D1$MMV12\n         LA    R4,=C' NOMAIL'\n         LA    R1,7                MACHINE LENGTH\n         BAL   R14,D1$MMV95\n         B     D1$MMV19\nD1$MMV12 DS    0H\nD1$MMV19 DS    0H\n*  HANDLE NOTICES/NONOTICES\n         OC    PNOTICES,PNOTICES   ANY SPECIFIED\n         BZ    D1$MMV29\n         CLC   PNOTICES,=H'1'      IS THIS NOTICES\n         BNE   D1$MMV21\n         LA    R4,=C' NOTICES'\n         LA    R1,8                MACHINE LENGTH\n         BAL   R14,D1$MMV95\n         B     D1$MMV29\nD1$MMV21 CLC   PNOTICES,=H'2'      IS THIS NONOTICES\n         BNE   D1$MMV22\n         LA    R4,=C' NONOTICES'   THE STRING TO INSERT\n         LA    R1,10               MACHINE LENGTH\n         BAL   R14,D1$MMV95        INSERT THE DATA\n         B     D1$MMV29\nD1$MMV22 DS    0H\nD1$MMV29 DS    0H\n*  HANDLE RECONNECT\n         OC    PRECON,PRECON\n         BZ    D1$MMV39\n         LA    R4,=C' RECONNECT'   THE STRING TO INSERT\n         LA    R1,10               MACHINE LENGTH\n         BAL   R14,D1$MMV95        INSERT THE DATA\nD1$MMV39 DS    0H\n*  HANDLE ACCOUNT SUB PARAMETER\n         TM    SACCT+6,X'80'       IS IT PRESENT\n         BZ    D1$MMV49            NO, SKIP INSERT\n         LA    R4,=C' ACCT('''     THE STRING TO INSERT\n         LA    R1,7                MACHINE LENGTH\n         BAL   R14,D1$MMV95        INSERT THE DATA\n         LA    R4,SACCT            POINT TO PDE\n         BAL   R14,D1$MMV90\n         LA    R4,=C''')'          THE STRING TO INSERT\n         LA    R1,2                MACHINE LENGTH\n         BAL   R14,D1$MMV95        INSERT THE DATA\nD1$MMV49 DS    0H\n*  HANDLE SIZE SUB PARAMETER\n         TM    SSIZE+6,X'80'       IS IT PRESENT\n         BZ    D1$MMV59            NO, SKIP INSERT\n         LA    R4,=C' SIZE('       THE STRING TO INSERT\n         LA    R1,6                MACHINE LENGTH\n         BAL   R14,D1$MMV95        INSERT THE DATA\n         LA    R4,SSIZE            POINT TO PDE\n         BAL   R14,D1$MMV90\n         LA    R4,=C')'            THE STRING TO INSERT\n         LA    R1,1                MACHINE LENGTH\n         BAL   R14,D1$MMV95        INSERT THE DATA\nD1$MMV59 DS    0H\n*  HANDLE PROCEDURE SUB PARAMETER\n         TM    SPROC+6,X'80'       IS IT PRESENT\n         BZ    D1$MMV69            NO, SKIP INSERT\n         LA    R4,=C' PROC('       THE STRING TO INSERT\n         LA    R1,6                MACHINE LENGTH\n         BAL   R14,D1$MMV95        INSERT THE DATA\n         LA    R4,SPROC            POINT TO PDE\n         BAL   R14,D1$MMV90\n         LA    R4,=C')'            THE STRING TO INSERT\n         LA    R1,1                MACHINE LENGTH\n         BAL   R14,D1$MMV95        INSERT THE DATA\nD1$MMV69 DS    0H\n         EJECT\n***********************************************************************\n*                                                                     *\n*       IF DEBUGGING THEN OUTPUT THE LOGON COMMAND TO CONSOLE         *\n*                                                                     *\n***********************************************************************\n         TM    ETBITS3,ET3DEBUG    DEBUG IN PROGRESS??\n         BZ    D1$MMV80            NOPE, SKIP CODE\n         L     R1,0(R3)            GET LENGTH\n         LA    R1,4(,R1)           INCREASE\n         STH   R1,D1@CBUF\n         MVC   D1@CBUF+2(2),=X'8000'\n         MVC   D1@CBUF+4(252),0(R2) MOVE IN BUFFER\n         LA    R1,D1@CBUF(R1)      POINT AFTER STRING\n         MVC   0(4,R1),=AL2(0,X'4000') SET ROUTCDE\n         WTO   MF=(E,D1@CBUF)\nD1$MMV80 DS    0H\n         EJECT\n***********************************************************************\n*                                                                     *\n*       RELEASE STORAGE FOR PDL                                       *\n*                                                                     *\n***********************************************************************\n         LA    R1,D1@PPANS\n         IKJRLSA (1)\n         EJECT\n***********************************************************************\n*                                                                     *\n*       RETURNS TO THE MAINLINE.                                      *\n*                                                                     *\n***********************************************************************\n         SR    R15,R15             CLEAR RETURN CODE\nD1$MEXIT SUBEXIT ,\n         EJECT\n***********************************************************************\n*                                                                     *\n*       SUBROUTINE TO MOVE DATA TO NEW COMMAND BUFFER                 *\n*              R4 => PDE OF ITEM TO MOVE                              *\n*              R3 => CURRENT LENGTH OF CMD BUFFER                     *\n*              R2 => START OF CMD BUFFER                              *\n*                                                                     *\n***********************************************************************\nD1$MMV90 DS    0H\n         TM    6(R4),X'80'         IS PARM PRESENT\n         BZR   R14                 EXIT IF NOT\n         LH    R1,4(,R4)           GET LENGTH\n         LTR   R1,R1               IS THERE ANY LENGTH\n         BZR   R14                 EXIT IF NOT\n         L     R4,0(,R4)           GET ADDRESS\nD1$MMV95 L     R15,0(,R3)          GET CURRENT LENGTH\n         AR    R15,R2              GET OUTPUT ADDRESS\n         BCTR  R1,0                GET MACHINE LENGTH\n         EX    R1,D1$MMV99\n         A     R1,0(,R3)           INCREMENT LENGTH\n         LA    R1,1(,R1)           PLUS DECREMENT\n         ST    R1,0(,R3)           SAVE NEW LENGTH\n         BR    R14\nD1$MMV99 MVC   0(0,R15),0(R4)      ** EXECUTED **\n         TITLE 'DAUGHTER TASK - STAX EXIT ROUTINE'\n*********************************************************************\n*\n* ROUTINE NAME -\n*    D1$RSTAX\n*\n* FUNCTION -\n*    ENTERED AFTER AN ATTENTION INTERRUPT HAS OCCURED.\n*\n* OPERATION -\n*    1) CHECKS LENGTH OF INPUT BUFFER.  IF ZERO, EXIT.\n*    2) UPDATES ORIGINAL INPUT BUFFER.\n*    3) REBUILDS CBUF.\n*    4) POSTS CP ECB.\n*    5) RETURNS TO CALLER.\n*\n* ENTRY POINTS -\n*    D1$RSTAX\n*\n* EXTERNAL REFERENCES -\n*    NONE\n*\n* INPUT -\n*    ATTENTION EXIT PARAMETER LIST (AEPL)\n*\n* OUTPUT -\n*    NONE\n*\n* MESSAGES -\n*    NONE\n*\n*********************************************************************\n         EJECT\n         PUSH  USING\n         USING *,R15\nD1$RSTAX DS    0H\n         SAVE  (14,12),,D1$RSTAX   SAVE CALLER'S REGISTERS\n         L     R12,=A(IKJEFLD1)    GET REAL BASE\n         POP   USING\n         USING AEPL,R1             ESTABLISH ADDRESSABILITY TO AEPL\n         L     R2,AEPLUSAD         GET ADDRESS OF USADDR FROM AEPL\n         LR    R3,R13              SAVE CALLER'S R13\n         L     R9,4(,R2)           GET PHASE DSA ADDRESS\n         L     R11,8(,R2)          GET EXTOEX ADDRESS\n         L     R10,12(,R2)         GET PARM ADDRESS\n         EJECT\n*********************************************************************\n*\n*       CHECKS LENGTH OF INPUT BUFFER.  IF ZERO, EXIT.\n*\n*********************************************************************\n         L     R1,AEPLTAIE         GET ADDRESS OF TAIE FROM AEPL\n         DROP  R1                  DROP APEL ADDRESSABILITY\n         USING TAIE,R1             ESTABLISH ADDRESSABILITY TO TAIE\n         SR    R2,R2               CLEAR REGISTER\n         ICM   R2,B'0011',TAIEMSGL GET LENGTH OF INPUT BUFFER\n         DROP  R1                  DROP TAIE ADDRESSABILITY\n         BZ    STAXRTRN            ELSE - GET OUT\n         EJECT\n*********************************************************************\n*\n*       UPDATES ORIGINAL INPUT BUFFER.\n*\n*********************************************************************\n         PARM  D1CMDBFR\n         ST    R2,4(,R15)          UPDATE ACTUAL LENGTH\n         EJECT\n*********************************************************************\n*\n*       REBUILDS CBUF.\n*\n*********************************************************************\n         LA    R2,4(,R2)           ADD 4 FOR LENGTH AND OFFSET\n         STH   R2,D1@CBUF+CBUFLEN-CBUF UPDATE BUILT CBUF\n         XC    D1@CBUF+CBUFOFFS-CBUF(2),D1@CBUF+CBUFOFFS-CBUF ZERO OFF\n         MVC   D1@CBUF+CBUFTEXT-CBUF(252),0(R1)  COPY STAX RESPONSE\n         EJECT\n*********************************************************************\n*\n*       POSTS CP ECB.\n*\n*********************************************************************\n         POST  D1@ECB              POST CP ECB\n         OI    ETBITS1,ET1ATTN     INDICATE ATTENTION INTERRUPT\n         EJECT\n*********************************************************************\n*\n*       RETURNS TO CALLER.\n*\n*********************************************************************\nSTAXRTRN DS    0H\n         LR    R13,R3              RESTORE CALLER'S R13\n         RETURN (14,12),RC=0       RETURN TO CALLER\n         TITLE 'DAUGHTER TASK - DUMMY STAX EXIT ROUTINE'\n*********************************************************************\n*\n* ROUTINE NAME -\n*    D1$DSTAX\n*\n* FUNCTION -\n*    ENTERED AFTER AN ATTENTION INTERRUPT HAS OCCURED.\n*      **  THIS IS THE DUMMY SECOND LEVEL HANDLER  **\n*\n* OPERATION -\n*    1) RETURNS TO CALLER.\n*\n* ENTRY POINTS -\n*    D1$DSTAX\n*\n* EXTERNAL REFERENCES -\n*    NONE\n*\n* INPUT -\n*    ATTENTION EXIT PARAMETER LIST (AEPL)\n*\n* OUTPUT -\n*    NONE\n*\n* MESSAGES -\n*    NONE\n*\n* NOTES -\n*    ADDRESSABILITY IS ESTABLISHED TO REST OF EXIT AND TO DYNAMIC\n*    AREA IN CASE THIS MAY BE NEEDED IN THE FUTURE.\n*\n*********************************************************************\n         EJECT\n         PUSH  USING\n         USING *,R15\nD1$DSTAX DS    0H\n         SAVE  (14,12),,D1$DSTAX   SAVE CALLER'S REGISTERS\n         L     R12,=A(IKJEFLD1)    GET REAL BASE\n         POP   USING\n         USING AEPL,R1             ESTABLISH ADDRESSABILITY TO AEPL\n         L     R2,AEPLUSAD         GET ADDRESS OF USADDR FROM AEPL\n         LR    R3,R13              SAVE CALLER'S R13\n         L     R9,4(,R2)           GET PHASE DSA ADDRESS\n         L     R11,8(,R2)          GET EXTOEX ADDRESS\n         L     R10,12(,R2)         GET PARM ADDRESS\n         SPACE 5\n*********************************************************************\n*\n*       RETURNS TO CALLER.\n*\n*********************************************************************\n         LR    R13,R3              RESTORE CALLER'S R13\n         RETURN (14,12),RC=0       RETURN TO CALLER\n         TITLE 'IKJEFLD1 - TEMPORARY ENTRY POINTS '\n         PUSH  USING\n         DROP  R12\n         USING *,R15\nD1$RETRY DS    0H\n         L     R12,=A(IKJEFLD1)    GET REAL BASE\n         POP   USING\n         OI    ETBITS1,ET1DENY     MARK TO DENY\n         LA    R15,16              SET ABEND RETURN CODE\n         B     D1$EXIT             ALL DONE\n         LTORG ,\n         DROP  ,\n         TITLE 'IKJEFLD1 - CONSTANTS AREA'\nKEYZERO  MODESET KEY=ZERO,MF=L     GET KEY 0\nNONZERO  MODESET KEY=NZERO,MF=L    RETURN TO USER KEY\nLESTAE   ESTAE ,MF=L               ESTAE PARAMETER LIST\nLGESTAE  EQU   *-LESTAE            CALCULATE LENGTH OF ESTAE PARM LIST\nSDUMP    SDUMP MF=L                SDUMP PARAMETER LIST\nLSDUMP   EQU   *-SDUMP             CALCULATE LENGTH OF SDUMP PARM\n         TITLE 'DAUGHTER TASK - MESSAGES'\n*                          1         2\n*                0123456789012345678901234567\nESTAEMSG DC    C'ESTAE UNSUCCESSFUL - RC=XXXX'\nSTAXOBUF DC    C'ENTER ''LOGON'' OR ''LOGOFF'' -'\n*                          1         2\n*                012345678901234567890123456\nSTAXMSG  DC    C'STAX UNSUCCESSFUL - RC=XXXX'\n*                          1         2\n*                012345678901234567890123456\nTGETMSG  DC    C'TGET UNSUCCESSFUL - RC=XXXX'\n*                          1         2\n*                012345678901234567890123456\nSTOWMSG  DC    C'STOW UNSUCCESSFUL - RC=XXXX'\nRESCFAIL DC    C'RESOURCE FAILURE.'\nLOGABEND DC    C'LOGON ABEND.'\n*                          1         2\n*                012345678901234567890123456789\nSCANMSG  DC    C'IKJSCAN UNSUCCESSFUL - RC=XXXX'\n*                          1         2         3\n*                0123456789012345678901234567890\nGFAILMSG DC    C'GNRLFAIL UNSUCCESSFUL - RC=XXXX'\nBCMNDMSG DC    C'COMMAND IS NOT ''LOGON'''\nNOTFOUND DC    C'USER NOT AUTHORIZED TO USE TIME-SHARING'\nDIVQUOTA DC    C'DIV. QUOTA CURRENTLY ON'\nBADPASS  DC    C'PASSWORD NOT AUTHORIZED FOR THIS USERID'\nPMSGHDR  DC    AL2(LPASSMSG,0),C' '\nPASSMSG  DC    C'ENTER PASSWORD -'\nLPASSMSG EQU   *-PMSGHDR\nNPMSGHDR DC    AL2(LNPASMSG,0),C' '\nNPASSMSG DC    C'ENTER NEW PASSWORD -'\nLNPASMSG EQU   *-NPMSGHDR\nBADACCT  DC    C'ACCT # NOT AUTHORIZED FOR THIS USERID'\nPRMPTMSG DC    C'PROMPT LIMIT EXCEEDED'\nAMSGHDR  DC    AL2(LACCTMSG,0),C' '\nACCTMSG  DC    C'ENTER ACCOUNT NUMBER -'\nLACCTMSG EQU   *-AMSGHDR\nBADPROC  DC    C'PROCEDURE IGNORED'\nDUPUSER  DC    C'USERID CURRENTLY LOGGED ON'\nBADRECON DC    C'RECONNECT SPECIFIED BUT USERID NOT LOGGED ON'\n*                     1         2         3         4\n*               4567890123456789012345678901234567890 123\nLOGWTO   WTO   'UNKNOWN LOGGING ON TERMINAL - ASID X''NNNN''',         X\n               MCSFLAG=HRDCPY,MF=L\nNOTEST   WTO   'IKJEFLD1: TEST ROUTINE INVOKED BUT NOT PRESENT',       X\n               ROUTCDE=(2),MF=L\nLLOGWTO  EQU   *-LOGWTO            CALCULATE LENGTH OF WTO MESSAGE\nCLRSCRN  DC    X'27F5401D40'       CLEAR SCREEN\nNAMEMSG  DC    C'ENTER YOUR NAME - '\nPHONEMSG DC    C'ENTER YOUR PHONE NUMBER - '\nADDRMSG  DC    C'ENTER YOUR ADDRESS - '\nPASSWARN DC    C'PASSWORD SHOULD BE CHANGED'\nLOG60MSG DC    C'USER HAS NOT LOGGED ON IN 60 DAYS'\nPAS28MSG DC    C'USER HAS NOT CHANGED PASSWORD IN 28 DAYS'\nTIMEMSG  DC    C'TIME EXCEEDS USER''S LIMIT.  MAXIMUM USED'\nLASTCARD DC    C'ENTER LAST JCL CARD OR ''END'''\nNEXTCARD DC    C'ENTER NEXT JCL CARD OR ''END'''\nMANYMSG  DC    C'TOO MANY CARDS ENTERED. LOGON PROCEEDING'\nBADJCL   DC    C'JCL IGNORED'\nENTRCONT DC    C'PRESS ENTER TO CONTINUE LOGON'\n         TITLE 'IKJEFLD1 - PARSE PARAMETER LIST'\n         PUSH  PRINT\n         PRINT NOGEN\n         SPACE 5\nPCLADDR  DC    A(PARMTAB)          ADDRESS OF PARS PARAMETER LIST\nPARMTAB  IKJPARM DSECT=IKJPARMD    START OF PCL\nPUSERID  IKJPOSIT UID2PSWD,PROMPT='USERID', USERID/PASSWORD/NEWPSWD\nPACCTNUM IKJKEYWD\n         IKJNAME 'ACCT',SUBFLD=ACCTSUB\nPPROC    IKJKEYWD\n         IKJNAME 'PROC',SUBFLD=PROCSUB\n*\nPRECON   IKJKEYWD\n         IKJNAME 'RECONNECT'\nPMAIL    IKJKEYWD DEFAULT='NOMAIL'\n         IKJNAME 'MAIL'\n         IKJNAME 'NOMAIL'\nPNOTICES IKJKEYWD DEFAULT='NONOTICES'\n         IKJNAME 'NOTICES'\n         IKJNAME 'NONOTICES'\n*\nPDEBUG   IKJKEYWD\n         IKJNAME 'DEBUG',INSERT='LISTINFO'\n*\nPNAME    IKJKEYWD\n         IKJNAME 'NAME',SUBFLD=NAMESUB\n*\nPPHONE   IKJKEYWD\n         IKJNAME 'PHONE',SUBFLD=PHONSUB\n*\nPADDRESS IKJKEYWD\n         IKJNAME 'ADDRESS',SUBFLD=ADDRSUB\n*\nPPROGNAM IKJKEYWD\n         IKJNAME 'PROGNAME',SUBFLD=PROGSUB\n*\nPCPUTIME IKJKEYWD\n         IKJNAME 'TIME',SUBFLD=CPUTSUB\n*\nPSIZE    IKJKEYWD\n         IKJNAME 'SIZE',SUBFLD=SIZESUB\n*\nPMSGCLAS IKJKEYWD\n         IKJNAME 'MSGCLASS',SUBFLD=MSGCSUB\n*\nPMSGLEVL IKJKEYWD\n         IKJNAME 'MSGLEVEL',SUBFLD=MSGLSUB\n*\nPFORMS   IKJKEYWD\n         IKJNAME 'FORMS',SUBFLD=FORMSUB\n*\nPROOM    IKJKEYWD\n         IKJNAME 'ROOM',SUBFLD=ROOMSUB\n*\nPLIST    IKJKEYWD\n         IKJNAME 'LISTINFO'\n*\nPJCL     IKJKEYWD\n         IKJNAME 'JCL'\n*\nPCOPIES  IKJKEYWD\n         IKJNAME 'COPIES',SUBFLD=COPSUB\n*\nPLINECT  IKJKEYWD\n         IKJNAME 'LINECT',SUBFLD=LINSUB,ALIAS=('K') LIKE /*JOBPARM\n         SPACE 3\n*        BEGIN SUBFIELDS\nACCTSUB  IKJSUBF\nSACCT    IKJIDENT 'ACCOUNT NUMBER',FIRST=NONATNUM,MAXLNTH=8,           X\n               OTHER=NONATNUM,PROMPT='ACCOUNT NUMBER'\n         SPACE 3\nPROCSUB  IKJSUBF\nSPROC    IKJIDENT 'PROCEDURE NAME',FIRST=ALPHA,MAXLNTH=8,              X\n               OTHER=ALPHANUM,PROMPT='PROCEDURE NAME'\n         SPACE 3\n*\nNAMESUB  IKJSUBF\nSNAME    IKJIDENT 'YOUR NAME',MAXLNTH=60,CHAR,                         X\n               PROMPT='YOUR NAME IN APOSTROPHES'\n         SPACE 3\n*\nPHONSUB  IKJSUBF\nSPHONE   IKJIDENT 'YOUR PHONE NUMBER',MAXLNTH=15,CHAR,                 X\n               PROMPT='YOUR PHONE NUMBER IN APOSTROPHES'\n         SPACE 3\n*\nADDRSUB  IKJSUBF\nSADDRESS IKJIDENT 'YOUR ADDRESS',MAXLNTH=60,CHAR,                      X\n               PROMPT='YOUR ADDRESS IN APOSTROPHES'\n         SPACE 3\n*\nPROGSUB  IKJSUBF\nSPROGNAM IKJIDENT 'PROGRAMMER NAME',MAXLNTH=20,CHAR,                   X\n               PROMPT='PROGRAMMER NAME IN ASPOSTOPHES'\n         SPACE 3\n*\nCPUTSUB  IKJSUBF\nSCPUTIME IKJIDENT 'CPU TIME',MAXLNTH=4,FIRST=NUMERIC,                  X\n               OTHER=NUMERIC,PROMPT='CPU TIME'\n         SPACE 3\n*\nSIZESUB  IKJSUBF\nSSIZE    IKJIDENT 'REGION SIZE',MAXLNTH=7,FIRST=NUMERIC,               X\n               OTHER=NUMERIC,PROMPT='REGION SIZE'\n         SPACE 3\n*\nMSGCSUB  IKJSUBF\nSMSGCLAS IKJIDENT 'MSGCLASS',MAXLNTH=1,FIRST=NONATNUM,                 X\n               PROMPT='MSGCLASS'\n         SPACE 3\n*\nMSGLSUB  IKJSUBF\nSMSGLEVL IKJIDENT 'MSGLEVEL',LIST,MAXLNTH=1,FIRST=NUMERIC,             X\n               PROMPT='MSGLEVEL'\n         SPACE 3\n*\nFORMSUB  IKJSUBF\nSFORMS   IKJIDENT 'JOB FORMS',MAXLNTH=4,FIRST=NONATNUM,                X\n               OTHER=NONATNUM,PROMPT='JOB FORMS'\n         SPACE 3\n*\nROOMSUB  IKJSUBF\nSROOM    IKJIDENT 'ROOM NUMBER',MAXLNTH=4,FIRST=NONATNUM,              X\n               OTHER=NONATNUM,PROMPT='ROOM NUMBER'\n         SPACE 3\n*\nCOPSUB   IKJSUBF\nSCOPIES  IKJIDENT 'COPIES',MAXLNTH=3,FIRST=NUMERIC,                    X\n               OTHER=NUMERIC,PROMPT='COPY COUNT'\n         SPACE 3\n*\nLINSUB   IKJSUBF\nSLINECT  IKJIDENT 'LINECT',MAXLNTH=3,FIRST=NUMERIC,                    X\n               OTHER=NUMERIC,PROMPT='LINE COUNT'\n         SPACE 3\n         IKJENDP\n         SPACE 5\n         POP   PRINT\n         EJECT\nDSAD1    DSECT\nD1@SAVE  DS    (18*5)F\nD1@WORK1 DS    D                   GENERAL WORK AREA\nD1@ECB   DS    F                   ECB FOR CALLS\nD1@CPPL  DS    XL(LCPPL)\n         SPACE 5\n*        THE FOLLOWING STORAGE IS FOR ESTAE AND ESTAE PROCESSING\nD1@ESTAE ESTAE ,MF=L               ESTAE PARAMETER LIST\n         SPACE 5\n*        THE FOLLOWING STORAGE IS FOR STAX\nD1@STAX1 STAX  ,MF=L               DUMMY STAX PARAMETER LIST\nLSTAX    EQU   *-D1@STAX1          CALCULATE LENGTH OF STAX PRM LIST\nD1@STAX2 STAX  ,MF=L               STAX PARAMETER LIST\n         SPACE 5\n*        THE FOLLOWING STORAGE IS FOR SCAN\nD1@CSPL DS     XL(LCSPL)           CSPL\nD1@CSPFL DS    F                   CSPL FLAG\nD1@CSLOA DS    XL(LCSOA)           CSPL OUTPUT AREA\n         SPACE 5\n*        THE FOLLOWING STORAGE IS FOR PARSE\nD1@PPL   DS    XL(LPPL)            PPL\nD1@PPANS DS    F                   PPL PDL\n         SPACE 5\n*        THE FOLLOWING STORAGE IS FOR GNRLFAIL\nD1@GFPRS DS    XL(GFLENGF)         GNRLFAIL PARAMETER LIST\nD1@GFPRP DS    F                   GNRLFAIL PARM LIST POINTER\n         SPACE 5\n* SPACE FOR MESSAGE TO BE ISSUED\nD1@MSGAR DS    CL100\n         SPACE 5\n* SPACE FOR COMMAND BUFFER\n         DS    0F\nD1@CBUF  DS    CL256\nDSAD1L   EQU   *-DSAD1\n         TITLE 'IKJEFLD1 - STANDARD EXIT PARAMETER LIST'\nD1CMDBFR EQU   1                   COMMAND BUFFER\nD1NEWCMD EQU   2                   NEW COMMAND BUFFER\nD1UPT    EQU   3                   UPT\nD1ECT    EQU   4                   ECT\nD1PSCB   EQU   5                   PSCB\nD1EXTOEX EQU   6                   EXIT TO EXIT COMM WORD\nD1RCODE  EQU   7                   EXIT REASON CODE\n*              8                   RESERVED\n*              9                   RESERVED\nD1SWITCH EQU   10                  CONTROL SWITCHES\nD1USERID EQU   11                  USERID\nD1PASSWD EQU   12                  CURRENT PASSWORD\nD1ACCNT  EQU   13                  ACCOUNT NUMBER\nD1PROC   EQU   14                  PROCEDURE NAME\nD1RSIZE  EQU   15                  REGION SIZE\nD1JCL    EQU   16                  JCL STATEMENTS\nD1NPSWD  EQU   17                  NEW PASSWORD\nD1SYSATR EQU   18                  SYSTEM ATTRIBUTES\nD1USRATR EQU   19                  USER ATTRIBUTES\nD1UNIT   EQU   20                  GENERIC UNIT NAME\nD1CECB   EQU   21                  CANCEL ECB\nD1PERFGP EQU   22                  PERFORMANCE GROUP\nD1DDEST  EQU   23                  DEFAULT SYSOUT DESTINATION\nD1GROUP  EQU   24                  RACF GROUP\nD1SHOLD  EQU   25                  SUBMIT HOLD CLASS\nD1SCLASS EQU   26                  SUBMIT CLASS\nD1SMCLAS EQU   27                  SUBMIT MESSAGE CLASS\nD1DSYSOT EQU   28                  DEFAULT SYSOUT CLASS\nD1FSTCMD EQU   29                  FIRST COMMAND\nD1RBA    EQU   30                  BORDCAST RBA\nD1SECLBL EQU   31                  SECURITY LABEL\nD1CNSLPF EQU   32                  CONSOLE COMMAND PROFILE\nD1PRMLNG EQU   33                  PRIMARY LANGUAGE ID\nD1SNDLNG EQU   34                  SECONDARY LANGUAGE ID\n         TITLE 'IKJEFLN1 - LOGON PRE-DISPLAY EXIT'\nIKJEFLN1 CSECT\nIKJEFLN1 AMODE 31\nIKJEFLN1 RMODE 24\n         SAVE  (14,12),,IKJEFLN1_&SYSDATE._&SYSTIME\n         LR    R12,R15             SET NEW BASE REGISTER\n         LR    R10,R1              SAVE PARM LIST\n         USING IKJEFLN1,R12,R8     SETUP ADDRESSABILITY\n         LA    R8,2048(,R12)       SETUP SECOND\n         LA    R8,2048(,R8)          BASE REGISTER\n         PARM  N1EXTOEX            GET EXIT TO EXIT PARM ENTRY\n         LR    R11,R1              SET ADDRESS\n         USING EXTEX,R11\n         EJECT\n***********************************************************************\n*                                                                     *\n*       GET THIS EXIT WORK AREA/SAVE AREA                             *\n*                                                                     *\n***********************************************************************\n         GETMAIN R,LV=DSAN1L,SP=11\n         ST    R13,4(,R1)          SAVE ADDRESS\n         LR    R13,R1              SET NEW SAVE AREA\n         LR    R9,R1               SET NEW SAVE AREA\n         USING DSAN1,R9\n         EJECT\n***********************************************************************\n*                                                                     *\n*       IF DEBUGGING MODE, HANDLE DISPLAYS AND TEST VERSION           *\n*                                                                     *\n***********************************************************************\n         CLI   ETTEST,255          FLAG AS TEST VERSION WANTED?\n         BNE   N1$M998             NOPE, SO USE PRODUCTION VERSION\n         PARM  N1EXTOEX\n         MVC   0(12,R15),ETHSKEY   SET TO ORIGINAL\n         LR    R1,R10              GET PARM LIST\n         LINK  EP=ZZZEFLN1         CALL TEST VERSION\n         LR    R2,R15              SAVE RETURN CODE\n         PARM  N1EXTOEX\n         MVC   ETHSKEY(12),0(R15)  SAVE THE TEST PGMS STUFF\n         MVC   0(12,R15),ETMYKEY   MOVE MY STUFF BACK IN\n         B     N1$BYE              RETURN WITH TEST EXIT CODE\n         SPACE 2\nN1$M998  DS    0H\n         TM    ETBITS3,ET3DEBUG    DEBUG IN PROGRESS??\n         BZ    N1$M999             NOPE, SKIP CODE\n         WTO   'IKJEFLN1: INSIDE',ROUTCDE=(2)\n         CLI   ETTEST,128\n         BNE   N1$M999\n         LR    R1,R10\n         L     R15,=A(IKJEXIT+X'80000000')\n         BASR  R14,R15\nN1$M999  DS    0H\n         EJECT\n***********************************************************************\n*                                                                     *\n*       MAINLINE PROCESSING                                           *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n*               1. IF USERID IS NOT LOCKED THEN EXIT\n         PARM  N1REPMPT\n         CLC   0(4,R1),=F'0'       IS THIS NORMAL PROMPT\n         BE    N1$NORM             YES, SO CONTINUE\n         CLC   0(4,R1),=F'2'       IS THIS NORMAL PASSWORD PROMPT\n         BNE   N1$EXIT             NO, SO EXIT\nN1$NORM  DS    0H\n         TM    ETBITS3,ET3DEBUG    DEBUGGING REQUESTED??\n         BZ    N1$10               NOPE SKIP CODE\n         WTO   'IKJEFLN1: PROCESSING',ROUTCDE=(2)\nN1$10    DS    0H\n*               2. DO HOUSEKEEPING\n         BAS   R14,N1$HSKP\n         LTR   R15,R15\n         BNZ   N1$DENY\n*               3. VALIDATE USERID AND GET BLOCKS FROM SYS1.UADS      *\n         BAS   R14,N1$USER\n         LTR   R15,R15\n         BNZ   N1$DENY\n*               4. UPDATE USER FIELDS FOR THE SCREEN\n         BAS   R14,N1$SCRN\n         LTR   R15,R15\n         BNZ   N1$DENY\n*               2. VERIFY TERMINAL RESTRICTIONS                       *\n         BAS   R14,N1$GTERM\n         LTR   R15,R15\n         BNZ   N1$DENY\n*               3. PERFORM 'ASKBACK' FUNCTION                         *\n         BAS   R14,N1$VTERM\n         LTR   R15,R15\n         BNZ   N1$DENY\n         EJECT\n***********************************************************************\n*                                                                     *\n*        FREE THIS EXIT WORK AREA AND EXIT                            *\n*                                                                     *\n***********************************************************************\nN1$EXIT  DS    0H\n         SR    R2,R2               CLEAR RETURN CODE\nN1$BYE   DS    0H\n*               5. CLEANUP AND RETURN                                 *\n         BAS   R14,N1$CLEAN\n*\n         LR    R1,R13\n         L     R13,4(,R13)\n         FREEMAIN R,LV=DSAN1L,A=(1),SP=11\n         LR    R15,R2              SET RETURN CODE\n         L     R14,12(,R13)        RESTORE REGISTERS\n         LM    R0,R12,20(R13)      RESTORE REGISTERS\n         BSM   0,R14               RETURN\nN1$DENY  LA    R2,16               DENY LOGON\n*\n**       PER OY48170 (0X250) NEED TO SET SWITCHES TO PREVENT\n**       IKJEFLN2 FROM BEING CALLED\n*\n         PARM  N1SWITCH\n         OI    4(R1),N1SW4NPR      SET \"NOPROMPT\" SWITCH\n         NI    4(R1),255-N1SW4IN2  RESET \"INVOKE IKJEFLN2\" SWITCH\n         B     N1$BYE\n         TITLE 'IKJEFLN1 - HOUSEKEEPING FUNCTIONS'\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*    N1$HSKP                                                          *\n*                                                                     *\n* FUNCTION -                                                          *\n*    PERFORMS HOUSEKEEPING FUNCTIONS FOR LOGONXIT.                    *\n*                                                                     *\n* OPERATION -                                                         *\n*    1) ISSUES ESTAE.  IF ESTAE IS UNSUCCESSFUL, TELLS TSO USER AND   *\n*       DENIES LOGON.                                                 *\n*    7) ATTEMPTS TO OPEN SYS1.UADS.  IF OPEN IS UNSUCCESSFUL, TELLS   *\n*       TSO USER AND DENIES LOGON.                                    *\n*    8) GETS STORAGE FOR UADS DATA BLOCKS.                            *\n*   14) RETURNS TO THE MAINLINE.\n*                                                                     *\n* ENTRY POINTS -                                                      *\n*    N1$HSKP                                                          *\n*                                                                     *\n* EXTERNAL REFERENCES -                                               *\n*    GETAUTH                                                          *\n*                                                                     *\n* INPUT -                                                             *\n*    NONE                                                             *\n*                                                                     *\n* OUTPUT -                                                            *\n*    NONE                                                             *\n*                                                                     *\n* MESSAGES -                                                          *\n*    'ESTAE UNSUCCESSFUL - RC=NNNN'                                   *\n*    'OPEN OF SYS1.UADS UNSUCCESSFUL'                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nN1$HSKP  DS    0H\n         SUBENTRY ,\n         EJECT\n***********************************************************************\n*                                                                     *\n*       ISSUES ESTAE.  IF ESTAE IS UNSUCCESSFUL, TELLS TSO USER AND   *\n*       DENIES LOGON.                                                 *\n*                                                                     *\n***********************************************************************\n         L     R1,=A(LESTAE)\n         MVC   N1@ESTAE(LGESTAE),0(R1) COPY ESTAE PARM LIST\n         L     R3,=A(GP$ESTAE)     GET ADDRESS OF ESTAE EXIT\n         LA    R4,ETESTPM          GET ADDRESS OF ESTAE PARMS\n         LA    R1,N1$RETRY         POINT TO RETRY ROUTINE\n         ST    R1,0(,R4)           SAVE ADDRESS OF RETRY ROUTINE\n         ST    R9,4(,R4)           SAVE PHASE DSA ADDRESS\n         ST    R11,8(,R4)          SAVE EXTOEX ADDRESSS\n         ST    R10,12(,R4)         SAVE INPUT ADDRESSS\n         ESTAE (3),PARAM=(4),MF=(E,N1@ESTAE) ESTABLISH ESTAE\n         LTR   R15,R15             WAS ESTAE SUCCESSFUL\n         BNZ   N1$HNSTA            NO - GO GIVE MESSAGE\n         EJECT\n***********************************************************************\n*                                                                     *\n*       BUILDS CPPL.                                                  *\n*                                                                     *\n***********************************************************************\n         PARM  N1UPT               GET ADDRESS OF UPT\n         ST    R1,N1@CPPL+CPPLUPT-CPPL PUT IN CPPL\n         PARM  N1PSCB              GET ADDRESS OF MY PSCB\n         ST    R1,N1@CPPL+CPPLPSCB-CPPL PUT IN CPPL\n         PARM  N1ECT               GET ADDRESS OF ECT\n         ST    R1,N1@CPPL+CPPLECT-CPPL PUT IN CPPL\n         EJECT\n***********************************************************************\n*                                                                     *\n*       ATTEMPTS TO OPEN SYS1.UADS.  IF OPEN IS UNSUCCESSFUL, TELLS   *\n*       TSO USER AND DENIES LOGON.                                    *\n*                                                                     *\n***********************************************************************\n         MVC   ETUADS,SYSUADS      MOVE SYS1.UADS DCB TO DYNAMIC AREA\n         MVC   ETOPENL,OPENUPDT    MOVE OPEN LIST TO DYNAMIC AREA\n         LA    R15,ETJFCB          GET ADDRESS OF JFCB AREA\n         ST    R15,ETEXLST         PUT IN ETEXLST\n         MVI   ETEXLST,X'87'       INDICATE JFCB ADDRESS\n         LA    R15,ETEXLST         GET ADDRESS OF ETEXLST\n         LA    R1,ETUADS           GET ADDRESS OF SYSUADS DCB\n         USING IHADCB,R1           GET DCB ADDRESSABILITY\n         STCM  R15,B'0111',DCBEXLSA PUT ADDRRESS OF ETEXLST IN DCB\n         STCM  R1,B'0111',ETOPENL+1 PUT ADDR OF DCB IN OPEN LIST\n         DROP  R1                  DROP DCB ADDRESSABILITY\n         OPEN  MF=(E,ETOPENL)      ATTEMPT TO OPEN SYS1.UADS\n         TM    ETUADS+DCBOFLGS-IHADCB,DCBOFOPN DID UADS OPEN\n         BZ    N1$HNOPN            NO - GO TO ERROR ROUTINE\n         RDJFCB MF=(E,ETOPENL)     YES - READ JFCB FOR LATER ENQ\n         L     R15,PSATOLD-PSA     GET ADDRESS OF MY TCB\n         L     R15,TCBTIO-TCB(,R15) GET ADDRESS OF MY TIOT\n         AH    R15,ETUADS+DCBTIOT-IHADCB GET ADDRESS OF UADS TIOT\n         MVC   ETAUCB,16(R15)      SAVE UCB ADDRESS FOR RESERVE\n         EJECT\n***********************************************************************\n*                                                                     *\n*       GETS STORAGE FOR UADS DATA BLOCKS.                            *\n*                                                                     *\n***********************************************************************\n         LH    R0,ETUADS+DCBBLKSI-IHADCB GET BLKSIZE\n         MH    R0,=H'3'            MULTIPLY BY 3\n*                                  (ASKBACK, TERM, INFO)\n         AH    R0,=H'8'            INCREASE FOR HEADERS\n         ST    R0,ETUADSIZ         SAVE SIZE FOR FREEMAIN\n         GETMAIN RU,LV=(0),BNDRY=PAGE GET AREA FOR SYS1.UADS BUFFER\n         ST    R1,ETUADADR         SAVE ADDR OF GOTTEN AREA\n         LH    R15,ETUADS+DCBBLKSI-IHADCB GET BLOCK LEN\n         STH   R15,2(R1)           SAVE HEADER FOR KEYVAL\n         LA    R1,4(R1)            POINT TO DATA AREA\n         ST    R1,ETAASKB          SAVE ASKBACK BLOCK ADDR\n         AR    R1,R15              MOVE TO NEXT BLOCK\n         STH   R15,2(R1)           SAVE HEADER FOR KEYVAL\n         LA    R1,4(R1)            POINT TO DATA AREA\n         ST    R1,ETATERM          SAVE TERMINAL BLOCK ADDR\n         AR    R1,R15              MOVE TO NEXT BLOCK\n         ST    R1,ETAINFO          SAVE ADDRESS OF INFO BLOCK BUFFER\n         EJECT\n********************************************************************\n*\n*        BLANK OUT ASKBACK AND TERM BLOCK\n*\n********************************************************************\n         L     R2,ETAASKB          GET ADDR OF BLOCK\n         LR    R1,R2               MOVE ADDRESS\n         BCTR  R1,0                NOW GET LENGTH\n         BCTR  R1,0\n         LH    R3,0(R1)            GET LENGTH OF BLOCK\n         LR    R15,R3              SAVE IT\n         L     R1,=X'40000000'     SET PAD CHAR\n         SR    R0,R0               CLEAR FROM ADDR\n         MVCL  R2,R0               CLEAR BLOCK\n         L     R2,ETATERM          POINT AT TERM BLOCK\n         LR    R3,R15              SET LENGTH\n         MVCL  R2,R0               BLANK IT OUT\n         EJECT\n***********************************************************************\n*                                                                     *\n*       RETURNS TO THE MAINLINE.                                      *\n*                                                                     *\n***********************************************************************\n         SR    R15,R15             SET GOOD RETURN CODE\nN1$HEXIT DS    0H\n         SUBEXIT ,\n         EJECT\n***********************************************************************\n*                                                                     *\n*       INFORM USER THAT OPEN FAILED AND DENY LOGON.                  *\n*                                                                     *\n***********************************************************************\nN1$HNOPN DS    0H                  SYS1.UADS DID NOT OPEN\n         LA    R0,L'OPENMSG        GET LENGTH OF MESSAGE\n         LA    R1,OPENMSG          POINT TO MESSAGE\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         LA    R15,4               SET RETURN CODE\n         OI    ETBITS1,ET1DENY     DENY LOGON\n         B     N1$HEXIT            EXIT\n         EJECT\n***********************************************************************\n*                                                                     *\n*       INFORM USER THAT ESTAE RETURN CODE WAS NOT ZERO AND DENY      *\n*       LOGON.                                                        *\n*                                                                     *\n***********************************************************************\nN1$HNSTA DS    0H                  NON-ZERO RETURN CODE FROM ESTAE\n         LR    R2,R15              PROTECT RETURN CODE\n         L     R1,=A(ESTAEMSG)\n         MVC   N1@MSGAR(L'ESTAEMSG),0(R1)  COPY MESSAGE\n         CVD   R15,N1@WORK1        CONVERT TO DECIMAL\n         OI    N1@WORK1+7,X'0F'    FIX SIGN\n         UNPK  N1@WORK1(5),N1@WORK1+5(3) UNPACK\n         MVC   N1@MSGAR+24(4),N1@WORK1+1 MOVE INTO MESSAGE\n         LA    R0,L'ESTAEMSG       GET LENGTH OF MESSAGE\n         LA    R1,N1@MSGAR         POINT TO MESSAGE\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         LR    R15,R2              RESTORE RETURN CODE\n         OI    ETBITS1,ET1DENY     DENY LOGON\n         B     N1$HEXIT            EXIT\n         TITLE 'IKJEFLN1 - CLEANUP RESOURCES'\n*********************************************************************\n*\n* ROUTINE NAME -\n*    N1$CLEAN\n*\n* FUNCTION -\n*    PERFORMS CLEANUP FUNCTIONS.\n*\n* OPERATION -\n*    9) IF UADS WAS OPENED, CLOSE AND FREE BUFFER.\n*    9) IF ANYTHING WAS ENQ'D ON, DEQ IT.\n*   10) CANCEL ESTAE.\n*\n*\n* ENTRY POINTS -\n*    N1$CLEAN\n*\n* EXTERNAL REFERENCES -\n*    NONE\n*\n* INPUT -\n*    NONE\n*\n* OUTPUT -\n*    NONE\n*\n* MESSAGES -\n*    NONE\n*\n*********************************************************************\n         SPACE 3\nN1$CLEAN DS    0H                  RETURN TO CALLER\n         SUBENTRY ,                PROTECT RETURN CODE\n         EJECT\n*********************************************************************\n*\n*       IF UADS WAS OPENED, CLOSE AND FREE BUFFER.\n*\n*********************************************************************\n         TM    ETUADS+DCBOFLGS-IHADCB,DCBOFOPN DID UADS OPEN\n         BZ    N1$CNOPN            NO - NO NEED TO DO FREEMAIN\nN1$CCLS  CLOSE MF=(E,ETOPENL)      CLOSE SYS1.UADS\nN1$CNOPN DS    0H\n         EJECT\n*********************************************************************\n*\n*       IF ANYTHING WAS ENQ'D/RESERVED'D ON, DEQ IT\n*\n*********************************************************************\n         TM    ETBITS2,ET2UADRS    WAS SYSIFJUA/OPENUADS ENQ'D ON\n         BZ    N1$CUADS            NO - CONTINUE\n         MVC   N1@ENQLT,ENQLIST3   YES - COPY ENQ LIST\n         MVI   N1@ENQLT+1,8        PUT LENGTH OF RNAME IN ENQ LIST\n         LA    R15,QNAME           GET ADDRESS OF QNAME (SYSIKJUA)\n         ST    R15,N1@ENQLT+4      PUT IN ENQ LIST\n         LA    R15,RNAME           GET ADDR OF RNAME (OPENUADS)\n         ST    R15,N1@ENQLT+8      PUT IN ENQ LIST\n         LA    R1,N1@ENQLT         GET ADDRESS OF ENQ LIST\n         DEQ   MF=(E,(1))          DEQ LIKE TSO ACCOUNT DOES\n         NI    ETBITS2,255-ET2UADRS TURN OFF SYSIKJUA/OPENUADS RESV\nN1$CUADS DS    0H\n         TM    ETBITS2,ET2SPFRS    WAS SPFDSN/DSN ENQ'D ON\n         BZ    N1$CSPF             NO - CONTINUE\n         MVC   N1@ENQLT,RESLIST    YES - COPY RESERVE LIST\n         MVI   N1@ENQLT+1,44       PUT LENGTH OF RNAME IN RES LIST\n         MVC   N1@RNAME(44),ETJFCB MOVE DSNAME TO RNAME\n         LA    R15,QNAME2          GET ADDRESS OF QNAME (SPFDSN  )\n         ST    R15,N1@ENQLT+4      PUT IN RESERVE LIST\n         LA    R15,N1@RNAME        GET ADDR OF RNAME (DSN)\n         ST    R15,N1@ENQLT+8      PUT IN RESERVE LIST\n         LA    R15,ETAUCB          GET ADDRESS OF UCB ADDRESS\n         ST    R15,N1@ENQLT+12     PUT IN RESERVE LIST\n         LA    R1,N1@ENQLT         GET ADDRESS OF RESERVE LIST\n         DEQ   MF=(E,(1))          DEQ LIKE ISPF DOES\n         NI    ETBITS2,255-ET2SPFRS TURN OFF SPFDSN/DSN RESERVED\nN1$CSPF  DS    0H\n         TM    ETBITS2,ET2SPFE0    WAS MEMBER0 ENQ'D ON\n         BZ    N1$CDEQ0            NO - GO CONTINUE\n         MVC   N1@ENQLT,ENQLIST2   YES - COPY ENQ LIST\n         MVI   N1@ENQLT+1,52       PUT LENGTH OF RNAME IN ENQ LIST\n         MVC   N1@RNAME(44),ETJFCB MOVE DSNAME TO RNAME\n         LH    R15,ETUSERID        GET LENGTH OF USERID\n         LA    R1,ETMEMBER(R15)    POINT TO BYTE AFTER USERID\n         MVI   0(R1),C'0'          ADD SUFFIX TO MAKE MEMBER0\n         MVC   N1@RNAME+44(8),ETMEMBER APPEND MEMBER0 NAME TO DSN\n         LA    R15,QNAME3          GET ADDRESS OF QNAME (SPFEDIT )\n         ST    R15,N1@ENQLT+4      PUT IN ENQ LIST\n         LA    R15,N1@RNAME        GET ADDR OF RNAME (DSN+MEMBER0)\n         ST    R15,N1@ENQLT+8      PUT IN ENQ LIST\n         LA    R1,N1@ENQLT         GET ADDRESS OF ENQ LIST\n         DEQ   MF=(E,(1))          DEQ LIKE ISPF DOES\n         NI    ETBITS2,255-ET2SPFE0 TURN OFF MEMBER0 ENQ'D ON\nN1$CDEQ0 DS    0H\n         TM    ETBITS2,ET2SPFEI    WAS INFO BLOCK ENQ'D ON\n         BZ    N1$CDEQI            NO - CONTINUE\n         MVC   N1@ENQLT,ENQLIST2   YES - COPY ENQ LIST\n         MVI   N1@ENQLT+1,52       PUT LENGTH OF RNAME IN ENQ LIST\n         MVC   N1@RNAME(44),ETJFCB MOVE DSNAME TO RNAME\n         MVC   N1@RNAME+44(8),ETINFOID APPEND INFO BLOCK NAME TO DSN\n         LA    R15,QNAME3          GET ADDRESS OF QNAME (SPFEDIT )\n         ST    R15,N1@ENQLT+4      PUT IN ENQ LIST\n         LA    R15,N1@RNAME        GET ADDR OF RNAME (DSN+USERID$)\n         ST    R15,N1@ENQLT+8      PUT IN ENQ LIST\n         LA    R1,N1@ENQLT         GET ADDRESS OF ENQ LIST\n         DEQ   MF=(E,(1))          DEQ LIKE ISPF DOES\n         NI    ETBITS2,255-ET2SPFEI TURN OFF INFO BLOCK ENQ'D ON\nN1$CDEQI DS    0H\n         EJECT\n*********************************************************************\n*\n*       IF LOGON IS TO BE DENIED, SET DISCONNECT INDICATOR AND WAIT\n*       5 SECONDS IF THIS IS A DISPLAY TERMINAL TO GIVE THE USER\n*       TIME TO READ THE DIAGNOSTICS.\n*\n*********************************************************************\n         TM    ETBITS1,ET1DENY     IS LOGON TO BE DENIED\n         BNO   N1$COK              NO - CONTINUE\n         GTSIZE ,                  DETERMINE TERMINAL TYPE\n         LTR   R0,R0               WAS THIS A DISPLAY\n         BZ    N1$CEND             NO - CONTINUE\n         STIMER WAIT,DINTVL==C'00000500' - WAIT A LITTLE WHILE FIRST\n         B     N1$CEND             THEN CONTINUE\nN1$COK   DS    0H\n         EJECT\n*********************************************************************\n*\n*       IF DEBUGGING MODE, HANDLE DISPLAYS\n*\n*********************************************************************\nN1$CEND  DS    0H\n         TM    ETBITS3,ET3DEBUG    DEBUG IN PROGRESS??\n         BZ    N1$C999             NOPE, SKIP CODE\n         WTO   'IKJEFLN1: EXITING',ROUTCDE=(2)\n         CLI   ETTEST,128\n         BNE   N1$C999\n         LR    R1,R10\n         L     R15,=A(IKJEXIT+X'80000000')\n         BASR  R14,R15\nN1$C999  DS    0H\n         EJECT\n*********************************************************************\n*\n*       CANCEL ESTAE.\n*\n*********************************************************************\n         ESTAE 0                   CANCEL ESTAE\n         EJECT\n********************************************************************\n*\n*       RETURN TO CALLER\n*\n********************************************************************\n         SUBEXIT ,                 GET RETURN REG\n         TITLE 'IKJEFLN1 - VALIDITY CHECK ROUTINE FOR USERID'\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*    N1$USER                                                          *\n*                                                                     *\n* FUNCTION -                                                          *\n*    ENTERED AS A VALIDITY CHECKING ROUTINE FROM IKJPARS TO VERIFY    *\n*    THE POSITIONAL VALUE OF USERID.                                  *\n*                                                                     *\n* OPERATION -                                                         *\n*    3) CHECKS TO SEE IF THE USERID IS IN THE TABLE OF USERIDS TO     *\n*       NEVER BE DENIED LOGON.  IF SO, BYPASS DIVISIONAL QUOTA        *\n*       CHECKING.                                                     *\n*    4) CHECKS THE NUMBER OF USERS ALLOWED TO BE LOGGED ON FOR THIS   *\n*       USER'S DIVISION.  IF ZERO, THE LOGON IS DENIED.  OTHERWISE,   *\n*       THE ASCBS ARE SEARCHED TO DETERMINE IF THE DIVISIONAL QUOTA   *\n*       IS CURRENTLY LOGGED ON.  IF SO, THE LOGON IS DENIED.          *\n*    5) CHECKS TO SEE IF THE USERID IS FOUND IN SYS1.UADS. IF NOT,    *\n*       THE LOGON IS DENIED.\n*    6) IF INFO BLOCK IS AVAILABLE, GET TTR.  IF NOT, CREATE ONE\n*       PADDED WITH BLANKS.\n*    7) READ IN INFO BLOCKS.\n*   13) RETURN TO IKJPARS.                                            *\n*                                                                     *\n* ENTRY POINTS -                                                      *\n*    N1$USER                                                          *\n*                                                                     *\n* EXTERNAL REFERENCES -                                               *\n*    GETPASS                                                          *\n*                                                                     *\n* INPUT -                                                             *\n*    NONE                                                             *\n*                                                                     *\n* OUTPUT -                                                            *\n*                                                                     *\n* MESSAGES -                                                          *\n*    'USER-ID LOGGING ON TERMINAL - ASID X'NN''\n*    'USER NOT AUTHORIZED TO USE TIME-SHARING'                        *\n*    'PROMPT LIMIT EXCEEDED'\n*    'DIVISIONAL QUOTA CURRENTLY LOGGED ON. TRY AGAIN LATER'          *\n*    'PASSWORD NOT AUTHORIZED FOR THIS USERID'                        *\n*    'YOU ARE NOT AUTHORIZED TO USE THIS TERMINAL\n*\n***********************************************************************\n         EJECT\nN1$USER  DS    0H\n         SUBENTRY ,\n         EJECT\n***********************************************************************\n*                                                                     *\n*       EXTRACTS THE USERID FROM THE PARM LIST AND PLACES IT IN       *\n*       ETUSERID PADDED WITH BLANKS.                                  *\n*                                                                     *\n***********************************************************************\n         PARM  N1USERID\n         MVC   ETUSERID+2(7),0(R1) MOVE IN ID\n         SR    R2,R2\n         LA    R3,7                MAX TO LOOP\nN1$ULLP  CLI   0(R1),C' '          IS IT BLANK\n         BE    N1$ULEP\n         LA    R2,1(,R2)           INCREMENT COUNT\n         LA    R1,1(,R1)           INCREMENT POINTER\n         BCT   R3,N1$ULLP\nN1$ULEP  STH   R2,ETUSERID         SAVE LENGTH OF USERID\n         LA    R14,N1$UM24         GET ADDR FOR 24 BIT MODE\n         BSM   0,R14               GO AND SET MODE\nN1$UM24  DS    0H\n         EJECT\n*********************************************************************\n*\n*       BUILD LOG WTO MESSAGE AND ISSUE IT.\n*\n*********************************************************************\n         L     R1,=A(LOGWTO)       POINT AT MESSAGE\n         MVC   N1@MSGAR(LLOGWTO),0(R1)\n         MVC   N1@MSGAR+4(7),ETUSERID+2 MOVE USERID TO LOG WTO MESSAGE\n         MVC   N1@MSGAR+23(8),ETTERMID+2 MOVE TERMID TO LOG WTO MESSAGE\n         MVC   N1@MSGAR+41(4),ETASIDE MOVE ASID TO LOG WTO MESSAGE\n         WTO   MF=(E,N1@MSGAR)     ISSUE LOG WTO MESSAGE\n         EJECT\n***********************************************************************\n*                                                                     *\n*       CHECKS TO SEE IF THE USERID IS IN THE TABLE OF USERIDS TO     *\n*       NEVER BE DENIED LOGON.  IF SO, BYPASS DIVISIONAL QUOTA        *\n*       CHECKING.                                                     *\n*                                                                     *\n***********************************************************************\n         L     R14,=A(USIDTABL)    GET ADDRESS OF USERID TABLE\nN1$UNUSR DS    0H                  CHECK NEXT USERID IN TABLE\n         CLI   0(R14),X'FF'        IS THIS END OF USERID TABLE\n         BE    N1$UCHKD            YES - GO CHECK DIVISION\n         CLC   0(7,R14),ETUSERID+2 NO - IS THIS MATCHING USERID\n         BE    N1$UUSOK            YES - NEVER DENY LOGON\n         LA    R14,7(,R14)         NO - BUMP TO NEXT USERID\n         B     N1$UNUSR            AND LOOP\n         EJECT\n***********************************************************************\n*                                                                     *\n*       CHECKS THE NUMBER OF USERS ALLOWED TO BE LOGGED ON FOR THIS   *\n*       USER'S DIVISION.  IF ZERO, THE LOGON IS DENIED.  OTHERWISE,   *\n*       THE ASCBS ARE SEARCHED TO DETERMINE IF THE DIVISIONAL QUOTA   *\n*       IS CURRENTLY LOGGED ON.  IF SO, THE LOGON IS DENIED.          *\n*                                                                     *\n***********************************************************************\nN1$UCHKD DS    0H                  CHECK FOR DIVISION QUOTA LOGGED ON\n         L     R14,=A(DIVTABLE)    GET ADDRESS OF DIVISION TABLE\nN1$UNDIV DS    0H                  CHECK NEXT DIVISION IN TABLE\n         CLI   0(R14),X'FF'        IS THIS END OF DIVISION TABLE\n         BE    N1$UUSOK            YES - ALLOW LOGON\n         CLC   0(1,R14),ETUSERID+2 NO - IS THIS MATCHING DIVISION\n         BE    N1$UCHKC            YES - GO CHECK DIVISION COUNT\n         LA    R14,2(,R14)         NO - BUMP TO NEXT DIVISION ENTRY\n         B     N1$UNDIV            AND LOOP\nN1$UCHKC DS    0H                  CHECK NUMBER LOGGED ON FOR THIS DIV.\n         SLR   R4,R4               CLEAR R4 FOR ICM OF COUNT\n         ICM   R4,B'0001',1(R14)   GET COUNT FOR THIS DIVISION\n         BZ    N1$UDIVQ            IF ZERO - GO GIVE MESSAGE\n         L     R14,CVTPTR          IF NON-ZERO - GET ADDRESS OF CVT\n         USING CVTMAP,R14          GET CVT ADDRESSABILITY\n         L     R14,CVTASVT         GET ADDRESS OF ASVT\n         DROP  R14                 DROP CVT ADDRESSABILITY\n         LA    R14,ASVTENTY-ASVT-4(R14) GET ADDR OF 1ST ASVT ENTRY - 4\nN1$UNASC DS    0H                  CHECK NEXT ASCB FOR THIS DIV. USER\n         LA    R14,4(,R14)         GET ADDRESS OF NEXT ASVT ENTRY\n         L     R1,0(,R14)          GET ADDRESS OF ASCB\n         LA    R1,0(,R1)           CLEAR HIGH ORDER BYTE\n         LTR   R1,R1               IS THIS END OF ASVT\n         BZ    N1$UUSOK            YES - ALLOW LOGON\n         TM    0(R14),KBIT0        NO - IS ASCB AVAILABLE\n         BO    N1$UNASC            NO - GO TO NEXT ASCB\n         CLC   =C'ASCB',ASCBASCB-ASCB(R1) YES - IS ACRONYM PRESENT\n         BNE   N1$UNASC            NO - GO TO NEXT ASCB\n         CLC   =F'0',ASCBTSB-ASCB(R1) YES - IS TSB ADDRESS ZERO\n         BE    N1$UNASC            YES - GO TO NEXT ASCB\n         L     R1,ASCBJBNS-ASCB(R1) NO - GET ADDRESS OF JOBNAME\n         CLC   0(1,R1),ETUSERID+2  IS DIVISION THE SAME\n         BNE   N1$UNASC            NO - GO TO NEXT ASCB\n         BCT   R4,N1$UNASC         YES - GO TO NEXT ASCB IF COUNT LEFT\n         B     N1$UDIVQ            IF NOT - GO GIVE MESSAGE\nN1$UUSOK DS    0H                  USER PASSED DIVISIONAL QUOTA TEST\n         EJECT\n*******************************************************************\n*\n*       RESERVE UADS PDS DIRECTORY\n*\n*******************************************************************\n         BAS   R14,VRESERVE        RESERVE UADS DIRECTORY\n         EJECT\n***********************************************************************\n*                                                                     *\n*       CHECKS TO SEE IF THE USERID IS FOUND IN SYS1.UADS. IF NOT,    *\n*       THE LOGON IS DENIED.\n*                                                                     *\n***********************************************************************\n         MVC   ETMEMBER,=CL8' '    CLEAR\n         MVC   ETMEMBER(7),ETUSERID+2 COPY USERID TO MEMBER0 NAME\n         LH    R15,ETUSERID        GET LENGTH OF USERID\n         LA    R3,ETMEMBER(R15)    POINT TO BYTE AFTER USERID\n         MVI   0(R3),C'0'          ADD SUFFIX (WILL USE R3 LATER\n*                                              NEAR LABEL N1$U1ST)\n         XC    N1@BLDL(8*N1@BLNSZ+4),N1@BLDL CLEAR LIST\n         MVI   N1@BLFF+1,1         SET FF IN BLDL LIST\n         MVI   N1@BLLL+1,12        SET LL IN BLDL LIST\n         MVC   N1@BLNM,ETMEMBER    MOVE MEMBER0 NAME TO BLDL LIST\n         BLDL  ETUADS,N1@BLDL      SEARCH DIRECTORY FOR MEMBER0\n         LTR   R15,R15             WAS MEMBER FOUND\n         BNZ   N1$UNFND            NO - GO TO ERROR ROUTINE\n         EJECT\n*********************************************************************\n*\n*       IF INFO BLOCK IS AVAILABLE, GET TTR.  IF NOT, CREATE ONE\n*       PADDED WITH BLANKS.\n*\n*********************************************************************\n         MVC   ETINFOID,=CL8' '    CLEAR\n         MVC   ETINFOID(7),ETUSERID+2 MOVE IN USERID AND BLANKS\n         LH    R1,ETUSERID         GET LENGTH\n         LA    R1,ETINFOID(R1)     POINT AT FIRST BLANK\n         MVI   0(R1),C'$'          SET TRAILING CHAR\n         MVC   N1@ENQLT,ENQLIST2   COPY ENQ LIST\n         MVI   N1@ENQLT+1,52       PUT LENGTH OF RNAME IN ENQ LIST\n         MVC   N1@RNAME(44),ETJFCB MOVE DSNAME TO RNAME\n         MVC   N1@RNAME+44(8),ETINFOID APPEND INFO BLOCK NAME TO DSN\n         LA    R15,QNAME3          GET ADDRESS OF QNAME (SPFEDIT )\n         ST    R15,N1@ENQLT+4      PUT IN ENQ LIST\n         LA    R15,N1@RNAME        GET ADDR OF RNAME (DSN+USERID$)\n         ST    R15,N1@ENQLT+8      PUT IN ENQ LIST\n         LA    R1,N1@ENQLT         GET ADDRESS OF ENQ LIST\n         ENQ   MF=(E,(1))          ENQ LIKE ISPF DOES\n         OI    ETBITS2,ET2SPFEI    INDICATE INFO BLOCK ENQ'D ON\n         MVC   N1@BLNM(8),ETINFOID MOVE USERID TO BLDL LIST\n         BLDL  ETUADS,N1@BLDL      SEARCH DIRECTORY FOR USERID$\n         LTR   R15,R15             WAS USERID$ FOUND\n         BNZ   N1$UCRET            NO - GO CREATE INFO BLOCK\n         MVC   ETTTRINF,N1@BLTTR   YES - SAVE INFO TTR FOR LATER\n         POINT ETUADS,ETTTRINF     POINT AT INFO BLOCK\n         L     R2,ETAINFO          GET ADDRESS OF INFO BLK BUFFER\n         READ  ETDECB,SF,ETUADS,(R2),'S',MF=E\n         CHECK ETDECB\n         LH    R1,ETUADS+DCBBLKSI-IHADCB GET BLKSIZE DESIRED\n         L     R15,ETDECB+16       GET IOB ADDRESS\n         SH    R1,14(,R15)         GET TRUE BLKSIZE\n         ST    R1,ETLINFO\n         B     N1$URED0            GO READ MEMBER0\n         EJECT\n*********************************************************************\n*\n*       CREATE INFO BLOCK.\n*\n*********************************************************************\nN1$UCRET DS    0H                  CREATE INFO BLOCK\n         L     R4,ETAINFO          GET ADDRESS OF INFO BLOCK\n         LR    R0,R4               GET ADDRESS OF INFO BLOCK\n         LH    R1,ETUADS+DCBBLKSI-IHADCB GET LENGTH OF INFO BLOCK\n         L     R6,=A(INFOMODL)     GET ADDRESS OF MODEL\n         L     R7,=A(LINFMODL)     GET ADDR OF FILL AND LENGTH\n         L     R7,0(,R7)           GET FILL CHARACTER AND LENGTH\n         MVCL  R0,R6               CREATE MODEL INFO BLOCK\n         CLOSE MF=(E,ETOPENL)      CLOSE UADS FOR UPDATE\n         MVC   ETOPENL(1),OPENOUT CHANGE OPEN LIST\n         OPEN  MF=(E,ETOPENL)      OPEN UADS FOR OUTPUT\n         WRITE ETDECB,SF,ETUADS,(R4),'S',MF=E WRITE INFO BLOCK\n         CHECK ETDECB              WAIT ON I/O\n         NOTE  ETUADS              GET TTR FOR INFO BLOCK\n         ST    R1,ETTTRINF         SAVE FOR LATER\n         MVC   N1@BLNM(8),ETINFOID MOVE USERID TO BLDL LIST\n         XC    N1@BLTTR,N1@BLTTR   ZERO TTR FIELD FOR ADD\n         STOW  ETUADS,N1@BLNM,A    UPDATE DIRECTORY\n         LR    R4,R15              PROTECT RETURN CODE FROM STOW\n         CLOSE MF=(E,ETOPENL)      CLOSE UADS FOR OUTPUT\n         LTR   R15,R4              WAS STOW SUCCESSFUL\n         BNZ   N1$UBSTO            NO - GO TO ERROR ROUTINE\n         MVC   ETOPENL(1),OPENUPDT YES - CHANGE OPEN LIST\n         OPEN  MF=(E,ETOPENL)      OPEN UADS FOR UPDATE\nN1$URED0 DS    0H\n         EJECT\n********************************************************************\n*\n*       FIND TTRS OF TERMINAL BLOCK AND ASKBACK BLOCK\n*\n********************************************************************\n         XC    ETTTRTRM,ETTTRTRM   CLEAR TTR\n         XC    N1@BLNM(8*N1@BLNSZ),N1@BLNM CLEAR ENTRIES\n         STM   R2,R3,N1@WORK1      SAVE REGISTERS\n         LA    R0,7                MAX ENTRIES TO GENERATE\n         LA    R1,ETTERMID+2       POINT AT TERMINAL ID\n         MVC   N1@BLNM(8),=C'#@@@@@@@' GLOBAL DEFAULT NAME\n         LA    R2,N1@BLNM+1        FIRST CHAR TO MODIFY\n         LA    R3,N1@BLNM          START OF EACH ENTRY\nN1$UTR1  MVC   N1@BLNSZ(8,R3),0(R3) PROPAGATE NAME\n         LA    R2,N1@BLNSZ(R2)     POINT TO NEW ENTRY\n         LA    R3,N1@BLNSZ(R3)     POINT TO NEW ENTRY\n         MVC   0(1,R2),0(R1)       MOVE IN ID CHAR\n         CLI   1(R1),C' '          IS THIS LAST CHAR\n         BE    N1$UTR3             YES - SO BLANK REST\n         LA    R2,1(R2)            POINT TO NEXT CHAR IN NAME\n         LA    R1,1(R1)            POINT TO NEXT CHAR IN TERM\n         BCT   R0,N1$UTR1          LOOP FOR NEXT CHAR\n         B     N1$UTR4             ALL DONE - FULL NAME\nN1$UTR2  MVI   0(R2),C' '          SET NEXT CHAR TO BLANK\nN1$UTR3  LA    R2,1(R2)            POINT TO NEXT CHAR\n         BCT   R0,N1$UTR2          LOOP TILL DONE\nN1$UTR4  LA    R1,N1@BLNM          GET ORIG START\n         SR    R3,R1               GET OFFSET\n         SR    R2,R2               CLEAR REG\n         D     R2,=A(N1@BLNSZ)     GET NUMBER OF ENTRIES\n         LA    R3,1(R3)            INCREASE BY ONE\n         STH   R3,N1@BLFF          SAVE NUMBER OF ENTRIES\n         LM    R2,R3,N1@WORK1      RESTORE REGISTERS\n         BLDL  ETUADS,N1@BLDL      SEARCH DIRECTORY FOR #TERMID\n         CH    R15,=H'8'           ANY BAD ERRORS\n         BNL   N1$UTR99            YES - SKIP\n         LH    R1,N1@BLFF          GET NUMBER OF ENTRIES\n         LR    R0,R1               SAVE COUNT\n         BCTR  R1,0                LESS ONE\n         MH    R1,=AL2(N1@BLNSZ)   TIMES ENTRY SIZE\n         LA    R1,N1@BLTTR(R1)     POINT AT LAST TTR\nN1$UTR8  CLI   2(R1),0             ANY TTR\n         BNE   N1$UTR9             YES - SO USE IT\n         SH    R1,=AL2(N1@BLNSZ)   BACK UP\n         BCT   R0,N1$UTR8\n         B     N1$UTR99            NO ENTRIES PRESENT SO SKIP\nN1$UTR9  MVC   ETTTRTRM,0(R1)      SAVE TERMINAL BLOCK TTR\n         POINT ETUADS,ETTTRTRM     POINT AT INFO BLOCK\n         L     R2,ETATERM          GET ADDRESS OF INFO BLK BUFFER\n         READ  ETDECB,SF,ETUADS,(R2),'S',MF=E\n         CHECK ETDECB\n         LH    R1,ETUADS+DCBBLKSI-IHADCB GET BLKSIZE DESIRED\n         L     R15,ETDECB+16       GET IOB ADDRESS\n         SH    R1,14(,R15)         GET TRUE BLKSIZE\n         ST    R1,ETLTERM\nN1$UTR99 MVC   N1@BLFF(2),=H'1'    SET NUMBER OF ENTRIES\n         XC    ETTTRASK,ETTTRASK   CLEAR TTR\n         MVC   N1@BLNM,=CL8'ASKBACK' SET NAME\n         BLDL  ETUADS,N1@BLDL      SEARCH DIRECTORY FOR ASKBASK\n         LTR   R15,R15             WAS IT FOUND\n         BNZ   *+10                NO - SKIP\n         MVC   ETTTRASK,N1@BLTTR   SAVE ASK BACK BLOCK TTR\n         POINT ETUADS,ETTTRASK     POINT AT INFO BLOCK\n         L     R2,ETAASKB          GET ADDRESS OF INFO BLK BUFFER\n         READ  ETDECB,SF,ETUADS,(R2),'S',MF=E\n         CHECK ETDECB\n         LH    R1,ETUADS+DCBBLKSI-IHADCB GET BLKSIZE DESIRED\n         L     R15,ETDECB+16       GET IOB ADDRESS\n         SH    R1,14(,R15)         GET TRUE BLKSIZE\n         ST    R1,ETLASKB\n         EJECT\n*******************************************************************\n*\n*       DEQ UADS PDS DIRECTORY NOW SO PROMPT WONT HANG UP OTHER\n*       USERS TRYING TO LOGON\n*\n*******************************************************************\n         BAS   R14,VDEQ            DEQ UADS DIRECTORY\n         EJECT\n*******************************************************************\n*\n*       MERGE ANY INFO IN BLOCK WITH DATA FROM LOGON COMMAND\n*              (FORWARD MERGE)\n*\n*******************************************************************\n         INFO  MADDRESS\n         LA    R3,ETADDRS\n         BAL   R14,N1$UMV90\n         INFO  MPROGNAM\n         LA    R3,ETPRGNM\n         BAL   R14,N1$UMV90\n         INFO  MDEFTIME\n         LA    R3,ETCPTIM\n         BAL   R14,N1$UMV90\n         INFO  MROOM\n         LA    R3,ETROOM\n         BAL   R14,N1$UMV90\n         INFO  MFORMS\n         LA    R3,ETFORM\n         BAL   R14,N1$UMV90\n         INFO  MLINECT\n         LA    R3,ETLINCT\n         BAL   R14,N1$UMV90\n         INFO  MNAME\n         LA    R3,ETNAME\n         BAL   R14,N1$UMV90\n         INFO  MPHONE\n         LA    R3,ETPHONE\n         BAL   R14,N1$UMV90\n         B     N1$UMXT\n         SPACE 2\n*\n**       SUBROUTINE TO MERGE DATA TO EXTEX\n*\nN1$UMV90 OC    0(2,R3),0(R3)       ANY LENGTH\n         BNZR  R14                 YES, SO HAS DATA ALREADY\n         CLI   9(R1),C' '          ANY INFO IN BLOCK\n         BER   R14                 NO, SO LEAVE ALONE\n         LA    R15,9(,R1)          SET START ADDRESS\n         LA    R1,71(R1)           POINT TO LAST CHARACTER\nN1$UMV95 CLI   0(R1),C' '          STILL A BLANK\n         BNE   N1$UMV97            NO, SO HAVE END OF STRING\n         BCT   R1,N1$UMV95         YES, SO LOOP TILL END\n         DC    H'0'                CANT HAPPEN (HOHOHOHO)\nN1$UMV97 LA    R1,1(R1)            REPOINT TO BLANK\n         SR    R1,R15              GET LENGTH\n         STH   R1,0(,R3)           SAVE LENGTH\n         BCTR  R1,0                GET MACHINE LENGTH\n         EX    R1,N1$UMV99         MOVE IN DATA\n         BR    R14\nN1$UMV99 MVC   2(0,R3),0(R15)      ** EXECUTED **\n         SPACE 3\nN1$UMXT  DS    0H\n         EJECT\n*******************************************************************\n*\n*       ALL DONE SO RETURN TO CALLER\n*\n*******************************************************************\n         SR    R15,R15\nN1$UEXIT DS    0H\n         SUBEXIT ,                 RETURN\n         EJECT\n***********************************************************************\n*                                                                     *\n*       INFORM USER THAT USERID WAS NOT IN SYS1.UADS.  IF PROMPT\n*       LIMIT NOT EXCEEDED, PROMPT FOR NEW USERID.  ELSE DENY LOGON.\n*                                                                     *\n***********************************************************************\nN1$UNFND DS    0H                  USERID NOT IN SYS1.UADS\n         BAS   R14,VDEQ            DEQ UADS PDS DIRECTORY\n         OI    ETBITS1,ET1DENY     DENY LOGON\n         LA    R0,L'NOTFOUND       GET LENGTH OF MESSAGE\n         L     R1,=A(NOTFOUND)     POINT TO MESSAGE\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         B     N1$UQUIT\n         EJECT\n***********************************************************************\n*                                                                     *\n*       INFORM USER THAT DIVISIONAL QUOTA CURRENTLY LOGGED ON, SET BIT*\n*       TO DENY LOGON, AND SET RETURN CODE FOR IKJPARS TO STOP.       *\n*                                                                     *\n***********************************************************************\nN1$UDIVQ DS    0H                  DIVISIONAL QUOTA CURRENTLY LOGGED ON\n         OI    ETBITS1,ET1DENY     DENY LOGON\n         LA    R0,L'DIVQUOTA       GET LENGTH OF MESSAGE\n         L     R1,=A(DIVQUOTA)     POINT TO MESSAGE\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         B     N1$UQUIT            QUIT\n         EJECT\n*********************************************************************\n*\n*       INFORM USER THAT STOW RETURN CODE WAS NOT ZERO AND DENY\n*       LOGON.\n*\n*********************************************************************\nN1$UBSTO DS    0H                  NON-ZERO RETURN CODE FROM STOW\n         BAS   R14,VDEQ            DEQ UADS PDS DIRECTORY\n         L     R1,=A(STOWMSG)\n         MVC   N1@MSGAR(L'STOWMSG),0(R1) COPY MESSAGE\n         CVD   R15,N1@WORK1        CONVERT TO DECIMAL\n         OI    N1@WORK1+7,X'0F'    FIX SIGN\n         UNPK  N1@WORK1(5),N1@WORK1+5(3) UNPACK\n         MVC   N1@MSGAR+23(4),N1@WORK1+1 MOVE INTO MESSAGE\n         LA    R0,L'STOWMSG        GET LENGTH OF MESSAGE\n         LA    R1,N1@MSGAR         POINT TO MESSAGE\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         OI    ETBITS1,ET1DENY     DENY LOGON\n         B     N1$UQUIT            EXIT\n         EJECT\n*********************************************************************\n*\n*       TERMINATE PARSE.\n*\n*********************************************************************\nN1$UQUIT DS    0H\n         LA    R15,12              TERMINATE PARSE\n         B     N1$UEXIT            AND EXIT\n         EJECT\n*******************************************************************\n*\n*       RESERVE ON QNAME SPFDSN RNAME DSN, AND\n*       QNAME SYSIKJUA RNAME OPENUADS, TO INHIBIT UPDATES TO THE\n*       UADS PDS DIRECTORY DURING BLDL AND FIND PROCESSING.\n*\n*******************************************************************\nVRESERVE DS    0H\n         SUBENTRY ,\n         MVC   N1@ENQLT,RESLIST    COPY RESERVE LIST\n         MVI   N1@ENQLT+1,44       PUT LENGTH OF RNAME IN RES LIST\n         MVC   N1@RNAME(44),ETJFCB MOVE DSNAME TO RNAME\n         LA    R15,QNAME2          GET ADDRESS OF QNAME (SPFDSN  )\n         ST    R15,N1@ENQLT+4      PUT IN RESERVE LIST\n         LA    R15,N1@RNAME        GET ADDR OF RNAME (DSN)\n         ST    R15,N1@ENQLT+8      PUT IN RESERVE LIST\n         LA    R15,ETAUCB          GET ADDRESS OF UCB ADDRESS\n         ST    R15,N1@ENQLT+12     PUT IN RESERVE LIST\n         LA    R1,N1@ENQLT         GET ADDRESS OF RESERVE LIST\n         RESERVE MF=(E,(1))        RESERVE LIKE ISPF DOES\n         OI    ETBITS2,ET2SPFRS    INDICATE SPFDSN/DSN RESERVED\n         MVC   N1@ENQLT,ENQLIST3   COPY ENQ LIST\n         MVI   N1@ENQLT+1,8        PUT LENGTH OF RNAME IN ENQ LIST\n         LA    R15,QNAME           GET ADDRESS OF QNAME (SYSIKJUA)\n         ST    R15,N1@ENQLT+4      PUT IN ENQ LIST\n         LA    R15,RNAME           GET ADDR OF RNAME (OPENUADS)\n         ST    R15,N1@ENQLT+8      PUT IN ENQ LIST\n         LA    R1,N1@ENQLT         GET ADDRESS OF ENQ LIST\n         ENQ   MF=(E,(1))          ENQ LIKE TSO ACCOUNT DOES\n         OI    ETBITS2,ET2UADRS    INDICATE SYSIKJUA/OPENUADS RESV\n         SUBEXIT ,\n         SPACE 1\nVDEQ     DS    0H\n         SUBENTRY ,\n         TM    ETBITS2,ET2UADRS    WAS SYSIFJUA/OPENUADS ENQ'D ON\n         BZ    VDEQUADS            NO - CONTINUE\n         MVC   N1@ENQLT,ENQLIST3   YES - COPY ENQ LIST\n         MVI   N1@ENQLT+1,8        PUT LENGTH OF RNAME IN ENQ LIST\n         LA    R15,QNAME           GET ADDRESS OF QNAME (SYSIKJUA)\n         ST    R15,N1@ENQLT+4      PUT IN ENQ LIST\n         LA    R15,RNAME           GET ADDR OF RNAME (OPENUADS)\n         ST    R15,N1@ENQLT+8      PUT IN ENQ LIST\n         LA    R1,N1@ENQLT         GET ADDRESS OF ENQ LIST\n         DEQ   MF=(E,(1))          DEQ LIKE TSO ACCOUNT DOES\n         NI    ETBITS2,255-ET2UADRS TURN OFF SYSIKJUA/OPENUADS RESV\nVDEQUADS DS    0H\n         TM    ETBITS2,ET2SPFRS    WAS SPFDSN/DSN ENQ'D ON\n         BZ    VDEQSPF             NO - CONTINUE\n         MVC   N1@ENQLT,RESLIST    YES - COPY RESERVE LIST\n         MVI   N1@ENQLT+1,44       PUT LENGTH OF RNAME IN RES LIST\n         MVC   N1@RNAME(44),ETJFCB MOVE DSNAME TO RNAME\n         LA    R15,QNAME2          GET ADDRESS OF QNAME (SPFDSN  )\n         ST    R15,N1@ENQLT+4      PUT IN RESERVE LIST\n         LA    R15,N1@RNAME        GET ADDR OF RNAME (DSN)\n         ST    R15,N1@ENQLT+8      PUT IN RESERVE LIST\n         LA    R15,ETAUCB          GET ADDRESS OF UCB ADDRESS\n         ST    R15,N1@ENQLT+12     PUT IN RESERVE LIST\n         LA    R1,N1@ENQLT         GET ADDRESS OF RESERVE LIST\n         DEQ   MF=(E,(1))          DEQ LIKE ISPF DOES\n         NI    ETBITS2,255-ET2SPFRS TURN OFF SPFDSN/DSN RESERVED\nVDEQSPF  DS    0H\n         SUBEXIT ,\n         TITLE 'IKJEFLN1 - UPDATE SCREEN USER FIELDS'\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*    N1$SCRN                                                          *\n*                                                                     *\n* FUNCTION -                                                          *\n*    FILL IN THE ITEMS IN THE USER FIELDS ON THE SCREEN.              *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*                                                                     *\n* ENTRY POINTS -                                                      *\n*    N1$SCRN                                                          *\n*                                                                     *\n* EXTERNAL REFERENCES -                                               *\n*    NONE                                                             *\n*                                                                     *\n* INPUT -                                                             *\n*    NONE                                                             *\n*                                                                     *\n* OUTPUT -                                                            *\n*    NONE                                                             *\n*                                                                     *\n* MESSAGES -                                                          *\n*    NONE                                                             *\n*                                                                     *\n* COMMENTS -                                                          *\n*    NONE                                                             *\n*                                                                     *\n***********************************************************************\nN1$SCRN  DS    0H\n         SUBENTRY\n         PARM  N1SWITCH\n         OI    2(R1),N1SW2URF      MARK TO REFRESH THE FIELDS\n         PARM  N1UFLDS             GET USER FIELDS\n         CLC   0(4,R15),=F'2'      ANY VALUES\n         BNE   N1$S10\n         LR    R7,R1               PUT IN SAFE REGS\n*  SET ADDRESS VALUE\n         L     R1,0(,R7)           GET ADDRESS OF FIRST FIELD\n         LA    R2,ETADDRS\n         BAL   R14,N1$SMOV\n*  SET PROGRAMMER NAME VALUE\n         L     R1,1*4(,R7)         GET ADDRESS OF FIELD\n         LA    R2,ETPRGNM\n         BAL   R14,N1$SMOV\n*  SET CPU TIME VALUE\n         L     R1,2*4(,R7)         GET ADDRESS OF FIELD\n         LA    R2,ETCPTIM\n         BAL   R14,N1$SMOV\n*  SET ROOM VALUE\n         L     R1,3*4(,R7)         GET ADDRESS OF FIELD\n         LA    R2,ETROOM\n         BAL   R14,N1$SMOV\n*  SET FORM VALUE\n         L     R1,4*4(,R7)         GET ADDRESS OF FIELD\n         LA    R2,ETFORM\n         BAL   R14,N1$SMOV\n*  SET MESSAGE CLASS VALUE\n         L     R1,5*4(,R7)         GET ADDRESS OF FIELD\n         LA    R2,ETMSGC\n         BAL   R14,N1$SMOV\n*  SET MESSAGE LEVEL VALUE\n         L     R1,6*4(,R7)         GET ADDRESS OF FIELD\n         LA    R2,ETMSGL\n         BAL   R14,N1$SMOV\n*  SET COPIES VALUE\n         L     R1,7*4(,R7)         GET ADDRESS OF FIELD\n         LA    R2,ETCOPY\n         BAL   R14,N1$SMOV\n*  SET LINE COUNT VALUE\n         L     R1,8*4(,R7)         GET ADDRESS OF FIELD\n         LA    R2,ETLINCT\n         BAL   R14,N1$SMOV\n*  SET JCL FLAG VALUE\n         L     R1,9*4(,R7)         GET ADDRESS OF FIELD\n         MVC   0(9,R1),=AL1(0,0,0,1,0,0,0,1,0) SET KEY,LEN, VALUE\n         TM    ETBITS3,ET3JCL      IS JCL SET\n         BZ    *+8                 NO, SKIP\n         MVI   8(R1),C'S'\n*  SET LISTINFO FLAG VALUE\n         L     R1,10*4(,R7)        GET ADDRESS OF FIELD\n         MVC   0(9,R1),=AL1(0,0,0,1,0,0,0,1,0) SET KEY,LEN, VALUE\n         TM    ETBITS3,ET3LSTIN    IS JCL SET\n         BZ    *+8                 NO, SKIP\n         MVI   8(R1),C'S'\n         SPACE 3\n         TM    ETBITS3,ET3DEBUG    DEBUG IN PROGRESS??\n         BZ    N1$S10              NOPE, SKIP CODE\n         WTO   'IKJEFLN1: SET SCREEN USER FIELDS',ROUTCDE=(2)\nN1$S10   DS    0H\n         EJECT\n***********************************************************************\n*                                                                     *\n*        RETURN TO MAINLINE                                           *\n*                                                                     *\n***********************************************************************\n         SR    R15,R15             CLEAR RETURN CODE\nN1$SEXIT DS    0H\n         SUBEXIT\n         EJECT\n***********************************************************************\n*                                                                     *\n*        MOVE AN ITEM FROM THE SAVED AREA TO THE SCREEN               *\n*              R1 => KEY,LENGTH,DATA OF SCREEN ITEM                   *\n*              R2 => LENGTH(2),DATA TO MOVE                           *\n*              R14 = RETURN ADDRESS                                   *\n*                                                                     *\n***********************************************************************\nN1$SMOV  DS    0H\n         OC    0(2,R2),0(R2)       ANY LENGTH\n         BZR   R14                 IF NOT THEN EXIT\n         LTR   R1,R1               ANY VALUE??\n         BZ    N1$S10              ESCAPE MODULE IF NOT\n         MVC   0(4,R1),=F'1'       SET KEY TO VALID\n         LH    R15,0(,R2)          GET LENGTH\n         ST    R15,4(,R1)          SAVE LENGTH\n         BCTR  R15,0               GET MACHINE LENGTH\n         EX    R15,N1$SM99         MOVE DATA\n         BR    R14\nN1$SM99  MVC   8(0,R1),2(R2)       ** EXECUTED **\n         TITLE 'IKJEFLN1 - GET TERMINAL RESTRICTION ROUTINE'\n********************************************************************\n*\n* ROUTINE NAME -\n*    N1$GTERM\n*\n* FUNCTION -\n*    GET TERMINAL RESTRICTION BLOCK AND PARSE IT.\n*\n* OPERATION -\n*    1) BLANK OUT BOTH THE TERMINAL RESTRICTION CORE BLOCK AND\n*       ASKBACK CORE BLOCK.\n*    2) IF TERMINAL RESTRICTION MEMBER EXISTS, READ IT IN.\n*    3) IF ASKBACK MEMBER EXISTS, READ IT IN.\n*    4) PARSE DATA IN TERMINAL RESTRICTION BLOCK.\n*    5) PARSE DATA IN ASKBACK BLOCK.\n*    6) RETURN TO THE MAINLINE.\n*\n* ENTRY POINTS -\n*    N1$GTERM\n*\n* EXTERNAL REFERENCES -\n*    NONE\n*\n* INPUT -\n*    ETTTRASK\n*    ETTTRTRM\n*\n* OUTPUT -\n*    REGISTER 15 CONTAINS THE RETURN CODE FOR THE MAINLINE.  THIS\n*    WILL BE AS FOLLOWS -\n*       |------|------------------------|--------------------------|\n*       |RETURN|                        |                          |\n*       |CODE  |REASON                  |ACTION                    |\n*       |------|------------------------|--------------------------|\n*       |   0  |NO ERRORS ENCOUNTERED.  |CONTINUE WITH LOGON.      |\n*       |------|------------------------|--------------------------|\n*       |   4  |PARSE FAILED.           |DENY LOGON.               |\n*       |------|------------------------|--------------------------|\n*\n* MESSAGES -\n*    LOGONXIT PARSE FAILED FOR TERMINAL BLOCK XXXXXXXX, RC=XX .\n*    LOGONXIT PARSE FAILED FOR ASKBACK BLOCK, RC=XX .\n*\n********************************************************************\n         EJECT\nN1$GTERM DS    0H\n         SUBENTRY ,\n         EJECT\n********************************************************************\n*\n*        PARSE TERMINAL BLOCK\n*\n********************************************************************\n         MVI   KTERM,0             CLEAR FLAGS\n         L     R4,ETATERM          POINT AT BLOCK\n         BCTR  R4,0                BACK UP\n         BCTR  R4,0                  TO LENGTH\n         KEYVAL (R4),TERMTBL       PARSE IT\n         B     GTTTP(R15)          INTERPRET RETURN CODE\nGTTTP    B     GTTC1               RC=0 SO CONTINUE\n         B     GTTER1              RC=4  VALUE NOT FOUND\n         B     GTTER1              RC=8  KEYWORD NOT FOUND\n         B     GTTER1              RC=12  VALCNT TEST FAILED\n         B     GTTC1               RC=16  NO VALID INPUT SO CONTINUE\n         B     GTTER1              RC=20  TYPE TEST FAILED\n         B     GTTER1              RC=24  LEN TEST FAILED\n         SPACE 3\n*        ERROR ON PARSE TELL USER AND OPERATOR\n         SPACE 1\nGTTER1   STC   R15,N1@WORK1        SAVE RETURN CODE\n         MVC   N1@MSGAR(LGTMSG1),GTMSG1 MOVE MESSAGE SKELETON\n         UNPK  N1@MSGAR+58(3),N1@WORK1(2) MAKE PRINTABLE\n         MVI   N1@MSGAR+58+2,C' '  CLEAR LAST BYTE\n         L     R1,=A(TRTABLE-240)\n         TR    N1@MSGAR+58(2),0(R1)\n         MVC   N1@MSGAR+45(8),ETTERMID+2 SET TERMINAL ID\n         WTO   MF=(E,N1@MSGAR)     TELL OPERATOR\n         LA    R1,N1@MSGAR+4\n         LH    R0,N1@MSGAR\n         SH    R0,=H'4'            GET TPUT LENGTH\n         TPUT  (1),(0),R           TELL USER\n         LA    R15,4               SET ERROR CODE\n         B     GTTEXIT             QUIT\n         SPACE 3\nGTTC1    DS    0H\n         EJECT\n********************************************************************\n*\n*        PARSE ASKBACK BLOCK\n*\n********************************************************************\n         MVI   KASKB,0             CLEAR FLAGS\n         L     R4,ETAASKB          POINT AT BLOCK\n         BCTR  R4,0                BACK UP\n         BCTR  R4,0                  TO LENGTH\n         KEYVAL (R4),ASKBTBL       PARSE IT\n         B     GTTAB(R15)          INTERPRET RETURN CODE\nGTTAB    B     GTTAB1              RC=0 SO CONTINUE\n         B     GTTER2              RC=4  VALUE NOT FOUND\n         B     GTTER2              RC=8  KEYWORD NOT FOUND\n         B     GTTER2              RC=12  VALCNT TEST FAILED\n         B     GTTAB1              RC=16  NO VALID INPUT SO CONTINUE\n         B     GTTER2              RC=20  TYPE TEST FAILED\n         B     GTTER2              RC=24  LEN TEST FAILED\n         SPACE 3\n*        ERROR ON PARSE TELL USER AND OPERATOR\n         SPACE 1\nGTTER2   STC   R15,N1@WORK1        SAVE RETURN CODE\n         MVC   N1@MSGAR(LGTMSG2),GTMSG2 MOVE MESSAGE SKELETON\n         UNPK  N1@MSGAR+48(3),N1@WORK1(2) MAKE PRINTABLE\n         MVI   N1@MSGAR+48+2,C' '  CLEAR LAST BYTE\n         L     R1,=A(TRTABLE-240)\n         TR    N1@MSGAR+48(2),0(R1)\n         WTO   MF=(E,N1@MSGAR)     TELL OPERATOR\n         LA    R1,N1@MSGAR+4\n         LH    R0,N1@MSGAR\n         SH    R0,=H'4'            GET TPUT LENGTH\n         TPUT  (1),(0),R           TELL USER\n         LA    R15,4               SET ERROR CODE\n         B     GTTEXIT             QUIT\n         SPACE 3\nGTTAB1   DS    0H\n         EJECT\n********************************************************************\n*\n*        RETURN TO MAIN LINE\n*\n********************************************************************\n         SR    R15,R15             SET RETURN CODE OF ZERO\nGTTEXIT  SUBEXIT ,\n         SPACE 3\n*                     1         2         3         4         5\n*               4567890123456789012345678901234567890123456789012345678\nGTMSG1   WTO   'LOGONXIT PARSE FAILED FOR TERMINAL BLOCK XXXXXXXX, RC=XX\n               X .',ROUTCDE=(2,11),MF=L\nLGTMSG1  EQU   *-GTMSG1\nGTMSG2   WTO   'LOGONXIT PARSE FAILED FOR ASKBACK BLOCK, RC=XX .',     X\n               ROUTCDE=(2,11),MF=L\nLGTMSG2  EQU   *-GTMSG2\n         EJECT\n********************************************************************\n*\n*        PARSE TABLES\n*\n********************************************************************\n         PRINT NOGEN\nTERMTBL  KEYT  USER,,KUSER,,(1,9),LEN=(1,10),                          X\n               FIELD1=(,O,KTERM,KTFUSER)\n         KEYT  TIME,,KTIME,NUMERIC,(2,2),LEN=4,                        X\n               FIELD1=(,O,KTERM,KTFTIME)\n         KEYT  ASKBACK,,KASKTM,NUMERIC,(1,1),LEN=(1,4),                X\n               FIELD1=(,O,KTERM,KTFASKB)\n         KEYT  LOG,,,,(0,0),                                           X\n               FIELD1=(,O,KTERM,KTFLOG)\n         KEYT  REJECT,,,,(0,0),                                        X\n               FIELD1=(,O,KTERM,KTFREJCT)\n         KEYT  SMF,,,,(0,0),                                           X\n               FIELD1=(,O,KTERM,KTFSMF)\n         KEYT  CONSOLE,,,,(0,0),END=YES,                               X\n               FIELD1=(,O,KTERM,KTFCNSL)\nASKBTBL  KEYT  S,,KASKBS,,(1,2),LEN=(1,8),                             X\n               FIELD1=(,O,KASKB,KAFS)\n         KEYT  O,,KASKBO,,(1,2),LEN=(1,8),                             X\n               FIELD1=(,O,KASKB,KAFO)\n         KEYT  T,,KASKBT,,(1,2),LEN=(1,8),                             X\n               FIELD1=(,O,KASKB,KAFT)\n         KEYT  E,,KASKBE,,(1,2),LEN=(1,8),                             X\n               FIELD1=(,O,KASKB,KAFE)\n         KEYT  B,,KASKBB,,(1,2),LEN=(1,8),                             X\n               FIELD1=(,O,KASKB,KAFB)\n         KEYT  P,,KASKBP,,(1,2),LEN=(1,8),                             X\n               FIELD1=(,O,KASKB,KAFP)\n         KEYT  C,,KASKBC,,(1,2),LEN=(1,8),                             X\n               FIELD1=(,O,KASKB,KAFC)\n         KEYT  D,,KASKBD,,(1,2),LEN=(1,8),END=YES,                     X\n               FIELD1=(,O,KASKB,KAFD)\n         PRINT GEN\n         TITLE 'IKJEFLN1 - VALIDATE TERMINAL RESTRICTIONS'\n********************************************************************\n*\n* ROUTINE NAME -\n*    N1$VTERM\n*\n* FUNCTION -\n*    VERIFY THE TERMINAL RESTRICTIONS AGAINST IT.\n*\n* OPERATION -\n*    1) IF NO RESTRICTIONS EXIST THEN EXIT.\n*    2) IF REJECT SPECIFIED IN TERMINAL FAIL LOGON.\n*    3) TEST WHETHER USERID IS VALID FOR TERMINAL.\n*    4) TEST WHETHER VALID TIME OF DAY.\n*    5) VALIDATE USERID ALRIGHT FOR ASKBACK TEST.\n*    5A)  IF NECESSARY PERFORM ASKBACK TEST.\n*    6) IF LOG SPECIFIED, THEN LOG SUCCESSFUL LOGON ATTEMPT.\n*    7) RETURN TO THE MAINLINE.\n*\n* ENTRY POINTS -\n*    N1$VTERM\n*\n* EXTERNAL REFERENCES -\n*    NONE\n*\n* INPUT -\n*    NONE\n*\n* OUTPUT -\n*    REGISTER 15 CONTAINS THE RETURN CODE FOR THE MAINLINE.  THIS\n*    WILL BE AS FOLLOWS -\n*       |------|------------------------|--------------------------|\n*       |RETURN|                        |                          |\n*       |CODE  |REASON                  |ACTION                    |\n*       |------|------------------------|--------------------------|\n*       |   0  |NO ERRORS ENCOUNTERED.  |CONTINUE WITH LOGON.      |\n*       |------|------------------------|--------------------------|\n*       |   4  |RESTRICTIONS VIOLATED   |DENY LOGON.               |\n*       |------|------------------------|--------------------------|\n*\n* MESSAGES -\n*     TSO LOGON VIOLATION.  USER=XXXXXXXX, TERM=XXXXXXXX.\n*     TSO ACCESS DENIED DUE TO TERMINAL RESTRICTION\n*     LOGONXIT ENTERED\n*     TSO LOGON SUCCESS.    USER=XXXXXXXX, TERM=XXXXXXXX.\n*\n********************************************************************\n         EJECT\nN1$VTERM DS    0H\n         SUBENTRY ,\n         NI    ETBITS2,255-ET2ASKB MARK NOT IN ASKBACK TEST\n         EJECT\n********************************************************************\n*\n*        SEE IF ANY TERMINAL RESTRICTIONS\n*\n********************************************************************\n         CLI   KTERM,0             ANY RESTRICTION SPECIFIED\n         BE    VERTXIT             NOPE SO SKIP TESTS\n         EJECT\n********************************************************************\n*\n*        SINCE WE HAVE RESTRICTIONS DO THEM ONE AT A TIME\n*        IF RESTRICTION IS MET THEN FAIL LOGON\n*\n*        FIRST TEST VALID USERID LIST\n*\n********************************************************************\n         TM    KTERM,KTFUSER       WAS USERID CHECK REQUESTED\n         BZ    VERTNUR             NOPE\n         SR    R5,R5               CLEAR LOOP REG\n         IC    R5,KUSER            GET NUMBER TO DO\n         LA    R4,KUSER+1          POINT AT FIRST USERID\nVERTLOOP DS    0H                  TOP OF LOOP FOR EACH ID SPECIFIED\n         MVC   N1@MSGAR(10),=CL10' ' BLANK OUT AREA\n         SR    R1,R1               CLEAR REG\n         IC    R1,0(R4)            GET LENGTH OF THIS ONE\n         BCTR  R1,0                GET MACHINE LENGTH\n         EX    R1,VERTMVC1         MOVE IT TO WORK AREA\n         SPACE 3\n*        CHECK AGAINST SUBSTRING ID\n         SPACE 1\n         CH    R1,=H'3'            IS THIS ID LONG ENOUGH FOR SUBSTR\n         BL    VERTNMUS            NOPE SO SKIP\n         LA    R2,N1@MSGAR(R1)     MOVE BACK TO PAREN\n         BCTR  R2,0\n         BCTR  R2,0\n         CLI   0(R2),C'('          IS THIS A PAREN\n         BNE   VERTNMUS            NOPE SO GO NORMAL\n         SH    R1,=H'3'            GET MACHINE LEN OF SUBSTR\n         IC    R3,1(R2)            GET DIGIT\n         N     R3,=A(15)           LEAVE JUST SUBSTR START\n         LA    R3,ETUSERID+1(R3)   GET POINTER TO ID\n         EX    R1,VERTCLC1         SEE IF SUBSTR MATCHES\n         BE    VERTNUR             OK  - USERID MATCHES SUBSTR\n         B     VERTLPND            DID NOT MATCH SO TRY NEXT\n         SPACE 3\n*        CHECK AGAINST NORMAL ID\n         SPACE 1\nVERTNMUS CLC   ETUSERID+2(7),N1@MSGAR   SEE IF LEGAL ID\n         BE    VERTNUR             IF SO THEN END\nVERTLPND IC    R1,0(R4)            GET ORIG LENGTH\n         LA    R4,1(R1,R4)         POINT TO NEXT ID\n         BCT   R5,VERTLOOP         IF NOT THEN TRY NEXT\n         B     VERTFAIL            IF NONE MATCH THEN ERROR\n         SPACE 2\nVERTMVC1 MVC   N1@MSGAR(0),1(R4)   MOVE IN DATA\nVERTCLC1 CLC   0(0,R3),N1@MSGAR    SEE IF SUBSTR MATCHES\n         SPACE 2\nVERTNUR  DS    0H\n         EJECT\n********************************************************************\n*\n*        TEST VALID LOGON TIME OF DAY\n*\n********************************************************************\n         TM    KTERM,KTFTIME       WAS TIME A REQUESTED RESTRICTION\n         BZ    VERTNTM             NOPE\n         UNPK  N1@MSGAR(5),ETLTIME(3) MAKE TIME CHARACTER\n         CLC   N1@MSGAR(4),KTIME+2 CHECK START TIME\n         BL    VERTFAIL            IF LOWER THEN DENY ATTEMPT\n         CLC   N1@MSGAR(4),KTIME+2+4+1 CHECK STOP TIME\n         BH    VERTFAIL            IF HIGHER THEN DENY ATTEMPT\nVERTNTM  DS    0H\n         EJECT\n********************************************************************\n*\n*        TEST IF ASKBACK RESTRICTION IS REQUESTED\n*\n********************************************************************\n         TM    KTERM,KTFASKB       IS ASKBACK NEEDED\n         BZ    VERTNASK            IF NOT THEN ALL DONE - USER PASSE\n         SR    R1,R1               CLEAR REGISTER\n         IC    R1,KASKTM+1         GET LENGTH OF TIME LIMIT\n         BCTR  R1,0                GET MACHINE LENGTH\n         EX    R1,VRTPACK          GET DECIMAL NUMBER\n         CVB   R5,N1@WORK1         GET TIME IN SECONDS\n         SPACE 3\n         MVC   N1@FCHR,ETUSERID+2  SAVE FIRST CHAR OF ID\nVERTASK1 DS    0H\n         SPACE 3\n*        SEE IF CHARACTER IS ONE OF THE VALID PARMS\n         SPACE 3\n         CLI   N1@FCHR,C'S'        IS THIS AN 'S' ID\n         BNE   VERTASK2\n         TM    KASKB,KAFS          WAS 'S' A SPECIFIED PARM\n         BZ    VERTFAIL            NOPE SO FAIL ID\n         LA    R4,KASKBS           POINT AT PARSE STRING\n         B     VRTASKB             GO DO ASKBACK TEST\n         SPACE 3\nVERTASK2 CLI   N1@FCHR,C'O'        IS THIS AN 'O' ID\n         BNE   VERTASK3\n         TM    KASKB,KAFO          WAS 'O' A SPECIFIED PARM\n         BZ    VERTFAIL            NOPE SO FAIL ID\n         LA    R4,KASKBO           POINT AT PARSE STRING\n         B     VRTASKB             GO DO ASKBACK TEST\n         SPACE 3\nVERTASK3 CLI   N1@FCHR,C'T'        IS THIS AN 'T' ID\n         BNE   VERTASK4\n         TM    KASKB,KAFT          WAS 'T' A SPECIFIED PARM\n         BZ    VERTFAIL            NOPE SO FAIL ID\n         LA    R4,KASKBT           POINT AT PARSE STRING\n         B     VRTASKB             GO DO ASKBACK TEST\n         SPACE 3\nVERTASK4 CLI   N1@FCHR,C'E'        IS THIS AN 'E' ID\n         BNE   VERTASK5\n         TM    KASKB,KAFE          WAS 'E' A SPECIFIED PARM\n         BZ    VERTFAIL            NOPE SO FAIL ID\n         LA    R4,KASKBE           POINT AT PARSE STRING\n         B     VRTASKB             GO DO ASKBACK TEST\n         SPACE 3\nVERTASK5 CLI   N1@FCHR,C'B'        IS THIS AN 'B' ID\n         BNE   VERTASK6\n         TM    KASKB,KAFB          WAS 'B' A SPECIFIED PARM\n         BZ    VERTFAIL            NOPE SO FAIL ID\n         LA    R4,KASKBB           POINT AT PARSE STRING\n         B     VRTASKB             GO DO ASKBACK TEST\n         SPACE 3\nVERTASK6 CLI   N1@FCHR,C'D'        IS THIS AN 'D' ID\n         BNE   VERTASK7\n         TM    KASKB,KAFD          WAS 'D' A SPECIFIED PARM\n         BZ    VERTFAIL            NOPE SO FAIL ID\n         LA    R4,KASKBD           POINT AT PARSE STRING\n         B     VRTASKB             GO DO ASKBACK TEST\n         SPACE 3\nVERTASK7 CLI   N1@FCHR,C'C'        IS THIS AN 'C' ID\n         BNE   VERTASK8\n         TM    KASKB,KAFC          WAS 'C' A SPECIFIED PARM\n         BZ    VERTFAIL            NOPE SO FAIL ID\n         LA    R4,KASKBC           POINT AT PARSE STRING\n         B     VRTASKB             GO DO ASKBACK TEST\n         SPACE 3\nVERTASK8 CLI   N1@FCHR,C'P'        IS THIS AN 'P' ID\n         BNE   VERTFAIL\n         TM    KASKB,KAFP          WAS 'P' A SPECIFIED PARM\n         BZ    VERTFAIL            NOPE SO FAIL ID\n         LA    R4,KASKBP           POINT AT PARSE STRING\n         B     VRTASKB             GO DO ASKBACK TEST\n         EJECT\n********************************************************************\n*\n*        DO ASKBACK TEST\n*\n********************************************************************\nVRTASKB  DS    0H\n         OI    ETBITS2,ET2ASKB     MARK IN ASKBACK TEST\n* *#*#   XC    STREQECB,STREQECB   CLEAR ECB\n* *#*#   POST  MTREQECB,(R5)       SET STIMER FOR ASKBACK LIMIT\n* *#*#   WAIT  ECB=STREQECB        WAIT FOR IT TO BE SET\n********************************************************************\n*\n*       CHECKS TO SEE IF TSO USER IS ON A DISPLAY TERMINAL.  IF NOT,\n*       OVERPRINT BEFORE ASKING FOR ASKBACK CODE.  IT THE USER IS\n*       ON A DISPLAY TERMINAL, PROMPT FOR PASSWORD WITH PRINT\n*       BYPASS.\n*\n********************************************************************\n         TM    ETBITS2,ET2DSPLY    WAS THIS A DISPLAY TERMINAL\n         BO    VERTDISP            YES - USE PUTGET\nVERTNDSP DS    0H                  NO - USE TPUT/TGET\n         LA    R0,L'VERTFM3        GET LENGTH OF MESSAGE\n         LA    R1,VERTFM3          GET MESSAGE ADDR\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         LTR   R15,R15             WAS RETURN CODE ZERO\n         BNZ   VERTEXIT            NO - EXIT\n         LA    R0,LOVRPRNT         YES - GET LENGTH OF MESSAGE\n         LA    R1,OVERPRNT         POINT TO MESSAGE\n         ICM   R1,B'1000',=X'01'   SET OPTIONS FOR ASIS\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         LTR   R15,R15             WAS RETURN CODE ZERO\n         BNZ   VERTEXIT            NO - EXIT\n         LA    R0,8                YES - GET LENGTH\n         LA    R1,N1@WORK1         GET ADDRESS OF N1@WORK1\n         ICM   R1,B'1000',=X'80'   SET OPTIONS\n         MVC   N1@WORK1,=CL8' '    BLANK INPUT AREA\n         TGET  (1),(0),R           READ ACCOUNT NUMBER\n         LTR   R15,R15             WAS RETURN CODE ZERO\n         BZ    VERTTGOK            YES - CONTINUE\n         BAL   R14,VERTEXIT        NO - GO TO ERROR ROUTINE\nVERTTGOK DS    0H\n         OC    N1@WORK1,=CL8' '    FORCE TO UPPERCASE\n         B     VERTEXIT            NO - EXIT\nVERTDISP DS    0H                  TERMINAL WAS DISPLAY\n         MVC   N1@PGPB(LPGPB),LPUTGET MOVE LIST TO WORK AREA\n         LA    R1,N1@IOPL          GET ADDRESS OF IOPL\n         USING IOPL,R1             GET ADDRESSABILITY TO IOPL\n         MVC   IOPLUPT,N1@CPPL+CPPLUPT-CPPL COPY UPT ADDRESS TO IOPL\n         MVC   IOPLECT,N1@CPPL+CPPLECT-CPPL COPY ECT ADDRESS TO IOPL\n         LA    R15,N1@ECB          GET ADDRESS OF CP ECB\n         ST    R15,IOPLECB         PUT CP ECB ADDRESS IN IOPL\n         XC    N1@ECB,N1@ECB       ZERO CP ECB\n         LA    R15,N1@PGPB         GET ADDRESS OF PUTGET PARM LIST\n         ST    R15,IOPLIOPB        PUT PUTGET PARM LIST ADDR IN IOPL\n         XC    N1@PGOLD(4),N1@PGOLD ZERO NUMBER OF SEGMENTS\n         MVI   N1@PGOLD+3,1        SET NUMBER TO 1\n         LA    R15,VRTMHDR         GET ADDRESS OF VERFICATION HDR\n         ST    R15,N1@PGOLD+4      PUT ADDRESS IN OLD\n         PUTGET OUTPUT=(N1@PGOLD,,PTBYPS),MF=(E,N1@IOPL)\n         LTR   R15,R15             WAS PUTGET SUCCESSFUL\n         BNZ   VERTEXIT            NO - EXIT\n         LA    R1,N1@PGPB          YES - GET ADDRESS OF P/G PRM LIST\n         USING PGPB,R1             GET ADDRESSABILITY TO PARM LIST\n         L     R1,PGPBIBUF         GET ADDRESS OF PUTGET INPUT BUFF\n         LR    R2,R1               SAVE ADDRESS FOR FREEMAIN\n         CLI   1(R1),44            WAS RESPONSE CORRECT LENGTH\n         BH    VERTFREE            NO - FREE INPUT BUFF & ASK AGAIN\n         LH    R15,0(R1)           GET BUFFER LENGTH\n         SH    R15,=H'4'           GET LENGTH OF RESPONSE\n         BZ    VERTSKIP            SKIP MOVE IF LENGTH ZERO\n         BCTR  R15,0               GET MACHINE LENGTH\n         EX    R15,MVCVERT3        MOVE IN DATA\n         OC    N1@WORK1,=CL8' '    FORCE TO UPPERCASE\nVERTSKIP LR    R1,R2               RESTORE THE BUFFER ADDRESS\n         LA    R0,1                GET THE SUBPOOL NUMBER\n         SLL   R0,24               SHIFT INTO HIGH-ORDER BYTE\n         ICM   R0,B'0011',0(R1)    GET THE LENGTH\n         FREEMAIN R,A=(1),LV=(0)   FREE THE INPUT BUFFER\n         SLR   R15,R15             SET RETURN CODE\n         B     VERTEXIT            AND EXIT\nVERTFREE DS    0H                  FREE INPUT BUFFER AND ASK AGAIN\n         LR    R1,R2               RESTORE THE BUFFER ADDRESS\n         LA    R0,1                GET THE SUBPOOL NUMBER\n         SLL   R0,24               SHIFT INTO HIGH-ORDER BYTE\n         ICM   R0,B'0011',0(R1)    GET THE LENGTH\n         FREEMAIN R,A=(1),LV=(0)   FREE THE INPUT BUFFER\n         B     VERTDISP            AND ASK AGAIN\nVERTEXIT DS    0H\n         L     R0,=A(X'FFFFFF')    NOW TURN OFF STIMER\n* *#*#   XC    STREQECB,STREQECB   CLEAR ECB\n* *#*#   POST  MTREQECB,(0)\n* *#*#   WAIT  ECB=STREQECB        WAIT FOR CANCEL COMPLETE\n         SR    R1,R1               CLEAR REGISTER\n         IC    R1,1(R4)            GET LENGTH OF CODE\n         BCTR  R1,0                GET MACHINE LENGTH\n         EX    R1,VRTCLC           SEE IF EQUAL\n         BNE   VERTFAIL            FAIL IF NO MATCH\n         EJECT\n********************************************************************\n*\n*        ASKBACK TEST PASSED, SET OVERRIDE PROC NAME IF ANY.\n*\n********************************************************************\n         CLI   0(R4),2             IS THERE A PROC NAME ALSO\n         BNE   VERTXIT             IF NOT THEN ALL DONE\n         LA    R2,2+1(R1,R4)       POINT AT LENGTH\n         IC    R1,0(R2)            GET LENGTH\n         STH   R1,ETPROC           SAVE LENGTH\n         BCTR  R1,0                GET MACHINE LENGTH\n         EX    R1,VRTMVC           MOVE IN PROC NAME\n*                                  ALL DONE\nVERTNASK DS    0H\n         EJECT\n********************************************************************\n*\n*        DETERMINE IF REJECT SPECIFIED\n*\n********************************************************************\n         TM    KTERM,KTFREJCT      WAS REJECT SPECIFIED\n         BO    VERTFAIL            YES - FAIL THE SUCKER\n         EJECT\n********************************************************************\n*\n*        WE HAVE A SUCCESSFUL RESTRICTION VALIDATION\n*          LOG IF NECESSARY\n*\n********************************************************************\n         TM    KTERM,KTFLOG        IS SUCCESSFUL LOGGING NECESSARY\n         BZ    VERTNLOG            NO SO SKIP\n         TM    KTERM,KTFSMF        LOG TO SMF\n         BZ    VERTLGCN            NOPE\n         SPACE 3\n*        WRITE VIOLATION TO SMF\n         SPACE 1\nVERTLGCN TM    KTERM,KTFCNSL       LOG TO CONSOLE\n         BZ    VERTNLOG            NOPE\n         SPACE 3\n*        WRITE VIOLATION TO CONSOLE\n         SPACE 1\n         MVC   N1@MSGAR(VERTFM4L),VERTFM4 MOVE IN MESSAGE\n         MVC   N1@MSGAR+33(7),ETUSERID+2 SET USER\n         MVC   N1@MSGAR+48(8),ETTERMID+2 SET TERMINAL\n         WTO   MF=(E,N1@MSGAR)\n         INFO  MNAME               FIND KEY IN USER FIELD\n         MVC   N1@MSGAR+10(47),9(R1) OUTPUT NAME\n         WTO   MF=(E,N1@MSGAR)\n         INFO  MPHONE              FIND KEY IN USER FIELD\n         MVC   N1@MSGAR+10(47),9(R1)  OUTPUT PHONE NUMBER\n         WTO   MF=(E,N1@MSGAR)\n         INFO  MADDRESS\n         MVC   N1@MSGAR+10(47),9(R1)  OUTPUT ADDRESS\n         WTO   MF=(E,N1@MSGAR)\n         SPACE 3\nVERTNLOG DS    0H\n         EJECT\n********************************************************************\n*\n*        RETURN TO MAIN LINE\n*\n********************************************************************\nVERTXIT  SR    R15,R15             SET RETURN ADDRESS\n         SUBEXIT ,\n         SPACE 3\nVRTPACK  PACK  N1@WORK1,KASKTM+2(0) **EXECUTED ONLY**\nVRTCLC   CLC   N1@WORK1(0),2(R4)    **EXECUTED ONLY**\nVRTMVC   MVC   ETPROC+2(0),1(R2)    **EXECUTED ONLY**\nMVCVERT3 MVC   N1@WORK1(*-*),4(R1)  MOVE ASKBACK ANSWER\n         EJECT\n********************************************************************\n*\n*        USER FAILED TO PASS TESTS SO LOG IT AND EXIT\n*\n********************************************************************\nVERTFAIL DS    0H\n         OI    ETBITS1,ET1DENY     DENY LOGON\n         SPACE 3\n*        TELL USER ABOUT VIOLATION (UNLESS IN ASKBACK PROCESSING)\n         SPACE 1\n         TM    ETBITS2,ET2ASKB     SEE IF ASKBACK TEST IN PROGRESS\n         BO    VERTFSMF            GO TO SMF PROCESSING\n         LA    R0,L'VERTFM2        GET LENGTH OF MESSAGE\n         LA    R1,VERTFM2          GET ADDR OF MESSAGE\n         TPUT  (1),(0),R           TELL USER\nVERTFSMF TM    KTERM,KTFSMF        LOG TO SMF\n         BZ    VERTFCNL            NOPE\n         SPACE 3\n*        WRITE VIOLATION TO SMF\n         SPACE 1\nVERTFCNL TM    KTERM,KTFCNSL       LOG TO CONSOLE\n         BZ    VERTFOT             NOPE\n         SPACE 3\n*        WRITE VIOLATION TO CONSOLE\n         SPACE 1\n         MVC   N1@MSGAR(VERTFM1L),VERTFM1 MOVE IN MESSAGE\n         MVC   N1@MSGAR+33(7),ETUSERID+2 SET USER\n         MVC   N1@MSGAR+48(8),ETTERMID+2 SET TERMINAL\n         WTO   MF=(E,N1@MSGAR)\n         INFO  MNAME\n         MVC   N1@MSGAR+10(47),9(R1) OUTPUT NAME\n         WTO   MF=(E,N1@MSGAR)\n         INFO  MPHONE\n         MVC   N1@MSGAR+10(47),9(R1)  OUTPUT PHONE NUMBER\n         WTO   MF=(E,N1@MSGAR)\n         INFO  MADDRESS\n         MVC   N1@MSGAR+10(47),9(R1)  OUTPUT ADDRESS\n         WTO   MF=(E,N1@MSGAR)\n         SPACE 3\n*        DENY LOGON\n         SPACE 1\nVERTFOT  DS    0H\n         LA    R15,4               SET RETURN CODE\n         SUBEXIT ,\n         EJECT\n********************************************************************\n*\n*        OPERATOR MESSAGES\n*\n********************************************************************\nVERTFM1  WTO   '  TSO LOGON VIOLATION.  USER=XXXXXXX,  TERM=XXXXXXXX.',X\n               ROUTCDE=(2,9),DESC=11,MF=L\nVERTFM1L EQU   *-VERTFM1\nVERTFM2  DC    C'TSO ACCESS DENIED DUE TO TERMINAL RESTRICTION'\nVRTMHDR  DC    AL2(LVERTMSG,0),C' '\nVERTFM3  DC    C'LOGONXIT ENTERED'\nLVERTMSG EQU   *-VRTMHDR\nVERTFM4  WTO   '  TSO LOGON SUCCESS.    USER=XXXXXXX,  TERM=XXXXXXXX.',X\n               ROUTCDE=(2,9),DESC=11,MF=L\nVERTFM4L EQU   *-VERTFM1\n         TITLE 'IKJEFLN1 - TEMPORARY ENTRY POINTS '\n         PUSH  USING\n         DROP  R12\n         USING *,R15\nN1$RETRY DS    0H\n         L     R12,=A(IKJEFLN1)    GET REAL BASE\n         POP   USING\n         OI    ETBITS1,ET1DENY     MARK TO DENY\n         LA    R15,16              SET ABEND RETURN CODE\n         B     N1$EXIT             ALL DONE\nN1$      DS    0H\n         SR    R15,R15\n         BR    R14\n         LTORG ,\n         DROP  ,\n         TITLE 'IKJEFLN1 - CONSTANTS AREA'\nLPUTGET  PUTGET ,MF=L              PUTGET PARAMETER LIST\nOPENUPDT OPEN  (SYSUADS,UPDAT),MF=L OPEN FOR UPDATE\nOPENOUT  OPEN  (SYSUADS,OUTPUT),MF=L OPEN FOR OUTPUT\nSYSUADS  DCB   DDNAME=SYSUADS,MACRF=(R,W),DSORG=PO\nLSYSUADS EQU   *-SYSUADS           CALCULATE LENGTH OF SYSUADS DCB\nQNAME    DC    C'SYSIKJUA'         QNAME FOR ENQ/RESERVE TSO\nQNAME2   DC    C'SPFDSN  '         QNAME FOR RESERVE ISPF/PDF\nQNAME3   DC    C'SPFEDIT '         QNAME FOR ENQ ISPF/PDF\nRNAME    DC    C'OPENUADS'         RNAME FOR RESERVE UADS\nENQLIST  ENQ   (,,E,,SYSTEM),RET=TEST,MF=L\n         DS    F                   ALLOW ROOM  OR RESERVE UCB ADDR\nLENQLIST EQU   *-ENQLIST\nENQLIST2 ENQ   (,,E,,SYSTEMS),RET=HAVE,MF=L\nENQLIST3 ENQ   (,,S,,SYSTEM),RET=HAVE,MF=L\nRESLIST  RESERVE (,,E,,SYSTEMS),RET=HAVE,UCB=0,MF=L\nOPENMSG  DC    C'OPEN OF UADS UNSUCCESSFUL'\n         DC    X'0D'               CARRIAGE RETURN\nOVERPRNT DC    8X'17'              RUBOUT\n         DC    8C'X'               X'S\n         DC    X'0D'               CARRIAGE RETURN\n         DC    8X'17'              RUBOUT\n         DC    8C'O'               O'S\n         DC    X'0D'               CARRIAGE RETURN\n         DC    8X'17'              RUBOUT\n         DC    8C'A'               A'S\n         DC    X'0D'               CARRIAGE RETURN\nLOVRPRNT EQU   *-OVERPRNT          LENGTH FOR TPUT\n         DC    X'25'               LINE FEED\n         TITLE 'IKJEFLN1 - LOCAL WORK AREA DSECT'\nDSAN1    DSECT\nN1@SAVE  DS    (18*5)F\nN1@WORK1 DS    D                   GENERAL WORK AREA\nN1@ECB   DS    F                   ECB FOR CALLS\nN1@CPPL  DS    XL(LCPPL)\n         SPACE 5\n*        THE FOLLOWING STORAGE IS FOR ESTAE AND ESTAE PROCESSING\nN1@ESTAE ESTAE ,MF=L               ESTAE PARAMETER LIST\n         SPACE 5\n* THE FOLLOWING STORAGE IS FOR ENQ\n         DS    0F                  ALIGNMENT\nN1@ENQLT DS    XL(LENQLIST)        ENQ LIST\nN1@RNAME DS    CL52                RNAME FOR SPF TYPE ENQ\n         SPACE 5\n* THE FOLLOWING STORAGE IS FOR BLDL\nN1@BLDL  DS    0F                  BLDL LIST\nN1@BLFF  DS    H                   FF   NUMBER OF ENTRIES\nN1@BLLL  DS    H                   LL   LENGTH OF EACH ENTRY\nN1@BLNM  DS    CL8                 NAME\nN1@BLTTR DS    XL4                 TTRC\nN1@BLNSZ EQU   *-N1@BLNM           SIZE OF ENTRY\n         DS    7XL(N1@BLNSZ)       EXTRA ENTRIES\n         SPACE 5\n*        THE FOLLOWING STORAGE IS FOR PUTGET\nN1@PGPB DS     XL(LPGPB)           PGPB\nN1@IOPL DS     XL(LIOPL)           IOPL\nN1@PGOLD DS    2F                  OUTPUT LINE DESCRIPTOR (OLD)\n         SPACE 5\n* THE FOLLOWING STORAGE IS THE MESSAGE AREA\nN1@MSGAR DS    CL100\nN1@FCHR  DS    C                   WORK AREA\n         SPACE 5\n* THE FOLLOWING STORAGE IS FOR PARSING THE TERMINAL BLOCK\nKTERM    DS    X                   VALUE PRESENCE FLAG\nKTFUSER  EQU   X'80'               USERID VALUES PRESENT\nKTFTIME  EQU   X'40'               TIME RESTRICTION PRESENT\nKTFASKB  EQU   X'20'               ASKBACK RESTRICTION PRESENT\nKTFSMF   EQU   X'10'               SMF REPORT REQUESTED\nKTFCNSL  EQU   X'08'               CONSOLE REPORT REQUESTED\nKTFLOG   EQU   X'04'               LOG SUCCESSFUL LOGON\nKTFREJCT EQU   X'02'               FORCE LOGON FAILURE\nKUSER    DS    CL(1+9*(1+10))      USERIDS\nKTIME    DS    CL(1+1+4+1+4)       TIME IN HHMM,HHMM FORMAT\nKASKTM   DS    CL(1+1+4)           ASKBACK TIME IN SECONDS\n         SPACE 5\n* THE FOLLOWING STORAGE IS FOR PARSING THE ASKBACK BLOCK\nKASKB    DS    X                   VALUE PRESENCE FLAG\nKAFS     EQU   X'80'               S ASK BACK VALUE PRESENT\nKAFO     EQU   X'40'               O ASK BACK VALUE PRESENT\nKAFT     EQU   X'20'               T ASK BACK VALUE PRESENT\nKAFE     EQU   X'10'               E ASK BACK VALUE PRESENT\nKAFB     EQU   X'08'               B ASK BACK VALUE PRESENT\nKAFP     EQU   X'04'               P ASK BACK VALUE PRESENT\nKAFC     EQU   X'02'               C ASK BACK VALUE PRESENT\nKAFD     EQU   X'01'               D ASK BACK VALUE PRESENT\nKASKBS   DS    CL(1+1+8+1+8)       S ID PASSWORD AND PROC\nKASKBO   DS    CL(1+1+8+1+8)       O ID PASSWORD AND PROC\nKASKBT   DS    CL(1+1+8+1+8)       T ID PASSWORD AND PROC\nKASKBE   DS    CL(1+1+8+1+8)       E ID PASSWORD AND PROC\nKASKBB   DS    CL(1+1+8+1+8)       B ID PASSWORD AND PROC\nKASKBP   DS    CL(1+1+8+1+8)       P ID PASSWORD AND PROC\nKASKBC   DS    CL(1+1+8+1+8)       C ID PASSWORD AND PROC\nKASKBD   DS    CL(1+1+8+1+8)       D ID PASSWORD AND PROC\n         DS    0D                  FILL OUT DSECT\nDSAN1L   EQU   *-DSAN1\n         TITLE 'IKJEFLN1 - STANDARD EXIT PARAMETER LIST'\nN1CMDBFR EQU   1                   COMMAND BUFFER\nN1NEWCMD EQU   2                   NEW COMMAND BUFFER\nN1UPT    EQU   3                   UPT\nN1ECT    EQU   4                   ECT\nN1PSCB   EQU   5                   PSCB\nN1EXTOEX EQU   6                   EXIT TO EXIT COMM WORD\nN1RCODE  EQU   7                   EXIT REASON CODE\n*              8                   RESERVED\n*              9                   RESERVED\nN1SWITCH EQU   10                  SWITCHES\nN1SW2IRF EQU   X'80'               BYTE 2 IBM FIELD REFRESH\nN1SW2URF EQU   X'40'               BYTE 2 USER FIELD REFRESH\nN1SW4NPR EQU   X'80'               BYTE 4 DONT PROMPT\nN1SW4IN2 EQU   X'40'               BYTE 4 INVOKE IKJEFLN2\nN1PANEL  EQU   11                  PANEL MODULE\nN1TGET   EQU   12                  TGET BUFFER\n*              13                  RESERVED\nN1LANG   EQU   14                  LANGUAGE CODE\nN1REPMPT EQU   15                  REPROMPT CODE\nN1UFLDS  EQU   16                  USER FIELD PARM LIST\n*              17                  RESERVED\n*              18                  RESERVED\nN1MSG1   EQU   19                  FIRST MESSAGE\nN1MSG2   EQU   20                  SECOND MESSAGE\nN1USERID EQU   21                  USERID\nN1PASSWD EQU   22                  PASSWORD\nN1ACCNT  EQU   23                  ACCOUNT NUMBER\nN1PROC   EQU   24                  PROCEDURE NAME\nN1RSIZE  EQU   25                  REGION SIZE\nN1PERFGP EQU   26                  JCL STATEMENTS\nN1NPSWD  EQU   27                  NEW PASSWORD\nN1GROUP  EQU   28                  RACF GROUP\nN1NOMAIL EQU   29                  NO MAIL INDICATOR\nN1NONOTC EQU   30                  NO NOTICIES INDICATOR\nN1RECONN EQU   31                  RECONNECT INDICATOR\nN1OIDCRD EQU   32                  OPERATOR ID CARD INDICATOR\nN1FSTCMD EQU   33                  FIRST COMMAND\nN1SECLBL EQU   34                  SECLABEL\n         TITLE 'IKJEFLN2 - LOGON POST-DISPLAY EXIT'\nIKJEFLN2 CSECT\nIKJEFLN2 AMODE 31\nIKJEFLN2 RMODE 24\n         SAVE  (14,12),,IKJEFLN2_&SYSDATE._&SYSTIME\n         LR    R12,R15             SET NEW BASE REGISTER\n         LR    R10,R1              SAVE PARM LIST\n         USING IKJEFLN2,R12        SETUP ADDRESSABILITY\n         PARM  N2EXTOEX            GET EXIT TO EXIT PARM ENTRY\n         LR    R11,R1              SET ADDRESS\n         USING EXTEX,R11\n         EJECT\n***********************************************************************\n*                                                                     *\n*        GET THIS EXIT WORK AREA/SAVE AREA                            *\n*                                                                     *\n***********************************************************************\n         GETMAIN R,LV=DSAN2L,SP=12\n         ST    R13,4(,R1)          SAVE ADDRESS\n         LR    R13,R1              SET NEW SAVE AREA\n         LR    R9,R1               SET NEW SAVE AREA\n         USING DSAN2,R9\n         EJECT\n***********************************************************************\n*                                                                     *\n*       IF TESTING NEW VERSION, CALL IT                               *\n*                                                                     *\n***********************************************************************\n         CLI   ETTEST,255          FLAG AS TEST VERSION WANTED?\n         BNE   N2$M998             NOPE, SO USE PRODUCTION VERSION\n         PARM  N2EXTOEX\n         MVC   0(12,R15),ETHSKEY   SET TO ORIGINAL\n         LR    R1,R10              GET PARM LIST\n         LINK  EP=ZZZEFLN2         CALL TEST VERSION\n         LR    R2,R15              SAVE RETURN CODE\n         PARM  N2EXTOEX\n         MVC   ETHSKEY(12),0(R15)  SAVE THE TEST PGMS STUFF\n         MVC   0(12,R15),ETMYKEY   MOVE MY STUFF BACK IN\n         B     N2$BYE              RETURN WITH TEST EXIT CODE\n         EJECT\n***********************************************************************\n*                                                                     *\n*       IF DEBUGGING MODE, HANDLE DISPLAYS                            *\n*                                                                     *\n***********************************************************************\nN2$M998  DS    0H\n         TM    ETBITS3,ET3DEBUG    DEBUG IN PROGRESS??\n         BZ    N2$M999             NOPE, SKIP CODE\n         WTO   'IKJEFLN2: INSIDE',ROUTCDE=(2)\n         CLI   ETTEST,128\n         BNE   N2$M999\n         LR    R1,R10\n         L     R15,=A(IKJEXIT+X'80000000')\n         BASR  R14,R15\nN2$M999  DS    0H\n         EJECT\n***********************************************************************\n*                                                                     *\n*        MAINLINE PROCESSING                                          *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n*               0. IF ALREADY DENIED LOGON THEN JUST EXIT\n         TM    ETBITS1,ET1DENY     HAVE WE ALREADY DENIED HIM\n         BO    N2$DENY             THEN EXIT\n*               1. IF USERID IS NOT LOCKED THEN EXIT\n         PARM  N2REPMPT\n         CLC   0(4,R1),=F'0'       IS THIS NORMAL PROMPT\n         BE    N2$NORM             YES SO CONTINUE\n         CLC   0(4,R1),=F'2'       IS THIS NORMAL PASSWORD PROMPT\n         BE    N2$NORM             YES SO CONTINUE\n         CLC   0(4,R1),=F'1'       IS THIS USERID REPROMPT\n         BNE   N2$EXIT             NO SO IGNORE\n         LR    R2,R1               SAVE REPROMPT CODE ADDRESS\n*\n**       SINCE A USERID PROMPT, SEE IF PASSWORD ENTERED\n**       (IF NOT THEN GENERAL PROMPT WILL BE DONE)\n*\n         PARM  N2PASSWD\n         CLC   0(4,R15),=F'1'      KEY OF PASSWORD PRESENT\n         BNE   N2$EXIT             NOPE\n         MVC   0(8,R15),=A(0,8)    KILL PASSWORD\n*\n**       FORCE GENERAL REPROMPT (WILL REQUIRE PASSWORD TO BE ENTERED)\n*\n         LA    R15,2               FORCE GENERAL REPROMPT\n         ST    R15,0(,R2)          SAVE IN REPROMPT CODE\n         PARM  N2SWITCH            GET SWITCHES\n         OI    4(R1),N2SW4RPT      REPROMPT AFTER USERID\n         OI    2(R1),X'C0'         REPROMPT AFTER USERID\n         B     N2$EXIT             CONTINUE\nN2$NORM  DS    0H\n*               2. DO HOUSEKEEPING\n         TM    ETBITS3,ET3DEBUG    DEBUGGING REQUESTED??\n         BZ    N2$10               NOPE SKIP CODE\n         WTO   'IKJEFLN2: PROCESSING',ROUTCDE=(2)\nN2$10    DS    0H\n         BAS   R14,N2$HSKP\n         LTR   R15,R15\n         BNZ   N2$DENY\n*\n* *#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#\n*\n*  FOLLOWING CODE DISABLED DUE TO INCLUSION IN APAR OY49074\n*\n*               3. PROCESS TGET BUFFER INTO USER PARMS\n*        BAS   R14,N2$SCRN\n*\n* *#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#\n         LTR   R15,R15\n         BNZ   N2$DENY\n*               3. EXTRACT DATA FROM PARMS TO MY AREA\n         BAS   R14,N2$EXTR\n         LTR   R15,R15\n         BNZ   N2$DENY\n*               4. HANDLE NEEDS OF SPECIAL USERS\n         BAS   R14,N2$SPUR\n         LTR   R15,R15\n         BNZ   N2$DENY\n         EJECT\n***********************************************************************\n*                                                                     *\n*        FREE THIS EXIT WORK AREA AND EXIT ROUTINE                    *\n*                                                                     *\n***********************************************************************\nN2$EXIT  DS    0H\n         SR    R2,R2               CLEAR RETURN CODE\nN2$BYE   DS    0H\n*               5. CLEANUP AND RETURN                                 *\n         BAS   R14,N2$CLEAN\n*\n         LR    R1,R13\n         L     R13,4(,R13)\n         FREEMAIN R,LV=DSAN2L,A=(1),SP=12\n         LR    R15,R2              SET RETURN CODE\n         L     R14,12(,R13)        RESTORE REGISTERS\n         LM    R0,R12,20(R13)      RESTORE REGISTERS\n         BSM   0,R14               RETURN\nN2$DENY  LA    R2,16               DENY LOGON\n         B     N2$BYE\n         TITLE 'IKJEFLN2 - HOUSEKEEPING FUNCTIONS'\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*    N2$HSKP                                                          *\n*                                                                     *\n* FUNCTION -                                                          *\n*    PERFORMS HOUSEKEEPING FUNCTIONS FOR LOGONXIT.                    *\n*                                                                     *\n* OPERATION -                                                         *\n*    1) ISSUES ESTAE.  IF ESTAE IS UNSUCCESSFUL, TELLS TSO USER AND   *\n*       DENIES LOGON.                                                 *\n*    7) ATTEMPTS TO OPEN SYS1.UADS.  IF OPEN IS UNSUCCESSFUL, TELLS   *\n*       TSO USER AND DENIES LOGON.                                    *\n*    8) GETS STORAGE FOR UADS DATA BLOCKS.                            *\n*   14) RETURNS TO THE MAINLINE.\n*                                                                     *\n* ENTRY POINTS -                                                      *\n*    N2$HSKP                                                          *\n*                                                                     *\n* EXTERNAL REFERENCES -                                               *\n*    GETAUTH                                                          *\n*                                                                     *\n* INPUT -                                                             *\n*    NONE                                                             *\n*                                                                     *\n* OUTPUT -                                                            *\n*    NONE                                                             *\n*                                                                     *\n* MESSAGES -                                                          *\n*    'ESTAE UNSUCCESSFUL - RC=NNNN'                                   *\n*    'OPEN OF SYS1.UADS UNSUCCESSFUL'                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nN2$HSKP  DS    0H\n         SUBENTRY ,\n         EJECT\n***********************************************************************\n*                                                                     *\n*       ISSUES ESTAE.  IF ESTAE IS UNSUCCESSFUL, TELLS TSO USER AND   *\n*       DENIES LOGON.                                                 *\n*                                                                     *\n***********************************************************************\n         L     R1,=A(LESTAE)\n         MVC   N2@ESTAE(LGESTAE),0(R1) COPY ESTAE PARM LIST\n         L     R3,=A(GP$ESTAE)     GET ADDRESS OF ESTAE EXIT\n         LA    R4,ETESTPM          GET ADDRESS OF ESTAE PARMS\n         LA    R1,N2$RETRY         POINT TO RETRY ROUTINE\n         ST    R1,0(,R4)           SAVE ADDRESS OF RETRY ROUTINE\n         ST    R9,4(,R4)           SAVE PHASE DSA ADDRESS\n         ST    R11,8(,R4)          SAVE EXTOEX ADDRESSS\n         ST    R10,12(,R4)         SAVE INPUT ADDRESSS\n         ESTAE (3),PARAM=(4),MF=(E,N2@ESTAE) ESTABLISH ESTAE\n         LTR   R15,R15             WAS ESTAE SUCCESSFUL\n         BNZ   N2$HNSTA            NO - GO GIVE MESSAGE\n         EJECT\n***********************************************************************\n*                                                                     *\n*       ATTEMPTS TO OPEN SYS1.UADS.  IF OPEN IS UNSUCCESSFUL, TELLS   *\n*       TSO USER AND DENIES LOGON.                                    *\n*                                                                     *\n***********************************************************************\n         L     R15,=A(SYSUADS)     MOVE SYS1.UADS DCB TO DYNAMIC AREA\n         MVC   ETUADS,0(R15)       MOVE SYS1.UADS DCB TO DYNAMIC AREA\n         L     R15,=A(OPENUPDT)    MOVE OPEN LIST TO DYNAMIC AREA\n         MVC   ETOPENL,0(R15)      MOVE OPEN LIST TO DYNAMIC AREA\n         LA    R15,ETJFCB          GET ADDRESS OF JFCB AREA\n         ST    R15,ETEXLST         PUT IN ETEXLST\n         MVI   ETEXLST,X'87'       INDICATE JFCB ADDRESS\n         LA    R15,ETEXLST         GET ADDRESS OF ETEXLST\n         LA    R1,ETUADS           GET ADDRESS OF SYSUADS DCB\n         USING IHADCB,R1           GET DCB ADDRESSABILITY\n         STCM  R15,B'0111',DCBEXLSA PUT ADDRRESS OF ETEXLST IN DCB\n         STCM  R1,B'0111',ETOPENL+1 PUT ADDR OF DCB IN OPEN LIST\n         DROP  R1                  DROP DCB ADDRESSABILITY\n         OPEN  MF=(E,ETOPENL)      ATTEMPT TO OPEN SYS1.UADS\n         TM    ETUADS+DCBOFLGS-IHADCB,DCBOFOPN DID UADS OPEN\n         BZ    N2$HNOPN            NO - GO TO ERROR ROUTINE\n         RDJFCB MF=(E,ETOPENL)     YES - READ JFCB FOR LATER ENQ\n         L     R15,PSATOLD-PSA     GET ADDRESS OF MY TCB\n         L     R15,TCBTIO-TCB(,R15) GET ADDRESS OF MY TIOT\n         AH    R15,ETUADS+DCBTIOT-IHADCB GET ADDRESS OF UADS TIOT\n         MVC   ETAUCB,16(R15)      SAVE UCB ADDRESS FOR RESERVE\n         EJECT\n***********************************************************************\n*                                                                     *\n*       RETURNS TO THE MAINLINE.                                      *\n*                                                                     *\n***********************************************************************\n         SR    R15,R15             SET GOOD RETURN CODE\nN2$HEXIT DS    0H\n         SUBEXIT ,\n         EJECT\n***********************************************************************\n*                                                                     *\n*       INFORM USER THAT OPEN FAILED AND DENY LOGON.                  *\n*                                                                     *\n***********************************************************************\nN2$HNOPN DS    0H                  SYS1.UADS DID NOT OPEN\n         LA    R0,L'OPENMSG        GET LENGTH OF MESSAGE\n         L     R1,=A(OPENMSG)      POINT TO MESSAGE\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         LA    R15,4               SET RETURN CODE\n         OI    ETBITS1,ET1DENY     DENY LOGON\n         B     N2$HEXIT            EXIT\n         EJECT\n***********************************************************************\n*                                                                     *\n*       INFORM USER THAT ESTAE RETURN CODE WAS NOT ZERO AND DENY      *\n*       LOGON.                                                        *\n*                                                                     *\n***********************************************************************\nN2$HNSTA DS    0H                  NON-ZERO RETURN CODE FROM ESTAE\n         LR    R2,R15              PROTECT RETURN CODE\n         L     R1,=A(ESTAEMSG)\n         MVC   N2@MSGAR(L'ESTAEMSG),0(R1)  COPY MESSAGE\n         CVD   R15,N2@WORK1        CONVERT TO DECIMAL\n         OI    N2@WORK1+7,X'0F'    FIX SIGN\n         UNPK  N2@WORK1(5),N2@WORK1+5(3) UNPACK\n         MVC   N2@MSGAR+24(4),N2@WORK1+1 MOVE INTO MESSAGE\n         LA    R0,L'ESTAEMSG       GET LENGTH OF MESSAGE\n         LA    R1,N2@MSGAR         POINT TO MESSAGE\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         LR    R15,R2              RESTORE RETURN CODE\n         OI    ETBITS1,ET1DENY     DENY LOGON\n         B     N2$HEXIT            EXIT\n         TITLE 'IKJEFLN2 - CLEANUP RESOURCES'\n*********************************************************************\n*\n* ROUTINE NAME -\n*    N2$CLEAN\n*\n* FUNCTION -\n*    PERFORMS CLEANUP FUNCTIONS.\n*\n* OPERATION -\n*    9) IF UADS WAS OPENED, CLOSE AND FREE BUFFER.\n*    9) IF ANYTHING WAS ENQ'D ON, DEQ IT.\n*   10) CANCEL ESTAE.\n*\n*\n* ENTRY POINTS -\n*    N2$CLEAN\n*\n* EXTERNAL REFERENCES -\n*    NONE\n*\n* INPUT -\n*    NONE\n*\n* OUTPUT -\n*    NONE\n*\n* MESSAGES -\n*    NONE\n*\n*********************************************************************\n         SPACE 3\nN2$CLEAN DS    0H                  RETURN TO CALLER\n         SUBENTRY ,                PROTECT RETURN CODE\n         EJECT\n*********************************************************************\n*\n*       IF UADS WAS OPENED, CLOSE AND FREE BUFFER.\n*\n*********************************************************************\n         TM    ETUADS+DCBOFLGS-IHADCB,DCBOFOPN DID UADS OPEN\n         BZ    N2$CNOPN            NO - NO NEED TO DO FREEMAIN\nN2$CCLS  CLOSE MF=(E,ETOPENL)      CLOSE SYS1.UADS\nN2$CNOPN DS    0H\n         EJECT\n*********************************************************************\n*\n*       IF ANYTHING WAS ENQ'D/RESERVED'D ON, DEQ IT\n*\n*********************************************************************\n         TM    ETBITS2,ET2UADRS    WAS SYSIFJUA/OPENUADS ENQ'D ON\n         BZ    N2$CUADS            NO - CONTINUE\n         L     R15,=A(ENQLIST3)    YES - COPY ENQ LIST\n         MVC   N2@ENQLT,0(R15)     YES - COPY ENQ LIST\n         MVI   N2@ENQLT+1,8        PUT LENGTH OF RNAME IN ENQ LIST\n         L     R15,=A(QNAME)       GET ADDRESS OF QNAME (SYSIKJUA)\n         ST    R15,N2@ENQLT+4      PUT IN ENQ LIST\n         L     R15,=A(RNAME)       GET ADDR OF RNAME (OPENUADS)\n         ST    R15,N2@ENQLT+8      PUT IN ENQ LIST\n         LA    R1,N2@ENQLT         GET ADDRESS OF ENQ LIST\n         DEQ   MF=(E,(1))          DEQ LIKE TSO ACCOUNT DOES\n         NI    ETBITS2,255-ET2UADRS TURN OFF SYSIKJUA/OPENUADS RESV\nN2$CUADS DS    0H\n         TM    ETBITS2,ET2SPFRS    WAS SPFDSN/DSN ENQ'D ON\n         BZ    N2$CSPF             NO - CONTINUE\n         L     R15,=A(RESLIST)     YES - COPY RESERVE LIST\n         MVC   N2@ENQLT,0(R15)     YES - COPY RESERVE LIST\n         MVI   N2@ENQLT+1,44       PUT LENGTH OF RNAME IN RES LIST\n         MVC   N2@RNAME(44),ETJFCB MOVE DSNAME TO RNAME\n         L     R15,=A(QNAME2)      GET ADDRESS OF QNAME (SPFDSN  )\n         ST    R15,N2@ENQLT+4      PUT IN RESERVE LIST\n         LA    R15,N2@RNAME        GET ADDR OF RNAME (DSN)\n         ST    R15,N2@ENQLT+8      PUT IN RESERVE LIST\n         LA    R15,ETAUCB          GET ADDRESS OF UCB ADDRESS\n         ST    R15,N2@ENQLT+12     PUT IN RESERVE LIST\n         LA    R1,N2@ENQLT         GET ADDRESS OF RESERVE LIST\n         DEQ   MF=(E,(1))          DEQ LIKE ISPF DOES\n         NI    ETBITS2,255-ET2SPFRS TURN OFF SPFDSN/DSN RESERVED\nN2$CSPF  DS    0H\n         TM    ETBITS2,ET2SPFE0    WAS MEMBER0 ENQ'D ON\n         BZ    N2$CDEQ0            NO - GO CONTINUE\n         L     R15,=A(ENQLIST2)    YES - COPY ENQ LIST\n         MVC   N2@ENQLT,0(R15)     YES - COPY ENQ LIST\n         MVI   N2@ENQLT+1,52       PUT LENGTH OF RNAME IN ENQ LIST\n         MVC   N2@RNAME(44),ETJFCB MOVE DSNAME TO RNAME\n         LH    R15,ETUSERID        GET LENGTH OF USERID\n         LA    R1,ETMEMBER(R15)    POINT TO BYTE AFTER USERID\n         MVI   0(R1),C'0'          ADD SUFFIX TO MAKE MEMBER0\n         MVC   N2@RNAME+44(8),ETMEMBER APPEND MEMBER0 NAME TO DSN\n         L     R15,=A(QNAME3)      GET ADDRESS OF QNAME (SPFEDIT )\n         ST    R15,N2@ENQLT+4      PUT IN ENQ LIST\n         LA    R15,N2@RNAME        GET ADDR OF RNAME (DSN+MEMBER0)\n         ST    R15,N2@ENQLT+8      PUT IN ENQ LIST\n         LA    R1,N2@ENQLT         GET ADDRESS OF ENQ LIST\n         DEQ   MF=(E,(1))          DEQ LIKE ISPF DOES\n         NI    ETBITS2,255-ET2SPFE0 TURN OFF MEMBER0 ENQ'D ON\nN2$CDEQ0 DS    0H\n         TM    ETBITS2,ET2SPFEI    WAS INFO BLOCK ENQ'D ON\n         BZ    N2$CDEQI            NO - CONTINUE\n         L     R15,=A(ENQLIST2)    YES - COPY ENQ LIST\n         MVC   N2@ENQLT,0(R15)     YES - COPY ENQ LIST\n         MVI   N2@ENQLT+1,52       PUT LENGTH OF RNAME IN ENQ LIST\n         MVC   N2@RNAME(44),ETJFCB MOVE DSNAME TO RNAME\n         MVC   N2@RNAME+44(8),ETINFOID APPEND INFO BLOCK NAME TO DSN\n         L     R15,=A(QNAME3)      GET ADDRESS OF QNAME (SPFEDIT )\n         ST    R15,N2@ENQLT+4      PUT IN ENQ LIST\n         LA    R15,N2@RNAME        GET ADDR OF RNAME (DSN+USERID$)\n         ST    R15,N2@ENQLT+8      PUT IN ENQ LIST\n         LA    R1,N2@ENQLT         GET ADDRESS OF ENQ LIST\n         DEQ   MF=(E,(1))          DEQ LIKE ISPF DOES\n         NI    ETBITS2,255-ET2SPFEI TURN OFF INFO BLOCK ENQ'D ON\nN2$CDEQI DS    0H\n         EJECT\n*********************************************************************\n*\n*       IF LOGON IS TO BE DENIED, SET DISCONNECT INDICATOR AND WAIT\n*       5 SECONDS IF THIS IS A DISPLAY TERMINAL TO GIVE THE USER\n*       TIME TO READ THE DIAGNOSTICS.\n*\n*********************************************************************\n         TM    ETBITS1,ET1DENY     IS LOGON TO BE DENIED\n         BNO   N2$COK              NO - CONTINUE\n         GTSIZE ,                  DETERMINE TERMINAL TYPE\n         LTR   R0,R0               WAS THIS A DISPLAY\n         BZ    N2$CEND             NO - CONTINUE\n         STIMER WAIT,DINTVL==C'00000500' - WAIT A LITTLE WHILE FIRST\n         B     N2$CEND             THEN CONTINUE\nN2$COK   DS    0H\n         EJECT\n*********************************************************************\n*\n*       IF DEBUGGING MODE, HANDLE DISPLAYS\n*\n*********************************************************************\nN2$CEND  DS    0H\n         TM    ETBITS3,ET3DEBUG    DEBUG IN PROGRESS??\n         BZ    N2$C999             NOPE, SKIP CODE\n         WTO   'IKJEFLN2: EXITING',ROUTCDE=(2)\n         CLI   ETTEST,128\n         BNE   N2$C999\n         LR    R1,R10\n         L     R15,=A(IKJEXIT+X'80000000')\n         BASR  R14,R15\nN2$C999  DS    0H\n         EJECT\n*********************************************************************\n*\n*       CANCEL ESTAE.\n*\n*********************************************************************\n         ESTAE 0                   CANCEL ESTAE\n         EJECT\n********************************************************************\n*\n*       RETURN TO CALLER\n*\n********************************************************************\n         SUBEXIT ,                 GET RETURN REG\n         TITLE 'IKJEFLN2 - EXTRACT DATA FROM TGET BUFFER TO PARMS'\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*    N2$SCRN                                                          *\n*                                                                     *\n* FUNCTION -                                                          *\n*    EXTRACT DATA FROM TGET BUFFER TO PARAMETER FIELDS                *\n* *#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#* *\n*                                                                     *\n*   FUNCTION MADE OBSOLETE DUE TO INCLUSION IN APAR OY49074.          *\n*                                                                     *\n* *#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#* *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*                                                                     *\n* ENTRY POINTS -                                                      *\n*    N2$SCRN                                                          *\n*                                                                     *\n* EXTERNAL REFERENCES -                                               *\n*    NONE                                                             *\n*                                                                     *\n* INPUT -                                                             *\n*    NONE                                                             *\n*                                                                     *\n* OUTPUT -                                                            *\n*    NONE                                                             *\n*                                                                     *\n* MESSAGES -                                                          *\n*    NONE                                                             *\n*                                                                     *\n* COMMENTS -                                                          *\n*    NONE                                                             *\n*                                                                     *\n***********************************************************************\nN2$SCRN  DS    0H\n         SUBENTRY\n         EJECT\n***********************************************************************\n*                                                                     *\n*       FIND TGET BUFFER AND SCREEN MODULE ADDRESS                    *\n*                                                                     *\n***********************************************************************\n         PARM  N2TGET              GET BUFFER ADDRESS\n         LR    R4,R1               SAVE ADDRESS OF BUFFER START\n         PARM  N2PANEL             GET PANEL ADDRESS\n         LR    R5,R1               SAVE ADDRESS OF MODULE\n         LH    R1,38(,R5)          GET OFFSET TO USER FIELDS\n         LTR   R1,R1               ANY FIELDS\n         BZ    N2$SFDNE            NO, BUT THIS SHOULD NOT HAPPEN\n         AR    R5,R1               POINT AT THE USER HEADERS\n         EJECT\n***********************************************************************\n*                                                                     *\n*       WANDER THROUGH THE TGET BUFFER CHECKING PANEL FOR FIELDS      *\n*              R4 => INPUT BUFFER AND IS STEPPED OVER IT              *\n*              R5 => FIRST USER HEADER FIELD IN PANEL (ALWAYS)        *\n*                                                                     *\n***********************************************************************\n         CLI   0(R4),X'7D'         IS THIS AN \"ENTER\"\n         BNE   N2$SNENT            NOPE\n         LA    R4,3(,R4)           POINT TO FIRST POSSIBLE FIELD\nN2$SNFL1 CLI   0(R4),X'11'         IS THIS A \"SF\"\n         BNE   N2$SFDNE            NOPE, ALL DONE\n*\n**       NOW FIND THE START OF NEXT FIELD\n*\n         LA    R6,3(,R4)           POINT TO DATA\nN2$SEF1  CLI   0(R6),0             END OF DATA??\n         BE    N2$SEF2             YES, SO END OF THIS ONE\n         CLI   0(R6),X'11'         START OF NEXT ONE??\n         BE    N2$SEF2             YES, SO END OF THIS ONE\n         LA    R6,1(,R6)           GO TO NEXT\n         B     N2$SEF1\nN2$SEF2  DS    0H\n*\n**       LOOK FOR THIS FIELD IN THE PANEL HEADERS\n*\n         LR    R2,R5               GET ADDRESS OF HEADER\nN2$SNHDR CLI   0(R2),X'FF'         OUT OF HEADERS\n         BE    N2$SNFL2            YES, SO SKIP THIS FIELD\n         CLC   1(2,R4),6(R2)       CHECK MATCH ON ADDRESS BYTES\n         BE    N2$SFHDR            FOUND ONE OF OUR FIELDS CHANGED\n         LA    R2,16(,R2)          GO TO NEXT FIELD\n         B     N2$SNHDR\n*\n**       FOUND FIELD IN PANEL HEADERS, SAVE DATA\n*\nN2$SFHDR DS    0H\n         SR    R2,R5               GET OFFSET\n         SRL   R2,2                  IN TERMS OF WORDS\n         PARM  N2UFLDS             GET ADDRESS OF USER FIELDS\n         AR    R1,R2               GET TO PROPER WORD\n         L     R1,0(R1)            POINT TO KEY, LEN, VALUE\n         LR    R15,R6              GET END ADDRESS\n         SR    R15,R4              GET LENGTH OF FIELD\n         SH    R15,=H'4'           GET MACHINE LEN\n         EX    R15,N2$SMV1         MOVE IN DATA\n         LA    R15,1(,R15)         GET TRUE LENGTH\n         ST    R15,4(,R1)          SAVE LENGTH\n         MVC   0(4,R1),=F'1'       SET KEY\n         TM    ETBITS3,ET3DEBUG    DEBUG IN PROGRESS??\n         BZ    N2$SNFL2            NO SKIP DEBUG CODE\n         SRL   R2,2                GET REAL NUMBER\n         CVD   R2,N2@WORK1         GET FIELD NUMBER\n         MVC   N2@MSGAR(N2DBG1L),N2DBG1 MOVE IN FIELD\n         ED    N2@MSGAR+25(4),N2@WORK1+6\n         WTO   MF=(E,N2@MSGAR)\n*\n**       GO DO NEXT FIELD FROM TGET BUFFER\n*\nN2$SNFL2 DS    0H                  NEED TO DO NEXT FIELD\n         LR    R4,R6               SET POINTER TO NEXT\n         B     N2$SNFL1\n         SPACE 2\nN2$SFDNE DS    0H                  DONE WITH FIELDS FROM TGET\n         EJECT\n***********************************************************************\n*                                                                     *\n*       RETURNS TO THE MAINLINE.                                      *\n*                                                                     *\n***********************************************************************\n         SR    R15,R15             CLEAR RETURN CODE\nN2$SEXIT DS    0H\n         SUBEXIT\n         SPACE 2\nN2$SMV1  MVC   8(0,R1),3(R4)       ** EXECUTED **\n         EJECT\n***********************************************************************\n*                                                                     *\n*        PROCESS IF NOT \"ENTER\" KEY                                   *\n*                                                                     *\n***********************************************************************\nN2$SNENT DS    0H\n         CLI   0(R4),X'F1'         IS IT PFK 1\n         BE    N2$SFDNE              YES, EXIT\n         CLI   0(R4),X'F3'         IS IT PFK 3\n         BE    N2$SFDNE              YES, EXIT\n         CLI   0(R4),X'C1'         IS IT PFK 13\n         BE    N2$SFDNE              YES, EXIT\n         CLI   0(R4),X'C3'         IS IT PFK 15\n         BE    N2$SFDNE              YES, EXIT\n         MVC   N2@MSGAR(N2DBG2L),N2DBG2 MOVE IN MESSAGE\n         UNPK  N2@MSGAR+23(3),0(2,R4) GET AID BYTE\n         L     R1,=A(TRTABLE-240)\n         TR    N2@MSGAR+23(2),0(R1) MAKE HEX\n         MVI   N2@MSGAR+23+2,C' '  BLANK OUT GARBAGE\n         WTO   MF=(E,N2@MSGAR)\n         LA    R15,12              SET ERROR RETURN\n         B     N2$SEXIT            EXIT WITH ERROR\n         TITLE 'IKJEFLN2 - EXTRACT DATA FROM PARM FIELDS'\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*    N2$EXTR                                                          *\n*                                                                     *\n* FUNCTION -                                                          *\n*    EXTRACT DATA FROM PARAMETER FIELDS AND SAVE IN OUR BLOCKS        *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*                                                                     *\n* ENTRY POINTS -                                                      *\n*    N2$EXTR                                                          *\n*                                                                     *\n* EXTERNAL REFERENCES -                                               *\n*    NONE                                                             *\n*                                                                     *\n* INPUT -                                                             *\n*    NONE                                                             *\n*                                                                     *\n* OUTPUT -                                                            *\n*    NONE                                                             *\n*                                                                     *\n* MESSAGES -                                                          *\n*    NONE                                                             *\n*                                                                     *\n* COMMENTS -                                                          *\n*    NONE                                                             *\n*                                                                     *\n***********************************************************************\nN2$EXTR  DS    0H\n         SUBENTRY\n         EJECT\n***********************************************************************\n*                                                                     *\n*       GET DATA ITEMS.                                               *\n*                                                                     *\n***********************************************************************\n         PARM  N2PROC              GET PROCEDURE NAME\n         LA    R4,ETPROC\n         BAL   R14,N2$ES1\n         PARM  N2ACCNT             GET ACCOUNT NUMBER\n         LA    R4,ETACCNT\n         BAL   R14,N2$ES1\n         PARM  N2RSIZE             GET REGION SIZE\n         LA    R4,ETSIZE\n         BAL   R14,N2$ES1\n         PARM  N2PERFGP            GET PERFORMANCE GROUP\n         LA    R4,ETPERFG\n         BAL   R14,N2$ES1\n         PARM  N2UFLDS             GET ADDRESS FIELD\n         LR    R7,R1\n*  SET ADDRESS VALUE\n         L     R15,0*4(,R7)        GET ADDRESS OF KEY\n         LA    R1,8(,R15)          GET ADDRESS OF DATA\n         LA    R4,ETADDRS\n         BAL   R14,N2$ES1\n*  SET PROGRAMMER NAME VALUE\n         L     R15,1*4(,R7)        GET ADDRESS OF FIELD\n         LA    R1,8(,R15)          GET ADDRESS OF DATA\n         LA    R4,ETPRGNM\n         BAL   R14,N2$ES1\n*  SET CPU TIME VALUE\n         L     R15,2*4(,R7)        GET ADDRESS OF FIELD\n         LA    R1,8(,R15)          GET ADDRESS OF DATA\n         LA    R4,ETCPTIM\n         BAL   R14,N2$ES1\n*  SET ROOM VALUE\n         L     R15,3*4(,R7)        GET ADDRESS OF FIELD\n         LA    R1,8(,R15)          GET ADDRESS OF DATA\n         LA    R4,ETROOM\n         BAL   R14,N2$ES1\n*  SET FORM VALUE\n         L     R15,4*4(,R7)        GET ADDRESS OF FIELD\n         LA    R1,8(,R15)          GET ADDRESS OF DATA\n         LA    R4,ETFORM\n         BAL   R14,N2$ES1\n*  SET MESSAGE CLASS VALUE\n         L     R15,5*4(,R7)        GET ADDRESS OF FIELD\n         LA    R1,8(,R15)          GET ADDRESS OF DATA\n         LA    R4,ETMSGC\n         BAL   R14,N2$ES1\n         OI    ETMSGC+2,X'40'      SET TO UPPER CASE\n*  SET MESSAGE LEVEL VALUE\n         L     R15,6*4(,R7)        GET ADDRESS OF FIELD\n         LA    R1,8(,R15)          GET ADDRESS OF DATA\n         LA    R4,ETMSGL\n         BAL   R14,N2$ES1\n*  SET COPIES VALUE\n         L     R15,7*4(,R7)        GET ADDRESS OF FIELD\n         LA    R1,8(,R15)          GET ADDRESS OF DATA\n         LA    R4,ETCOPY\n         BAL   R14,N2$ES1\n*  SET LINE COUNT VALUE\n         L     R15,8*4(,R7)        GET ADDRESS OF FIELD\n         LA    R1,8(,R15)          GET ADDRESS OF DATA\n         LA    R4,ETLINCT\n         BAL   R14,N2$ES1\n*  SET JCL FLAG VALUE\n         L     R1,9*4(,R7)         GET ADDRESS OF FIELD\n         NI    ETBITS3,255-ET3JCL  SET BIT OFF\n         OI    8(R1),X'40'         SHIFT TO UPPER CASE\n         CLI   8(R1),C'S'          IS IT SET??\n         BNE   *+8                 NOPE, SO LEAVE BIT OFF\n         OI    ETBITS3,ET3JCL      SET FLAG ON\n*  SET LISTINFO FLAG VALUE\n         L     R1,10*4(,R7)        GET ADDRESS OF FIELD\n         NI    ETBITS3,255-ET3LSTIN SET BIT OFF\n         OI    8(R1),X'40'         SHIFT TO UPPER CASE\n         CLI   8(R1),C'S'          IS IT SET??\n         BNE   *+8                 NOPE, SO LEAVE BIT OFF\n         OI    ETBITS3,ET3LSTIN    SET FLAG ON\nN2$E10   DS    0H\n         EJECT\n***********************************************************************\n*                                                                     *\n*       RETURNS TO THE MAINLINE.                                      *\n*                                                                     *\n***********************************************************************\n         SR    R15,R15             CLEAR RETURN CODE\nN2$EEXIT DS    0H\n         SUBEXIT\n         EJECT\n***********************************************************************\n*                                                                     *\n*       SUBROUTINE TO MOVE DATA AND SAVE LENGTH.                      *\n*                                                                     *\n*              R1 => DATA FIELD OF DATA TO MOVE                       *\n*              R4 => LENGTH(2), DATA                                  *\n*              R14 = RETURN ADDRESS                                   *\n*              R15 => KEY/LENGTH/ FIELD OF DATA TO MOVE               *\n*                                                                     *\n***********************************************************************\nN2$ES1   ICM   R2,B'1111',4(R15)   GET LENGTH\n         BZR   R14                 FIELD NOT SET\n         LTR   R15,R15             ANY KEY POINTER??\n         BZ    N2$E10              NOPE, GET OUT OF HERE\n         CLC   0(4,R15),=F'0'      DOES KEY EXIST\n         BER   R14                 IF NOT THEN SKIP\n         CLI   0(R1),0             IS DATA BINARY ZEROS\n         BER   R14                 IF SO SKIP MOVE\n         STH   R2,0(,R4)           SAVE LENGTH\n         BCTR  R2,0                GET MACHINE LENGTH\n         EX    R2,N2$ES11\n         BR    R14\nN2$ES11  MVC   2(0,R4),0(R1)       ** EXECUTED **\n         TITLE 'IKJEFLN2 - SPECIAL USER NEEDS'\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*    N2$SPUR                                                          *\n*                                                                     *\n* FUNCTION -                                                          *\n*                                                                     *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*                                                                     *\n* ENTRY POINTS -                                                      *\n*    N2$SPUR                                                          *\n*                                                                     *\n* EXTERNAL REFERENCES -                                               *\n*    NONE                                                             *\n*                                                                     *\n* INPUT -                                                             *\n*    NONE                                                             *\n*                                                                     *\n* OUTPUT -                                                            *\n*    NONE                                                             *\n*                                                                     *\n* MESSAGES -                                                          *\n*    NONE                                                             *\n*                                                                     *\n* COMMENTS -                                                          *\n*    NONE                                                             *\n*                                                                     *\n***********************************************************************\nN2$SPUR  DS    0H\n         SUBENTRY ,\n         EJECT\n***********************************************************************\n*                                                                     *\n*       FOR PRIVILEDGED USERS ALLOW ANY PROCEDURE                     *\n*                                                                     *\n***********************************************************************\n         CLI   ETUSERID+2,C'S'     IS THIS PRIV USER\n         BNE   N2$SP10             NOPE\n         PARM  N2PROC\n         MVC   0(4,R15),=F'4'      LOCK THE PROCEDURE\n         SPACE 2\n*\n*  FOLLOWING CODE INSERTED DUE TO SOLUTION OF APAR OY48687\n*  DEFAULT UNIT NAME AND REGION SIZE.   SEE 0X148\n*\n         PARM  N2PSCB\n         USING PSCB,R1             SETUP ADDRESSABILITY\n         MVC   PSCBGPNM,=CL8' '    SET SOME DEFAULTS\n         MVC   PSCBRSZ,=F'0'         TO ELIMINATE THE GARBAGE\n         PARM  N2RSIZE\n         MVC   0(4,R15),=F'4'      LOCK THE REGION SIZE\n         DROP  R1\n         SPACE 2\nN2$SP10  DS    0H\n         EJECT\n***********************************************************************\n*                                                                     *\n*       RETURNS TO THE MAINLINE.                                      *\n*                                                                     *\n***********************************************************************\n         SR    R15,R15             CLEAR RETURN CODE\nN2$PEXIT DS    0H\n         SUBEXIT\n         TITLE 'IKJEFLN2 - TEMPORARY ENTRY POINTS '\n         PUSH  USING\n         DROP  R12\n         USING *,R15\nN2$RETRY DS    0H\n         L     R12,=A(IKJEFLN2)    GET REAL BASE\n         POP   USING\n         OI    ETBITS1,ET1DENY     MARK TO DENY\n         LA    R15,16              SET ABEND RETURN CODE\n         B     N2$EXIT             ALL DONE\nN2$      DS    0H\n         SR    R15,R15\n         BR    R14\n         LTORG ,\n         DROP  ,\nN2DBG1   DC    AL2(N2DBG1L-4,X'8000')\n         DC    C'IKJEFLN2: FOUND FIELD ',X'202120',C' MODIFIED'\n         DC    AL2(0,X'4000')\nN2DBG1L  EQU   *-N2DBG1\nN2DBG2   DC    AL2(N2DBG2L-4,X'8000')\n         DC    C'IKJEFLN2: BAD AID: XX REJECTED'\n         DC    AL2(0,X'4000')\nN2DBG2L  EQU   *-N2DBG2\n         TITLE 'IKJEFLN2 - LOCAL WORK AREA DSECT'\nDSAN2    DSECT\nN2@SAVE  DS    (18*5)F\nN2@WORK1 DS    D                   GENERAL WORK AREA\n         SPACE 5\n*        THE FOLLOWING STORAGE IS FOR ESTAE AND ESTAE PROCESSING\nN2@ESTAE ESTAE ,MF=L               ESTAE PARAMETER LIST\n         SPACE 5\n* THE FOLLOWING STORAGE IS FOR ENQ\n         DS    0F                  ALIGNMENT\nN2@ENQLT DS    XL(LENQLIST)        ENQ LIST\nN2@RNAME DS    CL52                RNAME FOR SPF TYPE ENQ\n         SPACE 5\n* THE FOLLOWING STORAGE IS FOR BLDL\nN2@BLDL  DS    0F                  BLDL LIST\nN2@BLFF  DS    H                   FF   NUMBER OF ENTRIES\nN2@BLLL  DS    H                   LL   LENGTH OF EACH ENTRY\nN2@BLNM  DS    CL8                 NAME\nN2@BLTTR DS    XL4                 TTRC\nN2@BLNSZ EQU   *-N2@BLNM           SIZE OF ENTRY\n         DS    7XL(N2@BLNSZ)       EXTRA ENTRIES\n         SPACE 5\n* THE FOLLOWING STORAGE IS THE MESSAGE AREA\nN2@MSGAR DS    CL100\nDSAN2L   EQU   *-DSAN2\n         TITLE 'IKJEFLN2 - STANDARD EXIT PARAMETER LIST'\nN2CMDBFR EQU   1                   COMMAND BUFFER\nN2NEWCMD EQU   2                   NEW COMMAND BUFFER\nN2UPT    EQU   3                   UPT\nN2ECT    EQU   4                   ECT\nN2PSCB   EQU   5                   PSCB\nN2EXTOEX EQU   6                   EXIT TO EXIT COMM WORD\nN2RCODE  EQU   7                   EXIT REASON CODE\n*              8                   RESERVED\n*              9                   RESERVED\nN2SWITCH EQU   10                  SWITCHES\nN2SW4RPT EQU   X'80'               FORCE REPROMPT\nN2PANEL  EQU   11                  PANEL MODULE\nN2TGET   EQU   12                  TGET BUFFER\nN2HELP   EQU   13                  HELP PANEL NUMBER\nN2LANG   EQU   14                  LANGUAGE CODE\nN2REPMPT EQU   15                  REPROMPT CODE\nN2UFLDS  EQU   16                  USER FIELD PARM LIST\n*              17                  RESERVED\n*              18                  RESERVED\nN2MSG1   EQU   19                  FIRST MESSAGE\nN2MSG2   EQU   20                  SECOND MESSAGE\nN2USERID EQU   21                  USERID\nN2PASSWD EQU   22                  PASSWORD\nN2ACCNT  EQU   23                  ACCOUNT NUMBER\nN2PROC   EQU   24                  PROCEDURE NAME\nN2RSIZE  EQU   25                  REGION SIZE\nN2PERFGP EQU   26                  JCL STATEMENTS\nN2NPSWD  EQU   27                  NEW PASSWORD\nN2GROUP  EQU   28                  RACF GROUP\nN2NOMAIL EQU   29                  NO MAIL INDICATOR\nN2NONOTC EQU   30                  NO NOTICIES INDICATOR\nN2RECONN EQU   31                  RECONNECT INDICATOR\nN2OIDCRD EQU   32                  OPERATOR ID CARD INDICATOR\nN2FSTCMD EQU   33                  FIRST COMMAND\nN2SECLBL EQU   34                  SECLABEL\n         TITLE 'IKJEFLD3 - LOGON POST-PROMPT EXIT'\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*        IKJEFLD3                                                     *\n*                                                                     *\n* FUNCTION -                                                          *\n*        LOGON POST PROMPT EXIT                                       *\n*                                                                     *\n* OPERATION -                                                         *\n*        THE FOLLOWING FUNCTIONS ARE DONE:                            *\n*               1. DUMP OUT CURRENT INFO                              *\n*               2. VERIFY TERMINAL RESTRICTIONS                       *\n*               3. PERFORM 'ASKBACK' FUNCTION                         *\n*               4. UPDATE AND OUTPUT INFO BLOCK IF NECESSARY          *\n*               5. BUILD JCL.                                         *\n*                                                                     *\n* ENTRY POINTS -                                                      *\n*        IKJEFLD3                                                     *\n*                                                                     *\n* EXTERNAL REFERENCES -                                               *\n*    NONE                                                             *\n*                                                                     *\n* INPUT -                                                             *\n*    NONE                                                             *\n*                                                                     *\n* OUTPUT -                                                            *\n*    NONE                                                             *\n*                                                                     *\n* MESSAGES -                                                          *\n*    NONE                                                             *\n*                                                                     *\n* COMMENTS -                                                          *\n*    NONE                                                             *\n*                                                                     *\n***********************************************************************\nIKJEFLD3 CSECT\nIKJEFLD3 AMODE 31\nIKJEFLD3 RMODE 24\n         SAVE  (14,12),,IKJEFLD3_&SYSDATE._&SYSTIME\n         LR    R12,R15             SET NEW BASE REGISTER\n         LR    R10,R1              SAVE PARM LIST\n         USING IKJEFLD3,R12        SETUP ADDRESSABILITY\n         EJECT\n***********************************************************************\n*                                                                     *\n**       GET THIS EXIT WORK AREA/SAVE AREA                            *\n*                                                                     *\n***********************************************************************\n         GETMAIN R,LV=DSAD3L,SP=2\n         ST    R13,4(,R1)          SAVE ADDRESS\n         LR    R13,R1              SET NEW SAVE AREA\n         LR    R9,R1               SET NEW SAVE AREA\n         USING DSAD3,R9\n         PARM  D3EXTOEX            GET EXIT TO EXIT PARM ENTRY\n         LR    R11,R1              SET ADDRESS\n         USING EXTEX,R11\n         EJECT\n***********************************************************************\n*                                                                     *\n*       IF DEBUGGING MODE, HANDLE DISPLAYS                            *\n*                                                                     *\n***********************************************************************\n         CLI   ETTEST,255          FLAG AS TEST VERSION WANTED?\n         BNE   D3$M998             NOPE, SO USE PRODUCTION VERSION\n         PARM  D3EXTOEX\n         MVC   0(12,R15),ETHSKEY   SET TO ORIGINAL\n         LR    R1,R10              GET PARM LIST\n         LINK  EP=ZZZEFLD3         CALL TEST VERSION\n         LR    R2,R15              SAVE RETURN CODE\n         PARM  D3EXTOEX\n         MVC   ETHSKEY(12),0(R15)  SAVE THE TEST PGMS STUFF\n         MVC   0(12,R15),ETMYKEY   MOVE MY STUFF BACK IN\n         B     D3$BYE              RETURN WITH TEST EXIT CODE\n         SPACE 2\nD3$M998  DS    0H\n         TM    ETBITS3,ET3DEBUG    DEBUG IN PROGRESS??\n         BZ    D3$M999             NOPE, SKIP CODE\n         WTO   'IKJEFLD3: INSIDE',ROUTCDE=(2)\n         CLI   ETTEST,128\n         BNE   D3$M999\n         LR    R1,R10\n         L     R15,=A(IKJEXIT+X'80000000')\n         BASR  R14,R15\nD3$M999  DS    0H\n         EJECT\n***********************************************************************\n*                                                                     *\n*        MAINLINE PROCESSING                                          *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n*               1. DO HOUSEKEEPING                                    *\n         BAS   R14,D3$HSKP\n         LTR   R15,R15\n         BNZ   D3$DENY\n*               1. DUMP OUT CURRENT INFO                              *\n         BAS   R14,D3$DUMP\n         LTR   R15,R15\n         BNZ   D3$DENY\n*               4. UPDATE AND OUTPUT INFO BLOCK IF NECESSARY          *\n         BAS   R14,D3$UPDAT\n         LTR   R15,R15\n         BNZ   D3$DENY\n*               5. BUILD JCL.                                         *\n         BAS   R14,D3$BJCL\n         LTR   R15,R15\n         BNZ   D3$DENY\n         EJECT\n***********************************************************************\n*                                                                     *\n*        FREE THIS EXIT WORK AREA AND EXIT ROUTINE                    *\n*                                                                     *\n***********************************************************************\nD3$EXIT  DS    0H\n         SR    R2,R2               CLEAR RETURN CODE\nD3$BYE   DS    0H\n*               5. CLEANUP AND RETURN                                 *\n         BAS   R14,D3$CLEAN\n*\n         PARM  D3EXTOEX            GET EXIT TO EXIT PARM ENTRY\n         L     R0,4(,R15)          GET LENGTH AND SUBPOOL\n         ICM   R0,B'1000',=AL1(21) SET SUBPOOL\n         FREEMAIN R,LV=(0),A=(1)\n         LR    R1,R13\n         L     R13,4(,R13)\n         FREEMAIN R,LV=DSAD3L,A=(1),SP=2\n         LR    R15,R2              SET RETURN CODE\n         L     R14,12(,R13)        RESTORE REGISTERS\n         LM    R0,R12,20(R13)      RESTORE REGISTERS\n         BSM   0,R14               RETURN\nD3$DENY  LA    R2,16               DENY LOGON\n         DC    H'0'\n         B     D3$BYE\n         TITLE 'IKJEFLD3 - HOUSEKEEPING FUNCTIONS'\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*    D3$HSKP                                                          *\n*                                                                     *\n* FUNCTION -                                                          *\n*    PERFORMS HOUSEKEEPING FUNCTIONS FOR LOGONXIT.                    *\n*                                                                     *\n* OPERATION -                                                         *\n*    1) ISSUES ESTAE.  IF ESTAE IS UNSUCCESSFUL, TELLS TSO USER AND   *\n*       DENIES LOGON.                                                 *\n*    7) ATTEMPTS TO OPEN SYS1.UADS.  IF OPEN IS UNSUCCESSFUL, TELLS   *\n*       TSO USER AND DENIES LOGON.                                    *\n*    8) GETS STORAGE FOR UADS DATA BLOCKS.                            *\n*   14) RETURNS TO THE MAINLINE.\n*                                                                     *\n* ENTRY POINTS -                                                      *\n*    D3$HSKP                                                          *\n*                                                                     *\n* EXTERNAL REFERENCES -                                               *\n*    GETAUTH                                                          *\n*                                                                     *\n* INPUT -                                                             *\n*    NONE                                                             *\n*                                                                     *\n* OUTPUT -                                                            *\n*    NONE                                                             *\n*                                                                     *\n* MESSAGES -                                                          *\n*    'ESTAE UNSUCCESSFUL - RC=NNNN'                                   *\n*    'OPEN OF SYS1.UADS UNSUCCESSFUL'                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nD3$HSKP  DS    0H\n         SUBENTRY ,\n         EJECT\n***********************************************************************\n*                                                                     *\n*       ISSUES ESTAE.  IF ESTAE IS UNSUCCESSFUL, TELLS TSO USER AND   *\n*       DENIES LOGON.                                                 *\n*                                                                     *\n***********************************************************************\n         L     R1,=A(LESTAE)\n         MVC   D3@ESTAE(LGESTAE),0(R1) COPY ESTAE PARM LIST\n         L     R3,=A(GP$ESTAE)     GET ADDRESS OF ESTAE EXIT\n         LA    R4,ETESTPM          GET ADDRESS OF ESTAE PARMS\n         LA    R1,D3$RETRY         POINT TO RETRY ROUTINE\n         ST    R1,0(,R4)           SAVE ADDRESS OF RETRY ROUTINE\n         ST    R9,4(,R4)           SAVE PHASE DSA ADDRESS\n         ST    R11,8(,R4)          SAVE EXTOEX ADDRESSS\n         ST    R10,12(,R4)         SAVE INPUT ADDRESSS\n         ESTAE (3),PARAM=(4),MF=(E,D3@ESTAE) ESTABLISH ESTAE\n         LTR   R15,R15             WAS ESTAE SUCCESSFUL\n         BNZ   D3$HNSTA            NO - GO GIVE MESSAGE\n         EJECT\n***********************************************************************\n*                                                                     *\n*       ATTEMPTS TO OPEN SYS1.UADS.  IF OPEN IS UNSUCCESSFUL, TELLS   *\n*       TSO USER AND DENIES LOGON.                                    *\n*                                                                     *\n***********************************************************************\n         L     R15,=A(SYSUADS)     MOVE SYS1.UADS DCB TO DYNAMIC AREA\n         MVC   ETUADS,0(R15)       MOVE SYS1.UADS DCB TO DYNAMIC AREA\n         L     R15,=A(OPENUPDT)    MOVE OPEN LIST TO DYNAMIC AREA\n         MVC   ETOPENL,0(R15)      MOVE OPEN LIST TO DYNAMIC AREA\n         LA    R15,ETJFCB          GET ADDRESS OF JFCB AREA\n         ST    R15,ETEXLST         PUT IN ETEXLST\n         MVI   ETEXLST,X'87'       INDICATE JFCB ADDRESS\n         LA    R15,ETEXLST         GET ADDRESS OF ETEXLST\n         LA    R1,ETUADS           GET ADDRESS OF SYSUADS DCB\n         USING IHADCB,R1           GET DCB ADDRESSABILITY\n         STCM  R15,B'0111',DCBEXLSA PUT ADDRRESS OF ETEXLST IN DCB\n         STCM  R1,B'0111',ETOPENL+1 PUT ADDR OF DCB IN OPEN LIST\n         DROP  R1                  DROP DCB ADDRESSABILITY\n         OPEN  MF=(E,ETOPENL)      ATTEMPT TO OPEN SYS1.UADS\n         TM    ETUADS+DCBOFLGS-IHADCB,DCBOFOPN DID UADS OPEN\n         BZ    D3$HNOPN            NO - GO TO ERROR ROUTINE\n         RDJFCB MF=(E,ETOPENL)     YES - READ JFCB FOR LATER ENQ\n         L     R15,PSATOLD-PSA     GET ADDRESS OF MY TCB\n         L     R15,TCBTIO-TCB(,R15) GET ADDRESS OF MY TIOT\n         AH    R15,ETUADS+DCBTIOT-IHADCB GET ADDRESS OF UADS TIOT\n         MVC   ETAUCB,16(R15)      SAVE UCB ADDRESS FOR RESERVE\n         EJECT\n***********************************************************************\n*                                                                     *\n*       RETURNS TO THE MAINLINE.                                      *\n*                                                                     *\n***********************************************************************\n         SR    R15,R15             SET GOOD RETURN CODE\nD3$HEXIT DS    0H\n         SUBEXIT ,\n         EJECT\n***********************************************************************\n*                                                                     *\n*       INFORM USER THAT OPEN FAILED AND DENY LOGON.                  *\n*                                                                     *\n***********************************************************************\nD3$HNOPN DS    0H                  SYS1.UADS DID NOT OPEN\n         LA    R0,L'OPENMSG        GET LENGTH OF MESSAGE\n         L     R1,=A(OPENMSG)      POINT TO MESSAGE\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         LA    R15,4               SET RETURN CODE\n         OI    ETBITS1,ET1DENY     DENY LOGON\n         B     D3$HEXIT            EXIT\n         EJECT\n***********************************************************************\n*                                                                     *\n*       INFORM USER THAT ESTAE RETURN CODE WAS NOT ZERO AND DENY      *\n*       LOGON.                                                        *\n*                                                                     *\n***********************************************************************\nD3$HNSTA DS    0H                  NON-ZERO RETURN CODE FROM ESTAE\n         LR    R2,R15              PROTECT RETURN CODE\n         L     R1,=A(ESTAEMSG)\n         MVC   D3@MSGAR(L'ESTAEMSG),0(R1)  COPY MESSAGE\n         CVD   R15,D3@WORK1        CONVERT TO DECIMAL\n         OI    D3@WORK1+7,X'0F'    FIX SIGN\n         UNPK  D3@WORK1(5),D3@WORK1+5(3) UNPACK\n         MVC   D3@MSGAR+24(4),D3@WORK1+1 MOVE INTO MESSAGE\n         LA    R0,L'ESTAEMSG       GET LENGTH OF MESSAGE\n         LA    R1,D3@MSGAR         POINT TO MESSAGE\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         LR    R15,R2              RESTORE RETURN CODE\n         OI    ETBITS1,ET1DENY     DENY LOGON\n         B     D3$HEXIT            EXIT\n         TITLE 'IKJEFLD3 - CLEANUP RESOURCES'\n*********************************************************************\n*\n* ROUTINE NAME -\n*    D3$CLEAN\n*\n* FUNCTION -\n*    PERFORMS CLEANUP FUNCTIONS.\n*\n* OPERATION -\n*    9) IF UADS WAS OPENED, CLOSE AND FREE BUFFER.\n*    9) IF ANYTHING WAS ENQ'D ON, DEQ IT.\n*   10) CANCEL ESTAE.\n*\n*\n* ENTRY POINTS -\n*    D3$CLEAN\n*\n* EXTERNAL REFERENCES -\n*    NONE\n*\n* INPUT -\n*    NONE\n*\n* OUTPUT -\n*    NONE\n*\n* MESSAGES -\n*    NONE\n*\n*********************************************************************\n         SPACE 3\nD3$CLEAN DS    0H                  RETURN TO CALLER\n         SUBENTRY ,                PROTECT RETURN CODE\n         EJECT\n*********************************************************************\n*\n*       IF UADS WAS OPENED, CLOSE AND FREE BUFFER.\n*\n*********************************************************************\n         TM    ETUADS+DCBOFLGS-IHADCB,DCBOFOPN DID UADS OPEN\n         BZ    D3$CNOPN            NO - NO NEED TO DO FREEMAIN\n         L     R0,ETUADSIZ         GET SIZE GOTTEN\n         ICM   R1,B'1111',ETUADADR GET ADDRESS OF GOTTEN AREA\n         BZ    D3$CCLS             IF ZERO - SKIP FREEMAIN - DO CLOS\n         XC    ETUADADR,ETUADADR   CLEAR ADDRESS\n         FREEMAIN R,LV=(0),A=(1)   FREE AREA FOR SYS1.UADS BUFFER\nD3$CCLS  CLOSE MF=(E,ETOPENL)      CLOSE SYS1.UADS\nD3$CNOPN DS    0H\n         EJECT\n*********************************************************************\n*\n*       IF ANYTHING WAS ENQ'D/RESERVED'D ON, DEQ IT\n*\n*********************************************************************\n         TM    ETBITS2,ET2UADRS    WAS SYSIFJUA/OPENUADS ENQ'D ON\n         BZ    D3$CUADS            NO - CONTINUE\n         L     R15,=A(ENQLIST3)    YES - COPY ENQ LIST\n         MVC   D3@ENQLT,0(R15)     YES - COPY ENQ LIST\n         MVI   D3@ENQLT+1,8        PUT LENGTH OF RNAME IN ENQ LIST\n         L     R15,=A(QNAME)       GET ADDRESS OF QNAME (SYSIKJUA)\n         ST    R15,D3@ENQLT+4      PUT IN ENQ LIST\n         L     R15,=A(RNAME)       GET ADDR OF RNAME (OPENUADS)\n         ST    R15,D3@ENQLT+8      PUT IN ENQ LIST\n         LA    R1,D3@ENQLT         GET ADDRESS OF ENQ LIST\n         DEQ   MF=(E,(1))          DEQ LIKE TSO ACCOUNT DOES\n         NI    ETBITS2,255-ET2UADRS TURN OFF SYSIKJUA/OPENUADS RESV\nD3$CUADS DS    0H\n         TM    ETBITS2,ET2SPFRS    WAS SPFDSN/DSN ENQ'D ON\n         BZ    D3$CSPF             NO - CONTINUE\n         L     R15,=A(RESLIST)     YES - COPY RESERVE LIST\n         MVC   D3@ENQLT,0(R15)     YES - COPY RESERVE LIST\n         MVI   D3@ENQLT+1,44       PUT LENGTH OF RNAME IN RES LIST\n         MVC   D3@RNAME(44),ETJFCB MOVE DSNAME TO RNAME\n         L     R15,=A(QNAME2)      GET ADDRESS OF QNAME (SPFDSN  )\n         ST    R15,D3@ENQLT+4      PUT IN RESERVE LIST\n         LA    R15,D3@RNAME        GET ADDR OF RNAME (DSN)\n         ST    R15,D3@ENQLT+8      PUT IN RESERVE LIST\n         LA    R15,ETAUCB          GET ADDRESS OF UCB ADDRESS\n         ST    R15,D3@ENQLT+12     PUT IN RESERVE LIST\n         LA    R1,D3@ENQLT         GET ADDRESS OF RESERVE LIST\n         DEQ   MF=(E,(1))          DEQ LIKE ISPF DOES\n         NI    ETBITS2,255-ET2SPFRS TURN OFF SPFDSN/DSN RESERVED\nD3$CSPF  DS    0H\n         TM    ETBITS2,ET2SPFE0    WAS MEMBER0 ENQ'D ON\n         BZ    D3$CDEQ0            NO - GO CONTINUE\n         L     R15,=A(ENQLIST2)    YES - COPY ENQ LIST\n         MVC   D3@ENQLT,0(R15)     YES - COPY ENQ LIST\n         MVI   D3@ENQLT+1,52       PUT LENGTH OF RNAME IN ENQ LIST\n         MVC   D3@RNAME(44),ETJFCB MOVE DSNAME TO RNAME\n         LH    R15,ETUSERID        GET LENGTH OF USERID\n         LA    R1,ETMEMBER(R15)    POINT TO BYTE AFTER USERID\n         MVI   0(R1),C'0'          ADD SUFFIX TO MAKE MEMBER0\n         MVC   D3@RNAME+44(8),ETMEMBER APPEND MEMBER0 NAME TO DSN\n         L     R15,=A(QNAME3)      GET ADDRESS OF QNAME (SPFEDIT )\n         ST    R15,D3@ENQLT+4      PUT IN ENQ LIST\n         LA    R15,D3@RNAME        GET ADDR OF RNAME (DSN+MEMBER0)\n         ST    R15,D3@ENQLT+8      PUT IN ENQ LIST\n         LA    R1,D3@ENQLT         GET ADDRESS OF ENQ LIST\n         DEQ   MF=(E,(1))          DEQ LIKE ISPF DOES\n         NI    ETBITS2,255-ET2SPFE0 TURN OFF MEMBER0 ENQ'D ON\nD3$CDEQ0 DS    0H\n         TM    ETBITS2,ET2SPFEI    WAS INFO BLOCK ENQ'D ON\n         BZ    D3$CDEQI            NO - CONTINUE\n         L     R15,=A(ENQLIST2)    YES - COPY ENQ LIST\n         MVC   D3@ENQLT,0(R15)     YES - COPY ENQ LIST\n         MVI   D3@ENQLT+1,52       PUT LENGTH OF RNAME IN ENQ LIST\n         MVC   D3@RNAME(44),ETJFCB MOVE DSNAME TO RNAME\n         MVC   D3@RNAME+44(8),ETINFOID APPEND INFO BLOCK NAME TO DSN\n         L     R15,=A(QNAME3)      GET ADDRESS OF QNAME (SPFEDIT )\n         ST    R15,D3@ENQLT+4      PUT IN ENQ LIST\n         LA    R15,D3@RNAME        GET ADDR OF RNAME (DSN+USERID$)\n         ST    R15,D3@ENQLT+8      PUT IN ENQ LIST\n         LA    R1,D3@ENQLT         GET ADDRESS OF ENQ LIST\n         DEQ   MF=(E,(1))          DEQ LIKE ISPF DOES\n         NI    ETBITS2,255-ET2SPFEI TURN OFF INFO BLOCK ENQ'D ON\nD3$CDEQI DS    0H\n         EJECT\n*********************************************************************\n*\n*       IF LOGON IS TO BE DENIED, SET DISCONNECT INDICATOR AND WAIT\n*       5 SECONDS IF THIS IS A DISPLAY TERMINAL TO GIVE THE USER\n*       TIME TO READ THE DIAGNOSTICS.\n*\n*********************************************************************\n         TM    ETBITS1,ET1DENY     IS LOGON TO BE DENIED\n         BNO   D3$COK              NO - CONTINUE\n         GTSIZE ,                  DETERMINE TERMINAL TYPE\n         LTR   R0,R0               WAS THIS A DISPLAY\n         BZ    D3$CEND             NO - CONTINUE\n         STIMER WAIT,DINTVL==C'00000500' - WAIT A LITTLE WHILE FIRST\n         B     D3$CEND             THEN CONTINUE\nD3$COK   DS    0H\n         EJECT\n*********************************************************************\n*\n*       IF DEBUGGING MODE, HANDLE DISPLAYS\n*\n*********************************************************************\nD3$CEND  DS    0H\n         TM    ETBITS3,ET3DEBUG    DEBUG IN PROGRESS??\n         BZ    D3$C999             NOPE, SKIP CODE\n         WTO   'IKJEFLD3: EXITING',ROUTCDE=(2)\n         CLI   ETTEST,128\n         BNE   D3$C999\n         LR    R1,R10\n         L     R15,=A(IKJEXIT+X'80000000')\n         BASR  R14,R15\nD3$C999  DS    0H\n         EJECT\n*********************************************************************\n*\n*       CANCEL ESTAE.\n*\n*********************************************************************\n         ESTAE 0                   CANCEL ESTAE\n         EJECT\n********************************************************************\n*\n*       RETURN TO CALLER\n*\n********************************************************************\n         SUBEXIT ,                 GET RETURN REG\n         TITLE 'IKJEFLD3 - BUILD LOGON JCL FOR USER'\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*    D3$BJCL                                                          *\n*                                                                     *\n* FUNCTION -                                                          *\n*    CREATE THE JCL FROM THE PARAMETERS SPECIFIED BY THE USER         *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*                                                                     *\n* ENTRY POINTS -                                                      *\n*    D3$BJCL                                                          *\n*                                                                     *\n* EXTERNAL REFERENCES -                                               *\n*    NONE                                                             *\n*                                                                     *\n* INPUT -                                                             *\n*    NONE                                                             *\n*                                                                     *\n* OUTPUT -                                                            *\n*    NONE                                                             *\n*                                                                     *\n* MESSAGES -                                                          *\n*    NONE                                                             *\n*                                                                     *\n* COMMENTS -                                                          *\n*    NONE                                                             *\n*                                                                     *\n***********************************************************************\nD3$BJCL  DS    0H\n         SUBENTRY\n         EJECT\n***********************************************************************\n*                                                                     *\n*        DUMP OUT IBM SUPPLIED JCL                                    *\n*                                                                     *\n***********************************************************************\n         TM    ETBITS3,ET3DEBUG    DEBUG IN PROGRESS??\n         BZ    D3$BJ12             NOPE, SKIP CODE\n         PARM  D3JCL\n         LR    R2,R1               SAVE ADDRESS\n         L     R3,4(,R15)          GET LENGTH\n         WTO   'IKJEFLD3: ORIGINAL JCL',ROUTCDE=(2)\nD3$BJ10  MVC   D3@MSGAR+4(80),0(R2) GET CARD IMAGE\n         MVC   D3@MSGAR(4),=AL2(84,X'8000')\n         MVC   D3@MSGAR+84(4),=AL2(0,X'4000')\n         WTO   MF=(E,D3@MSGAR)\n         LA    R2,80(,R2)          UPDATE POINTER\n         SH    R3,=H'80'           DECREMENT LENGTH\n         BP    D3$BJ10             KEEP GOING IF MORE CARDS\nD3$BJ12  DS    0H\n         EJECT\n***********************************************************************\n*                                                                     *\n*        ALLOCATE SPACE FOR MY JCL                                    *\n*         (BY USING SP 1 THE STORAGE WILL BE FREED WHEN THE REAL      *\n*          TSU JOB STARTS (REGION FREE), OR SO SAYS THE MANUAL.)      *\n*                                                                     *\n***********************************************************************\n         GETMAIN R,LV=20*80,SP=1   SPACE FOR 20 CARDS\n         LA    R2,20               MAX CARD COUNT\n         ST    R1,ETAJCL           SAVE ADDRESS\n         ST    R2,ETCDMAX          SAVE MAX COUNT\n         XC    ETCDCNT,ETCDCNT     CLEAR COUNT\n         LR    R5,R1               SET ADDRESS OF FIRST\n         LA    R6,70(R5)           SET POINTER TO LAST BYTE\n         MVC   0(80,R5),=CL80' '   BLANK OUT CARD\n         EJECT\n***********************************************************************\n*                                                                     *\n*        BUILD JOB CARD                                               *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n*  START WITH JOBNAME\n         LA    R2,D3$JJ1           ALL JCL STARTS WITH //\n         LA    R3,ETUSERID         SET JOBNAME TO USERID\n         SR    R4,R4               NO SECOND CONSTANT\n         BAL   R14,D3$BJ300        HANDLE CVC\n*  NOW THE ACCOUNT NUMBER\n         LA    R2,D3$JJ2           THE \" JOB '\"\n         LA    R3,ETACCNT          DUMP OUT ACCOUNT NUMBER\n         SR    R4,R4               NO SECOND CONSTANT\n         BAL   R14,D3$BJ300        HANDLE CVC\n*  THEN EITHER THE PROGRAMMER NAME OR USERID\n         LA    R2,D3$JJ3           THE \"','\"\n         LA    R3,ETPRGNM          SET FOR PROGRAMMER NAME\n         OC    ETPRGNM(2),ETPRGNM  ANY PROGRAMMER NAME\n         BNZ   D3$BJ20             YES, SO USE IT\n         LA    R3,ETUSERID         OTHERWISE USE USERID\nD3$BJ20  LA    R4,D3$JJ4           THE \"'\"\n         BAL   R14,D3$BJ300        HANDLE CVC\n*  NOW THE OPTIONAL MESSAGE CLASS\n         LA    R2,D3$JJ5           THE \",MSGCLASS=\"\n         LA    R3,ETMSGC           AND THE MESSAGE CLASS\n         SR    R4,R4               NO SECOND CONSTANT\n         BAL   R14,D3$BJ300\n*  NOW THE OPTIONAL MESSAGE LEVEL\n         LA    R2,D3$JJ6           THE \",MSGELEVEL=(\"\n         LA    R3,ETMSGL           AND THE MESSAGE CLASS\n         LA    R4,D3$JJ7           THE \")\"\n         BAL   R14,D3$BJ300\n         EJECT\n***********************************************************************\n*                                                                     *\n*        BUILD OUTPUT CARD                                            *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         BAL   R14,D3$BJ400        GO TO NEXT CARD\n*  START WITH USERID AS OUTPUT NAME\n         LA    R2,D3$JJ1           ALL JCL STARTS WITH //\n         LA    R3,ETUSERID         SET JOBNAME TO USERID\n         LA    R4,D3$JO1           THE \" OUTPUT DEFAULT=YES,JESDS=ALL\"\n         BAL   R14,D3$BJ300        HANDLE CVC\n*  THE OPTIONAL ADDRESS FIELD\n         LA    R2,D3$JO2           THE \",ADDRESS=('\"\n         LA    R3,ETADDRS          AND THE ADDRESS LINE\n         LA    R4,D3$JO3           THE \"')\"\n         BAL   R14,D3$BJ300        HANDLE CVC\n*  THE OPTIONAL ROOM FIELD\n         LA    R2,D3$JO4           THE \",ROOM='\"\n         LA    R3,ETROOM           AND THE ROOM NUMBER\n         LA    R4,D3$JO5           THE \"'\"\n         BAL   R14,D3$BJ300        HANDLE CVC\n*  THE OPTIONAL COPIES FIELD\n         LA    R2,D3$JO6           THE \",COPIES=\"\n         LA    R3,ETCOPY           AND THE COPY COUNT\n         SR    R4,R4               NO SECOND CONSTANT\n         BAL   R14,D3$BJ300        HANDLE CVC\n*  THE OPTIONAL LINE COUNT FIELD\n         LA    R2,D3$JO7           THE \",LINECT=\"\n         LA    R3,ETLINCT          AND THE LINE COUNT\n         SR    R4,R4               NO SECOND CONSTANT\n         BAL   R14,D3$BJ300        HANDLE CVC\n*  THE OPTIONAL FORM FIELD\n         LA    R2,D3$JO8           THE \",FORM=\"\n         LA    R3,ETFORM           AND THE FORM CODE\n         OC    ETFORM+2(4),=CL4' ' FORCE TO UPPER CASE\n         SR    R4,R4               NO SECOND CONSTANT\n         BAL   R14,D3$BJ300        HANDLE CVC\n         EJECT\n***********************************************************************\n*                                                                     *\n*        BUILD EXEC CARD                                              *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         BAL   R14,D3$BJ400        GO TO NEXT CARD\n*  START WITH TERMINAL NAME AS STEP NAME\n         LA    R2,D3$JJ1           ALL JCL STARTS WITH //\n         LA    R3,ETTERMID         SET STEPNAME TO TERMINAL ID\n         SR    R4,R4               NO SECOND CONSTANT\n         BAL   R14,D3$BJ300        HANDLE CVC\n*  NOW THE PROCEDURE NAME\n         LA    R2,D3$JE1           THE \" EXEC \"\n         LA    R3,ETPROC           SET PROCEDURE NAME\n         SR    R4,R4               NO SECOND CONSTANT\n         BAL   R14,D3$BJ300        HANDLE CVC\n*  AND THE TERMINAL NAME FOR THE ACCOUNTING\n         LA    R2,D3$JE2           THE \",TERM=\"\n         LA    R3,ETTERMID         SET TERMINAL NAME IN ACCT DATA\n         SR    R4,R4               NO SECOND CONSTANT\n         BAL   R14,D3$BJ300        HANDLE CVC\n*  THE OPTIONAL CPU TIME VALUE\n         LA    R2,D3$JE3           THE \",TIME=\"\n         LA    R3,ETCPTIM          AND THE CPU TIME\n         SR    R4,R4               NO SECOND CONSTANT\n         BAL   R14,D3$BJ300        HANDLE CVC\n*  THE OPTIONAL REGION SIZE VALUE\n         LA    R2,D3$JE4           THE \",REGION=\"\n         LA    R3,ETSIZE           AND THE REGION SIZE\n         LA    R4,D3$JE5           THE \"K\"\n         BAL   R14,D3$BJ300        HANDLE CVC\n*  THE OPTIONAL REGION SIZE VALUE\n         LA    R2,D3$JE6           THE \",PERFORM=\"\n         LA    R3,ETPERFG          AND THE PERFORMANCE GROUP\n         SR    R4,R4               NO SECOND CONSTANT\n         BAL   R14,D3$BJ300        HANDLE CVC\n         BAL   R14,D3$BJ400        GO PAST LAST CARD\n         EJECT\n***********************************************************************\n*                                                                     *\n*        IF USER JCL REQUESTED, CHECK IF SYSTEMS USERS                *\n*                                                                     *\n***********************************************************************\n         TM    ETBITS3,ET3JCL      WAS JCL REQUESTED\n         BZ    D3$BALL             NOPE, SKIP CODE\n         CLI   ETUSERID+2,C'S'     IS THIS A SOFTWARE USER\n         BE    D3$BLOOP            YES - 'JCL' OK\n         LA    R0,L'BADJCL         NO - GET LENGTH OF MESSAGE\n         L     R1,=A(BADJCL)       POINT TO MESSAGE\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         B     D3$BALL             AND RETURN TO CALLER\n         EJECT\n*********************************************************************\n*\n*       GET JCL FROM USER.\n*\n*********************************************************************\nD3$BLOOP DS    0H\n         L     R14,ETCDMAX         GET MAX\n         BCTR  R14,0               LESS ONE\n         C     R14,ETCDCNT         CHECK AGAINST MAXIMUM\n         BL    D3$BALL             FULL - QUIT\n         BH    D3$BNLST            EMPTY - CONTINUE\n         LA    R0,L'LASTCARD       LAST - GET LENGTH OF MESSAGE\n         L     R1,=A(LASTCARD)     POINT TO MESSAGE\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         B     D3$BTGET            AND READ RESPONSE\nD3$BNLST DS    0H\n         LA    R0,L'NEXTCARD       YES - GET LENGTH OF MESSAGE\n         L     R1,=A(NEXTCARD)     POINT TO MESSAGE\n         TPUT  (1),(0),R           ISSUE MESSAGE\nD3$BTGET DS    0H\n         LR    R1,R5               GET ADDRESS FOR TGET\n         ICM   R1,B'1000',=X'80'   SET OPTIONS\n         MVC   0(80,R5),=CL80' '   BLANK INPUT AREA\n         LA    R0,80               SET LENGTH\n         TGET  (1),(0),R           READ RESPONSE\n         LTR   R15,R15             WAS RETURN CODE ZERO\n         BZ    D3$BTGOK            YES - CONTINUE\n         BAL   R14,D3$BTGER        NO - GO TO ERROR ROUTINE\nD3$BTGOK DS    0H\n         OC    0(80,R5),=CL80' '   FORCE TO UPPERCASE\n         CLC   =C'END',0(R5)       WAS THIS 'END'\n         BE    D3$BALL             YES - QUIT\n         CLI   0(R5),C' '          NO - WAS THIS BLANK LINE\n         BE    D3$BLOOP            YES - ASK AGAIN\n         BAL   R14,D3$BJ400        GO PAST LAST CARD\n         B     D3$BLOOP            AND LOOP\n         EJECT\n***********************************************************************\n*                                                                     *\n*        SET THE PARAMETER ENTRY FOR OUR NEW JCL LIST                 *\n*                                                                     *\n***********************************************************************\nD3$BALL  DS    0H\n         PARM  D3JCL\n         L     R14,ETAJCL          GET ADDR OF JCL\n         ST    R14,8(,R15)         SAVE IT\n         L     R14,ETCDCNT         GET COUNT\n         MH    R14,=H'80'          GET LENGTH\n         ST    R14,4(,R15)         SAVE LENGTH\n         EJECT\n***********************************************************************\n*                                                                     *\n*        DUMP OUT OUR NEW JCL                                         *\n*                                                                     *\n***********************************************************************\n         TM    ETBITS3,ET3DEBUG    DEBUG IN PROGRESS??\n         BZ    D3$BJ92             NOPE, SKIP CODE\n         PARM  D3JCL\n         LR    R2,R1               SAVE ADDRESS\n         L     R3,4(,R15)          GET LENGTH\n         WTO   'IKJEFLD3: NEW JCL',ROUTCDE=(2)\nD3$BJ90  MVC   D3@MSGAR+4(80),0(R2) GET CARD IMAGE\n         MVC   D3@MSGAR(4),=AL2(84,X'8000')\n         MVC   D3@MSGAR+84(4),=AL2(0,X'4000')\n         WTO   MF=(E,D3@MSGAR)\n         LA    R2,80(,R2)          UPDATE POINTER\n         SH    R3,=H'80'           DECREMENT LENGTH\n         BP    D3$BJ90             KEEP GOING IF MORE CARDS\nD3$BJ92  DS    0H\n         EJECT\n***********************************************************************\n*                                                                     *\n*        RETURN TO THE MAINLINE                                       *\n*                                                                     *\n***********************************************************************\n         SR    R15,R15             SET RETURN CODE\nD3$BJXIT DS    0H\n         SUBEXIT ,\n         EJECT\n*********************************************************************\n*\n*       IF RETURN CODE DID NOT INDICATE ATTENTION INTERRUPT, ISSUE\n*       MESSAGE TO USER AND DENY LOGON.\n*\n*********************************************************************\nD3$BTGER DS    0H                  NON-ZERO RETURN CODE FROM TGET\n         LA    R1,8                GET 8 IN R1 FOR COMPARISON\n         CR    R1,R15              WAS THIS AN ATTENTION INTERRUPT\n         BNE   D3$BTGNA            NO - GO ISSUE MESSAGE\n         TM    ETBITS1,ET1ATTN     YES - DID I GET ANY INPUT\n         BZR   R14                 NO - RETURN AS IF NULL INPUT\n         B     D3$BJXIT            YES - LET MAINLINE HANDLE INPUT\nD3$BTGNA DS    0H                  NOT AN ATTENTION INTERRUPT\n         LR    R2,R15              PROTECT RETURN CODE\n         L     R1,=A(TGETMSG)      POINT AT MSG\n         MVC   D3@MSGAR(L'TGETMSG),0(R1) COPY MESSAGE\n         CVD   R2,D3@WORK1         CONVERT TO DECIMAL\n         OI    D3@WORK1+7,X'0F'    FIX SIGN\n         UNPK  D3@WORK1(5),D3@WORK1+5(3) UNPACK\n         MVC   D3@MSGAR+23(4),D3@WORK1+1 MOVE INTO MESSAGE\n         LA    R0,L'TGETMSG        GET LENGTH OF MESSAGE\n         LA    R1,D3@MSGAR         POINT TO MESSAGE\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         LR    R15,R2              RESTORE RETURN CODE\n         OI    ETBITS1,ET1DENY     DENY LOGON\n         B     D3$BJXIT            EXIT\n         EJECT\n***********************************************************************\n*                                                                     *\n*        SUBROUTINE TO MOVE VARIABLE DATA TO OUTPUT LINE              *\n*              R1 => LENGTH(2), DATA TO MOVE                          *\n*              R5 => NEXT OPEN AREA IN LINE                           *\n*              R14 = RETURN ADDRESS                                   *\n*                                                                     *\n***********************************************************************\nD3$BJ200 DS    0H\n         LH    R15,0(R1)           GET LENGTH\n         LTR   R15,R15             ANY LENGTH\n         BZR   R14                 OUT IF NO DATA\n         BCTR  R15,0               GET MACHINE LENGTH\n         EX    R15,D3$BJ299        MOVE IN DATA\n         LA    R5,1(R15,R5)        UPDATE POINTER\n         BR    R14                 ALL DONE\nD3$BJ299 MVC   0(0,R5),2(R1)       MOVE IN DATA\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*        SUBROUTINE TO ADD ENTRY TO CURRENT CARD                      *\n*              R2 => LENGTH(2), DATA OF CONSTANT                      *\n*              R3 => LENGTH(2), DATA OF VARIABLE                      *\n*              R4 => LENGTH(2), DATA OF CONSTANT; OR 0                *\n*              R5 => NEXT OPEN AREA IN CARD                           *\n*              R6 => LAST USABLE BYTE IN CARD                         *\n*              R14 = RETURN ADDRESS                                   *\n*                                                                     *\n***********************************************************************\nD3$BJ300 DS    0H\n         OC    0(2,R3),0(R3)       ANY LENGTH TO VARIABLE\n         BZR   R14                 IF NOT THEN EXIT\n         ST    R14,D3@BJSV         SAVE RETURN ADDRESS\n         LH    R1,0(,R2)           GET LENGTH OF CONSTANT 1\n         AH    R1,0(,R3)           PLUS LENGTH OF VARIABLE\n         LTR   R4,R4               ANY CONSTANT 2\n         BZ    *+8                 IF NOT THEN SKIP\n         AH    R1,0(,R4)           PLUS LENGTH OF CONSTANT 2\n         AR    R1,R5               ADD IN CURRENT ADDRESS\n         CR    R1,R6               SEE IF EXCEEDS CARD\n         BNH   D3$BJ330            NO, EVERYTHING OK ON CARD\n         MVI   0(R5),C','          INDICATE CONTINUATION\n*  DUMP CARD\n         BAL   R14,D3$BJ400\n         MVC   0(3,R5),=C'// '     SET CONTINUATION START\n         LA    R5,3(,R5)           UPDATE POINTER\n         LR    R7,R5               SAVE POINTER\n         LR    R1,R2               POINT AT CONSTANT 1\n         BAL   R14,D3$BJ200        MOVE IT IN\n         MVI   0(R7),C' '          CLEAR COMMA FROM CONSTANT 1\n         B     D3$BJ335\nD3$BJ330 DS    0H\n         LR    R1,R2               POINT AT CONSTANT 1\n         BAL   R14,D3$BJ200        MOVE IT IN\nD3$BJ335 DS    0H\n         LR    R1,R3               POINT AT VARIABLE\n         BAL   R14,D3$BJ200        MOVE IT IN\n         LTR   R1,R4               POINT AT CONSTANT 2\n         BZ    D3$BJ338            IF NO CONSTANT 2, SKIP MOVE\n         BAL   R14,D3$BJ200        MOVE IT IN\nD3$BJ338 DS    0H\n         L     R14,D3@BJSV\n         BR    R14\n         SPACE 3\n*\n**       UPDATE POINTERS TO NEXT CARD\n*\nD3$BJ400 DS    0H                  ROUTINE TO DUMP OUT CARD\n         L     R5,ETCDCNT          GET CARD COUNT\n         LA    R5,1(R5)            ADD IN ANOTHER\n         ST    R5,ETCDCNT\n         C     R5,ETCDMAX          CHECK AGAINST MAX\n         BH    D3$BJ410            KILL IF TOO BIG\n         MH    R5,=H'80'           GET LENGTH\n         A     R5,ETAJCL           PLUS START\n         MVC   0(80,R5),=CL80' '   BLANK OUT CARD\n         LA    R6,70(,R5)          SET END ADDRESS\n         BR    R14                 DONE\nD3$BJ410 DS    0H                  ISSUE ERROR MESSAGE AND RETURN\n         LA    R0,L'MANYMSG        GET LENGTH OF MESSAGE\n         L     R1,=A(MANYMSG)      POINT TO MESSAGE\n         TPUT  (1),(0),R           ISSUE MESSAGE\n         B     D3$BALL             ALL DONE\n         TITLE 'IKJEFLD3 - DUMP OUT SAVED INFORMATION'\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*    D3$DUMP                                                          *\n*                                                                     *\n* FUNCTION -                                                          *\n*    DUMP OUT THE SAVED INFORMATION FOR CHECKING                      *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*                                                                     *\n* ENTRY POINTS -                                                      *\n*    D3$DUMP                                                          *\n*                                                                     *\n* EXTERNAL REFERENCES -                                               *\n*    NONE                                                             *\n*                                                                     *\n* INPUT -                                                             *\n*    NONE                                                             *\n*                                                                     *\n* OUTPUT -                                                            *\n*    NONE                                                             *\n*                                                                     *\n* MESSAGES -                                                          *\n*    NONE                                                             *\n*                                                                     *\n* COMMENTS -                                                          *\n*    NONE                                                             *\n*                                                                     *\n***********************************************************************\nD3$DUMP  DS    0H\n         SUBENTRY\n         EJECT\n***********************************************************************\n*                                                                     *\n*       SEE IF NECESSARY TO PROCESS.                                  *\n*                                                                     *\n***********************************************************************\n         TM    ETBITS3,ET3DEBUG+ET3LSTIN ANY REQURIEMENT\n         BZ    D3$DEXIT            NOPE\n         EJECT\n***********************************************************************\n*                                                                     *\n*       DUMP OUT EACH ITEM IN TURN.                                   *\n*                                                                     *\n***********************************************************************\n*  DUMP OUT USERID\n         LA    R3,ETUSERID\n         LA    R1,=CL9'USER    ='\n         BAL   R14,D3$DWTO\n*  DUMP OUT TERMINAL ID\n         LA    R3,ETTERMID\n         LA    R1,=CL9'TERMINAL='\n         BAL   R14,D3$DWTO\n*  DUMP OUT PROCEDURE NAME\n         LA    R3,ETPROC\n         LA    R1,=CL9'PROC    ='\n         BAL   R14,D3$DWTO\n*  DUMP OUT ACCOUNT NUMBER\n         LA    R3,ETACCNT\n         LA    R1,=CL9'ACCOUNT ='\n         BAL   R14,D3$DWTO\n*  DUMP OUT REGION SIZE\n         LA    R3,ETSIZE\n         LA    R1,=CL9'REG SIZE='\n         BAL   R14,D3$DWTO\n*  DUMP OUT PERFORMANCE GROUP\n         LA    R3,ETPERFG\n         LA    R1,=CL9'PERF GRP='\n         BAL   R14,D3$DWTO\n**  PARSE OR PANEL INPUT\n*  DUMP OUT MESSAGE CLASS VALUE\n         LA    R3,ETMSGC           POINT AT DATA\n         LA    R1,=CL9'MSGCLASS='\n         BAL   R14,D3$DWTO\n*  DUMP OUT MESSAGE LEVEL VALUE\n         LA    R3,ETMSGL           POINT AT DATA\n         LA    R1,=CL9'MSGLEVEL='\n         BAL   R14,D3$DWTO\n*  DUMP OUT COPIES VALUE\n         LA    R3,ETCOPY           POINT AT DATA\n         LA    R1,=CL9'COPIES  ='\n         BAL   R14,D3$DWTO\n*  DUMP OUT LINE COUNT VALUE\n         LA    R3,ETLINCT          POINT AT DATA\n         LA    R1,=CL9'LINECT  ='\n         BAL   R14,D3$DWTO\n**  FROM PARSE, PANEL, OR INFO BLOCK\n*  DUMP OUT ADDRESS INFO\n         LA    R3,ETADDRS          POINT AT DATA\n         LA    R1,=CL9'ADDRESS ='\n         BAL   R14,D3$DWTO\n*  DUMP OUT PROGRAMMER NAME INFO\n         LA    R3,ETPRGNM          POINT AT DATA\n         LA    R1,=CL9'PROG NAM='\n         BAL   R14,D3$DWTO\n*  DUMP OUT CPU TIME\n         LA    R3,ETCPTIM          POINT AT DATA\n         LA    R1,=CL9'CPU TIME='\n         BAL   R14,D3$DWTO\n*  DUMP OUT ROOM INFO\n         LA    R3,ETROOM           POINT AT DATA\n         LA    R1,=CL9'ROOM    ='\n         BAL   R14,D3$DWTO\n*  DUMP OUT ADDRESS INFO\n         LA    R3,ETFORM           POINT AT DATA\n         LA    R1,=CL9'FORMS   ='\n         BAL   R14,D3$DWTO\n         EJECT\n***********************************************************************\n*                                                                     *\n*       RETURNS TO THE MAINLINE.                                      *\n*                                                                     *\n***********************************************************************\nD3$DEXIT DS    0H\n         SR    R15,R15             CLEAR RETURN CODE\n         SUBEXIT\n***********************************************************************\n*                                                                     *\n*       SUBROUTINE TO FORMAT AND WRITE A LINE                         *\n*                                                                     *\n**             R14 = RETURN                                           *\n**             R3 => LENGTH(2),DATA                                   *\n**             R1 => LABEL                                            *\n***********************************************************************\nD3$DWTO  DS    0H\n         LR    R7,R14              SAVE RETURN ADDRESS\n         LH    R2,0(,R3)           GET LENGTH\n         LA    R3,2(,R3)           GET DATA ADDRESS\n         MVC   D3@MSGAR(4),=AL2(0,X'8000') SET HEADER\n         MVI   D3@MSGAR+4,C' '     BLANK OUT AREA\n         MVC   D3@MSGAR+5(94),D3@MSGAR+4\n         MVC   D3@MSGAR+4(9),=CL9'IKJEFLD3:' MOVE IN ID\n         MVC   D3@MSGAR+14(9),0(R1)  MOVE IN LABEL\n         LTR   R2,R2               ANY LENGTH\n         BP    D3$DW10             YES, KEEP GOING\n         MVC   D3@MSGAR+23(7),=C'* N/A *' SET FLAG\n         LA    R2,23+7             SET LENGTH\n         B     D3$DW20             GO AND OUTPUT MESSAGE\nD3$DW10  DS    0H\n         BCTR  R2,0                GET MACHINE LENGTH\n         EX    R2,D3$DW99          MOVE IN DATA\n         LA    R2,23+1(R2)         GET REAL LENGTH\nD3$DW20  DS    0H\n         STH   R2,D3@MSGAR         SET IN HEADER\n         LA    R2,D3@MSGAR(R2)     POINT PAST STRING\n         MVC   0(4,R2),=AL2(0,X'4000') SET ROUTCDE\n         TM    ETBITS3,ET3DEBUG    DEBUG IN PROGRESS??\n         BZ    D3$DW30             NOPE, SKIP CODE\n         WTO   MF=(E,D3@MSGAR)\nD3$DW30  DS    0H\n         TM    ETBITS3,ET3LSTIN    LISTINFO REQUESTED??\n         BZ    D3$DW40             NOPE, SKIP CODE\n         LH    R0,D3@MSGAR         GET LENGTH\n         SH    R0,=H'4'            LESS HEADER\n         LA    R1,D3@MSGAR+4       AND GET ADDRESS\n         TPUT  (1),(0),R           WRITE TO USER\nD3$DW40  DS    0H\n         BR    R7\nD3$DW99  MVC   D3@MSGAR+23(0),0(R3) ** EXECUTED **\n         TITLE 'IKJEFLD3 - UPDATE UADS BLOCK AND REWRITE DATA'\n*********************************************************************\n*\n* ROUTINE NAME -\n*    D3$UPDAT\n*\n* FUNCTION -\n*    UPDATE INFO BLOCK.\n*\n* OPERATION -\n*    2) UPDATE LASTON.\n*    4) REWRITE INFO BLOCK.\n*    5) RETURN TO THE MAINLINE.\n*\n* ENTRY POINTS -\n*    D3$UPDAT\n*\n* EXTERNAL REFERENCES -\n*    FINDINFO\n*\n* INPUT -\n*    NONE\n*\n* OUTPUT -\n*    REGISTER 15 CONTAINS THE RETURN CODE FOR THE MAINLINE.  THIS\n*    WILL BE AS FOLLOWS -\n*       |------|------------------------|--------------------------|\n*       |RETURN|                        |                          |\n*       |CODE  |REASON                  |ACTION                    |\n*       |------|------------------------|--------------------------|\n*       |   0  |NO ERRORS ENCOUNTERED.  |CONTINUE WITH LOGON.      |\n*       |------|------------------------|--------------------------|\n*\n* MESSAGES -\n*    NONE\n*\n*********************************************************************\n         EJECT\nD3$UPDAT DS    0H\n         SUBENTRY ,\n         EJECT\n*********************************************************************\n*\n*       MERGE DATA FROM LOGON COMMAND AND PANEL BACK TO MEMBER\n*\n*********************************************************************\n         SPACE 2\n         INFO  MADDRESS            MERGE ADDRESS\n         LA    R2,ETADDRS\n         BAL   R14,D3$UMV90\n         SPACE 2\n         INFO  MNAME               MERGE USER NAME\n         LA    R2,ETNAME\n         BAL   R14,D3$UMV90\n         SPACE 2\n         INFO  MPHONE              MERGE PHONE NUMBER\n         LA    R2,ETPHONE\n         BAL   R14,D3$UMV90\n         SPACE 2\n         INFO  MPROGNAM            MERGE PROGRAMMER NAME\n         LA    R2,ETPRGNM\n         BAL   R14,D3$UMV90\n         SPACE 2\n         INFO  MFORMS              MERGE FORM CODE\n         LA    R2,ETFORM\n         BAL   R14,D3$UMV90\n         SPACE 2\n         INFO  MROOM               MERGE ROOM NUMBER\n         LA    R2,ETROOM\n         BAL   R14,D3$UMV90\n         SPACE 2\n         INFO  MLINECT             MERGE LINE COUNT\n         LA    R2,ETLINCT\n         BAL   R14,D3$UMV90\n         EJECT\n*********************************************************************\n*\n*       UPDATE LASTON.\n*\n*********************************************************************\n         INFO  MLASTON             FIND LASTON\n         MVC   8(7,R1),=X'4021204B202020'  EDIT MASK FOR DATE\n         ED    8(7,R1),ETDATE+1    EDIT IN TODAY'S DATE\n         MVC   16(9,R1),=X'4021207A20207A2020' EDIT MASK FOR TIME\n         ED    16(9,R1),ETTIME     EDIT IN TODAY'S TIME\n         MVC   26(8,R1),ETTERMID+2 COPY TERMINAL TO INFO BLOCK\n         EJECT\n*********************************************************************\n*\n*       REWRITE INFO BLOCK.\n*\n*********************************************************************\n         POINT ETUADS,ETTTRINF     POINT AT INFO BLOCK\n         L     R2,ETAASKB          USE OTHER BUFFER\n         READ  ETDECB,SF,ETUADS,(R2),'S',MF=E   READ FOR UPDATE\n         CHECK ETDECB              WAIT ON I/O\n         L     R2,ETAINFO          GET ADDRESS OF INFO BLOCK BUFFER\n         L     R3,ETLINFO          GET LENGTH OF INFO BLOCK\n         WRITE ETDECB,SF,ETUADS,(R2),(R3),MF=E REWRITE INFO BLOCK\n         CHECK ETDECB              WAIT ON I/O\n         EJECT\n*********************************************************************\n*\n*       RETURN TO THE MAINLINE.\n*\n*********************************************************************\nD3$URTRN DS    0H\n         SLR   R15,R15             SET RETURN CODE\nD3$UEXIT DS    0H\n         SUBEXIT ,\n         EJECT\n*********************************************************************\n*\n*       RETURN TO THE MAINLINE.\n*              R1 => INFO BLOCK ENTRY\n*              R2 => LENGTH(2), DATA TO MERGE\n*              R14 = RETURN ADDRESS\n*\n*********************************************************************\nD3$UMV90 DS    0H\n         ICM   R3,B'0011',0(R2)    GET LENGTH\n         BZR   R14                 OUT IF NO DATA\n         BCTR  R3,0                GET MACHINE LENGTH\n         EX    R3,D3$UMV99         SEE IF DIFFERENT\n         BER   R14                 IF NOT THEN EXIT\n         EX    R3,D3$UMV98         MOVE IN NEW\n         BR    R14                 ALL DONE\nD3$UMV98 MVC   9(0,R1),2(R2)       COMPARE FIELDS\nD3$UMV99 CLC   9(0,R1),2(R2)       COMPARE FIELDS\n         TITLE 'IKJEFLD3 - JCL CONSTANTS'\nD3$JJ1   DC    AL2(2),C'//'        ALL JCL STARTS WITH //\nD3$JJ2   DC    AL2(6),C' JOB '''\nD3$JJ3   DC    AL2(3),C''','''\nD3$JJ4   DC    AL2(1),C''''\nD3$JJ5   DC    AL2(10),C',MSGCLASS='\nD3$JJ6   DC    AL2(11),C',MSGLEVEL=('\nD3$JJ7   DC    AL2(1),C')'\nD3$JO1   DC    AL2(29),C' OUTPUT DEFAULT=YES,JESDS=ALL'\nD3$JO2   DC    AL2(11),C',ADDRESS=('''\nD3$JO3   DC    AL2(2),C''')'\nD3$JO4   DC    AL2(7),C',ROOM='''\nD3$JO5   DC    AL2(1),C''''\nD3$JO6   DC    AL2(8),C',COPIES='\nD3$JO7   DC    AL2(8),C',LINECT='\nD3$JO8   DC    AL2(6),C',FORM='\nD3$JE1   DC    AL2(6),C' EXEC '\nD3$JE2   DC    AL2(6),C',TERM='\nD3$JE3   DC    AL2(6),C',TIME='\nD3$JE4   DC    AL2(8),C',REGION='\nD3$JE5   DC    AL2(1),C'K'\nD3$JE6   DC    AL2(9),C',PERFORM='\n         TITLE 'IKJEFLD3 - TEMPORARY ENTRY POINTS '\n         PUSH  USING\n         DROP  R12\n         USING *,R15\nD3$RETRY DS    0H\n         L     R12,=A(IKJEFLD3)    GET REAL BASE\n         POP   USING\n         OI    ETBITS1,ET1DENY     MARK TO DENY\n         LA    R15,16              SET ABEND RETURN CODE\n         B     D3$EXIT             ALL DONE\nD3$      DS    0H\n         SR    R15,R15\n         BR    R14\n         LTORG ,\n         DROP  ,\n         EJECT\nDSAD3    DSECT\nD3@SAVE  DS    (18*5)F\nD3@WORK1 DS    D                   GENERAL WORK AREA\nD3@BJSV  DS    F                   RETURN ADDRESS SAVE AREA\n         SPACE 5\n*        THE FOLLOWING STORAGE IS FOR ESTAE AND ESTAE PROCESSING\nD3@ESTAE ESTAE ,MF=L               ESTAE PARAMETER LIST\n         SPACE 5\n* THE FOLLOWING STORAGE IS FOR ENQ\n         DS    0F                  ALIGNMENT\nD3@ENQLT DS    XL(LENQLIST)        ENQ LIST\nD3@RNAME DS    CL52                RNAME FOR SPF TYPE ENQ\n         SPACE 5\n* THE FOLLOWING STORAGE IS FOR BLDL\nD3@BLDL  DS    0F                  BLDL LIST\nD3@BLFF  DS    H                   FF   NUMBER OF ENTRIES\nD3@BLLL  DS    H                   LL   LENGTH OF EACH ENTRY\nD3@BLNM  DS    CL8                 NAME\nD3@BLTTR DS    XL4                 TTRC\nD3@BLNSZ EQU   *-D3@BLNM           SIZE OF ENTRY\n         DS    7XL(D3@BLNSZ)       EXTRA ENTRIES\n         SPACE 5\n* THE FOLLOWING STORAGE IS THE MESSAGE AREA\nD3@MSGAR DS    CL100               MESSAGE AREA\nDSAD3L   EQU   *-DSAD3\n         TITLE 'IKJEFLD3 - STANDARD EXIT PARAMETER LIST'\nD3CMDBFR EQU   1                   COMMAND BUFFER\nD3NEWCMD EQU   2                   NEW COMMAND BUFFER\nD3UPT    EQU   3                   UPT\nD3ECT    EQU   4                   ECT\nD3PSCB   EQU   5                   PSCB\nD3EXTOEX EQU   6                   EXIT TO EXIT COMM WORD\nD3RCODE  EQU   7                   EXIT REASON CODE\n*              8                   RESERVED\n*              9                   RESERVED\nD3SWITCH EQU   10                  CONTROL SWITCHES\nD3JCL    EQU   11                  JCL AREA\n         TITLE 'GENERAL USE SUBROUTINES FOR ALL EXITS'\nGPSUBS   CSECT\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*        GPENTRY                                                      *\n*                                                                     *\n* FUNCTION -                                                          *\n*        GET PARAMETER LIST ENTRY                                     *\n*                                                                     *\n* OPERATION -                                                         *\n*        USED PASSED PARAMETER NUMBER TO GET POINTER TO ITEM          *\n*                                                                     *\n* ENTRY POINTS -                                                      *\n*        GPENTRY                                                      *\n*                                                                     *\n* EXTERNAL REFERENCES -                                               *\n*    NONE                                                             *\n*                                                                     *\n* INPUT -                                                             *\n*        R1  ==  ENTRY NUMBER TO RETURN                               *\n*        R14 ==  RETURN ADDRESS                                       *\n*        R15 ==  ENTRY POINT ADDRESS                                  *\n*                                                                     *\n* OUTPUT -                                                            *\n*        R1  ==  ADDRESS OF DATA                                      *\n*        R15 ==  ADDRESS OF LIST ENTRY (FOR MODIFICATIONS)            *\n*                                                                     *\n* MESSAGES -                                                          *\n*    NONE                                                             *\n*                                                                     *\n* COMMENTS -                                                          *\n*    NONE                                                             *\n*                                                                     *\n***********************************************************************\nGPENTRY  DS    0H\n         USING *,R15               SETUP ADDRESSABLILITY\n         BCTR  R1,0                MINUS 1\n         SLL   R1,2                TIMES 4\n         L     R1,0(R1,R10)        PLUS BASE\n         CLC   0(4,R1),=F'1'       IS KEY TYPE '1'\n         BH    GPE$10\n         LR    R15,R1              SET TO PROPER REGISTER\n         LA    R1,8(R15)           POINT AT DATA\n         BR    R14\nGPE$10   CLC   0(4,R1),=F'2'       IS KEY TYPE '2'\n         BNE   GPE$20\n         LR    R15,R1              SET TO PROPER REGISTER\n         L     R1,8(,R15)          GET POINTER TO DATA\n         BR    R14\nGPE$20   CLC   0(4,R1),=F'4'       IS KEY TYPE '4' (LOCKED 1??)\n         BNE   GPE$30\n         LR    R15,R1              SET TO PROPER REGISTER\n         LA    R1,8(,R15)          GET POINTER TO DATA\n         BR    R14\nGPE$30   DC    H'0'\n         TITLE 'FIND INFO SUBROUTINE'\n*********************************************************************\n*\n* ROUTINE NAME -\n*    FINDINFO\n*\n* FUNCTION -\n*    FIND INFO ENTRY.\n*\n* OPERATION -\n*\n* ENTRY POINTS -\n*    FINDINFO\n*\n* EXTERNAL REFERENCES -\n*    NONE\n*\n* INPUT -\n*    REGISTER 1 POINTS TO THE INFO KEY.\n*\n* OUTPUT -\n*    REGISTER 1 POINTS TO EITHER THE REQUESTED KEY OR A BLANK ENTRY\n*    WHICH CAN BE USED TO CREATE THE KEY.\n*\n* MESSAGES -\n*    NONE\n*\n* COMMENTS -\n*    THIS SUBROUTINE ASSUMES THAT THERE WILL ALWAYS BE AT LEAST ONE\n*    BLANK SLOT DEMARKING THE END OF THE INFO BLOCK AND THAT THE\n*    APPEARENCE OF THE FIRST EMPTY SLOT IS THE END OF THE VALID\n*    ENTRIES.  (MAY CHANGE ALL THIS LATER)\n*\n*********************************************************************\nFINDINFO DS    0H\n         USING *,R15\n         USING EXTEX,R11\n         ST    R2,12(,R13)         RESTORE REGSITER\n         L     R2,ETAINFO          GET ADDRESS OF INFO BLOCK\nFINFLOOP DS    0H\n         CLI   0(R2),C' '          IS THIS THE END\n         BE    FINFBLNK            YES - LET HIM USE THIS SLOT\n         CLC   0(8,R1),0(R2)       NO - IS THIS THIS THE REQ'D KEY\n         BE    FINFEXIT            YES - GET OUT\n         LA    R2,80(,R2)          NO - POINT TO NEXT SLOT\n         B     FINFLOOP            AND LOOP\nFINFBLNK DS    0H\n         MVC   0(80,R2),=CL80' '   CLEAR OUT SLOT\n         MVC   0(8,R2),0(R1)       INSERT KEY\nFINFEXIT DS    0H\n         LR    R1,R2               POINT TO SLOT\n         L     R2,12(,R13)         RESTORE REGSITER\n         BR    R14                 RETURN TO CALLER\n         DROP  ,\n         TITLE 'TABLE OF USERIDS TO NEVER DENY'\nUSIDTABL DS    0C                  TABLE OF USERIDS TO NEVER DENY\n         DC    X'FF'               END OF TABLE\n         TITLE 'TABLE OF DIVISIONS AND COUNTS'\nDIVTABLE DS    0C                  TABLE OF DIVISIONS AND COUNTS\n         DC    C'R',AL1(25)        RESEARCH - 25\n         DC    X'FF'               END OF TABLE\n         TITLE 'MODEL INFO BLOCK'\nLINFMODL DC    0F'0',C' ',AL3(LENIMODL) FILL CHARACTER AND LENGTH\nINFOMODL DS    0C                  START OF MODEL FOR INFO BLOCK\nMUSERID  DC    CL80'USERID  '      USERID\nMNAME    DC    CL80'NAME    '      USER'S NAME\nMPHONE   DC    CL80'PHONE   '      BUSINESS PHONE\nMADDRESS DC    CL80'ADDRESS '      INTERNAL MAILING ADDRESS\nMLASTON  DC    CL80'LASTON  '      YY.DDD TERMINAL LAST LOGGED ON\nMCHGPSWD DC    CL80'CHGPSWD '      YY.DDD PASSWORD LAST CHANGED\nMCPUTIME DC    CL80'CPUTIME '      MAXIMUM CPU TIME\nMDEFTIME DC    CL80'DEFTIME '      DEFAULT CPU TIME\nMPROGNAM DC    CL80'PROGNAME'      PROGRAMMER'S NAME FOR JOBCARD\nMFORMS   DC    CL80'FORMS   '      FORMS FOR /*JOBPARM\nMROOM    DC    CL80'ROOM    '      ROOM FOR /*JOBPARM\nMLINECT  DC    CL80'LINECT  '      LINECT FOR /*JOBPARM\nLENIMODL EQU   *-INFOMODL          CALCULATE LENGTH OF INFO MODEL\n         SPACE 3\nTRTABLE  DC    C'0123456789ABCDEF' TRANSLATE HEX TO EBCDIC\n         LTORG ,\n         DROP  ,\n         TITLE 'GENERAL PURPOSE ESTAE ROUTINE'\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*    GP$ESTAE                                                         *\n*                                                                     *\n* FUNCTION -                                                          *\n*    ENTERED AFTER AN ABEND TO PASS CONTROL TO A RETRY ROUTINE.       *\n*                                                                     *\n* OPERATION -                                                         *\n*    1) CHECKS TO SEE IF SDWA WAS OBTAINED.  IF NOT, POINT TO RETRY   *\n*       ROUTINE, SAVE ABEND CODE AND RETURN TO ABEND.  IF SDWA WAS    *\n*       OBTAINED, SAVE ABEND CODE AND ISSUE SETRP MACRO TO RETURN TO  *\n*       ABEND SPECIFING RETRY ROUTINE.  IN EITHER CASE, DO NOT RETRY\n*       IF THIS IS A RECURSIVE ABEND.\n*    2) IF ABEND IS MOTHER TASK DETACH THEN INDICATE LOGON FAILED\n*       AND TERMINATE WITHOUT RETRY\n*    3) ISSUES MESSAGE TO TSO USER AND OPERATOR INDICATING TYPE OF\n*       ABEND AND DENIES LOGON.  IF ABEND U0522, SKIP MESSAGES AND\n*       DUMP.\n*    4) IF APF AUTHORIZED, TAKE SDUMP.\n*                                                                     *\n* ENTRY POINTS -                                                      *\n*    GP$ESTAE                                                         *\n*                                                                     *\n* EXTERNAL REFERENCES -                                               *\n*    NONE                                                             *\n*                                                                     *\n* INPUT -                                                             *\n*    IF NO SDWA WAS OBTAINED REGISTER 1 CONTAINS THE ABEND CODE.      *\n*    IF AN SDWA WAS OBTAINED REGISTER 1 CONTAINS THE ADDRESS OF THE   *\n*    SDWA.                                                            *\n*    ESTAE PARM => +0  RETRY ADDRESS                                  *\n*                  +4  PHASE DSA (ORIG R9)                            *\n*                  +8  EXIT TO EXIT AREA (ORIG R11)                   *\n*                  +12 ADDRESS OF ENTRY PARMS OF ROUTINE              *\n*                                                                     *\n* OUTPUT -                                                            *\n*    ADDDRESS OF RETRY ROUTINE.                                       *\n*                                                                     *\n* MESSAGES -                                                          *\n*    'LOGON USER EXIT ABEND TNNNN'\n*    'USER-ID ON TERMINAL LOGON USER EXIT ABEND TNNNN - ASID X'NN''\n*                                                                     *\n***********************************************************************\n         EJECT\nGP$ESTAE DS    0H\n         USING GP$ESTAE,R12        ESTABLISH EXIT ADDRESSABILITY\n         USING EXTEX,R11           ESTABLISH DYNAMIC ADDRESSABILITY\n         LR    R12,R15             LOAD BASE\n         EJECT\n***********************************************************************\n*                                                                     *\n*       CHECKS TO SEE IF SDWA WAS OBTAINED.  IF NOT, POINT TO RETRY   *\n*       ROUTINE, SAVE ABEND CODE AND RETURN TO ABEND.  IF SDWA WAS    *\n*       OBTAINED, SAVE ABEND CODE AND ISSUE SETRP MACRO TO RETURN TO  *\n*       ABEND SPECIFING RETRY ROUTINE.  IN EITHER CASE, DO NOT RETRY\n*       IF THIS IS A RECURSIVE ABEND.\n*                                                                     *\n***********************************************************************\n         LA    R15,12              GET 12 IN R15\n         CR    R0,R15              WAS SDWA OBTAINED\n         BNE   HAVESDWA            YES - BRANCH\n         L     R11,8(,R2)          GET ADDRESS OF EXTOEX AREA\n         L     R0,0(,R2)           POINT TO RETRY ROUTINE\n         ST    R1,ETABNDCD         SAVE ABEND CODE\n         XC    ETABNDPW,ETABNDPW   INDICATE PSW NOT AVAILABLE\n         LA    R15,4               INDICATE RETRY ROUTINE SUPPLIED\n         TM    ETBITS2,ET2ABEND    ABENDED BEFORE\n         BO    NOSDWA2             YES - ABEND RECURSION\n         OI    ETBITS2,ET2ABEND    NO - SET ABEND INDICATOR\n         BR    R14                 RETURN TO CALLER\nNOSDWA2  DS    0H\n         SLR   R15,R15             INDICATE NO RETRY\n         BR    R14                 RETURN TO CALLER\n         SPACE 3\nHAVESDWA DS    0H                  SDWA OBTAINED\n         STM   R14,R12,12(13)      SAVE ENTRY REGISTERS\n         L     R2,0(,R1)           GET ADDRESS OF PARAM LIST FROM SDWA\n         L     R11,8(,R2)          GET ADDRESS OF EXTOEX AREA\n         MVC   ETABNDCD,4(R1)      SAVE ABEND CODE\n         MVC   ETABNDPW,8(R1)      SAVE PSW\n         TM    ETBITS2,ET2ABEND    ABENDED BEFORE\n         BO    HAVSDWA2            YES - ABEND RECURSION\n         OI    ETBITS2,ET2ABEND    NO - SET ABEND INDICATOR\n         LR    R3,R1               SAVE SDWA ADDR\n         CLC   =X'5220',ETABNDCD+1 WAS THIS U0522\n         BE    NOSDUMP1            YES - SKIP MESSAGES AND SDUMP\n         EJECT\n********************************************************************\n*\n*       ISSUES MESSAGE TO TSO USER AND OPERATOR INDICATING TYPE OF\n*       ABEND AND DENIES LOGON.  IF ABEND U0522, SKIP MESSAGES AND\n*       SDUMP.\n*\n********************************************************************\n         MVC   ETMSGAR,ABNDMSG     NO - COPY ABEND MESSAGE\n         L     R15,ETABNDCD        GET COMPLETION CODE\n         SLL   R15,8               SHIFT OUT TCBFLGS1\n         SRL   R15,20              AND SHIFT OUT USER ABEND CODE\n         LTR   R15,R15             WAS IT SYSTEM ABEND CODE\n         BZ    USERABND            NO - MUST BE USER ABEND\n         MVI   ETMSGAR+22,C'S'     YES - INDICATE SYSTEM ABEND\n         STH   R15,ETWORK1         PUT COMPLETION CODE IN ETWORK1\n         UNPK  ETWORK1+3(5),ETWORK1(3) UNPACK\n         L     R1,=A(TRTABLE-240)\n         TR    ETWORK1+3(4),0(R1)\n         MVC   ETMSGAR+23(3),ETWORK1+4 MOVE TO MESSAGE\n         B     ABNDTPUT            GO TELL OPERATOR\nUSERABND DS    0H\n         MVI   ETMSGAR+22,C'U'     INDICATE USER ABEND\n         L     R15,ETABNDCD        GET COMPLETION CODE\n         SLL   R15,20              SHIFT OUT TCBFLGS1\n         SRL   R15,20              SHIFT BACK\n         CVD   R15,ETWORK1         CONVERT TO DECIMAL\n         OI    ETWORK1+7,X'0F'     FIX SIGN\n         UNPK  ETWORK1(5),ETWORK1+5(3) UNPACK\n         MVC   ETMSGAR+23(4),ETWORK1+1 MOVE TO ABEND MESSAGE\nABNDTPUT DS    0H\n         LA    R0,L'ABNDMSG        GET LENGTH FOR TPUT\n         LA    R1,ETMSGAR          POINT TO ABEND MESSAGE\n         TPUT  (1),(0),R           TELL USER\n         MVC   ETWORK1(5),ETMSGAR+22 SAVE ABEND CODE\n         MVC   ETMSGAR,ABNDWTO     COPY WTO TEXT TO DYNAMIC AREA\n         MVC   ETMSGAR+46(5),ETWORK1 COPY ABEND CODE\n         CLI   ETUSERID+1,0        HAS USERID BEEN RETRIEVED\n         BE    ABENDWTO            NO - LEAVE TEXT WITH 'UNKNOWN'\n         MVC   ETMSGAR+4(7),ETUSERID+2  YES - COPY TO WTO\nABENDWTO DS    0H\n         MVC   ETMSGAR+15(8),ETTERMID+2  TERMID TO DYNAMIC AREA\n         MVC   ETMSGAR+61(4),ETASIDE COPY ASID TO DYNAMIC AREA\n         WTO   MF=(E,ETMSGAR)      TELL OPERATOR\n         EJECT\n********************************************************************\n*\n*       TAKE SDUMP ON FAILURE OF THIS ROUTINE\n*\n********************************************************************\n         LH    R15,ETMSGAR         YES - GET LENGTH OF WTO\n         SH    R15,=H'4'           GET LENGTH OF TEXT\n         STC   R15,ETMSGAR+3       SET UP FOR SDUMP\n         L     R1,=A(SDUMP)        POINT TO PARM LIST\n         MVC   ETSDUMP,0(R1)       COPY SDUMP PARAMETER LIST\n         L     R1,=A(KEYZERO)      POINT AT PARM LIST\n         MODESET MF=(E,(1))        GET KEY 0 FOR SDUMP CALL\n         LA    R1,ETSDUMP          POINT TO SDUMP PARAMETER LIST\n         SDUMP HDRAD=ETMSGAR+3,MF=(E,(1)) TAKE SDUMP\n         L     R1,=A(NONZERO)      POINT AT PARM LIST\n         MODESET MF=(E,(1))        RESTORE TCB KEY\nNOSDUMP1 DS    0H\n         EJECT\n********************************************************************\n*\n*       RETURN TO THE SYSTEM VIA THE SETRP MACRO\n*\n********************************************************************\n         MVC   ETRUB(2),=X'0075'   RESTORE REGS 9,10,11,13,15\n         MVC   ETRUB+2(4),4(R2)    GET PHASE DSA TO R9\n         MVC   ETRUB+14(4),4(R2)     AND R13\n         MVC   ETRUB+10(4),8(R2)   GET EXTOEX AREA TO R11\n         MVC   ETRUB+6(4),12(R2)   GET INPUT PARMS TO R10\n         MVC   ETRUB+18(4),0(R2)   GET RETRY ADDRESS TO R12\n         LR    R1,R3               RESTORE SDWA ADDR\n         L     R2,0(,R2)           GET RETRY ADDRESS\n         SETRP REGS=(14,12),RC=4,RETADDR=(R2),FRESDWA=YES,             X\n               RUB=ETRUB,RETREGS=YES\nHAVSDWA2 DS    0H\n         SETRP REGS=(14,12),RC=0   DO NOT RETRY\n         SPACE 3\n*                          1         2\n*                012345678901234567890123456\nABNDMSG  DC    C'LOGON USER EXIT ABEND      '\n*                     1         2         3         4         5\n*               4567890123456789012345678901234567890123456789012345678\nABNDWTO  WTO   'UNKNOWN ON TERMINAL LOGON USER EXIT ABEND       - ASID X\n               X''NNNN''',DESC=2,ROUTCDE=(2,11),MF=L\n*              90 123\n*               6\nLABNDWTO EQU   *-ABNDWTO           CALCULATE LENGTH OF WTO MESSAGE\n         LTORG ,\n         DROP  ,\n         EJECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nKBIT0    EQU   X'80'\nKBIT1    EQU   X'40'\nKBIT2    EQU   X'20'\nKBIT3    EQU   X'10'\nKBIT4    EQU   X'08'\nKBIT5    EQU   X'04'\nKBIT6    EQU   X'02'\nKBIT7    EQU   X'01'\n         TITLE 'EXIT-TO-EXIT WORK AREA'\nEXTEX    DSECT\nETID     DS    CL7                 EYEBALL ID\nETTEST   DS    CL1\nETASIDE  DS    CL4                 ASID IN HEX EBCDIC\nETLTIME  DS    2F                  LOGON TIME/DATE\nETTIME   EQU   ETLTIME,4\nETDATE   EQU   ETLTIME+4,4\nETMYKEY  DS    3F                  MY KEY,LENGTH,DATA FOR EXTOEX\nETHSKEY  DS    3F                  HIS(TEST) KEY,LENGTH,DATA FOR EXTOEX\nETUADSIZ DS    F                   SIZE OF CORE FOR UADS BLOCKS\nETUADADR DS    F                   START OF CORE FOR UADS BLOCKS\nETAASKB  DS    F                   ADDRESS OF ASKBACK BLOCK\nETLASKB  DS    F                   LENGTH OF ASKBACK BLOCK\nETATERM  DS    F                   ADDRESS OF TERMINAL BLOCK\nETLTERM  DS    F                   LENGTH OF TERMINAL BLOCK\nETAINFO  DS    F                   ADDRESS OF USER INFO BLOCK\nETLINFO  DS    F                   LENGTH OF USER INFO BLOCK\nETAJCL   DS    F                   ADDRESS OF NEW JCL AREA\nETCDCNT  DS    F                   NUMBER OF JCL STATEMENTS GEND\nETCDMAX  DS    F                   MAX NUMBER OF JCL STMTS\n         SPACE 5\n*        THE FOLLOWING STORAGE IS FOR ESTAE AND RECOVERY ROUTINES\nETWORK1  DS    D                   GENERAL WORK AREA\nETESTPM  DS    4F                  ESTAE EXIT PARAMETER LIST\nETABNDCD DS    F                   ABEND CODE FROM ESTAE EXIT\nETABNDPW DS    CL8                 ABEND PSW FROM ESTAE EXIT\nETRUB    DS    H,5F                REGS 9,10,11,13,15\n         SPACE 5\n* THE FOLLOWING STORAGE IS FOR SDUMP\n         DS    0F                  ALIGNMENT\nETSDUMP DS     XL(LSDUMP)          SDUMP PARAMETER LIST\n         SPACE 5\n*        THE FOLLOWING STORAGE IS FOR UADS DATASET ACCESS\nETOPENL  DS    F                   OPEN LIST\nETTTRINF DS    F                   TTR OF INFO BLOCK\nETTTRTRM DS    F                   TTR OF TERMINAL BLOCK\nETTTRASK DS    F                   TTR OF ASKBACK BLOCK\nETMEMBER DS    CL8                 MEMBER NAME FROM BLDL\nETINFOID DS    CL8                 ID OF UADS INFO BLOCK\nETUADS   DS    XL(LSYSUADS)        DCB FOR SYS1.UADS\n         READ  ETDECB,SF,MF=L      READ/WRITE ETDECB LIST\nETEXLST  DS    F                   DCB EXIT LIST FOR RDJFCB\nETJFCB   DS    XL176               JFCB AREA\nETAUCB   DS    F                   SYS1.UADS UCB FOR RESERVE\n         SPACE 5\n*        INFO FROM LOGON PROCESSING\n*  IBM BASIC VALUES FOR LOGON\nETUSERID DS    H,CL7               USERID\nETTERMID DS    H,CL8               TERMINAL NAME\n*  IBM ITEMS NEEDED FOR JCL\nETPROC   DS    H,CL8               PROCEDURE NAME\nETACCNT  DS    H,CL40              ACCOUNT NUMBER\nETSIZE   DS    H,CL7               REGION SIZE\nETPERFG  DS    H,CL3               PERFORMANCE GROUP\n*  BFG ITEMS NEEDED FOR JCL - FROM PANEL OR LOGON CMD ONLY\nETMSGC   DS    H,C                 MESSAGE CLASS VALUE\nETMSGL   DS    H,CL8               MESSAGE LEVEL VALUE\nETCOPY   DS    H,CL3               COPIES VALUE\n*  BFG ITEMS NEEDED FOR JCL - FROM PANEL, INFO, OR LOGON CMD\nETPRGNM  DS    H,CL20              PROGRAMMER NAME\nETCPTIM  DS    H,CL4               CPU TIME\nETADDRS  DS    H,CL60              ADDRESS LINE\nETROOM   DS    H,CL4               ROOM NUMBER\nETFORM   DS    H,CL4               FORM CODE\nETLINCT  DS    H,CL3               LINE COUNT VALUE\nETPHONE  DS    H,CL15              FORM CODE\nETNAME   DS    H,CL60              FORM CODE\n         SPACE 5\n*        FLAGS FOR CONTROLS\nETBITS1  DS    X                   FLAGS\nET1DENY  EQU   X'80'               DENY LOGON REQUEST\nET1ATTN  EQU   X'01'               ATTENTION HIT DURING PROMPT\nETBITS2  DS    X                   FLAGS\nET2SPFRS EQU   X'80'               DSN RESERVED\nET2SPFE0 EQU   X'40'               MEMBER0 ENQ'D ON\nET2SPFEI EQU   X'20'               INFO BLOCK ENQ'D ON\nET2UADRS EQU   X'10'               SYSIKJUA/OPENUADS RESERVED\nET2ABEND EQU   X'08'               ABEND HAS ALREADY OCCURED\nET2DSPLY EQU   X'04'               TERMINAL IS DISPLAY TYPE\nET2ASKB  EQU   X'02'               ASKBACK IS IN PROGRESS\nETBITS3  DS    X                   LOGON COMMAND FLAGS\nET3DEBUG EQU   X'80'               DEBUG SPECIFIED\nET3JCL   EQU   X'40'               JCL REQUESTED\nET3LSTIN EQU   X'20'               LISTINFO REQUESTED\n         SPACE 5\n* THE FOLLOWING STORAGE IS THE MESSAGE AREA\n         DS    0F\nETMSGAR  DS    CL100               MESSAGE AREA\nEXTEXL   EQU   *-EXTEX\n         TITLE 'SYSTEM DSECTS AND CONTROL BLOCKS'\n         PUSH  PRINT\n         PRINT NOGEN\n         IKJCPPL ,\n         DS    0F\nLCPPL    EQU   *-CPPL\n         SPACE 3\nCBUF     DSECT COMMAND BUFFER DSECT\nCBUFLEN  DS    H\nCBUFOFFS DS    H\nCBUFTEXT DS    C\n         SPACE 3\nAEPL     DSECT\nAEPLTAIE DS    F                   ADDRESS OF THE TAIE\nAEPLIBUF DS    F                   ADDRESS OF IBUF\nAEPLUSAD DS    F                   ADDRESS OF USER AREA\n         SPACE 3\n         IKJTAIE ,                 GENERATE TAIE DSECT\n         SPACE 3\n         IKJEFFGF GFDSECT=YES\n         SPACE 3\n         IKJCSPL ,\n         DS    0F\nLCSPL    EQU   *-CSPL\n         SPACE 3\n         IKJCSOA ,\n         DS    0F\nLCSOA    EQU   *-CSOA\n         SPACE 3\n         IKJPPL ,\n         DS    0F\nLPPL     EQU   *-PPL\n         SPACE 3\n         IKJIOPL ,\n         DS    0F\nLIOPL    EQU   *-IOPL\n         SPACE 3\n         IKJPGPB ,                 GENERATE PGPB DSECT\n         DS    0F\nLPGPB    EQU   *-PGPB              CALCULATE LENGTH OF PGPB\n         SPACE 3\n         IKJECT\n         SPACE 3\n         IKJPSCB\n         SPACE 3\n         IKJTSB\n         SPACE 3\n         CVT   DSECT=YES\n         SPACE 3\n         DCBD  DSORG=PS,DEVD=DA\n         SPACE 3\n         IHAPSA ,\n         SPACE 3\n         IHAASVT ,\n         SPACE 3\n         IHAASCB ,\n         SPACE 3\n         IKJTCB  ,\n         SPACE 3\n         IEZJSCB ,\n         SPACE 3\n         IHARB   ,\n         SPACE 3\n         IHASDWA ,\n         POP   PRINT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IKJEXIT1": {"ttr": 3077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x91$\\x7f\\x00\\x91&O\\x198\\t\\xea\\t\\xea\\x00\\n\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1991-09-04T00:00:00", "modifydate": "1991-09-21T19:38:00", "lines": 2538, "newlines": 2538, "modlines": 10, "user": "SALBERT"}, "text": "IKJEXIT TITLE 'TSO/E RELEASE 4 INSTALLATION EXIT EXAMPLE'\nIKJEXIT CSECT ,\n        PRINT NOGEN\nIKJEXIT AMODE 31                     EXIT'S ADDRESSING MODE\nIKJEXIT RMODE ANY                    EXIT'S RESIDENCY  MODE\n TITLE 'TSO/E RELEASE 4 INSTALLATION EXIT EXAMPLE PROLOGUE'\n***********************************************************************\n*                                                                     *\n* MODULE NAME - IKJEXIT                                               *\n*                                                                     *\n* CSECT  NAME - IKJEXIT                                               *\n*                                                                     *\n* DESCRIPTIVE NAME - TSO/E INSTALLATION EXIT EXAMPLE                  *\n*                                                                     *\n* FUNCTION -                                                          *\n*                                                                     *\n*  THIS ROUTINE IS AN EXAMPLE OF HOW A TSO/E INSTALLATION EXIT        *\n*  MIGHT BE CODED USING THE NEW TSO/E INSTALLATION EXIT               *\n*  PARAMETER_ENTRY ARCHITECTURE.                                      *\n*                                                                     *\n*  THE PARTICULAR FUNCTION OF THIS ROUTINE IS TO TAKE THE STANDARD    *\n*  TSO/E INSTALLATION EXIT PARAMETER LIST AND PERFORM THE FOLLOWING   *\n*  FUNCTIONS:                                                         *\n*                                                                     *\n*   1). IDENTIFY EVERY PARAMETER_ENTRY BY ASSOCIATING A HEX NUMBER TO *\n*       THE PARAMETER_ENTRY CURRENTLY BEING PROCESSED.                *\n*       (I.E. THE OUTPUT FOR PARAMETER_ENTRY 1 WOULD BE               *\n*             \"PARAMETER_ENTRY_01\" OR \"PE01\")                         *\n*                                                                     *\n*   2). DISPLAY THE DATA ASSOCIATED WITH EACH PARAMETER_ENTRY FIELD.  *\n*       (I.E. THE ACTUAL VALUES THAT ARE CONTAINED WITHIN THE         *\n*             PARAMETER_ENTRY_KEY AND THE PARAMETER_ENTRY_LENGTH      *\n*             FIELDS. THE VALUE FOR THE PARAMETER_ENTRY_DATA FIELD    *\n*             ALWAYS DESCRIBES THE BEGINNING ADDRESS OF WHERE THE     *\n*             DATA ACTUALLY RESIDES.)                                 *\n*                                                                     *\n*   3). DETECTS ERRORS ASSOCIATED WITH THE PARAMETER_ENTRY_KEY AND    *\n*       PARAMETER_ENTRY_LENGTH FIELDS OF THE PARAMETER_ENTRY.         *\n*       IF ANY ERRORS ARE FOUND, INFORMATIONAL ERROR MESSAGES         *\n*       ARE DISPLAYED.                                                *\n*                                                                     *\n*  *******************                                                *\n*  ***             ***                                                *\n*  ***    NOTE     ***                                                *\n*  ***             ***                                                *\n*  *******************                                                *\n*                                                                     *\n*      FOR A DESCRIPTION OF THE:                                      *\n*                                                                     *\n*      PARAMETER_ENTRY                                                *\n*      PARAMETER_ENTRY_KEY                                            *\n*      PARAMETER_ENTRY_LENGTH                                         *\n*      PARAMETER_ENTRY_DATA                                           *\n*                                                                     *\n*      PLEASE REFER TO INPUT SECTION OF THIS PROLOGUE.                *\n*                                                                     *\n*  *******************                                                *\n*  ***             ***                                                *\n*  *** END OF NOTE ***                                                *\n*  ***             ***                                                *\n*  *******************                                                *\n*                                                                     *\n* OPERATION - IKJEXIT PERFORMS THE FOLLOWING FUNCTION:                *\n*                                                                     *\n*    1 - ESTABLISHES SAVE AREA TO CALLING PROGRAM                     *\n*    2 - SAVES PARAMETER POINTER (R1)                                 *\n*    3 - DOES A GETMAIN FOR PROGRAM'S SAVE AREA                       *\n*    4 - CHAINS THE CALLER'S SAVE AREA AND THIS SAVE AREA             *\n*    5 - DOES A GETMAIN FOR PROGRAM'S WORK AREA                       *\n*    6 - DETERMINES WHETHER TO USE PUTLINE OR WTO                     *\n*    7 - HEX FORMATS THE PARAMETER ENTRIES                            *\n*    8 - IDENTIFIES THE HEX PARAMETER ENTRIES                         *\n*    9 - PRINTS ALL OF THE PARAMETER ENTRIES VIA PUTLINE OR WTO       *\n*   10 - DOES A FREEMAIN OF DYNAMIC STORAGE                           *\n*   11 - DOES A FREEMAIN OF DYNAMIC SAVE AREA                         *\n*   12 - LOADS REGISTER 14 WITH RETURN ADDRESS                        *\n*   13 - SETS THE RETURN CODE IN REGISTER 15 (ALWAYS RC=0)            *\n*   14 - LOADS REGISTERS R0 - R12 WITH CALLER'S ENTRY CONTENTS        *\n*   15 - RETURNS TO CALLER                                            *\n*                                                                     *\n* RECOVERY OPERATION -                                                *\n*                                                                     *\n*          MUST BE ESTABLISHED BY INVOKER OF IKJEXIT                  *\n*                                                                     *\n* NOTES                                                               *\n*                                                                     *\n*                                                                     *\n* DEPENDENCIES - MAY ONLY BE ASSEMBLED WITH ASSEMBLER H               *\n*                                                                     *\n* RESTRICTIONS - THIS EXAMPLE TSO/E INSTALLATION EXIT IS VALID        *\n*                ONLY FOR THE NEW TSO/E INSTALLATION EXITS            *\n*                THAT HAVE BEEN INTRODUCED IN THE TSO/E RELEASE       *\n*                4 PRODUCT.                                           *\n*                                                                     *\n*                PLEASE REFER TO THE TSO/E CUSTOMIZATION MANUAL       *\n*                FOR INFORMATION REGARDING THESE TSO/E INSTALLATION   *\n*                EXITS.                                               *\n*                                                                     *\n* ERROR MESSAGES - NONE                                               *\n*                                                                     *\n* ABEND CODES - NONE                                                  *\n*                                                                     *\n* ERROR CONDITIONS - NONE                                             *\n*                                                                     *\n* LINKAGES: BRANCHED TO VIA BALR OR LINKED TO                         *\n*                                                                     *\n* MODULE(S) CALLED: NONE                                              *\n*                                                                     *\n* ENTRY POINT - IKJEXIT                                               *\n*                                                                     *\n* EXIT CONDITIONS                                                     *\n*                                                                     *\n*        EXIT IS ACCOMPLISHED VIA BSM                                 *\n*                                                                     *\n* REFERENCES                                                          *\n*                                                                     *\n*        ROUTINES   - NONE                                            *\n*                                                                     *\n*        DATA AREAS - NONE                                            *\n*                                                                     *\n*    CONTROL BLOCKS - CVT,                                            *\n*                     IKJTSVT,                                        *\n*                     IKJCPPL,                                        *\n*                     IKJIOPL                                         *\n*                                                                     *\n*        TABLES     - NONE                                            *\n*                                                                     *\n* GLOBALS:                                                            *\n*                                                                     *\n*       NONE                                                          *\n*                                                                     *\n TITLE 'MACROS IKJEXIT ISSUES'\n* MACRO USAGE: SAVE,                                                  *\n*              GETMAIN,                                               *\n*              FREEMAIN,                                              *\n*              PUTLINE,                                               *\n*              WTO                                                    *\n*                                                                     *\n TITLE 'IKJEXIT MODULE ATTRIBUTES'\n* MODULE ATTRIBUTES - REENTRANT,                                      *\n*                     REFRESHABLE,                                    *\n*                     REUSEABLE,                                      *\n*                     AMODE(ANY),                                     *\n*                     RMODE(31),                                      *\n*                     MAY BE LINKED AC=1                              *\n*                                                                     *\n TITLE 'INPUT REQUIREMENTS TO IKJEXIT'\n* INPUT - ON ENTRY TO IKJEXIT R1 MUST POINT TO A VARIABLE LENGTH      *\n*         PARAMETER LIST THAT DESCRIBES A PARAMETER_ENTRY LIST.       *\n*                                                                     *\n*         THE HIGH ORDER BIT IN THE LAST PARAMETER                    *\n*         OF THE PARAMETER LIST MUST BE ON                            *\n*         X'80000000' TO INDICATE THE END OF THE LIST.                *\n*                                                                     *\n TITLE 'TSO/E STANDARD INSTALLATION EXIT PARAMETER_ENTRY '\n*                                                                     *\n*             PARAMETER_ENTRY                                         *\n*                                                                     *\n*             FIELD  FIELD   FIELD                                    *\n*                                                                     *\n*     P       P      P       P                                        *\n*     A       A      A       A                                        *\n*     R       R E    R E L   R E                                      *\n*     A       A N K  A N E   A N D                                    *\n*     M       M T E  M T N   M T A                                    *\n*     E L     E R Y  E R G   E R T                                    *\n*     T I     T Y    T Y T   T Y A                                    *\n*     E S     E      E   H   E              +0                        *\n*  R1 R T     R      R       R              +------------+            *\n*   |                            +--------->|  DATA      |            *\n*   V         +0    +4       +8  |          +------------+            *\n* +--------+  +-----+--------+---+---------+                          *\n* | PARM1  |->| KEY | LENGTH | PTR TO DATA |                          *\n* +--------+  +-----+--------+---------/ /--------------------------+ *\n* | PARM2  |->| KEY | LENGTH | DATA   / / DATA                      | *\n* +--------+  +-----+--------+-------/ /----------------------------+ *\n* | PARM3  |->| KEY | LENGTH | DATA   / / DATA                      | *\n* +--------+  +-----+--------+-------/ /----------------------------+ *\n* | PARM4  |->| KEY | LENGTH | DATA   / / DATA                      | *\n* +--------+  +-----+--------+-------/ /----------------------------+ *\n* | PARM5  |->| KEY | LENGTH | DATA   / / DATA                      | *\n* +--------+  +-----+--------+-------/ /----------------------------+ *\n* | PARM6  |->| KEY | LENGTH | DATA   / / DATA                      | *\n* +--------+  +-----+--------+-------/ /----------------------------+ *\n* | PARM7  |->| KEY | LENGTH | DATA   / / DATA                      | *\n* +--------+  +-----+--------+-------/ /----------------------------+ *\n*     .                                                               *\n*     .                                                               *\n*     .                                                               *\n*     .                                                               *\n* +--------+  +-----+--------+-------/ /----------------------------+ *\n* | PARMZZ |->| KEY | LENGTH | DATA   / / DATA                      | *\n* +--------+  +-----+--------+-------/ /----------------------------+ *\n* |8XXXXXXX|->| KEY | LENGTH | DATA   / / DATA                      | *\n* +A-------+  +-----+--------+-------/ /----------------------------+ *\n*  |                                                                  *\n*  8 INDICATES END OF PARAMETER LIST                                  *\n*                                                                     *\n TITLE 'OUTPUT GENERATED BY IKJEXIT'\n* OUTPUT -                                                            *\n*                                                                     *\n*  THE OUTPUT OF THIS TSO/E INSTALLATION EXIT EXAMPLE IS:             *\n*                                                                     *\n*  IKJEXIT                                                            *\n*                                                                     *\n*  PARAMETER_ENTRY_ZZ IS AT -> X..X  (ADDRESS OF WHERE THE            *\n*                                    PARAMETER_ENTRY STARTS)          *\n*                                                                     *\n*  PE_ZZ KEY -> X..X LENGTH OF DATA -> X..X ADDRESS OF DATA -> X..X   *\n*  DATA   +00000000  E3C8C9E2  40C9E240  E3C8C540  C4C1E3C1           *\n*         +00000010  40C6D6D9  40E3C8C9  E340C5E7  C1D4D7D3           *\n*         +00000020  C5                                               *\n*                                                                     *\n*       .                                                             *\n*       .                                                             *\n*       .                                                             *\n*       .                                                             *\n*                                                                     *\n*                                                                     *\n*  PARAMETER_ENTRY_ZZ IS AT -> X..X  (ADDRESS OF WHERE THE            *\n*                                    PARAMETER_ENTRY STARTS)          *\n*                                                                     *\n*  PE_ZZ KEY -> X..X LENGTH OF DATA -> X..X ADDRESS OF DATA -> X..X   *\n*  DATA   +00000000  E3C8C9E2  40C9E240  E3C8C540  C4C1E3C1           *\n*         +00000010  40C6D6D9  40E3C8C9  E340C5E7  C1D4D7D3           *\n*         +00000020  C5                                               *\n*                                                                     *\n*                                                                     *\n         EJECT\n*  *******************                                                *\n*  ***             ***                                                *\n*  ***    NOTE     ***                                                *\n*  ***             ***                                                *\n*  *******************                                                *\n*                                                                     *\n*    THE ZZ FIELDS IN THE ABOVE EXAMPLE OUTPUT WOULD INDICATE         *\n*    WHICH PARAMETER_ENTRY IS CURRENTLY BEING DISPLAYED.              *\n*                                                                     *\n*    THE ZZ FIELDS WILL START AT \"01\" AND CONTINUE THROUGH \"FF\".      *\n*    IF THERE ARE MORE THAN 255 PARAMETER ENTRIES, THE ZZ FIELD       *\n*    WILL START OVER AT 00.                                           *\n*                                                                     *\n*    THE X..X FIELDS WILL BE  FULL WORDS IN ALL CASES                 *\n*                                                                     *\n*    PARAMETER_ENTRY_KEY                                              *\n*    VALUE      MEANING                                               *\n*                                                                     *\n*    00000000 - THE INSTALLATION EXIT DID NOT PASS ANY DATA FOR       *\n*               THIS INSTALLATION EXIT PARAMETER_ENTRY.               *\n*                                                                     *\n*    00000001 - DATA BEGINS AT THIS PARAMETER_ENTRY_DATA FIELD        *\n*               AND CONTINUES CONTIGUOUSLY FOR A LENGTH AS            *\n*               DESCRIBED BY THE PARAMETER_ENTRY_LENGTH FIELD         *\n*                                                                     *\n*    00000002 - DATA IS POINTED TO FROM THE PARAMETER_ENTRY_DATA      *\n*               FIELD AND CONTINUES CONTIGUOUSLY FOR A LENGTH AS      *\n*               DESCRIBED BY THE PARAMETER_ENTRY_LENGTH FIELD         *\n*                                                                     *\n*    00000003 - SPECIAL KEY. ONLY VALID FOR SOME SELECTED TSO/E       *\n*               INSTALLATION EXITS. SEE THE TSO/E CUSTOMIZATION       *\n*               MANUAL FOR INFORMATION REGARDING THE USAGE OF         *\n*               THIS KEY.                                             *\n*                                                                     *\n*    IN THE EXAMPLE OUTPUT IN THE PROLOGUE THE                        *\n*                                                                     *\n*    PARAMETER_ENTRY_KEY COULD BE EITHER A '00000001' OR A            *\n*    '00000002'                                                       *\n*                                                                     *\n*    PARAMETER_ENTRY_LENGTH WOULD CONTAIN THE VALUE '00000021'        *\n*                                                                     *\n* AND THE ACTUAL DATA WOULD BE:                                       *\n*                                                                     *\n*                                                                     *\n*          \"THIS IS THE DATA FOR THIS EXAMPLE\"                        *\n*                                                                     *\n* IF AN ERROR FOR THE PARAMETER_ENTRY_KEY OR THE                      *\n* PARAMETER_ENTRY_LENGTH FIELD IS DETECTED, THE PARAMETER_ENTRY_KEY,  *\n* PARAMETER_ENTRY_LENGTH AND THE PARAMETER_ENTRY_DATA VALUES WILL BE  *\n* FORMATTED AS DESCRIBED ABOVE.                                       *\n*                                                                     *\n* IKJEXIT STOPS PROCESSING OF THE \"DATA +00000000\" MESSAGES AND       *\n* DISPLAYS INFORMATIONAL MESSAGES.  IKJEXIT THEN PROCESSES THE NEXT   *\n* PARAMETER_ENTRY, IF ONE IS AVAILABLE.                               *\n*                                                                     *\n*  *******************                                                *\n*  ***             ***                                                *\n*  *** END OF NOTE ***                                                *\n*  ***             ***                                                *\n*  *******************                                                *\n*                                                                     *\n  TITLE 'CHANGE ACTIVITY FOR IKJEXIT'\n*                                                                     *\n* CHANGE ACTIVITY:                                                    *\n*                                                                     *\n*      INTRODUCED IN TSO/E RELEASE 4 HTE1402                          *\n*                                                                     *\n* OY19583 - FIX &SYSDATE SO THE EXIT WILL ASSEMBLE USING THE          *\n*           REQUIRED ASSEMBLERH. FIX A LOGIC ERROR IN THE EXIT        *\n*           THAT CAUSES AN ABEND0C4.                          @YA19583*\n*                                                                     *\n* OY19658 - AT LABEL GOT_CPPLECT CHANGE CPPLUPT TO CPPLECT    @YA19658*\n*                                                                     *\n***********************************************************************\n TITLE 'REGISTER EQUATES'\n***********************************************************************\n* REGISTER EQUATES FOLLOW                                             *\n***********************************************************************\n*     REGISTER EQUATES AND USAGE                                      *\n*                                                                     *\n         SPACE 3\nR0       EQU   0                     UNPREDICTABLE\nR1       EQU   1                     ON ENTRY R1 POINTS TO THE\n*                                    PARAMETER LIST. AT OTHER TIMES\n*                                    THE VALUE OF R1 IS UNPREDICTABLE\nR2       EQU   2                     UNPREDICTABLE\nR3       EQU   3                     UNPREDICTABLE\nR4       EQU   4                     UNPREDICTABLE\nR5       EQU   5                     UNPREDICTABLE\nR6       EQU   6                     UNPREDICTABLE\nR7       EQU   7                     UNPREDICTABLE\nR8       EQU   8                     UNPREDICTABLE\nR9       EQU   9                     UNPREDICTABLE\nR10      EQU   10                    OUTPUT BUFFER\nR11      EQU   11                    DATA AREA BASE REGISTER\nR12      EQU   12                    CODE AREA BASE REGISTER\nR13      EQU   13                    SAVE AREA BASE REGISTER\nR14      EQU   14                    RETURN ADDRESS\nR15      EQU   15                    RETURN CODE\n TITLE 'COMMON EQUATES  '\n***********************************************************************\n* COMMON EQUATES USED THROUGHOUT THIS MODULE FOLLOW                   *\n***********************************************************************\n         SPACE 3\nISSUE_PUTLINE_INDICATOR    EQU   X'00'  INDICATES TO USE PUTLINE TO\n*                                       DISPLAY MESSAGES\nGOOD_KEY_INDICATOR         EQU   X'00'  INDICATES THAT A VALID\n*                                       KEY HAS BEEN FOUND OR ASSUMED\n*                                       FOR THIS PARAMETER_ENTRY\n*                                       PARAMETER_ENTRY_KEY FIELD\nBAD_KEY_INDICATOR          EQU   X'01'  INDICATES THAT AN INVALID\n*                                       OR UNDEFINED KEY WAS FOUND IN\n*                                       PARAMETER_ENTRY_KEY FIELD\nISSUE_WTO_INDICATOR        EQU   X'02'  INDICATES TO USE WTO TO DISPLAY\n*                                       MESSAGES\nBLANK                      EQU   X'40'\nPLUS_SIGN                  EQU   X'4E'  +\nHEX54                      EQU   X'54'\n*                                       LENGTH OF MESSAGE TO BE PUT\n*                                       INTO PTPB\nHEX80                      EQU   X'80'\n*                                       USED TO SEE IF THE BIT IS ON\n*                                       FOR THE LENGTH AND THE\n*                                       PARAMETER LIST\n TITLE 'ENTRY CODE      '\n***********************************************************************\n* IKJEXIT ENTRY CODE                                                  *\n*                                                                     *\n* DESCRIPTIVE NAME - STANDARD ENTRY LINKAGE CODE ROUTINE              *\n*                                                                     *\n* FUNCTION - ESTABLISHES STANDARD LINKAGE BETWEEN PROGRAMS            *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*    1).  PERFORMS STANDARD LINKAGE BETWEEN INVOKER OF EXIT AND       *\n*         EXIT.                                                       *\n*    2).  OBTAINS A DYNAMIC SAVE AREA FOR THE EXIT AND                *\n*         ESTABLISHES THIS AS THE SAVE AREA FOR THE EXIT              *\n*    3).  OBTAINS EXIT'S DYNAMIC WORK AREA STORAGE AND                *\n*         ESTABLISHES THIS AS THE WORK AREA FOR THE EXIT              *\n*                                                                     *\n***********************************************************************\nIKJEXIT CSECT\n         ENTRY IKJEXIT\n         SAVE  (14,12),,IKJEXIT____TSO/E_INSTALLATION_EXIT_EXAMPLE_____X\n               _____________________________________________&SYSDATE.__X\n               &SYSTIME              BUILD MODULE ID EYE CATCHER\n*                                                              @YA19583\n         LR    R12,R15\n*                                    LOAD R12 TO CONTAIN THE\n*                                    ENTRY POINT ADDRESS OF IKJEXIT\n*\n         USING IKJEXIT,R12\n*                                    ESTABLISH R12 TO BE THE\n*                                    PROGRAM'S BASE CODE REGISTER\n*\n         LR    R2,R1\n*                                    SAVE THE ADDRESS OF THE PARAMETER\n*                                    LIST\n*\n         GETMAIN RU,LV=L_SAVE_AREA,LOC=(BELOW,ANY)\n*                                    OBTAIN A DYNAMIC SAVE AREA\n*                                    FOR IKJEXIT AND MAKE SURE\n*                                    THE SAVE AREA IS BELOW 16\n*                                    MEGABYTES IN VIRTRUAL STORAGE\n*\n         ST    R13,4(,R1)\n*                                    SAVE THE ADDRESS OF THE INVOKER'S\n*                                    SAVE AREA INTO IKJEXIT'S DYNAMIC\n*                                    SAVE AREA\n*\n         ST    R1,8(,R13)\n*                                    SAVE THE ADDRESS OF IKJEXIT'S\n*                                    SAVE AREA INTO THE INVOKER'S\n*                                    SAVE AREA\n*\n         LR    R13,R1\n*                                    LOAD THE ADDRESS OF IKJEXIT'S\n*                                    DYNAMIC SAVE AREA INTO R13\n*                                    FOR POSSIBLE NEXT CALLER'S USE\n*\n         USING SAVE_AREA,R13\n*                                    ESTABLISH ADDRESSABILITY TO\n*                                    IKJEXIT'S SAVE AREA SO THAT THE\n*                                    LABELS WITHIN THE SAVE AREA\n*                                    CAN BE USED IF NEEDED\n*\n         GETMAIN RU,LV=TLEN,LOC=(BELOW,ANY),SP=1\n*                                    OBTAIN THE DYNAMIC WORK AREA\n*                                    FOR IKJEXIT IN SUBPOOL 1 AND\n*                                    MAKE SURE IT IS BELOW 16\n*                                    MEGABYTES IN VIRTRUAL STORAGE\n*\n         LR    R11,R1\n*                                    LOAD THE ADDRESS OF THE DYNAMIC\n*                                    WORK AREA INTO R11 FOR IKJEXIT'S\n*                                    USE\n*\n         USING WORKA,R11\n*                                    AND ESTABLISH ADDRESSABILITY\n*                                    TO THE DYNAMIC WORK AREA SO THAT\n*                                    THE LABELS WITHIN THE WORK AREA\n*                                    CAN BE ADDRESSED\n*\n         ST    R1,GM_PTR\n*                                    SAVE THE ADDRESS OF IKJEXIT'S\n*                                    DYNAMIC SAVE AREA FOR LATER USE\n*\n         ST    R2,R1_ENTRY_PARAMETER_LIST_PTR\n*                                    SAVE THE ADDRESS OF THE PARAMETER\n*                                    LIST THAT THE INVOKER OF IKJEXIT\n*                                    PASSED IN FOR LATER USE\n*\n         MVC   WORK_AREA_ID,WORKAREA_ID_CONSTANT\n*                                    PUT INTO THE FIRST 8 POSITIONS OF\n*                                    THE IKJEXIT'S DYNAMIC WORK AREA\n*                                    THE CHARACTERS \"WORKAREA\" SO THAT\n*                                    IT CAN BE EASILY FOUND IN A DUMP\n*\n TITLE 'INITIALIZATION CODE'\n***********************************************************************\n*                                                                     *\n* INITIALIZATION ROUTINE                                              *\n*                                                                     *\n* DESCRIPTIVE NAME - INITIALIZATION  CODE                             *\n*                                                                     *\n* FUNCTION - INITIALIZES THE DYNAMIC STORAGE AREA                     *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*                                                                     *\n*    1).  ENSURES THE RETURN CODE FROM THE EXIT WILL BE ZERO          *\n*    2).  ALLOCATES THE DYNAMIC SAVE AREA INTO CONTROL BLOCK          *\n*         AREAS AND EXIT WORK AREA                                    *\n*    3).  CLEARS THE MESSAGE LINE                                     *\n*    4).  BUILDS A COPY OF THE CPPL                                   *\n*    5).  DETERMINES WHETHER TO ISSUE PUTLINE OR WTO TO DISPLAY       *\n*         FORMATTED DATA TO USER                                      *\n*    6).  FALLS INTO PROCESS_EXIT_PARAMETERS                          *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n         XC    RETCODE,RETCODE\n*                                    INITIALIZE THE RETURN CODE.\n*                                    IKJEXIT WILL ALWAYS RETURN\n*                                    A RETURN CODE OF ZERO TO THE\n*                                    INVOKER.\n*\n         LR    R3,R11\n*                                    LOAD REGISTER 3 TO CONTAIN THE\n*                                    ADDRESS OF IKJEXIT'S DYNAMIC WORK\n*                                    AREA THAT WAS OBTAINED BY GETMAIN.\n*\n         LA    R4,CPPL_START\n*                                    OBTAIN THE OFFSET INTO IKJEXIT'S\n*                                    DYNAMIC WORK AREA WHERE THE\n*                                    CPPL IS TO BE DEFINED\n*\n         AR    R4,R3\n*                                    ADD TO THE OFFSET THE BEGINNING\n*                                    ADDRESS OF WHERE IKJEXIT'S\n*                                    DYNAMIC WORK AREA IS AT\n*\n         ST    R4,CPPL_PTR\n*                                    AND STORE THE ADDRESS INTO THE\n*                                    CPPL_POINTER SO THAT WE CAN\n*                                    EASILY LOCATE THE CPPL CONTROL\n*                                    BLOCK NEXT TIME\n*\n         LA    R4,IOPL_START\n*                                    OBTAIN THE OFFSET INTO IKJEXIT'S\n*                                    DYNAMIC WORK AREA WHERE THE\n*                                    IOPL IS TO BE DEFINED\n*\n         AR    R4,R3\n*                                    ADD TO THE OFFSET THE BEGINNING\n*                                    ADDRESS OF WHERE IKJEXIT'S\n*                                    DYNAMIC WORK AREA IS AT\n*\n         ST    R4,IOPL_PTR\n*                                    AND STORE THE ADDRESS INTO THE\n*                                    IOPL_POINTER SO THAT WE CAN\n*                                    EASILY LOCATE THE IOPL CONTROL\n*                                    BLOCK NEXT TIME\n*\n         LA    R4,WTO_START\n*                                    OBTAIN THE OFFSET INTO IKJEXIT'S\n*                                    DYNAMIC WORK AREA WHERE THE\n*                                    WTO CONTROL BLOCK IS TO BE\n*                                    DEFINED  AND\n*\n         AR    R4,R3\n*                                    ADD TO THE OFFSET THE BEGINNING\n*                                    ADDRESS OF WHERE IKJEXIT'S\n*                                    DYNAMIC WORK AREA IS AT\n*\n         ST    R4,WTO_LIST_PTR\n*                                    AND STORE THE ADDRESS INTO THE\n*                                    WTO_LIST_PTR SO THAT WE CAN\n*                                    EASILY LOCATE THE WTO CONTROL\n*                                    BLOCK NEXT TIME\n*\n         LA    R4,4(,R4)\n*                                    IDENTIFY WHERE THE\n*                                    TEXT AREA FOR THE DYNAMIC WTO\n*                                    IS LOCATED WITHIN IKJEXIT'S\n*                                    DYNAMIC WORK AREA SO THAT IF\n*                                    IT IS\n*\n         ST    R4,WTO_TEXT_PTR\n*                                    NECESSARY TO ISSUE A WTO THE\n*                                    WTO MESSAGE AREA IS EASY TO\n*                                    LOCATE\n*\n         L     R1,R1_ENTRY_PARAMETER_LIST_PTR\n*                                    LOAD R1 TO CONTAIN THE ADDRESS\n*                                    OF THE PARAMETER LIST THAT\n*                                    THE INVOKER OF IKJEXIT PASSED\n*                                    IN\n*\n         MVI   MSG_TEXT,BLANK\n*                                    PLACE A SPACE INTO THE FIRST\n*                                    POSITION OF THE MESSAGE OUTPUT\n*                                    BUFFER\n*\n         MVC   MSG_TEXT+1(L'MSG_TEXT-1),MSG_TEXT\n*                                    AND PROPAGATE THE BLANK ACROSS\n*                                    THE REST OF THE MESSAGE OUTPUT\n*                                    BUFFER IF THERE WAS ANY\n*                                    RESIDUAL DATA IN THE OUTPUT\n*                                    BUFFER\n*\n         L     R2,0(,R1)\n*                                    LOAD R2 TO CONTAIN THE ADDRESS\n*                                    OF THE FIRST PARAMETER_ENTRY\n*\n         USING PARAMETER_ENTRY,R2\n*                                    AND ESTABLISH ADDRESSABILITY TO\n*                                    THE PARAMETER_ENTRY DSECT SO THAT\n*                                    THE LABELS WITHIN THE DSECT CAN\n*                                    BE REFERENCED\n*\n         L     R3,CPPL_PTR\n*                                    LOAD R3 TO CONTAIN THE ADDRESS OF\n*                                    THE CPPL THAT WE DEFINED EARLIER\n*\n         USING CPPL,R3\n*                                    ESTABLISH ADDRESSABILITY TO THE\n*                                    CPPL CONTROL BLOCK SO THAT THE\n*                                    LABELS WITHIN THE CPPL CAN BE\n*                                    REFERENCED\n*\n         MVC   CPPLCBUF,PARAMETER_ENTRY_DATA\n*                                    MOVE INTO THE CPPLCBUF FIELD OF\n*                                    THE CPPL, THE CPPLCBUF ADDRESS\n*                                    THE INVOKER PASSED IN THE\n*                                    PARAMETER_ENTRY_DATA FIELD\n*\n         L     R2,8(,R1)\n*                                    LOAD R2 TO CONTAIN THE ADDRESS OF\n*                                    THE THIRD PARAMETER_ENTRY\n*\n         MVC   CPPLUPT,PARAMETER_ENTRY_DATA\n*                                    MOVE INTO THE CPPLUPT FIELD OF\n*                                    THE CPPL, THE CPPLUPT  ADDRESS\n*                                    THE INVOKER PASSED IN THE\n*                                    PARAMETER_ENTRY_DATA FIELD\n*\n         L     R2,12(,R1)\n*                                    LOAD R2 TO CONTAIN THE ADDRESS OF\n*                                    THE FOURTH PARAMETER_ENTRY\n*\n         MVC   CPPLECT,PARAMETER_ENTRY_DATA\n*                                    MOVE INTO THE CPPLECT FIELD OF\n*                                    THE CPPL, THE CPPLECT ADDRESS\n*                                    THE INVOKER PASSED IN THE\n*                                    PARAMETER_ENTRY_DATA FIELD\n*\n         L     R2,16(,R1)\n*                                    LOAD R2 TO CONTAIN THE ADDRESS\n*                                    OF THE FIFTH PARAMETER_ENTRY\n*\n         MVC   CPPLPSCB,PARAMETER_ENTRY_DATA\n*                                    MOVE INTO THE CPPLPSCB FIELD OF\n*                                    THE CPPL, THE CPPLPSCB ADDRESS\n*                                    THE INVOKER PASSED IN THE\n*                                    PARAMETER_ENTRY_DATA FIELD\n*\n         MVI   WTO_SWITCH,ISSUE_PUTLINE_INDICATOR\n*                                    START BY ASSUMING THAT IKJEXIT\n*                                    WAS INVOKED WITHIN AN ENVIRONMENT\n*                                    WHERE THE PUTLINE MACRO IS VALID\n*\n         L     R4,CPPLPSCB\n*                                    LOAD R4 TO CONTAIN THE CONTENTS\n*                                    OF THE CPPLPSCB\n*\n         LTR   R4,R4\n*                                    IF THE CPPLPSCB ADDRESS THAT THE\n*                                    INVOKER PASSED IN IS NOT ZERO\n*\n         BNZ   GOT_CPPLECT\n*                                    THEN ENSURE THAT A NON-ZERO\n*                                    CPPLECT ADDRESS EXISTS\n*\n         MVI   WTO_SWITCH,ISSUE_WTO_INDICATOR\n*                                    ELSE IKJEXIT WILL ASSUME THAT IT\n*                                    HAS BEEN INVOKED IN AN ENVIRONMENT\n*                                    WHERE PUTLINE MAY FAIL. IKJEXIT\n*                                    WILL ISSUE WTOS TO THE MASTER\n*                                    CONSOLE TO DISPLAY THE DATA\n*\nGOT_CPPLECT DS    0H\n*\n         L     R4,CPPLECT\n*                                    LOAD R4 TO CONTAIN THE CONTENTS\n*                                    OF THE CPPLPECT           @YA19658\n*\n         LTR   R4,R4\n*                                    IF THE CPPLECT ADDRESS THE\n*                                    INVOKER PASSED IN IS NOT ZERO\n*\n         BNZ   GOT_CPPLUPT\n*                                    THEN INSURE THAT A NON ZERO\n*                                    CPPLUPT ADDRESS EXISTS\n*\n         MVI   WTO_SWITCH,ISSUE_WTO_INDICATOR\n*                                    ELSE IKJEXIT WILL ASSUME THAT\n*                                    THAT IT HAS BEEN INVOKED IN AN\n*                                    ENVIRONMENT WHERE PUTLINE MAY\n*                                    FAIL. IKJEXIT WILL ISSUE WTOS\n*                                    TO THE MASTER CONSOLE TO\n*                                    DISPLAY THE DATA\n*\nGOT_CPPLUPT  DS    0H\n*\n         L     R4,CPPLUPT\n*                                    LOAD R4 TO CONTAIN THE CONTENTS\n*                                    OF THE CPPLUPT\n*\n* BFG    LTR   R4,R4\n*                                    IF THE CPPLUPT ADDRESS THE\n*                                    INVOKER PASSED IN IS NOT ZERO\n*\n* BFG    BNZ   PROCESS\n*                                    THEN IKJEXIT IS IN AN ENVIRONMENT\n*                                    WHERE PUTLINE WILL OPERATE\n*                                    PROPERLY\n*\n         MVI   WTO_SWITCH,ISSUE_WTO_INDICATOR\n*                                    ELSE IKJEXIT WILL ASSUME THAT\n*                                    IT HAS BEEN INVOKED IN AN\n*                                    ENVIRONMENT WHERE PUTLINE MAY\n*                                    FAIL. IKJEXIT WILL ISSUE WTO'S\n*                                    TO THE MASTER CONSOLE TO\n*                                    DISPLAY THE DATA\n*\n         DROP R3\n*                                    RELEASE ADDRESSABILITY TO THE\n*                                    CPPL\n TITLE 'MAIN LINE CODE  '\n***********************************************************************\n*                                                                     *\n* MAIN LINE CODE                                                      *\n*                                                                     *\n* DESCRIPTIVE NAME - CALL PROCESS_EXIT_PARAMETERS TO PROCESS ALL OF   *\n*                    THE PARAMETERS PASSED TO THIS ROUTINE IN         *\n*                    REGISTER 1.                                      *\n*                                                                     *\n*                                                                     *\n* FUNCTION - STARTS THE PARAMETER_ENTRY PROCESSING PROCESS            *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*                                                                     *\n*    1).  CALL PROCESS_EXIT_PARAMETERS                                *\n*    2).  WHEN CONTROL IS RETURNED CONTROL FALLS INTO THE TERMINATION *\n*         SUBROUTINE                                                  *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nPROCESS  DS    0H\n         BAL   R14,PROCESS_EXIT_PARAMETERS\n TITLE 'TERMINATION CODE'\n***********************************************************************\n*                                                                     *\n* TERMINATION CODE....                                                *\n*                                                                     *\n* DESCRIPTIVE NAME - CLEANUP AND TERMINATION CODE                     *\n*                                                                     *\n* FUNCTION - RELEASES DYNAMIC STORAGE TO SYSTEM AND RETURNS TO        *\n*            CALLER                                                   *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*                                                                     *\n*    1).  LOADS UP REGISTER 5 WITH THE RETURN CODE                    *\n*    2).  FREES THE DYNAMIC STORAGE WORK AREA                         *\n*    3).  RELOADS THE ADDRESS OF THE CALLER'S SAVE AREA               *\n*    4).  FREES THE DYNAMIC STORAGE SAVE AREA                         *\n*    5).  RELOADS REGISTER 14 WITH THE RETURN ADDRESS                 *\n*    6).  RELOADS REGISTER 15 WITH THE RETURN CODE                    *\n*    7).  RELOADS REGISTERS 0 - 12 WITH ORIGINAL CONTENTS             *\n*    8).  RETURNS TO CALLER VIA BSM                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nDONT_PROCESS DS 0H\n*\n         L     R5,RETCODE\n*                                    LOAD R5 TO CONTAIN THE RETURN\n*                                    CODE THAT IKJEXIT WILL RETURN\n*                                    TO THE INVOKER.  THE RETURN\n*                                    CODE WILL ALWAYS BE ZERO\n*\n         L     R1,GM_PTR\n*                                    LOAD R1 TO CONTAIN THE ADDRESS\n*                                    OF IKJEXIT'S DYNAMIC WORK AREA\n*\n         FREEMAIN RU,LV=TLEN,A=(1),SP=1\n*                                    ISSUE FREEMAIN TO RELEASE\n*                                    IKJEXIT'S DYNAMIC WORK AREA\n*                                    STORAGE BACK TO THE SYSTEM\n*\nRETURN   DS    0H\n*\n         LR    R1,R13\n*                                    LOAD R1 TO CONTAIN THE ADDRESS\n*                                    OF IKJEXIT'S DYNAMIC SAVE AREA\n*\n         L     R13,4(,R13)\n*                                    LOAD R13 TO CONTAIN THE ADDRESS\n*                                    OF THE INVOKER'S SAVE AREA THAT\n*                                    WAS PASSED TO IKJEXIT ON ENTRY\n*\n         FREEMAIN RU,LV=L_SAVE_AREA,A=(1)\n*                                    ISSUE FREEMAIN TO RELEASE\n*                                    IKJEXIT'S DYNAMIC SAVE AREA\n*                                    STORAGE BACK TO THE SYSTEM\n*\n         L     R14,12(,R13)\n*                                    LOAD R14 WITH THE ADDRESS OF THE\n*                                    NEXT INSTRUCTION THAT THE INVOKER\n*                                    WOULD HAVE EXECUTED IF IKJEXIT\n*                                    HAD NOT BEEN INVOKED\n*\n         LR    R15,R5\n*                                    LOAD R15 TO CONTAIN THE RETURN\n*                                    CODE IKJEXIT WILL PRESENT BACK\n*                                    TO THE INVOKER.  THE RETURN CODE\n*                                    WILL ALWAYS BE ZERO\n*\n         LM    R0,R12,20(R13)\n*                                    RESTORE THE INVOKER'S REGISTERS\n*                                    BEFORE IKJEXIT RETURNS TO\n*                                    THE INVOKER\n*\n         BSM   0,14\n*                                    RETURN TO THE INVOKER OF IKJEXIT\n*                                    AND RESET THE CALLER'S EXECUTION\n*                                    AND ADDRESSING MODE AS INVOKER\n*                                    CONTROL IS RESTORED\n*\n TITLE 'PROCESS_EXIT_PARAMETERS SUBROUTINE    '\n***********************************************************************\n*                                                                     *\n* PROCESS_EXIT_PARAMETERS                                             *\n*                                                                     *\n* DESCRIPTIVE NAME - PROCESS ALL INSTALLATION EXIT PARAMETERS         *\n*                                                                     *\n* FUNCTION -  CONTINUE PROCESSING ALL INSTALLATION EXIT               *\n*             PARAMETERS UNTIL THE END OF THE LIST IS FOUND.          *\n*             THE END OF THE LIST IS INDICATED BY HAVING THE          *\n*             X'80000000' BIT ON IN THE LAST PARAMETER.               *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*    1).  SAVES ALL OF THE CALLER'S REGISTERS IN A LOCAL SAVE AREA    *\n*         SO THAT ANY REGISTER CAN BE EASILY USED.                    *\n*    2).  MOVES INTO THE OUTPUT BUFFER THE NAME OF THE EXIT \"IKJEXIT\" *\n*    3).  CALLS THE PUTLINE SUBROUTINE TO OUTPUT THE BUFFER           *\n*    4).  CALLS THE PUTLINE SUBROUTINE TO OUTPUT A BLANK LINE         *\n*         FOR READABILITY PURPOSES.                                   *\n*    5).  ESTABLISH ADDRESSABILITY TO THE                             *\n*         \"PARAMETER_ENTRY_NN IS AT ->\" MESSAGE AND MOVES IT INTO     *\n*         THE PUTLINE OUTPUT BUFFER                                   *\n*    6).  GET THE ADDRESS OF THE FIRST PARAMETER_ENTRY                *\n*    7).  CALLS THE HEXCONV SUBROUTINE TO MAKE THE ADDRESS PRINTABLE  *\n*    8).  CALLS PUTLINE TO OUTPUT THE BUFFER                          *\n*    9).  CALLS PUTLINE TO PUT OUT A BLANK LINE FOR READABILITY       *\n*    10). CALLS PROCESS_PARAMETER_ENTRY                               *\n*    11). CHECKS TO SEE IF WE ARE DONE PROCESSING ALL OF THE          *\n*         PARAMETER_ENTRIES                                           *\n*    12). IF NOT DONE GET THE ADDRESS OF THE NEXT PARAMETER           *\n*         AND DO THE PROCESS FROM 5) AGAIN.                           *\n*    13). RELOADS THE CALLER'S REGISTERS                              *\n*    14). RETURNS TO CALLER                                           *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nPROCESS_EXIT_PARAMETERS DS 0H\n         STM   R0,R15,SAVE_AREA_1\n*                                    SAVE ALL REGISTERS THE CALLER\n*                                    OF THIS SUBROUTINE PRESENTED\n*                                    SO THAT ANY REGISTER\n*                                    CAN EASILY BE USED\n*\n         MVC   MSG_TEXT(L'EXIT_NAME),EXIT_NAME\n*                                    MOVE INTO THE OUTPUT BUFFER THE\n*                                    NAME OF THIS TSO/E INSTALLATION\n*                                    EXIT EXAMPLE \"IKJEXIT\"\n*\n         BAL   R14,PUTLINE\n*                                    CALL THE SUBROUTINE PUTLINE TO\n*                                    OUTPUT THE CONTENTS OF THE\n*                                    OUTPUT BUFFER CONTAINING \"IKJEXIT\"\n*\n         SR    R2,R2\n*                                    SET UP R2 AS AN INDEX INTO THE\n*                                    PARAMETER LIST\n*\n         SR    R5,R5\n*                                    USE R5 AS A WORK REGISTER\n*\nMORE_PARMS  DS 0H\n*\n* *#*#   BAL   R14,PUTLINE\n*                                    CALL THE PUTLINE SUBROUTINE\n*                                    TO OUTPUT A BLANK LINE FOR\n*                                    READABILITY PURPOSES\n*\n         LA    R10,MSG_TEXT\n*                                    LOAD R10 TO HAVE THE ADDRESS OF\n*                                    THE OUTPUT BUFFER\n*\n         USING PE_MSG0,R10\n*                                    ESTABLISH ADDRESSABILITY\n*                                    TO THE FIRST MESSAGE FOR\n*                                    EVERY PARAMETER_ENTRY\n*                               \"PARAMETER_ENTRY_ZZ IS AT -> XXXXXXXX\"\n*\n         MVC   PE_MSG0A,PE_AT_TEXT1\n*                                    MOVE \"PARAMETER_ENTRY_\" INTO\n*                                    THE OUTPUT BUFFER AREA\n*\n         MVC   PE_MSG0C,PE_AT_TEXT2\n*                                    MOVE \"IS AT ->\" INTO THE OUTPUT\n*                                    BUFFER AREA\n*\n         L     R1,R1_ENTRY_PARAMETER_LIST_PTR\n*                                    GET THE ADDRESS OF THE PARAMETER\n*                                    LIST THAT THE INVOKER PASSED INTO\n*                                    IKJEXIT\n*\n         AR    R1,R2\n*                                    ADD THE DISPLACEMENT OF THE\n*                                    NEXT PARAMETER IN THE PARAMETER\n*                                    LIST TO PROCESS TO THE\n*                                    PARAMETER LIST ADDRESS\n*\n*\n         ST    R1,HOLD\n*                                    PUT THE \"XXXXXXXX\" ADDRESS OF THE\n*                                    PARAMETER LIST CURRENTLY BEING\n*                                    PROCESSED INTO THE HOLD VARIABLE\n*                               \"PARAMETER_ENTRY_ZZ IS AT -> XXXXXXXX\"\n*\n         BAL   R14,HEXCONV\n*                                    CALL HEXCONV TO CONVERT\n*                                    THE HEX ADDRESS THAT WAS\n*                                    PASSED IN THE HOLD VARIABLE INTO\n*                                    DISPLAY  HEX EQUIVALENT\n*\n         MVC   PE_MSG0D,WORKAREA\n*                                    MOVE THE ADDRESS OF WHERE THE\n*                                    PARAMETER LIST IS AT INTO THE\n*                                    OUTPUT BUFFER\n*\n         L     R1,0(,R1)\n*                                    LOAD R1 TO POINT DIRECTLY TO\n*                                    THE PARAMETER_ENTRY\n*\n         ST    R1,PARAMETER_ENTRY_PTR\n*                                    SAVE THE ADDRESS OF WHERE THE\n*                                    PARAMETER_ENTRY IS AT FOR\n*                                    LATER USE\n*\n         LA    R5,1(,R5)\n*                                    INCREMENT THE ZZ COUNT FOR\n*                                    \"PARAMETER_ENTRY_ZZ\"\n*\n         ST    R5,HOLD\n*                                    PUT THE CURRENT \"ZZ\" COUNT OF THE\n*                                    PARAMETER LIST CURRENTLY BEING\n*                                    PROCESSED INTO THE HOLD VARIABLE\n*\n         BAL   R14,HEXCONV\n*                                    CALL HEXCONV TO CONVERT THE HEX\n*                                    \"ZZ\" COUNT OF THE PARAMETER\n*                                    LIST BEING PROCESSED INTO\n*                                    CHARACTERS THAT CAN BE DISPLAYED\n*\n         MVC   PE_MSG0B,WORKAREA+6\n*                                    PLACE INTO THE OUTPUT BUFFER\n*                                    THE \"ZZ\" VALUE THAT HAS BEEN\n*                                    CONVERTED \"PARAMETER_ENTRY_ZZ\"\n*\n         BAL   R14,PUTLINE\n*                                    CALL THE SUBROUTINE PUTLINE TO\n*                                    OUTPUT THE CONTENTS OF THE\n*                                    OUTPUT BUFFER CONTAINING\n*                                    THE FORMATTED\n*                               \"PARAMETER_ENTRY_ZZ IS AT -> XXXXXXXX\"\n*\n* *#*#   BAL   R14,PUTLINE\n*                                    CALL THE PUTLINE SUBROUTINE\n*                                    TO OUTPUT A BLANK LINE FOR\n*                                    READABILITY PURPOSES\n*\n         ST    R5,COUNT\n*                                    SAVE THE HEX \"ZZ\" COUNT FOR\n*                                    WHEN WE TRY TO PROCESS THE\n*                                    NEXT PARAMETER LIST AND\n*                                    PARAMETER_ENTRY SO IKJEXIT KNOWS\n*                                    WHAT THE LAST COUNT WAS\n*\n         BAL   R14,PROCESS_PARAMETER_ENTRY\n*                                    CALL THE SUBROUTINE\n*                                    PROCESS_PARAMETER_ENTRY TO\n*                                    FORMAT THE FIELDS WITHIN THE\n*                                    PARAMETER_ENTRY PROPER\n*\n         ST    R1,END_OF_PARAMETER_LIST\n*                                    SAVE THE ADDRESS OF THE\n*                                    PARAMETER_ENTRY IN THE\n*                                    PARAMETER LIST WE ARE WORKING\n*                                    ON TO SEE IF THERE ARE\n*                                    MORE PARAMETERS IN THE\n*                                    PARAMETER LIST TO PROCESS\n*\n         A     R2,FOUR\n*                                    INCREMENT THE INDEX INTO THE\n*                                    PARAMETER LIST FOR THE NEXT\n*                                    PARAMETER LIST AND PARAMETER_ENTRY\n*                                    TO PROCESS\n*\n         TM    END_OF_PARAMETER_LIST,HEX80\n*                                    IF THE HIGH ORDER BIT OF THE\n*                                    PARAMETER LIST IS NOT ON\n*\n         BNO   MORE_PARMS\n*                                    THEN IKJEXIT HAS MORE PARAMETERS\n*                                    WITHIN THE PARAMETER LIST TO\n*                                    PROCESS\n*\nEXIT_PROCESS_EXIT_PARAMETERS DS 0H\n*\n*                                    ELSE ALL OF THE PARAMETERS WITHIN\n*                                    THE PARAMETER LIST HAVE BEEN\n*                                    PROCESSED\n*\n         LM    R0,R15,SAVE_AREA_1\n*                                    RESTORE ALL OF THE CALLER'S\n*                                    REGISTERS TO THEIR ORIGINAL\n*                                    VALUE\n*\n         BR    R14\n*                                    RETURN TO CALLER\n*\n         DROP  R10\n*                                    NO LONGER USE R10 TO POINT TO\n*                                    THE\n*                               \"PARAMETER_ENTRY_ZZ IS AT -> XXXXXXXX\"\n*                                    DSECT DESCRIPTION\n TITLE 'PROCESS_PARAMETER_ENTRY SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* PROCESS_PARAMETER_ENTRY                                             *\n*                                                                     *\n* DESCRIPTIVE NAME - PROCESS EACH INDIVIDUAL PARAMETER_ENTRY THAT IS  *\n*                    POINTED TO FROM THE PARAMETER LIST.              *\n*                                                                     *\n* FUNCTION -  SUBROUTINE DRIVER                                       *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*    1). SAVES ALL OF THE CALLER'S REGISTERS IN A LOCAL SAVE AREA     *\n*    2). CALLS BUILD_PE_MSG1 TO BUILD THE                             *\n*        \"PE_ZZ KEY -> X..X DATA LENGTH -> X..X DATA AT -> X..X \"     *\n*    3). CALLS PUTLINE                                                *\n*    4). CALLS FMTDATA                                                *\n*    5). CALLS PUTLINE                                                *\n*    6). RELOADS THE CALLER'S REGISTERS                               *\n*    7). RETURNS TO CALLER                                            *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nPROCESS_PARAMETER_ENTRY DS 0H\n         STM   R0,R15,SAVE_AREA_2\n*                                    SAVE ALL REGISTERS THE CALLER\n*                                    OF THIS SUBROUTINE PRESENTED\n*                                    SO THAT ANY REGISTER\n*                                    CAN EASILY BE USED\n*\n         LA    R10,MSG_TEXT\n*                                    LOAD R2 TO CONTAIN THE ADDRESS OF\n*                                    THE PARAMETER_ENTRY\n*\n         USING PBUF,R10\n*                                    ESTABLISH ADDRESSABILITY TO\n*                                    THE OUTPUT BUFFER DSECT\n*\n         L     R2,PARAMETER_ENTRY_PTR\n*                                    LOAD R2 TO CONTAIN THE ADDRESS OF\n*                                    THE PARAMETER_ENTRY\n*\n         USING PARAMETER_ENTRY,R2\n*                                    ESTABLISH ADDRESSABILITY TO\n*                                    THE PARAMETER_ENTRY DSECT SO\n*                                    IKJEXIT CAN REFERENCE THE LABELS\n*                                    WITHIN THE PARAMETER_ENTRY DSECT\n*\n         BAL   R14,BUILD_PE_MSG1\n*                                    CALL SUBROUTINE BUILD_PE_MSG1\n*                                    TO BUILD AND FORMAT THE\n*                                    MESSAGE\n*\n*                                    \"PEZZ KEY -> X..X\n*                                    LENGTH OF DATA -> X..X\n*                                    ADDRESS OF DATA -> X..X\"\n*\n         BAL   R14,PUTLINE\n*                                    CALL THE PUTLINE SUBROUTINE\n*                                    TO OUTPUT THE MESSAGE\n*\n         CLI   BAD_KEY_SWITCH,BAD_KEY_INDICATOR\n*                                    IF IKJEXIT DID NOT DETECT AN\n*                                    INVALID KEY WITHIN THE\n*                                    PARAMETER_ENTRY_KEY FIELD OF THE\n*                                    PARAMETER_ENTRY BEING PROCESSED\n*\n         BNE   GOT_GOOD_KEY\n*                                    THEN CONTINUE PROCESSING AND\n*                                    FORMAT THE PARAMETER_ENTRY_DATA\n*                                    FIELD (EITHER DIRECT OR INDIRECT\n*                                    BASED ON THE PARAMETER_ENTRY_KEY)\n*                                    FOR THE LENGTH OF THE\n*                                    PARAMETER_ENTRY_LENGTH FIELD\n*\n* *#*#   BAL   R14,PUTLINE\n*                                    ELSE CALL THE PUTLINE SUBROUTINE\n*                                    TO OUTPUT A BLANK LINE FOR\n*                                    READABILITY PURPOSES\n*\n         MVC   MSG_TEXT(L'BAD_KEY_MSG),BAD_KEY_MSG\n*                                    MOVE THE FOLLOWING MESSAGE INTO\n*                                    THE OUTPUT BUFFER\n*\n*                                    \"THE PARAMETER_ENTRY_KEY\n*                                    FOR THIS PARAMETER_ENTRY\n*                                    CONTAINS AN UNDEFINED KEY\"\n*\n         BAL   R14,PUTLINE\n*                                    CALL THE PUTLINE SUBROUTINE\n*                                    TO OUTPUT THE\n*  \"THE PARAMETER_ENTRY_KEY FOR THIS PARAMETER_ENTRY CONTAINS AN\n*                                    UNDEFINED KEY\" MESSAGE\n*\n* *#*#   BAL   R14,PUTLINE\n*                                    CALL THE PUTLINE SUBROUTINE\n*                                    TO OUTPUT A BLANK LINE FOR\n*                                    READABILITY PURPOSES\n*\nGOT_GOOD_KEY DS    0H\n*\n         TM    ORIGINAL_DATA_LENGTH,HEX80\n*                                    IF THE PARAMETER_ENTRY_LENGTH\n*                                    FIELD OF THIS PARAMETER_ENTRY\n*                                    DOES NOT CONTAIN A NEGATIVE\n*                                    LENGTH\n*\n         BNO   LENGTH_IS_POSITIVE\n*                                    THEN DO NOT SET THE\n*                                    SWITCH NOT TO FORMAT THE \"DATA\"\n*                                    LINE\n*\n* *#*#   BAL   R14,PUTLINE\n*                                    ELSE CALL THE PUTLINE SUBROUTINE\n*                                    TO OUTPUT A BLANK LINE FOR\n*                                    READABILITY PURPOSES\n*\n         MVC   MSG_TEXT(L'BAD_LENGTH_MSG6),BAD_LENGTH_MSG6\n*                                    MOVE INTO THE OUTPUT BUFFER THE\n*                                    INFORMATIONAL ERROR MESSAGE\n*\n         BAL   R14,PUTLINE\n*                                    OUTPUT THE OUTPUT BUFFER THAT\n*                                    CONTAINS THE ERROR MESSAGE\n*                                    INDICATING A NEGATIVE LENGTH\n*                                    HAS BEEN FOUND IN THE\n*                                    PARAMETER_ENTER_LENGTH FIELD\n*                                    OF THIS PARAMETER_ENTEY\n*\n         B     EXIT_PROCESS_PARAMETER_ENTRY\n*                                    ERRROR CONDITION SO JUST EXIT\n*                                    THIS SUBROUTINE\n*\nLENGTH_IS_POSITIVE DS 0H\n*\n         BAL   R14,FMTDATA\n*                                    CALL THE SUBROUTINE FMTDATA TO\n*                                    FORMAT THE DATA EITHER POINTED\n*                                    TO INDIRECTLY FROM THE\n*                                    PARAMETER_ENTRY_DATA FIELD OF\n*                                    THE PARAMETER_ENTRY OR THE\n*                                    DATA WITHIN THE\n*                                    PARAMETER_ENTRY_DATA FIELD\n*\n*\nEXIT_PROCESS_PARAMETER_ENTRY DS 0H\n*\n* *#*#   BAL   R14,PUTLINE\n*                                    CALL THE PUTLINE SUBROUTINE\n*                                    TO OUTPUT A BLANK LINE FOR\n*                                    READABILITY PURPOSES\n         LM    R0,R15,SAVE_AREA_2\n*                                    RESTORE ALL OF THE CALLER'S\n*                                    REGISTERS TO THEIR ORIGINAL\n*                                    VALUE\n*\n         BR    R14\n*                                    RETURN TO CALLER\n*\n         DROP  R10\n*                                    NO LONGER USE R10 TO POINT TO THE\n*\n*\n*                                   \"PEZZ KEY -> X..X LENGTH OF DATA ->\n*                                    X..X ADDRESS OF DATA -> X..X\"\n*\n*                                    DSECT\n         DROP  R2\n*                                    NO LONGER USE PARAMETER_ENTRY\n*                                    DSECT DESCRIPTION\n TITLE 'BUILD_PE1_MSG SUBROUTINE'\n***********************************************************************\n* BUILD_PE_MSG1                                                       *\n*                                                                     *\n* DESCRIPTIVE NAME - FORMAT THE DISPLAY TEXT DESCRIBING THE           *\n*                    PARAMETER_ENTRY_KEY, PARAMETER_ENTRY_LENGTH AND  *\n*                    THE PARAMETER_ENTRY_DATA FIELDS OF THE           *\n*                    PARAMETER_ENTRY.                                 *\n*                                                                     *\n* FUNCTION -  BUILDS THE MESSAGE TEXT                                 *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*    1). SAVES ALL OF THE CALLER'S REGISTERS IN A LOCAL SAVE AREA     *\n*    2). MOVES INTO THE MESSAGE LINE THE                              *\n*        \"PE_ZZ KEY -> X..X DATA LENGTH -> X..X DATA AT -> X..X\" MSG  *\n*    3). VALIDATES THE PARAMETER ENTRY KEY                            *\n*        IF THE KEY IS VALID THEN                                     *\n*          {1}. CALLS FMT_PARAMETER_ENTRY_KEY                         *\n*          {2}. CALLS FMT_PARAMETER_ENTRY_DATA                        *\n*          {3}. RELOADS THE CALLER'S REGISTERS                        *\n*          {4}. CALLS HEXCONV                                         *\n*        ELSE                                                         *\n*          {1}. GENERATES A MESSAGE INDICATING THAT THE KEY IS        *\n*               INVALID.                                              *\n*    4). RELOADS THE CALLER'S REGISTERS                               *\n*    5). RETURNS TO CALLER                                            *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nBUILD_PE_MSG1  DS 0H\n*\n         STM   R0,R15,SAVE_AREA_3\n*                                    SAVE ALL REGISTERS THE CALLER\n*                                    OF THIS SUBROUTINE PRESENTED\n*                                    SO THAT ANY REGISTER\n*                                    CAN EASILY BE USED\n*\n         LA    R10,MSG_TEXT\n*                                    LOAD R10 TO HAVE THE ADDRESS OF\n*                                    THE OUTPUT BUFFER\n*\n         USING PE_MSG1,R10\n*                                    ESTABLISH ADDRESSABILITY\n*                                    TO THE SECOND MESSAGE FOR\n*                                    EVERY PARAMETER_ENTRY\n*\n*                                   \"PEZZ KEY -> X..X LENGTH OF DATA ->\n*                                    X..X ADDRESS OF DATA -> X..X\"\n*\n*                                    DSECT\n*\n         L     R2,PARAMETER_ENTRY_PTR\n*                                    LOAD R2 TO HAVE THE ADDRESS OF\n*                                    THE PARAMETER_ENTRY\n*\n         USING PARAMETER_ENTRY,R2\n*                                    ESTABLISH ADDRESSABILITY TO\n*                                    THE PARAMETER_ENTRY DSECT SO\n*                                    IKJEXIT CAN REFERENCE THE LABELS\n*                                    WITHIN THE PARAMETER_ENTRY DSECT\n*\n         MVC   HOLD,PARAMETER_ENTRY_LENGTH\n*                                    MOVE INTO THE HOLD VARIABLE THE\n*                                    LENGTH OF THE PARAMETER_ENTRY_DATA\n*                                    FIELD DESCRIBED BY THE\n*                                    PARAMETER_ENTRY_LENGTH FIELD\n*\n         MVC   ORIGINAL_DATA_LENGTH,HOLD\n*                                    SAVE THE ORIGINAL VALUE OF THE\n*                                    PARAMETER_ENTRY_LENGTH FIELD\n*                                    SO THAT IF IKJEXIT\n*                                    CALLS THE FMTDATA SUBROUTINE\n*                                    IKJEXIT KNOWS HOW MUCH DATA\n*                                    TO FORMAT\n*\n         BAL   R14,HEXCONV\n*                                    CALL HEXCONV TO CONVERT\n*                                    THE HEX LENGTH OF THE DATA\n*                                    THAT WAS OBTAINED FROM THE\n*                                    PARAMETER_ENTRY_LENGTH FIELD\n*                                    OF THE PARAMETER_ENTRY\n*                                    PASSED IN THE HOLD VARIABLE INTO\n*                                    CHARACTERS THAT CAN BE DISPLAYED\n*\n         MVC   PE_MSG1E,WORKAREA\n*                                    MOVE THE CONVERTED HEX VALUE OF\n*                                    THE PARAMETER_ENTRY_LENGTH OPERAND\n*                                    INTO THE OUTPUT BUFFER\n*\n         SR    R5,R5\n*                                    ZERO R5 AND USE IT TO CHECK\n*                                    IF THE VALUE OF THE\n*                                    PARAMETER_ENTRY_KEY PARAMETER OF\n*                                    THE PARAMETER_ENTRY IS VALID\n*\n         BCTR  R5,0\n*                                    INITIALIZE THE R5 KEY CHECK TO\n*                                    START AT X'FFFFFFFF'\n*\n         L     R7,MAXIMUM_KEY_VALUE\n*                                    USE R7 AS THE MAXIMUM VALID\n*                                    KEY VALUE + 1.\n*\n         MVI   BAD_KEY_SWITCH,GOOD_KEY_INDICATOR\n*                                    ASSUME THAT THE\n*                                    PARAMETER_ENTRY_KEY THAT IS IN\n*                                    THE PARAMETER_ENTRY IS VALID\n*\nNEXT_KEY DS    0H\n*                                    DO WHILE R7 HAS NOT REACHED ZERO\n*                                    AND THE R5 KEY CHECK AND THE\n*                                    PARAMETER_ENTRY_KEY ARE NOT\n*                                    EQUAL\n*\n*\n         LA    R5,1(,R5)\n*                                    INCREMENT THE VALUE OF R5 (THE\n*                                    KEY CHECK) BY 1\n*\n         C     R5,PARAMETER_ENTRY_KEY\n*                                    IF THE PARAMETER_ENTRY_KEY IS\n*                                    EQUAL TO THE KEY CHECK (R5)\n*\n         BE    CONTINUE\n*                                    THEN DO NOT SET THE\n*                                    BAD_KEY_INDICATOR\n*\n         BCT   R7,NEXT_KEY\n*                                    CONTINUE CHECKING THE KEY CHECK\n*                                    (R5) AGAINST THIS\n*                                    PARAMETER_ENTRY_KEY\n*\n         MVI   BAD_KEY_SWITCH,BAD_KEY_INDICATOR\n*                                    ELSE IKJEXIT HAS DETERMINED THAT\n*                                    AN INVALID KEY HAS BEEN FOUND\n*                                    WITHIN THE PARAMETER_ENTRY_KEY\n*                                    FIELD OF THIS PARAMETER ENTRY\n*                                    AND THE BAD_KEY_SWITCH HAS BEEN\n*                                    SET TO INDICATE THAT THE\n*                                    PARAMETER_ENTRY_KEY IS INVALID\n*\nCONTINUE DS    0H\n*\n         BAL   R14,FMT_PARAMETER_ENTRY_KEY\n*                                    CALL SUBROUTINE\n*                                    FMT_PARAMETER_ENTRY_KEY TO\n*                                    CONVERT THE HEX VALUE OF THE\n*                                    PARAMETER_ENTRY_KEY FIELD FROM THE\n*                                    HEX VALUE TO THE EQUIVALENT\n*                                    HEX CHARACTERS THAT CAN BE\n*                                    DISPLAYED\n*\n         BAL   R14,FMT_PARAMETER_ENTRY_DATA\n*                                    CALL SUBROUTINE\n*                                    FMT_PARAMETER_ENTRY_DATA  TO\n*                                    CONVERT THE HEX VALUE OF THE\n*                                    PARAMETER_ENTRY_DATA FIELD FROM\n*                                    THE HEX VALUE TO THE EQUIVALENT\n*                                    HEX CHARACTERS THAT CAN BE\n*                                    DISPLAYED\n*\nNO_GOOD  DS    0H\n*\n         MVC   HOLD,COUNT\n*                                    RE-LOAD THE \"ZZ\" COUNT OF THE\n*                                    PARAMETER_ENTRY CURRENTLY\n*                                    BEING PROCESSED AND PASS INTO\n*                                    THE HEXCONV SUBROUTINE\n*\n         BAL   R14,HEXCONV\n*                                    CALL HEXCONV TO CONVERT THE\n*                                    HEX \"ZZ\" COUNT OF THE\n*                                    PARAMETER LIST BEING PROCESS INTO\n*                                    EQUIVALENT\n*                                    HEX CHARACTERS THAT CAN BE\n*                                    DISPLAYED\n*\n         MVC   PE_MSG1H,WORKAREA+6\n*                                    MOVE INTO THE OUTPUT BUFFER THE\n*                                    \"ZZ\" FIELD OF THE\n*\n*                                   \"PEZZ KEY -> X..X LENGTH OF DATA ->\n*                                    X..X ADDRESS OF DATA -> X..X\"\n*\n*                                    MESSAGE\n*\n         MVC   PE_MSG1A,PE\n*                                    MOVE INTO THE OUTPUT BUFFER THE\n*                                    \"PE\" FIELD OF THE\n*\n*                                   \"PEZZ KEY -> X..X LENGTH OF DATA ->\n*                                    X..X ADDRESS OF DATA -> X..X\"\n*\n*                                    MESSAGE\n*\n         MVC   PE_MSG1B,KEY_EQU\n*                                    MOVE INTO THE OUTPUT BUFFER THE\n*                                    \"KEY -> ' FIELD OF THE\n*\n*                                   \"PEZZ KEY -> X..X LENGTH OF DATA ->\n*                                    X..X ADDRESS OF DATA -> X..X\"\n*\n*                                    MESSAGE\n*\n         MVC   PE_MSG1D,LENGTH_OF_DATA\n*                                    MOVE INTO THE OUTPUT BUFFER THE\n*                                    \"LENGTH OF DATA -> ' FIELD OF THE\n*\n*                                   \"PEZZ KEY -> X..X LENGTH OF DATA ->\n*                                    X..X ADDRESS OF DATA -> X..X\"\n*\n*                                    MESSAGE\n*\n         MVC   PE_MSG1F,ADDRESS_OF_DATA\n*                                    MOVE INTO THE OUTPUT BUFFER THE\n*                                    \"ADDRESS OF DATA -> ' FIELD OF THE\n*\n*                                   \"PEZZ KEY -> X..X LENGTH OF DATA ->\n*                                    X..X ADDRESS OF DATA -> X..X\"\n*\n*                                    MESSAGE\n*\nEXIT_BUILD_PE_MSG1  DS 0H\n*\n         LM    R0,R15,SAVE_AREA_3\n*                                    RESTORE ALL OF THE CALLER'S\n*                                    REGISTERS TO THEIR ORIGINAL\n*                                    VALUE\n*\n         BR    R14\n*                                    RETURN TO CALLER\n*\n         DROP  R10\n*                                    NO LONGER USE R10 TO POINT TO\n*                                    THE\n*\n*                                   \"PEZZ KEY -> X..X LENGTH OF DATA ->\n*                                    X..X ADDRESS OF DATA -> X..X\"\n*\n*                                    DSECT\n*\n         DROP  R2\n*                                    NO LONGER USE PARAMETER_ENTRY\n*                                    DSECT DESCRIPTION\n TITLE 'FMT_PARAMETER_ENTRY_KEY SUBROUTINE'\n***********************************************************************\n* FMT_PARAMETER_ENTRY_KEY                                             *\n*                                                                     *\n* DESCRIPTIVE NAME - COMMON ROUTINE TO CONVERT THE                    *\n*                    PARAMETER_ENTRY_KEY FROM HEX CHARACTERS TO       *\n*                    CHARACTERS THAT CAN BE DISPLAYED.                *\n*                                                                     *\n* FUNCTION -  BUILDS THE MESSAGE TEXT                                 *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*    1). SAVES ALL THE CALLER'S REGISTERS                             *\n*    2). LOADS  THE PARAMETER_ENTRY_KEY                               *\n*    3). CALLS HEXCONV                                                *\n*    4). PUTS THE CONVERTED TEXT INTO THE MESSAGE LINE                *\n*    5). RELOADS THE CALLER'S RETURN ADDRESS                          *\n*    6). RETURNS TO CALLER                                            *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nFMT_PARAMETER_ENTRY_KEY DS 0H\n*\n         STM   R0,R15,SAVE_AREA_4\n*                                    SAVE ALL REGISTERS THE CALLER\n*                                    OF THIS SUBROUTINE PRESENTED\n*                                    SO THAT ANY REGISTER\n*                                    CAN EASILY BE USED\n*\n         LA    R10,MSG_TEXT\n*                                    LOAD R10 TO HAVE THE ADDRESS OF\n*                                    THE OUTPUT BUFFER\n*\n         USING PE_MSG1,R10\n*                                    ESTABLISH ADDRESSABILITY\n*                                    TO THE SECOND MESSAGE FOR\n*                                    EVERY PARAMETER_ENTRY\n*\n*                                   \"PEZZ KEY -> X..X LENGTH OF DATA ->\n*                                    X..X ADDRESS OF DATA -> X..X\"\n*\n*                                    DSECT\n*\n         L     R2,PARAMETER_ENTRY_PTR\n*                                    LOAD R2 TO HAVE THE ADDRESS OF\n*                                    THE PARAMETER_ENTRY\n*\n         USING PARAMETER_ENTRY,R2\n*                                    ESTABLISH ADDRESSABILITY TO\n*                                    THE PARAMETER_ENTRY DSECT SO\n*                                    IKJEXIT CAN REFERENCE THE LABELS\n*                                    WITHIN THE PARAMETER_ENTRY DSECT\n*\n         MVC   HOLD,PARAMETER_ENTRY_KEY\n*                                    GET THE VALUE OF THE\n*                                    PARAMETER_ENTRY_KEY THAT IS\n*                                    WITHIN THE PARAMETER_ENTRY\n*                                    BEING PROCESSED AND PASS IT TO\n*                                    THE HEXCONV SUBROUTINE\n*\n         BAL   R14,HEXCONV\n*                                    CALL HEXCONV TO CONVERT THE\n*                                    HEX PARAMETER_ENTRY_KEY FOR\n*                                    PARAMETER_ENTRY BEING PROCESS INTO\n*                                    EQUIVALENT\n*                                    HEX CHARACTERS THAT CAN BE\n*                                    DISPLAYED\n*\n         MVC   PE_MSG1C,WORKAREA\n*                                    MOVE INTO THE OUTPUT BUFFER THE\n*                                    CONVERTED VALUE FOR THE\n*                                    \"X..X\" FIELD OF THE \"KEY AT -> \"\n*\n*                                    INTO THE\n*\n*                                   \"PEZZ KEY -> X..X LENGTH OF DATA ->\n*                                    X..X ADDRESS OF DATA -> X..X\"\n*\n*                                    MESSAGE\n*\nEXIT_FMT_PARAMETER_ENTRY_KEY DS 0H\n*\n         LM    R0,R15,SAVE_AREA_4\n*                                    RESTORE ALL OF THE CALLER'S\n*                                    REGISTERS TO THEIR ORIGINAL\n*                                    VALUE\n*\n         BR    R14\n*                                    RETURN TO CALLER\n*\n         DROP  R10\n*                                    NO LONGER USE R10 TO POINT TO\n*                                    THE\n*\n*                                   \"PEZZ KEY -> X..X LENGTH OF DATA ->\n*                                    X..X ADDRESS OF DATA -> X..X\"\n*\n*                                    DSECT\n*\n         DROP  R2\n*                                    NO LONGER USE PARAMETER_ENTRY\n*                                    DSECT DESCRIPTION\n TITLE 'FMT_PARAMETER_ENTRY_DATA SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* FMT_PARAMETER_ENTRY_DATA                                            *\n*                                                                     *\n* DESCRIPTIVE NAME - COMMON ROUTINE TO CONVERT THE                    *\n*                    PARAMETER_ENTRY_DATA FROM HEX CHARACTERS TO      *\n*                    CHARACTERS TO THAT CAN BE DISPLAYED.             *\n*                                                                     *\n* FUNCTION -  DISPLAY THE ADDRESS OF WHERE THE DATA IS                *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*    1). SAVES ALL THE CALLER'S REGISTERS                             *\n*    2). LOADS THE PARAMETER_ENTRY_DATA                               *\n*    3). CALLS HEXCONV                                                *\n*    4). PUTS THE CONVERTED TEXT INTO THE MESSAGE LINE                *\n*    5). RELOADS THE CALLER'S RETURN ADDRESS                          *\n*    6). RETURNS TO CALLER                                            *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nFMT_PARAMETER_ENTRY_DATA DS 0H\n*\n         STM   R0,R15,SAVE_AREA_5\n*                                    SAVE ALL REGISTERS THE CALLER\n*                                    OF THIS SUBROUTINE PRESENTED\n*                                    SO THAT ANY REGISTER\n*                                    CAN EASILY BE USED\n*\n         LA    R10,MSG_TEXT\n*                                    LOAD R10 TO HAVE THE ADDRESS OF\n*                                    THE OUTPUT BUFFER\n*\n         USING PE_MSG1,R10\n*                                    ESTABLISH ADDRESSABILITY\n*                                    TO THE SECOND MESSAGE FOR\n*                                    EVERY PARAMETER_ENTRY\n*\n*                                   \"PEZZ KEY -> X..X LENGTH OF DATA ->\n*                                    X..X ADDRESS OF DATA -> X..X\"\n*\n*                                    DSECT\n*\n         L     R2,PARAMETER_ENTRY_PTR\n*                                    LOAD R2 TO HAVE THE ADDRESS OF\n*                                    THE PARAMETER_ENTRY\n*\n         USING PARAMETER_ENTRY,R2\n*                                    ESTABLISH ADDRESSABILITY TO\n*                                    THE PARAMETER_ENTRY DSECT SO\n*                                    IKJEXIT CAN REFERENCE THE LABELS\n*                                    WITHIN THE PARAMETER_ENTRY DSECT\n*\n         C     R5,KEY_OF_TWO\n*                                    IF THE PARAMETER_ENTRY_KEY IN\n*                                    THIS PARAMETER_ENTRY DOES NOT\n*                                    HAVE A VALUE OF X'00000002'\n*\n         BNE   NOT_INDIRECT\n*                                    THEN THE PARAMETER_ENTRY_KEY\n*                                    IN THIS PARAMETER_ENTRY INDICATES\n*                                    THAT THE DATA IS DIRECT\n*\n         L     R6,PARAMETER_ENTRY_DATA\n*                                    ELSE THE DATA IN THE\n*                                    PARAMETER_ENTRY_DATA FIELD IS A\n*                                    POINTER TO THE DATA\n*\n         B     GO_ON\n*                                    JUMP AROUND THE DATA DIRECT\n*                                    INDICATOR AND KEEP GOING\n*\nNOT_INDIRECT DS 0H\n*\n         LA    R6,PARAMETER_ENTRY_DATA\n*                                    GET THE ADDRESS OF THE\n*                                    PARAMETER_ENTRY_DATA FIELD THAT\n*                                    IS CONTAINED WITHIN THE\n*                                    PARAMETER_ENTRY BEING PROCESSED\n*\nGO_ON    DS    0H\n*\n         ST    R6,HOLD\n*                                    IN ANY CASE IKJEXIT WILL PUT THE\n*                                    ADDRESS OF WHERE THE DATA IS AT\n*                                    INTO THE HOLD VARIABLE FOR HEXCONV\n*\n         ST    R6,DATA_AT\n*                                    AND IKJEXIT WILL SAVE THE ADDRESS\n*                                    OF WHERE THE DATA IS AT FOR THE\n*                                    FMTDATA SUBROUTINE\n*\n         BAL   R14,HEXCONV\n*                                    CALL HEXCONV TO CONVERT THE\n*                                    HEX PARAMETER_ENTRY_DATA FOR\n*                                    PARAMETER_ENTRY BEING PROCESS INTO\n*                                    EQUIVALENT\n*                                    HEX CHARACTERS THAT CAN BE\n*                                    DISPLAYED\n*\n         MVC   PE_MSG1G,WORKAREA\n*                                    MOVE INTO THE OUTPUT BUFFER THE\n*                                    CONVERTED VALUE FOR THE\n*                                    \"X..X\" FIELD OF THE\n*                                    \"ADDRESS OF DATA -> \" FIELD\n*\n*                                   \"PEZZ KEY -> X..X LENGTH OF DATA ->\n*                                    X..X ADDRESS OF DATA -> X..X\"\n*\n*                                    MESSAGE\n*\nEXIT_FMT_PARAMETER_ENTRY_DATA DS 0H\n*\n         LM    R0,R15,SAVE_AREA_5\n*                                    RESTORE ALL OF THE CALLER'S\n*                                    REGISTERS TO THEIR ORIGINAL\n*                                    VALUE\n*\n         BR    R14\n*                                    RETURN TO CALLER\n*\n         DROP  R10\n*                                    NO LONGER USE R10 TO POINT TO\n*                                    THE\n*\n*                                   \"PEZZ KEY -> X..X LENGTH OF DATA ->\n*                                    X..X ADDRESS OF DATA -> X..X\"\n*\n*                                    DSECT\n*\n         DROP  R2\n*                                    NO LONGER USE PARAMETER_ENTRY\n*                                    DSECT DESCRIPTION\n TITLE 'FMTDATA SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* FMTDATA                                                             *\n*                                                                     *\n* DESCRIPTIVE NAME - DISPLAY DATA SUBROUTINE                          *\n*                                                                     *\n* FUNCTION -  HEXDUMPS THE PARAMETER_ENTRY_DATA THAT IS BEING         *\n*             DESCRIBED BY THE PARAMETER_ENTRY_KEY AND THE            *\n*             PARAMETER_ENTRY_LENGTH.                                 *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*    1).  SAVES ALL OF THE CALLER'S REGISTERS IN A LOCAL SAVE AREA    *\n*    2).  CHECKS TO SEE IF THERE IS ANY DATA TO FORMAT                *\n*         IF THERE IS NO DATA TO FORMAT THEN                          *\n*          {1}. INSERTS A MESSAGE INDICATING NO DATA TO FORMAT        *\n*        ELSE THERE IS DATA TO FORMAT                                 *\n*          {1}. BUILDS EACH LINE OF OUTPUT ONE LINE AT A TIME         *\n*               DISPLAYING THE OFFSET INTO THE DATA                   *\n*          {2}. CALLS HEXCONV                                         *\n*          {3}. CALLS PUTLINE                                         *\n*          {4}. CONTINUES THIS PROCESS UNTIL THERE IS NO MORE         *\n*               DATA TO FORMAT.                                       *\n*    3). CALLS HEXCONV ON LAST TIME                                   *\n*    4). CALLS PUTLINE ON LAST TIME                                   *\n*    5). RELOADS THE CALLER'S REGISTERS                               *\n*    6). RETURNS TO CALLER                                            *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nFMTDATA        DS  0H\n*\n         STM   R0,R15,SAVE_AREA_6\n*                                    SAVE ALL REGISTERS THE CALLER\n*                                    OF THIS SUBROUTINE PRESENTED\n*                                    SO THAT ANY REGISTER\n*                                    CAN EASILY BE USED\n*\n         L     R1,ORIGINAL_DATA_LENGTH\n*                                    LOAD R1 TO HAVE THE ORIGINAL\n*                                    LENGTH OF THE DATA THAT WAS\n*                                    SAVED EARLIER\n*\n         LTR   R1,R1\n*                                    IF THE LENGTH OF THE DATA\n*                                    WE OBTAINED FROM THE\n*                                    PARAMETER_ENTRY_DATA FIELD WITHIN\n*                                    THIS PARAMETER_ENTRY IS GREATER\n*                                    THAN ZERO\n*\n         BNZ   GOT_DATA\n*                                    THEN THERE IS DATA TO FORMAT AND\n*                                    DISPLAY\n*\n         MVC   MSG_TEXT(L'BAD_LENGTH_MSG1),BAD_LENGTH_MSG1\n*                                    ELSE\n*                                    MOVE THE FOLLOWING MESSAGE\n*                                    INTO THE OUTPUT BUFFER:\n*\n*                                    \"THE PARAMETER_ENTRY_LENGTH FOR\n*                                    THIS PARAMETER_ENTRY HAS A VALUE\n*                                    OF ZERO\"\n*\n         BAL   R14,PUTLINE\n*                                    CALL THE PUTLINE SUBROUTINE\n*                                    TO OUTPUT THE MESSAGE\n*\n* *#*#   BAL   R14,PUTLINE\n*                                    CALL THE PUTLINE SUBROUTINE\n*                                    TO OUTPUT A BLANK LINE FOR\n*                                    READABILITY PURPOSES\n*\n         MVC   MSG_TEXT(L'BAD_LENGTH_MSG2),BAD_LENGTH_MSG2\n*                                    MOVE THE FOLLOWING MESSAGE\n*                                    INTO THE OUTPUT BUFFER:\n*\n*                                    \"THE PARAMETER_ENTRY_LENGTH MUST\n*                                    CONTAIN A VALUE NO LESS THAN\n*                                    '00000004'\"\n*\n         BAL   R14,PUTLINE\n*                                    CALL THE PUTLINE SUBROUTINE\n*                                    TO OUTPUT THE MESSAGE\n*\n         MVC   MSG_TEXT(L'BAD_LENGTH_MSG3),BAD_LENGTH_MSG3\n*                                    MOVE THE FOLLOWING MESSAGE\n*                                    INTO THE OUTPUT BUFFER:\n*\n*                                    \"IF THE PARAMETER_ENTRY_KEY\n*                                    IS '00000000' OR '00000003'\"\n*\n         BAL   R14,PUTLINE\n*                                    CALL THE PUTLINE SUBROUTINE\n*                                    TO OUTPUT THE MESSAGE\n*\n* *#*#   BAL   R14,PUTLINE\n*                                    CALL THE PUTLINE SUBROUTINE\n*                                    TO OUTPUT A BLANK LINE FOR\n*                                    READABILITY PURPOSES\n*\n         MVC   MSG_TEXT(L'BAD_LENGTH_MSG4),BAD_LENGTH_MSG4\n*                                    MOVE THE FOLLOWING MESSAGE\n*                                    INTO THE OUTPUT BUFFER:\n*\n*                                    \"IF THE PARAMETER_ENTRY_KEY\n*                                    IS '00000001' OR '00000002'\"\n*\n         BAL   R14,PUTLINE\n*                                    CALL THE PUTLINE SUBROUTINE\n*                                    TO OUTPUT THE MESSAGE\n*\n         MVC   MSG_TEXT(L'BAD_LENGTH_MSG5),BAD_LENGTH_MSG5\n*                                    MOVE THE FOLLOWING MESSAGE\n*                                    INTO THE OUTPUT BUFFER:\n*                                    \"THE PARAMETER_ENTRY_LENGTH\n*                                    MAY CONTAIN A VALUE OF '00000001'\"\n*\n         BAL   R14,PUTLINE\n*                                    CALL THE PUTLINE SUBROUTINE\n*                                    TO OUTPUT THE MESSAGE\n*\n*\n         B     LAST_PUT\n*                                    QUIT PROCESSING FMTDATA BECAUSE\n*                                    OF INVALID LENGTH FOUND WITHIN\n*                                    THE PARAMETER_ENTRY_KEY FIELD\n*                                    FOR THIS PARAMETER_ENTRY\n*                                    ANY ATTEMPT TO FORMAT THIS DATA\n*                                    COULD PRESENT UNPREDICTABLE\n*                                    RESULTS\n*\nGOT_DATA DS    0H\n*\n         LA    R15,MSG_TEXT\n*                                    LOAD R15 TO HAVE THE ADDRESS OF\n*                                    THE OUTPUT BUFFER\n*\n         USING PE_MSG2,R15\n*                                    ESTABLISH ADDRESSABILITY\n*                                    TO THE THIRD MESSAGE FOR\n*                                    EVERY PARAMETER_ENTRY\n* \"DATA   +00000000  E3C8C9E2  40C9E240  E3C8C540  C4C1E3C1\" MESSAGE\n*                                    DSECT\n*\n*\n         MVC   PE_MSG2A,DATA\n*                                    MOVE \"DATA\" INTO THE OUTPUT\n* \"DATA   +00000000  E3C8C9E2  40C9E240  E3C8C540  C4C1E3C1\" MESSAGE\n*                                    BUFFER\n*\n         SR    R3,R3\n*                                    R3 IS THE INDEX INTO THE DATA\n*                                    AREA COUNTER FOR THE\n*                                    \"+00000000\" PART OF\n* \"DATA   +00000000  E3C8C9E2  40C9E240  E3C8C540  C4C1E3C1\" MESSAGE\n*                                    EVERY TIME A NEW DATA LINE IS\n*                                    NEEDED THE R3 INDEX IS INCREMENTED\n*                                    BY A VALUE OF X'10'\n*\n         L     R2,DATA_AT\n*                                    LOAD R2 TO POINT TO THE BEGINNING\n*                                    LOCATION OF THE DATA\n*\nLOOP0    DS    0H\n*\n         LA    R15,MSG_TEXT\n*                                    SET R10 TO POINT TO THE BEGINNING\n*                                    LOCATION OF THE OUTPUT BUFFER\n*                                    FOR THE\n* \"DATA   +00000000  E3C8C9E2  40C9E240  E3C8C540  C4C1E3C1\" MESSAGE\n*\n         MVI   PE_MSG2B,PLUS_SIGN\n*                                    MOVE INTO THE OUTPUT BUFFER THE\n*                                    \"+\" SIGN FOR THE OFFSET INTO\n*                                    THE DATA DISPLACEMENT COUNTER\n*\n         ST    R3,HOLD\n*                                    STORE INTO THE VARIABLE HOLD THE\n*                                    OFFSET INTO THE DATA THAT\n*                                    IS CURRENTLY BEING PROCESSED\n*\n         BAL   R14,HEXCONV\n*                                    CALL HEXCONV TO CONVERT THE\n*                                    HEX DATA OFFSET COUNTER FOR\n*                                    \"+00000000\" FIELD OF THE\n* \"DATA   +00000000  E3C8C9E2  40C9E240  E3C8C540  C4C1E3C1\" MESSAGE\n*                                    INTO THE HEX CHARACTER\n*                                    EQUIVALENTS\n*\n         MVC   PE_MSG2C(L'WORKAREA/2),WORKAREA\n*                                    MOVE INTO THE OUTPUT BUFFER THE\n*                                    \"+00000000\" DATA OFFSET COUNTER\n*                                    RETURNED FROM HEXCONV\n*\n         LA    R15,PE_MSG2C\n*                                    REPOSITION THE OUTPUT\n*                                    BUFFER POINTER FOR THE REST\n*                                    OF THE OUTPUT FIELDS FOR THE\n* \"DATA   +00000000  E3C8C9E2  40C9E240  E3C8C540  C4C1E3C1\" MESSAGE\n*\n         L     R4,FOUR\n*                                    SET R4 TO THE MAXIMUM NUMBER\n*                                    OF ACTUAL DATA DISPLAY FIELDS\n*                                    THAT CAN BE PLACED IN THE OUTPUT\n*                                    BUFFER\n*\nLOOP1    DS    0H\n*\n         LA    R15,L'PE_MSG2C(,R15)\n*                                    BEFORE ANY DATA IS FORMATTED\n*                                    AND MOVED INTO THE OUTPUT\n*                                    BUFFER, POINT TO THE DATA\n*                                    TARGET BUFFER AREA\n* \"DATA   +00000000  E3C8C9E2  40C9E240  E3C8C540  C4C1E3C1\" MESSAGE\n*                    TARGET 1  TARGET 2  TARGET 3  TARGET 4\n*\n         C     R1,FOUR\n*                                    IF THERE ARE 4 OR LESS CHARACTERS\n*                                    LEFT TO FORMAT IN THE DATA AREA\n*                                    POINTED TO R2\n*\n         BNH   LESSTHAN\n*                                    THEN GET OUT OF THIS LOOP\n*\nLOOP2    DS    0H\n*                                    ELSE\n*\n         MVC   HOLD,0(R2)\n*                                    MOVE 4 BYTES OF THE DATA INTO\n*                                    THE VARIABLE HOLD SO THAT\n*                                    THE HEXCONV ROUTINE CAN CONVERT\n*                                    THE DATA FROM\n*                                    HEX CHARACTERS TO HEX CHARACTERS\n*                                    THAT CAN BE DISPLAYED\n*\n         BAL   R14,HEXCONV\n*                                    CALL HEXCONV TO CONVERT THE\n*                                    HEX DATA FOR THE OUTPUT BUFFER\n* \"DATA   +00000000  E3C8C9E2  40C9E240  E3C8C540  C4C1E3C1\" MESSAGE\n*\n         MVC   0(L'WORKAREA/2,R15),WORKAREA\n*                                    MOVE THE HEX CONVERTED DATA\n*                                    INTO THE TARGET 1, TARGET 2,\n*                                    TARGET 3, OR TARGET 4 FIELD OF\n*                                    THE\n* \"DATA   +00000000  E3C8C9E2  40C9E240  E3C8C540  C4C1E3C1\" MESSAGE\n*\n         S    R1,FOUR\n*                                    DECREMENT THE AMOUNT OF DATA\n*                                    LEFT IN THE DATA AREA REMAINING\n*                                    TO BE CONVERTED INTO HEX\n*                                    CHARACTERS THAT CAN BE DISPLAYED\n*\n         LA   R2,4(,R2)\n*                                    INCREMENT R2 BY 4. R2 POINTS TO\n*                                    THE NEXT 4 BYTES OF DATA THAT\n*                                    NEED TO BE PASSED THROUGH THE\n*                                    HEXCONV SUBROUTINE AND THEN\n*                                    MOVED INTO THE OUTPUT BUFFER\n*\n         BCT  R4,LOOP1\n*                                    IF THE TARGET 1 THROUGH TARGET 4\n*                                    FIELDS OF THE OUTPUT BUFFER HAVE\n*                                    BEEN ALREADY FILLED WITH HEX\n*                                    CONVERTED DATA FROM THE DATA\n*                                    AREA\n*\n         BAL  R14,PUTLINE\n*                                    CALL PUTLINE TO OUTPUT THE\n*                                    OUTPUT BUFFER THAT CONTAINS THE\n* \"DATA   +00000000  E3C8C9E2  40C9E240  E3C8C540  C4C1E3C1\"\n*        OR\n*        \"+00000010  E3C8C9E2  40C9E240  E3C8C540  C4C1E3C1\" MESSAGE\n*\n         LA   R3,16(,R3)\n*                                    INCREMENT THE DATA DISPLACEMENT\n*                                    INDEX BY X'10' TO MAKE THE\n*                                    DATA EASY TO LOCATE BY AN\n*                                    OFFSET\n*\n         B    LOOP0\n*                                    NEXT OUTPUT BUFFER HAS BEEN\n*                                    CLEARED AND IS READY FOR DATA\n*                                    INSERTION INTO THE TARGET FIELDS\n*                                    AND THE DATA OFFSET AREA\n*\nLESSTHAN DS   0H\n*\n         LA   R7,HOLD\n*                                    GET THE ADDRESS OF THE HOLD\n*                                    VARIABLE THAT WILL BE PASSED INTO\n*                                    HEXCONV\n*\n         ST   R1,TEMP\n*                                    SAVE THE LENGTH OF THE DATA\n*                                    IN THE DATA LINE LEFT TO\n*                                    FORMAT\n*\n         LTR  R1,R1\n*                                    IS THE LENGTH ZERO        @YA19583\n         BZ   LAST_PUT\n*                                    LENGTH IS ZERO SO BYPASS THE\n*                                    EXECUTION OF THE MOVE INSTRUCTION\n*                                                              @YA19583\n         BCTR R1,0\n*                                    DECREASE THE LENGTH FOR THE\n*                                    EXECUTION OF THE MOVE INSTRUCTION\n*                                                              @YA19583\n         EX   R1,HOLDMVC\n*                                    MOVE INTO THE HOLD\n*                                    VARIABLE THE REMAINING AMOUNT OF\n*                                    DATA THAT NEEDS TO GO THROUGH\n*                                    HEXCONV\n*\n         BAL   R14,HEXCONV\n*                                    CALL HEXCONV TO CONVERT THE\n*                                    HEX DATA FOR THE OUTPUT BUFFER\n* \"DATA   +00000000  E3C8C9E2  40C9E240  E3C8C540  C4C1E3C1\" MESSAGE\n*\n         L    R1,TEMP\n*                                    LOAD R1 WITH THE ORIGINAL LENGTH\n*                                    OF THE DATA THAT WAS\n*                                    LEFT TO FORMAT WHEN THIS\n*                                    SECTION OF CODE WAS ENTERED\n         AR   R1,R1\n*                                    DOUBLE ITS LENGTH\n*\n         BCTR R1,0\n*                                    DECREMENT THE LENGTH FOR THE\n*                                    MOVEMENT OF THE DATA FROM THE\n*                                    HEXCONV WORK AREA TO THE\n*                                    TARGET OUTPUT BUFFER\n*\n         EX   R1,LASTMVC\n*                                    MOVE THE DATA INTO THE OUTPUT\n*                                    BUFFER FROM WORKAREA FOR LENGTH\n*                                    OF R1\n*\nLAST_PUT DS    0H\nEXIT_FMTDATA DS 0H\n*\n         BAL  R14,PUTLINE\n*                                    CALL PUTLINE TO OUTPUT THE\n*                                    OUTPUT BUFFER THAT CONTAINS THE\n*\n* \"DATA   +00000000  E3C8C9E2  40C9E240  E3C8C540  C4C1E3C1\"\n*        OR\n*        \"+00000010  E3C8C9E2  40C9E240  E3C8C540  C4C1E3C1\" MESSAGE\n*\n*\n         LM    R0,R15,SAVE_AREA_6\n*                                    RESTORE ALL OF THE CALLER'S\n*                                    REGISTERS TO THEIR ORIGINAL\n*                                    VALUE\n*\n         BR    R14\n*                                    RETURN TO CALLER\n*\n         DROP  R15\n*                                    NO LONGER USE R15 TO POINT TO\n*                                    THE\n* \"DATA   +00000000  E3C8C9E2  40C9E240  E3C8C540  C4C1E3C1\"\n*                                    DSECT DESCRIPTION\n TITLE 'PUTLINE SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* PUTLINE                                                             *\n*                                                                     *\n* DESCRIPTIVE NAME - COMMON PUTLINE ROUTINE                           *\n*                                                                     *\n* FUNCTION -  DETERMINES WHETHER TO USE PUTLINE OR WTO BASED ON       *\n*             A FLAG THAT WAS SET IN THE INITIALIZATION CODE.         *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*    1).  SAVES ALL OF THE CALLER'S REGISTERS IN A LOCAL SAVE AREA    *\n*    2).  CHECKS TO SEE IF A WTO IS TO BE ISSUED                      *\n*         IF A WTO IS TO BE ISSUED THEN                               *\n*          {1}. CALL WTO                                              *\n*        ELSE USE PUTLINE TO PUT OUT THE MESSAGE                      *\n*          {1}. BUILDS THE IOPL                                       *\n*          {2}. INVOKES THE TSO/E PUTLINE FACILITY                    *\n*    3). CLEARS THE MESSAGE LINE FOR THE NEXT USER                    *\n*    4). RELOADS THE CALLER'S REGISTERS                               *\n*    5). RETURNS TO CALLER                                            *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nPUTLINE  DS    0H\n*\n         STM   R0,R15,SAVE_AREA_7\n*                                    SAVE ALL REGISTERS THE CALLER\n*                                    OF THIS SUBROUTINE PRESENTED\n*                                    SO THAT ANY REGISTER\n*                                    CAN EASILY BE USED\n*\n         LA    R10,MSG_TEXT\n*                                    LOAD R10 TO HAVE THE ADDRESS OF\n*                                    THE OUTPUT BUFFER\n*\n         USING PBUF,R10\n*                                    ESTABLISH ADDRESSABILITY TO THE\n*                                    OUTPUT BUFFER\n*                                    DSECT\n*\n         CLI   WTO_SWITCH,ISSUE_WTO_INDICATOR\n*                                    IF THE ISSUE_WTO_INDICATOR IS\n*                                    NOT ON\n*\n         BNE   NO_WTO\n*                                    THEN USE THE PUTLINE ROUTINE TO\n*                                    DISPLAY THE OUTPUT MESSAGE TO\n*                                    THE USER OF IKJEXIT\n*\n         BAL   R14,WTO\n*                                    ELSE IKJEXIT HAS DETERMINED THAT\n*                                    PUTLINE MAY NOT WORK CORRECTLY\n*                                    WITHIN THIS INVOCATION OF\n*                                    IKJEXIT AND WTOS WILL BE ISSUED\n*                                    TO THE MASTER CONSOLE\n*\n         B     EXIT_PUTLINE\n*                                    WTOS WERE USED TO OUTPUT THE\n*                                    DATA TO THE MASTER CONSOLE\n*                                    AND CLEAR THE OUTPUT BUFFER\n*                                    FOR THE NEXT USER WHO HAS DATA\n*                                    TO DISPLAY\n*\nNO_WTO   DS    0H\n*\n         L     R1,IOPL_PTR\n*                                    LOAD THE ADDRESS OF THE IOPL\n*                                    THAT WAS DEFINED WITHIN THE\n*                                    IKJEXIT DYNAMIC WORK AREA\n*\n         USING IOPL,R1\n*                                    ESTABLISH ADDRESSABILITY TO\n*                                    THE IOPL SO THE LABELS IN THE\n*                                    IOPL CAN BE REFERENCED\n*\n         L     R2,CPPL_PTR\n*                                    LOAD THE ADDRESS OF THE CPPL\n*                                    THAT WAS DEFINED WITHIN THE\n*                                    IKJEXIT DYNAMIC WORK AREA\n*\n         USING CPPL,R2\n*                                    ESTABLISH ADDRESSABILITY TO\n*                                    THE CPPL SO THE LABELS IN THE\n*                                    CPPL CAN BE REFERENCED\n*\n         L     R5,CPPLUPT\n*                                    LOAD R5 TO HAVE THE ADDRESS OF\n*                                    THE USER PROFILE TABLE (UPT)\n*                                    THAT WAS PASSED IN TO IKJEXIT\n*                                    ON THE INVOCATION ON IKJEXIT\n*\n         L     R6,CPPLECT\n*                                    LOAD R6 TO HAVE THE ADDRESS OF\n*                                    THE USER EVENT CONTOL TABLE (ECT)\n*                                    THAT WAS PASSED IN TO IKJEXIT\n*                                    ON THE INVOCATION ON IKJEXIT\n*\n         XC    ECB,ECB\n*                                    FORCE THE EVENT CONTROL BLOCK TO\n*                                    HAVE A VALUE OF ZERO SO THAT\n*                                    THE POSTING CAN BE CORRECTLY\n*                                    DONE BY PUTLINE\n*\n         MVI   MSG_LENGTH+1,HEX54\n*                                    MOVE INTO THE PUTLINE PARAMETER\n*                                    BLOCK (PTPB, PUTBLOK)\n*                                    THE LENGTH OF THE DATA THAT\n*                                    IS TO BE DISPLAYED PLUS THE\n*                                    LENGTH OF THE 4 BYTE HEADER\n*                                    IKJEXIT WILL ALWAYS INDICATE A\n*                                    LENGTH OF 80 CHARACTERS FOR\n*                                    OUTPUT + THE 4 BYTE HEADER\n*\n         PUTLINE PARM=PUTBLOK,       LABEL FOR THE PUTLINE MF=L        X\n               UPT=(5),              THE UPT                           X\n               ECT=(6),              THE ECT                           X\n               ECB=ECB,              THE ECB                           X\n               OUTPUT=(MSG_LENGTH,TERM,SINGLE,DATA),                   X\n               MF=(E,(1))            EXECUTE FORM OF PUTLINE MACRO\n*                                    ISSUE THE EXECUTE FORMAT OF\n*                                    THE PUTLINE MACRO\n*\n*        LTR   R15,R15\n*                                    IF THE RETURN CODE FROM PUTLINE\n*                                    IS ZERO\n*\n*        BZ    EXIT_PUTLINE\n*                                    THEN BRANCH TO LABEL EXIT_PUTLINE\n*                                    IN THIS SUBROUTINE\n*\n*        MVI   WTO_SWITCH,ISSUE_WTO_INDICATOR\n*                                    ELSE AN ERROR HAS OCCURRED IN\n*                                    PUTLINE PROCESSING SO A\n*                                    WTO WILL BE USED INSTEAD\n*\n*        BAL   R14,WTO\n*                                    CALL SUBROUTINE TO OUTPUT THE\n*                                    MESSAGES FROM NOW ON SINCE\n*                                    PUTLINE INDICATES AN ERROR\n*                                    OCCURRED\n         DROP  R2\n*                                    DROP ADDRESSABILITY TO THE\n*                                    CPPL\n*\n         DROP  R1\n*                                    DROP ADDRESSABILITY TO THE\n*                                    IOPL\n*\nEXIT_PUTLINE  DS    0H\n*\n         MVI   MSG_TEXT,BLANK\n*                                    PLACE A SPACE INTO THE FIRST\n*                                    POSITION OF THE MESSAGE OUTPUT\n*                                    BUFFER\n*\n         MVC   MSG_TEXT+1(L'MSG_TEXT-1),MSG_TEXT\n*                                    AND PROPAGATE THE BLANK ACROSS\n*                                    THE REST OF THE MESSAGE OUTPUT\n*                                    BUFFER IN CASE THERE WAS ANY\n*                                    RESIDUAL DATA IN THE OUTPUT\n*                                    BUFFER FOR THE NEXT USER\n*\n         LM    R0,R15,SAVE_AREA_7\n*                                    RESTORE ALL OF THE CALLER'S\n*                                    REGISTERS TO THEIR ORIGINAL\n*                                    VALUE\n*\n         BR    R14                   RETURN TO CALLER\n*\n         DROP  R10\n*                                    NO LONGER USE R10 TO POINT TO\n*                                    THE OUTPUT BUFFER\n*                                    DSECT DESCRIPTION\n TITLE 'WTO SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* WTO                                                                 *\n*                                                                     *\n* DESCRIPTIVE NAME - WTO SUBROUTINE                                   *\n*                                                                     *\n* FUNCTION -  OUTPUTS THE MESSAGES TO THE MVS MASTER CONSOLE          *\n*             INSTEAD OF THE TSO/E USER'S SCREEN.                     *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*    1). SAVES ALL OF THE CALLER'S REGISTERS IN A LOCAL SAVE AREA     *\n*    2). COPIES THE STATIC FORM OF THE WTO MF=L TO THE DYNAMIC        *\n*        FORM OF THE PARAMETER LIST                                   *\n*    3). INSERTS THE WTO MESSAGE TEXT                                 *\n*    4). ISSUES THE EXECUTE FORM OF THE WTO POINTING TO THE           *\n*        DYNAMIC FORM OF THE MACRO LIST                               *\n*    5). RELOADS THE CALLER'S REGISTERS                               *\n*    6). RETURNS TO CALLER                                            *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nWTO      DS    0H\n*\n         STM   R0,R15,SAVE_AREA_8\n*                                    SAVE ALL REGISTERS THE CALLER\n*                                    OF THIS SUBROUTINE PRESENTED\n*                                    SO THAT ANY REGISTER\n*                                    CAN EASILY BE USED\n*\n         LA    R10,MSG_TEXT\n*                                    LOAD R10 TO HAVE THE ADDRESS OF\n*                                    THE OUTPUT BUFFER\n*\n         USING PBUF,R10\n*                                    ESTABLISH ADDRESSABILITY\n*                                    TO THE OUTPUT BUFFER\n*                                    DSECT\n*\n         L     R1,WTO_LIST_PTR\n*                                    POINT TO THE DYNAMIC WTO LIST\n*                                    LOAD R1 TO HAVE THE ADDRESS\n*                                    OF WHERE THE DYNAMIC WTO LIST\n*                                    FORM OF THE MACRO IS TO BE COPIED\n*\n         MVC   0(LWTOLST,R1),WTOLIST\n*                                    COPY INTO THE DYNAMIC WTO AREA\n*                                    THE STATIC FORM OF THE WTO\n*                                    LIST\n*\n         L     R2,WTO_TEXT_PTR\n*                                    LOAD R2 TO HAVE THE ADDRESS OF\n*                                    THE WTO MESSAGE TEXT AREA\n*\n         MVC   0(L'MSG_TEXT,R2),MSG_TEXT\n*                                    MOVE INTO THE WTO OUTPUT BUFFER\n*                                    THE ORIGINAL OUTPUT BUFFER\n*                                    CONTENTS IF THE PUTLINE WAS USED\n*\n         WTO   MF=(E,(1))\n*                                    ISSUE THE EXECUTE FORM OF THE\n*                                    WTO MACRO\n*\nEXIT_WTO DS    0H\n*\n         LM    R0,R15,SAVE_AREA_8    RESTORE ALL OF THE CALLER'S\n*                                    REGISTERS TO THEIR ORIGINAL\n*                                    VALUE\n*\n         BR    R14                   RETURN TO CALLER\n*\n         DROP  R10\n*                                    NO LONGER USE R10 TO POINT TO\n*                                    THE OUTPUT BUFFER\n*                                    DSECT DESCRIPTION\n TITLE 'HEXCONV SUBOUTINE'\n***********************************************************************\n* HEXCONV                                                             *\n*                                                                     *\n* DESCRIPTIVE NAME - CONVERTS HEX CHARACTERS TO CHARACTERS THAT       *\n*                    CAN BE DISPLAYED                                 *\n*                                                                     *\n* FUNCTION -  CONVERTS HEX DATA THAT CAN NOT BE DISPLAYED INTO        *\n*             HEX DATA THAT CAN BE DISPLAYED                          *\n*                                                                     *\n* OPERATION -                                                         *\n*                                                                     *\n*    1). SAVES ALL OF THE CALLER'S REGISTERS IN A LOCAL SAVE AREA     *\n*    2). CONVERTS THE HEX DATA INTO CHARACTERS THAT CAN BE DISPLAYED  *\n*    3). RELOADS THE CALLER'S REGISTERS                               *\n*    4). RETURNS TO CALLER                                            *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nHEXCONV  DS    0F\n*\n         STM   R0,R15,SAVE_AREA_9\n*                                    SAVE ALL REGISTERS THE CALLER\n*                                    OF THIS SUBROUTINE PRESENTED\n*                                    SO THAT ANY REGISTER\n*                                    CAN EASILY BE USED\n*\n         UNPK  WORKAREA(9),HOLD(L'HOLD+1)\n*                                    TAKE EACH NIBBLE OF THE HOLD\n*                                    VARIABLE AND PLACE IT IN THE\n*                                    LOW ORDER NIBBLE OF THE WORKAREA\n*                                    VARIABLE. THE HIGH ORDER NIBBLE\n*                                    OF THE WORKAREA VARIABLE WILL\n*                                    CONTAIN A X'F'\n*\n*\n         TR    WORKAREA(8),TRTBL-240\n*                                    ENSURE THE HIGH ORDER NIBBLE\n*                                    OF EACH BYTE IN THE WORKAREA\n*                                    VARIABLE CONTAINS THE CORRECT\n*                                    VALUE FOR THE CHARACTER THAT\n*                                    IS BEING TRANSLATED.\n*                                    THE VALID CHARACTERS ARE\n*                                    C - FOR CHARACTERS A-F\n*                                    F - FOR CHARACTERS 0-9\n*\nEXIT_HEXCONV  DS    0F\n*\n         LM    R0,R15,SAVE_AREA_9\n*                                    RESTORE ALL OF THE CALLER'S\n*                                    REGISTERS TO THEIR ORIGINAL\n*                                    VALUE\n*\n         BR    R14\n*                                    RETURN TO CALLER\n*\n         DS    0F\n TITLE 'EXECUTED INSTRUCTIONS'\n***********************************************************************\n* EXECUTED INSTRUCTIONS.                                              *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nHOLDMVC  MVC   0(0,R7),0(R2)\nLASTMVC  MVC   0(0,R15),WORKAREA\n TITLE 'STATIC VARIABLES'\n*\n***********************************************************************\n* DECLARES OF ALL CONSTANTS USED BY THIS MODULE FOLLOW                *\n***********************************************************************\n*\n         SPACE 3\nWORKAREA_ID_CONSTANT DC C'WORKAREA'\nKEY_OF_TWO      DC    F'2'          INDICATES PARAMETER_ENTRY_DATA\n*                                   IS INDIRECT\nMAXIMUM_KEY_VALUE DC  F'4'          VALID PARAMETER_ENTRY_KEY VALUES\n*                                   X'00000000' THROUGH X'00000003'\n*\n*        INFORMATIONAL ERROR MESSAGES\n*\n*\nBAD_KEY_MSG     DC    C'THE PARAMETER_ENTRY_KEY FOR THIS PARAMETER_ENTRY\n               Y CONTAINS AN UNDEFINED KEY'\nBAD_LENGTH_MSG1 DC    C'THE PARAMETER_ENTRY_LENGTH FOR THIS PARAMETER_EX\n               NTRY HAS A VALUE OF ZERO'\nBAD_LENGTH_MSG2 DC    C'THE PARAMETER_ENTRY_LENGTH MUST CONTAIN A VALUEX\n                NOT LESS THAN X''00000004'' '\nBAD_LENGTH_MSG3 DC   C'IF THE PARAMETER_ENTRY_KEY IS X''00000000'', OR X\n               X''00000003'' '\nBAD_LENGTH_MSG4 DC   C'IF THE PARAMETER_ENTRY_KEY IS X''00000001'', OR X\n               X''00000002'' '\nBAD_LENGTH_MSG5 DC   C'THE PARAMETER_ENTRY_LENGTH MAY CONTAIN A VALUE OX\n               F X''00000001'' '\nBAD_LENGTH_MSG6 DC   C'THE PARAMETER_ENTRY_LENGTH MAY NOT CONTAIN A NEGX\n               ATIVE LENGTH'\nFOUR            DC    F'4'\nSIXTEEN         DC    F'16'\n*\n*\n*        CONSTANTS THAT ARE PLACED INTO VARIOUS MESSAGE LINES\n*\n*\nEXIT_NAME       DC    CL8'IKJEXIT'\nDATA            DC    CL4'DATA'\nKEY_EQU         DC    CL7'KEY -> '\nLENGTH_OF_DATA  DC    CL18'LENGTH OF DATA -> '\nADDRESS_OF_DATA DC    CL19'ADDRESS OF DATA -> '\nPE              DC    CL2'PE'\nTRTBL           DC    CL16'0123456789ABCDEF'\nPE_AT_TEXT1     DC    CL16'PARAMETER_ENTRY_'\nPE_AT_TEXT2     DC    CL9'IS AT -> '\n*\n*\n*        LIST FORM OF THE WTO MACTO\n*\n*\nWTOLIST  WTO ('                                                        X\n                                       '),                             X\n               ROUTCDE=(2),            MASTER CONSOLE AND WTP          X\n               DESC=(5),                                               X\n               MCSFLAG=(NOTIME),                                       X\n               MF=L\nLWTOLST        EQU *-WTOLIST\n TITLE 'DYNAMIC SAVE AREA'\n***********************************************************************\n* IKJEXIT'S DYNAMIC SAVE AREA                                         *\n***********************************************************************\n*\n         SPACE 3\nSAVE_AREA                DSECT\nSAVE_AREA_0              DS 0CL72    STANDARD SAVE AREA\n                         DS  F       UNUSED\nB_PTR                    DS  F       BACKWARD SAVE AREA POINTER\nF_PTR                    DS  F       FORWARD SAVE AREA POINTER\nREG14                    DS  F       CONTENTS OF REGISTER 14\nREG15                    DS  F       CONTENTS OF REGISTER 15\nREG0                     DS  F       CONTENTS OF REGISTER 0\nREG1                     DS  F       CONTENTS OF REGISTER 1\nREG2                     DS  F       CONTENTS OF REGISTER 2\nREG3                     DS  F       CONTENTS OF REGISTER 3\nREG4                     DS  F       CONTENTS OF REGISTER 4\nREG5                     DS  F       CONTENTS OF REGISTER 5\nREG6                     DS  F       CONTENTS OF REGISTER 6\nREG7                     DS  F       CONTENTS OF REGISTER 7\nREG8                     DS  F       CONTENTS OF REGISTER 8\nREG9                     DS  F       CONTENTS OF REGISTER 9\nREG10                    DS  F       CONTENTS OF REGISTER 10\nREG11                    DS  F       CONTENTS OF REGISTER 11\nREG12                    DS  F       CONTENTS OF REGISTER 12\nL_SAVE_AREA              EQU *-SAVE_AREA\n TITLE 'DYNAMIC WORK AREA'\n***********************************************************************\n* DECLARES OF ALL DYNAMIC VARIABLES USED BY THIS MODULE FOLLOW        *\n***********************************************************************\n*\n         SPACE 3\nWORKA    DSECT\nWORK_AREA_ID             DS  CL8     WORKAREA ID\nSAVE_AREA_1              DS  18F     SAVE AREA 1\nSAVE_AREA_2              DS  18F     SAVE AREA 2\nSAVE_AREA_3              DS  18F     SAVE AREA 3\nSAVE_AREA_4              DS  18F     SAVE AREA 4\nSAVE_AREA_5              DS  18F     SAVE AREA 5\nSAVE_AREA_6              DS  18F     SAVE AREA 6\nSAVE_AREA_7              DS  18F     SAVE AREA 7\nSAVE_AREA_8              DS  18F     SAVE AREA 8\nSAVE_AREA_9              DS  18F     SAVE AREA 9\n         SPACE 1\nGM_PTR                   DS  F       ADDRESS OF GETMAIN\nCPPL_PTR                 DS  F       ADDRESS OF THE CPPL\nIOPL_PTR                 DS  F       ADDRESS OF THE IOPL\nWTO_LIST_PTR             DS  F       ADDRESS OF DYNAMIC WTO AREA\nWTO_TEXT_PTR             DS  F       ADDRESS OF DYNAMIC WTO TEXT AREA\nPBUF_LENGTH              DS  F       TRUE LENGTH OF PBUF\nPBUF_PTR                 DS  F       ADDRESS OF THE PBUF\nPARAMETER_ENTRY_PTR      DS  F       ADDRESS OF THE PARAMETER_ENTRY\nR1_ENTRY_PARAMETER_LIST_PTR DS F     ADDRESS OF THE PARAMETER LIST\n*                                    THAT WAS PASSED INTO IKJEXIT\n         SPACE 1\nTEMP                     DS  F       HOLDS THE LENGTH OF THE DATA\nECB                      DS  F       IKJEXIT'S ECB\nRETCODE                  DS  F       THE RETURN CODE HOLDER\nPUTBLOK  PUTLINE MF=L                LIST FORM OF PUTLINE MACRO\nMSG_LENGTH               DS  H       LENGTH OF MSG + LENGTH OF....\n                         DS  H       FIRST TWO HALF WORDS\nMSG_TEXT                 DS  CL80    HERE'S WHERE MESSAGE TEXT GOES\n                         DS  0F      ALIGN ON A FULL WORD\nEND_OF_PARAMETER_LIST    DS  F       HAS AN ADDRESS OUT OF THE\n*                                    PARAMETER LIST PASSED IN TO\n*                                    IKJEXIT FROM CALLING MODULE\nDATA_AT                  DS  F\nHOLD                     DS  2F      PARAMETER PASSED TO HEXCONV\nWORKAREA                 DS  CL16    WORK AREA FOR HEXCONV\nCOUNT                    DS  F       HAS THE \"ZZ\" VALUE\nORIGINAL_DATA_LENGTH     DS  F       WORK AREA FOR LENGTH OF DATA\nWTO_SWITCH               DS  CL1     PUTLINE OR WTO\nBAD_KEY_SWITCH           DS  CL1     INVALID PARAMETER_ENTRY_KEY\n*                                    FOUND INDICATOR\n                         DS  0D      ALIGN ON A DOUBLE WORD\nLWORKA   EQU   *-WORKA LENGTH OF THIS WORK AREA\n*\n TITLE 'IKJCPPL MAPPING MACRO'\nCPPL_START EQU LWORKA\n         IKJCPPL                     HERE IS THE CPPL\nLCPPL    EQU   *-CPPL                DESCRIBES LENGTH OF THE CPPL DSECT\n TITLE 'IKJIOPL MAPPING MACRO'\nIOPL_START EQU LCPPL+CPPL_START\n         IKJIOPL                     HERE IS THE IOPL\nLIOPL    EQU   *-IOPL                DESCRIBES LENGTH OF THE IOPL DSECT\n TITLE 'DYNAMIC WTO  WORKA AREA'\nWTO_START EQU LIOPL+IOPL_START\nTLEN     EQU LCPPL+LIOPL+LWORKA+LWTOLST\n*                                    TOTAL LENGTH OF IKJEXIT'S\n*                                    DYNAMIC WORK AREA\n TITLE 'PBUF MAPPING DSECT'\nPBUF     DSECT                       PRINT BUFFER DSECT\n         DS    CL80                  MESSAGE TEXT IS 80 CHARS WIDE\nLPBUF    EQU   *-PBUF                LENGTH OF PBUF DSECT\n TITLE 'PARAMETER_ENTRY DSECT MAPPING'\nPARAMETER_ENTRY        DSECT         DESCRIBE THE PARAMETER_ENTRY\n                        DS  0F       ALIGN ON A FULL WORD\nPARAMETER_ENTRY_KEY     DS  F        HERE'S THE KEY FIELD\nPARAMETER_ENTRY_LENGTH  DS  F        HERE'S THE LENGTH OF THE DATA\nPARAMETER_ENTRY_DATA    DS  CL4088   HERE'S THE DATA/ PTR TO DATA\nLPARAMETER_ENTRY        EQU *-PARAMETER_ENTRY\n*                                    LENGTH OF PARAMETER_ENTRY DSECT\n TITLE 'PE_MSG1 MAPPING DSECT'\nPE_MSG1  DSECT\nPEMSG1   DS    0CL80                 MSG1\nPE_MSG1A DS    CL2                   SAYS PE\nPE_MSG1H DS    CL2                        ZZ\n         DS    CL2\nPE_MSG1B DS    CL7                   SAYS 'KEY -> '\nPE_MSG1C DS    CL8                   HEX DATA X..X\n         DS    CL2\nPE_MSG1D DS    CL18                  'LENGTH OF DATA -> '\nPE_MSG1E DS    CL8                   HEX DATA X..X\n         DS    CL2\nPE_MSG1F DS    CL19                  'ADDRESS OF DATA -> '\nPE_MSG1G DS    CL8                   HEX DATA X..X\n         DS    CL2\nLPE_MSG1 EQU   *-PE_MSG1             AND HERE'S THE LENGTH OF N\n TITLE 'PE_MSG2 MAPPING DSECT'\nPE_MSG2  DSECT\nPEMSG2   DS    0CL80                 MSG1\nPE_MSG2A DS    CL4                   'DATA'\n         DS    CL3\nPE_MSG2B DS    CL1                   '+'\nPE_MSG2C DS    5CL12                 HEX DATA X..X\n         DS    CL12\nLPE_MSG2 EQU   *-PE_MSG2             AND HERE'S THE LENGTH OF N\n         SPACE 3\nPE_MSG0  DSECT\nPEMSG0   DS    0CL80                 MSG1\nPE_MSG0A DS    CL16                  PARAMETER_ENTRY_\nPE_MSG0B DS    CL2                   NN\n         DS    CL1                   '+'\nPE_MSG0C DS    CL9                   IS AT ->\n         DS    CL1\nPE_MSG0D DS    CL8                    X..X\n         DS    CL43\nLPE_MSG0 EQU   *-PE_MSG0             AND HERE'S THE LENGTH OF N\n TITLE 'CVT MAPPING MACRO'\n         CVT  DSECT=YES              HERE IS THE CVT FOR CALLTSSR\n TITLE 'IKJTSVT MAPPING MACRO'\n         IKJTSVT                     HERE IS THE TSVT FOR TSSR\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IKJLPENU": {"ttr": 4102, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x91$\\x9f\\x00\\x912O\\t@\\x00|\\x03L\\x00|\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1991-09-06T00:00:00", "modifydate": "1991-11-20T09:40:00", "lines": 124, "newlines": 844, "modlines": 124, "user": "SALBERT"}, "text": "//IKJLPENU JOB (U32048,DCSG),GUY,CLASS=E,MSGCLASS=T\n//A EXEC ASMHC,MAC1='IPO1.NEW.BFGMODS'\n//SYSPUNCH  DD  DSN=&T1\n//SYSIN DD *\n         COPY  MACLPENU\n         EJECT\n         PANEL START,NAME=IKJLPENU,                                    X\n               MSG1=MSG1,                                              X\n               MSG2=MSG2,                                              X\n               USERFLD=INSTHEAD,                                       X\n               OTITLE=RACF_TITLE\n*\n**       First 14 fields **must** remain in this order. IBM requirement\n**       (Change the address values if you want to move them around.)\n*\n         FLD   AD1=(6,3),AT1=60,                       **  1 **        X\n               TXT1='CL15'' Userid    ===>''',                         X\n               AD2=(6,19),AT2=E8,                                      X\n               TXT2='XL7''00'''\n         FLD   AD1=(7,3),AT1=60,                       **  2 **        X\n               TXT1='CL15'' Password  ===>''',                         X\n               AD2=(7,19),AT2=6C,                                      X\n               TXT2='XL8''00'''\n         FLD   AD1=(09,3),AT1=60,                      **  3 **        X\n               TXT1='CL15'' Acct Nmbr ===>''',                         X\n               AD2=(09,19),AT2=E8,                                     X\n               TXT2='XL40''00'''\n         FLD   AD1=(08,3),AT1=60,                      **  4 **        X\n               TXT1='CL15'' Procedure ===>''',                         X\n               AD2=(08,19),AT2=E8,                                     X\n               TXT2='XL08''00'''\n         FLD   AD1=(10,3),AT1=60,                      **  5 **        X\n               TXT1='CL15'' Size      ===>''',                         X\n               AD2=(10,19),AT2=E8,                                     X\n               TXT2='XL07''00'''\n         FLD   AD1=(11,3),AT1=60,                      **  6 **        X\n               TXT1='CL15'' Perform   ===>''',                         X\n               AD2=(11,19),AT2=E8,                                     X\n               TXT2='XL03''00'''\n         FLD   AD1=(07,51),AT1=60,                     **  7 **        X\n               TXT1='CL18'' New Password ===>''',                      X\n               AD2=(07,70),AT2=6C,                                     X\n               TXT2='XL08''00'''\n         FLD   AD1=(08,51),AT1=60,                     **  8 **        X\n               TXT1='CL18'' Group Ident  ===>''',                      X\n               AD2=(08,70),AT2=E8,                                     X\n               TXT2='XL08''00'''\n         FLD2  AD1=(21,08),AT1=E8,                     **  9 **        X\n               TXT1='XL01''00''',                                      X\n               AD2=(21,10),AT2=F0,                                     X\n               TXT2='CL7''-Nomail'''\n         FLD2  AD1=(21,24),AT1=E8,                     ** 10 **        X\n               TXT1='XL01''00''',                                      X\n               AD2=(21,26),AT2=F0,                                     X\n               TXT2='CL9''-Nonotice'''\n         FLD2  AD1=(21,41),AT1=E8,                     ** 11 **        X\n               TXT1='XL01''00''',                                      X\n               AD2=(21,43),AT2=F0,                                     X\n               TXT2='CL10''-Reconnect'''\n         FLD2  AD1=(21,59),AT1=E8,                     ** 12 **        X\n               TXT1='XL01''00''',                                      X\n               AD2=(21,61),AT2=F0,                                     X\n               TXT2='CL9''-OIDcard'''\n         FLD   AD1=(12,03),AT1=60,                     ** 13 **        X\n               TXT1='CL15'' Command   ===>''',                         X\n               AD2=(12,19),AT2=6C,                                     X\n               TXT2='CL80'' '''\n         FLD   AD1=(06,51),AT1=60,                     ** 14 **        X\n               TXT1='CL18'' Seclabel     ===>''',                      X\n               AD2=(06,70),AT2=6C,                                     X\n               TXT2='CL08'' '''\nINSTHEAD FLD   AD1=(14,3),AT1=60,                                      X\n               TXT1='CL15'' Address   ===>''',                         X\n               AD2=(14,19),AT2=E8,                                     X\n               TXT2='XL60''00'''\n         FLD   AD1=(15,3),AT1=60,                                      X\n               TXT1='CL15'' Progrmr Nm===>''',                         X\n               AD2=(15,19),AT2=E8,                                     X\n               TXT2='XL20''00'''\n         FLD   AD1=(15,51),AT1=60,                                     X\n               TXT1='CL18'' CPU Time     ===>''',                      X\n               AD2=(15,70),AT2=E8,                                     X\n               TXT2='XL04''00'''\n         FLD   AD1=(16,3),AT1=60,                                      X\n               TXT1='CL15'' Room Numbr===>''',                         X\n               AD2=(16,19),AT2=E8,                                     X\n               TXT2='XL04''00'''\n         FLD   AD1=(16,51),AT1=60,                                     X\n               TXT1='CL18'' Form Code    ===>''',                      X\n               AD2=(16,70),AT2=E8,                                     X\n               TXT2='XL04''00'''\n         FLD   AD1=(17,3),AT1=60,                                      X\n               TXT1='CL15'' MSG Class ===>''',                         X\n               AD2=(17,19),AT2=E8,                                     X\n               TXT2='XL01''00'''\n         FLD   AD1=(17,51),AT1=60,                                     X\n               TXT1='CL18'' MSG Level    ===>''',                      X\n               AD2=(17,70),AT2=E8,                                     X\n               TXT2='XL08''00'''\n         FLD   AD1=(18,3),AT1=60,                                      X\n               TXT1='CL15'' Copies    ===>''',                         X\n               AD2=(18,19),AT2=E8,                                     X\n               TXT2='XL03''00'''\n         FLD   AD1=(18,51),AT1=60,                                     X\n               TXT1='CL18'' Line Count   ===>''',                      X\n               AD2=(18,70),AT2=E8,                                     X\n               TXT2='XL03''00'''\n         FLD2  AD1=(22,08),AT1=E8,                                     X\n               TXT1='XL01''00''',                                      X\n               AD2=(22,10),AT2=F0,                                     X\n               TXT2='CL4''-JCL'''\n         FLD2  AD1=(22,24),AT1=E8,                                     X\n               TXT1='XL01''00''',                                      X\n               AD2=(22,26),AT2=F0,                                     X\n               TXT2='CL9''-Listinfo'''\n         FLD   END\n*   OTHER FIELDS\n  PUNCH '  COPY ORGLPEN1 '\n         PANEL END,CURAD=(8,20)\n//B EXEC ASMHCL,MAC1='IPO1.NEW.BFGMODS',\n//   PARM.LKED='RENT,REUS,XREF,LET,LIST,NCAL,SIZE=(384K,96K)'\n//ASM.SYSIN DD  DSN=&T1,DISP=(OLD,DELETE)\n//LKED.SYSLMOD DD DSN=SYS1.ESA42.BFGLPA(IKJLPENU),DISP=SHR,UNIT=,\n//      SPACE=\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JCLEFLDN": {"ttr": 4105, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x00\\x00\\x91$/\\x00\\x92\\x04/\\x13V\\x00\\x18\\x00\\x1d\\x00\\x14\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1991-08-30T00:00:00", "modifydate": "1992-02-11T13:56:00", "lines": 24, "newlines": 29, "modlines": 20, "user": "SALBERT"}, "text": "//IKJEFLDN  JOB  (U32048,DCSG),GUY,CLASS=R,MSGCLASS=T,NOTIFY=SALBERT\n//ASMIT  EXEC  ASMHC,MAC1='SYS1.MODGEN',\n//        MAC='SYS1.MACLIB',\n//        PARM.ASM='XREF(SHORT)'\n//ASM.SYSIN  DD  DSN=IPO1.BFGMODS(IKJEFLDN),DISP=SHR\n//*\n//ASMIT  EXEC  ASMHC,MAC1='SYS1.MODGEN',\n//        MAC='SYS1.MACLIB',\n//        PARM.ASM='XREF(SHORT)'\n//ASM.SYSIN  DD  DSN=IPO1.BFGMODS(IKJEXIT1),DISP=SHR\n//*\n//LINKIT  EXEC  LKED,COND.LKED=(0,NE),\n//      PARM.LKED='LIST,LET,XREF,NCAL,RENT,REUS,AC=1,SIZE=(384K,96K)'\n//LKED.SYSLMOD  DD  DSN=SYS1.SOFTJOB,DISP=SHR,UNIT=,SPACE=\n//LKED.MYOBJ  DD  DSN=&&LOADSET,DISP=(OLD,DELETE)\n//LKED.SYSIN  DD *\n  INCLUDE MYOBJ\n  ALIAS IKJEFLN1\n  ALIAS IKJEFLN2\n  ALIAS IKJEFLD3\n  ENTRY IKJEFLD1\n  NAME IKJEFLD1(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MACLPENU": {"ttr": 4107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x91%O\\x00\\x91'/\\x18X\\x00\\xcb\\x00\\xc9\\x00\\x02\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1991-09-11T00:00:00", "modifydate": "1991-09-29T18:58:00", "lines": 203, "newlines": 201, "modlines": 2, "user": "SALBERT"}, "text": "         MACRO\n         PANEL &TYPE,                                                  X\n               &NAME=,                                                 X\n               &USERFLD=,                                              X\n               &MSG1=,                                                 X\n               &MSG2=,                                                 X\n               &CURAD=,                                                X\n               &OTITLE=\n         GBLC  &BBB1,&BBBL\n         AIF   ('&TYPE' NE 'START').TRYEND\n  PUNCH 'ZPANEL  CSECT                                                '\n  PUNCH 'ZPANEL  AMODE 31                                             '\n  PUNCH 'ZPANEL  RMODE ANY                                            '\n  PUNCH ' DC    CL8''&NAME''                                          '\n  PUNCH ' DC    CL8''&&SYSTIME''                                      '\n  PUNCH ' DC    CL8''&&SYSDATE''                                      '\n  PUNCH ' DC    AL2(ZLC4-ZPANEL)    LENGTH OF PANEL                   '\n  PUNCH ' DC    AL2(1)              PANEL VERSION                     '\n  PUNCH ' DC    AL2(ZLC0-ZPANEL)    START OF OFFSET ARRAY             '\n  PUNCH ' DC    AL2(ZLC1-ZPANEL)    START OF PANEL                    '\n         AIF   ('&MSG1' EQ '').ST10A\n  PUNCH ' DC    AL2(&MSG1-ZPANEL)   MSG 1                             '\n         AGO   .ST10B\n.ST10A   ANOP\n  PUNCH ' DC    AL2(0)              MSG 1                             '\n.ST10B   ANOP\n         AIF   ('&MSG2' EQ '').ST20A\n  PUNCH ' DC    AL2(&MSG2-ZPANEL)   MSG 2                             '\n         AGO   .ST20B\n.ST20A   ANOP\n  PUNCH ' DC    AL2(0)              MSG 2                             '\n.ST20B   ANOP\n  PUNCH ' DC    AL2(ZLC3-ZPANEL)    INSERT CURSOR ADDRESS             '\n         AIF   ('&USERFLD' EQ '').ST30A\n  PUNCH ' DC    AL2(&USERFLD-ZPANEL)  1ST INSTALL DEFINED HEADER      '\n         AGO   .ST30B\n.ST30A   ANOP\n  PUNCH ' DC    AL2(0)              FIRST INSTALL DEFINED HEADER      '\n.ST30B   ANOP\n  PUNCH ' DC    AL2(ZLC4-ZLC1)      LENGTH OF PANEL ITSELF            '\n  PUNCH ' DC    AL2(ZLC2-ZPANEL)    WCC                               '\n         AIF   ('&OTITLE' EQ '').ST40A\n  PUNCH ' DC    AL2(&OTITLE-ZPANEL) OFFSET TO OPTIONAL TITLE          '\n  PUNCH ' DC    AL2(L''&OTITLE)     LENGTH OF OPTIONAL TITLE          '\n         AGO   .ST40B\n.ST40A   ANOP\n  PUNCH ' DC    AL2(0)              OFFSET TO OPTIONAL TITLE          '\n  PUNCH ' DC    AL2(0)              LENGTH OF OPTIONAL TITLE          '\n.ST40B   ANOP\n  PUNCH 'ZLC0 DS    0F                                                '\n         MEXIT\n.TRYEND  AIF   ('&TYPE' NE 'END').ER1\n  PUNCH ' AGO   .&BBB1                                                '\n  PUNCH '.&BBBL   ANOP                                                '\n  PUNCH ' DC    X''11''                                               '\n  PUNCH 'ZLC3 DS   0X                                                 '\n         GRC   &CURAD                       CURSOR ADDRESS            '\n  PUNCH ' DC    X''13''                                               '\n  PUNCH 'ZLC4 EQU  *                                                  '\n  PUNCH ' END                                                         '\n         END\n         MEXIT\n.ER1     MNOTE 8,'PANEL TYPE IS NEITHER START NOR END'\n         MEND\n         MACRO\n&NAME    FLD   &TYPE,                                                  X\n               &AD1=,              ADDRESS OF INFO                     X\n               &AT1=,              ATTRIBUTE OF INFO                   X\n               &TXT1=,             TEXT OF INFO                        X\n               &AD2=,              ADDRESS OF DATA                     X\n               &AT2=,              ATTRIBUTE OF DATA                   X\n               &TXT2=              TEXT OF DATA\n         GBLC  &BBB1,&BBBL\n         LCLC  &LB1,&LB2,&LB3,&LB4,&AA,&TXT\n         LCLA  &I\n         AIF   ('&TYPE' NE '').TRYEND\n&LB1     SETC  'ZLB1&SYSNDX'\n&LB2     SETC  'ZLB2&SYSNDX'\n&LB3     SETC  'ZLB3&SYSNDX'\n&LB4     SETC  'ZLB4&SYSNDX'\n&AA      SETC  'ZAA&SYSNDX'\n         AIF   ('&BBB1' NE '').OK1\n&BBBL    SETC  'ZBB100'\n&BBB1    SETC  'ZBB100'\n.OK1     ANOP\n  PUNCH '&NAME DC    AL2(&LB1-ZPANEL)    HIGHLIGHT ATTR               '\n  PUNCH ' DC    AL2(&LB2-ZPANEL)    HIGHLIGHT CHAR                    '\n  PUNCH ' DC    AL2(&LB3-ZPANEL)    PROT ATTR                         '\n         GRC   &AD2,INCR\n  PUNCH ' DC    AL2(L''&LB4)        LENGTH OF INPUT FIELD             '\n  PUNCH ' DC    AL2(&LB4-ZPANEL)    INPUT FIELD                       '\n  PUNCH ' DC    AL2(0,0)            RESERVED                          '\n  PUNCH ' AGO   .&AA                                                  '\n  PUNCH '.&BBBL ANOP                                                  '\n&BBBL    SETC  'ZBB1&SYSNDX'\n  PUNCH ' DC    X''11''                                               '\n         GRC   &AD1\n  PUNCH ' DC    X''1D''                                               '\n  PUNCH '&LB1 DC    X''&AT1''                                         '\n&I       SETA  K'&TXT1\n&TXT     SETC  '&TXT1'(2,&I-2)\n  PUNCH '&LB2 DC    &TXT'\n  PUNCH ' DC    X''11''                                               '\n         GRC   &AD2\n  PUNCH ' DC    X''1D''                                               '\n  PUNCH '&LB3 DC    X''&AT2''                                         '\n&I       SETA  K'&TXT2\n&TXT     SETC  '&TXT2'(2,&I-2)\n  PUNCH '&LB4 DC    &TXT'\n  PUNCH ' DC    X''1DF0''                                             '\n  PUNCH ' AGO   .&BBBL                                                '\n  PUNCH '.&AA     ANOP                                                '\n         MEXIT\n.TRYEND  AIF   ('&TYPE' NE 'END').ER1\n  PUNCH ' DC    XL16''FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF''              '\n  PUNCH 'ZLC1 DC    X''27F5''           EXC, ERASE WRITE              '\n  PUNCH 'ZLC2 DC    X''C3''             WCC                           '\n  PUNCH ' DC    X''114040''         SET BUFFER TOP LEFT OF SCREEN     '\n  PUNCH ' DC    X''3C404040''       REPEAT BLANK TO TOP OF SCREEN     '\n         MEXIT\n.ER1     MNOTE 8,'FIELD TYPE IS NOT END OR NULL'\n         MEND\n         MACRO\n&NAME    FLD2  &TYPE,       ** FIELD NAME FOLLOWING INPUT **           X\n               &AD1=,              ADDRESS OF INFO                     X\n               &AT1=,              ATTRIBUTE OF INFO                   X\n               &TXT1=,             TEXT OF INFO                        X\n               &AD2=,              ADDRESS OF DATA                     X\n               &AT2=,              ATTRIBUTE OF DATA                   X\n               &TXT2=              TEXT OF DATA\n         GBLC  &BBB1,&BBBL\n         LCLC  &LB1,&LB2,&LB3,&LB4,&AA,&TXT\n         LCLA  &I\n         AIF   ('&TYPE' NE '').TRYEND\n&LB1     SETC  'ZLB1&SYSNDX'\n&LB2     SETC  'ZLB2&SYSNDX'\n&LB3     SETC  'ZLB3&SYSNDX'\n&LB4     SETC  'ZLB4&SYSNDX'\n&AA      SETC  'ZAA&SYSNDX'\n         AIF   ('&BBB1' NE '').OK1\n&BBBL    SETC  'ZBB100'\n&BBB1    SETC  'ZBB100'\n.OK1     ANOP\n  PUNCH '&NAME DC    AL2(&LB1-ZPANEL)    HIGHLIGHT ATTR               '\n  PUNCH ' DC    AL2(&LB2-ZPANEL)    HIGHLIGHT CHAR                    '\n  PUNCH ' DC    AL2(&LB3-ZPANEL)    PROT ATTR                         '\n         GRC   &AD2,INCR\n  PUNCH ' DC    AL2(L''&LB4)        LENGTH OF INPUT FIELD             '\n  PUNCH ' DC    AL2(&LB4-ZPANEL)    INPUT FIELD                       '\n  PUNCH ' DC    AL2(0,0)            RESERVED                          '\n  PUNCH ' AGO   .&AA                                                  '\n  PUNCH '.&BBBL ANOP                                                  '\n&BBBL    SETC  'ZBB1&SYSNDX'\n  PUNCH ' DC    X''11''                                               '\n         GRC   &AD1\n  PUNCH ' DC    X''1D''                                               '\n  PUNCH ' DC    X''E8''                                               '\n  PUNCH '&LB2 DC  X''00'''\n  PUNCH ' DC    X''11''                                               '\n         GRC   &AD2\n  PUNCH ' DC    X''1D''                                               '\n  PUNCH '&LB3 DC    X''&AT1''                                         '\n&I       SETA  K'&TXT1\n&TXT     SETC  '&TXT1'(2,&I-2)\n  PUNCH '&LB4 DC    &TXT'\n  PUNCH ' DC    X''1D''                                               '\n  PUNCH '&LB1 DC    X''&AT2''                                         '\n&I       SETA  K'&TXT2\n&TXT     SETC  '&TXT2'(2,&I-2)\n  PUNCH ' DC    &TXT'\n  PUNCH ' DC    X''1D60''                                             '\n  PUNCH ' AGO   .&BBBL                                                '\n  PUNCH '.&AA     ANOP                                                '\n         MEXIT\n.TRYEND  AIF   ('&TYPE' NE 'END').ER1\n  PUNCH ' DC    XL16''FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF''              '\n  PUNCH 'ZLC1 DC    X''27F5''           EXC, ERASE WRITE              '\n  PUNCH 'ZLC2 DC    X''C3''             WCC                           '\n  PUNCH ' DC    X''114040''         SET BUFFER TOP LEFT OF SCREEN     '\n  PUNCH ' DC    X''3C404040''       REPEAT BLANK TO TOP OF SCREEN     '\n         MEXIT\n.ER1     MNOTE 8,'FIELD TYPE IS NOT END OR NULL'\n         MEND\n         MACRO\n         GRC   &RC,&INCR\n         LCLC  &C,&C1,&C2,&ROW,&COL\n         LCLA  &POS,&P1,&P2\n.*       COMPUTE 3270 ADDRESSES FROM ROW/COLUMN\n&ROW     SETC  '&SYSLIST(1,1)'\n&COL     SETC  '&SYSLIST(1,2)'\n&POS     SETA  80*(&ROW-1)+(&COL-1)\n         AIF   ('&INCR' EQ '').OK23\n&POS     SETA  &POS+1\n.OK23    ANOP\n&P1      SETA  &POS/64             GET FIRST CHAR POS\n&P2      SETA  &POS-(&P1*64)       GET SECOND CHAR POS\n&C SETC '40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F50D1D2D3D4D5D6D7D8D95A5B5C5D5EX\n               5F6061E2E3E4E5E6E7E8E96A6B6C6D6E6FF0F1F2F3F4F5F6F7F8F97AX\n               7B7C7D7E7F'\n&C1      SETC  '&C'(&P1*2+1,2)\n&C2      SETC  '&C'(&P2*2+1,2)\n  PUNCH ' DC    X''&C1&C2''         GENERATE ADDRESS CHARACTERS       '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ORGLPEN1": {"ttr": 4353, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91%O\\x00\\x91%O\\x16\\x12\\x00J\\x00J\\x00\\x00\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-09-11T00:00:00", "modifydate": "1991-09-11T16:12:00", "lines": 74, "newlines": 74, "modlines": 0, "user": "SALBERT"}, "text": "LGHDR1    EQU *                        Heading for Logon Panel\n          DC X'11'                     Set Buffer Address\n          DC X'4040'                   Address in Buffer\n          DC X'1D'                     Start Field            @PID0140\n          DC X'E8'                     Attr = Protected, Intensified\nHEADER    DC C'------------------------------- TSO/E LOGON ------------+\n               ------------------------' Header\n          EJECT\n          DC X'11'                     Set Buffer Address\n          DC X'C150'                   Address in Buffer\n          DC X'1D'                     Start Field            @PID0140\n          DC X'E8'                     Attr = Protected, Intensified\nMSG1      EQU *\n          DC CL80' '                   Line of blanks where 1st level\n*                                      MSG will appear.\n          EJECT\n          DC X'11'                     Set Buffer Address\n          DC X'C260'                   Address in Buffer\n          DC X'1D'                     Start Field            @PID0140\n          DC X'E8'                     Attr = Protected, Intensified\nMSG2      EQU *\n          DC CL80' '                   Line of blanks where 2nd level\n*                                      MSG will appear.\n          EJECT\nPFLINE    EQU *\n          DC X'11'                     Set Buffer Address\n          DC X'5B60'                   Address in Buffer\n          DC X'1D'                     Start Field            @PID1040\n          DC X'E8'                     Attr = Protected, Intensified\n          DC C'PF1/PF13 ==> Help    PF3/PF15 ==> Logoff    PA1 ==> Atte+\n               ntion    PA2 ==> Reshow' Header\nHELPLINE  EQU *\n          DC X'11'                     Set Buffer Address\n          DC X'5CF0'                   Address in Buffer\n          DC X'1D'                     Start Field            @PID1040\n          DC X'E8'                     Attr = Protected, Intensified\n          DC C'You may request specific help information by entering a +\n               ''?'' in any entry field' header\n          EJECT\n***********************************************************************\n*                                                                     *\n* LOGON's Prompt for information                                      *\n*                                                                     *\n***********************************************************************\nPROMPT1   EQU *\n          DC X'11'                     Set Buffer Address\n          DC X'C3F3'                   Address in Buffer\n          DC X'1D'                     Start Field            @PID1040\n          DC X'E8'                     Attr = Protected, Intensified\n          DC CL29'Enter LOGON parameters below:' Text for prompt\n          EJECT\n***********************************************************************\n*                                                                     *\n* TPUT orders for SAF prompting area header on LOGON panel            *\n*                                                                     *\n***********************************************************************\nPRMPTSAF  EQU *                        SAF parameter Prompt\n          DC X'11'                     Set Buffer Address\n          DC X'C4E3'                   Address in Buffer\n          DC X'1D'                     Start Field            @PID1040\n          DC X'E8'                     Attr = Protected, Intensified\nRACF_TITLE DC CL22'RACF LOGON parameters:' Text for prompt\n***********************************************************************\n*                                                                     *\n* TPUT orders for Options Title on LOGON panel                        *\n*                                                                     *\n***********************************************************************\nOPTTITLE  EQU *                        Option Title Line\n          DC X'11'                     Set Buffer Address\n          DC X'D7F3'                   Address in Buffer\n          DC X'1D'                     Start Field            @PID1040\n          DC X'E8'                     Attr = Protected, Intensified\n          DC CL46'Enter an ''S'' before each option desired below:'\n          DC X'1D60'                   End Options Title field\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT265/FILE265.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT265", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}