{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012245000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 823004, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE520.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 823004, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 823004, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE520.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0e\\x06'", "DS1TRBAL": "b'v4'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\xde\\x00\\x0c\\x03\\xdf\\x00\\x0b\\x00\\x0f'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x04T\\x00\\x07\\x01\\x12\\x10\\x0f\\x01\\x12\\x10\\x0f\\x11'\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf4@@@\"", "ispf": {"version": "04.84", "flags": 0, "createdate": "2012-04-09T00:00:00", "modifydate": "2012-04-09T11:27:07", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-484"}, "text": "REGULAR CBT TAPE - VERSION 484    FILE:  520\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT484.FILE520\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 19 MEMBERS COUNTED; CUMULATIVE SIZE IS 7,413 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/09/12    11:27:07    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x13\\x01\\x12\\x10\\x0f\\x01\\x12\\x10\\x0f\\x00)\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-04-09T00:00:00", "modifydate": "2012-04-09T00:29:13", "lines": 27, "newlines": 27, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  CBT File 520\nFrom:     \"Wilfried Eike\" <Wilfried.Eike@t-online.de>\nDate:     Thu, 05 Apr 2012 07:09:43 +0200\nTo:       <sbgolob@cbttape.org>\n\nHello Mr. Golob,\n\nHere I am sending a modification I did to a Program found on CBT\nFile 520 (VARLIST).  I named it VARLISTS.  The only difference\nis:  Output is no longer placed on screen, it is placed on the\nREXX-Stack so it could be used within a REXX-Script.\n\n--\nMit freundlichen Gruessen\nWilfried Eike\nDiplom-Informatiker\nGeschaeftsfuehrer\n\n\nInformatik Buero Eike GmbH\nZuckerkuchenweg 5 b\n30890 Barsinghausen\nAmtsgericht Hameln HRB 2954\nGeschaeftsfuehrer: Wilfried Eike\nTel: 05105/64607  Fax: 05105/64608\nE-Mail: kontakt@ibe-gmbh.net\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PDSLOAD": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x01\\x15\\x7f\\x01\\x01\\x15\\x7f\\x158\\x00%\\x00\\x1b\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-06-06T00:00:00", "modifydate": "2001-06-06T15:38:00", "lines": 37, "newlines": 27, "modlines": 0, "user": "WSBG"}, "text": "//WSBGPDSL  JOB (ACCT#),S-GOLOB,\n// NOTIFY=&SYSUID,\n// CLASS=S,MSGCLASS=X\n//*\n//*   PDSLOAD COMES FROM FILE 093 OF THE CBT TAPE COLLECTION\n//*\n//*   YOU CAN USE IEBUPDTE INSTEAD OF PDSLOAD, BUT YOU LOSE THE\n//*   EMBEDDED ISPF STATISTICS.\n//*\n//*   THE PDSLOAD LOAD MODULE IS INCLUDED IN XMIT FORMAT.\n//*   TO GET THE LOAD LIBRARY CONTAINING IT, ISSUE (UNDER TSO):\n//*\n//*   TSO RECEIVE INDS(USERID.FILE520.PDS(PDSLOAD))\n//*\n//SCCPDSD  EXEC  PGM=PDSLOAD,PARM='UPDTE(><)',COND=EVEN\n//STEPLIB  DD  DISP=SHR,DSN=WSBG.LOAD\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=WSBG.FILE520.PDS(SCCPDSD),DISP=SHR\n//SYSUT2   DD  DSN=WSBG.SCCPDSD.PDS,DISP=(NEW,CATLG,DELETE),\n//         UNIT=SYSDA,VOL=SER=WORK03,SPACE=(TRK,(15,15,44),RLSE),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=8880)\n//*\n//SCCPDSR  EXEC  PGM=PDSLOAD,PARM='UPDTE(><)',COND=EVEN\n//STEPLIB  DD  DISP=SHR,DSN=WSBG.LOAD\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=WSBG.FILE520.PDS(SCCPDSR),DISP=SHR\n//SYSUT2   DD  DSN=WSBG.SCCPDSR.PDS,DISP=(NEW,CATLG,DELETE),\n//         UNIT=SYSDA,VOL=SER=WORK03,SPACE=(TRK,(15,15,44),RLSE),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=8880)\n//*\n//WILDCARD EXEC  PGM=PDSLOAD,PARM='UPDTE(><)',COND=EVEN\n//STEPLIB  DD  DISP=SHR,DSN=WSBG.LOAD\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=WSBG.FILE520.PDS(WILDCARD),DISP=SHR\n//SYSUT2   DD  DSN=WSBG.WILDCARD.PDS,DISP=(NEW,CATLG,DELETE),\n//         UNIT=SYSDA,VOL=SER=WORK03,SPACE=(TRK,(15,15,44),RLSE),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=8880)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SCCPDSD": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x01\\x15\\x7f\\x01\\x01\\x15\\x7f\\x149\\x00.\\x00.\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-06-06T00:00:00", "modifydate": "2001-06-06T14:39:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "PST0705"}, "text": "Installation / readme for SCCPDSD\n\nThere are 5 component for this package\n\nID       Is an Assembler macro required to assemble each of the\n         assembler routines. Put it into a library included in your\n         SYSLIB concatenation for the assemblies.\n\nSTSS383  Is an assembler subroutine required for SCCPDSD. Assemble it\n         into an object or call library so that it can be link edited\n         into SCCPDSD.  Note that this subroutine could be CALLed by any\n         program wishing to get an in-core table of the directory\n         entries from a PDS.\n\nSCCWC001 Is an assembler subroutine required for SCCPDSD. Assemble it\n         into an object or call library so that it can be link edited\n         into SCCPDSD.  Note that this subroutine could be CALLed by any\n         program wishing to get an answer to 'does this generic entry\n         match this static entry?'\n\nSCCPDSD  Is an assembler routine which runs as a Rexx function to\n         populate a stem variable (or 'stack') with the directory\n         entries\n\nHELP     Is the documentation on how to access directory entries in Rexx\n\nMaking SCCPDSD available to your rexx program can be as simple as\nlink editing it to a load library that is within the JOBLIB/STEPLIB\nconcatenation when the rexx program runs. Myself, I have built a Rexx\nfunction package under the name IRXFLOC which contains all the\nassembler written rexx functions for the platform.\n\nBelow is a Rexx prototype to read all the records of every member from\nDDname SYSUT1 where the member name begins with SCC. Note that\nDDname SYSUT1 would be pre-allocated. SCCPDSR is another function\npackaged separately.\n\n\nCall SCCPDSD 'SYSUT1',   'SCC*',  'D.'\ndo d# = 1 to d.0\n     call SCCPDSR 'SYSUT1',  left(d.d#,12),  'R.'\n     do r# = 1 to r.0\n          parse var r.r# word1 etc .\n     end\n     drop R.\nend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$SCCPDSR": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x15\\x7f\\x01\\x01\\x15\\x7f\\x14U\\x00&\\x00&\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-06T00:00:00", "modifydate": "2001-06-06T14:55:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "PST0705"}, "text": "Installation / readme for SCCPDSR\n\nThere are 4 component for this package\n\nID.MAC  Is an Assembler macro required to assemble each of the assembler\n        routines. Put it into a library included in your SYSLIB\n        concatenation for the assemblies.\n\nSTSS384.ASM  Is an assembler subroutine required for SCCPDSR. Assemble\n        it into an object or call library so that it can be link edited\n        into SCCPDSR.  Note that this subroutine could be CALLed by any\n        program wishing to read the records of a member in a PDS.\n\nSCCPDSR.ASM  Is an assembler routine which runs as a Rexx function to\n        populate a stem variable (or 'stack') with the member records\n\nSCCPDSR.HLP  Is the documentation on how to access member records in\n        Rexx\n\nMaking SCCPDSR available to your rexx program can be as simple as link\nediting it to a load library that is within the JOBLIB/STEPLIB\nconcatenation when the rexx program runs. Myself, I have built a Rexx\nfunction package under the name IRXFLOC which contains all the assembler\nwritten rexx functions for the platform.\n\nBelow is a Rexx prototype to read all the records of every member from\nDDname SYSUT1 where the member name begins with SCC. Note that DDname\nSYSUT1 would be pre-allocated. SCCPDSD is another function packaged\nseparately.\n\nCall SCCPDSD 'SYSUT1',   'SCC*',  'D.'\ndo d# = 1 to d.0\n     call SCCPDSR 'SYSUT1',  left(d.d#,12),  'R.'\n     do r# = 1 to r.0\n          parse var r.r# word1 etc .\n     end\n     drop R.\nend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$WILDCAR": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x15\\x7f\\x01\\x01\\x15\\x7f\\x15\\x11\\x00\\x1a\\x00\\x1a\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-06T00:00:00", "modifydate": "2001-06-06T15:11:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "PST0705"}, "text": "Installation / readme for WILDCARD\n\nThere are 4 component for this package\n\nID.MAC  Is an Assembler macro required to assemble each of the assembler\n        routines. Put it into a library included in your SYSLIB\n        concatenation for the assemblies.\n\nSCCWC001.ASM  Is an assembler subroutine required for WILDCARD. Assemble\n        it into an object or call library so that it can be link edited\n        into WILDCARD.  Note that this subroutine could be CALLed by any\n        program wishing to get an answer to 'does this generic entry\n        match this static entry?'\n\nWILDCARD.ASM  Is an assembler routine which runs as a Rexx function to\n        set a logical value answering the question  'does this generic\n        entry match this static entry?'\n\nWILDCARD.HLP  Is the documentation on how a REXX program can use the\n        function\n\nMaking WILDCARD available to your rexx program can be as simple as link\nediting it to a load library that is within the JOBLIB/STEPLIB\nconcatenation when the rexx program runs. Myself, I have built a Rexx\nfunction package under the name IRXFLOC which contains all the assembler\nwritten rexx functions for the platform.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE520": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x04T\\x00\\x02\\x01\\x12\\x10\\x0f\\x01\\x12\\x10\\x0f\\x11'\\x00\\x9b\\x00\\x9b\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf4@@@\"", "ispf": {"version": "04.84", "flags": 0, "createdate": "2012-04-09T00:00:00", "modifydate": "2012-04-09T11:27:02", "lines": 155, "newlines": 155, "modlines": 0, "user": "CBT-484"}, "text": "//***FILE 520 is from Robin Ryerse and contains some REXX           *   FILE 520\n//*           functions, written in Assembler.                      *   FILE 520\n//*                                                                 *   FILE 520\n//*           Their names are:  SCCPDSD, SCCPDSR, and WILDCARD.     *   FILE 520\n//*           And a new one is called:   VARLIST                    *   FILE 520\n//*                                                                 *   FILE 520\n//*     Note: A modification of VARLIST, called VARLISTS, was       *   FILE 520\n//*           submitted by Wilfried Eike, which returns the output  *   FILE 520\n//*           on the REXX stack so it could be used within a REXX   *   FILE 520\n//*           script.                                               *   FILE 520\n//*                                                                 *   FILE 520\n//*           email:  Wilfried.Eike@t-online.de                     *   FILE 520\n//*                                                                 *   FILE 520\n//*           Another function has been added to this package,      *   FILE 520\n//*           called SCXSORT.  Notes for SCXSORT are found below.   *   FILE 520\n//*                                                                 *   FILE 520\n//*           Another new function:  SCC@DSN - to determine if      *   FILE 520\n//*           a dataset exists.                                     *   FILE 520\n//*                                                                 *   FILE 520\n//*           A new function package has also been added, called    *   FILE 520\n//*           SCCALLOC.  SCCALLOC provides, in native REXX, the     *   FILE 520\n//*           functionality of the TSO ALLOCATE and FREE commands,  *   FILE 520\n//*           which will now be available to \"Address TSO\".         *   FILE 520\n//*                                                                 *   FILE 520\n//*           An additional package, called DSN4DD, tells you,      *   FILE 520\n//*           for a dataset in a concatenation, which number of     *   FILE 520\n//*           the concatenation that dataset is.                    *   FILE 520\n//*                                                                 *   FILE 520\n//*           The purpose of these REXX functions is to select      *   FILE 520\n//*           certain members of a partitioned dataset, according   *   FILE 520\n//*           to some rule, and to allow you to perform, in REXX,   *   FILE 520\n//*           some operation on all the members that were           *   FILE 520\n//*           selected.                                             *   FILE 520\n//*                                                                 *   FILE 520\n//*           email:   Robin.Ryerse@stelco.ca                       *   FILE 520\n//*                                                                 *   FILE 520\n//*           Each package has a $README member with a $ preceding  *   FILE 520\n//*           its name.  Each package is actually an unloaded pds   *   FILE 520\n//*           in IEBUPDTE SYSIN format (really in PDSLOAD format).  *   FILE 520\n//*           The $PDSLOAD member is a job to create a pds out of   *   FILE 520\n//*           each member that is really a package.                 *   FILE 520\n//*                                                                 *   FILE 520\n//*           The member of this file which is called PDSLOAD,      *   FILE 520\n//*           is an XMIT-format load library, containing the        *   FILE 520\n//*           PDSLOAD load module.  To create the load library,     *   FILE 520\n//*           issue the command (under TSO):                        *   FILE 520\n//*                                                                 *   FILE 520\n//*           RECEIVE INDS(userid.FILE520.PDS(PDSLOAD)),            *   FILE 520\n//*                                                                 *   FILE 520\n//*           and press ENTER at the prompts.                       *   FILE 520\n//*                                                                 *   FILE 520\n//*        -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -        *   FILE 520\n//*                                                                 *   FILE 520\n//*    Special notes for the SCXSORT package:                       *   FILE 520\n//*                                                                 *   FILE 520\n//*       Name:        SCXSORT                                      *   FILE 520\n//*                                                                 *   FILE 520\n//*       Purpose:     Sort from and/or into REXX stem              *   FILE 520\n//*                    variables.                                   *   FILE 520\n//*                                                                 *   FILE 520\n//*       Environment: REXX subroutine/function for all MVS/ESA     *   FILE 520\n//*                    environments.  SCXSORT resides in the        *   FILE 520\n//*                    IRXFLOC \"function package\".                  *   FILE 520\n//*                                                                 *   FILE 520\n//*       Features:    All the capabilities of the system sort      *   FILE 520\n//*                    program are available.                       *   FILE 520\n//*                                                                 *   FILE 520\n//*        -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -        *   FILE 520\n//*                                                                 *   FILE 520\n//*      Installation / readme for SCXSORT                          *   FILE 520\n//*                                                                 *   FILE 520\n//*      There are 3 components for this package                    *   FILE 520\n//*                                                                 *   FILE 520\n//*      MACRO    Is the Assembler macro named ID requitred to      *   FILE 520\n//*               assemble the assembler routine. Put it into a     *   FILE 520\n//*               library included in your SYSLIB concatenation     *   FILE 520\n//*               for the assembly.                                 *   FILE 520\n//*                                                                 *   FILE 520\n//*      SOURCE   Is the single Assembler source deck of the        *   FILE 520\n//*               function.                                         *   FILE 520\n//*                                                                 *   FILE 520\n//*      HELP     Is the documentation on how to use SCXSORT in     *   FILE 520\n//*               REXX programs.                                    *   FILE 520\n//*                                                                 *   FILE 520\n//*      Making SCXSORT available to your REXX program can be as    *   FILE 520\n//*      simple as link editing it to a load library that is        *   FILE 520\n//*      within the JOBLIB/STEPLIB concatenation when the REXX      *   FILE 520\n//*      program runs.  I myself have built a REXX function         *   FILE 520\n//*      package under the name IRXFLOC which contains all the      *   FILE 520\n//*      assembler written REXX functions for the platform.         *   FILE 520\n//*                                                                 *   FILE 520\n//*      The HELP documentation should provide all the usage        *   FILE 520\n//*      notes required.                                            *   FILE 520\n//*                                                                 *   FILE 520\n//*        -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -        *   FILE 520\n//*                                                                 *   FILE 520\n//*    Special notes for the DSN4DD package:                        *   FILE 520\n//*                                                                 *   FILE 520\n//*    Name:        DSN4DD                                          *   FILE 520\n//*                                                                 *   FILE 520\n//*    Purpose:     Return the name of (a concatenation level       *   FILE 520\n//*                 of) a dataset for a specified DDname.           *   FILE 520\n//*                                                                 *   FILE 520\n//*    Environment: REXX subroutine/function for all MVS/ESA        *   FILE 520\n//*                 environments.  DSN4DD resides in the            *   FILE 520\n//*                 IRXFLOC \"function package\".                     *   FILE 520\n//*                                                                 *   FILE 520\n//*    Features:    The value of the DSN is returned as per         *   FILE 520\n//*                 the invocation construct.                       *   FILE 520\n//*                                                                 *   FILE 520\n//*                 The REXX variable RC is set to the number       *   FILE 520\n//*                 of concatenation levels for the DD.             *   FILE 520\n//*                                                                 *   FILE 520\n//*    Argument:    The DDname for which the dataset name is        *   FILE 520\n//*                 required.                                       *   FILE 520\n//*                                                                 *   FILE 520\n//*                 The DDname can be further qualified with        *   FILE 520\n//*                 a suffix in format  +n  where \"n\" is a          *   FILE 520\n//*                 number relative to 1 of the concatenation       *   FILE 520\n//*                 within the DDname.                              *   FILE 520\n//*                                                                 *   FILE 520\n//*    Results:     DSN4DD operates as a REXX subroutine/function.  *   FILE 520\n//*                 When used as a subroutine, the caller           *   FILE 520\n//*                 retrieves the value from the REXX variable      *   FILE 520\n//*                 RESULT. When used as a function, REXX makes     *   FILE 520\n//*                 the requested assignment from the context of    *   FILE 520\n//*                 REXX statement which invoked it.                *   FILE 520\n//*                                                                 *   FILE 520\n//*                 DSN4DD always sets the REXX variable RC.        *   FILE 520\n//*                 For a request which is matched without          *   FILE 520\n//*                 error, RC is asigned the number of              *   FILE 520\n//*                 datasets which are concatenated together.       *   FILE 520\n//*                 If there is no concatenation, RC will be        *   FILE 520\n//*                 assigned the value one.                         *   FILE 520\n//*                                                                 *   FILE 520\n//*    Errors/Warnings:                                             *   FILE 520\n//*                 If the DDNAME is not allocated or the           *   FILE 520\n//*                 argument is missing, RC will be assigned        *   FILE 520\n//*                 the value of minus one and the result will      *   FILE 520\n//*                 be null.                                        *   FILE 520\n//*                                                                 *   FILE 520\n//*                 If the DDNAME is allocated but the requested    *   FILE 520\n//*                 concatenation level is invalid or beyond the    *   FILE 520\n//*                 allocated concatenation level, the 'result'     *   FILE 520\n//*                 will be null and RC is assigned the number      *   FILE 520\n//*                 of datasets allocated within the                *   FILE 520\n//*                 concatenation level.                            *   FILE 520\n//*                                                                 *   FILE 520\n//*    Notes:       If the DDname is allocated to a member of       *   FILE 520\n//*                 a partitioned dataset, the member name is       *   FILE 520\n//*                 included in the result. This makes DSN4DD       *   FILE 520\n//*                 distinct from the TSO LISTF command.            *   FILE 520\n//*                                                                 *   FILE 520\n//*        -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -        *   FILE 520\n//*                                                                 *   FILE 520\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSN4DD": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x07\\x04\\x0f\\x01\\x07\\x04\\x0f\\x08G\\x02\\x88\\x02\\x88\\x00\\x00\\xd7\\xc4\\xe2\\xd3\\xd6\\xc1\\xc4@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2007-02-09T00:00:00", "modifydate": "2007-02-09T08:47:00", "lines": 648, "newlines": 648, "modlines": 0, "user": "PDSLOAD"}, "text": "./ ADD NAME=$README$ 0102-01157-01270-1116-00025-00046-00000-PST0705\nInstallation / readme for DSN4DD / VOL4DD / JFCB4DD\n\nThere are 4 component for this package\n\nMACRO    Is the Assembler macro named ID required to assemble the\n         assembler routine. Put it into a library included in your\n         SYSLIB concatenation for the assembly.\n\nSOURCE   Is the single Assembler source deck of the function.\n\nLINKEDT  Is the linkage editor control statements to build the\n         load module and its aliases\n\nHELP     Is a two part document. Part 1 describes how to use DSN4DD.\n         Part 2 describes how to use VOL4DD.\n\nMaking DSN4DD available to your rexx program can be as simple as\nlink editing it to a load library that is within the JOBLIB/STEPLIB\nconcatenation when the rexx program runs. Myself, I have built a Rexx\nfunction package under the name IRXFLOC which contains all the\nassembler written rexx functions for the platform. VOL4DD had not been\ntested as a loadmodule alias but it does execute properly from the\nfunction package.\n\nThe HELP documentation should provide all the usage notes required.\n./ ADD NAME=HELP     0106-96073-01270-1108-00143-00063-00000-PST0705\n Name:        DSN4DD\n\n Purpose:     Return the name of (a concatenation level of) a dataset\n              for a specified DDname.\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              DSN4DD resides in the IRXFLOC \"function package\".\n\n Features:    The value of the DSN is returned as per the invocation\n              contruct.\n\n              The REXX variable RC is set to the number of concatenation\n              levels for the DD.\n\n Argument:    The DDname for which the dataset name is required.\n\n              The DDname can be further qualified with a suffix in\n              format  +n  where \"n\" is a number relative to 1 of\n              the concatenation within the DDname.\n\n\n Results:     DSN4DD operates as a REXX subroutine/function. When used\n              as a subroutine, the caller retrieves the value from the\n              REXX variable RESULT. When used as a function, REXX makes\n              the requested assignment from the context of REXX\n              statement which invoked it.\n\n              DSN4DD always sets the REXX variable RC. For a request\n              which is matched without error, RC is asigned the number\n              of datasets which are concatenated together. If there is\n              no concatenation, RC will be assigned the value one.\n\n Errors/Warnings:\n              If the DDNAME is not allocated or the argument is missing,\n              RC will be assigned the value of minus one and the result\n              will be null.\n\n              If the DDNAME is allocated but the requested concatenation\n              level is invalid or beyond the allocated concatenation\n              level, the 'result' will be null and RC is assigned the\n              number of datasets allocated within the concatenation\n              level.\n\n Examples: 1. say dsn4dd('SYSPROC+1')  ==> TCS0TSO.SYSTEM.FUNCLIB\n\n           2. Identify the members (and the library) which have\n              multiple versions in the set of a concatenated DD.\n                 dd = 'SYSUT1'\n                 dsn.0 = dsn4dd(dd)\n                 concat_count = rc\n                 do i = 1 to concat_count-1; dsn.i = dsn4dd(dd'+'i); end\n                 call sccpdsd dd, '*', 'D.' /* build member list */\n                 do i = 1 to d.0-1\n                      ii = i + 1\n                      if left(d.i,8) == left(d.ii,8) then\n                        do\n                           parse value spfdir(d.i) with mem concat .\n                           ? = mem 'exists in' dsn.concat\n                           do while left(d.i,8) == left(d.ii,8)\n                                concat = c2d(substr(d.ii,12,1))\n                                ? = ? dsn.concat\n                                i = ii\n                                ii = ii + 1\n                           end\n                           say ?\n                        end\n                 end\n\n Notes:       If the DDname is allocated to a member of a partitioned\n              dataset, the member name is included in the result. This\n              makes DSN4DD distinct from the TSO LISTF command.\n\n\n\n\n\n\n\n\n\n\n\n Name:        VOL4DD\n\n Purpose:     Return the volume serial number(s) of (a concatenation\n              level of) a dataset for a specified DDname.\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              VOL4DD resides in the IRXFLOC \"function package\".\n\n Features:    The value of the volume serial number is returned as\n              per the invocation construct.\n\n              The REXX variable RC is set to the number of\n              concatenation levels for the DD.\n\n Argument:    The DDname for which the dataset name is required.\n\n              The DDname can be further qualified with a suffix in\n              format  +n  where \"n\" is a number relative to 1 of\n              the concatenation within the DDname.\n\n\n Results:     VOL4DD operates as a REXX subroutine/function. When\n              used as a subroutine, the caller retrieves the value\n              from the REXX variable RESULT. When used as a\n              function, REXX makes the requested assignment from the\n              context of REXX statement which invoked it.\n\n              If the specified DDname is allocated to multiple volumes,\n              VOL4DD returns a character string listing the volume\n              serial numbers separated by commas. If the DDname is\n              allocated to more than 5 volumes, only the first five\n              are listed by VOL4DD.\n\n              VOL4DD always sets the REXX variable RC. For a request\n              which is matched without error, RC is asigned the number\n              of datasets which are concatenated together. If there is\n              no concatenation, RC will be assigned the value one.\n\n Errors/Warnings:\n              If the DDNAME is not allocated or the argument is missing,\n              RC will be assigned the value of minus one and the result\n              will be null.\n\n              If the DDNAME is allocated but the requested concatenation\n              level is invalid or beyond the allocated concatenation\n              level, the 'result' will be null and RC is assigned the\n              number of datasets allocated within the concatenation\n              level.\n\n Examples: 1. say VOL4dd('SYSPROC+1')  ==> ST3S03\n\n\n\n\n\n\n\n\n\n\n\n./ ADD NAME=LINKEDT  0100-01270-01270-1123-00005-00005-00000-PST0705\n INCLUDE _______(DSN4DD)\n ENTRY DSN4DD\n ALIAS VOL4DD\n ALIAS JFCB4DD\n NAME DSN4DD(R)\n./ ADD NAME=MACRO    0102-98050-98050-1606-00049-00046-00000-PST0705\n         MACRO\n&LABEL   ID    &USING,&CSECT=YES,&AMODE=31,&RMODE=ANY\n         LCLC  &U,&LBL\n.*\n.* Stelco macro used to:\n.*    - generate the CSECT statement.\n.*    - generate the USING, AMODE and RMODE statements for the CSECT.\n.*    - generate an eye-catcher and date/time stamp (28 bytes total).\n.*      (The values for date and time are the time of the Assembly.)\n.*\n.* The default for the USING statement is (register) 15.\n.* Other defaults are as per the prototype above.\n.*\n.* If the CSECT requires multiple base registers, their specification\n.* must be enclosed in parenthesis.       e.g.  BIGRTN   ID     (12,11)\n.*\n.* This macro can also be used to generate only the eye-catcher and\n.* date/time stamp. For this type of usage specify   ID    ,CSECT=NO\n.*\n.* -----------------------Modification History-------------------------\n.* 98-02-19 change from &SYSDATE to &SYSDATC\n.*\n&U       SETC  '15'\n&LBL     SETC  ' '\n         AIF   (K'&LABEL EQ 0).LBLSET\n&LBL     SETC  '&LABEL'\n.LBLSET  ANOP\n         AIF   (T'&USING EQ 'O').USET\n         AIF   ('&USING'(1,1) NE '(').ONEUSE\n&U       SETC  '&USING'(2,K'&USING-2)\n         AGO   .USET\n.ONEUSE  ANOP\n&U       SETC  '&USING'\n.USET    ANOP\n         AIF   ('&CSECT' EQ 'YES').CSECT\n&LBL     DS    0H\n         B     *+32\n         AGO   .STAMP\n.CSECT   ANOP\n&LBL     CSECT\n&LBL     AMODE &AMODE\n&LBL     RMODE &RMODE\n         USING &LABEL,&U\n         BC    15,32(,15)\n.STAMP   ANOP\n         DS    CL4\n         DC    CL8'&LBL'\n         DC    CL16'&SYSDATC &SYSTIME'\n         MEND\n./ ADD NAME=SOURCE   0100-07040-07040-0844-00421-00421-00000-PST0705\nDSN4DD   TITLE            '<< REXX - Obtain JFCB information for a DD  X\n                                                      Documentation >>'\n* Name:        DSN4DD   VOL4DD   JFCB4DD\n*\n* Purpose:     See %QWT R=______   for the related user documentation.\n*\n* This program scans the TIOT for the specified DDname and from\n* there obtains the JFCB for the requested data.\n*\n* The number of concatenation levels for the specified DDname is\n* returned in the REXX variable RC.\n* (RC is set to -1 if the DDname is not allocated.)\n*\n* The entry point determines the field to be extracted from the JFCB.\n*\n* Modification history:\n*    May 2004 - Use SWA manager to determine the JFCB address.\n*\n         TITLE            '<< REXX - Obtain JFCB information for a DD  X\n                              System Linkage for entry point DSN4DD >>'\n* Entry point DSN4DD extracts the dataset name (including the member\n* name) from the JFCB.\n*\n         PRINT   GEN\nDSN4DD   ID    R12\n         PRINT NOGEN\n         ENTRY VOL4DD\n         ENTRY JFCB4DD\n         USING EFPL,R1\n         USING ENVBLOCK,R8\n         USING EVALBLOCK,R11\n         SPACE 2\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         ST    R13,SAVEAREA+4\n         LA    R15,SAVEAREA\n         ST    R15,8(,R13)\n         LR    R13,R15\n         LR    R8,R0\n         LM    R10,R11,EFPLARG     Address ARGTABLE\n         L     R11,0(,R11)            & EVALBLOCK\n         XC    EVALBLOCK_EVLEN,EVALBLOCK_EVLEN   Default to zero length\n         B     MAINLINE\n         SPACE 2\nRTNXT    DS    0H\n         L     R13,SAVEAREA+4\n         XC    8(4,R13),8(R13)\n         XC    16(4,R13),16(R13)   R15 (return code) always\n         LM    R14,R12,12(R13)        get set to zero.\n         BR    R14\n         TITLE            '<< REXX - Obtain JFCB information for a DD  X\n                              System Linkage for entry point VOL4DD >>'\n         SPACE 3\n* VOL4DD extract up to 5 volume serial numbers from the JFCB\n*\n* If the DDname is allocated to multiple volumes, VOL4DD returns the\n* the list as a string using comma as the separator character.\n         SPACE 3\nVOL4DD   DS    0D\n         DROP  R12\n         USING VOL4DD,R15\n         STM   R14,R12,12(R13)\n         L     R12,VDSN4DD\n         DROP  R15\n         USING DSN4DD,R12\n         ST    R13,SAVEAREA+4\n         LA    R15,SAVEAREA\n         ST    R15,8(,R13)\n         LR    R13,R15\n         LR    R8,R0\n         LM    R10,R11,EFPLARG     Address ARGTABLE\n         L     R11,0(,R11)            & EVALBLOCK\n         XC    EVALBLOCK_EVLEN,EVALBLOCK_EVLEN   Default to zero length\n         MVI   EVALBLOCK_EVLEN+L'EVALBLOCK_EVLEN-1,X'06'\n         B     MAINLINE\n         TITLE            '<< REXX - Obtain JFCB information for a DD  X\n                             System Linkage for entry point JFCB4DD >>'\n         SPACE 3\n* JFCB4DD returns the address of the JFCB for the specified DDname.\n         SPACE 3\nJFCB4DD  DS    0D\n         DROP  R12\n         USING JFCB4DD,R15\n         STM   R14,R12,12(R13)\n         L     R12,VDSN4DD\n         DROP  R15\n         USING DSN4DD,R12\n         ST    R13,SAVEAREA+4\n         LA    R15,SAVEAREA\n         ST    R15,8(,R13)\n         LR    R13,R15\n         LR    R8,R0\n         LM    R10,R11,EFPLARG     Address ARGTABLE\n         L     R11,0(,R11)            & EVALBLOCK\n         XC    EVALBLOCK_EVLEN,EVALBLOCK_EVLEN   Default to zero length\n         MVI   EVALBLOCK_EVLEN+L'EVALBLOCK_EVLEN-1,X'04'\n         B     MAINLINE\n         SPACE 2\nVDSN4DD  DC    V(DSN4DD)\nSAVEAREA DS    18F\n         TITLE            '<< REXX - Obtain JFCB information for a DD  X\n                                                Parse the Arguments >>'\nMAINLINE DS    0H\n         USING IRXEXTE,R9\n         USING SHVBLOCK,R14\n         L     R9,ENVBLOCK_IRXEXTE Address the REXX vector table.\n         MVI   TRTABLE-1,X'FF'     Pre-set table value.\n         MVI   DDNAME,C' '\n         MVC   DDNAME+1(L'DDNAME-1),DDNAME\n         BAL   R14,STRIP           Strip out arg(1).\n         B     MISSING_DD          Arg(1) not specified.\n         LA    R0,11               Maximum length.\n         CR    R15,R0              Length(arg(1)) > maximum ?\n         BNH   *+6                    -no -\n         LR    R15,R0                 -yes-   Use maximum\n         EX    R15,MVC_DD          Pick-up the DDname.\n         SPACE 1\n         LA    R3,0                Presume 'concat' = 0.\n         MVI   TRTABLE-1,X'00'     Pre-set table value.\n         MVC   TRTABLE,TRTABLE-1\n         MVI   TRTABLE+X'4E',X'4E' Looking for a plus sign.\n         TRT   DDNAME(9),TRTABLE\n         BZ    QUALIFIED           Plus sign was not found.\n         MVI   TRTABLE-1,X'FF'     Pre-set table value.\n         MVC   TRTABLE,TRTABLE-1\n         MVI   TRTABLE+C'0',X'00'\n         MVC   TRTABLE+C'1'(9),TRTABLE+C'0'\n         LR    R4,R1               Remember the plus sign's address.\n         LA    R3,1(,R1)           Address of 1st numeric.\n         TRT   0(4,R3),TRTABLE     Find the delimiter (i.e. blank)\n         BZ    BAD_CONCAT          Too many digits.\n         SR    R1,R3               Calculate number of digits and\n         LA    R1,111(,R1)            hence the PACK instr len.\n         BZ    BAD_CONCAT          When the length was zero.\n         EX    R1,PACK1            Pick-up the qualifier\n         CVB   R3,DBLWD               into a register.\n         TITLE            '<< REXX - Obtain JFCB information for a DD  X\n                                                      Scan the TIOT >>'\nQUALIFIED0 DS  0H\n         MVI   0(R4),C' '          Clean-up\n         MVC   1(4,R4),0(R4)          the DDname.\nQUALIFIED  DS  0H\n         SR    R0,R0               Used later\n         LR    R5,R0                  for IC/ICM instructions.\n         USING PSA,R0\n         USING TCB,R1\n         L     R1,PSATOLD          Get TCB address.\n         L     R1,TCBTIO           Get TIOT address.\n         DROP  R1\n         USING TIOT1,R1\n         LA    R3,1(,R3)           Concat number relative to zero.\n         LA    R4,0                Concat counter starts at zero.\nFIND_DD  DS    0H\n         CLC   TIOEDDNM,DDNAME     Is this the requester's DDname?\n         BE    SAME_DD                -yes-\n         CLI   TIOELNGH,X'00'      End of TIOT's?\n         BE    WRONG_DD               -yes-\n         IC    R0,TIOELNGH         Get TIOT length and\n         AR    R1,R0                  point to next TIOT.\n         B     FIND_DD             Loop back.\nNEXT_CONCAT DS 0H\n         LA    R4,1(,R4)           Count another concat level.\n         IC    R0,TIOELNGH         Get TIOT length.\n         LTR   R0,R0               Is there any length?\n         BZ    COUNTED                -no -   Done counting.\n         AR    R1,R0               Point to next TIOT.\n         CLC   TIOEDDNM,=CL8'        '   Still same DDname?\n         BNE   COUNTED                      -no -   Done counting.\nSAME_DD  DS    0H\n         BCT   R3,NEXT_CONCAT      Caller's concat number exhausted?\n         ICM   R5,7,TIOEJFCB          -yes-   Get the JFCB TTR address.\n         LA    R10,REQEPA          SWA parm list\n         USING ZB505,R10              addressability\nCOUNT_CONCAT   DS    0H\n         IC    R0,TIOELNGH         Get TIOT length.\n         LTR   R0,R0               Is there any length?\n         LA    R4,1(,R4)           Count another concat level.\n         BZ    COUNTED                -no -   Done counting.\n         AR    R1,R0               Point to next TIOT.\n         CLC   TIOEDDNM,=CL8'        '   Still same DDname?\n         BE    COUNT_CONCAT                 -yes-   Keep counting.\nCOUNTED  DS    0H\n         LTR   R5,R5               Is there a JFCB address?\n         BNZ   GET_JFCB               -yes-\n         MVI   EVALBLOCK_EVLEN+L'EVALBLOCK_EVLEN-1,X'00'\n         B     DSN_DONE\n         TITLE            '<< REXX - Obtain JFCB information for a DD  X\n                                               Set the REXX result. >>'\nGET_JFCB DS    0H\n         STCM  R5,7,SWVA           Give EPA the JFCB token.\n         XC    SWQMPA,SWQMPA       Clear the QMPA address.\n         PRINT GEN\n        SWAREQ MF=(E,REQLIST),UNAUTH=YES    Call the SWA manager.\n         PRINT NOGEN\n         L     R5,SWPFXPTR         Get the resolved address for JFCB.\n         DROP  R10\n         LA    R5,16(,R5)\n         CLI   EVALBLOCK_EVLEN+L'EVALBLOCK_EVLEN-1,X'04'\n         BE    GIVE_JFCB\n         USING INFMJFCB,R5\n         CLI   EVALBLOCK_EVLEN+L'EVALBLOCK_EVLEN-1,X'06'\n         BE    GET_VOLSER\n         MVC   EVALBLOCK_EVDATA(44),JFCBDSNM   Get the DSN\n         LA    R1,EVALBLOCK_EVDATA+44   In case of full name.\n         XC    TRTABLE,TRTABLE     Clear the TRT table\n         MVI   TRTABLE+C' ',C' '   Blank is the only delimiter.\n         TRT   EVALBLOCK_EVDATA(44),TRTABLE   Find the blank.\n         TM    JFCBTSDM,JFCPAT     DSCB patterning done?\n         BO    NO_MEMBER             -yes-\n         CLI   JFCBELNM,C' '       Is there a member name?\n         BE    NO_MEMBER             -no -\n         MVI   0(R1),C' '          In case\n         MVC   1(10,R1),0(R1)         membername is 8 bytes long.\n         MVI   0(R1),C'('          Wrap\n         MVC   1(8,R1),JFCBELNM       the member name.\n         LA    R2,1(,R1)           Start-of-scan address.\n         TRT   0(9,R2),TRTABLE     Will always find a blank.\n         MVI   0(R1),C')'          Complete the wrap.\n         LA    R1,1(,R1)           Allow for right parenthesis.\nNO_MEMBER  DS  0H\n         LA    R2,EVALBLOCK_EVDATA Calculate\n         SR    R1,R2                  the total length and\n         ST    R1,EVALBLOCK_EVLEN        give it to REXX.\n         B     DSN_DONE\nGIVE_JFCB  DS  0H\n         ST    R5,EVALBLOCK_EVDATA  Give the address.\n         B     DSN_DONE\nGET_VOLSER  DS  0H\n         MVC   EVALBLOCK_EVDATA(6),JFCBVOLS  Pickup the first volser\n         LA    R0,5                5 volsers is the maximum.\n         SR    R1,R1               Pickup\n         IC    R1,JFCBNVOL            the volume count.\n         CR    R1,R0               More than the maximum?\n         BNH   *+6                    -no -\n         LR    R1,R0                  -yes- Use the maximum instead.\n         BCT   R1,*+8              Only one volser?  -no -\n         B     DSN_DONE                              -yes-\n         LA    R2,EVALBLOCK_EVDATA+6  Next volser goes here.\n         LA    R3,JFCBVOLS+6       Next volser comes from here.\n         B     VOL_LOOP+8\nVOL_LOOP DS    0H\n         LA    R2,7(,R2)           Next 'to' address.\n         LA    R3,6(,R3)           Next 'from' address.\n         SPACE 1\n         MVI   0(R2),C','          Comma is the separator of choice.\n         MVC   1(6,R2),0(R3)       Pickup next volser.\n         BCT   R1,VOL_LOOP         Count exhausted?  -no -\n         SPACE 1\n         LA    R0,EVALBLOCK_EVDATA-7\n         SR    R2,R0\n         ST    R2,EVALBLOCK_EVLEN\nDSN_DONE DS    0H\n         CVD   R4,DBLWD            Put concat count\n         OI    DBLWD+7,X'0F'          into\n         UNPK  UNPACKED,DBLWD+5(3)       EBCDIC format.\n         LA    R2,4                Maximum loop count.\n         LA    R3,*+4              Top-of-loop address.\n         CLI   UNPACKED,C'0'       Significant digit yet?\n         BNE   *+12                   -yes-\n         MVC   UNPACKED(L'UNPACKED-1),UNPACKED+1\n         BCTR  R2,R3               Keep looking (4 times.)\n         LA    R2,1(,R2)           Number of significant digits so\n         ST    R2,SHVVALL-SHVBLOCK+@SHV  tell EXCOM that.\n         TITLE            '<< REXX - Obtain JFCB information for a DD  X\n                                               Set REXX variable RC >>'\n*\n* Refer to the IRXEXCOM routine; pages 312-319 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\nSET_RC   DS    0H\n         LA    R0,ENVBLOCK         Make sure REXX knows environment.\n         L     R15,IRXEXCOM        Get IRXEXCOM's address from vector.\n         LA    R1,PLIST_EXCOM      Set the plist address.\n         BALR  R14,R15             Now call IRXEXCOM.\n         B     RTNXT               Go return to caller.\n         SPACE 1\nPLIST_EXCOM DC A(EXCOM_LIT,0,0)\n         DC    A(@SHV+X'80000000')\n         SPACE 1\n@SHV     DC    2A(0)\n         DC    C'S'\n         DS    XL3'000000'\n         DC    A(0,RC_LIT,L'RC_LIT,UNPACKED,0)\n         SPACE 1\nEXCOM_LIT DC   CL8'IRXEXCOM'\nRC_LIT   DC    C'RC'\n         SPACE 2\nBAD_CONCAT     DS    0H\n         LA    R3,256              A bogus concatenation counter\n         B     QUALIFIED0             but revert to normal logic flow.\n         SPACE 2\nMISSING_DD     DS    0H\nWRONG_DD       DS    0H            The requested DDNAME was not found.\n         XC    EVALBLOCK_EVLEN,EVALBLOCK_EVLEN   Default to zero length\n         MVC   UNPACKED(L'MINUS1),MINUS1\n         LA    R0,L'MINUS1\n         ST    R0,SHVVALL-SHVBLOCK+@SHV\n         B     SET_RC\n         TITLE            '<< REXX - Obtain JFCB information for a DD  X\n                     Subroutine to Strip Leading && Trailing Blanks >>'\n* Registers upon entry\n*    R10 ==> argument table entry\n*    R14 ==> exit address when agrument is null\n*    R14+4=> normal exit\n*\n* Registers upon exit\n*    R10 ==> next argument table entry.\n*    R2    = 0 (zero)\n*    R3  ==> leftmost non-blank byte of argument\n*    R4  ==> rightmost non-blank byte of argument\n*    R15   = R4 - R3 (length of argument minus 1)\n         SPACE 2\nHEXFF    DC    X'FFFFFFFFFFFFFFFF'\n         DS    XL1\nTRTABLE  DS    XL256\n         SPACE 1\nTRT3     TRT   0(0,R3),TRTABLE\n         SPACE 2\n         USING ARGTABLE_ENTRY,R10\nSTRIP    DS    0H\n         CLC   HEXFF,ARGTABLE_ARGSTRING_PTR  Is there an argument?\n         BER   R14                              -no -\n         L     R15,ARGTABLE_ARGSTRING_LENGTH\n         L     R3,ARGTABLE_ARGSTRING_PTR  Get address of argument.\n         LA    R10,ARGTABLE_NEXT   Point to next argument table entry.\n         SPACE 1\n         LTR   R15,R15             Does the argument have any length?\n         BZR   R14                    -NO - take abnormal exit.\n         LA    R4,0(R15,R3)        Point just beyond ARG.\n         MVC   TRTABLE,TRTABLE-1   Set to\n         MVI   TRTABLE+C' ',X'00'     bypass blanks.\n         BCTR  R15,0               Set length for TRT instruction.\n         EX    R15,TRT3            Skip to non-blank.\n         BZR   R14                 When all blank.\n         LR    R3,R1               Re-set starting address.\nSTRIP@R  DS    0H\n         BCTR  R4,0                Backpedal 1 byte.\n         CLI   0(R4),X'40'         (still) at a blanK?\n         BNE   STRIPPED               -no -\n         CR    R4,R3                  -yes-  More to inspect?\n         BH    STRIP@R                          -yes-\nSTRIPPED DS    0H\n         LR    R15,R4              Calculate\n         SR    R15,R3                 length of ARG - 1.\n         SR    R2,R2               Pre-clear R2 for TRT\n         XC    TRTABLE,TRTABLE     Clear translate table.\n         BC    15,4(,R14)          Take normal exit.\n         TITLE            '<< REXX - Obtain JFCB information for a DD  X\n                                                   Error Conditions >>'\n*\n* Refer to the IRXSAY   routine; pages 336-339 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\nSAY_LIT        DC    CL8'WRITE   '\nSAY_BUFF       DS    A\nSAY_LEN        DS    F\nSAY_PLIST      DC    A(SAY_LIT,SAY_BUFF,SAY_LEN+X'80000000')\nMISSING_MSG    DC    C'First argument (DDNAME) missing or invalid.'\n         LA    R15,MISSING_MSG\n         LA    R0,L'MISSING_MSG\n         B     SAY_CALL\nSAY_CALL DS    0H\n         ST    R15,SAY_BUFF\n         ST    R0,SAY_LEN\n         LA    R1,SAY_PLIST\n         LA    R0,ENVBLOCK\n         L     R15,IRXSAY\n         BALR  R14,R15\n         L     R13,SAVEAREA+4\n         XC    8(4,R13),8(R13)\n         LM    R14,R12,12(R13)\n         LA    R15,40\n         BR    R14\n*        ORG   SAY_LIT\n         TITLE            '<< REXX - Obtain JFCB information for a DD  X\n                                              Global Data Constants >>'\n         SPACE 2\nDBLWD    DS    D\n         SPACE 1\n         PRINT GEN\nREQLIST SWAREQ FCODE=LA,EPA=REQPTR,MF=L\nREQPTR   DC    A(REQEPA)\nREQEPA   DC    9F'0'\n         PRINT NOGEN\n         SPACE 1\nMVC_DD   MVC   DDNAME(0),0(R3)\nPACK1    PACK  DBLWD(0),1(0,R4)\nMINUS1   DC    CL2'-1'\nDDNAME   DS    CL13' '\nUNPACKED DS    CL5\n         SPACE 2\n         LTORG\n         TITLE            '<< REXX - Obtain JFCB information for a DD  X\n                                                 DSECTs and EQUates >>'\n         YREGS\n         SPACE 2\n       IRXENVB\n         SPACE 2\n       IRXEXTE\n         SPACE 2\n       IRXSHVB\n         SPACE 2\n       IRXEFPL\n         SPACE 2\n      IRXARGTB\n         SPACE 2\n      IRXEVALB\n         SPACE 2\n        IHAPSA\n         SPACE 2\n        IKJTCB\n         SPACE 2\n      IEFTIOT1\n         SPACE 2\n      IEFJFCBN\n         SPACE 2\n         PRINT GEN\n      IEFZB505 LOCEPAX=YES\n         CVT   DSECT=YES\n      IEFJESCT\n         END   DSN4DD\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ID": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x15\\x7f\\x01\\x01\\x15\\x7f\\x14Y\\x001\\x001\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-06T00:00:00", "modifydate": "2001-06-06T14:59:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "PST0705"}, "text": "         MACRO\n&LABEL   ID    &USING,&CSECT=YES,&AMODE=31,&RMODE=ANY\n         LCLC  &U,&LBL\n.*\n.* Stelco macro used to:\n.*    - generate the CSECT statement.\n.*    - generate the USING, AMODE and RMODE statements for the CSECT.\n.*    - generate an eye-catcher and date/time stamp (28 bytes total).\n.*      (The values for date and time are the time of the Assembly.)\n.*\n.* The default for the USING statement is (register) 15.\n.* Other defaults are as per the prototype above.\n.*\n.* If the CSECT requires multiple base registers, their specification\n.* must be enclosed in parenthesis.       e.g.  BIGRTN   ID     (12,11)\n.*\n.* This macro can also be used to generate only the eye-catcher and\n.* date/time stamp. For this type of usage specify   ID    ,CSECT=NO\n.*\n.* -----------------------Modification History-------------------------\n.* 98-02-19 change from &SYSDATE to &SYSDATC\n.*\n&U       SETC  '15'\n&LBL     SETC  ' '\n         AIF   (K'&LABEL EQ 0).LBLSET\n&LBL     SETC  '&LABEL'\n.LBLSET  ANOP\n         AIF   (T'&USING EQ 'O').USET\n         AIF   ('&USING'(1,1) NE '(').ONEUSE\n&U       SETC  '&USING'(2,K'&USING-2)\n         AGO   .USET\n.ONEUSE  ANOP\n&U       SETC  '&USING'\n.USET    ANOP\n         AIF   ('&CSECT' EQ 'YES').CSECT\n&LBL     DS    0H\n         B     *+32\n         AGO   .STAMP\n.CSECT   ANOP\n&LBL     CSECT\n&LBL     AMODE &AMODE\n&LBL     RMODE &RMODE\n         USING &LABEL,&U\n         BC    15,32(,15)\n.STAMP   ANOP\n         DS    CL4\n         DC    CL8'&LBL'\n         DC    CL16'&SYSDATC &SYSTIME'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MERGE@PC": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x15\\x7f\\x01\\x01\\x15\\x7f\\x19\\x19\\x00\\x0e\\x00\\x0e\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-06T00:00:00", "modifydate": "2001-06-06T19:19:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "PST0705"}, "text": "/* REXX */\nparse arg select, target .\nselect = translate(select,'00'x,'%')\nreturn bitor(bitand(translate(select,overlay('FF'x,copies('00'x,256),1),\n       ,overlay('00'x,xrange('00'x,'FF'x),109)),\n       ,left(target,length(select),'00'x)),select)\n\n/* Following are the component processes of the statement above */\ntarget = left(target,length(select),'00'x)\nself = overlay('00'x,xrange('00'x,'FF'x),c2d('%')+1)\nx_00 = overlay('FF'x,copies('00'x,256),1)\ns = translate(select,x_00,self)\ns = bitand(s,target)\ns = bitor(s,select)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PDSLOAD": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x15\\x7f\\x01\\x01\\x15\\x7f\\x156\\x00e\\x00e\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-06T00:00:00", "modifydate": "2001-06-06T15:36:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "LOADLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "SCC@DSN": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x07\\x01\\x03\\x16O\\x01\\x03\\x16O\\x14#\\x01\\xf2\\x01\\xf2\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-06-13T00:00:00", "modifydate": "2003-06-13T14:23:07", "lines": 498, "newlines": 498, "modlines": 0, "user": "PST0705"}, "text": "./ ADD NAME=$README$ 0101-01157-01235-1310-00019-00046-00000-PST0705\nInstallation / readme for SCC@DSN\n\nThere are 3 component for this package\n\nMACRO    Is the Assembler macro named ID required to assemble the\n         assembler routine. Put it into a library included in your\n         SYSLIB concatenation for the assembly.\n\nSOURCE   Is the single Assembler source deck of the function.\n\nHELP     Is the documentation on how to use SCC@DSN in Rexx programs.\n\nMaking SCC@DSN available to your rexx program can be as simple as\nlink editing it to a load library that is within the JOBLIB/STEPLIB\nconcatenation when the rexx program runs. Myself, I have built a Rexx\nfunction package under the name IRXFLOC which contains all the\nassembler written rexx functions for the platform.\n\nThe HELP documentation should provide all the usage notes required.\n./ ADD NAME=HELP     0105-96073-96204-1023-00077-00063-00000-PST0705\n Name:        SCC@DSN\n\n Purpose:     Determine if a specified dataset exits.\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              SCC@DSN resides in the IRXFLOC \"function package\".\n\n Features:    SCC@DSN extracts the catalog entry to determine the\n              volume serial number. It then ensures that the dataset\n              exists on that volume.\n\n              Datasets belonging to a GenerationDataGroup are supported at\n              the relative generation level.  SCC@DSN will optionally\n              translate a relative level of a GDG to its absolute value.\n\n              Uncatalogued datasets can be verified.\n\n              A dataset which is catalogued to tape is partially\n              supported. SCC@DSN does not check that the dataset\n              exists on the volume.\n\n Arguments:   1. The dataset name as per JCL.\n\n                 For a GenerationDataGroup, the dataset name is\n                 qualified as per JCL. i.e. STP.XX00.GDG(0)\n\n              2. (optional; use for uncatalogued datasets)\n                 The volume serial number.\n\n                 When the second argument is specified, SCC@DSN avoids\n                 checking the system catalog via the LOCATE macro.\n\n              3. (optional) variable name to which the value of the\n                 volume serial number will be assigned.\n\n              4. (optional) variable name to which the value of the\n                 absolute dataset name (of a relative\n                 GenerationDataGroup) will be assigned.\n\n Results:     0 = dataset does not exist or dataset is migrated.\n\n              1 = dataset does exist.\n\n              (when 3rd argument is used.) The variable is assigned\n              the value of the series volume serial numbers. If the\n              dataset is catalogued to multiple volumes, the series\n              entries are separated by commas.\n\n Notes:\n   MIGRATED datasets.\n      Migrated datasets are supported but as per the 'tape dataset'\n      feature. If the 3rd argument is coded, the value returned in\n      that variable will be MIGRAT regardless of the level of\n      migration.  If the dataset is migrated to tape, it will be\n      considerd to exist (because SCC@DSN does not verify tape\n      datasets). If the dataset is migrated to dasd, it will be\n      considered to not exist.\n\n         dsn = 'STTEST.WHATEVER'\n         exist? = scc@dsn(dsn,,'VOL_SER')\n         if vol_ser = 'MIGRAT' then\n              say dsn 'is migrated to' word('dasd tape',exist?+1)\n\n\n   If the 3rd arguement is used, ensure the variable name is enclosed\n   within quotation marks so that REXX does not assign the variable's\n   (pre-set) value before passing it to the function/subroutine.\n\n   SCC@DSN was developed for a specfic jobstream where, under\n   (abnormal) situations, no levels of a generation data group would\n   be available to a jobstep which archives and deletes all the\n   levels of the generation data group.\n\n   SCC@DSN can be used effectively in a batch environment via the\n   RC@FUNC exec to support conditional JCL.  (Note that as a\n   function SCC@DSN does not set a return code but because RC@FUNC\n   is an exec it does set the return code.) See example 2 below.\n\n   If SCC@DSN is utilized to verify that a catalog entry for a disk\n   dataset actually exists on the speified volume, then the second\n   argument should be used to avoid re-checking the system catalog.\n\n   Although in most situations the functionality of SCC@DSN is the\n   same as SYSDSN, the following distinctions should be noted.\n      SCC@DSN is independent of the host environment; SYSDSN is\n      available only under address TSO.\n\n      The dataset name for SCC@DSN is as per JCL. The dataset name\n      for SYSDSN is as per TSO convention. i.e. unquoted dsn's have\n      the PROFILE PREFIX applied; fully qualified dsn's must be\n      enclosed within (single) quotation marks.\n\n      SCC@DSN does not support/validate member names within a\n      partiioned dataset; SYSDSN does.\n\n      SCC@DSN validates relative generation data groups; SYSDSN\n      validates generation data groups only as an absolute dataset\n      name.\n\n      SCC@DSN sets only a logical value (0 or 1) without\n      'explanation' of when the dataset is not found; SYSDSN sets a\n      text value which attempts to explain why the dataset was not\n      found.\n\n      SCC@DSN will validate a dataset name regardless of the system\n      catalog via the second (volser) argument; SYSDSN will only\n      validate a catalogued dataset name.\n\n      SCC@DSN determines the migration level of a dataset; SYSDSN will\n      cause a migrated dataset to be recalled.\n\n Examples:\n   1. Allocate to a dataset if it exists\n          if scc@dsn(userid()'.CLIST') then\n               call sccalloc 'CLISTDD', userid()'.CLIST'\n\n   2. Batch JCL to execute a step if a dataset exists\n          //SETCC  EXEC  PGM=IRXJCL,\n          //             PARM='RC@FUNC SCC@DSN(\"STP.XX00.D2\")\n          //    INCLUDE  MEMBER=SYSEXEC\n          //         IF  (SETCC.RUN & SETCC.RC = 1) THEN\n          //RUN    EXEC  PGM=STXX000\n          //HISTORY  DD  DISP=SHR,DSN=STP.XX00.D2\n          //RPT001OT DD  SYSOUT=(,)\n          //       ENDIF\n\n\n\n\n\n\n./ ADD NAME=MACRO    0102-98050-98050-1606-00049-00046-00000-PST0705\n         MACRO\n&LABEL   ID    &USING,&CSECT=YES,&AMODE=31,&RMODE=ANY\n         LCLC  &U,&LBL\n.*\n.* Stelco macro used to:\n.*    - generate the CSECT statement.\n.*    - generate the USING, AMODE and RMODE statements for the CSECT.\n.*    - generate an eye-catcher and date/time stamp (28 bytes total).\n.*      (The values for date and time are the time of the Assembly.)\n.*\n.* The default for the USING statement is (register) 15.\n.* Other defaults are as per the prototype above.\n.*\n.* If the CSECT requires multiple base registers, their specification\n.* must be enclosed in parenthesis.       e.g.  BIGRTN   ID     (12,11)\n.*\n.* This macro can also be used to generate only the eye-catcher and\n.* date/time stamp. For this type of usage specify   ID    ,CSECT=NO\n.*\n.* -----------------------Modification History-------------------------\n.* 98-02-19 change from &SYSDATE to &SYSDATC\n.*\n&U       SETC  '15'\n&LBL     SETC  ' '\n         AIF   (K'&LABEL EQ 0).LBLSET\n&LBL     SETC  '&LABEL'\n.LBLSET  ANOP\n         AIF   (T'&USING EQ 'O').USET\n         AIF   ('&USING'(1,1) NE '(').ONEUSE\n&U       SETC  '&USING'(2,K'&USING-2)\n         AGO   .USET\n.ONEUSE  ANOP\n&U       SETC  '&USING'\n.USET    ANOP\n         AIF   ('&CSECT' EQ 'YES').CSECT\n&LBL     DS    0H\n         B     *+32\n         AGO   .STAMP\n.CSECT   ANOP\n&LBL     CSECT\n&LBL     AMODE &AMODE\n&LBL     RMODE &RMODE\n         USING &LABEL,&U\n         BC    15,32(,15)\n.STAMP   ANOP\n         DS    CL4\n         DC    CL8'&LBL'\n         DC    CL16'&SYSDATC &SYSTIME'\n         MEND\n./ ADD NAME=SOURCE   0140-95181-01235-1315-00824-00355-00000-PST0705\n@DSN     TITLE            '<< REXX - Determine a datasets existence    X\n                                                      Documentation >>'\n* Name:        SCC@DSN\n*\n* Purpose:     Determine if a specified dataset exits.\n*\n* Environment: REXX subroutine/function for Address TSO or MVS\n*\n* Features:    SCC@DSN extracts the catalogue entry to determine the\n*              volume serial number. It then ensures that the dataset\n*              exists on that volume.\n*\n*              Datasets belonging to a GenerationDataGroup are\n*              supported at the relative generation level.\n*\n*              Uncatalogued datasets can be verified.\n*\n*              A dataset which is catalogued to tape is partially\n*              supported. SCC@DSN does not check that the dataset\n*              exists on the volume.\n*\n* Arguments:   1. The dataset name as per JCL.\n*\n*                 For a GenerationDataGroup, the dataset name is\n*                 qualified as per JCL. i.e. STP.XX00.GDG(0)\n*\n*              2. (optional; use for uncatalogued datasets)\n*                 The volume serial number.\n*\n*              3. (optional) A variable name which will be assigned\n*                 the value of the volume serial number.\n*\n*              4. (optional) A variable name which will be assigned the\n*                 value of the absolute dataset name (for a relative\n*                 GenerationDataGroup).\n*\n* Results:     If the dataset exists, the result is 1 (one).\n*\n*              If the dataset does not exist, the result is 0 (zero).\n*\n*              If a (list of) volume serial number(s) was requested\n*              via argument three, entries in the list are separated\n*              by commas.\n         TITLE            '<< REXX - Determine a datasets existence    X\n                                                                    >>'\n         PRINT   GEN\nSCC@DSN  ID    R12\n         SPACE 2\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         ST    R13,SAVEAREA+4\n         LA    R15,SAVEAREA\n         ST    R15,8(,R13)\n         LR    R13,R15\n         XC    RC,RC\n         B     MAINLINE\n         SPACE 3\nRC       DS    0F\n         DS    AL1\nRC1      DS    AL1\nRC2      DS    AL1\nRC3      DS    AL1\n         SPACE 1\nSAVEAREA DS    18F\n         SPACE 1\nRTNXT    DS    0H\n         L     R15,RC\n         L     R13,SAVEAREA+4\n         XC    8(4,R13),8(R13)\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n         TITLE            '<< REXX - Determine a datasets existence    X\n                                                             Do it. >>'\nMAINLINE DS    0H\n         USING EFPL,R1\n         USING ENVBLOCK,R8\n         LR    R8,R0               Address the environment block.\n         USING ARGTABLE_ENTRY,R10\n         USING EVALBLOCK,R11\n         USING IRXEXTE,R9\n         USING SHVBLOCK,R7\n         LM    R10,R11,EFPLARG     Address ARGTABLE & EVALBLOCK\n         L     R11,0(,R11)\n         L     R9,ENVBLOCK_IRXEXTE Address the REXX vector table.\n         DROP  R1\n         MVI   EVALBLOCK_EVDATA,C'1'  Presume dataset will be found.\n         LA    R14,1               Set\n         ST    R14,EVALBLOCK_EVLEN   length.\n         MVI   TRTABLE-1,X'FF'\n         MVI   DSN,C' '\n         MVC   DSN+1(L'DSN+L'VOLSER-1),DSN\n         XC    DEV_CODE,DEV_CODE\n         BAL   R14,STRIP           Parse ARG(1).\n         B     MISSING_DSN            - there was no ARG(1) -\n         EX    R15,MVC_DSN         Get dataset name.\n         BAL   R14,STRIP           Parse ARG(2).\n         B     DO_LOCATE              - there was no ARG(2) -\n         EX    R15,MVC_VOLSER      Get volume serial number.\n         B     ISSUE_OBTAIN\n         SPACE 3\nDO_OBTAIN DS   0H\n         TM    DEV_CODE+2,X'20'    Is the device class 'dasd'?\n         BZ    RTNXT                  -no -\nISSUE_OBTAIN   DS    0H\n        OBTAIN OBTAIN              Verify DSCB\n         LTR   R15,R15             Good?\n         BZ    RTNXT                  -yes-\n         SPACE 1\nFALSE    DS    0H\n         MVI   EVALBLOCK_EVDATA,C'0'  -no -   revert to 'false'\n         B     RTNXT                             and exit\n         SPACE 3\nDO_LOCATE LOCATE LOCATE            Verify catalog entry\n         LTR   R15,R15             Good?\n         BNZ   FALSE                  -no -\n         MVC   VOLSER,WA_VOLSER    Extract the volser from catalog.\n         BAL   R14,STRIP           Variable name for volser?\n         B     IF_ARG4                -no -\n         ST    R3,SHVNAMA-SHVBLOCK+@SHV\n         LA    R15,1(,R15)\n         ST    R15,SHVNAML-SHVBLOCK+@SHV\n         LH    R15,VOLUMES\n         LA    R2,WA_VOLSER\n         ST    R2,SHVVALA-SHVBLOCK+@SHV\n         LA    R14,12(,R2)\n         LA    R1,6\nLOOP     DS    0H\n         BCT   R15,*+8\n         B     CALL_EXCOM\n         MVI   6(R2),C','\n         MVC   7(6,R2),0(R14)\n         LA    R1,7(,R1)\n         LA    R2,7(,R2)\n         LA    R14,12(,R14)\n         B     LOOP\n         SPACE 1\nMVC_DSN  MVC   DSN(0),0(R3)\nMVC_VOLSER     MVC   VOLSER(0),0(R3)\n         TITLE            '<< REXX - Determine a datasets existence    X\n                                     Assign the logical value to RC >>'\n*\n* Refer to the IRXEXCOM routine; pages 312-319 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\nCALL_EXCOM  DS  0H\n         ST    R1,SHVVALL-SHVBLOCK+@SHV\n         L     R15,IRXEXCOM        Get routine's address from vector.\n         LA    R0,ENVBLOCK         Make sure REXX knows environment.\n         LA    R1,PLIST_EXCOM\n         BALR  R14,R15\nIF_ARG4  DS    0H\n         BAL   R14,STRIP           Variable name for dsn?\n         B     DO_OBTAIN              -no -\n         ST    R3,SHVNAMA-SHVBLOCK+@SHV\n         LA    R15,1(,R15)         Get length of varaiable name\n         ST    R15,SHVNAML-SHVBLOCK+@SHV  into SHVBLOCK\n         MVI   TRTABLE-1,X'00'     Every\n         MVC   TRTABLE,TRTABLE-1      character\n         MVI   TRTABLE+X'40',X'40'        except blank is valid.\n         LA    R1,DSN+44           Pre-set delimiting address.\n         TRT   DSN,TRTABLE         Find a blank.\n         LA    R0,DSN              Address of variable's address\n         ST    R0,SHVVALA-SHVBLOCK+@SHV  into the SHVBLOCK.\n         SR    R1,R0               Calculate length of value.\n         ST    R1,SHVVALL-SHVBLOCK+@SHV\n         L     R15,IRXEXCOM        Get routine's address from vector.\n         LA    R0,ENVBLOCK         Make sure REXX knows environment.\n         LA    R1,PLIST_EXCOM\n         BALR  R14,R15\n         B     DO_OBTAIN\n         SPACE 1\nPLIST_EXCOM DC A(EXCOM_LIT,0,0)\n         DC    A(@SHV+X'80000000')\n         SPACE 1\n@SHV     DS    0A\n         DC    2A(0)\n         DC    C'S'\n         DS    XL3'000000'\n         DC    3A(0)\n         DC    A(WA_VOLSER,6)\n         SPACE 1\nEXCOM_LIT DC   CL8'IRXEXCOM'\nRC_LIT   DC    C'RC'\n         TITLE            '<< REXX - Determine a datasets existence    X\n                     Subroutine to Strip Leading && Trailing Blanks >>'\n* Registers upon entry\n*    R10 ==> argument table entry\n*    R14 ==> exit address when agrument is null\n*    R14+4=> normal exit\n*\n* Registers upon exit\n*    R10 ==> next argument table entry.\n*    R2    = 0 (zero)\n*    R3  ==> leftmost non-blank byte of argument\n*    R4  ==> rightmost non-blank byte of argument\n*    R15   = R4 - R3 (length of argument minus 1)\n         SPACE 2\nHEXFF    DC    X'FFFFFFFFFFFFFFFF'\n         DS    XL1\nTRTABLE  DS    XL256\n         SPACE 1\nTRT3     TRT   0(0,R3),TRTABLE\n         SPACE 2\n         USING ARGTABLE_ENTRY,R10\nSTRIP    DS    0H\n         CLC   HEXFF,ARGTABLE_ARGSTRING_PTR  Is there an argument?\n         BER   R14                              -no -\n         L     R15,ARGTABLE_ARGSTRING_LENGTH\n         L     R3,ARGTABLE_ARGSTRING_PTR  Get address of argument.\n         LA    R10,ARGTABLE_NEXT   Point to next argument table entry.\n         SPACE 1\n         LTR   R15,R15             Does the argument have any length?\n         BZR   R14                    -NO - take abnormal exit.\n         LA    R4,0(R15,R3)        Point just beyond ARG.\n         MVC   TRTABLE,TRTABLE-1   Set to\n         MVI   TRTABLE+C' ',X'00'     bypass blanks.\n         BCTR  R15,0               Set length for TRT instruction.\n         EX    R15,TRT3            Skip to non-blank.\n         BZR   R14                 When all blank.\n         LR    R3,R1               Re-set starting address.\nSTRIP@R  DS    0H\n         BCTR  R4,0                Backpedal 1 byte.\n         CLI   0(R4),X'40'         (still) at a blanK?\n         BNE   STRIPPED               -no -\n         CR    R4,R3                  -yes-  More to inspect?\n         BH    STRIP@R                          -yes-\nSTRIPPED DS    0H\n         LR    R15,R4              Calculate\n         SR    R15,R3                 length of ARG - 1.\n         SR    R2,R2               Pre-clear R2 for TRT\n         XC    TRTABLE,TRTABLE     Clear translate table.\n         BC    15,4(,R14)          Take normal exit.\n         TITLE            '<< REXX - Determine a datasets existence    X\n                                                   Error Conditions >>'\n*\n* Refer to the IRXSAY   routine; pages 336-339 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\nSAY_LIT        DC    CL8'WRITE   '\nSAY_BUFF       DS    A\nSAY_LEN        DS    F\nSAY_PLIST      DC    A(SAY_LIT,SAY_BUFF,SAY_LEN+X'80000000')\nMISSING_DSN_MSG DC    C'Argument (Datasetname) missing.'\nMISSING_DSN    DS    0H\n         LA    R15,MISSING_DSN_MSG\n         LA    R0,L'MISSING_DSN_MSG\n         B     SAY_CALL\nSAY_CALL DS    0H\n         ST    R15,SAY_BUFF\n         ST    R0,SAY_LEN\n         LA    R1,SAY_PLIST\n         LA    R0,ENVBLOCK\n         L     R15,IRXSAY\n         BALR  R14,R15\n         L     R13,SAVEAREA+4\n         XC    8(4,R13),8(R13)\n         LM    R14,R12,12(R13)\n         LA    R15,40\n         BR    R14\n         TITLE            '<< REXX - Determine a datasets existence    X\n                                           Data areas and constants >>'\n         PRINT   GEN\nOBTAIN  CAMLST SEARCH,DSN,VOLSER,WORKAREA\n         SPACE 1\nLOCATE  CAMLST NAME,DSN,,WORKAREA\n         PRINT NOGEN\n         SPACE 3\n         SPACE 3\n         SPACE 3\nDSN      DS    CL44\nVOLSER   DS    CL6\n         DS    0D\nWORKAREA DS    0CL265\nVOLUMES  DS     H\nDEV_CODE DS    XL4\nWA_VOLSER DS   CL6\n         DS    CL(265-12)\n         LTORG\n         TITLE            '<< REXX - Determine a datasets existence    X\n                                                 DSECTs and EQUates >>'\n         YREGS\n         SPACE 2\n       IRXENVB\n         SPACE 2\n       IRXEXTE\n         SPACE 2\n       IRXEFPL\n         SPACE 2\n      IRXARGTB\n         SPACE 2\n      IRXEVALB\n         SPACE 2\n       IRXSHVB\n         END   SCC@DSN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCCALLOC": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\"_\\x01\\x02\"_\\x08G\\x04j\\x04j\\x00\\x00\\xd7\\xc4\\xe2\\xd3\\xd6\\xc1\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-08-13T00:00:00", "modifydate": "2002-08-13T08:47:00", "lines": 1130, "newlines": 1130, "modlines": 0, "user": "PDSLOAD"}, "text": "./ ADD NAME=$$INDEX$ 0100-02224-02224-1603-00008-00008-00000-PST0705\nThe following are the member names associated with the built-in function\nnamed SCCALLOC for REXX.\n\n$README  - How to install SCCALLOC\nID$S     - ID Assembler macro used within assembley of SCCALLOC\nSCCALL$H - A 'help' file explaining the various SCCALLOC agruments,\n           features, and funtionality\nSCCALL$S - The Assembler source\n./ ADD NAME=$README  0100-02224-02224-1601-00013-00013-00000-PST0705\nSCCALLOC must be made an entry in one of the 3 Rexx function packages\n -- or --  a single load module availble via STEPLIB etc. The function\npackage is a more efficient operating environment but requires\nre-assembley of the package for installation. Refer to the TSO REXX\nreference manual for building REXX function pacakges.\n\nTo assemble the source as provided, the ID macro must be made available\nto the Assembler. Copy and rename ID$S member from this package into\na library within the SYSLIB concatenation for the Assembler. The new\nname will be  ID.\n\nLink edit the assembled source as per the function package  -- or --\ninto a load library which will be available via STEPLIB etc.\n./ ADD NAME=ID$S     0100-02224-02224-1537-00049-00049-00000-PST0705\n         MACRO\n&LABEL   ID    &USING,&CSECT=YES,&AMODE=31,&RMODE=ANY\n         LCLC  &U,&LBL\n.*\n.*        macro used to:\n.*    - generate the CSECT statement.\n.*    - generate the USING, AMODE and RMODE statements for the CSECT.\n.*    - generate an eye-catcher and date/time stamp (28 bytes total).\n.*      (The values for date and time are the time of the Assembly.)\n.*\n.* The default for the USING statement is (register) 15.\n.* Other defaults are as per the prototype above.\n.*\n.* If the CSECT requires multiple base registers, their specification\n.* must be enclosed in parenthesis.       e.g.  BIGRTN   ID     (12,11)\n.*\n.* This macro can also be used to generate only the eye-catcher and\n.* date/time stamp. For this type of usage specify   ID    ,CSECT=NO\n.*\n.* -----------------------Modification History-------------------------\n.* 98-02-19 change from &SYSDATE to &SYSDATC\n.*\n&U       SETC  '15'\n&LBL     SETC  ' '\n         AIF   (K'&LABEL EQ 0).LBLSET\n&LBL     SETC  '&LABEL'\n.LBLSET  ANOP\n         AIF   (T'&USING EQ 'O').USET\n         AIF   ('&USING'(1,1) NE '(').ONEUSE\n&U       SETC  '&USING'(2,K'&USING-2)\n         AGO   .USET\n.ONEUSE  ANOP\n&U       SETC  '&USING'\n.USET    ANOP\n         AIF   ('&CSECT' EQ 'YES').CSECT\n&LBL     DS    0H\n         B     *+32\n         AGO   .STAMP\n.CSECT   ANOP\n&LBL     CSECT\n&LBL     AMODE &AMODE\n&LBL     RMODE &RMODE\n         USING &LABEL,&U\n         BC    15,32(,15)\n.STAMP   ANOP\n         DS    CL4\n         DC    CL8'&LBL'\n         DC    CL16'&SYSDATC &SYSTIME'\n         MEND\n./ ADD NAME=SCCALL$H 0100-02224-02224-1534-00139-00139-00000-PST0705\n Name:        SCCALLOC\n\n Purpose:     Provide native REXX with the equivalent of TSO\n              ALLOCATE and FREE\n\n Environment: REXX subroutine/function for Address TSO or MVS\n\n Features:    Refer to argument 1 formats\n\n\n Arguments:\n           1. The first argument is the ddname operand. It may be\n              specified in one of six  formats.\n            .1  A single ddname representing the dd to be\n                allocated/freed.\n            .2  A list of ddnames to be freed. The ddnames must be\n                separated by at least one blank. With this format,\n                argument two is ignored.\n            .3  A single ddname with a plus sign (+) appended as a\n                suffix. This is to indicate that the dataset(s)\n                specified at argument 2 are to be concatenated ahead\n                of those aleady allocated to the specified ddname.\n                Note that the ddname does not necessarily have to\n                be pre-allocated for this format.\n            .4  A single ddname with a question mark (?) appended as a\n                suffix. This is to indicate that the dataset(s)\n                specified at argument 2 are to be allocated only if\n                the ddname is not already allocated. Note that the\n                dataset(s) specified at argument 2 are verified\n                even if the ddname is already allocated.\n            .5  A single ddname with a equal sign (=) appended as a\n                suffix. This is to indicate that the ddname\n                specified at argument 2 is to be allocated to the\n                datasets already allocated to the ddname (without\n                the suffix) at argument 1.\n            .6  A single ddname with an underscore (_) appended as a\n                suffix. This is special means of telling SCCALLOC\n                not to check the catalog and existence of the dataset(s)\n                specified at argument 2. This format should be reserved\n                for temporary (i.e. VIO) datasets.\n            .7  A single ddname with left parenthesis appended as a\n                suffix. This format will cause SCCALLOC to allocate a\n                system determined ddname to a member (specified in\n                argument 2) within the (first) dataset represented by the\n                ddname specified (without the suffix) at argument 1.\n                SCCALLOC will return the system determined ddname.\n           2. (optional - if omitted the specified ddname is freed)\n              The (list of) dataset name(s) to be allocated. Names\n              must be specified in JCL format; quotes are not used,\n              high level node is required.\n\n              If allocating to the member level, specify the member\n              name as per JCL; i.e. enclosed in parenthesis and\n              appended to the library name.\n\n              If allocating to a relative GDG, specify the GDG\n              level as per JCL; i.e. enclosed in parenthesis and\n              appended to the GDG index name.\n\n              For formats 2, 5 and 7 of argument 1, argument 2\n              also  has special format\n\n            .2  null\n\n            .5  The ddname from which the new allocation will be\n                made.\n\n            .7  The member name to which allocation is required.\n\n Results:     The direct result of the subroutine/function is a\n              logical value indicating whether or not the requested\n              function was performed. Refer to the example 1 below.\n\n              The variable RC is set as per the return code from\n              LOCATE/OBTAIN/DYNALLOC.\n\n              For format 7 of argument 1, the result is the system\n              determined ddname. If the dynamic allocation fails the\n              the result is 0 (zero).\n\n              In error situations, appropriate messages are generated.\n              The messages after a DYNALLOC failure are formatted to\n              assist the programmer maintaining the SCCALLOC program\n              and are to be used in conjunction with the IBM manual\n              \"Authorized Assembler Programming Langauge Programs\"\n              (GC28-1645) chapter 23.  Error code 0218 0000 will be\n              generated if the dataset is catalogued to a tape (i.e\n              \"not mounted\") device.\n\n\n Examples:\n  1. Conditional allocates as well as multiple frees.\n      /* REXX */\n      Call Initailize\n      Call Process\n      Call Terminate\n      exit\n      Initialize:\n           dd_s = ''\n           if SCCALLOC('DD1?','MY.DATASET')   then dd_s = dd_s 'DD1'\n           if SCCALLOC('DD2?','YOUR.DATASET') then dd_s = dd_s 'DD2'\n        return 0\n      Terminate::\n           if dd_s \\= '' then SCCALLOC(dd_s)\n        return 0\n\n  2. Remove a specified dataset from the SYSEXEC allocation.\n      /* REXX */\n      ? = dsn4dd('SYSEXEC')\n      if ? == arg(1) then dsn_s = ''\n      else dsn_s = ?\n      do i = 1 to rc-1\n           ? = dsn4dd('SYSEXEC+'i)\n           if ? \\== arg(1) then dsn_s = dsn_s ?\n      end\n      call SCCALLOC 'SYSEXEC', dsn_s\n      exit\n\n Notes:\n   SCCALLOC will allocate only to existing datasets. It always uses\n   a disposition of SHR.\n\n   A relative GDG is automatically resolved to its absolute dataset\n   name. Do not use SCCALLOC to achieve that resolution; rather use\n   SCC@DSN to determine an absolute gdg name without allocating it.\n\n   SCCALLOC provides only limited allocations operands i.e. DSNAME\n   DDNAME/FILE and SHR. SCCALLOC's purpose is to allow a non-TSO\n   application to allocate to existing datasets.  TSO applications\n   should utilize the ALLOCATE command unless a feature of SCCALLOC\n   is required.\n\n   If an uncataloged dataset is (pre)allocated and format 3 of\n   argument 1 for that ddname is requested, a DYNALLOC failure will\n   occur.\n\n   Failures may render an unexpected allocation environment i.e\n   partial unallocates/allocates\n\n./ ADD NAME=SCCALL$S 0100-02224-02224-1513-00916-00916-00000-PST0705\nALLOC    TITLE            '<< REXX - Dynamic dataset allocation        X\n                                                      Documentation >>'\n* Refer to  QW R=SCCALLOC  for description of how to use SCCALLOC\n*\n* Written originally for the REXX exec UPDATE (May 1996)\n*\n* This program could be made re-entrant with little difficulty\n* but since it is part of a IRXFLOC function package, the whole\n* function package must be made re-entrant first.\n*\n* Support documentation for DYNALLOC is contained in the IBM manual\n* \"Authorized Assembler Programming\" (GC28-1645) chapter 23.\n*\n         TITLE            '<< REXX - Dynamic dataset allocation        X\n                                                     System Linkage >>'\nSCCALLOC ID    R12\n         SPACE 2\n         PRINT NOGEN\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         LA    R0,WORKLEN\n      GETMAIN  R,LV=(0)\n         USING GET_MAIN,R1\n         ST    R13,SAVEAREA+4\n         ST    R1,8(,R13)\n         LR    R15,R13\n         LR    R13,R1\n         LM    R0,R1,20(R15)\n         DROP  R1\n         USING GET_MAIN,R13\n         XC    RC,RC\n         B     MAINLINE\n         SPACE 3\nRC       DS    0F\n         DS    AL1\nRC1      DS    AL1\nRC2      DS    AL1\nRC3      DS    AL1\n         SPACE 3\nRTNXT    DS    0H\n         LR    R2,R13\n         L     R13,SAVEAREA+4\n         LA    R0,WORKLEN\n      FREEMAIN R,LV=(R0),A=(R2)\n         XC    8(4,R13),8(R13)\n         XC    16(4,R13),16(R13)   R15 (return code) always\n         LM    R14,R12,12(R13)        get set to zero.\n         BR    R14\n         USING EFPL,R1\n         USING S99TUNIT,R7\n         USING ENVBLOCK,R8\n         USING EVALBLOCK,R11\n         TITLE            '<< REXX - Dynamic dataset allocation        X\n                               Adressability and Re-entrancy set-up >>'\nMAINLINE DS    0H\n         LR    R8,R0               Address the environment block.\n         L     R9,ENVBLOCK_IRXEXTE Address the REXX vector table.\n         LM    R10,R11,EFPLARG     Address ARGTABLE & EVALBLOCK.\n         L     R11,0(,R11)\n         LA    R0,1\n         ST    R0,EVALBLOCK_EVLEN\n         MVI   EVALBLOCK_EVDATA,C'0'\n         DROP  R1\n         DROP  R8\n         LA    R7,TU@___DDNAM\n         XC    S99TUNIT(6),S99TUNIT\n         MVI   S99TUKEY+1,DALDDNAM\n         MVI   S99TUNUM+1,X'01'\n         MVI   S99TUPAR,C' '       Pre-clear\n         MVC   S99TUPAR+1(7),S99TUPAR the ddname\n         ST    R7,FREE_TUPL\n         ST    R7,CONC_TUPL\n         ST    R7,DAL_TUPL+4\n         MVI   DD_SW,NULL\n         XC    CONCAT_COUNT,CONCAT_COUNT\n         MVI   TRTABLE-1,X'FF'     Pre-set table value.\n         XC    TRTDSN,TRTDSN\n         MVI   TRTDSN+C' ',X'01'\n         TITLE            '<< REXX - Dynamic dataset allocation        X\n                                                 Process the DDname >>'\n         BAL   R14,STRIP           Strip out arg(1).\n         B     MISSING_DDNAME      Arg(1) not specified.\n         LA    R0,8                Is arg(1)\n         CR    R15,R0                 longer than 8 bytes?\n         BH    MULTI_FREE                -yes-\n         EX    R15,TRT_ARG         Does arg(1) contain a blank?\n         BNZ   MULTI_FREE             -yes-\n         LA    R2,1(,R15)          Get length of the value.\n         CLI   0(R4),C'_'          Avoid LOCATE/OBTAIN?\n         BNE   *+12                   -no -\n         OI    DD_SW,@VIO          Set the indicator.\n         B     CLIP_ARG1\n         CLI   0(R4),C'='          Copy a DD?\n         BNE   *+12                   -no -\n         OI    DD_SW,COPY_DD       Set the indicator.\n         B     CLIP_ARG1\n         CLI   0(R4),C'+'          Forcing concatenation?\n         BNE   *+12                   -no -\n         OI    DD_SW,CONCAT_FORCE  I will have to concatenate.\n         B     CLIP_ARG1\n         SPACE 1\n         CLI   0(R4),C'?'          Request conditional?\n         BNE   *+12                   -no -\n         OI    DD_SW,CONDITIONAL   I will have to concatenate.\n         B     CLIP_ARG1\n         SPACE 1\n         CLI   0(R4),C'('          Request conditional?\n         BNE   CLIP_ARG1+2            -no -\n         OI    DD_SW,@MEMBER       I have to allocate to a member.\n         B     CLIP_ARG1\nCLIP_ARG1  DS  0H\n         BCTR  R2,0                Exclude one byte from the length.\n         SPACE 1\n         STH   R2,S99TULNG\n         BCTR  R2,0                Save\n         EX    R2,MVC_TU              the ddname.\n         TITLE            '<< REXX - Dynamic dataset allocation        X\n                   Collect and verify the dataset names from arg(2) >>'\n         BAL   R14,STRIP           Strip out arg(2).\n         B     FREE_ONLY           No arg(2) means do a FREE.\n         MVI   TRTDSN+C')',X'01'\n         MVI   TRTDSN+C'(',X'02'\n         XC    LOCATE_OBTAIN,LOCATE_OBTAIN\n         MVI   LOCATE_PLIST,X'44'\n         LA    R0,WORKAREA\n         ST    R0,LOCATE@WORK\n         ST    R0,OBTAIN@WORK\n         MVI   OBTAIN_PLIST,X'C1'\n         LA    R0,VOLSER\n         ST    R0,OBTAIN@VOLSER\n         LA    R7,DSN_LIST\n         XC    S99TUNIT(4),S99TUNIT\n         MVI   S99TUKEY+1,DALDSNAM Set the key\n         MVI   S99TUNUM+1,X'01'\n         SR    R2,R2\nARG2_DSN DS    0H\n         MVI   S99TUPAR,C' '       Pre-clear\n         MVC   S99TUPAR+1(44),S99TUPAR  for a dsn plus one byte\n         LA    R0,S99TUPAR         A(DSN) for\n         ST    R0,LOCATE@DSN          LOCATE and\n         ST    R0,OBTAIN@DSN             OBTAIN plist's.\n         LR    R15,R4              Calculate\n         SR    R15,R3                 the residual length.\n         LA    R5,43               Maximum dsn length\n         CR    R15,R5              Residual < 43 ?\n         BNL   *+6                    -no -\n         LR    R5,R15                 -yes-  Use the shorter.\n         LA    R1,1(R5,R3)         Pre-set R1 in case TRT misses.\n         EX    R5,TRT_ARG          Find delimiter within dsn.\n         BZ    NOT_GDG\n         CLI   1(R1),C'0'          Is this a relative GDG?\n         BE    USE_GDG                -yes-\n         CLI   1(R1),C'-'          Is this a relative GDG?\n         BNE   NOT_GDG                -no -\nUSE_GDG  DS    0H\n         LR    R14,R1\n         LA    R5,8                Maximum length.\n         CR    R15,R5              More than residual length?\n         BNL   *+6                    -no -\n         LR    R5,R15                 -yes-  Use residual length.\n         LA    R1,1(R5,R3)         Pre-set R1 in case there is no hit.\n         EX    R5,TRT_GDG          Find the delimiting paren.\n         AR    R1,R2               Right paren adjustment.\nNOT_GDG  DS    0H\n         LR    R14,R1              Hang on to the delimit address.\n         SR    R1,R3               Calculate length of dsn and\n         STH   R1,S99TULNG            save it in case we don't LOCATE.\n         BCTR  R1,0                Instruction length.\n         EX    R1,MVC_TU           Pick-up the dsn.\n         SPACE 1\n         LA    R3,1(,R14)          Set the 'scanned-to' address.\n         ST    R2,DBLWD            Preserve R2 across LOCATE/OBTAIN\n         TM    DD_SW,@VIO          Allocating to existing VIO?\n         BO    NO_OBTAIN              -yes-\n         TM    DD_SW,@MEMBER       Allocating a member?\n         BZ    *+12                   -no -\n         MVI   S99TUKEY+1,DALMEMBR    -yes-  Set the key and\n         B     NO_OBTAIN                        don't LOCATE/OBTAIN.\n         TM    DD_SW,COPY_DD       Copying a DDname allocation?\n         BZ    *+16                   -no -\n         MVI   S99TULNG+1,X'08'       -yes-  Force a length of 8,\n         MVI   S99TUKEY+1,DALDDNAM              set the key and\n         B     NO_OBTAIN                           don't LOCATE/OBTAIN.\n         SPACE 1\n       LOCATE  LOCATE_PLIST\n         LTR   R15,R15             Cataloged?\n         BNZ   LOCATE_ERROR           -no -\n         TRT   S99TUPAR(45),TRTDSN LOCATE will have resolved GDG.\n         LA    R0,S99TUPAR\n         SR    R1,R0               Calculate DSN length\n         STH   R1,S99TULNG            and save it.\n         TM    DEV_CODE+2,X'20'    Is the device class 'dasd'?\n         BZ    NO_OBTAIN              -no -\n         MVC   VOLSER,WA_VOLSER    Use the volser as per catalog.\n       OBTAIN  OBTAIN_PLIST\n         LTR   R15,R15             Is there a VTOC entry on the volume?\n         BNZ   OBTAIN_ERROR           -no -\nNO_OBTAIN  DS  0H\n         L     R2,DBLWD            Recover R2\n         LH    R1,S99TULNG         Need the DSN length again.\n         LA    R7,7(R1,R7)         Calculate address of next text unit\n         SRL   R7,1                   rounded to\n         SLL   R7,1                      halfword.\n         XC    S99TUNIT(4),S99TUNIT\n         MVI   S99TUKEY+1,DALDSNAM Pre-set the key.\n         MVI   S99TUNUM+1,X'01'\n         CR    R3,R4               At the end of arg(2)?\n         BNL   DD_SEARCH              -yes-\n         BCT   R2,*+8              Member name to follow?\n         B     NEXT_ARG2              -no -\n         CR    R3,R4               Reached the end of the arg?\n         BNL   DD_SEARCH              -yes-\n         LR    R15,R4              Calculate\n         SR    R15,R3                 the residual length.\n         LA    R5,8                Max. member name length\n         CR    R15,R5              More than residual length?\n         BNL   *+6                    -no -\n         LR    R5,R15                 -yes-  Use residual length.\n         LA    R1,1(,R5)           Pre-set R1 in case there is no hit.\n         EX    R5,TRT_ARG          Find the end of the member name.\n         CLI   0(R1),C')'\n         BNE   DSN_ERROR\n         LR    R14,R1              Hang on to the delimit address.\n         SR    R1,R3               Calculate membername length\n         STH   R1,S99TULNG           and save it.\n         SR    R15,R1              Decrement arg(2) residual length.\n         BCTR  R1,0                Instruction length.\n         EX    R1,MVC_TU           Pick-up the member name\n         MVI   S99TUKEY+1,DALMEMBR (Re)set the key.\n         LH    R1,S99TULNG         Need the mem name length again.\n         LA    R7,7(R1,R7)         Calculate address of next text unit\n         SRL   R7,1                   rounded to\n         SLL   R7,1                      halfword.\n         XC    S99TUNIT(4),S99TUNIT\n         MVI   S99TUKEY+1,DALDSNAM Pre-set the key.\n         MVI   S99TUNUM+1,X'01'\n         LA    R3,2(,R14)          Set the 'scanned-to' address\nNEXT_ARG2  DS  0H\n         CR    R3,R4               At the end of arg(2)?\n         BNL   DD_SEARCH              -yes-\n         LH    R1,CONCAT_COUNT\n         LA    R1,1(,R1)\n         STH   R1,CONCAT_COUNT\n         TRT   0(256,R3),TRTABLE\n         LR    R3,R1\n         LR    R15,R4\n         SR    R15,R3\n         B     ARG2_DSN\n         USING PSA,R0\n         USING TCB,R1\n         USING INFMJFCB,R5\n         TITLE            '<< REXX - Dynamic dataset allocation        X\n                       Determine if/how ddname is already allocated >>'\nFREE_ONLY  DS  0H\n         OI    DD_SW,FREE_FORCE\nDD_SEARCH  DS  0H\n         SR    R0,R0               Used later\n         LR    R5,R0                  for IC/ICM instructions.\n         L     R1,PSATOLD          Get TCB address.\n         L     R15,TCBTIO           Get TIOT address.\n         DROP  R1\n         USING TIOT1,R15\nFIND_DD  DS    0H\n         CLC   TIOEDDNM,DDNAME     Is this the requester's DDname?\n         BE    FOUND_DD               -yes-\n         CLI   TIOELNGH,X'00'      End of TIOT's?\n         BE    SEARCHED               -yes-\n         IC    R0,TIOELNGH         Get TIOT length and\n         AR    R15,R0                 point to next TIOT.\n         B     FIND_DD             Loop back.\nFOUND_DD DS    0H\n         OI    DD_SW,ALLOCATED     Say 'DD is allocated'\n         TM    DD_SW,FREE_FORCE    Asking for FREE?\n         BO    ONE_FREE               -yes-   This is easy.\n         TM    DD_SW,CONDITIONAL   Conditional allocate?\n         BO    RC@0                   -yes-   This is easier.\n         TM    DD_SW,@MEMBER       Requested to allocate to a member?\n         BO    COLLECT                -yes-   I have to get dsn.\n         TM    DD_SW,COPY_DD       Requested to copy an allocation?\n         BO    COLLECT                -yes-   I have to get dsn.\n         TM    DD_SW,CONCAT_FORCE  Asking for concatenation?\n         BZ    SEARCHED               -no -   I presume REUSE\nCOLLECT  DS    0H\n         ICM   R5,7,TIOEJFCB       Get the JFCB TTR address.\n         LTR   R5,R5               Is there a JFCB address?\n         BZ    COLLECTED              -no -\n         LA    R5,16(,R5)\n         LH    R1,CONCAT_COUNT     Count\n         LA    R1,1(,R1)              another\n         STH   R1,CONCAT_COUNT           concatenated dataset.\n         MVC   S99TUPAR(44),JFCBDSNM   Get the DSN\n         LA    R1,S99TUPAR+44      In case of full name.\n         TRT   S99TUPAR(44),TRTDSN Find the blank.\n         LA    R0,S99TUPAR         Calculate\n         SR    R1,R0                  length of DSN\n         STH   R1,S99TULNG               and save it.\n         LA    R7,7(R1,R7)         Calculate address of next text unit\n         SRL   R7,1                   rounded to\n         SLL   R7,1                      halfword.\n         XC    S99TUNIT(4),S99TUNIT  Pre-clear the next text unit.\n         MVI   S99TUKEY+1,DALDSNAM Pre-set the key.\n         MVI   S99TUNUM+1,X'01'\n         TM    JFCBTSDM,JFCPAT     DSCB patterning done?\n         BO    COLLECTED             -yes-\n         CLI   JFCBELNM,C' '       Is there a member name?\n         BE    COLLECTED             -no -\n         MVI   S99TUKEY+1,DALMEMBR (Re)set the key.\n         MVC   S99TUPAR(8),JFCBELNM   Get the GDG/member name\n         LA    R1,S99TUPAR+8       In case of full member name.\n         TRT   S99TUPAR(8),TRTDSN  Find the blank.\n         LA    R0,S99TUPAR         Calculate\n         SR    R1,R0                  length of member name\n         STH   R1,S99TULNG               and save it.\n         LA    R7,7(R1,R7)         Calculate address of next text unit\n         SRL   R7,1                   rounded to\n         SLL   R7,1                      halfword.\n         XC    S99TUNIT(4),S99TUNIT  Pre-clear the next text unit.\n         MVI   S99TUKEY+1,DALDSNAM Pre-set the key.\n         MVI   S99TUNUM+1,X'01'\nCOLLECTED  DS  0H\n         SR    R0,R0\n         IC    R0,TIOELNGH         Get TIOT length.\n         LTR   R0,R0               Is there any length?\n         BZ    SEARCHED               -no -   Done collecting\n         AR    R15,R0              Point to next TIOT.\n         CLC   TIOEDDNM,=CL8'        '   Still same DDname?\n         BE    COLLECT                      -yes-   collect the DSN\n         SPACE 3\n         DROP  R15\n         DROP  R0\n         USING S99RB,R2\n         USING S99TUPL,R6\n         TITLE            '<< REXX - Dynamic dataset allocation        X\n                                    Proceed with required allocates >>'\nSEARCHED DS    0H\n*\n* Note that the logic at FOUND_DD honours a valid FREE request.\n* Here we handle the superfluous FREE request.\n*\n         TM    DD_SW,FREE_FORCE    FREE an un_allocated ddname?\n         BO    RC@0                   -yes-  Ignore the request.\n         TM    DD_SW,@MEMBER\n         BO    ALLOC_MEM\n         TM    DD_SW,COPY_DD\n         BO    COPY@DD\n         TM    DD_SW,ALLOCATED\n         BZ    FREED\n         LA    R2,S99_RB           Address the request block\n         MVI   S99VERB,S99VRBUN       and set its 'verb'.\n         LA    R6,FREE_TUPL        Address the text unit parameter list\n         ST    R6,S99TXTPP            and put it int the request block.\n         LA    R7,TU@___DDNAM      Address the text unit\n         MVI   S99TUKEY+1,DUNDDNAM    to use 'unallocate' as the key.\n         SPACE 1\n         LA    R1,S99_PLIST        Get the plist address.\n      DYNALLOC\n         LTR   R15,R15\n         BNZ   DYN_ERROR\n         B     FREED\nCOPY@DD  DS    0H\n         LH    R2,CONCAT_COUNT\n         BCTR  R2,0\n         STH   R2,CONCAT_COUNT\n         LA    R7,DSN_LIST         Address the DALDDNAM and\n         LA    R6,TU@DALSTATS         DALSTATS text units to\n         STM   R6,R7,BUILD_TUPL          start the TUPL list.\n         MVC   TU@___DDNAM+S99TULNG-S99TUNIT(10),S99TULNG\n         LH    R14,S99TULNG        Calculate\n         LA    R7,7(R14,R7)           address of DALDSNAM text unit\n         SRL   R7,1                       rounded up\n         SLL   R7,1                          to a halfword.\n         B     JUMP_IN             Jump into the middle of the logic.\nFREED    DS    0H\n*\n* Allocate the first dataset within the concatenation.\n* We use the real DDNAME for this;\n*\n         MVI   S99TUKEY+1-S99TUNIT+TU@___DDNAM,DALDDNAM\n         MVC   BUILD_TUPL(2*4),DAL_TUPL  Get the 1st 2 TU addresses.\n         LA    R7,DSN_LIST         Top of the list.\nJUMP_IN  DS    0H\n         LA    R2,S99_RB           Address the request block\n         MVI   S99VERB,S99VRBAL       and set its 'verb'.\n         LA    R6,BUILD_TUPL       Address the text unit parameter list\n         ST    R6,S99TXTPP            and put it in the request block.\n         LA    R6,2*4(,R6)         Point to next available TUPL cell\n         ST    R7,S99TUPTR            and put A(DSN TU) there.\n         LR    R15,R7              Convenient for compare @ next TU.\n         LH    R14,S99TULNG        Calculate\n         LA    R7,7(R14,R7)           address of next TU\n         SRL   R7,1                       rounded up\n         SLL   R7,1                          to a halfword.\n         CLC   S99TUKEY,0(R15)     Next TU also for a DSN?\n         BE    NO_MEM1                -yes-   TU doesn't belong here.\n         LA    R6,4(,R6)           Point to next available TUPL cell\n         ST    R7,S99TUPTR            and put A(mem TU) there.\n         LH    R14,S99TULNG        Calculate\n         LA    R7,7(R14,R7)           address of next TU\n         SRL   R7,1                       rounded up\n         SLL   R7,1                          to a halfword.\nNO_MEM1  DS    0H\n         OI    S99TUPTR,S99TUPLN   Indicate end of TUPL.\n         LA    R1,S99_PLIST        Get the plist address.\n      DYNALLOC\n         LTR   R15,R15\n         BNZ   DYN_ERROR\n         LH    R10,CONCAT_COUNT\n         LTR   R10,R10\n         BZ    DONE_IT\n*\n* Allocate the datasets which require concatenation.\n* Ask the system to assign and return an available ddname.\n*\n         LA    R0,TU@DALRTDDN\n         ST    R0,BUILD_TUPL+1*4\n         LA    R9,DD_LIST\nALLOC_LOOP DS  0H\n         LA    R6,BUILD_TUPL+2*4   Point to available TUPL cell\n         ST    R7,S99TUPTR            and put A(DSN TU) there.\n         LR    R15,R7              Convenient for compare @ next TU.\n         LH    R14,S99TULNG        Calculate\n         LA    R7,7(R14,R7)           address of next TU\n         SRL   R7,1                       rounded up\n         SLL   R7,1                          to a halfword.\n         CLC   S99TUKEY,0(R15)     Next TU also for a DSN?\n         BE    NO_MEM2                -yes-   TU doesn't belong here.\n         LA    R6,4(,R6)           Point to next available TUPL cell\n         ST    R7,S99TUPTR            and put A(mem TU) there.\n         LH    R14,S99TULNG        Calculate\n         LA    R7,7(R14,R7)           address of next TU\n         SRL   R7,1                       rounded up\n         SLL   R7,1                          to a halfword.\nNO_MEM2  DS    0H\n         OI    S99TUPTR,S99TUPLN   Indicate end of TUPL.\n         LA    R1,S99_PLIST        Get the plist address.\n      DYNALLOC\n         LTR   R15,R15\n         BNZ   DYN_ERROR\n         MVI   TU@DALRTDDN+5,X'08' Force the length of DDname\n         MVC   0(10,R9),TU@DALRTDDN+4  Pick-up the assignment.\n         LA    R9,10(,R9)          Next one goes here.\n         BCT   R10,ALLOC_LOOP      Count and loop.\n         SPACE 2\n         MVI   S99VERB,S99VRBCC    Set for concatenation.\n         LA    R7,DD_LIST-14       Use a\n         MVC   S99TUNIT(14),TU@___DDNAM  copy of the general DDNAM TU\n         MVI   S99TULNG+L'S99TULNG-1,X'08'\n         MVI   S99TUKEY+1,DCCDDNAM          with required key set.\n         LH    R1,CONCAT_COUNT     Pick-up the concatenation count\n         LA    R1,1(,R1)              make it relative to zero for\n         STH   R1,S99TUNUM               the number of DD's.\n         ST    R7,BUILD_TUPL       (Re)build\n         LA    R7,TU@DCCPERMC         a two\n         ST    R7,BUILD_TUPL+4           text unit\n         OI    BUILD_TUPL+4,S99TUPLN        parm list.\n         LA    R1,S99_PLIST        Get the plist address.\n      DYNALLOC\n         LTR   R15,R15\n         BNZ   DYN_ERROR\nDONE_IT  DS    0H\n         MVI   EVALBLOCK_EVDATA,C'1'\nRC@0     DS    0H\n         SR    R15,R15\n         CVD   R15,DBLWD\n         B     R15_RC\nONE_FREE DS    0H\n         LA    R2,S99_RB           Address the request block\n         MVI   S99VERB,S99VRBUN       and set its 'verb'.\n         LA    R6,FREE_TUPL        Address the text unit parameter list\n         ST    R6,S99TXTPP            and put it int the request block.\n         SPACE 1\n         LA    R1,S99_PLIST        Get the plist address.\n      DYNALLOC\n         LTR   R15,R15\n         BNZ   DYN_ERROR\n         B     DONE_IT\n         SPACE 3\nMULTI_FREE  DS 0H\n         LA    R0,8                Maximum length for TRT instruction.\n         LR    R5,R4               Calculate\n         SR    R5,R3                  residual length\n         CR    R5,R0               Residual > maximum?\n         BNH   *+6                    -no -\n         LR    R5,R0                  -yes-  Use the maximum\n         LA    R1,1(,R4)           Pre-set R1 in case there is no hit.\n         EX    R5,TRT_ARG          Find the delimiting blank.\n         LR    R0,R1               Hang on to the delimit address.\n         SR    R1,R3               Calculate the length of ddname,\n         STH   R1,S99TULNG            save it and\n         BCTR  R1,0                      make it an instruction length\n         EX    R1,MVC_TU                    to move the ddname.\n         LR    R3,R0               Set the scanned-to address\n         LA    R2,S99_RB           Address the request block\n         MVI   S99VERB,S99VRBUN       and set its 'verb'.\n         LA    R6,FREE_TUPL        Address the text unit parameter list\n         ST    R6,S99TXTPP            and put it int the request block.\n         SPACE 1\n         LA    R1,S99_PLIST        Get the plist address.\n      DYNALLOC\n         LTR   R15,R15\n         BNZ   *+8\n         MVI   EVALBLOCK_EVDATA,C'1'\n         CR    R3,R4               All scanned?\n         BNL   RC@0                   -yes-\n         TRT   0(256,R3),TRTABLE   Find a non-blank\n         LR    R3,R1               Set the 'scanned-to' address.\n         B     MULTI_FREE          Go process another ddname.\n         TITLE            '<< REXX - Dynamic dataset allocation        X\n                            Allocate to a member of an allocated DD >>'\nALLOC_MEM  DS  0H\n         TM    DD_SW,ALLOCATED     Did we find the DD?\n         BZ    NO_DD4MEM              -no -\n         LA    R2,S99_RB           Address the DYNALLOC request block.\n         MVI   S99VERB,S99VRBAL    Set the vert to allocate.\n         LA    R6,BUILD_TUPL       Address the TUPL work area and\n         ST    R6,S99TXTPP            put it into the request block.\n         LA    R7,DSN_LIST         Address the\n         ST    R7,S99TUPTR            first text unit.\n         LH    R1,S99TULNG         Address\n         LA    R7,7(R1,R7)            the\n         SRL   R7,1                      second (i.e. DSN)\n         SLL   R7,1                         text\n         ST    R7,S99TUPTR+4                   unit.\n         LH    R1,S99TULNG         Address\n         LA    R7,7(R1,R7)            the\n         SRL   R7,1                      third\n         SLL   R7,1                         text\n         ST    R7,S99TUPTR+8                   unit and\n         MVC   0(14,R7),TU@DALRTDDN               put a text unit there\n         LR    R0,R7               Preserve the address of the 3rd TU.\n         LA    R7,14(,R7)          Address the\n         ST    R7,S99TUPTR+12         fourth text unit area\n         MVC   0(7,R7),TU@DALSTATS       and fill in that text unit.\n         LR    R7,R0               3rd text unit required post DYNALLOC\n         OI    S99TUPTR+12,S99TUPLN  Close the TUPL list.\n         LA    R1,S99_PLIST        Get the plist address.\n      DYNALLOC\n         LTR   R15,R15\n         BNZ   DYN_ERROR\n         MVC   EVALBLOCK_EVDATA(8),S99TUPAR\n         MVI   EVALBLOCK_EVLEN+3,X'08'\n         B     RC@0\n         SPACE 3\n         DROP  R5\n         USING IRXEXTE,R9\n         USING ENVBLOCK,R8\n         TITLE            '<< REXX - Dynamic dataset allocation        X\n                Assign the value from the record to a REXX variable >>'\n*\n* Refer to the IRXEXCOM routine; pages 312-319 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\n         SPACE 1\nPLIST_EXCOM DC A(EXCOM_LIT,0,0)\n         DC    A(@SHV+X'80000000')\n         SPACE 1\n@SHV     DS    0A\n         DC    2A(0)\n         DC    C'S'\n         DS    XL3'000000'\n         DC    5A(0)\n         SPACE 1\nEXCOM_LIT DC   CL8'IRXEXCOM'\n         SPACE 3\nASSIGN_VAR  DS  0H\n         L     R15,IRXEXCOM        Get routine's address from vector.\n         LA    R1,PLIST_EXCOM\n         LA    R0,ENVBLOCK         Make sure REXX knows environment.\n         BALR  R14,R15\n         B     RTNXT\n*\n* Alternative to variable name assignment is to STACK the value.\n*\n* Refer to the IRXSTK   routine; pages 485-490 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\nSTK_FUNC DC    CL8'QUEUE   '\nSTK_PLIST  DC  A(STK_FUNC)\n         DC    A(SHVVALA-SHVBLOCK+@SHV)\n         DC    A(SHVVALL-SHVBLOCK+@SHV)\n         DC    A(RC+X'80000000')\n         ORG   ASSIGN_VAR      Overlay that code. It does not get used.\n         TITLE            '<< REXX - Dynamic dataset allocation        X\n                     Subroutine to Strip Leading && Trailing Blanks >>'\n         USING ARGTABLE_ENTRY,R10\n* Registers upon entry\n*    R10 ==> argument table entry\n*    R14 ==> exit address when agrument is null\n*    R14+4=> normal exit\n*\n* Registers upon exit\n*    R10 ==> next argument table entry.\n*    R2    = 0 (zero)\n*    R3  ==> leftmost non-blank byte of argument\n*    R4  ==> rightmost non-blank byte of argument\n*    R15   = R4 - R3 (length of argument minus 1)\n         SPACE 2\nTRT3     TRT   0(0,R3),TRTABLE\nHEXFF    DC    X'FFFFFFFFFFFFFFFF'\n         DS    XL1\nTRTABLE  DS    XL256\n         SPACE 2\nSTRIP    DS    0H\n         CLC   HEXFF,ARGTABLE_ARGSTRING_PTR  Is there an argument?\n         BER   R14                              -no -\n         L     R15,ARGTABLE_ARGSTRING_LENGTH\n         L     R3,ARGTABLE_ARGSTRING_PTR  Get address of argument.\n         LA    R10,ARGTABLE_NEXT   Point to next argument table entry.\n         SPACE 1\n         LTR   R15,R15             Does the argument have any length?\n         BZR   R14                    -NO - take abnormal exit.\n         LA    R4,0(R15,R3)        Point just beyond ARG.\n         MVC   TRTABLE,TRTABLE-1   Set to\n         MVI   TRTABLE+C' ',X'00'     bypass blanks.\n         BCTR  R15,0               Set length for TRT instruction.\n         EX    R15,TRT3            Skip to non-blank.\n         BZR   R14                 When all blank.\n         LR    R3,R1               Re-set starting address.\nSTRIP@R  DS    0H\n         BCTR  R4,0                Backpedal 1 byte.\n         CLI   0(R4),X'40'         (still) at a blanK?\n         BNE   STRIPPED               -no -\n         CR    R4,R3                  -yes-  More to inspect?\n         BH    STRIP@R                          -yes-\nSTRIPPED DS    0H\n         LR    R15,R4              Calculate\n         SR    R15,R3                 length of ARG - 1.\n         SR    R2,R2               Pre-clear R2 for TRT\n         BC    15,4(,R14)          Take normal exit.\n         TITLE            '<< REXX - Dynamic dataset allocation        X\n                                                Errors and messgaes >>'\n*\n* Refer to the IRXSAY   routine; pages 336-339 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\nSAY_LIT        DC    CL8'WRITE   '\nSAY_BUFF       DS    A\nSAY_LEN        DS    F\nSAY_PLIST      DC    A(SAY_LIT,SAY_BUFF,SAY_LEN+X'80000000')\nMISSING_DDNAME_MSG DC  C'First argument (DDNAME) missing.'\nNO_DD4MEM_MSG  DC    C'Requested DDNAME is not allocated.'\nDSN_ERROR_MSG      DC  C'Invalid dataset name construct.'\nL_O_MSG  DC    C'       failed for '\nL_O_LEN  EQU   *-L_O_MSG+44\nDYN_MSG  DC    C'DYNALLOC error. R15='\nDYN_R15  DS    CL8\n         DC    C' Verb='\nDYN_VERB DS    CL2\n         DC    C' Flag1='\nDYN_FLAG DS    CL4\n         DC    C' Error code='\nDYN_EC   DS    CL4\n         DC    C'     '\nDYN_MSG_L  EQU *-DYN_MSG\n         SPACE 1\nTU_MSG   DC    C'      Text unit Key='\nTU_KEY   DS    CL4\n         DC    C' count='\nTU_COUNT DS    CL4\n         DC    C' length='\nTU_LENGTH DS   CL4\n         DC    C' '\nTU_MSG_L EQU   *-TU_MSG+1\n         SPACE 1\nTU_DATA  DS    CL44\n         SPACE 3\nDYN_ERROR  DS  0H\n         CVD   R15,DBLWD\n         ST    R15,RC\n         UNPK  WORKAREA(9),RC(5)\n         LA    R2,S99_RB\n         UNPK  WORKAREA+8(15),S99RB+1(8)\n         TR    WORKAREA(18),HEX_TR-C'0'\n         MVC   DYN_R15,WORKAREA\n         MVC   DYN_VERB,WORKAREA+8\n         MVC   DYN_FLAG,WORKAREA+10\n         MVC   DYN_EC,WORKAREA+14\n         MVC   DYN_EC+5,WORKAREA+18\n         L     R9,ENVBLOCK_IRXEXTE Make sure we have REXX vector table.\n         LA    R0,DYN_MSG\n         ST    R0,SAY_BUFF\n         LA    R0,DYN_MSG_L\n         ST    R0,SAY_LEN\n         LA    R0,ENVBLOCK\n         LA    R1,SAY_PLIST\n         L     R15,IRXSAY\n         BALR  R14,R15\n         L     R6,S99TXTPP\nTU_MSG_LOOP DS 0H\n         L     R7,S99TUPTR\n         UNPK  WORKAREA(13),S99TUNIT(7)\n         TR    WORKAREA(12),HEX_TR-C'0'\n         MVC   TU_KEY,WORKAREA\n         MVC   TU_COUNT,WORKAREA+4\n         MVC   TU_LENGTH,WORKAREA+8\n         LH    R15,S99TULNG\n         BCTR  R15,0\n         EX    R15,MVC_TUPAR\n         LA    R15,TU_MSG_L(,R15)\n         LR    R0,R15\n         LA    R15,TU_MSG\n         TM    S99TUPL,S99TUPLN\n         BO    R15_RC\n         ST    R15,SAY_BUFF\n         ST    R0,SAY_LEN\n         LA    R0,ENVBLOCK\n         LA    R1,SAY_PLIST\n         L     R15,IRXSAY\n         BALR  R14,R15\n         LA    R6,4(,R6)\n         B     TU_MSG_LOOP\nLOCATE_ERROR   DS    0H\n         MVC   L_O_MSG(6),=C'LOCATE'\n         B     OBTAIN_ERROR+6\n         SPACE 1\nOBTAIN_ERROR   DS    0H\n         MVC   L_O_MSG(6),=C'OBTAIN'\n         SPACE 1\n         CVD   R15,DBLWD\n         L     R15,LOCATE@DSN\n         LA    R0,L'L_O_MSG\n         SR    R15,R0\n         MVC   0(L'L_O_MSG,R15),L_O_MSG\n         LA    R0,L_O_LEN\nR15_RC   DS    0H\n         ST    R15,SAY_BUFF\n         ST    R0,SAY_LEN\n         L     R9,ENVBLOCK_IRXEXTE Make sure we have REXX vector table.\n         LA    R0,RC_LIT\n         ST    R0,SHVNAMA-SHVBLOCK+@SHV\n         LA    R0,2\n         ST    R0,SHVNAML-SHVBLOCK+@SHV\n         OI    DBLWD+7,X'0F'\n         UNPK  WORKAREA(5),DBLWD+5(3)\n         LA    R1,WORKAREA\n         ST    R1,SHVVALA-SHVBLOCK+@SHV\n         LA    R2,4\n         LA    R3,*+4\n         CLI   0(R1),C'0'\n         BNE   *+10\n         LA    R1,1(,R1)\n         BCTR  R2,R3\n         LA    R2,1(,R2)\n         ST    R2,SHVVALL-SHVBLOCK+@SHV\n         MVC   WORKAREA(5),0(R1)\n         L     R15,IRXEXCOM        Get routine's address from vector.\n         LA    R1,PLIST_EXCOM\n         LA    R0,ENVBLOCK         Make sure REXX knows environment.\n         BALR  R14,R15\n         CLI   WORKAREA,C'0'\n         BE    RTNXT\n         B     CALL@SAY\n         SPACE 2\nNO_DD4MEM DS   0H\n         LA    R15,NO_DD4MEM_MSG\n         LA    R0,L'NO_DD4MEM_MSG\n         B     SAY_CALL\n         SPACE 2\nDSN_ERROR DS         0H\n         LA    R15,DSN_ERROR_MSG\n         LA    R0,L'DSN_ERROR_MSG\n         B     SAY_CALL\n         SPACE 2\nMISSING_DDNAME DS    0H\n         LA    R15,MISSING_DDNAME_MSG\n         LA    R0,L'MISSING_DDNAME_MSG\n         B     SAY_CALL\nSAY_CALL DS    0H\n         ST    R15,SAY_BUFF\n         ST    R0,SAY_LEN\n         L     R9,ENVBLOCK_IRXEXTE Make sure we have REXX vector table.\nCALL@SAY DS    0H\n         LA    R0,ENVBLOCK\n         LA    R1,SAY_PLIST\n         L     R15,IRXSAY\n         BALR  R14,R15\n         LR    R2,R13\n         L     R13,SAVEAREA+4\n         LA    R0,WORKLEN\n      FREEMAIN R,LV=(R0),A=(R2)\n         XC    8(4,R13),8(R13)\n         LM    R14,R12,12(R13)\n         LA    R15,40\n         BR    R14\n         TITLE            '<< REXX - Dynamic dataset allocation        X\n                                              Global Data Constants >>'\n         SPACE 2\n         DS    0F\nS99_PLIST  DC  AL4(X'80000000'+S99_RB)\n         SPACE 1\nS99_RB   DC    AL1(S99RBEND-S99RB)\n         DC    AL1(S99VRBUN)\n         DC    AL1(S99NOMNT),AL1(0)\n         DC    2AL2(0)\n         DC    A(FREE_TUPL),2A(0)\n*\n*  Text Unit Pointers\n*\n          DS   0F\nFREE_TUPL DC   AL4(0,X'80000000'+TU@DUNUNALC)\n         SPACE 1\nDAL_TUPL DC    A(TU@DALSTATS,0)\n         SPACE 1\nCONC_TUPL DC   AL4(0,X'80000000'+TU@DCCPERMC)\n*\n*  ALLOCATE Text Units\n*\n         DS    0F\n* @DALDSNAM  DC  AL2(DALDDNAM),AL2(1),AL2(0),CL44' '\n* @DALMEMBR  DC  AL2(DALMEMBR),AL2(1),AL2(0),CL8' '\nTU@DALSTATS  DC  AL2(DALSTATS),AL2(1),AL2(1),X'08'\n* @DALNDISP  DC  AL2(DALNDISP),AL2(1),AL2(1),X'08'\n* @DALCDISP  DC  AL2(DALCDISP),AL2(1),AL2(1),X'08'\nTU@DALRTDDN  DC  AL2(DALRTDDN),AL2(1),AL2(8),CL8' '\n*\n*  FREE Text Units\n*\n         DS    0F\nTU@DUNUNALC  DC  AL2(DUNUNALC),AL2(0)\n*\n*  CONCATenate Text Units\n*\n         DS    0F\nTU@DCCPERMC  DC  AL2(DCCPERMC),AL2(0)\n         SPACE 2\nRC_LIT   DC    C'RC'\n         SPACE 2\nHEX_TR   DC    10AL1(*-HEX_TR+C'0')\n         DC    5AL1(*-10-HEX_TR+C'A')\n         SPACE 2\nMVC_TU   MVC   S99TUPAR(0),0(R3)\nMVC_TUPAR MVC  TU_DATA(0),S99TUPAR\nTRT_ARG  TRT   0(0,R3),TRTDSN\nTRT_GDG  TRT   1(0,R14),TRTDSN\n         SPACE 2\n         LTORG\n         TITLE            '<< REXX - Dynamic dataset allocation        X\n                                                 DSECTs and EQUates >>'\nGET_MAIN DSECT\nSAVEAREA DS    18F\nDBLWD    DS    D\n         SPACE 1\nLOCATE_OBTAIN  DS  0XL32\nLOCATE_PLIST   DS  A\nLOCATE@DSN     DS  A\n               DS  A\nLOCATE@WORK    DS  A\n         SPACE 1\nOBTAIN_PLIST   DS  A\nOBTAIN@DSN     DS  A\nOBTAIN@VOLSER  DS  A\nOBTAIN@WORK    DS  A\n         SPACE 2\nBUILD_TUPL  DS 8A\n         DS    0F\nTU@___DDNAM  DS  3AL2\nDDNAME   DS    CL8                 DDNAME definition is part of TU.\n         SPACE 2\nVOLSER   DS    CL6\n         SPACE 2\nCONCAT_COUNT   DS    H\n         SPACE 2\nDSN_LIST DS    16XL60\n         SPACE 1\nDD_LIST  DS    16XL10\n         SPACE 1\nTRTDSN   DS    XL256\n         SPACE 1\nDD_SW          DS    XL1\nNULL           EQU   X'00'\nCONCAT_FORCE   EQU   X'01'\n@MEMBER        EQU   X'02'         Allocate a member member name.\nFREE_FORCE     EQU   X'04'         FREE was requested.\nCONDITIONAL    EQU   X'08'         Allocate only if not pre-alloacted.\nCOPY_DD        EQU   X'10'         Copy a DD allocation.\n@VIO           EQU   X'20'         Do not LOCATE/OBTAIN (for VIO).\nALLOCATED      EQU   X'40'         DD was pre-alloacted.\n         SPACE 1\n         DS    0D\nWORKAREA DS    0XL265\n         DS    AL2\nDEV_CODE DS    XL4\nWA_VOLSER  DS  CL6\n         DS    XL(265-12)\n         DS    D\nWORKLEN  EQU   *-GET_MAIN\n         SPACE 2\n         PRINT NOGEN\n         YREGS\n         SPACE 2\n       IRXENVB\n         SPACE 2\n       IRXEXTE\n         SPACE 2\n       IRXSHVB\n         SPACE 2\n       IRXEFPL\n         SPACE 2\n      IRXARGTB\n         SPACE 2\n      IRXEVALB\n         PRINT GEN\n      IEFZB4D0\n         SPACE 2\n      IEFZB4D2\n         SPACE 2\n         PRINT NOGEN\n        IHAPSA\n         SPACE 2\n        IKJTCB\n         SPACE 2\n      IEFTIOT1\n         SPACE 2\n      IEFJFCBN\n         SPACE 2\n         END  SCCALLOC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCCPDSD": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x15\\x7f\\x01\\x01\\x15\\x7f\\x14A\\x05\\x00\\x05\\x00\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-06T00:00:00", "modifydate": "2001-06-06T14:41:00", "lines": 1280, "newlines": 1280, "modlines": 0, "user": "PST0705"}, "text": "./ ADD NAME=HELP     0100-01157-01157-1131-00054-00054-00000-PST0705\n Name:        SCCPDSD\n\n Purpose:     Obtain selected directory entries from the specified\n              DDname into a stemmed variable or into the data stack.\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              SCCD2O resides in the IRXFLOC \"function package\".\n\n\n Arguments:\n           1. The DDname of the library. If the same DDname is to\n              be used by SCCPDSR, currently only three values\n              are allowed namely PDS1, PDS2, and PDS3. (Removal of\n              this limitation is the planned enhancement.)\n\n              The DDname must be pre-allocated to the library. That\n              allocation must not be done at the member level.\n\n           2. The selection criteria. The criteria is composed of\n              natural characters and/or the 'wildcard' values\n              '*' and '%'\n\n              Refer to the WILDCARD function for details of how this\n              criteria may be used.\n\n           3. The name of the REXX stem variable to receive the\n              directory entries.  The caller must ensure this\n              specification is enclosed within quotes.\n\n              If argument 3 is not specified (or specified as null),\n              the directory entries are placed in the data stack.\n\n\n Results: (when 'stem.' is specified at argument 3)\n              'stem.0' contains a count of the number of directory\n              entries.\n\n              'stem.1' through 'stem.stem.0' contains the individual\n              directory entries.\n\n          (when argument 3 is null):\n              The data stack contains directory entries read in FIFO\n              order.\n\n          (independent of argument 3)\n              As a REXX subroutine/function SCCPDSD must return a result\n              to the caller. SCCPDSD returns the number (relative to 0)\n              of datasets concatenated within the DDname.\n\n\n Notes:       Choice of a technique to manage the 'data stack' is a\n              subjective matter. SCCPDSD makes no choice. If the REXX\n              program requires stack isolation, the programmer must\n              use an appropriate technique.\n./ ADD NAME=ID       0102-98050-98050-1606-00049-00046-00000-PST0705\n         MACRO\n&LABEL   ID    &USING,&CSECT=YES,&AMODE=31,&RMODE=ANY\n         LCLC  &U,&LBL\n.*\n.* Stelco macro used to:\n.*    - generate the CSECT statement.\n.*    - generate the USING, AMODE and RMODE statements for the CSECT.\n.*    - generate an eye-catcher and date/time stamp (28 bytes total).\n.*      (The values for date and time are the time of the Assembly.)\n.*\n.* The default for the USING statement is (register) 15.\n.* Other defaults are as per the prototype above.\n.*\n.* If the CSECT requires multiple base registers, their specification\n.* must be enclosed in parenthesis.       e.g.  BIGRTN   ID     (12,11)\n.*\n.* This macro can also be used to generate only the eye-catcher and\n.* date/time stamp. For this type of usage specify   ID    ,CSECT=NO\n.*\n.* -----------------------Modification History-------------------------\n.* 98-02-19 change from &SYSDATE to &SYSDATC\n.*\n&U       SETC  '15'\n&LBL     SETC  ' '\n         AIF   (K'&LABEL EQ 0).LBLSET\n&LBL     SETC  '&LABEL'\n.LBLSET  ANOP\n         AIF   (T'&USING EQ 'O').USET\n         AIF   ('&USING'(1,1) NE '(').ONEUSE\n&U       SETC  '&USING'(2,K'&USING-2)\n         AGO   .USET\n.ONEUSE  ANOP\n&U       SETC  '&USING'\n.USET    ANOP\n         AIF   ('&CSECT' EQ 'YES').CSECT\n&LBL     DS    0H\n         B     *+32\n         AGO   .STAMP\n.CSECT   ANOP\n&LBL     CSECT\n&LBL     AMODE &AMODE\n&LBL     RMODE &RMODE\n         USING &LABEL,&U\n         BC    15,32(,15)\n.STAMP   ANOP\n         DS    CL4\n         DC    CL8'&LBL'\n         DC    CL16'&SYSDATC &SYSTIME'\n         MEND\n./ ADD NAME=SCCPDSD  0139-95181-01019-1445-00456-00355-00000-PST0705\nPDSD     TITLE            '<< REXX - Get PDS directory entry           X\n                                                      Documentation >>'\n* Name:        SCCPDSD\n*\n* Purpose:     Select the directory entries of a specified\n*              partitioned dataset via (Assembler) subroutine STSS383.\n*\n* Environment: REXX subroutine/function for Address TSO or MVS\n*\n* Features:    STSS383 supports 'wildcard' selection criteria for the\n*              directory entries via (Assembler) subroutine SCCWC001\n*\n*              The caller access the directory entries through either:\n*                 - a \"stemmed\" variable\n*                 - the \"data stack\"\n*\n* Parameters:  1. The DDNAME which refers to the partitioned dataset.\n*\n*              2. The member selection criteria. This parameter\n*                 supports the 'wildcard' values of '*' (asterisk)\n*                 and '%' (percent sign). Refer to subroutine\n*                 SCCWC001 for more information on these wild\n*                 cards.\n*\n*              3. (optional) The name of the stem variable which\n*                 will be assigned the values from the record. If the\n*                 caller does not delimit the stem with a period,\n*                 one is generated.\n*\n*                 The REXX programmer should ensure that the value\n*                 specified for the call is enclosed in quotes.\n*\n*                 stem.0 is assigned the value of the number of\n*                 records read.\n*\n*                 If parameter 3 is not specified or specified as null,\n*                 SCCPDSD places the records in the data stack.\n* Notes:\n*\n*    There are mutually exclusive techniques to handle the data stack.\n*    Since the choice of a technique is subjective, SCCPDSD makes no\n*    choice. If stack isolation is required, an appropriate technique\n*    is the responsibilty of the callin program.\n*\n         TITLE            '<< REXX - Get PDS directory entry           X\n                                                     System Linkage >>'\nSCCPDSD  ID    R12\n         SPACE 2\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         ST    R13,SAVEAREA+4\n         LA    R15,SAVEAREA\n         ST    R15,8(,R13)\n         LR    R13,R15\n         XC    RC,RC\n         B     MAINLINE\n         SPACE 3\nRC       DS    0F\n         DS    AL1\nRC1      DS    AL1\nRC2      DS    AL1\nRC3      DS    AL1\n         SPACE 1\nSAVEAREA DS    18F\n         SPACE 3\nRTNXT    DS    0H\n         L     R13,SAVEAREA+4\n         XC    8(4,R13),8(R13)\n         XC    16(4,R13),16(R13)   R15 (return code) always\n         LM    R14,R12,12(R13)        get set to zero.\n         BR    R14\n         TITLE            '<< REXX - Get PDS directory entry           X\n                                                Parse the Arguments >>'\nMAINLINE DS    0H\n         USING EFPL,R1\n         USING ENVBLOCK,R8\n         USING IRXEXTE,R9\n         USING EVALBLOCK,R11\n         USING SHVBLOCK,R14\n         LR    R8,R0               Address the environment block.\n         L     R9,ENVBLOCK_IRXEXTE Address the REXX vector table.\n         LM    R10,R11,EFPLARG     Address ARGTABLE & EVALBLOCK.\n         L     R11,0(,R11)\n         LM    R14,R0,SET_REGS-12\n         STM   R14,R0,SET_REGS\n         MVI   DDNAME,C' '\n         MVC   DDNAME+1(L'DDNAME+L'MEM_NAME-1),DDNAME\n         XC    SHVNAMA-SHVBLOCK+@SHV,SHVNAMA-SHVBLOCK+@SHV\n         MVI   TRTABLE-1,X'FF'     Pre-set table value.\n         NI    PLIST383,X'7F'      More than one parm for STSS383.\n*        WTO   'SCCPDSD started.'\n         BAL   R14,STRIP           Strip out arg(1).\n         B     MISSING_DD          Arg(1) not specified.\n         LA    R0,7                Maximum length.\n         CR    R15,R0              Length(arg(1)) > maximum ?\n         BNH   *+6                    -no -\n         LR    R15,R0                 -yes-   Use maximum\n         EX    R15,MVC_DD          Pick-up the DDname.\n         SPACE 1\n         BAL   R14,STRIP           Strip out arg(2).\n         B     MISSING_MEM         Arg(2) not specified\n         LA    R0,7                Maximum length.\n         CR    R15,R0              Length(arg(2)) > maximum ?\n         BNH   *+6                    -no -\n         LR    R15,R0                 -yes-   Use maximum\n         EX    R15,MVC_MEM         Pick-up the member name.\n         LA    R15,1(,R15)\n         ST    R15,SELECT_LEN\n         MVC   NON_WILD,MEM_NAME\n         TR    NON_WILD,NON_WILD_TR\n         BAL   R14,STRIP           Strip out arg(3).\n         B     MISSING_STEM        Arg(3) not specified\n         LA    R0,244              Maximum length of variable stem.\n         SR    R0,R15              Calculate\n         LA    R2,VAR_NAME            address where\n         AR    R2,R0                     stem will be stored.\n         CLI   0(R4),C'.'          Does stem end with period?\n         BE    *+10                   -yes-\n         BCTR  R2,0                   -no -   adjust address and\n         MVI   TAIL-1,C'.'                       provide the period.\n         EX    R15,MVC_STEM        Pick-up the stem name.\n         ST    R2,SHVNAMA-SHVBLOCK+@SHV   Variable name addr into SHVB.\n         LA    R0,TAIL+1           Include one digit of 'tail'\n         SR    R0,R2                  in the qualified\n         ST    R0,SHVNAML-SHVBLOCK+@SHV  variable name length.\n         SPACE 1\nMISSING_STEM   DS    0H\n         TITLE            '<< REXX - Get PDS directory entry           X\n                      Call STSS383 and determine method of disposal >>'\n         XC    ADRCTRY,ADRCTRY     Pre-set STSS383's result to zero.\n         LA    R1,PLIST383         Parameter list.\n         L     R15,VSTSS383        Entry point address.\n         BALR  R14,R15             Call.\n         L     R10,ADRCTRY         Address STSS383's result.\n         LTR   R10,R10             Did STSS383 set the address?\n         BZ    @383_FAILED            -no -\n         USING DRCTPREF,R10\n         LH    R0,DRCTCON          Number of concatenation levels\n         CVD   R0,DBLWD               into\n         OI    DBLWD+7,X'0F'             ebcdic\n         UNPK  EVALBLOCK_EVDATA(3),DBLWD+6(2)  format.\n         LA    R0,3                Let\n         ST    R0,EVALBLOCK_EVLEN     REXX know the length of data.\n         DROP  R11                 Done addressing EVALBLOCK.\n         LH    R11,DRCTCNT         Get the number of directory entries.\n         LTR   R11,R11             Empty PDS?\n         BZ    DO_STEM0               -yes-\n         LA    R10,DRCTNTRY        Address the first directory entry.\n         B     MATCH_ENTRY\n         DROP  R10\n         USING DRCTNTRY,R10\nNEXT_ENTRY DS  0H\n         BCT   R11,*+8\n         B     DO_STEM0\n         SR    R1,R1               Clear a register to\n         IC    R1,MEMLEN              pick-up number of member halfwd.\n         LA    R0,31               B'00011111' zero out bits 0,1,2\n         NR    R1,R0                  of byte 3 within register.\n         SLL   R1,1                Half words to bytes.\n         LA    R10,14(R1,R10)      Address the next entry.\nMATCH_ENTRY DS 0H\n         ST    R10,PLIST_WC001+8   Address of SCCWC001 'target'.\n         LA    R1,PLIST_WC001      Call\n         L     R15,VWC001             ...\n         BALR  R14,R15                   SCCWC001\n         BE    STEM_OR_STACK       Matched.\n         CLC   NON_WILD,MEMNAME    Beyond matching?\n         BNL   NEXT_ENTRY             -not yet-\nDO_STEM0 DS    0H\n*        WTO   'SCCPDSD after last CALL SCCWC001.'\n         LA    R1,PLIST383\n         OI    PLIST383,X'80'      One parm for STSS383.\n         L     R15,VSTSS383        Entry point address.\n         BALR  R14,R15             Call to free areas.\n*        WTO   'SCCPDSD after last CALL STSS383.'\n         L     R2,SHVNAMA-SHVBLOCK+@SHV  Address of variable name.\n         LTR   R2,R2               Did caller specify a stem variable?\n         BZ    RTNXT                  -no -   Go stack the entries.\n         MVI   TAIL,C'0'           Will be setting stem.0\n         LA    R0,TAIL+1           Calculate\n         SR    R0,R2                  length of variable name and\n         ST    R0,SHVNAML-SHVBLOCK+@SHV  tell EXCOM about it.\n         L     R0,SET_REGS         Get the record count\n         CVD   R0,DBLWD               into a\n         UNPK  NON_WILD(5),DBLWD+5(3)    ebcidic\n         OI    NON_WILD+4,X'F0'             format.\n         LA    R1,NON_WILD         Leftmost byte of variable value.\n         LA    R2,4                Maximum loop counter.\n         LA    R15,*+4             Top-of-loop address.\n         CLI   0(R1),C'0'          Insignificant zero?\n         BNE   *+10                   -no -\n         LA    R1,1(,R1)           Next byte.\n         BCTR  R2,R15              Count and loop.\n         SPACE 1\n         LA    R2,1(,R2)           Residual of loop-counter plus 1\n         ST    R2,SHVVALL-SHVBLOCK+@SHV equals the length of the value.\n         ST    R1,SHVVALA-SHVBLOCK+@SHV  EXCOM finds the value there.\n         L     R15,IRXEXCOM        Get routine's address from vector.\n         LA    R0,ENVBLOCK         Make sure REXX knows environment.\n         LA    R1,PLIST_EXCOM\n         BALR  R14,R15\n         B     RTNXT\nSTEM_OR_STACK  DS    0H\n         SR    R1,R1               Clear a register to\n         IC    R1,MEMLEN              pick-up number of member halfwd.\n         LA    R0,31               B'00011111' zero out bits 0,1,2\n         NR    R1,R0                  of byte 3 within register.\n         SLL   R1,1                Half words to bytes\n         LA    R1,14(,R1)             plus minimum length.\n         ST    R1,SHVVALL-SHVBLOCK+@SHV\n         ST    R10,SHVVALA-SHVBLOCK+@SHV\n         AR    R10,R1\n         L     R2,SHVNAMA-SHVBLOCK+@SHV  Address of variable name.\n         LTR   R2,R2               Did caller specify a stem variable?\n         BZ    STACK                  -no -   Go stack the entries.\n         TITLE            '<< REXX - Get PDS directory entry           X\n                             Place record into the stemmed variable >>'\n         LM    R2,R4,SET_REGS\n         LA    R2,1(,R2)           Count the entries and\n         ST    R2,SET_REGS            save the count.\n         CVD   R2,DBLWD            Covert the count\n         UNPK  TAIL,DBLWD+5(3)        to ebcdic\n         OI    TAIL+4,X'F0'              format.\n         BCTR  R3,R4               Branch unless count was 10, 100 etc.\n         L     R3,SHVNAML-SHVBLOCK+@SHV  Length of tail\n         LA    R3,1(,R3)                    just increased by one\n         ST    R3,SHVNAML-SHVBLOCK+@SHV        so save.\n         CLI   TAIL,C'1'           Just counted 10,000?\n         BE    SET@10000              -yes-\n         CLI   TAIL+1,C'1'         Just counted 1,000?\n         BE    SET@1000               -yes-\n         CLI   TAIL+2,C'1'         Just counted 100?\n         BE    SET@100                -yes-\n         LA    R3,90               At 10 now, re-set counter @ 90\n         LA    R4,*+8              Re-set address for left adjust move\n         ST    R4,SET_REGS+8          and save it.\n         MVC   TAIL(2),TAIL+3      Left adjust the tail to stem.\n         B     CALL_EXCOM          Ready for IRXEXCOM.\nSET@100  DS    0H                  At 100 now,\n         LA    R3,900                 re-set counter @ 900\n         LA    R4,*+8              Re-set address for left adjust move\n         ST    R4,SET_REGS+8          and save it.\n         MVC   TAIL(3),TAIL+2      Left adjust the tail to stem.\n         B     CALL_EXCOM          Ready for IRXEXCOM.\nSET@1000 DS    0H                  At 1,000 now,\n         L     R3,=A(9000)            re-set counter @ 9000\n         LA    R4,*+8              Re-set address for left adjust move\n         ST    R4,SET_REGS+8          and save it.\n         MVC   TAIL(4),TAIL+1      Left adjust the tail to stem.\n         B     CALL_EXCOM          Ready for IRXEXCOM.\nSET@10000 DS   0H                  At 10,000 now,\n         L     R3,=A(90000)           re-set counter @ 90000\n         LA    R4,CALL_EXCOM       Re-set address for no adjust move\n         ST    R4,SET_REGS+8          and save it.\n         B     CALL_EXCOM          Ready for IRXEXCOM.\nSET@1    DS    0H\n         MVC   TAIL(1),TAIL+4\n         TITLE            '<< REXX - Get PDS directory entry           X\n                Assign the value from the record to a REXX variable >>'\nCALL_EXCOM  DS  0H\n         ST    R3,SET_REGS+4       Save the loop counter.\n*\n* Refer to the IRXEXCOM routine; pages 312-319 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\nCALL_EXCOM@    DS  0H\n         L     R15,IRXEXCOM        Get routine's address from vector.\n         LA    R0,ENVBLOCK         Make sure REXX knows environment.\n         LA    R1,PLIST_EXCOM\n         BALR  R14,R15\n         BCT   R11,MATCH_ENTRY\n         B     DO_STEM0\n         SPACE 1\nPLIST_EXCOM DC A(EXCOM_LIT,0,0)\n         DC    A(@SHV+X'80000000')\n         SPACE 1\n@SHV     DS    0A\n         DC    2A(0)\n         DC    C'S'\n         DS    XL3'000000'\n         DC    5A(0)\n         SPACE 1\nEXCOM_LIT DC   CL8'IRXEXCOM'\n         TITLE            '<< REXX - Get PDS directory entry           X\n                                   Put the record on the data stack >>'\n*\n* Refer to the IRXSTK   routine; pages 485-490 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\nSTK_FUNC DC    CL8'QUEUE   '\nSTK_PLIST  DC  A(STK_FUNC)\n         DC    A(SHVVALA-SHVBLOCK+@SHV)\n         DC    A(SHVVALL-SHVBLOCK+@SHV)\n         DC    A(RC+X'80000000')\nSTACK    DS    0H\n         LA    R1,STK_PLIST\n         LA    R0,ENVBLOCK\n         L     R15,IRXSTK\n         BALR  R14,R15\n         BCT   R11,MATCH_ENTRY\n         B     DO_STEM0\n         TITLE            '<< REXX - Read a PDS member                 X\n                     Subroutine to Strip Leading && Trailing Blanks >>'\n         DROP  R10\n         USING ARGTABLE_ENTRY,R10\n* Registers upon entry\n*    R10 ==> argument table entry\n*    R14 ==> exit address when agrument is null\n*    R14+4=> normal exit\n*\n* Registers upon exit\n*    R10 ==> next argument table entry.\n*    R2    = 0 (zero)\n*    R3  ==> leftmost non-blank byte of argument\n*    R4  ==> rightmost non-blank byte of argument\n*    R15   = R4 - R3 (length of argument minus 1)\n         SPACE 2\nTRT3     TRT   0(0,R3),TRTABLE\nHEXFF    DC    X'FFFFFFFFFFFFFFFF'\n         DS    XL1\nTRTABLE  DS    XL256\n         SPACE 2\nSTRIP    DS    0H\n         CLC   HEXFF,ARGTABLE_ARGSTRING_PTR  Is there an argument?\n         BER   R14                              -no -\n         L     R15,ARGTABLE_ARGSTRING_LENGTH\n         L     R3,ARGTABLE_ARGSTRING_PTR  Get address of argument.\n         LA    R10,ARGTABLE_NEXT   Point to next argument table entry.\n         SPACE 1\n         LTR   R15,R15             Does the argument have any length?\n         BZR   R14                    -NO - take abnormal exit.\n         LA    R4,0(R15,R3)        Point just beyond ARG.\n         MVC   TRTABLE,TRTABLE-1   Set to\n         MVI   TRTABLE+C' ',X'00'     bypass blanks.\n         BCTR  R15,0               Set length for TRT instruction.\n         EX    R15,TRT3            Skip to non-blank.\n         BZR   R14                 When all blank.\n         LR    R3,R1               Re-set starting address.\nSTRIP@R  DS    0H\n         BCTR  R4,0                Backpedal 1 byte.\n         CLI   0(R4),X'40'         (still) at a blanK?\n         BNE   STRIPPED               -no -\n         CR    R4,R3                  -yes-  More to inspect?\n         BH    STRIP@R                          -yes-\nSTRIPPED DS    0H\n         LR    R15,R4              Calculate\n         SR    R15,R3                 length of ARG - 1.\n         SR    R2,R2               Pre-clear R2 for TRT\n         XC    TRTABLE,TRTABLE     Clear translate table.\n         BC    15,4(,R14)          Take normal exit.\n         TITLE            '<< REXX - Get PDS directory entry           X\n                                                   Error Conditions >>'\n*\n* Refer to the IRXSAY   routine; pages 336-339 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\nSAY_LIT        DC    CL8'WRITE   '\nSAY_BUFF       DS    A\nSAY_LEN        DS    F\nSAY_PLIST      DC    A(SAY_LIT,SAY_BUFF,SAY_LEN+X'80000000')\n@383_MSG DC    C'Directory read (STSS383) failure.'\nMISSING_DD_MSG DC    C'First argument (DDNAME) missing.'\nMISSING_MEM_MSG DC   C'Second argument (member selection criteria) missi\n               ing.'\n@383_FAILED    DS    0H\n         LA    R15,@383_MSG\n         LA    R0,L'@383_MSG\n         B     SAY_CALL\nMISSING_DD     DS    0H\n         LA    R15,MISSING_DD_MSG\n         LA    R0,L'MISSING_DD_MSG\n         B     SAY_CALL\nMISSING_MEM    DS    0H\n         LA    R15,MISSING_MEM_MSG\n         LA    R0,L'MISSING_MEM_MSG\n         B     SAY_CALL\nSAY_CALL DS    0H\n         ST    R15,SAY_BUFF\n         ST    R0,SAY_LEN\n         LA    R1,SAY_PLIST\n         LA    R0,ENVBLOCK\n         L     R15,IRXSAY\n         BALR  R14,R15\n         L     R13,SAVEAREA+4\n         XC    8(4,R13),8(R13)\n         LM    R14,R12,12(R13)\n         LA    R15,40\n         BR    R14\n         TITLE            '<< REXX - Get PDS directory entry           X\n                                              Global Data Constants >>'\n         SPACE 2\nDBLWD    DS    D\n         SPACE 2\n         DC    A(0,10,SET@1)\nSET_REGS DS    3A\n         SPACE 1\nVSTSS383 DC    V(STSS383)\nVWC001   DC    V(SCCWC001)\n         SPACE 1\nF8       DC    F'8'\nSELECT_LEN DS  F\n         SPACE 1\nPLIST383 DC    A(DDNAME,ADRCTRY+X'80000000')\nPLIST_WC001 DC    A(MEM_NAME,SELECT_LEN,0,F8+X'80000000')\nDDNAME   DC    CL8' '\nMEM_NAME DC    CL8' '\nNON_WILD DC    CL8' '\nADRCTRY  DS    F\nMVC_DD   MVC   DDNAME(0),0(R3)\nMVC_MEM  MVC   MEM_NAME(0),0(R3)\nMVC_STEM MVC   0(0,R2),0(R3)\n         SPACE 2\nNON_WILD_TR DC 256AL1(*-NON_WILD_TR)\n         ORG   NON_WILD_TR+C'*'\n         DC    X'FF'\n         ORG   NON_WILD_TR+C'%'\n         DC    X'FF'\n         ORG\n         SPACE 2\nVAR_NAME DS    0CL250\n         DS    CL245\nTAIL     DS    CL5\n         SPACE 2\n         LTORG\n         TITLE            '<< REXX - Get PDS directory entry           X\n                                                 DSECTs and EQUates >>'\n         YREGS\n         SPACE 2\n       IRXENVB\n         SPACE 2\n       IRXEXTE\n         SPACE 2\n       IRXSHVB\n         SPACE 2\n       IRXEFPL\n         SPACE 2\n      IRXARGTB\n         SPACE 2\n      IRXEVALB\n         SPACE 2\nDRCT00D  DSECT\nDRCTPREF DS   0D        Prefix area double word aligned.\nDRCTSIZ  DS   F         Size of table (in bytes).\nDRCTCNT  DS   H         Number of directory entries.\nDRCTCON  DS   H         Concatenation levels.\n*                End of prefix area\nDRCTNTRY DS   0CL14     (Note minimum size).\nMEMNAME  DS   CL8       Member name.\nMEMTTR   DS   XL3       Member \"ttr\" location.\nMEMCON   DS   XL1       Member concatenation level.\n         DS   XL1       Reserved.\nMEMLEN   DS   XL1       Number of user halfwords\nMEMALIAS EQU  X'80'     Mask for an ALIAS designation.\nMEMTTRNS EQU  X'60'     Mask for # of \"ttrn\" halfwords.\nMEMHALF  DS   0H        Member \"user data\".\n         END  SCCPDSD\n./ ADD NAME=SCCWC001 0108-95180-95229-1033-00139-00122-00000-PST0705\n* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *\n*\n* Program name :  SCCWC001\n*\n* Function:       Determine if the selection parameter (which may\n*                 contain 'wildcard' specifications of * and %) is\n*                 matched to the target parameter.\n*\n*                 A wildcard value of percent sign (or x'FF') means\n*                 the corresponding column in the target must exist.\n*                 A wildcard value of asterisk will match to any\n*                 string of any length (including 0) in the target.\n*\n*                 Multiple wildcard specifications are valid.\n*\n* Parameters:  1. The 'selection' field. A string of characters which\n*                 may contain 'wildcard' values as described above.\n*                 All non-wildcard values are compared for an exact\n*                 match against the target parameter.\n*\n*              2. Fullword field whose hexadecimal value is the\n*                 length of parameter 1.\n*\n*              3. The 'target' field. This (sub)field is what the\n*                 'selection' parameter is attempting to match.\n*\n*              4. Fullword field whose hexadecimal value is the\n*                 length of parameter 3.\n*\n* Output:      SCCWC001 produces no output parameter. It sets the\n*              condition code to zero if a match is made and sets the\n*              condition code to other than zero if no match is made.\n*              (No meaning other than 'not equal' should be derived\n*              from condition code settings of 1 or 2; condition code\n*              3 should never be set.)\n*\n* Updates:\n*     Jun. 1995    - R. Ryerse. Original composition.\n*\n* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *\nSCCWC001 ID    R12\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         B     START\nFORCE_EQUAL DS 0H\n         SR    R0,R0\n         B     RTNXT\nFORCE_LOW  DS  0H\n         CLI   SCCWC001,X'FF'\n         B     RTNXT\nFORCE_HIGH  DS 0H\n         CLI   SCCWC001,X'00'\nRTNXT    DS    0H\n         LA    R0,0                  Need a convenient zero to\n         ST    R0,16(,R13)              set R15 to zero.\n         LM    R14,R12,12(R13)       Re-set callers registers.\n         BR    R14                   Return to caller.\n         SPACE 3\nSTART    DS    0H\n         XC    A_STAR,A_STAR         We have no asterisk (yet).\n         LM    R3,R6,0(R1)           Pick-up parameter addresses.\n         L     SELECT_COUNT,0(,R4)   Get length(select).\n         L     TARGET_COUNT,0(,R6)   Get length(target).\n         LA    R1,0(TARGET_COUNT,TARGET)\n         LA    R7,*+4\n         BCTR  R1,0\n         CLI   0(R1),C' '\n         BNE   *+6\n         BCTR  TARGET_COUNT,R7\n         LA    R7,LOOP\nLOOP     DS    0H            The major loop.\n         CLI   0(SELECT),C'*'        Match everything?\n         BNE   NOT_ASTERISK             -no -\n         LA    R7,LOOP@                 -yes-   Switch to minor loop\n         B     COUNT_SELECT                        and continue.\nNOT_ASTERISK   DS    0H\n         CLI   0(SELECT),C'%'        Match any character?\n         BE    COUNT_TARGET             -yes-\n         CLC   0(1,SELECT),0(TARGET) Matched?\n         BNE   RE_LOOP                  -no - double check needed.\nCOUNT_TARGET   DS    0H\n         LA    TARGET,1(,TARGET)     Step along to next 'target' byte.\n         BCT   TARGET_COUNT,COUNT_SELECT  Count and continue.\n         B     END_OF_TARGET         'Target' is exhausted.\nCOUNT_SELECT   DS    0H\n         LA    SELECT,1(,SELECT)     Step along to next 'select' byte.\n         BCTR  SELECT_COUNT,R7       Count the select and loop.\n         SPACE 2\n* The 'select' field is exhausted but 'target' is not.\n         LA    R0,LOOP@              Was last 'select' byte\n         CR    R0,R7                    an asterisk?\n         BE    RTNXT                       -yes-   We have a match\nRE_LOOP  DS    0H\n         LM    SELECT,TARGET_COUNT,A_STAR\n         LTR   SELECT,SELECT         Was there a previous asterisk?\n         BZ    FORCE_LOW                -no -\n         LA    TARGET,1(,TARGET)     Post asterisk matched plus one\n         BCT   TARGET_COUNT,LOOP@@      and length minus one.\n         B     FORCE_LOW             Target went exhausted.\nEND_OF_TARGET  DS    0H\n         LA    SELECT,1(,SELECT)     Step along to next 'select' byte.\n         BCT   SELECT_COUNT,*+8      Count 'select'.\n         B     FORCE_EQUAL           'Select' equally exhausted.\n         CLI   0(SELECT),C'*'        Afterthought '*'\n         BE    END_OF_TARGET            -yes-   Keep checking.\n         B     FORCE_HIGH               -no -   No match.\n         EJECT\nLOOP@    DS    0H            After '*' in select.\n         CLI   0(SELECT),C'*'        Another asterisk?\n         BE    COUNT_SELECT@            -yes-   Really has no meaning.\n         CLI   0(SELECT),C'%'        Looking for any character?\n         BNE   LOOP@@                   -no -\n         LA    TARGET,1(,TARGET)     Step along to next 'target' byte.\n         BCT   TARGET_COUNT,COUNT_SELECT@ Decrement 'target' count.\n         B     END_OF_TARGET@        'Target' is exhausted.\nCOUNT_SELECT@  DS    0H\n         LA    SELECT,1(,SELECT)     Step along to next 'select' byte.\n         BCTR  SELECT_COUNT,R7       Count the select and loop.\n         B     FORCE_EQUAL           'Select' is exhausted.\nEND_OF_TARGET@ DS    0H\n         BCT   SELECT_COUNT,FORCE_LOW Count 'select'. No match if more.\n         B     FORCE_EQUAL           'Select' equally exhausted.\nLOOP@@   DS    0H\n         LA    R7,LOOP               Revert to major loop.\n         STM   SELECT,TARGET_COUNT,A_STAR\n         CLC   0(1,SELECT),0(TARGET) Matched?\n         BE    COUNT_TARGET             -yes-   Jump into major loop.\n         LA    TARGET,1(,TARGET)     Step along to next 'target' byte.\n         BCT   TARGET_COUNT,LOOP@@+4 Decrement 'target' count. Loop.\n         B     RTNXT                 LOOP@@+8 has set condition code.\n         SPACE 3\n         DS    0D\nA_STAR   DS    XL16\n         YREGS\nSELECT         EQU   R3\nSELECT_COUNT   EQU   R4\nTARGET         EQU   R5\nTARGET_COUNT   EQU   R6\n         END   SCCWC001\n./ ADD NAME=STSS383  0131-95310-98218-0839-00577-00710-00000-PST0705\nSS383    TITLE                     '<< Load/search a PDS directory     >\n                                                      Documentation >>'\n* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *\n*\n* Program name :  STSS383\n*\n* Function:       Build and/or search an in-core directory of a\n*                 specified partitioned data set.\n*\n* Parameters:     Be aware that the number of parameters passed to this\n*                 routine determines the funtion to be performed\n*\n*                 When there are no parameters, STSS383 releases all\n*                 the tables it has built.\n*\n*                 When there is one parameter, STSS383 releases the\n*                 the table for the specified DDNAME.\n*\n*                 When there are two parameters, STSS383 returns the\n*                 address of the table for the specified DDNAME.\n*\n*                 When there are three parameters, STSS383 matches\n*                 the specified member name and provides\n*                 addressability to the directory entry of the latest\n*                 version of that memeber.\n*\n*   1. In all cases (except when there are no parameters) the 1st\n*      parameter is an eight byte field containing the value of the\n*      DDNAME which STSS383 must act upon.\n*\n*   2. In the case where there are two parameters, the 2nd parameter is\n*      a fullword \"cell\" where STSS383 puts the address of the\n*      structure mapped as follows:\n*\n*         DRCT00D  DSECT\n*         DRCTPREF DS   0D        Prefix area double word aligned.\n*         DRCTSIZ  DS   F         Size of table (in bytes).\n*         DRCTCNT  DS   H         Number of directory entries.\n*         DRCTCON  DS   H         Concatenation levels.\n*         *                End of prefix area\n*         DRCTNTRY DS   0CL14     (Note minimum size).\n*         MEMNAME  DS   CL8       Member name.\n*         MEMTTR   DS   XL3       Member \"ttr\" location.\n*         MEMCON   DS   XL1       Member concatenation level.\n*                  DS   XL1       Reserved.\n*         MEMLEN   DS   XL1       Number of user halfwords\n*         MEMALIAS EQU  X'80'     Mask for an ALIAS designation.\n*         MEMTTRNS EQU  X'60'     Mask for # of \"ttrn\" halfwords.\n*         MEMHALF  DS   0H        Member \"user data\".\n*\n*      Note that the mapping above shows the table \"prefix\" area\n*      and one memeber.\n*\n*      In the case where there are three parameters, the 2nd parameter\n*      is an eight byte field containing the member name to be matched.\n         EJECT\n*   3. The 3rd parameter is a fullword where STSS383 places the\n*      address of the entry for the requested member.\n*      Zero signifies a \"not-found\".\n*\n* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *\n         TITLE                     '<< load/search a pds directory     >\n                                            initialization per call >>'\nSTSS383  ID    R12,AMODE=31,RMODE=24\n         SPACE 2\n         PRINT NOGEN\n         USING IHADCB,R11\n         STM   R14,R12,12(R13)     Save the callers registers\n         LR    R12,R15             Establish my base register.\n         LA    R15,SAVEAREA        Add\n         ST    R13,SAVEAREA+4         myself to the\n         ST    R15,8(,R13)               save area chain\n         LR    R13,R15             Finally linkup savearea chain.\n         ST    R1,APARMS           Save parameter list address.\n         LA    R11,DRCTDCB\n         MVI   COBOLSW,X'00'       Indicate non-COBOL caller.\n         XC    RC,RC               Pre-clear return code\n         XC    HCONCAT,HCONCAT        concatenation level\n         XC    ALLEN,ALLEN               and total length.\n         LTR   R1,R1               Any parameters?\n         BZ    FREEALL                -no -  Go free acquired areas.\n         TM    0(R1),X'80'         Only one parameter?\n         BO    FREEONE                -yes-  Go free acquired area.\n         TM    4(R1),X'80'         Did I get 2 parameters?\n         BO    *+12                   -yes-\n         TM    8(R1),X'80'         Did I get 3 parameters?\n         BZ    BADPARMS              -no - Something wrong here.\n         L     R3,0(,R1)           Addressablity to parameters.\n         MVC   DCBDDNAM,0(R3)\n         LA    R5,DDTBL-DDNTRY     Pre-set for table search.\nNXTDD    DS    0H\n         LA    R5,DDNTRY(0,R5)     Point to next table entry.\n         CLC   BLANK8,0(R5)        At end of active entries?\n         BE    SETDD                    -yes-\n         CLC   DCBDDNAM,0(R5)\n         BE    PARMOUT\n         C     R5,=A(DDLAST)       Any more entries?\n         BL    NXTDD                  -yes-  Go inspect them.\n         B     XTBL                   -no -  Abort.\nSETDD    DS    0H\n         MVC   0(8,R5),0(R3)       Save the DDNAME in the table entry.\n         ST    R5,ADDNTRY          Save address of this entry.\n         OPEN  ((R11)),MODE=31\n         LA    R0,ATBL0            The first entry\n         ST    R0,AATBL               is the current entry.\n         L     R0,GETMAIN_AVAIL    64K minus prefix (8) and 1 minimum\n         ST    R0,TBLEN               entry is the length available.\n         L     R0,GETMAIN_SIZE     Want 64K of virtual storage.\n       GETMAIN R,LV=(0)\n         MVC   0(4,R1),GETMAIN_SIZE\n         L     R5,ADDNTRY          Point to my table entry so I can\n         ST    R1,8(0,R5)             save the storage address\n         ST    R1,ATBL0                  also at index entry.\n         OI    ATBL0,X'80'         Say GETMAIN'd area.\n         LA    R1,8(0,R1)          Point to the 1st member area and\n         ST    R1,ATBLNTRY               1st member address.\n         SR    R8,R8               Initialize member counter.\n         TITLE                     '<< Load/search a pds directory     >\n                                          mainline (including read) >>'\nREADDRCT DS    0H\n         AMODE24\n         PRINT   GEN\n         GET   (R11)\n         AMODE31\n         MVC   DRCTBLK,0(R1)\n         BAL   R9,DEBLOCK          De-block a directory block.\n         CLC   =XL8'FFFFFFFFFFFFFFFF',0(R7)\n         BNE   READDRCT            More directory blocks to come.\n         FEOV  (R11)               Get next DD in the concatenation.\n         PRINT NOGEN\n         LH    R9,HCONCAT          Next concatenation exists so\n         LA    R9,1(,R9)              count 1 more and\n         STH   R9,HCONCAT                save the sum.\n         BAL   R9,NEXT_INDEX       I'll need another sector.\n         B     READDRCT            Go for more.\nEODRCT   DS    0H\n         CLOSE ((R11)),MODE=31\n         MVC   DRCTDCB(DCB_LEN),A_DCB\n         BAL   R9,TBLOUT           Format into one table.\nPARMOUT  DS    0H\n         L     R5,ADDNTRY          Pickup my entry for this DD and\n         L     R2,8(,R5)              get the table address for it.\n         L     R1,APARMS           Restore my parameter list address.\n         TM    4(R1),X'80'         Two parameters?\n         BZ    SEARCH0                -no -  Must be three parms.\n         L     R3,4(,R1)           Get the address of the 2nd parm.\n         ST    R2,0(,R3)           Give the caller the table address.\n         B     RTNXT               All done.\nSEARCH0  DS    0H\n         BAL   R9,SEARCH           Search for a member.\nRTNXT    DS    0H\n         L     R15,RC              Set the return code.\n         L     R13,SAVEAREA+4      Get the caller's savearea\n         L     R14,12(,R13)        Get the caller's return address.\n         LM    R0,R12,20(R13)      Restore the caller's registers\n         XC    8(4,R13),8(R13)     Take a link off the savearea chain.\n         BR    R14                 Return to the caller.\n         TITLE                     '<< Load/search a pds directory     >\n                                         de-block record into table >>'\nUSERIN   MVC   14(0,R4),12(R7)\nDEBLOCK9 DS    F\n         SPACE 1\nDEBLOCK  DS    0H\n         ST    R9,DEBLOCK9         Save the BAL return address.\n         LH    R2,DRCTBLK          Get the length\n         BCTR  R2,0                   of data\n         BCTR  R2,0                       within the block.\n         LA    R3,42(0,R2)         Do I have enough\n         C     R3,TBLEN               room in the table?\n         BL    *+8                       -yes-\n         BAL   R9,NEWSPAC                -no -  Get some more space.\n         SR    R3,R3               Pre-clear a work register.\n         LM    R4,R7,ATBLNTRY      Get various pointers.\nDEBLOCK1 DS    0H\n         CLC   =XL8'FFFFFFFFFFFFFFFF',0(R7)\n         BE    DEBLOCK8            Block is finished.\n         LA    R8,1(0,R8)          Increment the memeber counter.\n         IC    R3,11(R7)           Get number of user halfwords\n         N     R3,=F'31'              voiding the high order 3 bits.\n         SLL   R3,1                Halfword to bytes and\n         LA    R3,14(0,R3)            include the overhead.\n         SR    R6,R3               Decrement table length.\n         AR    R5,R3               Increment total length.\n         MVC   0(11,R4),0(R7)      Get the member name and TTR.\n         MVC   13(1,R4),11(R7)     Get the number of user halfwords.\n         MVC   11(1,R4),CONCAT     Get the concatenation level and\n         MVI   12(R4),X'00'           set a convenient halfword.\n         SH    R3,=H'15'           Decrement by overhead length + 1.\n         BNP   DEBLOCK2            There is nothing left.\n         EX    R3,USERIN           Get the user data.\nDEBLOCK2 DS    0H\n         LA    R3,13(,R3)          Restore the member length.\n         AR    R7,R3               Point to next source member\n         LA    R4,2(R3,R4)         Point to next target member.\n         SR    R2,R3               Decrement the block residual size.\n         BP    DEBLOCK1            There is still more to come.\nDEBLOCK8 DS    0H\n         STM   R4,R6,ATBLNTRY      Replace all that good stuff.\n         L     R9,DEBLOCK9         Get the return address.\n         BR    R9                  Exit this BAL procedure.\n         TITLE                     '<< Load/search a pds directory     >\n                   Switch to a new sector  /  Allocate more storage >>'\nGETMAIN_SIZE   DC  A(GETMAIN_VALUE)\nGETMAIN_AVAIL  DC  A(AVAIL_VALUE)\nTBLNTRYS EQU   64                  Maximum number of tables.\n         SPACE 1\nAATBL    DC    A(ATBL0)            Current entry of table below.\nATBL0    DS    (TBLNTRYS-1)F\nATBLF    DS    F\n         SPACE 1\nNEXT_INDEX  DS 0H\n         L     R3,AATBL            Already at\n         C     R3,=A(ATBLF)           last cell?\n         BNL   BADTBL                    -yes-   down the tubes.\n         LA    R3,4(0,R3)                -no - point to next cell and\n         ST    R3,AATBL                           save the cell address\n         L     R4,ATBLNTRY         Point no temp table slot.\n         MVI   0(R4),X'FF'         Fill slot\n         MVC   1(10,R4),0(R4)         with a\n         MVC   11(1,R4),CONCAT           high-value\n         XC    12(2,R4),12(R4)              entry.\n         LA    R4,14(0,R4)         Point beyond dummy slot in temp tbl.\n         ST    R4,ATBLNTRY         Save the address for later ntrys.\n         ST    R4,0(0,R3)          Fill cell for next temp table.\n         L     R6,TBLEN            Decrement\n         S     R6,=F'14'              available storage\n         ST    R6,TBLEN                  and save it.\n         BR    R9                  Exit via bal register.\n         SPACE 3\nNEWSPAC0 DS    10F\n         SPACE 1\nNEWSPAC  DS    0H\n         STM   R0,R9,NEWSPAC0      Save all those values.\n         BAL   R9,NEXT_INDEX       Allocate a new table entry.\n         MVC   TBLEN,GETMAIN_AVAIL Set the 'storage available'.\n         L     R0,GETMAIN_SIZE     64K.\n       GETMAIN R,LV=(0)\n         MVC   0(4,R1),GETMAIN_SIZE\n         L     R9,AATBL            Point to index entry.\n         ST    R1,0(0,R9)          The index knows where to save data.\n         OI    0(R9),X'80'         Set GETMAIN'd indicator.\n         LA    R1,8(,R1)           Point beyond the prefix area.\n         ST    R1,ATBLNTRY         Save the virtual storage address.\n         LM    R0,R9,NEWSPAC0      Restore all those registers.\n         BR    R9                  Exit via BAL register.\n         TITLE                     '<< Load/search a pds directory     >\n                                                 Load callers table >>'\nTBLOUT   DS    0H\n         L     R3,ADDNTRY          Get address for the DD table entry.\n         LA    R2,ATBL0            Is the first index\n         C     R2,AATBL               the current index?\n         BNE   TBLOUT1                   -no -\n         L     R2,ATBL0            Get the primary table address\n         LA    R2,0(,R2)           Clear the high order bit.\n         ST    R2,8(0,R3)          Put address into DDtable entry.\n         STH   R8,4(R2)            Put the memeber count, and\n         MVC   6(2,R2),HCONCAT        the concatenation level.\n         BR    R9                  That's all there is to it.\nTBLOUT1  DS    0H\n         L     R2,ATBLNTRY\n         MVI   0(R2),X'FF'         Set\n         MVC   1(10,R2),0(R2)         last\n         MVC   11(1,R2),CONCAT           table\n         XC    12(2,R2),12(R2)              entry.\n         L     R2,ALLEN            Get total length\n         LA    R2,16(,R2)             of storage required.\n         LR    R0,R2               Use R0 for GETMAIN\n       GETMAIN R,LV=(0)\n         ST    R1,8(0,R3)          Put address into DDtable entry.\n         ST    R2,0(,R1)           Length of GETMAIN now in table.\n         STH   R8,4(,R1)           Set number of directory entries,\n         MVC   6(2,R1),HCONCAT        and number of concatentaions.\n         LA    R8,8(0,R1)          Establish table base.\n         SR    R6,R6               Clear work register.\n         MVC   SAVEAREA+12(TBLNTRYS*4),ATBL0\n         LA    R2,ATBL0-4          Set index pointer.\n         LA    R15,*+4             Top of loop address\n         SPACE 1\n         LA    R2,4(,R2)           Point to next storage index.\n         C     R2,AATBL            Beyond allocated indexes?\n         BH    TBLOUT2                -yes-\n         TM    0(R2),X'80'         GETMAIN'd area\n         BZR   R15                    -no -   Loop back.\n         L     R14,0(,R2)          Adjust the address\n         LA    R14,8(,R14)            for the prefix area\n         ST    R14,0(,R2)                and put it back.\n         BR    R15                 Loop\nTBLOUT2  DS    0H\n         LA    R2,ATBL0            Get address of 1st storage index.\n         LR    R5,R2               Say this points to the least.\n         L     R3,ATBL0            Get address of 1st storage sector.\nTBLOUT3  DS    0H\n         LA    R2,4(0,R2)          Point to next storage index.\n         C     R2,AATBL            Out of indexes?\n         BH    TBLOUT4                -yes- Ready to move.\n         L     R4,0(0,R2)          Get address of comparator.\n         CLC   0(8,R4),0(R3)       This table entry less than current?\n         BNL   TBLOUT3                -no - keep looking\n         LR    R3,R4                  -yes- save sector address and\n         LR    R5,R2                        index address.\n         B     TBLOUT3             Keep looking.\nTBLOUT4  DS    0H\n         CLC   =XL8'FFFFFFFFFFFFFFFF',0(R3) Lowest at high-values?\n         BE    TBLOUT5                         -yes- table is complete.\n         IC    R6,13(R3)           Get number of\n         N     R6,=F'31'              'user' halfwords\n         SLL   R6,1                      into a length.\n         LA    R6,13(0,R6)         Incement by fixed length minus 1\n         EX    R6,MVC_DRCTRY          to pick-up the directry entry.\n         LA    R6,1(0,R6)          Get true entry length.\n         AR    R3,R6               Point to next temp entry and\n         ST    R3,0(0,R5)             reset the sector address.\n         AR    R8,R6               Point to next final slot.\n         B     TBLOUT2             Start again.\nMVC_DRCTRY     MVC   0(0,R8),0(R3) Move in the entry.\nTBLOUT5  DS    0H\n         MVC   ATBL0(TBLNTRYS*4),SAVEAREA+12\n         LA    R3,ATBL0            Will need more indexes.\nTBLOUT6  DS    0H\n         TM    0(R3),X'80'         GETMAIN'd area.\n         BZ    TBLOUT7                -no -\n         NI    0(R3),X'7F'         Turn off the bit.\n         L     R2,0(,R3)           Get storage address.\n         L     R0,0(,R2)           Get storage length.\n      FREEMAIN R,LV=(0),A=(R2)\nTBLOUT7  DS    0H\n         LA    R3,4(0,R3)          Point to next index.\n         C     R3,AATBL            All done?\n         BHR   R9                     -yes-  Exit via BAL register.\n         B     TBLOUT6                -no -  Go free it.\n         TITLE                     '<< Load/search a pds directory     >\n                                        Warnings, errors and abends >>'\nABEND    DS    0H\n         ABEND 383,DUMP,STEP\n         SPACE 3\nBADPARMS DS    0H\n         WTO   'STSS383  :  Incorrect number of parameters. Run abortedx\n               ',ROUTCDE=(11),DESC=(6)\n         B     ABEND\n         SPACE 3\nBADIO    DS    0H\n         WTO   'STSS383  :  Raised unrecognized sense bits from I/O',  x\n               ROUTCDE=(11),DESC=(6)\n         B     ABEND\n         SPACE 3\nBADTBL   DS    0H\n         WTO   'STSS383  :  Excessive table allocations. run aborted', x\n               ROUTCDE=(11),DESC=(6)\n         B     ABEND\n         SPACE 3\nXTBL     DS    0H\n         WTO   'STSS383  :  Excessive ddname requests. run aborted',   x\n               ROUTCDE=(11),DESC=(6)\n         B     ABEND\n         TITLE                     '<< Load/search a pds directory     >\n                                Release previously acquired storage >>'\nFREEALL  DS    0H\n         LA    R6,DDTBL-DDNTRY     Pre-set for indexes.\n         LA    R6,DDNTRY(,R6)      Point to next index.\n         CLC   BLANK8,0(R6)        Active index?\n         BE    RTNXT                  -no -  All done.\n         BAL   R9,FREEANY          Free this index and\n         MVC   0(8,R6),BLANK8         de-activate it.\n         B     FREEALL+4           Loop for next index.\n         SPACE 3\nFREEONE  DS    0H\n         L     R3,0(,R1)           Address the 1st parameter.\n         LA    R6,DDTBL-DDNTRY     Pre-set for indexes.\n         LA    R6,DDNTRY(,R6)      Point to next index.\n         CLC   BLANK8,0(R6)        Active index?\n         BE    RTNXT                  -no -  All done.\n         CLC   0(8,R6),0(R3)       Is the DDNAME matched?\n         BE    *+14                   -yes-\n         CLC   8(4,R6),0(R3)       How about table address?\n         BNE   FREEONE+8              -no -  Go bump to next index.\n         BAL   R9,FREEANY          Free this index.\n         LA    R7,DDLAST-1         Calculate residual\n         SR    R7,R6                  length of index entries\n         EX    R7,MINUS_DDNTRY           to eliminate this entry.\n         B     RTNXT               All done.\n         SPACE 1\nMINUS_DDNTRY   MVC   0(0,R6),DDNTRY(R6)  Overlay/lop off this entry.\n         SPACE 3\nFREEANY  DS    0H\n         L     R2,8(0,R6)          Get the directory table address.\n         L     R0,0(,R2)           Get the directory table length.\n         LTR   R0,R0               Table formatted for COBOL?\n         BNZ   *+12                   -no -\n         LH    R0,4(,R2)              -yes-   Calculate\n         MH    R0,=H'22'                         its length.\n      FREEMAIN R,LV=(0),A=(R2)\n         BR    R9                  Exit via BAL register.\n         TITLE                     '<< Load/search a pds directory     >\n                                                   Search routines >>'\nSRCHCLC  CLC   0(0,R3),0(R4)\nSRCHMAX  DS    F\n         SPACE 2\nSEARCH   DS    0H\n         L     R1,APARMS           Get parameter list address.\n         L     R3,4(,R1)           Address the 2nd and\n         L     R8,8(,R1)              3rd parameters.\n         LA    R1,8(,R3)           Pre-set end-of-search-name address\n         TRT   0(8,R3),TOBLNK      Find a blank.\n         BCTR  R1,0                Calculate machine instruction\n         SR    R1,R3                  length of the search name.\n         L     R5,ADDNTRY          Get the index.\n         L     R4,8(,R5)           Get the directory table address.\n         LH    R7,4(,R4)           Get the number of directory entries.\n         SR    R6,R6               Thereby calculate\n         M     R6,=F'22'              the address\n         LA    R6,8(R4,R7)               beyond the last entry and\n         ST    R6,SRCHMAX                   save the address.\n         L     R2,0(,R4)           Get the directory table length.\n         LTR   R2,R2               COBOL formatted table.\n         BZ    SEARCH40               -yes-\n         LA    R6,8(R4,R2)         Address beyond the last table entry\n         ST    R6,SRCHMAX             and save it.\nSEARCH10 DS    0H\n         LH    R2,4(,R4)           Get the member count.\n         LA    R4,8(,R4)           Point to the first table entry.\nSEARCH11 DS    0H\n         EX    R1,SRCHCLC          Matched?\n         BE    SEARCH60               -yes-\n         BL    SEARCH70               -never-\n         IC    R6,13(,R4)          Point\n         N     R6,=F'31'              to\n         SLL   R6,1                     next\n         LA    R4,14(R6,R4)                entry.\n         BCT   R2,SEARCH11         Decrement the count and loop back.\n         B     SEARCH70            No match.\n         EJECT\nSEARCH40 DS    0H\n         LA    R2,3                Set 2's exponent\n         LA    R7,15                  and maximum entries.\n         CH    R7,4(,R4)           Are there less than 15 entries.\n         BNL   SEARCH10               -yes-  Use a serial search.\n         LA    R14,*+4              Set top-of-loop address.\n         LA    R2,1(,R2)           Increment 2's exponent.\n         SLL   R7,1                Double\n         LA    R7,1(,R7)              the maximum entries.\n         CH    R7,4(,R4)           High enough yet?\n         BLR   R14                    -no -  Keep bumping.\n         LA    R7,1(,R7)           Double the maximum to a power of 2\n         SRL   R7,1                   for the initial incr/decr count.\n         SR    R6,R6               Calculate incr/decr width\n         M     R6,=F'22'              from the count.\n         LR    R6,R7               Save the value\n         S     R6,=F'22'              minus 1 entry width.\n         LA    R4,8(R4,R6)         Point to approximately mid-table.\nSEARCH42 DS    0H\n         SRL   R7,1                Cut the incr/decr value in half.\n         C     R4,SRCHMAX          Beyond the table?\n         BNL   *+16                   -yes-\n         EX    R1,SRCHCLC          Are we matched?\n         BE    SEARCH60               -yes-  Still need to dig further.\n         BH    *+14                   -no, but need to look higher\n         SR    R4,R7                  -no, but need to look lower.\n         BCT   R2,SEARCH42         Decrement the count and try again.\n         B     SEARCH45            Need to take one last peek.\n         SPACE 1\n         AR    R4,R7               Move the address higher.\n         BCT   R2,SEARCH42         Decrement the count and try again.\nSEARCH45 DS    0H\n         C     R4,SRCHMAX          Beyond the table?\n         BNL   SEARCH70               -yes-\n         EX    R1,SRCHCLC          One last attempt to match\n         BNE   SEARCH70               wasn't satisfied either.\n         EJECT\nSEARCH60 DS    0H\n         ST    R4,0(,R8)           We may have the right entry already.\n         LR    R7,R4               Keep the entry address.\n         IC    R6,13(,R4)          Point\n         N     R6,=F'31'              to\n         SLL   R6,1                      next\n         LA    R4,14(R6,R4)                 entry.\n         C     R4,SRCHMAX          Too far?\n         BNL   SEARCH80               -yes-\n         EX    R1,SRCHCLC          Still matched?\n         BNE   SEARCH80               -no -  I'm satisfied.\n         CLC   0(8,R4),0(R7)       Concatenation of equal member names?\n         BE    SEARCH60+6             -yes-  Don't want the concat.\n         B     SEARCH60               -no -  Re-set and keep trying.\nSEARCH70 DS    0H\n         XC    0(4,R8),0(R8)       Indicate a \"no-match\"\n         BR    R9                  Exit via BAL register.\n         SPACE 3\nSEARCH80 DS    0H\n         TM    COBOLSW,X'40'       COBOL caller?\n         BZR   R9                     -no -  Exit via BAL register.\n         L     R3,8(,R5)           Address of\n         LA    R3,8(,R3)              beginning of the table.\n         SR    R7,R3               Displacement to the match.\n         SR    R6,R6               Width\n         D     R6,=F'22'              divided by 22 = count\n         LA    R7,1(,R7)                 relative to 1.\n         ST    R7,0(,R8)           Give COBOL caller subscript value.\n         BR    R9                  Exit via BAL register.\n         SPACE 1\n         DS    0F\n         SPACE 1\n         TITLE                     '<< Load/search a pds directory     >\n                                                      Storage areas >>'\nRC       DC    F'0'                Return code.\n         SPACE 1\nATBLNTRY DS    F\nALLEN    DC    F'0'\nTBLEN    DC    A(4096*16-14-8)\n         DC    A(DRCTBLK+2)\n         SPACE 1\nAPARMS   DS    F\n         SPACE 1\nSAVEAREA DS    (3+TBLNTRYS)F\n         SPACE 1\nTOBLNK   DC    256X'00'\n         ORG   TOBLNK+C' '\n         DC    X'01'\n         ORG\n         SPACE 1\nHCONCAT  DS    0H\n         DC    X'0'\nCONCAT   DC    XL1'0'\n         EJECT\nADDNTRY  DS    F\n         SPACE 2\nDDTBL    DS    0F\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\n         DC    CL8'        ',A(0)\nDDLAST   DC    CL8'        ',A(0)\nDDNTRY   EQU   *-DDLAST\nBLANK8   DC    CL8'        '      These two definitions must\nA0       DC    A(0)                  follow DDLAST.\n         SPACE 2\nCOBOLSW  DS    XL1\n         SPACE 3\n         EJECT\n         LTORG\n         TITLE                     '<< Load/search a pds directory     >\n                                                I/O control blocks >>'\n         DS    0D\nDRCTDCB  DCB   DSORG=PS,                                               x\n               EODAD=EODRCT,                                           x\n               MACRF=GL,                                               x\n               BLKSIZE=256,RECFM=F,LRECL=256,                          x\n               DDNAME=SYSUT1\n         DS    0D\nDCB_LEN  EQU   *-DRCTDCB\nA_DCB    DCB   DSORG=PS,                                               x\n               EODAD=EODRCT,                                           x\n               MACRF=GL,                                               x\n               BLKSIZE=256,RECFM=F,LRECL=256,                          x\n               DDNAME=SYSUT1\n         DS    0D\nDRCTKEY  DS    CL8\nDRCTBLK  DS    CL256\n         SPACE 1\n         TITLE                     '<< Load/search a pds directory     >\n                                                 DSECTs and EQUates >>'\nGETMAIN_VALUE  EQU   4096*16\nAVAIL_VALUE    EQU   GETMAIN_VALUE-8-14\n         YREGS\n         PRINT NOGEN\n         DCBD  DSORG=(QS),DEVD=(DA)\n         END   STSS383\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCCPDSR": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x15\\x7f\\x01\\x01\\x15\\x7f\\x15\\x00\\x06N\\x06N\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-06T00:00:00", "modifydate": "2001-06-06T15:00:00", "lines": 1614, "newlines": 1614, "modlines": 0, "user": "PST0705"}, "text": "./ ADD NAME=$README  0100-01157-01157-1455-00038-00038-00000-PST0705\nInstallation / readme for SCCPDSR\n\nThere are 4 component for this package\n\nID.MAC  Is an Assembler macro required to assemble each of the assembler\n        routines. Put it into a library included in your SYSLIB\n        concatenation for the assemblies.\n\nSTSS384.ASM  Is an assembler subroutine required for SCCPDSR. Assemble\n        it into an object or call library so that it can be link edited\n        into SCCPDSR.  Note that this subroutine could be CALLed by any\n        program wishing to read the records of a member in a PDS.\n\nSCCPDSR.ASM  Is an assembler routine which runs as a Rexx function to\n        populate a stem variable (or 'stack') with the member records\n\nSCCPDSR.HLP  Is the documentation on how to access member records in\n        Rexx\n\nMaking SCCPDSR available to your rexx program can be as simple as link\nediting it to a load library that is within the JOBLIB/STEPLIB\nconcatenation when the rexx program runs. Myself, I have built a Rexx\nfunction package under the name IRXFLOC which contains all the assembler\nwritten rexx functions for the platform.\n\nBelow is a Rexx prototype to read all the records of every member from\nDDname SYSUT1 where the member name begins with SCC. Note that DDname\nSYSUT1 would be pre-allocated. SCCPDSD is another function packaged\nseparately.\n\nCall SCCPDSD 'SYSUT1',   'SCC*',  'D.'\ndo d# = 1 to d.0\n     call SCCPDSR 'SYSUT1',  left(d.d#,12),  'R.'\n     do r# = 1 to r.0\n          parse var r.r# word1 etc .\n     end\n     drop R.\nend\n./ ADD NAME=HELP     0100-01157-01157-1457-00075-00075-00000-PST0705\n Name:        SCCPDSR\n\n\n Purpose:     Read a specified member of a specified DDname into either\n              a stemmed variable or into the data stack.\n\n Features:    Determination of ISRLEMX compression is made internally\n              and decompression is performed automatically.\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              SCCPDSR resides in the IRXFLOC \"function package\".\n\n Arguments:\n           1. The DDname of the library.\n\n              The DDname must be pre-allocated to the library. That\n              allocation must not be done at the member level.\n\n           2. The name of the member within the library. If the entire\n              directory entry (as per SCCPDSD) is available, then\n              the first 12 bytes of the directory should be provided\n              to SCCPDSR. See also argument 5.\n\n           3. The name of the REXX stem variable to receive the\n              records. The caller must ensure this specification is\n              enclosed within quotes.\n\n              If argument 3 is not specified (or specified as null),\n              the records are placed in the data stack.\n\n           4. (optional) The length of each record.hin the library.\n              By default, 80 is used. If the member records are\n              longer than 80 bytes, this argument must be spedcified\n              to receive the entire record.\n\n           5. (optional) The name of a variable which will be assigned\n              the value of the directory entry associated with the\n              member. The argument is redundant and ignored if argument\n              2 is coded with TTR information.  The value of the\n              directory entry will be formatted as per SCCPDSD; the\n              function SPFDIR can be used to format an ISPF style entry\n              in ebcdic values.\n\n Results: (when 'stem.' is specified at argument 3):\n              'stem.0' contains a count of the number of records.\n\n              'stem.1' through 'stem.stem.0' contains the individual\n              records.\n\n          (when argument 3 is null):\n              The data stack contains records read in FIFO order.\n\n          (independent of argument 3)\n              As a REXX subroutine/function SCCPDSR must return a\n              result to the caller. SCCPDSR returns a value indicative\n              of internal errors. Typically this value is 000; if it\n              is not all other results are suspect and incomplete.\n\n              If the specified member name (argument 2) is not found in\n              the concatenation of the directories, the result will be\n              004.\n\n Notes:\n    Choice of a technique to manage the 'data stack' is a subjective\n    matter. SCCPDSR makes no choice. If the REXX program requires stack\n    isolation, the programmer must use an appropriate technique.\n\n    If SCCPDSR is used subsequent to the use of SCCPDSD against the same\n    DDNAME and the DDNAME is a concatenation of multiple datasets with\n    unhomoginous blocksizes, special action is required.  For such a\n    situation, the allocation of the DDNAME must be such that the\n    largest blocksize is associated with the first dataset in the\n    concatenation either by coding a BLKSIZE parameter with the first\n    dataset or by placing the dataset with the largest blocksize first\n    in the concatenation.\n./ ADD NAME=ID       0100-01157-01157-1459-00049-00049-00000-WSBG\n         MACRO\n&LABEL   ID    &USING,&CSECT=YES,&AMODE=31,&RMODE=ANY\n         LCLC  &U,&LBL\n.*\n.* Stelco macro used to:\n.*    - generate the CSECT statement.\n.*    - generate the USING, AMODE and RMODE statements for the CSECT.\n.*    - generate an eye-catcher and date/time stamp (28 bytes total).\n.*      (The values for date and time are the time of the Assembly.)\n.*\n.* The default for the USING statement is (register) 15.\n.* Other defaults are as per the prototype above.\n.*\n.* If the CSECT requires multiple base registers, their specification\n.* must be enclosed in parenthesis.       e.g.  BIGRTN   ID     (12,11)\n.*\n.* This macro can also be used to generate only the eye-catcher and\n.* date/time stamp. For this type of usage specify   ID    ,CSECT=NO\n.*\n.* -----------------------Modification History-------------------------\n.* 98-02-19 change from &SYSDATE to &SYSDATC\n.*\n&U       SETC  '15'\n&LBL     SETC  ' '\n         AIF   (K'&LABEL EQ 0).LBLSET\n&LBL     SETC  '&LABEL'\n.LBLSET  ANOP\n         AIF   (T'&USING EQ 'O').USET\n         AIF   ('&USING'(1,1) NE '(').ONEUSE\n&U       SETC  '&USING'(2,K'&USING-2)\n         AGO   .USET\n.ONEUSE  ANOP\n&U       SETC  '&USING'\n.USET    ANOP\n         AIF   ('&CSECT' EQ 'YES').CSECT\n&LBL     DS    0H\n         B     *+32\n         AGO   .STAMP\n.CSECT   ANOP\n&LBL     CSECT\n&LBL     AMODE &AMODE\n&LBL     RMODE &RMODE\n         USING &LABEL,&U\n         BC    15,32(,15)\n.STAMP   ANOP\n         DS    CL4\n         DC    CL8'&LBL'\n         DC    CL16'&SYSDATC &SYSTIME'\n         MEND\n./ ADD NAME=SCCPDSR  0100-01157-01157-1457-00620-00620-00000-PST0705\nPDSR     TITLE            '<< REXX - Read a PDS Member                 X\n                                                      Documentation >>'\n* Name:        SCCPDSR\n*\n* Purpose:     Read all the records of a specified member of a\n*              partitioned dataset via (Assembler) subroutine STSS384.\n*\n* Environment: REXX subroutine/function for Address TSO or MVS\n*\n* Features:    STSS384 supports decompression of ISRLEMX, WYLBUR and\n*              YSLIM compressed members. For more information, refer\n*              to STSS384's documentation.\n*\n*              The REXX caller receives the records through either:\n*                 - a \"stemmed\" variable\n*                 - the \"data stack\"\n*\n*              The REXX caller can specify a logical record length.\n*\n* Parameters:  1. The DDNAME which refers to the partitioned dataset.\n*\n*                 Note that the routine itself determines if the\n*                 member has been compressed by ISRLEMX\n*\n*                 The following prefix values are reserved:\n*                    YSLIM___ and WYL_____\n*                 for referencing libraries where the members are\n*                 YSLIM or WYLBUR compressed repectively.\n*\n*              2. The name of the member to be read. If the caller has\n*                 entire directory entry available (as per SCCPDSD),\n*                 the first 12 bytes of that entry should be provided.\n*\n*              3. (optional) The name of the stem variable which\n*                 will be assigned the values from the record. If the\n*                 caller does not delimit the stem with a period,\n*                 one is generated.\n*\n*                 The REXX programmer should ensure that the value\n*                 specified for the call is enclosed in quotes.\n*\n*                 stem.0 is assigned the value of the number of\n*                 records read.\n*\n*                 If parameter 3 is not specified or specified as null,\n*                 SCCPDSR places the records in the data stack.\n*\n*              4. (optional; omit unless required)\n*                 The logical record length. More precisely\n*                 the length of each record returned to the caller.\n*\n*                 This is the equivalent of   rec.1 = left(rec.1,n)\n*\n*                 When not specified, the logical record length of the\n*                 dataset is used.\n*\n*              5. (optional; omit unless required)\n*                 The variable name to receive the value of the\n*                 directory entry associated with the member. The\n*                 value will be in the same format as from SCCPDSD.\n*\n* Notes:\n*    All the records of the member are read. The user should use\n*    alternative techniques (e.g. EXECIO) to read selelective\n*    records especially if the member contains many records.\n*\n*    There are mutually exclusive techniques to handle the data stack.\n*    Since the choice of a technique is subjective, SCCPDSR makes no\n*    choice. If stack isolation is required, an appropriate technique\n*    is the responsibilty of the calling program.\n         TITLE            '<< REXX - Read a PDS Member                 X\n                                                     System Linkage >>'\n         PRINT   GEN\nSCCPDSR  ID    R12\n         PRINT NOGEN\n         SPACE 2\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         ST    R13,SAVEAREA+4\n         LA    R15,SAVEAREA\n         ST    R15,8(,R13)\n         LR    R13,R15\n         XC    RC,RC\n         B     MAINLINE\n         SPACE 3\nRC       DS    0F\n         DS    AL1\nRC1      DS    AL1\nRC2      DS    AL1\nRC3      DS    AL1\n         SPACE 1\nSAVEAREA DS    18F\n         SPACE 3\nRTNXT    DS    0H\n         L     R13,SAVEAREA+4\n         XC    8(4,R13),8(R13)\n         XC    16(4,R13),16(R13)   R15 (return code) always\n         LM    R14,R12,12(R13)        get set to zero.\n         BR    R14\n         TITLE            '<< REXX - Read a PDS Member                 X\n                                                Parse the Arguments >>'\nMAINLINE DS    0H\n         USING EFPL,R1\n         USING ENVBLOCK,R8\n         USING IRXEXTE,R9\n         USING EVALBLOCK,R11\n         USING SHVBLOCK,R14\n         LR    R8,R0               Address the environment block.\n         L     R9,ENVBLOCK_IRXEXTE Address the REXX vector table.\n         LM    R10,R11,EFPLARG     Address ARGTABLE & EVALBLOCK.\n         L     R11,0(,R11)\n         MVI   TRTABLE-1,X'FF'     Pre-set table value.\n         MVI   DDNAME,C' '\n         MVC   DDNAME+1(L'DDNAME+L'MEMNAME+4-1),DDNAME\n         XC    SET_REGS(4),SET_REGS\n         XC    SHVNAMA-SHVBLOCK+@SHV,SHVNAMA-SHVBLOCK+@SHV\n         NI    PLIST384,X'7F'      Ensure end-of-plist is OFF.\n         LA    R0,LOCAL_BUFFER\n         ST    R0,SHVVALA-SHVBLOCK+@SHV\n         ST    R0,PLIST384+8\n         OI    PLIST384+8,X'80'    Presume we will pass 3 args to 384.\n         MVI   SW_384,DEFAULT_LEN\n         BAL   R14,STRIP           Strip out arg(1).\n         B     MISSING_DD          Arg(1) not specified.\n         LA    R0,7                Maximum length.\n         CR    R15,R0              Length(arg(1)) > maximum ?\n         BNH   *+6                    -no -\n         LR    R15,R0                 -yes-   Use maximum\n         EX    R15,MVC_DD          Pick-up the DDname.\n         SPACE 1\n         BAL   R14,STRIP           Strip out arg(2).\n         B     MISSING_MEM         Arg(2) not specified\n         LA    R0,11               Maximum length.\n         CR    R15,R0              Member name include TTR?\n         BL    *+16                   -no -\n         OI    SW_384,TTR@MEMBER   Say we have the TTR data.\n         EX    R15,MVC_MEM         Pick-up the member name.\n         B     GET_ARG3\n         SPACE 1\n         LA    R0,7                Maximum length.\n         CR    R15,R0              Length(arg(2)) > maximum ?\n         BNH   *+6                    -no -\n         LR    R15,R0                 -yes-   Use maximum\n         EX    R15,MVC_MEM         Pick-up the member name.\nGET_ARG3 DS    0H\n         BAL   R14,STRIP           Strip out arg(3).\n         B     GET_ARG4            Arg(3) not specified\n         LA    R5,6(,R15)          Maximum stem.tail length\n         LA    R0,244              Maximum length of variable stem.\n         SR    R0,R15              Calculate\n         LA    R2,VAR_NAME            address where\n         AR    R2,R0                     stem will be stored.\n         CLI   0(R4),C'.'          Does stem end with period?\n         BE    *+14                   -yes-\n         LA    R5,1(,R5)              -no -   adjust length,\n         BCTR  R2,0                              address and\n         MVI   TAIL-1,C'.'                          provide the period.\n         EX    R15,MVC_STEM        Pick-up the stem name.\n         ST    R2,SHVNAMA-SHVBLOCK+@SHV\n         ST    R5,SET_REGS+8       Now save (maximum) name length.\n         SPACE 1\nGET_ARG4 DS    0H\n         BAL   R14,STRIP           Strip out arg(4).\n         B     GET_ARG5            Arg(4) not specified\n         LA    R0,14               Maximum length I can handle.\n         CR    R15,R0              Too many digits?\n         BH    BAD_LENGTH             -yes-\n         LR    R0,R15              Hang onto the length.\n         LA    R15,112(,R15)       Set lengths\n         EX    R15,PACK1              to pack.\n         UNPK  LOCAL_BUFFER(15),DBLWD   Undo that pack.\n         LR    R15,R0              Calculate\n         LA    R0,14                  how many\n         SR    R0,R15                    (of 15)\n         LA    R2,LOCAL_BUFFER              high order digits\n         AR    R2,R0                           are insignificant.\n         EX    R15,NUMERIC_TEST    Does unpacked result = original?\n         BNE   BAD_LENGTH             -no -   i.e. not numeric\n         OI    SW_384,USER_LEN\n         CVB   R0,DBLWD            Requestor's\n         ST    R0,SHVVALL-SHVBLOCK+@SHV  record length.\n         C     R0,=F'256'\n         BNH   GET_ARG5\n       GETMAIN R,LV=(0)\n         ST    R1,SHVVALA-SHVBLOCK+@SHV\n         ST    R1,PLIST384+8\n         OI    PLIST384+8,X'80'\nGET_ARG5 DS    0H\n         XC    SHVNAMA-SHVBLOCK+@SHV2,SHVNAMA-SHVBLOCK+@SHV2\n         BAL   R14,STRIP\n         B     CALL1\n         NI    PLIST384+8,X'7F'\n         ST    R3,SHVNAMA-SHVBLOCK+@SHV2\n         LA    R15,1(,R15)\n         ST    R15,SHVNAML-SHVBLOCK+@SHV2\n         LA    R0,BLDL_LIST\n         ST    R0,PLIST384+12\n         OI    PLIST384+12,X'80'\n         TITLE            '<< REXX - Read a PDS Member                 X\n                      Call STSS384 and determine method of disposal >>'\nCALL1    DS    0H\n         LA    R1,PLIST384         Parameter list.\n         L     R15,VSS384          Entry point address.\n         TM    SW_384,TTR@MEMBER   User give me a TTR?\n         BZ    *+8                    -no -\n         L     R15,V@T2            Alternate entry point.\n         SPACE 1\n         BALR  R14,R15             Call.\n         LTR   R15,R15             Success?\n         BNZ   BAD_384                -no -\n         TM    PLIST384+8,X'80'    Need to provide dirctory entry?\n         BO    NO_DRCT1               -no -\n         IC    R15,BLDL_LIST+13    Get\n         N     R15,=F'31'             number of user halfwords\n         SLL   R15,1                     as bytes\n         LA    R15,14(,R15)                 plus fixed portion equals\n         ST    R15,SHVVALL-SHVBLOCK+@SHV2      directory length.\n         L     R15,IRXEXCOM        Get routine's address from vector.\n         LA    R0,ENVBLOCK         Make sure REXX knows environment.\n         LA    R1,PLIST_EXCOM2\n         BALR  R14,R15\nNO_DRCT1 DS    0H\n         L     R1,PLIST384+8       Get address\n         L     R10,0(,R1)             of STSS384 member\n         USING MEMNTRY0,R10              dsect and hence\n         L     R2,MEMADCB-1                 the address of\n         USING IHADCB,R2                       the DCB.\n         LH    R0,DCBLRECL         Get the real LRECL.\n         ST    R0,LRECL\n         TM    SW_384,USER_LEN     Does caller want that LRECL?\n         BO    *+8                       -no -\n         ST    R0,SHVVALL-SHVBLOCK+@SHV  -yes-\n         C     R0,SHVVALL-SHVBLOCK+@SHV  Is LRECL < callers request?\n         BH    SET@384                      -yes-  deblk via STSS384.\n         TM    MEMBER_SW,PACKED_MEMBER   Is the member ISRLEMX pressed.\n         BO    LENGTH@384                   -yes-  deblk via STSS384.\n         TM    DCBRECFM,DCBRECF    RECFM=F?\n         BZ    *+8                    -no -\n         OI    SW_384,DCBRECF         -yes-   Local reference\n         TM    DCBRECFM,DCBRECV    RECFM=V?\n         BZ    CALL384                -no-\n         OI    SW_384,DCBRECV         -yes-   Local reference\n         TM    SW_384,USER_LEN     Fixed output to caller?\n         BO    LENGTH@384             -yes-\n         LA    R0,SHVVALL-SHVBLOCK+@SHV  Tell STSS384 where to put\n         ST    R0,PLIST384+12               record length.\n         NI    PLIST384+8,X'7F'     Not 3\n         OI    PLIST384+12,X'80'       but 4 args to STSS384.\n         B     CALL384\nLENGTH@384     DS    0H\n         LA    R0,SHVVALL-SHVBLOCK+@SHV  Tell STSS384 where to put\n         ST    R0,PLIST384+12               record length.\n         NI    PLIST384+8,X'7F'     Not 3\n         OI    PLIST384+12,X'80'       but 4 args to STSS384.\nSET@384  DS    0H\n         OI    SW_384,DEBLOCK@384   Deblocking is to be done @ STSS384.\n         DROP  R2\nCALL384  DS    0H\n         TM    SW_384,DEBLOCK@384  Is STSS384 responsible for deblock?\n         BO    CALL384@               -yes-\n         TM    MEMBER_SW,DO_READ   Need a new block?\n         BZ    DEBLOCK                -no -\n         LA    R1,PLIST384         Parameter list.\n         L     R15,VSS384          Entry point address.\n         BALR  R14,R15             Call.\n         L     R2,SHVNAMA-SHVBLOCK+@SHV\n         LTR   R15,R15             Was non-normal condition raised?\n         BNZ   @EOF\nDEBLOCK  DS    0H\n         L     R2,SHVNAMA-SHVBLOCK+@SHV When 0, stack instead of stem.\n         L     R1,MEMAREC          Get address of logical record.\n         TM    SW_384,DCBRECU      RECFM=U?\n         BO    DEBLOCK_U              -yes-\n         L     R0,LRECL            Get real LRECL.\n         TM    SW_384,DCBRECV      RECFM=V?\n         BZ    VALL_SET               -no -\n         SR    R0,R0               Get\n         ICM   R0,3,0(R1)             LRECL of this record\n         S     R0,=F'4'                  reduce it by RDW length and\n         LA    R1,4(,R1)                    step over the RDW.\n         ST    R0,SHVVALL-SHVBLOCK+@SHV  Use the adjusted LRECL.\n         B     VALL_SET\nDEBLOCK_U  DS  0H\n         LH    R0,MEMBLKL\n         ST    R0,SHVVALL-SHVBLOCK+@SHV  Tell EXCOMM the value length.\nVALL_SET DS    0H\n         ST    R1,SHVVALA-SHVBLOCK+@SHV  Save address of logical record\n         AR    R1,R0               Point to next logical record\n         ST    R1,MEMAREC             and save that address.\n         LH    R0,MEMBLKL          Calculate address of\n         A     R0,MEMABLK             end-of-block.\n         CR    R0,R1               Reached end-of-block?\n         BH    STEM_OR_STACK          -no yet-\n         OI    MEMBER_SW,DO_READ      -yes-   Indicate block READ req.\n         B     STEM_OR_STACK       Go dispose of this record.\nCALL384@ DS    0H\n         TM    PLIST384,X'80'      Closing the DCB?\n         BO    @384                   -yes-\n         L     R15,SHVVALL-SHVBLOCK+@SHV\n         L     R14,PLIST384+8\n         LA    R14,0(,R14)\n         LA    R1,1\n         SLL   R1,30\n         LR    R0,R14\n         MVCL  R14,R0\n@384     DS    0H\n         LA    R1,PLIST384         Parameter list.\n         LA    R15,VSTSS384        Top-of-list\n         TM    SW_384,TTR@MEMBER   Caller provide a TTR'd member?\n         BZ    *+8                    -no -\n         LA    R15,8(,R15)            -yes- Use subset entry point\n         TM    SW_384,DEBLOCK@384  Does STSS384 do the deblocking?\n         BO    *+8                    -yes-\n         LA    R15,4(,R15)            -no - Use alternate entry point.\n         L     R15,0(,R15)         Entry point address.\n         BALR  R14,R15             Call.\n         TM    PLIST384,X'80'      Just closed the DCB?\n         BO    SET_EOF                -yes-\n         L     R2,SHVNAMA-SHVBLOCK+@SHV Get address of variable name.\n         LTR   R15,R15             Did call complete normally?\n         BZ    STEM_OR_STACK          -yes-\n@EOF     DS    0H\n         MVI   SW_384,DEBLOCK@384\n         ST    R15,RC              Save the return code for inspection.\n         CLI   RC3,12              End-of-file condition raised?\n         BNE   READ_ERROR             -no -  There was an error.\n         OI    PLIST384,X'80'      Tell STSS384 to close the DCB.\n         LTR   R2,R2               Disposal via variable name?\n         BZ    CALL384                -no -\n         MVI   TAIL,C'0'           Will be setting stem.0\n         L     R4,SET_REGS+8       Calculate\n         S     R4,=F'4'               length of variable name and\n         ST    R4,SHVNAML-SHVBLOCK+@SHV  tell EXCOM about it.\n         L     R0,SET_REGS         Get the record count\n         CVD   R0,DBLWD               into a\n         UNPK  LOCAL_BUFFER(5),DBLWD+5(3)  ebcidic\n         OI    LOCAL_BUFFER+4,X'F0'         format.\n         LA    R4,5                Maximum value length.\n         LA    R3,LOCAL_BUFFER     I start looking at the left.\n         LA    R14,*+4             Top-of-loop address.\n         CLI   0(R3),C'0'          High-order zero?\n         BNE   *+10                   -no -  all set\n         LA    R3,1(,R3)           Point to the next byte\n         BCTR  R4,R14              Decrement value length and loop.\n         SPACE 1\n         ST    R3,SHVVALA-SHVBLOCK+@SHV  Address of the value.\n         ST    R4,SHVVALL-SHVBLOCK+@SHV  Length of the value.\n         B     CALL_EXCOM@\nSTEM_OR_STACK  DS   0H\n         LTR   R2,R2\n         BZ    STACK\n         TITLE            '<< REXX - Read a PDS Member                 X\n                            Build the tail of the stemmed variable. >>'\n         LM    R2,R4,SET_REGS\n         LA    R2,1(,R2)           Count the records and\n         ST    R2,SET_REGS            save the count.\n         CVD   R2,DBLWD            Covert the count\n         UNPK  TAIL,DBLWD+5(3)        to ebcdic\n         OI    TAIL+4,X'F0'              format.\n         CLI   TAIL,C'0'           Any high-order zero?\n         BNE   BIG_TAIL               -no -   That was easy.\n         LA    R14,*+4             Top-of-loop address.\n         SPACE 1\n         CLI   0(R3),C'0'          (still) a high-order zero?\n         BNE   *+10                   -no -   Exit the loop.\n         LA    R3,1(,R3)           Point to next byte.\n         BCTR  R4,R14              Decrement name length and loop.\n         SPACE 1\n         MVC   TAIL,0(R3)\nBIG_TAIL DS    0H\n         ST    R4,SHVNAML-SHVBLOCK+@SHV\n         TITLE            '<< REXX - Read a PDS member                 X\n                Assign the value from the record to a REXX variable >>'\nCALL_EXCOM  DS  0H\n*\n* Refer to the IRXEXCOM routine; pages 312-319 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\nCALL_EXCOM@    DS  0H\n         L     R15,IRXEXCOM        Get routine's address from vector.\n         LA    R0,ENVBLOCK         Make sure REXX knows environment.\n         LA    R1,PLIST_EXCOM\n         BALR  R14,R15\n         B     CALL384\n         SPACE 1\nPLIST_EXCOM DC A(EXCOM_LIT,0,0)\n         DC    A(@SHV+X'80000000')\n         SPACE 1\n@SHV     DS    0A\n         DC    2A(0)\n         DC    C'S'\n         DS    XL3'000000'\n         DC    A(0,0,0,LOCAL_BUFFER,0)\n         SPACE 1\nPLIST_EXCOM2   DC     A(EXCOM_LIT,0,0)\n         DC    A(@SHV2+X'80000000')\n         SPACE 1\n@SHV2    DS    0A\n         DC    2A(0)\n         DC    C'S'\n         DS    XL3'000000'\n         DC    A(0,0,0,BLDL_LIST,0)\n         SPACE 1\nEXCOM_LIT DC   CL8'IRXEXCOM'\n         TITLE            '<< REXX - Read a PDS member                 X\n                     Subroutine to Strip Leading && Trailing Blanks >>'\n* Registers upon entry\n*    R10 ==> argument table entry\n*    R14 ==> exit address when agrument is null\n*    R14+4=> normal exit\n*\n* Registers upon exit\n*    R10 ==> next argument table entry.\n*    R2    = 0 (zero)\n*    R3  ==> leftmost non-blank byte of argument\n*    R4  ==> rightmost non-blank byte of argument\n*    R15   = R4 - R3 (length of argument minus 1)\n         SPACE 2\nHEXFF    DC    X'FFFFFFFFFFFFFFFF'\n         DS    XL1\nTRTABLE  DS    XL256\n         SPACE 1\nTRT3     TRT   0(0,R3),TRTABLE\n         SPACE 2\n         USING ARGTABLE_ENTRY,R10\nSTRIP    DS    0H\n         CLC   HEXFF,ARGTABLE_ARGSTRING_PTR  Is there an argument?\n         BER   R14                              -no -\n         L     R15,ARGTABLE_ARGSTRING_LENGTH\n         L     R3,ARGTABLE_ARGSTRING_PTR  Get address of argument.\n         LA    R10,ARGTABLE_NEXT   Point to next argument table entry.\n         SPACE 1\n         LTR   R15,R15             Does the argument have any length?\n         BZR   R14                    -NO - take abnormal exit.\n         LA    R4,0(R15,R3)        Point just beyond ARG.\n         MVC   TRTABLE,TRTABLE-1   Set to\n         MVI   TRTABLE+C' ',X'00'     bypass blanks.\n         BCTR  R15,0               Set length for TRT instruction.\n         EX    R15,TRT3            Skip to non-blank.\n         BZR   R14                 When all blank.\n         LR    R3,R1               Re-set starting address.\nSTRIP@R  DS    0H\n         BCTR  R4,0                Backpedal 1 byte.\n         CLI   0(R4),X'40'         (still) at a blanK?\n         BNE   STRIPPED               -no -\n         CR    R4,R3                  -yes-  More to inspect?\n         BH    STRIP@R                          -yes-\nSTRIPPED DS    0H\n         LR    R15,R4              Calculate\n         SR    R15,R3                 length of ARG - 1.\n         SR    R2,R2               Pre-clear R2 for TRT\n         XC    TRTABLE,TRTABLE     Clear translate table.\n         BC    15,4(,R14)          Take normal exit.\n         TITLE            '<< REXX - Read a PDS Member                 X\n                                   Put the record on the data stack >>'\n*\n* Refer to the IRXSTK   routine; pages 485-490 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\nSTK_FUNC DC    CL8'QUEUE   '\nSTK_PLIST  DC  A(STK_FUNC)\n         DC    A(SHVVALA-SHVBLOCK+@SHV)\n         DC    A(SHVVALL-SHVBLOCK+@SHV)\n         DC    A(RC+X'80000000')\n         SPACE 2\nSTACK    DS    0H\n         LA    R1,STK_PLIST\n         LA    R0,ENVBLOCK\n         L     R15,IRXSTK\n         BALR  R14,R15\n         B     CALL384\n         TITLE            '<< REXX - Read a PDS Member                 X\n                                                   Error Conditions >>'\n*\n* Refer to the IRXSAY   routine; pages 336-339 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\nSAY_LIT        DC    CL8'WRITE   '\nSAY_BUFF       DS    A\nSAY_LEN        DS    F\nSAY_PLIST      DC    A(SAY_LIT,SAY_BUFF,SAY_LEN+X'80000000')\nMISSING_DD_MSG DC    C'First argument (DDNAME) missing.'\nMISSING_MEM_MSG DC   C'Second argument (member name) missing.'\nBAD_LENGTH_MSG DC    C'Fourth argument not numeric or too large.'\nBAD_384_MSG    DC    C'Error in STSS384. Check ''result''.'\n               SPACE 2\nMISSING_DD     DS    0H\n         LA    R15,MISSING_DD_MSG\n         LA    R0,L'MISSING_DD_MSG\n         B     SAY_CALL\nMISSING_MEM    DS    0H\n         LA    R15,MISSING_MEM_MSG\n         LA    R0,L'MISSING_MEM_MSG\n         B     SAY_CALL\nBAD_LENGTH     DS    0H\n         LA    R15,BAD_LENGTH_MSG\n         LA    R0,L'BAD_LENGTH_MSG\n         B     SAY_CALL\nSAY_CALL DS    0H\n         ST    R15,SAY_BUFF\n         ST    R0,SAY_LEN\n         LA    R1,SAY_PLIST\n         LA    R0,ENVBLOCK\n         L     R15,IRXSAY\n         BALR  R14,R15\n         L     R13,SAVEAREA+4\n         XC    8(4,R13),8(R13)\n         LM    R14,R12,12(R13)\n         LA    R15,40\n         BR    R14\n         SPACE 2\nBAD_384  DS    0H\n         CVD   R15,DBLWD           Convert the return code.\n         LA    R0,BAD_384_MSG\n         ST    R0,SAY_BUFF\n         LA    R0,L'BAD_384_MSG\n         ST    R0,SAY_LEN\n         LA    R1,SAY_PLIST\n         LA    R0,ENVBLOCK\n         L     R15,IRXSAY\n         BALR  R14,R15\n         B     SET_RC\n         TITLE            '<< REXX - Read a PDS Member                 X\n                                                 Exits back to REXX >>'\nSET_EOF  DS    0H\n         LA    R15,0\nREAD_ERROR DS  0H\n         CVD   R15,DBLWD           Convert the return code\nSET_RC   DS    0H\n         UNPK  EVALBLOCK_EVDATA(3),DBLWD+6(2)  into\n         OI    EVALBLOCK_EVDATA+2,X'F0'         ebcidic format.\n         LA    R2,3                Length of the return code is 3.\n         ST    R2,EVALBLOCK_EVLEN  Let REXX know the length.\n         SPACE 2\n         L     R0,SHVVALL-SHVBLOCK+@SHV  The length of the values\n         C     R0,=F'256'                   to see if we did a GETMAIN.\n         BNH   RTNXT               No we didn't.\n         L     R1,SHVVALA-SHVBLOCK+@SHV Area to be freed.\n      FREEMAIN R,LV=(0),A=(1)\n         B     RTNXT               All done.\n         TITLE            '<< REXX - Read a PDS Member                 X\n                                              Global Data Constants >>'\n         SPACE 2\nDBLWD    DS    D\n         SPACE 2\nSET_REGS DC    A(0,TAIL,0)\n         SPACE 1\nVSTSS384 DC    V(STSS384)\nVSS384   DC    V(SS384)\nV@T1     DC    V(SS384@T1)\nV@T2     DC    V(SS384@T2)\n         SPACE 1\nPLIST384 DC    A(DDNAME,MEMNAME,LOCAL_BUFFER+X'80000000',0)\nDDNAME   DC    CL8' '\nMEMNAME  DC    CL8' '\n         DS    CL4                 Reserved for TTR data.\nMVC_DD   MVC   DDNAME(0),0(R3)\nMVC_MEM  MVC   MEMNAME(0),0(R3)\nMVC_STEM MVC   0(0,R2),0(R3)\nPACK1    PACK  DBLWD(0),0(0,R3)\nNUMERIC_TEST   CLC   0(0,R3),0(R2)\n         SPACE 2\nVAR_NAME DS    0CL250\n         DS    CL245\nTAIL     DS    CL5\n         SPACE 2\nSW_384   DC      X'00'\nDEFAULT_LEN    EQU   X'00'\nUSER_LEN       EQU   X'01'\nDEBLOCK@384    EQU   X'08'\nTTR@MEMBER     EQU   X'10'\n         SPACE 2\n         DS    0D\n         DC    CL8' '\nLOCAL_BUFFER   DS    0CL256\n         DS    F\nLRECL    DS    F\n         DS    CL248               248 = 256-(*-LOCAL_BUFFER)\n         SPACE 2\nBLDL_LIST      DS    CL60\n         SPACE 2\n         LTORG\n         TITLE            '<< REXX Read a PDS member record            X\n                                                 DSECTs and EQUates >>'\n         YREGS\n         SPACE 2\n       IRXENVB\n         SPACE 2\n       IRXEXTE\n         SPACE 2\n       IRXSHVB\n         SPACE 2\n       IRXEFPL\n         SPACE 2\n      IRXARGTB\n         SPACE 2\n      IRXEVALB\n         SPACE 2\n         DCBD  DSORG=(PO),DEVD(DA)\n         SPACE 2\nMEMNTRY0 DSECT\nMEMNAME0 DS    CL8\n         DS    2A\n         DS    AL1\nMEMADCB  DS    AL3\nMEMABLK  DS    F\n         DS    AL1\n         DS    AL3\nMEMAREC  DS    F\n         DS    F\nMEMBLKL  DS    H\nMEMBER_SW      DS    XL1\nNEW_MEMBER     EQU  X'80'\nPACKED_MEMBER  EQU  X'40'\nOVERFLOW       EQU  X'20'\nDE_ACTIVE      EQU  X'08'\nDO_READ        EQU  X'04'\n         DS    0D\nMEMNTRY  EQU   *-MEMNAME0\n         END   SCCPDSR\n./ ADD NAME=STSS384  0100-01157-01157-1457-00827-00827-00000-PST0705\nSS384    TITLE                     'Read PDS member(s)                 x\n                                                         Documentation'\n* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *\n*\n* Program name :  STSS384\n*\n* Function:       Get the next logical record from a library member.\n*                 The \"get\" process will include explosion of\n*                 compressed data for ISPF, WYLBUR and YSLIM depending\n*                 on the value of the DDNAME specified with the CALL.\n*\n*                 Note that a caller can have multiple members in\n*                 process simultaneously.\n*\n* Parameters:  1. The DDNAME representing the library of the member.\n*                 The values of   WYLn   and   YSLIMn\n*                 have special meaning in that they must be used to\n*                 to decompress WYLBUR or YSLIM members.\n*\n*              2. (optional) Member name within the library that is to\n*                 be read. If not specified, the areas associated with\n*                 specfied DDname are released/closed.\n*\n*              3. (required unless parameter 2 is not specified.)\n*                 Area where the read data is to be placed.\n*\n*              4. (optional) Fullword to receive the length of the\n*                 record.\n*\n* Entry points    The 4 entry points are used for the 4 combinations\n*                 of whether or not the member name includes TTR data\n*                 and whether or not this routine is responsible for\n*                 de-blocking the data.\n*\n*                 De-block here?   TTR data with member?\n*\n*         STSS384     yes             no\n*         SS384       no              no\n*         SS384@T1    yes             yes\n*         SS384@T2    no              yes\n*\n*\n* Updates:\n*     Feb. 1995  - Include decompression of ISPF packed data.\n*     R. Ryerse\n*\n*     Jun. 1995  - Ensure AMODE 31 (after FIND macro).\n*     R. Ryerse  - Make parameter 2 optional; include close of DCB.\n*\n*     Jul. 1995  - Remove limitation of DDNAME values.\n*     R. Ryerse  - Build the DCBs dynamically (below the line).\n*                - Repair tests for DCBRECV.\n*                - Add entry point SS384.\n*                - Research RMODE=ANY\n*                - Incorporate use of parameter 4\n*\n*     Dec. 1995  - Include ENTRY points and remove call to STSS383. By\n*                  excluding STSS383, use of the FIND macro now depends\n*                  on whether or not the caller provides TTR data with\n*                  the member name. With TTR data a type C FIND is\n*                  used, without TTR data a type D FIND is used.\n* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *\n         TITLE                     'Read PDS member(s)                 x\n                                               Initialization per call'\n         PRINT NOGEN\n*\n* RMODE=24 is required. If STSS384 were to execute above the line,\n* the routines referenced off the DCB (FIND, READ, CHECK) will\n* not return. They switch to AMODE=24 and don't switch back.\n*\nSTSS384  ID    R12,AMODE=31,RMODE=24\n         USING IHADCB,R10\n         USING DDNTRY0,R6\n         USING MEMNTRY0,R2\n         USING FREENTRY,R4\n         ENTRY SS384\n         ENTRY SS384@T1\n         ENTRY SS384@T2\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         ST    R13,SAVEAREA+4\n         LA    R15,SAVEAREA\n         ST    R15,8(,R13)\n         LR    R13,R15\n         MVI   ENTRY_SW,YES_DEBLOCK\n         B     START\n         SPACE 2\nSS384    DS    0F\n         DROP  R12\n         USING *,R15\n         STM   R14,R12,12(R13)\n         L     R12,VSTSS384\n         DROP  R15\n         USING STSS384,R12\n         ST    R13,SAVEAREA+4\n         LA    R15,SAVEAREA\n         ST    R15,8(,R13)\n         LR    R13,R15\n         MVI   ENTRY_SW,NO_DEBLOCK\n         B     START\n         SPACE 2\nSS384@T1 DS    0F\n         DROP  R12\n         USING *,R15\n         STM   R14,R12,12(R13)\n         L     R12,VSTSS384\n         DROP  R15\n         USING STSS384,R12\n         ST    R13,SAVEAREA+4\n         LA    R15,SAVEAREA\n         ST    R15,8(,R13)\n         LR    R13,R15\n         MVI   ENTRY_SW,YES_DEBLOCK+TTR_MEMBER\n         B     START\n         SPACE 2\nSS384@T2 DS    0F\n         DROP  R12\n         USING *,R15\n         STM   R14,R12,12(R13)\n         L     R12,VSTSS384\n         DROP  R15\n         USING STSS384,R12\n         ST    R13,SAVEAREA+4\n         LA    R15,SAVEAREA\n         ST    R15,8(,R13)\n         LR    R13,R15\n         MVI   ENTRY_SW,NO_DEBLOCK+TTR_MEMBER\n         B     START\n         SPACE 2\nVSTSS384 DC    V(STSS384)\nSAVEAREA DS    18F\n         SPACE 1\nFULLRC   DS    0F\n         DC    XL3'000000'\nRC       DC    X'00'\n         SPACE 3\nRTNXT    DS    0H\n         L     R15,FULLRC\n         L     R13,SAVEAREA+4\n         XC    8(4,R13),8(R13)\n         L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n         TITLE                     'Read PDS member(s)                 x\n                                                      Match/set DDNAME'\nSTART    DS    0H\n         ST    R1,APARMS             Save my plist address.\n         XC    FULLRC,FULLRC         Pre-clear my return code.\n         LM    R3,R5,0(R1)           Address callers 3 parameters.\n         LA    R5,0(,R5)             Clear high order bit.\n         LA    R6,DDTBL-DDNTRY       Get ready to search DD entries.\nFIND_DDNAME DS 0H\n         LA    R6,DDNTRY(,R6)        Point to next DD entry.\n         CLC   DDNAME0,0(R3)         Matched the caller's DDname?\n         BE    OPENED                   -yes-\n         CLC   DDNAME0,BLANK15       Any more DD entries?\n         BE    BUILD_DCB                -no - Build a new entry\n         C     R6,=A(DDLAST)         At the end of the DD table?\n         BL    FIND_DDNAME              -not yet-   Keep looking.\n         WTO   MF=(E,ABNDMSG1)\n         ABEND 384,DUMP,STEP\nABNDMSG1 DS    0F\n         DC    AL2(MSG1L),XL2'8000',C'STSS384  :  '\n         DC    C'Too many DDnames.'\nMSG1L    EQU   *-ABNDMSG1\n         DC    X'04000020'\n         SPACE 1\nBUILD_DCB  DS  0H\n         ST    R6,LAST_DD_ENTRY     Remember what entry I am at.\n         MVC   DDNAME0,0(R3)        Get the DDname.\n         LA    R0,DCBLNGPO          How much space we need\n       GETMAIN RU,LV=(0),LOC=BELOW     to hold the DCB\n         LR    R10,R1               Base register for DCB\n         ST    R10,DDADCB0          Save that address in the DD entry.\n         MVC   IHADCB(DCBLNGPO),A_DCB   Copy the DCB.\n         MVC   DCBDDNAM,DDNAME0     Use the caller's DDname.\n         CLC   =CL5'YSLIM',DDNAME0  Special DDname?\n         BE    SET_RECFM@U             -yes-\n         CLC   =CL3'WYL',DDNAME0    Special DDname?\n         BE    SET_RECFM@U             -yes-\n         B     *+8                     -no -\nSET_RECFM@U DS 0H\n         MVI   DCBRECFM,DCBRECU     Special DDnames are RECFM=U.\n         OPEN  ((R10)),MODE=31\n*        MVI   DCBKEYLE,0\n         B     NEWMEM\nCLOSE    DS    0H\n         LH    R15,DCBBLKSI         Use blocksize\n         LA    R15,15(,R15)            to calculate\n         SRL   R15,3                      amount\n         SLL   R15,3                         of storage\n         LR    R0,R15                           for FREEMAIN's.\n         LA    R4,DDAFREE           Anchor the chain.\nFREE_LOOP  DS  0H\n         L     R4,FREENXT           Another\n         LTR   R4,R4                   link?\n         BZ    CLOSE_DCB                 -no -\n         L     R2,FREEADDR          Get address to be freed.\n         XC    FREEADDR,FREEADDR    Make the entry available.\n*  Note that FREENXT is not cleared; without an anchor\n*  the link (address) is meaningless. The anchor is released below.\n      FREEMAIN R,LV=(R0),A=(R2)\n         B     FREE_LOOP            Go get next link in the chain.\n         SPACE 1\nCLOSE_DCB  DS  0H\n         CLOSE ((R10)),MODE=31\n         LA    R0,DCBLNGPO\n      FREEMAIN R,LV=(R0),A=(R10)\n         L     R1,LAST_DD_ENTRY      Is this\n         CR    R1,R6                    the last DD table entry?\n         BE    *+12                        -yes-\n         MVC   DDNTRY0(DDNTRY),0(R1)       -no - last entry goes here\n         LR    R6,R1                                and switch.\n         SPACE 1\n         XC    DDNTRY0(DDNTRY),DDNTRY0\n         MVC   DDNAME0,BLANK15       Clear the last DD table entry.\n         B     RTNXT                 All done.\n         TITLE                     'Read PDS member(s)                 x\n                                                 Match/set member name'\nOPENED   DS    0H\n         L     R10,DDADCB0           Get the DCB address.\n         TM    0(R1),X'80'           Caller requesting 'close'?\n         BO    CLOSE                    -yes- Honor the request.\n         LA    R2,MEMTBL             Point to 1st member table entry.\n         CLC   MEMNAME0,0(R4)        Right member name?\n         BNE   MEMATCH                  -no -\n         SR    R0,R0                 Get\n         ICM   R0,7,MEMADCB             DCB address for this entry.\n         CR    R10,R0                Right DCB\n         BE    ALLMATCH                 -yes-  We have the right entry.\nMEMATCH  DS    0H\n         LA    R2,MEMNTRY(,R2)       Point to next member entry.\n         CLC   MEMNAME0,0(R4)        Right member name?\n         BNE   *+16                     -no -\n         SR    R0,R0                 Get\n         ICM   R0,7,MEMADCB             DCB address for this entry.\n         CR    R10,R0                Right DCB\n         BE    ALLMATCH                 -yes-  We have the right entry.\n         SPACE 1\n         C     R2,=A(MEMLAST)        At last table entry?\n         BL    MEMATCH                  -not yet-  keep looping\n         SPACE 2\nNEWMEM   DS    0H\nMEMHIT   DS    0H\n         LA    R2,MEMTBL-MEMNTRY\n         LA    R2,MEMNTRY(,R2)\n         CLI   MEMBER_SW,DE_ACTIVE\n         BE    MEM2TBL\n         C     R2,=A(MEMLAST)\n         BL    MEMHIT+4\n         WTO   'STSS384  :  No room in member name table. Run aborted',x\n               ROUTCDE=(11),DESC=(6)\n         ABEND 384,DUMP,STEP\nMEM2TBL  DS    0H\n         ST    R4,SAVE25+8          Save R4.\n         LA    R4,DDAFREE           Get 'free chain' anchor.\n         L     R1,FREENXT           Is the\n         LTR   R1,R1                   chain anchored?\n         BP    MEM2TBL2                   -yes-  Go find the last link.\n         LH    R15,DCBBLKSI         Use blocksize\n         LA    R15,15(,R15)            to calculate\n         SRL   R15,3                      amount\n         SLL   R15,3                         of storage\n         LR    R0,R15                           for GETMAIN.\n       GETMAIN R,LV=(0),LOC=BELOW\n         B     GOTMAIN\nMEM2TBL2 DS    0H\n         LR    R0,R4                Address of previous link.\n         LR    R4,R1                Step along. (R1 already loaded.)\n         L     R1,FREENXT           Another\n         LTR   R1,R1                   link yet?\n         BP    MEM2TBL2                   -no -  keep looking.\n         L     R1,FREEADDR          Use GETMAIN'd address.\n         XC    FREEADDR,FREEADDR       but make it unavailable.\n         LR    R4,R0                Drop\n         XC    FREENXT,FREENXT         the last link.\nGOTMAIN  DS    0H                   Build table entry for the member.\n         L     R4,SAVE25+8\n         XC    MEMDECB,MEMDECB      Pre-clear the DECB\n         MVC   MEMNAME0,0(R4)       Member name\n         MVI   MEMBER_SW,DO_READ+NEW_MEMBER  (DECB) READ types\n         LA    R1,0(,R1)\n         ST    R1,MEMABLK           (DECB) data address\n         TM    ENTRY_SW,TTR_MEMBER\n         BZ    FIND@D\n         LA    R0,8(,R4)\n*        FIND  (R10),(R0),C\n         MVC   DCBRELAD,8(R4)\nFIND@C   DS    0H\n         LR    R1,R10\n         LR    R0,R10\n         SR    R15,R15\n         ICM   R15,7,DCBCNTRL+1\n         BAL   R14,4(0,R15)\n         L     R14,AMODE31\n         BSM   0,R14\nFIND@D   DS    0H\n         TM    ENTRY_SW,NO_DEBLOCK Do I do the deblocking?\n         BZ    FIND@D1                -no -   Don't do BLDL\n         L     R1,APARMS           Did caller provide\n         TM    8(R1),X'80'            more than 3 parms?\n         BO    FIND@D1                   -no -   Don't do BLDL\n         PRINT GEN\n         L     R11,12(,R1)         Get address of parm 4.\n         LA    R0,1                Need 1\n         STH   R0,0(,R11)             as value for BLDL FF field.\n         LA    R0,58               Need 58\n         STH   R0,2(,R11)             as value for BLDL LL field.\n         MVC   4(8,R11),MEMNAME0\n         LR    R0,R11              R0 as list address.\n         LA    R1,0(,R10)          R1 as DCB address.\n*        BLDL  (1),(0)             Get the directory entry.\n         SLR   R15,R15\n         SVC   18\n         L     R14,AMODE31\n         LTR   R15,R15             Success?\n         BZ    *+6                    -yes-\n         BSM   0,R14                  -no -\n         MVC   0(58,R11),4(R11)    Drop prefix from BLDL list.\n         MVC   DCBRELAD,8(R11)     Preamble of FIND type \"C\".\n         B     FIND@C\nFIND@D1  DS    0H\n*        FIND  (R10),(R4),D\n         LCR   R1,R10\n         LR    R0,R4\nSVC18    DS    0H\n         SVC   18\n         PRINT NOGEN\n         L     R14,AMODE31\n         BSM   0,R14\nAMODE31  DC    A(AMODE31+X'80000004')\n         LTR   R15,R15\n         BZ    ALLMATCH\n         ST    R15,FULLRC\n         CVD   R15,DBLWD\n         MVC   WARN1RC,=X'40202120'\n         ED    WARN1RC,DBLWD+6\n         WTO   MF=(E,WARN1MSG)\n         B     RTNXT\n         TITLE                     'Read PDS member(s)                 x\n                                                          Read (PIOCS)'\nALLMATCH DS    0H\n         TM    MEMBER_SW,DO_READ     (Physical) read required?\n         BZ    DEBLOCK                  -no - Go get data from buffer.\n         NI    MEMBER_SW,255-DO_READ Turn off the indicator.\nREAD     DS    0H\n         LA    R7,MEMDECB            Address\n         USING DECB,R7                  the DECB.\n         MVI   DECTYPE1,DECLNS       Set the\n         MVI   DECTYPE2,DECRDSF         DECB type.\n         ST    R10,DECDCBAD          Put the DCB address into the DECB.\n         LR    R1,R7                 R1 = A(DECB)\n         SR    R15,R15               Make sure high-order byte is clear\n         ICM   R15,7,DCBREADA           for the READ address\n         BALR  R14,R15               READ (completed by CHECK below.)\n         LR    R1,R7                 R1 = A(DECB)\n         SR    R15,R15               Make sure high-order byte is clear\n         ICM   R15,7,DCBCHCKA           for CHECK address.\n         BALR  R14,R15               CHECK completes READ.\n         L     R9,DECIOBPT           Address\n         USING IOBSTDRD,R9              the IOB.\n         LH    R1,DCBBLKSI           BLKSIZE\n         SH    R1,IOBCSW+5              minus short fall\n         STH   R1,MEMBLKL                  equals size of the block.\n         DROP  R9\n         DROP  R7\n         L     R1,MEMABLK            Address of the block.\n         TM    DCBRECFM,DCBRECU      RECFM=U?\n         BO    *+16                     -yes-\n         TM    DCBRECFM,DCBRECV      RECFM=V?\n         BZ    *+8                      -no -\n         LA    R1,4(,R1)                -yes- step over block length.\n         ST    R1,MEMAREC            Address of (1st) record.\n         TITLE                     'Read PDS member(s)                 x\n                                What type of deblocking is to be used?'\n         TM    MEMBER_SW,OVERFLOW    Handling a buffer wrap?\n         BZ    NOT_FLOWING              -no -\n         L     R7,MEM_FLOWAREA       Address of iterim area.\n         L     R9,0(,R7)             Get length of interim area.\n         L     R14,4(,R7)            Length already used\n         LA    R14,8(,R14)              plus 8\n         SR    R9,R14                      subtracted from total length\n         BCTR  R9,0                  Fill the interim area\n         EX    R9,NEWFLOW               from the new buffer.\n         LR    R8,R7                 Calculate\n         A     R8,0(,R7)                \"dummy\" end-of-buffer address.\n         LH    R0,DCBLRECL           Calculate\n         AR    R0,R5                    end-of take-up address.\n         SR    R1,R1                 Needs to be clear.\n         LA    R7,8(,R7)             Address of data to be unpacked.\n         B     UNPACK                Unpack the interim area.\nNEWFLOW  MVC   0(0,R8),0(R1)\n         SPACE 1\nNOT_FLOWING  DS  0H\n         TM    MEMBER_SW,PACKED_MEMBER  Are we (already) unpacking?\n         BZ    *+12                        -no -\n         LA    R7,0(,R1)                   -yes- Get data address and\n         B     SET_E_O_B                            go unpack.\n         SPACE 1\n         TM    MEMBER_SW,NEW_MEMBER  Just read 1st block?\n         BZ    DEBLOCK                  -no -\n         NI    MEMBER_SW,255-NEW_MEMBER  Turn off 1st read indicator.\n         CLC   =CL3'WYL',DDNAME0     Reading a 'normal' PDS?\n         BE    DEBLOCK                  -no -\n         CLC   =CL5'YSLIM',DDNAME0   Reading a 'normal' PDS?\n         BE    DEBLOCK                  -no -\n         TM    DCBRECFM,DCBRECV      RECFM=V?\n         BZ    *+8                      -no -\n         LA    R1,8(,R1)                -yes- Get address of data.\n         CLC   =XL3'000140',0(R1)    Is member packed?\n         BNE   DEBLOCK                  -no -\n         OI    MEMBER_SW,PACKED_MEMBER  Indicate packed member.\n         LH    R8,6(,R1)             Get lrecl as per packing.\n         LA    R8,8+8(,R8)           8 bytes for my areas plus 8 more\n*                                       for inserted control bytes.\n         LA    R1,8(,R1)             Bypass the header information and\n         ST    R1,MEMAREC               save the data address.\n         SRL   R8,3\n         SLL   R8,3\n         LR    R0,R8\n       GETMAIN R,LV=(R0),LOC=BELOW\n         ST    R1,MEM_FLOWAREA\n         ST    R8,0(,R1)\n         SPACE 1\nDEBLOCK  DS    0H\n         TM    ENTRY_SW,NO_DEBLOCK   Caller want blocked data?\n         BZ    *+12                     -no -\n         ST    R2,0(,R5)                -yes-   Give the mem tbl ntry\n         B     RTNXT                               and exit\n         L     R7,MEMAREC            Get address of data (source).\n         CLC   =CL3'WYL',DDNAME0     WYLBUR dataset?\n         BE    WYLBLK                   -yes-   special handling.\n         CLC   =CL5'YSLIM',DDNAME0   YSLIM dataset?\n         BE    YSLIMBLK                 -yes-   specila handling.\n         TM    MEMBER_SW,PACKED_MEMBER  Packed member?\n         BZ    NOT_PACKED                  -no -\n         TITLE                     'Read PDS member(s)                 x\n                                                       (PDF) Unpacking'\nSET_E_O_B  DS  0H\n         LR    R8,R5                 Calculate\n         AH    R8,DCBLRECL               end-of-record address.\n         CLI   0(R7),X'FF'           End-of-member?\n         BE    EOMEM                    -yes-\n         LR    R0,R8                 Use R0 for end-of-output address.\n         L     R8,MEMABLK            Calculate address of\n         AH    R8,MEMBLKL               the end of the block.\n         SR    R1,R1                 Clear a work register.\nUNPACK   DS    0H\n         CR    R7,R8                 At end-of-block?\n         BL    UNPACK1                  -not yet- Keep unpacking.\n         BH    START_WRAP               -beyond - Buffer wrapping.\n         CR    R0,R5                 At end of (output) record?\n         BH    START_WRAP               -not yet- Buffer wrapping.\n         ST    R7,MEMAREC               -yes-  Save data address and\n         B     DEBLKXT                            exit deblocking\nSTART_WRAP  DS  0H\n         OI    MEMBER_SW,OVERFLOW    Need an 'buffer wrap' indicator.\n         LR    R5,R0                 Point to\n         SH    R5,DCBLRECL              caller's receiving area.\n         L     R1,MEM_FLOWAREA       Get address of interim area.\n         L     R9,MEMAREC            Re-do for entire logical record.\n         SR    R8,R9                 How much in the exhausted buffer.\n         ST    R8,4(,R1)             Save that length.\n         BCTR  R8,0                  Move the residual\n         EX    R8,OLDFLOW               from the exhauted buffer.\n         LA    R8,9(R1,R8)           Data from new buffer goes here.\n         B     READ                  Go read next buffer.\nOLDFLOW  MVC   8(0,R1),0(R9)\nUNPACK1  DS    0H\n         CR    R0,R5                 At end of (output) record?\n         BH    *+12                     -not yet-\n         ST    R7,MEMAREC               -yes-  Save data address and\n         B     DEBLKXT                            exit deblocking\n         SPACE 1\n         IC    R1,0(,R7)             Get instruction length\n         N     R1,=F'127'               never > 127\n*\n         CLI   0(R7),X'7A'           At a repeating character?\n         BNE   NOT_REPEATER             -no -\n         LA    R14,3(,R7)            Address of next area to unpack.\n         CR    R14,R8                Beyond the end of the buffer?\n         BH    START_WRAP               -yes-\n         IC    R1,1(,R7)             Get repetition count and\n         MVC   0(1,R5),2(R7)            repeating character.\n         LR    R7,R14                Point to next (source) data.\nDUPLICATE  DS  0H\n         BCTR  R1,0                  Get instr. len. from rept'n\n         EX    R1,REPEATER           Repeat the character.\n         LA    R5,2(R1,R5)           Point to next receiver addr.\n         B     UNPACK                Loop back\nREPEATER MVC  1(0,R5),0(R5)\n         SPACE 1\nNOT_REPEATER  DS 0H\n         CLI   0(R7),X'7C'           End-of-record indicator?\n         BNE   NOT_END_OF_REC           -no -\n         TM    DCBRECFM,DCBRECF      RECFM=F?\n         BO    NOT_DATA                 -yes-\n         LR    R0,R5                 Indicate end-of-record.\n         LA    R7,1(,R7)             Point at next source data.\n         B     UNPACK                Loop back.\n         SPACE 1\nNOT_END_OF_REC  DS   0H\n         TM    0(R7),X'80'           Data to be move?\n         BZ    NOT_DATA                 -no -\n         LA    R14,2(R1,R7)          Address of next area to unpack.\n         CR    R14,R8                Beyond the end of the buffer?\n         BH    START_WRAP               -yes-\n         EX    R1,SIMPLE_MOVE        Move that chunk.\n         LA    R5,1(R1,R5)           Re-set target address.\n         LR    R7,R14                Re-set source address.\n         B     UNPACK                Loop back.\nSIMPLE_MOVE MVC  0(0,R5),1(R7)\n         SPACE 1\nNOT_DATA DS    0H\n         MVI   0(R5),X'40'           Must be padding with blanks.\n         CLI   0(R7),X'00'           One byte of space?\n         LA    R7,1(,R7)                -anyway- Re-set source address.\n         BNE   DUPLICATE                -no    - Duplicate\n         LA    R5,1(,R5)                -yes-    Re-set target address\n         B     UNPACK                               and Loop back.\n         TITLE                     'Read PDS member(s)                 x\n                                                Clear text de-blocking'\nNOT_PACKED  DS 0H\n         STM   R2,R5,SAVE25          Save the registers\n         LH    R3,DCBLRECL           Get the LRECL\n         LA    R4,0(,R7)             Address the record\n         LR    R2,R5                 Move 'to' address\n         TM    DCBRECFM,DCBRECF      RECFM=V (not RECFM=F or RECFM=U)\n         BO    *+16                     -no -\n         ICM   R3,3,0(R7)            Get RDW from the record.\n         SH    R3,=H'4'              Calculate the length of the data.\n         LA    R4,4(,R7)             Address the data.\n         SPACE 1\n         L     R1,APARMS             Address the parm list given to me.\n         TM    8(R1),X'80'           Two parms?\n         BO    *+12                     -yes-\n         L     R1,12(,R1)               -no -  Address parm 3 and\n         ST    R3,0(,R1)                          put LRECL there.\n         SPACE 1\n         LR    R5,R3                 Move 'from' length = 'to' length.\n         MVCL  R2,R4                 Give caller his copy of the rec.\n         L     R2,SAVE25             Restore addressablity.\n         ST    R4,MEMAREC            Address of next logical record.\n         LM    R3,R5,SAVE25+4        Restore the other registers.\n         B     DEBLKXT               Almost done.\n         TITLE                     'Read PDS member(s)                 x\n                                             WYLBUR deblocking routine'\nBLANK15  DC    CL15'               '\n         SPACE 3\nWYLBLK   DS    0H\n         CLC   MEMABLK,MEMAREC\n         BNE   *+8\n         LA    R7,2(,R7)\n         CLI   4(R7),X'00'\n         BNE   *+26\n         MVI   0(R5),X'40'\n         MVC   1(79,R5),0(R5)\n         LA    R7,5(,R7)\n         ST    R7,MEMAREC\n         B     WYLBLK2\n         SPACE 1\n         SR    R8,R8\n         IC    R8,4(,R7)\n         LA    R8,5(R7,R8)\n         ST    R8,MEMAREC\n         SR    R1,R1\n         LA    R7,5(,R7)\nWYLBLK1  DS    0H\n         IC    R1,0(,R7)\n         SRA   R1,4\n         LR    R14,R1\n         BZ    *+20\n         BCTR  R1,0\n         STC   R1,*+5\n         MVC   0(1,R5),BLANK15\n         LA    R5,1(R1,R5)\n         SPACE 1\n         IC    R1,0(,R7)\n         SLL   R14,4\n         SR    R1,R14\n         BZ    *+24\n         BCTR  R1,0\n         STC   R1,*+5\n         MVC   0(1,R5),1(R7)\n         LA    R5,1(R1,R5)\n         LA    R7,1(R1,R7)\n         SPACE 1\n         LA    R7,1(,R7)\n         CR    R7,R8\n         BL    WYLBLK1\nWYLBLK2  DS    0H\n         L     R8,MEMABLK\n         AH    R8,0(,R8)\n         CR    R7,R8\n         BL    RTNXT\n         OI    MEMBER_SW,DO_READ     (Physical) read required.\n         B     RTNXT\n         TITLE                     'Read PDS member(s)                 x\n                                              YSLIM deblocking routine'\nYSLIMBLK DS    0H\n         LA    R15,72(,R5)\n         MVI   0(R5),X'40'\n         MVC   1(79,R5),0(R5)\n         SR    R1,R1\n         CLI   0(R7),X'00'\n         BE    YSLIMB8\nYSLIMB1  DS    0H\n         IC    R1,0(,R7)\n         SRL   R1,4\n         LR    R14,R1\n         AR    R5,R1\n         IC    R1,0(,R7)\n         SLL   R14,4\n         SR    R1,R14\n         BZ    YSLIMB2\n         BCTR  R1,0\n         STC   R1,*+5\n         MVC   0(1,R5),1(R7)\n         LA    R5,1(R1,R5)\n         LA    R7,1(R1,R7)\nYSLIMB2  DS    0H\n         LA    R7,1(,R7)\n         CR    R5,R15\n         BNL   YSLIMB8+4\n         CLI   0(R7),X'00'\n         BNE   YSLIMB1\nYSLIMB8  DS    0H\n         LA    R7,1(,R7)\n         ST    R7,MEMAREC\n         B     DEBLKXT\n         TITLE                     'Read PDS member(s)                 x\n                 Common deblocking exit   /   End-of-member processing'\nDEBLKXT  DS    0H\n         TM    MEMBER_SW,PACKED_MEMBER  Packed member?\n         BZ    DE_BLOCK_XT2                -no -\n         L     R1,APARMS             Need my plist.\n         TM    8(R1),X'80'           3 parameters?\n         BO    DE_BLOCK_XT2             -yes-\n         LM    R0,R1,8(R1)              -no - need parm 3 and parm 4.\n         SR    R5,R0                 Calculate length of record\n         ST    R5,0(,R1)                and return it to the caller.\nDE_BLOCK_XT2   DS    0H\n         TM    MEMBER_SW,OVERFLOW    Handling a buffer wrap?\n         BZ    DE_BLOCK_XT              -no -\n         NI    MEMBER_SW,255-OVERFLOW  Turn OFF buffer wrap processing.\n         L     R14,MEM_FLOWAREA      Address interim area.\n         L     R1,4(,R14)            Length of data from old buffer.\n         LA    R14,8(R1,R14)         Address of data from new buffer\n         SR    R7,R14                   minus current pointer equals\n         A     R7,MEMABLK                  displacement into new buffer\n         ST    R7,MEMAREC                     which gets used next CALL\n         B     RTNXT\nDE_BLOCK_XT DS 0H\n         L     R7,MEMAREC\n         L     R8,MEMABLK\n         AH    R8,MEMBLKL\n         CR    R7,R8\n         BL    RTNXT\n         OI    MEMBER_SW,DO_READ     (Physical) read required.\n         B     RTNXT\n         SPACE 3\nEOMEM    DS    0H\n         L     R8,MEMABLK\n         TM    MEMBER_SW,PACKED_MEMBER  Was member packed?\n         BZ    EOMEM010                    -no -\n         L     R1,MEM_FLOWAREA       Need to release\n         L     R0,0(,R1)                acquired storage.\n      FREEMAIN R,LV=(R0),A=(R1)\nEOMEM010 DS    0H\n         LA    R4,FREETBL-FREELEN  Top-of-table minus 1 entry\n         SPACE 1\n         LA    R4,FREELEN(,R4)     Next table entry\n         L     R1,FREEADDR         Entry\n         LTR   R1,R1                  available for use\n         BNZ   *-10                     -no -  loop back.\n         LR    R0,R4               Save address of available entry.\n         LA    R4,DDAFREE          Get anchor.\n         B     EOMEM040\nEOMEM020 DS    0H\n         LR    R4,R5               One link at a time.\nEOMEM040 DS    0H\n         L     R5,FREENXT          Is this\n         LTR   R5,R5                  the last link?\n         BNZ   EOMEM020                  -no -\n         ST    R0,FREENXT          Link in next available entry.\n         LR    R4,R0               Point to that entry\n         ST    R8,FREEADDR            and save the GETMAIN'd address.\n         MVI   RC,12\n         XC    0(MEMNTRY,R2),0(R2) Clear the member entry.\n         MVI   MEMBER_SW,DE_ACTIVE Indicate available entry.\n         B     RTNXT\n         TITLE                     'Read PDS member(s)                 x\n                                                     Global data areas'\nAPARMS   DS    F\n         SPACE 1\nDDTBL    DS    0D\n         DC    C'        ',3A(0)\n         DC    C'        ',3A(0)\n         DC    C'        ',3A(0)\n         DC    C'        ',3A(0)\n         DC    C'        ',3A(0)\n         DC    C'        ',3A(0)\n         DC    C'        ',3A(0)\n         DC    C'        ',3A(0)\nDDLAST   DC    C'        ',3A(0)\n         SPACE 1\nFREETBL  DC    16D'0'\n*\n* 'FREETBL' is a table containing chains of entries pointing to\n* storage which has become free because the buffer is no longer\n* required after a member has been read. Note that each chain is\n* anchored to a 'DDNTRY' because the DCB determines the amount of\n* storage acquired. The total number of (active) 'free' entries is\n* controlled by the number of active 'MEMNTRY's.\n*\n* 'FREETBL\" entries are mapped via the 'FREENTRY' DSECT.\n         SPACE 1\nMEMTBL   DS    0D\n         DC    (MEMNTRY)X'00'\n         ORG   *-MEMNTRY+MEMBER_SW-MEMNTRY0\n         DC    AL1(DE_ACTIVE)\n         ORG\n         DC    (MEMNTRY)X'00'\n         ORG   *-MEMNTRY+MEMBER_SW-MEMNTRY0\n         DC    AL1(DE_ACTIVE)\n         ORG\n         DC    (MEMNTRY)X'00'\n         ORG   *-MEMNTRY+MEMBER_SW-MEMNTRY0\n         DC    AL1(DE_ACTIVE)\n         ORG\n         DC    (MEMNTRY)X'00'\n         ORG   *-MEMNTRY+MEMBER_SW-MEMNTRY0\n         DC    AL1(DE_ACTIVE)\n         ORG\n         DC    (MEMNTRY)X'00'\n         ORG   *-MEMNTRY+MEMBER_SW-MEMNTRY0\n         DC    AL1(DE_ACTIVE)\n         ORG\n         DC    (MEMNTRY)X'00'\n         ORG   *-MEMNTRY+MEMBER_SW-MEMNTRY0\n         DC    AL1(DE_ACTIVE)\n         ORG\n         DC    (MEMNTRY)X'00'\n         ORG   *-MEMNTRY+MEMBER_SW-MEMNTRY0\n         DC    AL1(DE_ACTIVE)\n         ORG\nMEMLAST  DC    (MEMNTRY)X'00'\n         ORG   *-MEMNTRY+MEMBER_SW-MEMNTRY0\n         DC    AL1(DE_ACTIVE)\n         ORG\n         SPACE 1\nDBLWD    DS    D\n         SPACE 1\nSAVE25   DS    4F\n         SPACE 1\nLAST_DD_ENTRY  DS    F\n         SPACE 3\nA_DCB    DCB   DSORG=PO,                                               X\n               MACRF=R,                                                X\n               DDNAME=PDS1,                                            X\n               EODAD=EOMEM\n         SPACE 1\nWARN1MSG DS    0F\n         DC    AL2(WARN1LEN),XL2'8000'\n         DC    C'STSS384  :  ''FIND'' macro generated return code'\nWARN1RC  DS    CL4\n         DC    C'.'\nWARN1LEN EQU   *-WARN1MSG\n         DC    X'04000020'\n         SPACE 1\nENTRY_SW       DS     XL1\nNO_DEBLOCK     EQU    X'01'\nYES_DEBLOCK    EQU    X'00'\nTTR_MEMBER     EQU    X'10'\n         EJECT\n         LTORG\n         TITLE                     'Read PDS member(s)                 x\n                                                    DSECTS and EQUates'\n         SPACE 2\nIOB000D  DSECT\nIOBPREFX DS    0CL16\nIOBCFLG1 DS    XL1\n         DS    XL15\nIOBSTDRD DS    CL8\n         DS    XL1\nIOBCSW   DS    XL7\n         SPACE 2\nDDNTRY0  DSECT\nDDNAME0  DS    CL8\nDDMEM0   DS    XL1\nDDADRCT0 DS    AL3\nDDADCB0  DS    A\nDDAFREE  DS    A\nDDNTRY   EQU   *-DDNAME0\n         SPACE 2\nFREENTRY DSECT\nFREENXT  DS    A\nFREEADDR DS    A\nFREELEN  EQU   *-FREENXT\n         SPACE 2\nMEMNTRY0 DSECT\nMEMNAME0 DS    CL8\nMEMDECB  DS    0CL20\n         DS    2A\n         DS    AL1\nMEMADCB  DS    AL3\nMEMABLK  DS    F\n         DS    AL1\nMEMAIOB  DS    AL3\nMEMAREC  DS    F\nMEM_FLOWAREA   DS    F\nMEMBLKL  DS    H\nMEMBER_SW      DS    XL1\nNEW_MEMBER     EQU  X'80'\nPACKED_MEMBER  EQU  X'40'\nOVERFLOW       EQU  X'20'\nDE_ACTIVE      EQU  X'08'\nDO_READ        EQU  X'04'\n         DS    0D\nMEMNTRY  EQU   *-MEMNAME0\n         SPACE 1\n         DCBD  DSORG=(PO),DEVD=(DA)\n         SPACE 1\n         IHADECB\n         SPACE 1\n         YREGS\n         END   STSS384\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCXSORT": {"ttr": 2824, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00X\\x01\\x01%O\\x01\\x01%O!C\\x03\\xcd\\x03\\xcd\\x00\\x00\\xd7\\xc4\\xe2\\xd3\\xd6\\xc1\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-09-11T00:00:00", "modifydate": "2001-09-11T21:43:58", "lines": 973, "newlines": 973, "modlines": 0, "user": "PDSLOAD"}, "text": "./ ADD NAME=$README$ 0101-01157-01235-1310-00019-00046-00000-PST0705\nInstallation / readme for SCXSORT\n\nThere are 3 component for this package\n\nMACRO    Is the Assembler macro named ID requitred to assemble the\n         assembler routine. Put it into a library included in your\n         SYSLIB concatenation for the assembly.\n\nSOURCE   Is the single Assembler source deck of the function.\n\nHELP     Is the documentation on how to use SCXSORT in Rexx programs.\n\nMaking SCXSORT available to your rexx program can be as simple as\nlink editing it to a load library that is within the JOBLIB/STEPLIB\nconcatenation when the rexx program runs. Myself, I have built a Rexx\nfunction package under the name IRXFLOC which contains all the\nassembler written rexx functions for the platform.\n\nThe HELP documentation should provide all the usage notes required.\n./ ADD NAME=HELP     0105-96073-96204-1023-00077-00063-00000-PST0705\n Name:        SCXSORT\n\n Purpose:     Sort from and/or into REXX stem variables.                e\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              SCXSORT resides in the IRXFLOC \"function package\".\n\n Features:    All the capabilities of the system sort program are\n              available.\n\n              Use of stem variables is not mandatory. SCXSORT may be\n              used to manipulate files as per normal.\n\n              SORT's control statements are coded as values assigned\n              to specific REXX variables. Each control statement\n              uses a REXX variable name of the format SCX._____\n              where _____ is the name of the control statement\n              e.g. SCX.SORT = 'FIELDS=(1,8,BI,A)'\n\n Arguments:   There are two possible arguments; both are optional.\n\n           1. The name of the stem variable containing the\n              input \"records\". (If this argument is omitted, SORT\n              will obtain the input records from SORTIN or as per\n              the MODS control statement.)\n\n              The argument (when used) must specify a stem variable\n              name including the period. It should/must be enclosed\n              within quotation marks.\n\n              If there are non-existent variables within the range\n              of stem.1 and stem.n, then stem.0 must contain the\n              value of \"n\" to cause SCXSORT to ignore the\n              non-existent variables.\n\n           2. The name of the stem variable to receive the output\n              \"records\".  (If this argument is omitted, SORT will\n              dispose of the output records to SORTOUT or as per the\n              MODS control statement.)\n\n              The argument (when used) must specify a stem variable\n              name including the period. It should/must be enclosed\n              within quotation marks.\n\n              SCXSORT normally uses stem.1 for the first output\n              \"record\".  If stem.0 is assigned the value \"n\", then\n              output begins at stem.n. This technique can be used\n              to add entries to an existing range.\n\n Results:     Direct results for the REXX exec are only produced\n              when argument two is used. In that case the stem\n              variables are (re)filled and stem.0 contains the value\n              of the number of the last stem filled.\n\n\n Notes:\n    It is recommended that scx.RECORD always be used.  Default for\n    stemmed input is scx.RECORD = 'TYPE=F,LENGTH=(length(stem.1))'.\n    SCXSORT will abort when scx.RECORD is not assigned and stemmed\n    output is requested but stemmed input is not.\n\n    Misrepresentation of RECORD TYPE/LENGTH will create\n    unpredictable results.\n\n    If SCXSORT is to be used multiple times within one exec, ensure\n    that only those scx.____ variables required for each SCXSORT are\n    in force before the invocation. It may be necessary to DROP\n    SCX.___ variables (e.g. scx.SUM = 'FIELDS=NONE')\n\n    Control of SORT's message is accomplished through the $ORTPARM\n    DDname. Once a particular use of SCXSORT is stable and SORT's\n    messages are to be suppressed (and allocation of SYSOUT\n    avoided), then $ORTPARM should be allocated to\n    SYS1.UTILPARM(SORT@NOL)\n\n    In certain situations, SCXSORT can be an alternative to EXECIO.\n\n./ ADD NAME=MACRO    0102-98050-98050-1606-00049-00046-00000-PST0705\n         MACRO\n&LABEL   ID    &USING,&CSECT=YES,&AMODE=31,&RMODE=ANY\n         LCLC  &U,&LBL\n.*\n.* Stelco macro used to:\n.*    - generate the CSECT statement.\n.*    - generate the USING, AMODE and RMODE statements for the CSECT.\n.*    - generate an eye-catcher and date/time stamp (28 bytes total).\n.*      (The values for date and time are the time of the Assembly.)\n.*\n.* The default for the USING statement is (register) 15.\n.* Other defaults are as per the prototype above.\n.*\n.* If the CSECT requires multiple base registers, their specification\n.* must be enclosed in parenthesis.       e.g.  BIGRTN   ID     (12,11)\n.*\n.* This macro can also be used to generate only the eye-catcher and\n.* date/time stamp. For this type of usage specify   ID    ,CSECT=NO\n.*\n.* -----------------------Modification History-------------------------\n.* 98-02-19 change from &SYSDATE to &SYSDATC\n.*\n&U       SETC  '15'\n&LBL     SETC  ' '\n         AIF   (K'&LABEL EQ 0).LBLSET\n&LBL     SETC  '&LABEL'\n.LBLSET  ANOP\n         AIF   (T'&USING EQ 'O').USET\n         AIF   ('&USING'(1,1) NE '(').ONEUSE\n&U       SETC  '&USING'(2,K'&USING-2)\n         AGO   .USET\n.ONEUSE  ANOP\n&U       SETC  '&USING'\n.USET    ANOP\n         AIF   ('&CSECT' EQ 'YES').CSECT\n&LBL     DS    0H\n         B     *+32\n         AGO   .STAMP\n.CSECT   ANOP\n&LBL     CSECT\n&LBL     AMODE &AMODE\n&LBL     RMODE &RMODE\n         USING &LABEL,&U\n         BC    15,32(,15)\n.STAMP   ANOP\n         DS    CL4\n         DC    CL8'&LBL'\n         DC    CL16'&SYSDATC &SYSTIME'\n         MEND\n./ ADD NAME=SOURCE   0140-95181-01235-1315-00824-00355-00000-PST0705\nXSORT    TITLE            '<< REXX - SORT from/into REXX stems         X\n                                                      Documentation >>'\n* Name:        SCXSORT\n*\n* Purpose:     Invoke the system sort routine and optionally use\n*              'stemmed' input variables and/or 'stemmed' output.\n*\n* Environment: REXX subroutine/function for Address TSO or MVS\n*\n* Features:    All SORT control statements are made available via\n*              values for REXX variable names. Each REXX variable name\n*              is composed of a stem of SCX. followed by the name of a\n*              SORT control statement.\n*              e.g. SCX.RECORD = 'TYPE=V,LENGTH=(.... '\n*\n* Arguments:\n*  1. The name of a stem variable or null. If this argument is null,\n*     this routine (of its own) will not establish an E15 exit and SORT\n*     will defer to the control statements values; i.e. default to\n*     SORTIN or use the MODS settings.\n*\n*     If a stemmed variable is to be used:\n*        - specify the name of the stem variable including the '.'\n*        - if there are unitialized variables between stem.1 and\n*          stem.n, then set the value of stem.0 to 'n' so that all\n*          initialized stems within the range will be sorted.\n*\n*  2. The name of a stem variable or null. If this argument is null,\n*     this routine (of its own) will not establish an E35 exit and SORT\n*     will defer to the control statements values; i.e. default to\n*     SORTOUT or use the MODS settings\n*\n*     If a stemmed variable is to be used:\n*        - specify the name of the stem variable including the '.'\n*        - if the variable stem already has a series of 'tails' up to\n*          n-1, then pre-set stem.0 = n so that the sort will start\n*          adding records at stem.n\n*        - SCXSORT will (re)set the value of 'stem.0' to the number of\n*          output variables.\n*\n* Notes:\n*     The RECORD control statement should be used for stemmed input\n*     and/or output.  This routine will check the variable SCX.RECORD\n*     and use both the TYPE= and LENGTH= operands.  Misrepresentation\n*     of the RECORD parameters will yield unpredicatble results.\n*\n*     If stemmed input is used and\n*        - if SCX.RECORD is un-initialized or 'TYPE=F'\n*          (without LENGTH= operands) is coded, then\n*          RECORD TYPE=F,LENGTH=(length(stem.1)) is forced.\n*        - if TYPE=V is coded, the E15 exit portion of this routine\n*          will create variable length records. This is recommended\n*          when sorting from stems to stems.\n*\n*     If stemmed output is used and\n*        - variable length records are being passed to build the stems,\n*          then TYPE=V must be coded (i.e. TYPE=V is not implied.)\n*        - TYPE=V is not coded and LENGTH= is not coded (or forced as\n*          per above), then this routine aborts the SORT.\n*        - TYPE=V is coded, the LENGTH= operands are ignored by this\n*          routine.\n*\n         TITLE            '<< REXX - SORT from/into REXX stems         X\n                                                     System Linkage >>'\n         PRINT   GEN\nSCXSORT  ID    R12\n         PRINT NOGEN\n         SPACE 2\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         ST    R13,SAVEAREA+4\n         LA    R15,SAVEAREA\n         ST    R15,8(,R13)\n         LR    R13,R15\n         XC    RC,RC\n         B     MAINLINE\n         SPACE 3\nRC       DS    0F\n         DS    AL1\nRC1      DS    AL1\nRC2      DS    AL1\nRC3      DS    AL1\n         SPACE 1\nSAVEAREA DS    18F\n         SPACE 3\nRTNXT    DS    0H\n         L     R13,SAVEAREA+4\n         XC    8(4,R13),8(R13)\n         XC    16(4,R13),16(R13)   R15 (return code) always\n         LM    R14,R12,12(R13)        get set to zero.\n         BR    R14\n         TITLE            '<< REXX - SORT from/into REXX stems         X\n                                                Parse the Arguments >>'\nMAINLINE DS    0H\n         USING EFPL,R1\n         USING ENVBLOCK,R8\n         USING IRXEXTE,R9\n         USING EVALBLOCK,R11\n         USING SHVBLOCK,R14\n         ST    R0,A_ENVBLK\n         LR    R8,R0               Address the environment block.\n         L     R9,ENVBLOCK_IRXEXTE Address the REXX vector table.\n         LM    R10,R11,EFPLARG     Address ARGTABLE & EVALBLOCK.\n         L     R11,0(,R11)\n         ST    R9,A_IRXEXTE        Save address of the vector table.\n         DROP  R8\n         SR    R0,R0\n         ST    R0,SHVNAMA-SHVBLOCK+@SHV\n         ST    R0,E15_GOTMAIN      Presume no storage for stems.\n         ST    R0,VE15             Presume no stemmed input.\n         ST    R0,VE35             Presume no stemmed output\n         ST    R0,IN_LRECL\n         ST    R0,OUT_LRECL\n         ST    R0,LRECL            Clear LENGTH=\n         MVI   RECFM,C' '             and TYPE=\n         MVI   TRTABLE-1,X'FF'\n         BAL   R14,STRIP           Strip out arg(1).\n         B     GET_ARG2            Arg(1) not specified.\n         CLI   0(R4),C'.'          Stemmed input?\n         BNE   ARG1_ERR               -no -\n         LA    R14,TAIL_IN-1       Calculate starting address\n         SR    R14,R15                of input stem name\n         ST    R14,A_STEM_IN             and save it.\n         EX    R15,MVC_STEMIN      Pick-up the name of the input stem.\n         LA    R0,FROM_STEM        Entry address\n         ST    R0,VE15                for E15 exit\n         OI    VE15,X'80'                in AMODE 31.\n         B     GET_ARG2\nMVC_STEMIN  MVC  0(0,R14),0(R3)\n         SPACE 1\nGET_ARG2 DS    0H\n         BAL   R14,STRIP           Strip out arg(2).\n         B     ARGS_DONE           Arg(2) not specified\n         CLI   0(R4),C'.'          Stemmed output?\n         BNE   ARG2_ERR               -no -\n         LA    R14,TAIL_OUT-1      Calculate starting address\n         SR    R14,R15                of output stem name\n         ST    R14,A_STEM_OUT            and save it.\n         EX    R15,MVC_STEMIN      Pick-up the name of the output stem.\n         LA    R0,TO_STEM          Entry address\n         ST    R0,VE35                for E35 exit\n         OI    VE35,X'80'                in AMODE 31.\n         B     ARGS_DONE\n         TITLE            '<< REXX - SORT from/into REXX stems         X\n                                Collect the SORT control statements >>'\nSTMNT_TABLE DS 0C\n          DC   AL1(L'@SORT)\n@SORT     DC   C'SORT',AL1(L'@ALTSEQ)\n@ALTSEQ   DC   C'ALTSEQ',AL1(L'@INCLUDE)\n@INCLUDE  DC   C'INCLUDE',AL1(L'@INREC)\n@INREC    DC   C'INREC',AL1(L'@MERGE)\n@MERGE    DC   C'MERGE',AL1(L'@MODS)\n@MODS     DC   C'MODS',AL1(L'@OMIT)\n@OMIT     DC   C'OMIT',AL1(L'@OUTFIL)\n@OUTFIL   DC   C'OUTFIL',AL1(L'@OUTREC)\n@OUTREC   DC   C'OUTREC',AL1(L'@SUM)\n@SUM      DC   C'SUM',AL1(L'@RECORD)\n@RECORD   DC   C'RECORD'           Procees RECORD statement last.\n          DC   AL1(0)              End-of-table indicator.\n@SCX      DC   C'SCX.'\nCONTROL   DS   CL8\nMVC_CONTROL  MVC  CONTROL(0),1(R4)\nMVC2_CONTROL MVC  1(0,R3),1(R4)\n         SPACE 2\nARGS_DONE  DS  0H\n         LA    R1,4087             Maximum of 4K for statements.\n         ST    R1,SHVBUFL-SHVBLOCK+@SHV\n         LA    R0,9(,R1)\n      GETMAIN  R,LV=(R0)\n         ST    R1,@CONTROLS        Save the address of the area.\n         LA    R3,2(,R1)\n         LA    R4,STMNT_TABLE\n         SR    R5,R5\n         LA    R0,@SCX\n         ST    R0,SHVNAMA-SHVBLOCK+@SHV\n         MVI   SHVCODE-SHVBLOCK+@SHV,SHVFETCH\nSTMNT_LOOP  DS  0H\n         IC    R5,0(R4)            Get the length of the statement name\n         LA    R0,4(,R5)           Hence length of variable name.\n         ST    R0,SHVNAML-SHVBLOCK+@SHV\n         LR    R1,R5               Pick-up\n         BCTR  R1,0                   this control statement's name\n         EX    R1,MVC_CONTROL            to complete the variable name.\n         LA    R0,2(R5,R3)         Address where variable\n         ST    R0,SHVVALA-SHVBLOCK+@SHV  value is placed.\n*\n* Refer to the IRXEXCOM routine; pages 312-319 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\n         L     R15,IRXEXCOM        Get routine's address from vector.\n         L     R0,A_ENVBLK         Make sure REXX knows environment.\n         LA    R1,PLIST_EXCOM\n         BALR  R14,R15\n         LTR   R15,R15\n         BNZ   EXCOM_FAILURE\n         TM    SHVRET-SHVBLOCK+@SHV,SHVNEWV\n         BO    NEXT_STMNT\n         LR    R1,R5               Pick-up\n         BCTR  R1,0                   this control statement's name\n         EX    R1,MVC2_CONTROL           to complete SORT's statement.\n         LA    R1,2(R1,R3)         Enclose\n         MVI   0(R3),C' '            it in\n         MVI   0(R1),C' '               blanks.\n         L     R3,SHVVALA-SHVBLOCK+@SHV\n         A     R3,SHVVALL-SHVBLOCK+@SHV\n         L     R1,@CONTROLS\n         LA    R1,4087(,R1)\n         SR    R1,R3\n         ST    R1,SHVBUFL-SHVBLOCK+@SHV\nNEXT_STMNT  DS  0H\n         LA    R4,1(R5,R4)         Address of next statement.\n         CLI   0(R4),X'00'         More statements?\n         BNE   STMNT_LOOP             -yes-\n         L     R6,SHVVALA-SHVBLOCK+@SHV  Where was the last value put?\n         ST    R3,SHVVALA-SHVBLOCK+@SHV  Here's where to put more.\n         L     R1,@CONTROLS        Calculate\n         SR    R3,R1                  length\n         BCTR  R3,0\n         BCTR  R3,0\n         STH   R3,0(,R1)                 of SORT's control statements.\n         TITLE            '<< REXX - SORT from/into REXX stems         X\n                                       Analize the RECORD statement >>'\n         TM    SHVRET-SHVBLOCK+@SHV,SHVNEWV\n         BO    IF_E15\n         CLC   =CL5'TYPE=',0(R6)\n         BNE   *+14\n         MVC   RECFM,5(R6)\n         LA    R6,7(,R6)\n         SPACE 1\n         SR    R14,R14             Indicate LRECL not set.\n         CLC   0(8,R6),=CL8'LENGTH=(' Is there a LENGTH= operand?\n         BE    LENGTH_GIVEN             -yes-\n         CLC   0(7,R6),=CL8'LENGTH=(' Is there a LENGTH= operand?\n         BNE   NO_MORE_LENGTHS          -no -\n         LA    R6,7(,R6)\n         B     LENGTH_GIVEN+4\nLENGTH_GIVEN   DS  0H\n         LA    R6,8(,R6)           Point to the operand.\n         SPACE 1\n         MVI   TRTABLE-1,X'FF'     Delimit\n         MVC   TRTABLE,TRTABLE-1      the search\n         MVI   TRTABLE+C'0',X'00'        at any\n         MVC   TRTABLE+C'1'(9),TRTABLE+C'0' non-numeric but\n         MVI   TRTABLE+C',',X'01'              comma is special.\n         SR    R2,R2               Pre-clear R2.\n         LA    R1,6(,R6)           Pre-set maximum delimiter address.\n         TRT   0(7,R6),TRTABLE     Find delimiter of numerics.\n         BZ    NO_MORE_LENGTHS     Too many numerics.\n         SR    R1,R6           *\\  Calculate length of the operand\n         LA    R1,X'6F'(,R1)     )    as a machine instruction.\n         BNP   NO_MORE_LENGTHS */  (cc from SR above) Null operand.\n         EX    R1,PACK@R6          Pick-up\n         CVB   R14,DBLWD              length of the operand\n         ST    R14,LRECL                 and save it.\nNO_LENGTH1 DS  0H\n         BCT   R2,NO_MORE_LENGTHS  Was comma the delimiter?  -no -\n         LA    R6,1(,R1)                                     -yes-\n         LA    R1,6(,R6)           Pre-set maximum delimiter address.\n         TRT   0(7,R6),TRTABLE     Find delimiter of numerics.\n         BZ    NO_MORE_LENGTHS     Too many numerics.\n         SR    R1,R6           *\\  Calculate length of the operand\n         LA    R1,X'6F'(,R1)     )    as a machine instruction.\n         BNP   NO_MORE_LENGTHS */  (cc from SR above) Null operand.\n         EX    R1,PACK@R6          Pick-up\n         CVB   R0,DBLWD               length of the operand\n         ST    R0,IN_LRECL               and save it.\nNO_LENGTH2 DS  0H\n         BCT   R2,NO_MORE_LENGTHS  Was comma the delimiter?  -no -\n         LA    R6,1(,R1)                                     -yes-\n         LA    R1,6(,R6)           Pre-set maximum delimiter address.\n         TRT   0(7,R6),TRTABLE     Find delimiter of numerics.\n         BZ    NO_MORE_LENGTHS     Too many numerics.\n         SR    R1,R6           *\\  Calculate length of the operand\n         LA    R1,X'6F'(,R1)     )    as a machine instruction.\n         BNP   NO_MORE_LENGTHS */  (cc from SR above) Null operand.\n         EX    R1,PACK@R6          Pick-up\n         CVB   R0,DBLWD               length of the operand\n         ST    R0,OUT_LRECL              and save it.\nNO_MORE_LENGTHS  DS  0H   Propogate length operand forward.\n         L     R1,IN_LRECL         Is\n         LTR   R1,R1                  E15 length set?\n         BNZ   *+8                       -yes-\n         ST    R14,IN_LRECL              -no -   Use global length.\n         SPACE 1\n         L     R2,IN_LRECL         Get E15 length\n         L     R1,OUT_LRECL        Is\n         LTR   R1,R1                  E35 length set?\n         BNZ   IF_E15                    -yes-\n         ST    R2,OUT_LRECL              -no -   Use E15 length.\nIF_E15   DS    0H\n         TM    VE15,X'80'          Input stems?\n         BZ    IF_E35                 -no -\n         L     R15,IN_LRECL        Is RECORD LENGTH=\n         LTR   R0,R15                 set?\n         BNZ   E15_GETMAIN               -yes-\n         MVI   TAIL_IN,C'1'        Set the stem's tail to one.\n         L     R1,A_STEM_IN        Get address of the variable name and\n         ST    R1,SHVNAMA-SHVBLOCK+@SHV  let EXCOM know about it.\n         LA    R3,TAIL_IN+1        Calculate length of variable name\n         SR    R3,R1                  including the tail and\n         ST    R3,SHVNAML-SHVBLOCK+@SHV  let EXCOM know about it.\n         L     R3,SHVBUFL-SHVBLOCK+@SHV\n         L     R15,IRXEXCOM        Get routine's address from vector.\n         L     R0,A_ENVBLK         Make sure REXX knows environment.\n         LA    R1,PLIST_EXCOM\n         BALR  R14,R15\n         LTR   R15,R15\n         BNZ   EXCOM_FAILURE\n         ST    R3,SHVBUFL-SHVBLOCK+@SHV\n         TM    SHVRET-SHVBLOCK+@SHV,SHVNEWV\n         BO    NO_STEM_IN\n         L     R0,SHVVALL          Get the length(stem.1)\n         CLI   RECFM,C'V'          RECORD TYPE=V?\n         BNE   *+8                    -no -\n         A     R0,A4                  -yes-   RDW adjustemnt.\n         SPACE 1\n         ST    R0,IN_LRECL         Save the LRECL\n         CVD   R0,DBLWD            Convert\n         OI    DBLWD+7,X'0F'          to decimal\n         L     R1,@CONTROLS        Address of control cards.\n         LH    R0,0(,R1)           Length used already.\n         AR    R1,R0               I can put data here.\n         CLI   RECFM,C' '          Did we find a RECORD statement?\n         BNE   FORCE_LENGTH           -yes-\n         MVI   0(R1),C' '          Build\n         MVC   1(6,R1),@RECORD        RECORD\n         MVI   7(R1),C' '\n         MVC   8(5,R1),=CL5'TYPE='       TYPE=\n         MVI   13(R1),C'F'                    F\n         MVI   RECFM,C'F'          Remember the RECFM\n         LA    R1,14(,R1)          Adjust pick-up address.\nFORCE_LENGTH  DS  0H\n         MVI   0(R1),C','          Build\n         MVC   1(8,R1),=CL8'LENGTH=('  LENGTH=\n         UNPK  9(5,R1),DBLWD+5(3)        operand\n         MVI   14(R1),C')'                  .\n         LA    R0,15(,R1)          Re-calculate\n         L     R1,@CONTROLS           length of control\n         SR    R0,R1                     statements\n         STH   R0,0(,R1)                    and save the result.\n         L     R1,OUT_LRECL        Has the output LRECL\n         LTR   R1,R1                  been esatblished?\n         BNZ   *+10                      -yes-\n         MVC   OUT_LRECL,IN_LRECL        -no -   Default\n         SPACE 1\n         L     R0,IN_LRECL         Re-set R0 for GETMAIN\nE15_GETMAIN  DS  0H\n         LR    R1,R0\n         LA    R0,11(,R1)         (4 of 11 could be avoided, but...)\n         N     R0,X_FFFFFFF8       Bits 29-31 become zero.\n         ST    R0,IN_LRECL               and save result.\n       GETMAIN R,LV=(R0)\n         ST    R1,E15_GOTMAIN      Remember the address.\nIF_E35   DS    0H\n         TM    VE35,X'80'          Output stems?\n         BZ    PRE_SORT               -no -\n         LA    R0,1                Presume\n         ST    R0,OUT_COUNT           we start at stem.1\n         MVI   TAIL_OUT,C'0'       Set the stem's tail to zero.\n         L     R1,A_STEM_OUT       Get address of the variable name and\n         ST    R1,SHVNAMA-SHVBLOCK+@SHV  let EXCOM know about it.\n         LA    R3,TAIL_OUT+1       Calculate length of variable name\n         SR    R3,R1                  including the tail and\n         ST    R3,SHVNAML-SHVBLOCK+@SHV  let EXCOM know about it.\n         L     R3,SHVBUFL-SHVBLOCK+@SHV\n         L     R15,IRXEXCOM        Get routine's address from vector.\n         L     R0,A_ENVBLK         Make sure REXX knows environment.\n         LA    R1,PLIST_EXCOM\n         BALR  R14,R15\n         LTR   R15,R15\n         BNZ   EXCOM_FAILURE\n         ST    R3,SHVBUFL-SHVBLOCK+@SHV\n         TM    SHVRET-SHVBLOCK+@SHV,SHVNEWV  Did that variable exist?\n         BO    NO_STEM_OUT                      -no -\n         L     R6,SHVVALA-SHVBLOCK+@SHV\n         L     R1,SHVVALL-SHVBLOCK+@SHV  Use the length of the value\n         LA    R1,X'6F'(,R1)                for the\n         EX    R1,PACK@R6                      PACK instruction.\n         CVB   R1,DBLWD\n         LTR   R1,R1               Is the value\n         BP    *+8                    greater than zero?   -yes-\n         LA    R1,1                Substitute 1.\n         SPACE 1\n         ST    R1,OUT_COUNT        Tail number is ready.\nNO_STEM_OUT  DS  0H\n         CLI   RECFM,C'V'          Has RECORD TYPE=V been specified?\n         BE    PRE_SORT               -yes-  We hope that will work.\n         L     R15,OUT_LRECL       Is a stem length\n         LTR   R15,R15                available?\n         BZ    NO_OUT_LRECL              -no -  hang-up now.\n         MVI   RECFM,C'F'          Presumption.\n         TITLE            '<< REXX - SORT from/into REXX stems         X\n                                          Pre-sets for the E15 exit >>'\nPRE_SORT DS    0H\n         TM    VE15,X'80'\n         BZ    START_SORT\n         SR    R0,R0\n         ST    R0,IN_LIMIT\n         ST    R0,IN_COUNT\n         MVI   SHVCODE-SHVBLOCK+@SHV,SHVFETCH\n         MVI   TAIL_IN,C'0'\n         L     R1,A_STEM_IN        Get address of the variable name and\n         ST    R1,SHVNAMA-SHVBLOCK+@SHV  let EXCOM know about it.\n         LA    R3,TAIL_IN+1        Calculate length of variable name\n         SR    R3,R1                  including the tail and\n         ST    R3,SHVNAML-SHVBLOCK+@SHV  let EXCOM know about it.\n         L     R3,SHVBUFL-SHVBLOCK+@SHV\n         L     R15,IRXEXCOM        Get routine's address from vector.\n         L     R0,A_ENVBLK         Make sure REXX knows environment.\n         LA    R1,PLIST_EXCOM\n         BALR  R14,R15\n         LTR   R15,R15\n         BNZ   EXCOM_FAILURE\n         ST    R3,SHVBUFL-SHVBLOCK+@SHV\n         TM    SHVRET-SHVBLOCK+@SHV,SHVNEWV  Did that variable exist?\n         BO    NO_STEM0_IN                      -no -\n         L     R6,SHVVALA-SHVBLOCK+@SHV\n         L     R1,SHVVALL-SHVBLOCK+@SHV  Use the length of the value\n         LA    R1,X'6F'(,R1)                for the\n         EX    R1,PACK@R6                      PACK instruction.\n         CVB   R1,DBLWD\n         LTR   R1,R1               Is the value\n         BP    *+6                    greater than zero?   -yes-\n         SR    R1,R1               Substitute zero.\n         SPACE 1\n         ST    R1,IN_LIMIT         Input limit count is ready.\nNO_STEM0_IN  DS  0H\n         L     R0,A_STEM_IN\n         ST    R0,SHVNAMA-SHVBLOCK+@SHV\n         L     R0,IN_LRECL\n         L     R1,E15_GOTMAIN\n         CLI   RECFM,C'V'\n         BNE   *+12\n         LA    R1,4(,R1)\n         S     R0,A4\n         SPACE 1\n         ST    R0,SHVBUFL-SHVBLOCK+@SHV\n         ST    R1,SHVVALA-SHVBLOCK+@SHV\n         B     START_SORT          Ready for SORT to do its thing.\n         TITLE            '<< REXX - SORT from/into REXX stems         X\n                                Run SORT.   Set result.   Clean-up. >>'\nSTART_SORT  DS  0H\n         LA    R1,SORT_PLIST\n         LINK  EP=SORT\n         SPACE 3\n         CVD   R15,DBLWD           Convert the return code\n         UNPK  EVALBLOCK_EVDATA(5),DBLWD+5(3)  into\n         OI    EVALBLOCK_EVDATA+4,X'F0'          ebcidic format.\n         LA    R2,5                Maximum length of the value.\n         LA    R3,4                Maximum leading zeroes.\n         LA    R4,*+4              Top-of-loop address\n         CLI   EVALBLOCK_EVDATA,C'0'  Leading zero?\n         BNE   RESULT_SET                -no -\n         BCTR  R2,0                Decrement the length\n         MVC   EVALBLOCK_EVDATA(4),EVALBLOCK_EVDATA+1  Shift the data.\n         BCTR  R3,R4               Count and loop.\nRESULT_SET  DS 0H\n         ST    R2,EVALBLOCK_EVLEN\n         TM    VE35,X'80'          Output stems?\n         BZ    STEM0_SET              -no -\n         MVI   SHVCODE-SHVBLOCK+@SHV,SHVSTORE\n         MVI   TAIL_OUT,C'0'       Stem.0 is qualified variable name.\n         L     R0,A_STEM_OUT       Where is the variable name because\n         ST    R0,SHVNAMA-SHVBLOCK+@SHV  EXCOM needs to know.\n         LA    R2,TAIL_OUT+1       Calculate\n         SR    R2,R0                  the length of the varaible name\n         ST    R2,SHVNAML-SHVBLOCK+@SHV  and let EXCOM know about it.\n         L     R2,OUT_COUNT        Convert\n         BCTR  R2,0                   the\n         CVD   R2,DBLWD                  value\n         OI    DBLWD+7,X'0F'                to\n         UNPK  EVALBLOCK_EVDATA+7(7),DBLWD+4(4)  ebcdic format.\n         LA    R0,EVALBLOCK_EVDATA+7\n         LA    R2,EVALBLOCK_EVDATA+14\n         LA    R3,6                Maximum leading zeroes.\n         LA    R4,*+4              Top-of-loop address\n         CLI   EVALBLOCK_EVDATA+7,C'0'  Leading zero?\n         BNE   *+14                        -no -\n         BCTR  R2,0                Decrement the length\n         MVC   EVALBLOCK_EVDATA+7(6),EVALBLOCK_EVDATA+8 Shift the data.\n         BCTR  R3,R4               Count and loop.\n         SPACE 1\n         SR    R2,R0\n         ST    R0,SHVVALA-SHVBLOCK+@SHV\n         ST    R2,SHVVALL-SHVBLOCK+@SHV\n         L     R15,IRXEXCOM        Get routine's address from vector.\n         L     R0,A_ENVBLK         Make sure REXX knows environment.\n         LA    R1,PLIST_EXCOM\n         BALR  R14,R15\n         LTR   R15,R15\n         BNZ   EXCOM_FAILURE\nSTEM0_SET  DS  0H\n         SPACE 3\n         LA    R1,4095\n         LA    R0,1(,R1)\n         L     R1,@CONTROLS\n      FREEMAIN R,LV=(R0),A=(R1)\n         L     R1,E15_GOTMAIN\n         LTR   R1,R1\n         BZ    RTNXT\n         L     R0,IN_LRECL\n      FREEMAIN R,LV=(R0),A=(R1)\n         B     RTNXT\n         SPACE 3\nSORT_PLIST DS  0A\n@CONTROLS DS   A                   Address of SORT control statements.\nVE15     DS    A\nVE35     DS    A\n         DC    X'FFFFFFFF'\n         TITLE            '<< REXX - SORT from/into REXX stems         X\n                  Place record into the stem variable. The E35 exit >>'\n         DROP  R12\nTO_STEM  DS    0D\n         STM   R14,R12,12(R13)\n         USING TO_STEM,R15\n         L     R12,VSCXSORT\n         DROP  R15\n         USING SCXSORT,R12\n         ST    R13,E@5SAVE+4\n         LA    R15,E@5SAVE\n         ST    R15,8(,R13)\n         LR    R13,R15\n         XC    E@5RC,E@5RC\n         B     E35MAIN\n         SPACE 3\nE@5RC    DS    F\n         SPACE 1\nE@5SAVE  DS    18F\n         SPACE 3\nE@5XT    DS    0H\n         L     R13,E@5SAVE+4       SORT's save area.\n         XC    8(4,R13),8(R13)     Break the save area chain.\n         L     R15,E@5RC           R15 = exit return code.\n         L     R14,12(,R13)        SORT's return address.\n         LM    R0,R12,20(R13)      SORT's registers.\n         BR    R14                 Return to SORT\n         SPACE 3\nE35MAIN  DS    0H\n         L     R9,A_IRXEXTE        Get address of the vector table.\n         MVI   SHVCODE-SHVBLOCK+@SHV,SHVSTORE\n         L     R1,0(,R1)           Get address of the 'record'.\n         MVI   E@5RC+3,8           Presume we are to raise e-o-f.\n         LTR   R1,R1               Is there a record?\n         BZ    E@5XT                  -no -  made good presumption.\n         MVI   E@5RC+3,4           Tell SORT we liked what we got.\n         L     R0,OUT_LRECL        Get LRECL (when RECFM=F).\n         CLI   RECFM,C'V'          Dealing with RECFM=V\n         BNE   OUT_F                  -no -\n         ICM   R0,B'0011',0(R1)    Extract the actual LRECL and\n         S     R0,A4                  hence the length of data.\n         LA    R1,4(,R1)           Get address of record data.\nOUT_F    DS    0H\n         ST    R0,SHVVALL-SHVBLOCK+@SHV\n         ST    R1,SHVVALA-SHVBLOCK+@SHV\n         L     R1,OUT_COUNT        What tail\n         CVD   R1,DBLWD               do we create.\n         LA    R1,1(,R1)           Increment the count\n         ST    R1,OUT_COUNT           for the next pass.\n         OI    DBLWD+7,X'0F'       Ensure an ebcdic\n         UNPK  TAIL_OUT(7),DBLWD+4(4)  Use maximum of 7 digits.\n         L     R0,A_STEM_OUT       Get address of variable name\n         ST    R0,SHVNAMA-SHVBLOCK+@SHV  for EXCOM\n         LA    R1,TAIL_OUT+7       Maximum\n         SR    R1,R0                  variable name length.\n         CLI   TAIL_OUT,C'0'       Any high order zeroes?\n         BNE   TAIL_OUT_SET           -no -\n         LA    R15,TAIL_OUT\n         LA    R2,*+6              Top-of-loop address.\n         BCTR  R1,R2               Already know about leftmost byte.\n         SPACE 1\n         LA    R15,1(,R15)         Point right one byte.\n         CLI   0(R15),C'0'         High order zero?\n         BNE   *+6                    -no -\n         BCTR  R1,R2               Decrement length and loop back.\n         SPACE 1\n         MVC   TAIL_OUT(6),0(R15)  Calculate length of variable name\nTAIL_OUT_SET  DS  0H\n         ST    R1,SHVNAML-SHVBLOCK+@SHV\n         L     R15,IRXEXCOM        Get routine's address from vector.\n         L     R0,A_ENVBLK         Make sure REXX knows environment.\n         LA    R1,PLIST_EXCOM\n         BALR  R14,R15\n         LTR   R15,R15\n         BNZ   EXCOM_FAILURE\n         B     E@5XT\n         TITLE            '<< REXX - SORT from/into REXX stems         X\n                  Create records from a stem variable. The E15 exit >>'\n         DROP  R12\nFROM_STEM DS    0D\n         STM   R14,R12,12(R13)\n         USING FROM_STEM,R15\n         L     R12,VSCXSORT\n         DROP  R15\n         USING SCXSORT,R12\n         ST    R13,E@5SAVE+4\n         LA    R15,E@5SAVE\n         ST    R15,8(,R13)\n         LR    R13,R15\n         LA    R0,12               Presume a record get be generated.\n         ST    R0,E@5RC\n         SPACE 3\n         L     R9,A_IRXEXTE        Get address of the vector table.\n         L     R8,E15_GOTMAIN      Address of record buffer.\n         ST    R8,0(,R1)           Tell SORT about it.\n         L     R1,IN_COUNT         What\nNEXT_INPUT  DS  0H\n         LA    R1,1(,R1)              tail number\n         CVD   R1,DBLWD                  do we create?\n         ST    R1,IN_COUNT         Save the number for the next iterate\n         OI    DBLWD+7,X'0F'       Ensure an ebcdic.\n         UNPK  TAIL_IN(7),DBLWD+4(4)   Use maximum of 7 digits.\n         L     R0,A_STEM_IN        Get address of variable name.\n         LA    R1,TAIL_IN+7        Maximum\n         SR    R1,R0                  variable name length.\n         CLI   TAIL_IN,C'0'        Any high order zeroes?\n         BNE   TAIL_IN_SET            -no -\n         LA    R15,TAIL_IN         Start at the left.\n         LA    R2,*+6              Top-of-loop address.\n         BCTR  R1,R2               Already know about leftmost byte.\n         SPACE 1\n         LA    R15,1(,R15)         Point right one byte.\n         CLI   0(R15),C'0'         Still high order zero?\n         BNE   *+6                    -no -   Jump out of the loop.\n         BCTR  R1,R2               Decrement length and loop back.\n         SPACE 1\n         MVC   TAIL_IN(6),0(R15)   Pick-up significant digits.\nTAIL_IN_SET   DS  0H\n         ST    R1,SHVNAML-SHVBLOCK+@SHV  for EXCOM\n         L     R15,IRXEXCOM        Get routine's address from vector.\n         L     R0,A_ENVBLK         Make sure REXX knows environment.\n         LA    R1,PLIST_EXCOM\n         BALR  R14,R15\n         LTR   R15,R15\n         BNZ   EXCOM_FAILURE\n         TM    SHVRET-SHVBLOCK+@SHV,SHVNEWV\n         BO    NULL_IN\n         CLI   RECFM,C'V'\n         BNE   E15_EXIT\n         L     R0,SHVVALL-SHVBLOCK+@SHV\n         A     R0,A4\n         SLL   R0,16\n         STCM  R0,B'1111',0(R8)\nE15_EXIT DS    0H\n         L     R13,E@5SAVE+4       SORT's save area.\n         XC    8(4,R13),8(R13)     Break the save area chain.\n         LM    R14,R0,12(R13)      SORT's registers\n         L     R15,E@5RC           R15 = exit return code.\n         LR    R1,R8\n         LM    R2,R12,28(R13)      SORT's registers.\n         BR    R14                 Return to SORT\nNULL_IN  DS    0H\n         L     R1,IN_COUNT\n         C     R1,IN_LIMIT\n         BL    NEXT_INPUT\n         MVI   E@5RC+3,8           Indicate end-of-input.\n         B     E@5XT\n         TITLE            '<< REXX - SORT from/into REXX stems         X\n                     Subroutine to Strip Leading && Trailing Blanks >>'\n* Registers upon entry\n*    R10 ==> argument table entry\n*    R14 ==> exit address when agrument is null\n*    R14+4=> normal exit\n*\n* Registers upon exit\n*    R10 ==> next argument table entry.\n*    R2    = 0 (zero)\n*    R3  ==> leftmost non-blank byte of argument\n*    R4  ==> rightmost non-blank byte of argument\n*    R15   = R4 - R3 (length of argument minus 1)\n         SPACE 2\nHEXFF    DC    X'FFFFFFFFFFFFFFFF'\n         DS    XL1\nTRTABLE  DS    XL256\n         SPACE 1\nTRT3     TRT   0(0,R3),TRTABLE\n         SPACE 2\n         USING ARGTABLE_ENTRY,R10\nSTRIP    DS    0H\n         CLC   HEXFF,ARGTABLE_ARGSTRING_PTR  Is there an argument?\n         BER   R14                              -no -\n         L     R15,ARGTABLE_ARGSTRING_LENGTH\n         L     R3,ARGTABLE_ARGSTRING_PTR  Get address of argument.\n         LA    R10,ARGTABLE_NEXT   Point to next argument table entry.\n         SPACE 1\n         LTR   R15,R15             Does the argument have any length?\n         BZR   R14                    -NO - take abnormal exit.\n         LA    R4,0(R15,R3)        Point just beyond ARG.\n         MVC   TRTABLE,TRTABLE-1   Set to\n         MVI   TRTABLE+C' ',X'00'     bypass blanks.\n         BCTR  R15,0               Set length for TRT instruction.\n         EX    R15,TRT3            Skip to non-blank.\n         BZR   R14                 When all blank.\n         LR    R3,R1               Re-set starting address.\nSTRIP@R  DS    0H\n         BCTR  R4,0                Backpedal 1 byte.\n         CLI   0(R4),X'40'         (still) at a blanK?\n         BNE   STRIPPED               -no -\n         CR    R4,R3                  -yes-  More to inspect?\n         BH    STRIP@R                          -yes-\nSTRIPPED DS    0H\n         LR    R15,R4              Calculate\n         SR    R15,R3                 length of ARG - 1.\n         SR    R2,R2               Pre-clear R2 for TRT\n         XC    TRTABLE,TRTABLE     Clear translate table.\n         BC    15,4(,R14)          Take normal exit.\n         TITLE            '<< REXX - SORT from/into REXX stems         X\n                                                   Error Conditions >>'\n*\n* Refer to the IRXSAY   routine; pages 336-339 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\nSAY_LIT        DC    CL8'WRITE   '\nSAY_BUFF       DS    A\nSAY_LEN        DS    F\nSAY_PLIST      DC    A(SAY_LIT,SAY_BUFF,SAY_LEN+X'80000000')\nCOM_FAIL DC    C'IRXEXCOM failed. Return code=     .'\nARG_MSG  DC    C'1st argument not terminated by ''.'''\nNO_OUT_LRECL_MSG  DC  C'Output stem length can not be determined; SORT a\n               aborted.'\n         SPACE 2\nNO_STEM_IN     DS    0H\n         MVC   TAIL_IN+1(16),=C' does not exist.'\n         L     R15,SHVNAMA\n         LA    R0,TAIL_IN+17\n         SR    R0,R15\n         B     SAY_CALL\n         SPACE 1\nEXCOM_FAILURE  DS    0H\n         LA    R15,COM_FAIL\n         ORG   *-4\n         DC    X'00000000'\n         LA    R0,L'COM_FAIL\n         B     SAY_CALL\n         SPACE 1\nNO_OUT_LRECL  DS  0H\n         LA    R15,NO_OUT_LRECL_MSG\n         LA    R0,L'NO_OUT_LRECL_MSG\n         B     SAY_CALL\n         SPACE 1\nARG1_ERR DS    0H\n         MVC   ARG_MSG(3),=CL3'1st'\nARG_ERR  DS    0H\n         LA    R15,ARG_MSG\n         LA    R0,L'ARG_MSG\n         B     SAY_CALL\n         SPACE 1\nARG2_ERR DS    0H\n         MVC   ARG_MSG(3),=CL3'2nd'\n         B     ARG_ERR\n         SPACE 2\nSAY_CALL DS    0H\n         ST    R15,SAY_BUFF\n         ST    R0,SAY_LEN\n         LA    R1,SAY_PLIST\n         L     R0,A_ENVBLK\n         L     R15,IRXSAY\n         BALR  R14,R15\n         L     R13,SAVEAREA+4\n         XC    8(4,R13),8(R13)\n         LM    R14,R12,12(R13)\n         LA    R15,40\n         BR    R14\n         TITLE            '<< REXX - SORT from/into REXX stems         X\n                                    Global data areas and constants >>'\n         SPACE 2\nDBLWD    DS    D\n         SPACE 2\nA_ENVBLK DS    A\nA_IRXEXTE  DS  A\nA_STEM_IN  DS  A\nA_STEM_OUT DS  A\nOUT_COUNT  DS  F\nIN_COUNT DS    F\nIN_LIMIT DS    F\nA4       DC    A(4)\nX_FFFFFFF8  DS  0F\nMINUS8   DC    F'-8'\n         SPACE 1\nVSCXSORT DC    V(SCXSORT)\n         SPACE 1\nPLIST_EXCOM DC A(EXCOM_LIT,0,0)\n         DC    A(@SHV+X'80000000')\n         SPACE 1\n@SHV     DS    0A\n         DC    2A(0)\n         DC    C'S'\n         DS    XL3'000000'\n         DC    5A(0)\n         SPACE 1\nEXCOM_LIT DC   CL8'IRXEXCOM'\nE15_GOTMAIN  DS  A\nLRECL    DS    F\nIN_LRECL DS    F\nOUT_LRECL DS   F\n         SPACE 1\nPACK@R6  PACK  DBLWD(0),0(0,R6)\n         SPACE 1\nSTEM_IN  DS    0CL250\n         DS    CL245\nTAIL_IN  DS    CL7\n         SPACE 2\nSTEM_OUT DS    0CL250\n         DS    CL245\nTAIL_OUT DS    CL7\nRECFM    DS    C\n         SPACE 2\n         LTORG\n         TITLE            '<< REXX - SORT from/into REXX stems         X\n                                                 DSECTs and EQUates >>'\n         YREGS\n         SPACE 2\n       IRXENVB\n         SPACE 2\n       IRXEXTE\n         SPACE 2\n       IRXSHVB\n         SPACE 2\n       IRXEFPL\n         SPACE 2\n      IRXARGTB\n         SPACE 2\n      IRXEVALB\n         SPACE 2\n         END   SCXSORT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VARLIST": {"ttr": 3332, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x02$\\x8f\\x01\\x02$\\x8f\\x14\\x17\\x00y\\x00y\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-09-05T00:00:00", "modifydate": "2002-09-05T14:17:03", "lines": 121, "newlines": 121, "modlines": 0, "user": "PST0705"}, "text": "VARS     TITLE            '<< REXX - List all assigned variables       X\n                                                      Documentation >>'\n* Name:        VARLIST\n*\n* Purpose:     Determine the name of all initialized variables. List\n*              the variable name and up to 80 bytes of value.\n*\n* Environment: REXX subroutine/function for any REXX environment.\n*\n* Features:\n*\n* Parameters:\n* Notes:       Designed as a debugging aid.\n*\n*\n         TITLE            '<< REXX - List all assigned variables       X\n                                                     System Linkage >>'\nVARLIST  ID    R12\n         SPACE 2\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         ST    R13,SAVEAREA+4\n         LA    R15,SAVEAREA\n         ST    R15,8(,R13)\n         LR    R13,R15\n         XC    RC,RC\n         B     MAINLINE\n         SPACE 3\nRC       DS    0F\n         DS    AL1\nRC1      DS    AL1\nRC2      DS    AL1\nRC3      DS    AL1\n         SPACE 1\nSAVEAREA DS    18F\n         SPACE 3\nRTNXT    DS    0H\n         L     R13,SAVEAREA+4\n         XC    8(4,R13),8(R13)\n         XC    16(4,R13),16(R13)   R15 (return code) always\n         LM    R14,R12,12(R13)        get set to zero.\n         BR    R14\n         TITLE            '<< REXX - List all assigned variables       X\n                                                                    >>'\nMAINLINE DS    0H\n         USING ENVBLOCK,R8\n         USING IRXEXTE,R9\n         USING SHVBLOCK,R10\n         LR    R8,R0               Address the environment block.\n         L     R9,ENVBLOCK_IRXEXTE Address the REXX vector table.\n         LA    R10,@SHV            Address the SHVBLOCK.\n         MVI   SHVCODE,SHVNEXTV\n         LA    R0,L'VARNAME\n         ST    R0,SHVUSER\n         LA    R0,VARNAME\n         ST    R0,SHVNAMA\n         LA    R0,VARVALUE\n         ST    R0,SHVVALA\n         LA    R0,L'VARVALUE\n         ST    R0,SHVBUFL\n         B     CALL_EXCOM\n         TITLE            '<< REXX - List all assigned variables       X\n                                            Fetch the next variable >>'\n*\n* Refer to the IRXEXCOM routine; pages 312-319 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\nPLIST_EXCOM DC A(EXCOM_LIT,0,0)\n         DC    A(@SHV+X'80000000')\n         SPACE 1\n@SHV     DS    0A\n         DC    2A(0)\n         DC    C'N'\n         DS    XL3'000000'\n         DC    5A(0)\n         SPACE 1\nEXCOM_LIT DC   CL8'IRXEXCOM'\n         SPACE 2\nCALL_EXCOM  DS  0H\n         MVC   VARNAME,VARNAME-1\n         MVC   VARVALUE,VARVALUE-1\n         L     R15,IRXEXCOM        Get routine's address from vector.\n         LA    R0,ENVBLOCK         Make sure REXX knows environment.\n         LA    R1,PLIST_EXCOM\n         BALR  R14,R15\n         CLI   SHVRET,SHVLVAR      End of list?\n         BE    RTNXT                  -yes-\n         TITLE            '<< REXX - List all assigned variables       X\n                                                     Display a line >>'\n*\n* Refer to the IRXSAY   routine; pages 336-339 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\n         LA    R1,SAY_PLIST\n         LA    R0,ENVBLOCK\n         L     R15,IRXSAY\n         BALR  R14,R15\n         B     CALL_EXCOM\nSAY_LIT        DC    CL8'WRITE   '\nSAY_BUFF       DC    A(VARNAME)\nSAY_LEN        DC    A(79)\nSAY_PLIST      DC    A(SAY_LIT,SAY_BUFF,SAY_LEN+X'80000000')\n         TITLE            '<< REXX - List all assigned variables       X\n                                              Global Data Constants >>'\n         SPACE 2\n         DC    CL1' '\nVARNAME  DS    CL20\n         DC    CL2'= '\nVARVALUE DS    CL57\n         SPACE 2\n         LTORG\n         TITLE            '<< REXX - Get PDS directory entry           X\n                                                 DSECTs and EQUates >>'\n         YREGS\n         SPACE 2\n       IRXENVB\n         SPACE 2\n       IRXEXTE\n         SPACE 2\n       IRXSHVB\n         END  VARLIST\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VARLISTS": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x03\\x01\\x12\\x10\\x0f\\x01\\x12\\x10\\x0f\\x11&\\x00\\x88\\x00\\x88\\x00\\x00\\xe6`\\xc5\\xc9\\xd2\\xc5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2012-04-09T00:00:00", "modifydate": "2012-04-09T11:26:03", "lines": 136, "newlines": 136, "modlines": 0, "user": "W-EIKE"}, "text": "VARS     TITLE            '<< REXX - List all assigned variables       X\n                                                      Documentation >>'\n* Name:        VARLISTS\n*\n* Purpose:     Determine the name of all initialized variables.\n*              Put variable name\n*              and up to 180 bytes of value on STACK.\n*\n* Environment: REXX subroutine/function for any REXX environment.\n*\n* Features:\n*\n* Parameters:\n* Notes:       Designed as a debugging aid.\n*              This Program is based on VARLIST (CBT File 520)\n*\n*\n         TITLE            '<< REXX - List all assigned variables       X\n                                                     System Linkage >>'\n* VARLISTS ID    R12\nVARLISTS CSECT\nVARLISTS RMODE 24                      For TPUT\nVARLISTS AMODE 31\n&D       SETC  '&SYSDATE'(7,2)'-'.'&SYSDATE'(1,2)'-'.'&SYSDATE'(4,2)\n         USING VARLISTS,R12\n         SPACE 2\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         ST    R13,SAVEAREA+4\n         LA    R15,SAVEAREA\n         ST    R15,8(,R13)\n         LR    R13,R15\n         XC    RC,RC\n         B     MAINLINE\n         SPACE 3\nRC       DS    0F\n         DS    AL1\nRC1      DS    AL1\nRC2      DS    AL1\nRC3      DS    AL1\n         SPACE 1\nSAVEAREA DS    18F\n         SPACE 3\nRTNXT    DS    0H\n         L     R13,SAVEAREA+4\n         XC    8(4,R13),8(R13)\n         XC    16(4,R13),16(R13)   R15 (return code) always\n         LM    R14,R12,12(R13)        get set to zero.\n         BR    R14\n         TITLE            '<< REXX - List all assigned variables       X\n                                                                    >>'\nMAINLINE DS    0H\n         USING ENVBLOCK,R8\n         USING IRXEXTE,R9\n         USING SHVBLOCK,R10\n         LR    R8,R0               Address the environment block.\n         L     R9,ENVBLOCK_IRXEXTE Address the REXX vector table.\n         LA    R10,@SHV            Address the SHVBLOCK.\n         MVI   SHVCODE,SHVNEXTV\n         LA    R0,L'VARNAME\n         ST    R0,SHVUSER\n         LA    R0,VARNAME\n         ST    R0,SHVNAMA\n         LA    R0,VARVALUE\n         ST    R0,SHVVALA\n         LA    R0,L'VARVALUE\n         ST    R0,SHVBUFL\n         B     CALL_EXCOM\n         TITLE            '<< REXX - List all assigned variables       X\n                                            Fetch the next variable >>'\n*\n* Refer to the IRXEXCOM routine; pages 312-319 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\nPLIST_EXCOM DC A(EXCOM_LIT,0,0)\n         DC    A(@SHV+X'80000000')\n         SPACE 1\n@SHV     DS    0A\n         DC    2A(0)\n         DC    C'N'\n         DS    XL3'000000'\n         DC    5A(0)\n         SPACE 1\nEXCOM_LIT DC   CL8'IRXEXCOM'\n         SPACE 2\nCALL_EXCOM  DS  0H\n         MVC   VARNAME,VARNAME-1\n         MVC   VARVALUE,VARVALUE-1\n         L     R15,IRXEXCOM        Get routine's address from vector.\n         LA    R0,ENVBLOCK         Make sure REXX knows environment.\n         LA    R1,PLIST_EXCOM\n         BALR  R14,R15\n         CLI   SHVRET,SHVLVAR      End of list?\n         BE    RTNXT                  -yes-\n         TITLE            '<< REXX - List all assigned variables       X\n                                                     Display a line >>'\n*\n* Refer to the IRXSAY   routine; pages 336-339 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\n         LA    R1,SAY_PLIST\n         LA    R0,ENVBLOCK\n         L     R15,IRXSTK\n         BALR  R14,R15\n         B     CALL_EXCOM\nSAY_LIT        DC    CL8'QUEUE   '\nSAY_BUFF       DC    A(VARNAME)\nSAY_LEN        DC    A(179)\nSAY_RES        DC    A(0)\nSAY_ENV        DC    A(0)\nSAY_RC         DC    A(0)\nSAY_PLIST      DC    A(SAY_LIT)\n               DC    A(SAY_BUFF)\n               DC    A(SAY_LEN)\n               DC    A(SAY_RES)\n               DC    A(SAY_ENV)\n               DC    A(SAY_RC+X'80000000')\n         TITLE            '<< REXX - List all assigned variables       X\n                                              Global Data Constants >>'\n         SPACE 2\n         DC    CL1' '\nVARNAME  DS    CL20\n         DC    CL2'= '\nVARVALUE DS    CL157\n         SPACE 2\n         LTORG\n         TITLE            '<< REXX - Get PDS directory entry           X\n                                                 DSECTs and EQUates >>'\n         YREGS\n         SPACE 2\n       IRXENVB\n         SPACE 2\n       IRXEXTE\n         SPACE 2\n       IRXSHVB\n         END  VARLISTS\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WILDCARD": {"ttr": 3338, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x15\\x7f\\x01\\x01\\x15\\x7f\\x15\\x18\\x01\\xfc\\x01\\xfc\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-06T00:00:00", "modifydate": "2001-06-06T15:18:00", "lines": 508, "newlines": 508, "modlines": 0, "user": "PST0705"}, "text": "./ ADD NAME=$README  0100-01157-01157-1511-00026-00026-00000-PST0705\nInstallation / readme for WILDCARD\n\nThere are 4 component for this package\n\nID.MAC  Is an Assembler macro required to assemble each of the assembler\n        routines. Put it into a library included in your SYSLIB\n        concatenation for the assemblies.\n\nSCCWC001.ASM  Is an assembler subroutine required for WILDCARD. Assemble\n        it into an object or call library so that it can be link edited\n        into WILDCARD.  Note that this subroutine could be CALLed by any\n        program wishing to get an answer to 'does this generic entry\n        match this static entry?'\n\nWILDCARD.ASM  Is an assembler routine which runs as a Rexx function to\n        set a logical value answering the question  'does this generic\n        entry match this static entry?'\n\nWILDCARD.HLP  Is the documentation on how a REXX program can use the\n        function\n\nMaking WILDCARD available to your rexx program can be as simple as link\nediting it to a load library that is within the JOBLIB/STEPLIB\nconcatenation when the rexx program runs. Myself, I have built a Rexx\nfunction package under the name IRXFLOC which contains all the assembler\nwritten rexx functions for the platform.\n./ ADD NAME=HELP     0100-01157-01157-1511-00053-00053-00000-PST0705\n Name:        WILDCARD\n\n Purpose:     Set a logical value as to whether or not the first\n              argument is 'matched' to the second argument.\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              WILDCARD resides in the IRXFLOC \"function package\".\n\n Arguments:\n           1. The selection criterea. The criterea is composed of a\n              combination of natural characters and two 'wildcard'\n              values. The natural characters must be matched (within\n              positional context) to the second argument value.\n\n              The 'wildcard' values and there action are:\n                 '*' (asterisk) will 'match' to any value of any\n                     length (including zero) in the 'target'.\n                 '%' (percent sign) will 'match' any value in the\n                     'target' but the corresponding 'target' position\n                     must be occupied i.e not null\n\n              'Wildcard' values can be specified multiple times.\n\n\n           2. The 'target' field. This argument contains the value\n              the selection criterea will attempt to match.\n\n\n Results:    1 means the 'target' is matched.\n\n             0 means the 'target' is not matched.\n\n\n Examples:\n             wildcard('PST*','PST0705') --> 1\n\n             wildcard('*705','PST0705') --> 1\n\n             wildcard('*07*','PST0705') --> 1\n\n             wildcard('*0%0*','PST0705') --> 1\n\n             wildcard('PST0705%','PST0705') --> 0\n\n             wildcard('PST%','PST0705') --> 0\n\n             if wildcard('ANYMEM*',mem) then\n               do\n                  call sccpdsr('PDS1',mem,'MEM.')\n                  do i = 1 to mem.0\n                       if find(mem.i,'COPY') then call read_copy\n                  end\n               end\n./ ADD NAME=ID       0100-01157-01157-1459-00049-00049-00000-PST0705\n         MACRO\n&LABEL   ID    &USING,&CSECT=YES,&AMODE=31,&RMODE=ANY\n         LCLC  &U,&LBL\n.*\n.* Stelco macro used to:\n.*    - generate the CSECT statement.\n.*    - generate the USING, AMODE and RMODE statements for the CSECT.\n.*    - generate an eye-catcher and date/time stamp (28 bytes total).\n.*      (The values for date and time are the time of the Assembly.)\n.*\n.* The default for the USING statement is (register) 15.\n.* Other defaults are as per the prototype above.\n.*\n.* If the CSECT requires multiple base registers, their specification\n.* must be enclosed in parenthesis.       e.g.  BIGRTN   ID     (12,11)\n.*\n.* This macro can also be used to generate only the eye-catcher and\n.* date/time stamp. For this type of usage specify   ID    ,CSECT=NO\n.*\n.* -----------------------Modification History-------------------------\n.* 98-02-19 change from &SYSDATE to &SYSDATC\n.*\n&U       SETC  '15'\n&LBL     SETC  ' '\n         AIF   (K'&LABEL EQ 0).LBLSET\n&LBL     SETC  '&LABEL'\n.LBLSET  ANOP\n         AIF   (T'&USING EQ 'O').USET\n         AIF   ('&USING'(1,1) NE '(').ONEUSE\n&U       SETC  '&USING'(2,K'&USING-2)\n         AGO   .USET\n.ONEUSE  ANOP\n&U       SETC  '&USING'\n.USET    ANOP\n         AIF   ('&CSECT' EQ 'YES').CSECT\n&LBL     DS    0H\n         B     *+32\n         AGO   .STAMP\n.CSECT   ANOP\n&LBL     CSECT\n&LBL     AMODE &AMODE\n&LBL     RMODE &RMODE\n         USING &LABEL,&U\n         BC    15,32(,15)\n.STAMP   ANOP\n         DS    CL4\n         DC    CL8'&LBL'\n         DC    CL16'&SYSDATC &SYSTIME'\n         MEND\n./ ADD NAME=SCCWC001 0100-01157-01157-1515-00139-00139-00000-PST0705\n* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *\n*\n* Program name :  SCCWC001\n*\n* Function:       Determine if the selection parameter (which may\n*                 contain 'wildcard' specifications of * and %) is\n*                 matched to the target parameter.\n*\n*                 A wildcard value of percent sign (or x'FF') means\n*                 the corresponding column in the target must exist.\n*                 A wildcard value of asterisk will match to any\n*                 string of any length (including 0) in the target.\n*\n*                 Multiple wildcard specifications are valid.\n*\n* Parameters:  1. The 'selection' field. A string of characters which\n*                 may contain 'wildcard' values as described above.\n*                 All non-wildcard values are compared for an exact\n*                 match against the target parameter.\n*\n*              2. Fullword field whose hexadecimal value is the\n*                 length of parameter 1.\n*\n*              3. The 'target' field. This (sub)field is what the\n*                 'selection' parameter is attempting to match.\n*\n*              4. Fullword field whose hexadecimal value is the\n*                 length of parameter 3.\n*\n* Output:      SCCWC001 produces no output parameter. It sets the\n*              condition code to zero if a match is made and sets the\n*              condition code to other than zero if no match is made.\n*              (No meaning other than 'not equal' should be derived\n*              from condition code settings of 1 or 2; condition code\n*              3 should never be set.)\n*\n* Updates:\n*     Jun. 1995    - R. Ryerse. Original composition.\n*\n* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *\nSCCWC001 ID    R12\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         B     START\nFORCE_EQUAL DS 0H\n         SR    R0,R0\n         B     RTNXT\nFORCE_LOW  DS  0H\n         CLI   SCCWC001,X'FF'\n         B     RTNXT\nFORCE_HIGH  DS 0H\n         CLI   SCCWC001,X'00'\nRTNXT    DS    0H\n         LA    R0,0                  Need a convenient zero to\n         ST    R0,16(,R13)              set R15 to zero.\n         LM    R14,R12,12(R13)       Re-set callers registers.\n         BR    R14                   Return to caller.\n         SPACE 3\nSTART    DS    0H\n         XC    A_STAR,A_STAR         We have no asterisk (yet).\n         LM    R3,R6,0(R1)           Pick-up parameter addresses.\n         L     SELECT_COUNT,0(,R4)   Get length(select).\n         L     TARGET_COUNT,0(,R6)   Get length(target).\n         LA    R1,0(TARGET_COUNT,TARGET)\n         LA    R7,*+4\n         BCTR  R1,0\n         CLI   0(R1),C' '\n         BNE   *+6\n         BCTR  TARGET_COUNT,R7\n         LA    R7,LOOP\nLOOP     DS    0H            The major loop.\n         CLI   0(SELECT),C'*'        Match everything?\n         BNE   NOT_ASTERISK             -no -\n         LA    R7,LOOP@                 -yes-   Switch to minor loop\n         B     COUNT_SELECT                        and continue.\nNOT_ASTERISK   DS    0H\n         CLI   0(SELECT),C'%'        Match any character?\n         BE    COUNT_TARGET             -yes-\n         CLC   0(1,SELECT),0(TARGET) Matched?\n         BNE   RE_LOOP                  -no - double check needed.\nCOUNT_TARGET   DS    0H\n         LA    TARGET,1(,TARGET)     Step along to next 'target' byte.\n         BCT   TARGET_COUNT,COUNT_SELECT  Count and continue.\n         B     END_OF_TARGET         'Target' is exhausted.\nCOUNT_SELECT   DS    0H\n         LA    SELECT,1(,SELECT)     Step along to next 'select' byte.\n         BCTR  SELECT_COUNT,R7       Count the select and loop.\n         SPACE 2\n* The 'select' field is exhausted but 'target' is not.\n         LA    R0,LOOP@              Was last 'select' byte\n         CR    R0,R7                    an asterisk?\n         BE    RTNXT                       -yes-   We have a match\nRE_LOOP  DS    0H\n         LM    SELECT,TARGET_COUNT,A_STAR\n         LTR   SELECT,SELECT         Was there a previous asterisk?\n         BZ    FORCE_LOW                -no -\n         LA    TARGET,1(,TARGET)     Post asterisk matched plus one\n         BCT   TARGET_COUNT,LOOP@@      and length minus one.\n         B     FORCE_LOW             Target went exhausted.\nEND_OF_TARGET  DS    0H\n         LA    SELECT,1(,SELECT)     Step along to next 'select' byte.\n         BCT   SELECT_COUNT,*+8      Count 'select'.\n         B     FORCE_EQUAL           'Select' equally exhausted.\n         CLI   0(SELECT),C'*'        Afterthought '*'\n         BE    END_OF_TARGET            -yes-   Keep checking.\n         B     FORCE_HIGH               -no -   No match.\n         EJECT\nLOOP@    DS    0H            After '*' in select.\n         CLI   0(SELECT),C'*'        Another asterisk?\n         BE    COUNT_SELECT@            -yes-   Really has no meaning.\n         CLI   0(SELECT),C'%'        Looking for any character?\n         BNE   LOOP@@                   -no -\n         LA    TARGET,1(,TARGET)     Step along to next 'target' byte.\n         BCT   TARGET_COUNT,COUNT_SELECT@ Decrement 'target' count.\n         B     END_OF_TARGET@        'Target' is exhausted.\nCOUNT_SELECT@  DS    0H\n         LA    SELECT,1(,SELECT)     Step along to next 'select' byte.\n         BCTR  SELECT_COUNT,R7       Count the select and loop.\n         B     FORCE_EQUAL           'Select' is exhausted.\nEND_OF_TARGET@ DS    0H\n         BCT   SELECT_COUNT,FORCE_LOW Count 'select'. No match if more.\n         B     FORCE_EQUAL           'Select' equally exhausted.\nLOOP@@   DS    0H\n         LA    R7,LOOP               Revert to major loop.\n         STM   SELECT,TARGET_COUNT,A_STAR\n         CLC   0(1,SELECT),0(TARGET) Matched?\n         BE    COUNT_TARGET             -yes-   Jump into major loop.\n         LA    TARGET,1(,TARGET)     Step along to next 'target' byte.\n         BCT   TARGET_COUNT,LOOP@@+4 Decrement 'target' count. Loop.\n         B     RTNXT                 LOOP@@+8 has set condition code.\n         SPACE 3\n         DS    0D\nA_STAR   DS    XL16\n         YREGS\nSELECT         EQU   R3\nSELECT_COUNT   EQU   R4\nTARGET         EQU   R5\nTARGET_COUNT   EQU   R6\n         END   SCCWC001\n./ ADD NAME=WC       0100-01157-01157-1511-00043-00043-00000-PST0705\n/* REXX subroutine/function which determines if a selection operand\n   which may contain \"wildcard\" values is matched to a second operand.\n   The valid \"wildcard\" values are:\n   % - The corresponding position of the 2nd operand must be filled.\n      * - Any string (including null) of any length from the 2nd\n          operand is a 'match'.                                       */\nparse arg select, target\nprefix = 0\ndo while pos('*',select,) > 0\n     parse var select sub_select '*' select\n     if sub_select = '' then\n       do\n          if select = '' then return 1\n          prefix = 1\n          ? = left(select,1)\n          select\n               when ? = '*' then nop\n               when ? = '%' then\n                 do\n                    ?? = compare(select,copies('%',length(select)))\n                    ? = pos(substr(select,??,1),target)\n                    if ? = 0 then return 0\n                    target = substr(target,?-??+1)\n                 end\n               otherwise parse var target (?)-0 target\n          end\n       end\n     else\n       do\n          sub_select = merge@pc(sub_select,target)\n          if \\prefix & sub_select \\== left(target,length(sub_select)) then retur\n          if  prefix & pos(sub_select,target) = 0 then return 0\n          parse var target (sub_select) target\n       end\nend\nif select \\= '' then\n  do\n     if arg(2) \\== target then prefix = 1\n     if prefix then target = right(target,length(select))\n     if merge@pc(select,target) \\== target then return 0\n  end\nreturn 1\n\n./ ADD NAME=WILDCARD 0100-01157-01157-1511-00192-00192-00000-PST0705\n* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *\n*\n* Program name :  WILDCARD\n*\n* Environment:    REXX Function/Subroutine\n*\n* Function:       Set logical value (0 or 1) which answers the question\n*                 'does arg(1) match arg(2)?' wherein arg(1) can\n*                 include (multiple occurrances of) * (asterisk) and/or\n*                 % (percent sign).\n*\n* Parameters:  1. The 'select' mask. A string of characters which may\n*                 contain the wildcard values.\n*\n*              2. The 'target' field which is to be matched.\n*                 length of parameter 1.\n*\n* Output          0   (the select field was not matched)\n*                 1   (the select field was matched)\n*\n* Notes:          WILDCARD is the REXX function/subroutine shell. The\n*                 actual 'matching' is done via the assembler\n*                 subroutine SCCWC001.\n*\n* Updates:\n*     Jun. 1995    - R. Ryerse. Original composition.\n*\n* ** ** ** ** ** ** ** ** ** ** ** * ** ** ** ** ** ** ** ** ** ** ** *\nWILDCARD ID    R12\n         SPACE 2\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         ST    R13,SAVEAREA+4\n         LA    R15,SAVEAREA\n         ST    R15,8(,R13)\n         LR    R13,R15\n         XC    RC,RC\n         B     MAINLINE\n         SPACE 3\nRC       DS    0F\n         DS    AL1\nRC1      DS    AL1\nRC2      DS    AL1\nRC3      DS    AL1\n         SPACE 1\nSAVEAREA DS    18F\n         SPACE 3\nRTNXT    DS    0H\n         L     R13,SAVEAREA+4\n         XC    8(4,R13),8(R13)\n         XC    16(4,R13),16(R13)   R15 (return code) always\n         LM    R14,R12,12(R13)        get set to zero.\n         BR    R14\n         TITLE            '<<                                          X\n                                                Parse the Arguments >>'\nMAINLINE DS    0H\n         USING EFPL,R1\n         USING ENVBLOCK,R8\n         USING IRXEXTE,R9\n         USING ARGTABLE_ENTRY,R10\n         USING EVALBLOCK,R11\n         LR    R8,R0               Address the environment block.\n         L     R9,ENVBLOCK_IRXEXTE Address the REXX vector table.\n         LM    R10,R11,EFPLARG     Address ARGTABLE & EVALBLOCK.\n         L     R11,0(,R11)\n         MVI   TRTABLE-1,X'FF'     Pre-set table value.\n         BAL   R14,STRIP           Strip out arg(1).\n         B     MISSING_MASK        Arg(1) not specified.\n         ST    R3,PLIST            Need argument address\n         LA    R15,1(,R15)            and\n         ST    R15,LENGTH1               length.\n         SPACE 1\n         BAL   R14,STRIP           Strip out arg(2).\n         B     MISSING_TARGET      Arg(2) not specified\n         ST    R3,PLIST+8          Need argument address\n         LA    R15,1(,R15)            and\n         ST    R15,LENGTH2               length.\n         MVI   EVALBLOCK_EVDATA,C'1'  Presume 'matched' for result.\n         LA    R0,1                Length of result\n         ST    R0,EVALBLOCK_EVLEN     is always 1.\n         LA    R1,PLIST            CALL\n         L     R15,VSCCWC001          SCCWC001\n         BALR  R14,R15                   to set condition code.\n         BE    RTNXT               Presumtion was correct.\n         MVI   EVALBLOCK_EVDATA,C'0'  Say 'not matched' in result.\n         B     RTNXT\n         SPACE 3\n         TITLE            '<<                                          X\n                     Subroutine to Strip Leading && Trailing Blanks >>'\n* Registers upon entry\n*    R10 ==> argument table entry\n*    R14 ==> exit address when agrument is null\n*    R14+4=> normal exit\n*\n* Registers upon exit\n*    R10 ==> next argument table entry.\n*    R2    = 0 (zero)\n*    R3  ==> leftmost non-blank byte of argument\n*    R4  ==> rightmost non-blank byte of argument\n*    R15   = R4 - R3 (length of argument minus 1)\n         SPACE 2\nHEXFF    DC    X'FFFFFFFFFFFFFFFF'\n         DS    XL1\nTRTABLE  DS    XL256\nTRT3     TRT   0(0,R3),TRTABLE\n         SPACE 2\nSTRIP    DS    0H\n         CLC   HEXFF,ARGTABLE_ARGSTRING_PTR  Is there an argument?\n         BER   R14                              -no -\n         L     R15,ARGTABLE_ARGSTRING_LENGTH\n         L     R3,ARGTABLE_ARGSTRING_PTR  Get address of argument.\n         LA    R10,ARGTABLE_NEXT   Point to next argument table entry.\n         SPACE 1\n         LTR   R15,R15             Does the argument have any length?\n         BZR   R14                    -NO - take abnormal exit.\n         LA    R4,0(R15,R3)        Point just beyond ARG.\n         MVC   TRTABLE,TRTABLE-1   Set to\n         MVI   TRTABLE+C' ',X'00'     bypass blanks.\n         BCTR  R15,0               Set length for TRT instruction.\n         EX    R15,TRT3            Skip to non-blank.\n         BZR   R14                 When all blank.\n         LR    R3,R1               Re-set starting address.\nSTRIP@R  DS    0H\n         BCTR  R4,0                Backpedal 1 byte.\n         CLI   0(R4),X'40'         (still) at a blanK?\n         BNE   STRIPPED               -no -\n         CR    R4,R3                  -yes-  More to inspect?\n         BH    STRIP@R                          -yes-\nSTRIPPED DS    0H\n         LR    R15,R4              Calculate\n         SR    R15,R3                 length of ARG - 1.\n         SR    R2,R2               Pre-clear R2 for TRT\n         XC    TRTABLE,TRTABLE     Clear translate table.\n         BC    15,4(,R14)          Take normal exit.\n         TITLE            '<<                                          X\n                                                   Error Conditions >>'\n*\n* Refer to the IRXSAY   routine; pages 336-339 of SC28-1883-06 -\n* TSO Extentions Version 2  REXX/MVS Reference\n*\nSAY_LIT        DC    CL8'WRITE   '\nSAY_BUFF       DS    A\nSAY_LEN        DS    F\nSAY_PLIST      DC    A(SAY_LIT,SAY_BUFF,SAY_LEN+X'80000000')\nMISSING_MASK_MSG   DC C'First argument (MASK) missing.'\nMISSING_TARGET_MSG DC C'Second argument (TARGET) missing.'\nMISSING_MASK   DS    0H\n         LA    R15,MISSING_MASK_MSG\n         LA    R0,L'MISSING_MASK_MSG\n         B     SAY_CALL\nMISSING_TARGET DS    0H\n         LA    R15,MISSING_TARGET_MSG\n         LA    R0,L'MISSING_TARGET_MSG\n         B     SAY_CALL\nSAY_CALL DS    0H\n         ST    R15,SAY_BUFF\n         ST    R0,SAY_LEN\n         LA    R1,SAY_PLIST\n         LA    R0,ENVBLOCK\n         L     R15,IRXSAY\n         BALR  R14,R15\n         L     R13,SAVEAREA+4\n         XC    8(4,R13),8(R13)\n         LM    R14,R12,12(R13)\n         LA    R15,40\n         BR    R14\n         TITLE            '<<                                          X\n                                              Global Data Constants >>'\n         SPACE 2\n         DS    0D\n         SPACE 2\nVSCCWC001 DC   V(SCCWC001)\n         SPACE 1\nPLIST    DC    A(0,LENGTH1,0,LENGTH2+X'80000000')\nLENGTH1  DS    F\nLENGTH2  DS    F\n         SPACE 2\n         LTORG\n         TITLE            '<<                                          X\n                                                 DSECTs and EQUates >>'\n         YREGS\n         SPACE 2\n       IRXENVB\n         SPACE 2\n       IRXEXTE\n         SPACE 2\n       IRXEFPL\n         SPACE 2\n      IRXARGTB\n         SPACE 2\n      IRXEVALB\n         END   WILDCARD\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT520/FILE520.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT520", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}