{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011859000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 3703518, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 40, "INMDSNAM": "CBT.V500.FILE380.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 3703518, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 3703518, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE380.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00<\\x12'", "DS1TRBAL": "b'\\t*'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\xb7\\x00\\x02\\x02\\xbb\\x00\\x02\\x00='", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x046\\x00\\x00\\x01\\x021?\\x01\\x021? F\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf5\\xf4@@@'", "ispf": {"version": "04.54", "flags": 0, "createdate": "2002-11-09T00:00:00", "modifydate": "2002-11-09T20:46:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-454"}, "text": "REGULAR CBT TAPE - VERSION 454    FILE:  380\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT454.FILE380\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 204 MEMBERS COUNTED; CUMULATIVE SIZE IS 33,783 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/09/02    20:46:47    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$COPYR": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x18\\x00\\x18\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "MCRITCH"}, "text": "********************************************************************\n\n  COPYRIGHT (C) BY  F. DAVID MCRITCHIE.  ALL RIGHTS RESERVED.\n\n  The material contained in this library is a part of a collection of\n  coding and documentation.\n\n  Particular license is granted to distribute these programs as part\n  of the CBT collection where a small service charge for distribution\n  is appropriate.\n\n  My name must remain with the coding.\n\n  Commercial distribution and for sale distribution by anyone other\n  than the author is expressly prohibited.\n\n  The material in this library may also be available and located\n  from my website.\n      \"The REXX Macros Toolbox\" which can be found at\n      http://members.aol.com/dmcritchie/home.htm\n\n                               F. David McRitchie\n                               Email: DMcRitchie@aol.com\n********************************************************************\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$BROWSE": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x9a\\x00\\x9a\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 154, "newlines": 154, "modlines": 0, "user": "MCRITCH"}, "text": "/*$BROWSE   AUTHOR: DAVID MCRITCHIE, CREATED 1985/07/13 IS03--rexx*/\n/*          AT \"The REXX Macros Toolbox\"                        */\n/*          UPDATED 1991/06/28 17:53 IS03                     */\n/*PROC 1 DSNAME  PANEL() TRACE */\n/*$BROWSE   AUTHOR: DAVID MCRITCHIE, CREATED 1985/12/04 IS03\n            \"The REXX Macros Toolbox\",  now at DMcRitchie@aol.com\n            UPDATED 1991/12/24 11:33 IS03\n            UPDATED 1993/10/18 16:24 IS03 CONVERTED TO REXX\n            UPDATED 1994/02/22 14:30 IS03 FOR GDG(-n) relative\n           PURPOSE: EDIT A DATASET FROM WITHIN EDIT OR OTHER\n                    ISPF PANEL -- DSNAME REQUIRED UPON ENTRY.\n                               -- CHECKS EXISTANCE AND RACF ACCESS.\n           CONTRIBUTED:   F. David McRitchie\n           USER CONTACT:  F. David McRitchie \"The REXX Macros Toolbox\"\n           CODE MAINT.:   SYSTECH GROUP\n           $BROWSE IS NOW PATTERNED ON THE $EDIT CLIST\n  ****************************************************************\n     A COMPLETE DSNAME MUST BE PROVIDED\n        -- CAN BE ENCLOSED IN QUOTES, IF YOU SO WISH.\n        -- MEMBERNAME MAY BE INCLUDED AS PART OF DSNAME.\n        -- WILL NOT PREFIX THE USERID TO THE DSNAME.\n     A DATASET LEVELNAME MAY BE PROVIDED IN WHICH CASE\n        -- ALL OTHER OPTIONS WILL BE IGNORED, MEMBERNAME NOT ALLOWED\n           E.G.  ==> $BROWSE IS03.*.TEXT\n  *****************************************************************/\n      /*  ---INSURE DSNAME IS SURROUNDED BY QUOTES AND ...  */\n      /*  --- CREATE RDSNAME (WITHOUT MEMBERNAME) TO CHECK RACF */\n        PARSE ARG TOKEN; TOKEN=TRANSLATE(TOKEN)\n        PARSE VAR TOKEN DSNAME ' ' TOKEN\n        SYSUID = SYSVAR('SYSUID')\n        TOKEN = ' '||TOKEN||' '\n/*********not applicable to $BROWSE***********************************/\n/*         MACRO=KEYWORD('MACRO')                                    */\n/*         NEW =PROCESS('NEW')                                       */\n/*********************************************************************/\n        PANEL=KEYWORD('PANEL')\n        TRACE=PROCESS('TRACE')\n\n        IF TOKEN \\= '' THEN\n           SAY 'UNRESOLVED OPERANDS ARE:' TOKEN\n\n        L = LENGTH(DSNAME)\n        XX = SUBSTR(DSNAME,1,1)SUBSTR(DSNAME,L,1)\n        IF XX = \"''\" THEN DSNAME = SUBSTR(DSNAME,2,L-2)\n        /* MUST NOT HAVE MEMBERNAME*/\n        CDSNAME = DSNAME\n        PARSE VAR CDSNAME LEVEL '(' MEMBER ')'\n        if member \\= '' then cdsname = level\n        if datatype(member, \"Whole number\") = 1 then do\n           /* dealing with a GDG dataset so get the correct dsn*/\n           Call OutTrap \"ListCat.\", \"*\", \"noconcat\"\n           \"ListCat Entry('\"cdsname\"') GDG all\"\n           if rc > 0 then signal failure\n           if member > 0 then\n               errmsg('GDG relative numbers > 0 do not exist')\n           lineno = listcat.0  + member  /* relative goes backward*/\n           parse var listcat.lineno \"NONVSAM--\" cdsname\n           member = \"\"  /* finished with relative number as member*/\n        end;\n        RDSNAME = CDSNAME       /* RACF NAME */\n        I = POS('*',cdsname)\n        IF  I  \\= 0 THEN DO\n          /* E.G.   ==> TSO $BROWSE IS03.*.CNTL */\n          ADDRESS \"ISPEXEC\" \"VGET ZDLDSNLV PROFILE\"\n          OLD = ZDLDSNLV\n          ZDLDSNLV = CDSNAME\n          ADDRESS \"ISPEXEC\" \" VPUT ZDLDSNLV PROFILE\"\n          /* ACCORDING TO Q417856 QUALIFIED DATASET*/\n          /* SHOULD HAVE USED LMMDISP. */\n          /* METHOD USED HAS PANEL OPTIONS AVAILABLE*/\n          ADDRESS \"ISPEXEC\" \"SELECT PGM(ISRUDL) PARM(ISRUDLP)\"\n          ZDLDSNLV = OLD\n          ADDRESS \"ISPEXEC\" \"VPUT ZDLDSNLV PROFILE\"\n          RETURN 0\n        END\n        RMEMBER = MEMBER\n      /*  ----------- CHECK FOR EXISTENCE OF THE DATASET ----*/\n        IF MEMBER \\= '' THEN IF POS('*',MEMBER) = 0 ,\n           THEN CDSNAME = DSNAME\n        CHK =  SYSDSN(\"'\"CDSNAME\"'\")\n/************not applicable to $BROWSE********************************/\n/*         IF CHK = 'MEMBER NOT FOUND' THEN DO                       */\n/*           IF NEW = \"NEW\" THEN CHK = \"OK\"                          */\n/*           ELSE SAY CHK||\" -- USE OPTION \"\"NEW\"\" TO ALLOW\"         */\n/*        END                                                        */\n/*********************************************************************/\n       IF CHK = \"OK\" THEN DO\n          /*  ------- MAKE AVAILABLE TO OTHER CLISTS --------*/\n          ADDRESS \"ISPEXEC\" \" VPUT DSNAME SHARED\"\n          ADDRESS \"ISPEXEC\" \" VPUT RDSNAME SHARED\"\n          /*  ------- TRAP SYSOUT FOR RACF CHECKING ---------*/\n          TRAP.=\n          X = OUTTRAP(\"TRAP.\",\"*\")\n             \"LD DATASET('\"RDSNAME\"') GENERIC\"\n          X= OUTTRAP(\"OFF\")\n          IF SUBSTR(TRAP.1,1,3) = \"ICH\" THEN\n              IF SUBSTR(TRAP.1,1,8) \\= ICH35003 ,\n                THEN DO\n                   ZEDSMSG = 'NOT AUTHORIZED'\n                   ZEDLMSG = TRAP.1 '-- HIT',\n                     'ENTER NOT PFK-3'\n                   ADDRESS \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n                   RETURN 12\n               END\n          /*  ------- DATASET EXITS AND RACF S/B HAPPY ------*/\n       BYPX:\n          ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"\n          ADDRESS \"ISPEXEC\" \"BROWSE DATASET('\"DSNAME\"')\" PANEL\n          RCX = RC\n          /* not bothering much with $BROWSE errors */\n          zedsmsg = zerrsm\n          zedlmsg = zerrlm 'RC='rcx\n          address \"ISPEXEC\" \"setmsg msg(isrz000)\"\n          X = MSG('OFF')\n          ADDRESS \"TSO\" \"FREE DATASET('\"RDSNAME\"')\"\n          X = MSG('ON')\n          RETURN RCX\n       END\n       /* ----------- DATASET DOES NOT EXIST ----------------*/\n       SAY \"'\"DSNAME\"'\"   CHK\n       ZEDSMSG = 'INVALID DSN'\n       ZEDLMSG = \"FAILED -- \"CHK\" -- '\"DSNAME\"'\"\n       ADDRESS \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n       SAY \"TSO $BROWSE\" DSNAME \"FAILED DUE TO '\"CHK\"'\"\n       SAY \"AN EXAMPLE WITH A CORRECT SYNTAX IS      ===> TSO $BROWSE\" ,\n         SYSUID\".LIBR.CNTL\"\n       SAY \"TSO $BROWSE FAILED FOR  DSNAME=\"DSNAME\"   DUE TO '\"CHK\"'\"\n       RETURN 12\nPROCESS: PROCEDURE EXPOSE TOKEN\n ARG SUBTOKEN\n I = POS(' '||SUBTOKEN||' ',TOKEN)\n IF I=0 THEN RETURN ''\n TOKENX = SUBSTR(TOKEN,1,I) || SUBSTR(TOKEN,I+2+LENGTH(SUBTOKEN))\n TOKEN = TOKENX\n RETURN SUBTOKEN\n KEYWORD:\n  PARSE ARG KEY\n  KEY1 = ' '||KEY||'('\n  PARSE VAR TOKEN  LEFT   (KEY1) VALUE ')' RIGHT\n  TOKEN = LEFT RIGHT\n  IF VALUE = \"\" THEN RETURN ''\n  RETURN KEY\"(\"VALUE\")\"\nErrMsg: Procedure expose RC;\n   Parse arg Text;\n   Say Center(\" \"Text\" \", 79, \"*\");\n   RC = 12;\n   Exit RC;   /* do not return */\n\n/* In the event of a failure following ListCat, emit it */\nFailure:\n   Do I = 1 to ListCat.0;\n      Say ListCat.I;\n   End;\n   Exit RC;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$D": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x03Y\\x03Y\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 857, "newlines": 857, "modlines": 0, "user": "MCRITCH"}, "text": "/*                                 REXX                             */\n/*  obtained from TECH.CBT.FILE166.PDS($D) -------------------------*/\n/*                                                                  */\n/*      This REXX exec will display different MVS control blocks    */\n/*                                                                  */\n/*      Note:  The HELP Text itself is part of this EXEC.           */\n/*      It begins after '/*BEGHELP ... */' and ends at              */\n/*      '/*ENDHELP ...*/'.  Any invalid parm will cause the         */\n/*      Help text to be displayed.                                  */\n/*                                                                  */\n/*                                                                  */\n/*      Vinh Vu - 1992/05/21 - Origrinal codes - V1.0               */\n/*                                                                  */\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*      06/10'92 - Vinh Vu -                                        */\n/*              - Access SYSID from CVT, not from SMF (SMFID).      */\n/*              - Pick up CPU model from CVT extenstion, not from   */\n/*                serial number.                                    */\n/*              - Also display DFP level.                           */\n/*                                                                  */\n/*     1993/10/07 - Vinh Vu -                                       */\n/*              - Add display for LPA List.                         */\n/*                                                                  */\n/*------------------------------------------------------------------*/\n\nVERSION = '1.1'\n\n/*BEGHELP       - - - - - - - - - - - - - - - - - - - - - - - - - - */\n/*                                                                  */\n/*                       HELP Text                                  */\n/*                                                                  */\n/*  Syntax:   $D PARM                                               */\n/*                                                                  */\n/*     PARM will be one of the following:                           */\n/*                                                                  */\n/*      o   APF(LIST) to display the APF libraries                  */\n/*      o   LINK(LIST) or LLT to display the linklist libraries     */\n/*      o   LPA(LIST) to display the LPA List libraries             */\n/*      o   PAG(ING) to display paging statistics                   */\n/*      o   SS(T) to list all SubSystem names                       */\n/*      o   SVC to display the SVC table                            */\n/*      o   SYS(TEM) to display system information                  */\n/*                                                                  */\n/*ENDHELP       - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\nParse Upper Arg P1\nCVTADD  = C2X(Storage(10,4))\nPTR     = D2X(X2D(CVTADD)+196)\nSMCAADD = C2X(STORAGE(PTR,4))                  /* SMCA pointer      */\nSMFID   = Substr(Storage(SMCAADD,20),17,4)     /* Get System SMF ID */\n\nSYSIDL  = C2D('154'x)                          /* SYSID offset      */\nSYSID   = Substr(Storage(CVTADD,SYSIDL+4),SYSIDL+1,4)\n\n/*                                                                  */\n/*                                                                  */\n\nHEAD = '<$D V'||VERSION||'>       ===> $D' P1\nSay HEAD\nSay\n\nSelect\n   When ABBREV('APFLIST',P1,3)        Then Do\n        Signal APFDISP\n        End\n   When (ABBREV('LINKLIST',P1,4)     |,\n         ABBREV('LLT',P1,3))          Then Do\n        Signal LLTDISP\n        End\n   When ABBREV('LPALIST',P1,3)        Then Do\n        Signal LPADISP\n        End\n   When ABBREV('PAGING',P1,3)        |,\n        ABBREV('PAGE',P1,3)           Then Do\n        Signal PAGDISP\n        End\n   When ABBREV('SST',P1,2)            Then Do\n        Signal SSTDISP\n        End\n   When ABBREV('SVC',P1,3)            Then Do\n        Signal SVCDISP\n        End\n   When ABBREV('SYSTEM',P1,3)            Then Do\n        Signal SYSDISP\n        End\n   Otherwise Do\n        LASTLINE = SourceLine()\n        I = 1\n        Do Until Substr(SourceLine(I),1,9) = '/*BEGHELP'\n           I = I+1\n           End\n        I = I + 1                              /* Skip BEGHELP line */\n        If I = LASTLINE Then Exit              /* In case ......... */\n        Do Until Substr(SourceLine(I),1,9) = '/*ENDHELP'\n           Say SourceLine(I)\n           I = I+1\n           End\n        Exit\n        End\n\n/*------------------------------------------------------------------*/\n\n/*                                                                  */\n/*      DISPLAY APFLIST                                             */\n/*                                                                  */\n/*                                                                  */\n/*      APF = CVT+x'1E4' = Pointer to the APFList                   */\n/*      COUNT will be how many DSN's in APFList                     */\n/*                                                                  */\n\nAPFDISP:\nAPFOFF  = '1E4'x                               /* Offset of APF     */\nAPFOFFD = C2D(APFOFF)                          /* Offset in dec     */\nAPFADD  = C2X(Substr((Storage(CVTADD,APFOFFD+4)),APFOFFD+1,4))\nCOUNT   = C2D(Substr((Storage(APFADD,2)),1,2))\nDSNDEC  = X2D(APFADD)+2                        /* Ptr to Dsn (dec)  */\n\n/*                                                                  */\n/*                                                                  */\n/*                                                                  */\n\n\nSay '         --- APFList For' SYSID '---'\nSay\nDO I=1 to COUNT\n   DSNLENG = C2D(Storage(D2X(DSNDEC),1))-6     /* Get DSname leng   */\n   DSNDEC = DSNDEC+1                           /* Go past length    */\n   VOLSER = Substr((Storage(D2X(DSNDEC),6)),1,6)\n   DSNDEC = DSNDEC+6                           /* Go past VOLSER    */\n   DSNAME = Substr((Storage(D2X(DSNDEC),DSNLENG)),1,DSNLENG)\n   DSNDEC = DSNDEC+DSNLENG                     /* Go to next entry  */\n   DSNAME = Left(DSNAME,44)\n   Say Format(I,3,0) ' ' VOLSER ' ' DSNAME\n   End\n\nExit\n\n/*------------------------------------------------------------------*/\n\n/*                                                                  */\n/*      DISPLAY LINKLIST                                            */\n/*                                                                  */\n/*      LLT = CVT+x'4DC'(1244) = Pointer to Linklist Table          */\n/*      COUNT will be how many DSN's in Linklist                    */\n/*                                                                  */\n\nLLTDISP:\nLLTOFF  = '4DC'x                               /* Offset of LLT     */\nLLTOFFD = C2D(LLTOFF)                          /* Offset in dec     */\nLLTADD  = C2X(Substr((Storage(CVTADD,LLTOFFD+4)),LLTOFFD+1,4))\nCOUNT   = C2D(Substr((Storage(LLTADD,8)),5,4))\nLLTDEC  = X2D(LLTADD)+9                        /* Ptr to Dsn (dec)  */\nAPFDEC  = X2D(LLTADD)+8+(45*COUNT)             /* Ptr to Flag (dec) */\n\n/*                                                                  */\n/*                                                                  */\n/*                                                                  */\n\nSay '        --- LinkList For' SYSID '---'\nSay\nDO I=1 to COUNT\n   DSNAME=Substr((Storage(D2X(LLTDEC),44)),1,44)\n   LLTDEC = LLTDEC + 45\n   APFFLAG=Substr((Storage(D2X(APFDEC),1)),1,1)\n   If Bitand(APFFLAG,'80'x) = '80'x Then\n      APFMSG = '- APF Lib - '\n   Else\n      APFMSG = '            '\n   APFDEC = APFDEC + 1\n   Say Format(I,3,0) ' ' APFMSG DSNAME\n   End\n\nExit\n\n\n/*------------------------------------------------------------------*/\n\n/*                                                                  */\n/*      DISPLAY LPA Libraries List                                  */\n/*                                                                  */\n/*      CVTEXT  = CVT+x'4AC' = CVT extension                        */\n/*      LPALST  = CVTEXT+x'38' = LPA Libraries List                 */\n/*                                                                  */\n\nLPADISP:\n\nCVTEXT   = '4AC'x\nCVTEOFFD = C2D(CVTEXT)\nCVTEADD  = C2X(Substr((Storage(CVTADD,CVTEOFFD+4)),CVTEOFFD+1,4))\n\nLPALOFF  = '38'x                                /* Offset of LPALIST */\nLPALOFFD = C2D(LPALOFF)                         /* Offset in dec     */\nLPALADD  = C2X(Substr((Storage(CVTEADD,LPALOFFD+4)),LPALOFFD+1,4))\nCOUNT    = C2D(Substr((Storage(LPALADD,8)),5,4))\nDSNDEC   = X2D(LPALADD)+8                       /* Ptr to Dsn (dec)  */\n\n\n/*                                                                  */\n/*                                                                  */\n\nSay '         --- LPAList For' SYSID '---'\nSay\n\nDO I=1 to COUNT\n   DSNAME = Substr((Storage(D2X(DSNDEC),45)),2,44)\n   DSNDEC = DSNDEC+45                          /* Go to next entry  */\n   DSNAME = Left(DSNAME,44)\n   Say Format(I,3,0) ' ' DSNAME\n   End\n\nExit\n\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*      DISPLAY Paging statistics                                   */\n/*                                                                  */\n/*                                                                  */\n/*      ASMVT = CVT + x'2C0'                                        */\n/*                                                                  */\n\nPAGDISP:\nASMOFF  = '2C0'x                               /* Offset of ASMVT   */\nASMOFFD = C2D(ASMOFF)                          /* Offset in dec     */\nASMADD  = C2X(Substr((Storage(CVTADD,ASMOFFD+4)),ASMOFFD+1,4))\n\nSARTADD = C2X(Substr((Storage(ASMADD,8)),5,4))  /* SART address     */\nPARTADD = C2X(Substr((Storage(ASMADD,12)),9,4)) /* PART address     */\n\n/*                                                                  */\n/*                                                                  */\n/*                                                                  */\n\nFIRSTADD= C2X(Substr((Storage(PARTADD,56)),53,4))\nLASTADD = C2X(Substr((Storage(PARTADD,60)),57,4))\nLPAADD  = C2X(Substr((Storage(PARTADD,52)),49,4))\n\nSay '             ------- Paging STAT Display for' SYSID '-------'\nSay\nSay '                               Burst         Avail Outst I/O' ,\n    ' Num  Slots'\nSay 'Type Volser Adr Devt Stat  Num Size    Size  Slots  I/O  Err' ,\n    ' Cyls PerCyl'\nSay\n\nENTADD  = LPAADD\nLPALOOP:\nCall PARTDATA\nENTADD  = C2X(Substr((Storage(ENTADD,4)),1,4))\nIf X2D(ENTADD) ^= 0 Then Signal LPALOOP\n\n\nENTADD  = FIRSTADD\nPAGLOOP:\nCall PARTDATA\nIf ENTADD ^= LASTADD Then Do\n   ENTADD  = C2X(Substr((Storage(ENTADD,4)),1,4))\n   Signal PAGLOOP\n   End\n\nExit\n\nPARTDATA:\nTYPE1   = Substr((Storage(ENTADD,9)),9,1)\nTYPE2   = Substr((Storage(ENTADD,10)),10,1)\nPATADD  = C2X(Substr((Storage(ENTADD,36)),33,4))\nPCTADD  = C2X(Substr((Storage(ENTADD,40)),37,4))\nUCBADD  = C2X(Substr((Storage(ENTADD,48)),45,4))\n\nSelect\n   When Bitand(TYPE1,'80'x) = '80'x Then Do\n      DSATTYPE = 'LPLA'\n      End\n   When Bitand(TYPE1,'40'x) = '40'x Then Do\n      DSATTYPE = 'COMM'\n      End\n   When Bitand(TYPE1,'20'x) = '20'x Then Do\n      DSATTYPE = 'DUPL'\n      End\n   When Bitand(TYPE1,'10'x) = '10'x Then Do\n      DSATTYPE = 'LOCL'\n      End\n   Otherwise Do\n      DSATTYPE = '    '\n      End\n   End       /* Select */\n\nIf Bitand(TYPE2,'40'x) = '40'x Then BADDSAT = 'BAD'\n   Else BADDSAT = 'Ok '\n\nUCBNUM   = Substr((Storage(UCBADD,16)),14,3)\nUCBVOL   = Substr((Storage(UCBADD,34)),29,6)\n\nPARTNUM = Right(C2D(Substr((Storage(ENTADD,12)),11,2)),3)\nBURSTSZE= Right(C2D(Substr((Storage(ENTADD,5)),5,1)),3)\nSIZE    = Right(C2D(Substr((Storage(ENTADD,20)),17,4)),8)\nAVAIL   = Right(C2D(Substr((Storage(ENTADD,24)),21,4)),6)\nOUTSTAND= Right(C2D(Substr((Storage(ENTADD,64)),63,2)),4)\nIOERR   = Right(C2D(Substr((Storage(ENTADD,28)),25,4)),3)\n\nCYLNO   = Right(C2D(Substr((Storage(PATADD,10)),9,2)),5)\nCYLSIZE = Right(C2D(Substr((Storage(PATADD,12)),11,2)),5)\n\nDEVTYPE = Substr((Storage(PCTADD,10)),5,6)\n\nSay DSATTYPE UCBVOL UCBNUM DEVTYPE BADDSAT PARTNUM  ,\n    BURSTSZE SIZE AVAIL OUTSTAND IOERR ,\n    CYLNO CYLSIZE\nReturn\n\n/*------------------------------------------------------------------*/\n\n/*                                                                  */\n/*      DISPLAY SubSystems                                          */\n/*                                                                  */\n/*                                                                  */\n/*      JESCT = CVT+x'128' = Pointer to the JESCT                   */\n/*      JESCT points to first SSCT which chains to next SSCT        */\n/*                                                                  */\n\nSSTDISP:\nJCTOFF  = '128'x                               /* Offset of JESCT   */\nJCTOFFD = C2D(JCTOFF)                          /* Offset in dec     */\nJCTADD  = C2X(Substr((Storage(CVTADD,JCTOFFD+4)),JCTOFFD+1,4))\nSSCTADD = C2X(Substr((Storage(JCTADD,28)),25,4))\n\n/*                                                                  */\n/*                                                                  */\n/*                                                                  */\n\nI = 1\nSay '                       --- SUBSYSTEM List For' SYSID '---'\nSay\n\nSSTLOOP:\nSUBSYS  = Substr((Storage(SSCTADD,12)),9,4)    /* SubSys Name       */\nSSVT    = Substr((Storage(SSCTADD,20)),17,4)   /* SSVT Address      */\n\nIf C2D(SSVT) = 0 Then\n   SSTMSG = '(Dormant)'\nElse\n   SSTMSG = ''\n\nSay Format(I,3,0) ' ' SUBSYS '    SSCT Address = ' SSCTADD,\n    '  SSVT Address = ' C2X(SSVT)  SSTMSG\n\nSSCTADD =C2X(Substr((Storage(SSCTADD,8)),5,4)) /* Next one in chain */\nI = I+1\nIf X2D(SSCTADD) ^= 0 Then Signal SSTLOOP\nExit\n\n/*------------------------------------------------------------------*/\n\n/*                                                                  */\n/*      DISPLAY SVC Table                                           */\n/*                                                                  */\n/*      CVT -> CVTABEND -> SCVT -> SVCTABLE                         */\n/*                                                                  */\n\nSVCDISP:\nSCVTOFF  = 'C8'x                              /* Offset of SCVT    */\nSCVTOFFD = C2D(SCVTOFF)                       /* Offset in dec     */\nSCVTADD  = C2X(Substr((Storage(CVTADD,SCVTOFFD+4)),SCVTOFFD+1,4))\n\nSVCOFF   = '84'x\nSVCOFFD  = C2D(SVCOFF)\nSVCADD   = C2X(Substr((Storage(SCVTADD,SVCOFFD+4)),SVCOFFD+1,4))\n\n/*                                                                  */\n/*                                                                  */\n   SNUM.0   = 'EXCP/XDAP    '\n   SNUM.1 =   'WAIT/WAITR/..'\n   SNUM.2 =   'POST         '\n   SNUM.3 =   'EXIT         '\n   SNUM.4 =   'GETMAIN      '\n   SNUM.5 =   'FREEMAIN     '\n   SNUM.6 =   'LINK         '\n   SNUM.7 =   'XCTL         '\n   SNUM.8 =   'LOAD         '\n   SNUM.9 =   'DELETE       '\n   SNUM.10 =  'GET/FREEM R  '\n   SNUM.11 =  'TIME         '\n   SNUM.12 =  'SYNCH        '\n   SNUM.13 =  'ABEND        '\n   SNUM.14 =  'SPIE         '\n   SNUM.15 =  'ERREXCP      '\n   SNUM.16 =  'PURGE        '\n   SNUM.17 =  'RESTORE      '\n   SNUM.18 =  'BLDL/FIND    '\n   SNUM.19 =  'OPEN         '\n   SNUM.20 =  'CLOSE        '\n   SNUM.21 =  'STOW         '\n   SNUM.22 =  'OPEN TYPE J  '\n   SNUM.23 =  'CLOSE TYPE T '\n   SNUM.24 =  'DEVTYPE      '\n   SNUM.25 =  'TRKBAL       '\n   SNUM.26 =  'LOCATE, ETC  '\n   SNUM.27 =  'OBTAIN       '\n   SNUM.28 =  '\"RESERVED\"   '\n   SNUM.29 =  'SCRATCH      '\n   SNUM.30 =  'RENAME       '\n   SNUM.31 =  'FEOV         '\n   SNUM.32 =  'ALLOC        '\n   SNUM.33 =  'IOHALT       '\n   SNUM.34 =  'MGCR/QEDIT   '\n   SNUM.35 =  'WTO/WTOR     '\n   SNUM.36 =  'WTL          '\n   SNUM.37 =  'SEGLD/SEGWT  '\n   SNUM.38 =  '\"RESERVED\"   '\n   SNUM.39 =  'LABEL        '\n   SNUM.40 =  'EXTRACT      '\n   SNUM.41 =  'IDENTIFY     '\n   SNUM.42 =  'ATTACH       '\n   SNUM.43 =  'CIRB         '\n   SNUM.44 =  'CHAP         '\n   SNUM.45 =  'OVLYBRCH     '\n   SNUM.46 =  'TTIMER       '\n   SNUM.47 =  'STIMER       '\n   SNUM.48 =  'DEQ          '\n   SNUM.49 =  '\"RESERVED\"   '\n   SNUM.50 =  '\"RESERVED\"   '\n   SNUM.51 =  'SNAP/SDUMP   '\n   SNUM.52 =  'RESTART      '\n   SNUM.53 =  'RELEX        '\n   SNUM.54 =  'DISABLE      '\n   SNUM.55 =  'EOV          '\n   SNUM.56 =  'ENQ/RESERVE  '\n   SNUM.57 =  'FREEDBUF     '\n   SNUM.58 =  'RELBUF/REQBUF'\n   SNUM.59 =  'OLTEP        '\n   SNUM.60 =  '(E)STAE/STAI '\n   SNUM.61 =  'IKJEGS6A     '\n   SNUM.62 =  'DETACH       '\n   SNUM.63 =  'CHKPT        '\n   SNUM.64 =  'RDJFCB       '\n   SNUM.65 =  '\"RESERVED\"   '\n   SNUM.66 =  'BTAMTEST     '\n   SNUM.67 =  '\"RESERVED\"   '\n   SNUM.68 =  'SYNAD...     '\n   SNUM.69 =  'BSP          '\n   SNUM.70 =  'GSERV        '\n   SNUM.71 =  'ASGNBFR, ETC '\n   SNUM.72 =  '\"NO MACRO\"   '\n   SNUM.73 =  'SPAR         '\n   SNUM.74 =  'DAR          '\n   SNUM.75 =  'DQUEUE       '\n   SNUM.76 =  'IFBSTAT      '\n   SNUM.77 =  '             '\n   SNUM.78 =  'LSPACE       '\n   SNUM.79 =  'STATUS       '\n   SNUM.80 =  '             '\n   SNUM.81 =  'SETPRT       '\n   SNUM.82 =  '             '\n   SNUM.83 =  'SMFWTM       '\n   SNUM.84 =  'GRAPHICS     '\n   SNUM.85 =  'DDRSWAP      '\n   SNUM.86 =  'ATLAS        '\n   SNUM.87 =  'DOM          '\n   SNUM.88 =  '             '\n   SNUM.89 =  '             '\n   SNUM.90 =  '             '\n   SNUM.91 =  'VOLSTAT      '\n   SNUM.92 =  'TCBEXCP      '\n   SNUM.93 =  'TGET/TPUT    '\n   SNUM.94 =  'STCC         '\n   SNUM.95 =  'SYSEVENT     '\n   SNUM.96 =  'STAX         '\n   SNUM.97 =  'IKJEGS9G     '\n   SNUM.98 =  'PROTECT      '\n   SNUM.99 =  'DYNALLOC     '\n   SNUM.100 = 'IKJEFFIB     '\n   SNUM.101 = 'QTIP         '\n   SNUM.102 = 'AQCTL (TCAM) '\n   SNUM.103 = 'XLATE        '\n   SNUM.104 = 'TOPCTL (TCAM)'\n   SNUM.105 = 'IMGLIB       '\n   SNUM.106 = '             '\n   SNUM.107 = 'MODESET      '\n   SNUM.108 = '             '\n   SNUM.109 = 'ESR TYPE 4   '\n   SNUM.110 = 'DSTATUS      '\n   SNUM.111 = '\"NO MACRO\"   '\n   SNUM.112 = 'PGRLSE       '\n   SNUM.113 = 'PGFIX/PGFREE/'\n   SNUM.114 = 'EXCPVR       '\n   SNUM.115 = '             '\n   SNUM.116 = 'ESR TYPE 1   '\n   SNUM.117 = 'DEBCHK       '\n   SNUM.118 = '             '\n   SNUM.119 = 'TESTAUTH     '\n   SNUM.120 = 'GETMAIN/FREEM'\n   SNUM.121 = 'VSAM         '\n   SNUM.122 = 'ESR TYPE 2   '\n   SNUM.123 = 'PURGEDQ      '\n   SNUM.124 = 'TPIO         '\n   SNUM.125 = 'EVENTS       '\n   SNUM.126 = 'MSS INTERFACE'\n   SNUM.127 = '             '\n   SNUM.128 = '             '\n   SNUM.129 = '             '\n   SNUM.130 = 'RACHECK      '\n   SNUM.131 = 'RACINIT      '\n   SNUM.132 = 'RACLIST      '\n   SNUM.133 = 'RACDEF       '\n   SNUM.134 = '             '\n   SNUM.135 = '             '\n   SNUM.136 = '             '\n   SNUM.137 = 'ESR TYPE 6   '\n   SNUM.138 = 'PGSER (XA)   '\n   SNUM.139 = 'CVAF...      '\n   SNUM.140 = '             '\n   SNUM.141 = '             '\n   SNUM.142 = '             '\n   SNUM.143 = '             '\n   SNUM.144 = '             '\n   SNUM.145 = '             '\n   SNUM.146 = '             '\n   SNUM.147 = '             '\n   SNUM.148 = '             '\n   SNUM.149 = '             '\n   SNUM.150 = '             '\n   SNUM.151 = '             '\n   SNUM.152 = '             '\n   SNUM.153 = '             '\n   SNUM.154 = '             '\n   SNUM.155 = '             '\n   SNUM.156 = '             '\n   SNUM.157 = '             '\n   SNUM.158 = '             '\n   SNUM.159 = '             '\n   SNUM.160 = '             '\n   SNUM.161 = '             '\n   SNUM.162 = '             '\n   SNUM.163 = '             '\n   SNUM.164 = '             '\n   SNUM.165 = '             '\n   SNUM.166 = '             '\n   SNUM.167 = '             '\n   SNUM.168 = '             '\n   SNUM.169 = '             '\n   SNUM.170 = '             '\n   SNUM.171 = '             '\n   SNUM.172 = '             '\n   SNUM.173 = '             '\n   SNUM.174 = '             '\n   SNUM.175 = '             '\n   SNUM.176 = '             '\n   SNUM.177 = '             '\n   SNUM.178 = '             '\n   SNUM.179 = '             '\n   SNUM.180 = '             '\n   SNUM.181 = '             '\n   SNUM.182 = '             '\n   SNUM.183 = '             '\n   SNUM.184 = '             '\n   SNUM.185 = '             '\n   SNUM.186 = '             '\n   SNUM.187 = '             '\n   SNUM.188 = '             '\n   SNUM.189 = '             '\n   SNUM.190 = '             '\n   SNUM.191 = '             '\n   SNUM.192 = '             '\n   SNUM.193 = '             '\n   SNUM.194 = '             '\n   SNUM.195 = '             '\n   SNUM.196 = '             '\n   SNUM.197 = '             '\n   SNUM.198 = '             '\n   SNUM.199 = '             '\n   SNUM.200 = '             '\n   SNUM.201 = '             '\n   SNUM.202 = '             '\n   SNUM.203 = '             '\n   SNUM.204 = '             '\n   SNUM.205 = '             '\n   SNUM.206 = '             '\n   SNUM.207 = '             '\n   SNUM.208 = '             '\n   SNUM.209 = '             '\n   SNUM.210 = '             '\n   SNUM.211 = '             '\n   SNUM.212 = '             '\n   SNUM.213 = '             '\n   SNUM.214 = '             '\n   SNUM.215 = 'CICS(HPSVC)  '\n   SNUM.216 = 'CICS(CSVC)   '\n   SNUM.217 = '             '\n   SNUM.218 = '             '\n   SNUM.219 = '             '\n   SNUM.220 = '             '\n   SNUM.221 = '             '\n   SNUM.222 = '             '\n   SNUM.223 = '             '\n   SNUM.224 = '             '\n   SNUM.225 = '             '\n   SNUM.226 = '             '\n   SNUM.227 = '             '\n   SNUM.228 = '             '\n   SNUM.229 = '             '\n   SNUM.230 = '             '\n   SNUM.231 = '             '\n   SNUM.232 = '             '\n   SNUM.233 = '             '\n   SNUM.234 = '             '\n   SNUM.235 = '             '\n   SNUM.236 = '             '\n   SNUM.237 = '             '\n   SNUM.238 = '             '\n   SNUM.239 = '             '\n   SNUM.240 = '             '\n   SNUM.241 = 'VSAMTUNE     '\n   SNUM.242 = 'UCC7         '\n   SNUM.243 = '             '\n   SNUM.244 = '             '\n   SNUM.245 = 'UCC11        '\n   SNUM.246 = '             '\n   SNUM.247 = 'UCC1 (X)     '\n   SNUM.248 = 'UCC1 (Y)     '\n   SNUM.249 = 'DIAGNOSE     '\n   SNUM.250 = '             '\n   SNUM.251 = '             '\n   SNUM.252 = '             '\n   SNUM.253 = '             '\n   SNUM.254 = '             '\n   SNUM.255 = 'JES3 SDF     '\n/*                                                                  */\n/*                                                                  */\n/*                                                                  */\n\nSay '         --- SVCTABLE Display For' SYSID '---'\nSay\nSay '                   ' Copies(' ',16) ,\n            '                A S P A             '\nSay '  SVC# (Hex)  Entry' Copies(' ',16) ,\n            '  Amod  Type    P E R S  Lock(s) needed '\nSay '                   ' Copies(' ',16) ,\n            '                F R E T             '\nSay\n\nDO I=0 to 255\n   ENTRYPT = Storage(SVCADD,4)                 /*                   */\n   AMODE = Substr(ENTRYPT,1,1)\n   If Bitand(AMODE,'80'x) = '80'x Then\n      ADDR = '31'\n   Else\n      ADDR = '  '\n   SVCTYPE = Substr(Storage(SVCADD,5),5,1)\n   If Bitand(SVCTYPE,'20'x) = '20'x Then Do\n      TYPEMSG = 'T6   '\n      End\n   Else\n      If Bitand(SVCTYPE,'C0'x) = 'C0'x Then Do\n         TYPEMSG = 'T3/4 '\n         End\n      Else\n         If Bitand(SVCTYPE,'80'x) = '80'x Then Do\n            TYPEMSG = 'T2   '\n            End\n         Else\n            If Bitand(SVCTYPE,'00'x) = '00'x Then Do\n               TYPEMSG = 'T1   '\n               End\n            Else\n               TYPEMSG = '?    '\n   If Bitand(SVCTYPE,'08'x) = '08'x Then\n      APF = 'A'\n   Else\n      APF = ' '\n   If Bitand(SVCTYPE,'04'x) = '04'x Then\n      ESR = 'E'\n   Else\n      ESR = ' '\n   If Bitand(SVCTYPE,'02'x) = '02'x Then\n      PRE = 'P'\n   Else\n      PRE = ' '\n   If Bitand(SVCTYPE,'01'x) = '01'x Then\n      AST = 'S'\n   Else\n      AST = ' '\n   LOCK    = Substr(Storage(SVCADD,7),7,1)\n   LMSG = ''\n   If Bitand(LOCK,'80'x) = '80'x Then\n      LMSG = LMSG||'LOCL'\n   If Bitand(LOCK,'40'x) = '40'x Then\n      LMSG = LMSG||',CMS'\n   If Bitand(LOCK,'20'x) = '20'x Then\n      LMSG = LMSG||',OPT'\n   If Bitand(LOCK,'10'x) = '10'x Then\n      LMSG = LMSG||',SALLOC'\n   If Bitand(LOCK,'08'x) = '08'x Then\n      LMSG = LMSG||',DISP'\n   IHEX = '    '\n   IHEX = Right(D2X(I),2)\n   Say ' ' Format(I,3,0) '-' IHEX ' ' ,\n       C2X(ENTRYPT) ' ' SNUM.I ' ' ADDR ' ',\n       TYPEMSG ' ' APF ESR PRE AST ' ' LMSG\n   SVCADD  = D2X(X2D(SVCADD)+8)                /* Bump to next entry */\n   End\nSay\nExit\n\n/*------------------------------------------------------------------*/\n\n/*                                                                  */\n/*      DISPLAY SYSTEM information                                  */\n/*                                                                  */\n/*                                                                  */\n/*      PCCAT = CVT+x'2FC' = Pointer to the PCCA Vector Table       */\n/*      PCCAVT has up to 16 PCCA pointers                           */\n/*      PCCA Has CPU Serial # plus its physical CPU Id              */\n/*                                                                  */\n/*      STRGOFF = CVT+x'358' = Online Storage (K's) at IPL          */\n/*                                                                  */\n\nSYSDISP:\nPVTOFF  = '2FC'x                               /* Offset of PCCAVT  */\nPVTOFFD = C2D(PVTOFF)                          /* Offset in dec     */\nPVTADD  = C2X(Substr((Storage(CVTADD,PVTOFFD+4)),PVTOFFD+1,4))\n\nSTRGOFF  = '358'x\nSTRGOFFD = C2D(STRGOFF)\nSTRG     = Substr((Storage(CVTADD,STRGOFFD+4)),STRGOFFD+1,4)\n\nIPLTIME  = '150'x                             /* Offset into SMCA   */\nIPLDATE  = '154'x                             /* Offset into SMCA   */\nIPLTIMED = C2D(IPLTIME)\nIPLDATED = C2D(IPLDATE)\n\nIPLTI  = C2D(Substr(Storage(SMCAADD,IPLTIMED+4),IPLTIMED+1,4))%360000\nIPLTRM = C2D(Substr(Storage(SMCAADD,IPLTIMED+4),IPLTIMED+1,4))//360000\nIPLTD  = RIGHT(IPLTRM%6000,2,'0')             /* Find # of Minutes  */\n\nIPLT   = IPLTI||'.'||IPLTD\nIPLD   = C2X(Substr(Storage(SMCAADD,IPLDATED+4),IPLDATED+1,4))\n\nIPLYEAR  = Substr(IPLD,3,2)\nIPLDAY   = Substr(IPLD,5,3)\n\nUCBOFF   = '30'x                         /* CVT+x'30' = SYSRES UCB */\nUCBOFFD  = C2D(UCBOFF)\nUCBADD   = C2X(Substr((Storage(CVTADD,UCBOFFD+4)),UCBOFFD+1,4))\n\nUCBNUM   = Substr((Storage(UCBADD,16)),14,3)\nUCBVOL   = Substr((Storage(UCBADD,34)),29,6)\n\nCVTPRADD = D2X(X2D(CVTADD)-40)\nOPSYS    = Substr((Storage(CVTPRADD,8)),1,8)\nFMIDS    = Substr((Storage(CVTPRADD,16)),9,8)\nCPUTYPE  = C2X(Substr((Storage(CVTPRADD,36)),35,2))\nMVSREL   = Substr((Storage(CVTPRADD,40)),37,4)\n\nDFAOFF   = '4C0'x                        /* CVT+x'4C0' = DFA       */\nDFAOFFD  = C2D(DFAOFF)\nDFAADD   = C2X(Substr((Storage(CVTADD,DFAOFFD+4)),DFAOFFD+1,4))\n\nDFPREL   = C2X(Substr((Storage(DFAADD,4)),3,2))\nDFPREL   = Substr(DFPREL,1,3)\n\nASMOFF  = '2C0'x                               /* Offset of ASMVT   */\nASMOFFD = C2D(ASMOFF)                          /* Offset in dec     */\nASMADD  = C2X(Substr((Storage(CVTADD,ASMOFFD+4)),ASMOFFD+1,4))\n\nIPLFLG  =  Substr((Storage(ASMADD,2)),2,1)\n\nCVTEXT   = '4AC'x\nCVTEOFFD = C2D(CVTEXT)\nCVTEADD  = C2X(Substr((Storage(CVTADD,CVTEOFFD+4)),CVTEOFFD+1,4))\n\nMLPABEG  = C2X(Substr((Storage(CVTEADD,12)),9,4))\nMLPAEND  = C2X(Substr((Storage(CVTEADD,16)),13,4))\n\nFLPABEG  = C2X(Substr((Storage(CVTEADD,20)),17,4))\nFLPAEND  = C2X(Substr((Storage(CVTEADD,24)),21,4))\n\nPLPABEG  = C2X(Substr((Storage(CVTEADD,28)),25,4))\nPLPAEND  = C2X(Substr((Storage(CVTEADD,32)),29,4))\n\nWNUCBEG  = C2X(Substr((Storage(CVTEADD,36)),33,4))\nWNUCEND  = C2X(Substr((Storage(CVTEADD,40)),37,4))\n\nRNUCBEG  = C2X(Substr((Storage(CVTEADD,44)),41,4))\nRNUCEND  = C2X(Substr((Storage(CVTEADD,48)),45,4))\n\nENUCBEG  = C2X(Substr((Storage(CVTEADD,52)),49,4))\nENUCEND  = C2X(Substr((Storage(CVTEADD,56)),53,4))\n\nEPLPABEG = C2X(Substr((Storage(CVTEADD,60)),57,4))\nEPLPAEND = C2X(Substr((Storage(CVTEADD,64)),61,4))\n\nEFLPABEG = C2X(Substr((Storage(CVTEADD,68)),65,4))\nEFLPAEND = C2X(Substr((Storage(CVTEADD,72)),69,4))\n\nEMLPABEG = C2X(Substr((Storage(CVTEADD,76)),73,4))\nEMLPAEND = C2X(Substr((Storage(CVTEADD,80)),77,4))\n\n/*                                                                  */\n/*                                                                  */\n/*                                                                  */\nD1  = Substr(DATE('J'),1,2)\nD2  = Substr(DATE('J'),3,3)\nD1N2 = D1||'.'||D2\n\nSay '         --- SYSTEM INFO Display For' SYSID '---'\nSay\nSay ' Today =' D1N2 'or' DATE('W')||',' DATE('N')\nSay ' System IPL''ed at' Format(IPLT,4,2) 'on ' IPLYEAR||'.'||IPLDAY,\n     'from ' UCBVOL 'at address ' UCBNUM\n\nIf BitAnd(IPLFLG,'08'x) = '08'x Then Do\n   QIPL = 'Non-CLPA'\n   End\nElse Do\n   QIPL = 'CLPA    '\n   End\n\nIf BitAnd(IPLFLG,'04'x) = '04'x Then Do\n   WIPL = 'Non-CVIO'\n   End\nElse Do\n   WIPL = 'CVIO    '\n   End\n\nSay ' IPL Type:  Quick Start =' QIPL  '   Warm Start =' WIPL\n\nSay ' Online Storage at IPL =' Format(C2D(STRG)/1024,5,0)||'M'\nSay ' Operating System = ' OPSYS '    FMID =' FMIDS '   SMFID =' SMFID\nSay ' MVS Release =' MVSREL '   DFP Release =' DFPREL ,\n    '  CPU Type ='  CPUTYPE\nSay\n\nDO I=1 to 16\n   PCCAADD = C2X(Storage(PVTADD,4))            /*                   */\n   If X2D(PCCAADD) ^=0 Then Do\n      SERIAL  = Substr(Storage(PCCAADD,12),7,6)\n      CPUTYPE = Substr(Storage(PCCAADD,16),13,4)\n      CPUID   = C2D(Substr(Storage(PCCAADD,18),17,2))\n      Say ' CPU =' CPUID  '  Serial =' SERIAL\n      End\n   PVTADD  = D2X(X2D(PVTADD)+4)                /* Bump to next entry */\n   End\nSay\nSay ' Start/End Address for MLPA   ' MLPABEG  ' - '  MLPAEND\nSay ' - - - - - - - - - - - FLPA   ' FLPABEG  ' - '  FLPAEND\nSay ' - - - - - - - - - - - PLPA   ' PLPABEG  ' - '  PLPAEND\nSay ' - - - - - - READ/WRITE NUC   ' WNUCBEG  ' - '  WNUCEND\nSay ' - - - - - -  READ-ONLY NUC   ' RNUCBEG  ' - '  RNUCEND\nSay ' -  READ/WRITE EXTENDED NUC   ' ENUCBEG  ' - '  ENUCEND\nSay ' - - - - - -  EXTENDED PLPA   ' EPLPABEG  ' - '  EPLPAEND\nSay ' - - - - - -  EXTENDED FLPA   ' EFLPABEG  ' - '  EFLPAEND\nSay ' - - - - - -  EXTENDED MLPA   ' EMLPABEG  ' - '  EMLPAEND\nExit\n\n/*------------------------------------------------------------------*/\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$DASDERR": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x03\\x00\\x03\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 3, "newlines": 3, "modlines": 0, "user": "MCRITCH"}, "text": "00010000 ISREDIT MACRO\n00020000 ISPEXEC BROWSE DATASET('INTERNAL.LIBRARY.IV2B6502')\n00030000 EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DASD03": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x03\\x00\\x03\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 3, "newlines": 3, "modlines": 0, "user": "MCRITCH"}, "text": "00010000 ISREDIT MACRO\n00020000 ISPEXEC BROWSE DATASET('INTERNAL.LIBRARY.IV2B6503')\n00030000 EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DIRPARM": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x0c\\x00\\x0c\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "MCRITCH"}, "text": "  PROC 1 DIRPARM\n /* THIS CLIST IS USED BY @DIR WHEN  DOITMAC(NAME) IS INVOKED */\n /* TSO VERSION SO CAN DO SAME AS @DIRPARM, WHEN IN BROWSE\n /* TO MAKE SURE THAT CONTINUATION OF THE CLIST PROCESS IS WANTED*/\n /* DAVID MCRITCHIE,  MAY 28, 1986,\n    SET @DIRPARM = &STR(&DIRPARM)\n    IF &STR(&@DIRPARM) = &STR() THEN DO\n       ISPEXEC VPUT (@DIRPARM)  SHARED\n       EXIT CODE(12)\n    END\n    ISPEXEC VPUT (@DIRPARM)  SHARED\n    EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DMS": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xaa\\x00\\xaa\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 170, "newlines": 170, "modlines": 0, "user": "MCRITCH"}, "text": "         PROC 0 ONLY() MSG\n         SET RP = &STR())\n         SET LP = &STR((\n         IF MSG = &MSG. THEN DO\n            $BROWSE IS03.IS03D001.IOFLIST\n            FREE DS('IS03.IS03D001.IOFLIST')\n            EXIT CODE(0)\n         END\n/* ISPEXEC  LIBDEF ISPPLIB\nISPEXEC  VGET (VSTSRVTI) SHARED\n         SET   TMPSRVTI = &STR(&VSTSRVTI.)\n         IF &STR(&ONLY) ^= &STR() THEN GOTO ONLY&ONLY.\n         CONTROL ASIS\n         WRITE  &B\n         WRITE  &B\n         WRITE  &B\n         WRITE  &B\n         WRITE  &B\n         WRITE  &B\n         WRITE  &B\n         WRITE       **** the clist  $DMS  has been invoked ***\n         WRITE ONLY(1). DATASETS SCRATCHED BY DMS   (WILL NOW BE +\n           DISPLAYED)\n         WRITE ONLY(2). DATASETS IN ERROR, NO DMS BACKUP DONE       +\n           (LATER)\n         WRITE ONLY(3). DATASETS IN CONTENTION WITH DMS BACKUP      +\n           (LATER)\n         WRITE ONLY(4). ALL DATASETS on SYSTEM when MIDILIST RAN    +\n           (LATER)\n         WRITE ONLY(5). DEFERRED RESTORE ERROR LIST LATEST RUN      +\n           (LATER)\n         WRITE ONLY(6). DEFERRED RESTORE CUMULATIVE ERROR/REPORT +\n           (available)\n         WRITE &B.\n         WRITE  FIND \"&SYSUID\" <column>, assumes   \"DISPLAY CC\" in +\n           effect for browse\n         WRITE &B.\n         WRITE &B.   ADDITIONAL INFORMATION CAN BE SEEN IN\n         WRITE &B      TSOMODEL.PUBLIC.TEXT     USE ===> TSO MODELT *\n         WRITE DMSTSO:   Control of TSO packs by DMS; Standards, +\n           Archival, Backups, Restores\n         WRITE INFO035:  DMS archive procedure for TESTDISK\n         WRITE INFO036:  DMS deferred restore of SYS5 datasets\n         WRITE INFO042:  DMS dataset user document and DMS Panel Usage\n         WRITE SCRATCH:  DMS/OS Jobs which automatically scratch data +\n           sets from DASD.\n         IF &STR(&ONLY) = 0 THEN GOTO ONLYDONE\n    ONLY1: -\n         SET &VSTSRVTI = &STR(SYS6.MIDILIST.DMSWARN)\n         SET &DSNDESC  = &STR(1-a  DATASETS recently SCRATCHED BY +\n           DMS         )\n         SET &DSNDESC3 = &STR(        &lp.The next BROWSE will +\n           indicate reason.&rp.      )\n         SET &DSNDESC4 = &STR(     DATASETS SCRATCHED BY DMS  -- FIND +\n           &SYSUID.)\n         ISPEXEC  VPUT (VSTSRVTI,DSNDESC) SHARED\n         ISPEXEC  BROWSE DATASET('SYS6.MIDILIST.DMSWARN') +\n           PANEL(SYSBROB4)\n         /* ---------- */\n         SET &VSTSRVTI = &STR(INTERNAL.LIBRARY.IV2B6505)\n         SET &DSNDESC  = &STR(1-b. REASONS why DATASETs were +\n           SCRATCHED by DMS   )\n         SET &DSNDESC3 = &STR(1-b. DATASETS SCRATCHED BY DMS  -- FIND +\n           4 &SYSUID.)\n         ISPEXEC  VPUT (VSTSRVTI,DSNDESC) SHARED\n         ISPEXEC  BROWSE DATASET('INTERNAL.LIBRARY.IV2B6505') +\n           PANEL(SYSBROB3)\n         IF &STR(&ONLY) = 1 THEN GOTO ONLYDONE\n    ONLY2: -\n         SET &VSTSRVTI = &STR(INTERNAL.LIBRARY.IV2B6502)\n         SET &DSNDESC  = &STR(2. FILES NOT BACKED UP BY DMS, DUE TO +\n           ERRORS -- F 16 &SYSUID.)\n         SET &DSNDESC3  = &STR(   to identify a member to a TTR use +\n           JCL in IS03.SHARE.CNTL(TTR&rp.)\n         ISPEXEC  VPUT (VSTSRVTI,DSNDESC,DSNDESC3) SHARED\n         ISPEXEC  BROWSE DATASET('INTERNAL.LIBRARY.IV2B6502') +\n           PANEL(SYSBROB3)\n         IF &STR(&ONLY) = 2 THEN GOTO ONLYDONE\n    ONLY3: -\n         SET &VSTSRVTI = &STR(INTERNAL.LIBRARY.IV2B6503)\n         SET &DSNDESC  = &STR(3. FILES ALREADY IN USE, DMS COULD NOT +\n           BACK UP -- F 16 &SYSUID.)\n         ISPEXEC  VPUT (VSTSRVTI,DSNDESC) SHARED\n         ISPEXEC  BROWSE DATASET('INTERNAL.LIBRARY.IV2B6503') +\n           PANEL(SYSBROB2)\n         IF &STR(&ONLY) = 3 THEN GOTO ONLYDONE\n    ONLY4: -\n         SET &VSTSRVTI = &STR(SYS6.MIDILIST.DMSUTIL)\n         SET &DSNDESC  = &STR(4. DMS - DMSUTIL dataset usage summary +\n           -- F 44 &SYSUID.)\n         ISPEXEC  VPUT (VSTSRVTI,DSNDESC) SHARED\n         ISPEXEC  BROWSE DATASET('SYS6.MIDILIST.DMSUTIL') +\n           PANEL(SYSBROB2)\n         IF &STR(&ONLY) = 4 THEN GOTO ONLYDONE\n    ONLY5: -\n         SET &VSTSRVTI = &STR(INTERNAL.LIBRARY.IV2A0301)\n         SET &DSNDESC  = &STR(5. DMS - ERROR LIST FROM LATEST +\n           DEFERRED RESTORE)\n         SET &DSNDESC3 = &STR(&lp.1&rp. dsn,reason scratched, +\n         &lp.2&rp. failures, &lp.4&rp. current DiskDs)\n         SET &DSNDESC4 = &STR(Contact xxx-xxxx for restores from +\n           DMSxxx volumes)\n         ISPEXEC  VPUT (VSTSRVTI,DSNDESC) SHARED\n         ISPEXEC  BROWSE DATASET('INTERNAL.LIBRARY.IV2A0301') +\n           PANEL(SYSBROB4)\n         IF &STR(&ONLY) = 5 THEN GOTO ONLYDONE\n         GOTO ONLYDONE    /* FORCED BYPASS OF AUTOMATIC ONLY(6)\n    ONLY6: -\n         SET DSNAME = 'INTERNAL.LIBRARY.IV2A0303'\n         SET &VSTSRVTI = &STR($DMSB.TEMP)\n         ALLOCATE DDNAME($DMSB) REUSE DSNAME(&VSTSRVTI) -\n              LIKE(&DSNAME.) -\n              NEW UNIT(TESTDISK) LIKE(&DSNAME) REUSE\n         /* A LITTLE EXTRA WORK REQUIRED TO COPY BECAUSE\n         /*  IN PRODUCTION THE DATASET IS  DISP=MOD\n         COPY &DSNAME &VSTSRVTI NONUM\n         FREE DS(&DSNAME)\n         FREE DS(&VSTSRVTI)\n         SET &DSNDESC  = &STR(6. DMS - CUMMULATIVE ERROR/REPORT +\n           DEFERRED RESTORE)\n         SET &DSNDESC3 = &STR(   LATEST MATERIAL IS AT END   ===> +\n           DOWN MAX)\n         ISPEXEC VPUT (VSTSRVTI,DSNDESC) SHARED\n  /*     ISPEXEC BROWSE DATASET($DMSB.TEMP) PANEL(SYSBROB3)\n  /*     WILL USE EDIT INSTEAD BECAUSE IT IS A USER TEMPORARY DATASET\n         ISPEXEC EDIT   DATASET($DMSB.TEMP) PANEL(SYSEDDE3) MACRO($DMS6)\n         CONTROL NOMSG\n         DEL $DMSB.TEMP\n         CONTROL MSG\n         GOTO ONLYDONE\n    ONLY7: -\n         SET &VSTSRVTI = &STR(SYS6.MIDILIST.DMSUTIL)\n         SET &DSNDESC  = &STR(7. DMS - DMSUTIL DATASET USAGE BEFORE +\n           DMS SCRATCHING)\n         ISPEXEC  VPUT (VSTSRVTI,DSNDESC) SHARED\n         ISPEXEC  BROWSE DATASET('SYS6.MIDILIST.DMSUTIL.EVENING') +\n           PANEL(SYSBROB2)\n         GOTO ONLYDONE    /* FORCED BYPASS OF AUTOMATIC ONLY(7)\n    ONLYDONE: -\n         SET   VSTSRVTI = &STR(&TMPSRVTI.)\nISPEXEC  VPUT (VSTSRVTI) SHARED\n         IF X&ONLY ^= X THEN EXIT CODE(0)\n         WRITE       **** the clist  $DMS  has been invoked ***\n         WRITE ONLY(1). DATASETS SCRATCHED BY DMS           (HAS BEEN +\n           VIEWED)\n         WRITE ONLY(2). DATASETS IN ERROR, NO DMS BACKUP DONE (HAS +\n           BEEN VIEWED)\n         WRITE ONLY(3). DATASETS IN CONTENTION WITH DMS BACKUP (HAS +\n           BEEN VIEWED)\n         WRITE ONLY(4). DMS - DMSUTIL run showing all datasets when +\n           MIDILIST ran\n         WRITE          in the morning or on the weekend    (HAS BEEN +\n           VIEWED)\n         WRITE ONLY(5). DEFERRED RESTORE ERROR LIST LATEST RUN (HAS +\n           BEEN VIEWED)\n         WRITE --- the following is available by SPECIFIC request +\n           only &STR(---)\n         WRITE ONLY(6). DEFERRED RESTORE CUMULATIVE ERROR/REPORT +\n           (available)\n         WRITE &B.\n         WRITE &B.   ADDITIONAL INFORMATION CAN BE SEEN IN\n         WRITE &B      TSOMODEL.PUBLIC.TEXT     USE ===> TSO MODELT *\n         WRITE DMSTSO:   Control of TSO packs by DMS; Standards, +\n           Archival, Backups, Restores\n         WRITE INFO035:  DMS archive procedure for TESTDISK\n         WRITE INFO036:  DMS deferred restore of SYS5 datasets\n         WRITE INFO042:  DMS dataset user document and DMS Panel Usage\n         WRITE SCRATCH:  DMS/OS Jobs which automatically scratch data +\n           sets from DASD.\n         EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$EDIT": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xa1\\x00\\xa1\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 161, "newlines": 161, "modlines": 0, "user": "MCRITCH"}, "text": " /* $EDIT -- EDIT DATASET SPECIFIED (NO QUOTES REQ'D) -- REXX*/\n/*PROC 1 DSNAME  MACRO(RCVYWARN) NEW PANEL() TRACE */\n/*$EDIT     AUTHOR: DAVID MCRITCHIE, CREATED 1985/12/04 IS03\n            \"The REXX Macros Toolbox\",  DMcRitchie@aol.com\n            UPDATED 1991/12/24 11:33 IS03\n            UPDATED 1993/10/18 16:24 IS03 CONVERTED TO REXX\n            UPDATED 1994/02/22 14:30 IS03 FOR GDG(-n) relative\n           PURPOSE: EDIT A DATASET FROM WITHIN EDIT OR OTHER\n                    ISPF PANEL -- DSNAME REQUIRED UPON ENTRY.\n                               -- CHECKS EXISTANCE AND RACF ACCESS.\n           CONTRIBUTED:   F. David McRitchie 1985/12/04\n           USER CONTACT:  F. David McRitchie \"The REXX Macros Toolbox\"\n           CODE MAINT.:   SYSTECH GROUP\n           $BROWSE IS now PATTERNED ON THE $EDIT (this) CLIST\n  ****************************************************************\n     A COMPLETE DSNAME MUST BE PROVIDED\n        -- CAN BE ENCLOSED IN QUOTES, IF YOU SO WISH.\n        -- MEMBERNAME MAY BE INCLUDED AS PART OF DSNAME.\n        -- WILL NOT PREFIX THE USERID TO THE DSNAME.\n     A DATASET LEVELNAME MAY BE PROVIDED IN WHICH CASE\n        -- ALL OTHER OPTIONS WILL BE IGNORED, MEMBERNAME NOT ALLOWED\n           E.G.  ==> $BROWSE IS03.*.TEXT\n  *****************************************************************/\n      /*  ---INSURE DSNAME IS SURROUNDED BY QUOTES AND ...  */\n      /*  --- CREATE RDSNAME (WITHOUT MEMBERNAME) TO CHECK RACF */\n        PARSE ARG TOKEN; TOKEN=TRANSLATE(TOKEN)\n        PARSE VAR TOKEN DSNAME ' ' TOKEN\n        SYSUID = SYSVAR('SYSUID')\n        TOKEN = ' '||TOKEN||' '\n        MACRO=KEYWORD('MACRO')\n        NEW =PROCESS('NEW')\n        PANEL=KEYWORD('PANEL')\n        TRACE=PROCESS('TRACE')\n\n        IF TOKEN \\= '' THEN\n           SAY 'UNRESOLVED OPERANDS ARE:' TOKEN\n\n        L = LENGTH(DSNAME)\n        XX = SUBSTR(DSNAME,1,1)SUBSTR(DSNAME,L,1)\n        IF XX = \"''\" THEN DSNAME = SUBSTR(DSNAME,2,L-2)\n        /* MUST NOT HAVE MEMBERNAME*/\n        CDSNAME = DSNAME\n        PARSE VAR CDSNAME LEVEL '(' MEMBER ')'\n        if member \\= '' then cdsname = level\n        if datatype(member, \"Whole number\") = 1 then do\n           /* dealing with a GDG dataset so get the correct dsn*/\n           Call OutTrap \"ListCat.\", \"*\", \"noconcat\"\n           \"ListCat Entry('\"cdsname\"') GDG all\"\n           if rc > 0 then signal failure\n           if member > 0 then\n               errmsg('GDG relative numbers > 0 do not exist')\n           lineno = listcat.0  + member  /* relative goes backward*/\n           parse var listcat.lineno \"NONVSAM--\" cdsname\n           member = \"\"  /* finished with relative number as member*/\n        end;\n        RDSNAME = CDSNAME       /* RACF NAME */\n        I = POS('*',cdsname)\n        IF  I  \\= 0 THEN DO\n          /* E.G.   ==> TSO $BROWSE IS03.*.CNTL */\n          ADDRESS \"ISPEXEC\" \"VGET ZDLDSNLV PROFILE\"\n          OLD = ZDLDSNLV\n          ZDLDSNLV = CDSNAME\n          ADDRESS \"ISPEXEC\" \" VPUT ZDLDSNLV PROFILE\"\n          /* ACCORDING TO Q417856 QUALIFIED DATASET*/\n          /* SHOULD HAVE USED LMMDISP. */\n          /* METHOD USED HAS PANEL OPTIONS AVAILABLE*/\n          ADDRESS \"ISPEXEC\" \"SELECT PGM(ISRUDL) PARM(ISRUDLP)\"\n          ZDLDSNLV = OLD\n          ADDRESS \"ISPEXEC\" \"VPUT ZDLDSNLV PROFILE\"\n          RETURN 0\n        END\n        RMEMBER = MEMBER\n      /*  ----------- CHECK FOR EXISTENCE OF THE DATASET ----*/\n        IF MEMBER \\= '' THEN IF POS('*',MEMBER) = 0 ,\n           THEN CDSNAME = DSNAME\n        CHK =  SYSDSN(\"'\"CDSNAME\"'\")\n        IF CHK = 'MEMBER NOT FOUND' THEN DO\n          IF NEW = \"NEW\" THEN CHK = \"OK\"\n          ELSE SAY CHK||\" -- USE OPTION \"\"NEW\"\" TO ALLOW\"\n       END\n       IF CHK = \"OK\" THEN DO\n          /*  ------- MAKE AVAILABLE TO OTHER CLISTS --------*/\n          ADDRESS \"ISPEXEC\" \" VPUT DSNAME SHARED\"\n          ADDRESS \"ISPEXEC\" \" VPUT RDSNAME SHARED\"\n          /*  ------- TRAP SYSOUT FOR RACF CHECKING ---------*/\n          TRAP.=\n          X = OUTTRAP(\"TRAP.\",\"*\")\n             \"LD DATASET('\"RDSNAME\"') GENERIC\"\n          X= OUTTRAP(\"OFF\")\n          IF SUBSTR(TRAP.1,1,3) = \"ICH\" THEN\n              IF SUBSTR(TRAP.1,1,8) \\= ICH35003 ,\n                THEN DO\n                   ZEDSMSG = 'NOT AUTHORIZED'\n                   ZEDLMSG = TRAP.1 '-- HIT',\n                     'ENTER NOT PFK-3'\n                   ADDRESS \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n                   RETURN 12\n               END\n          /*  ------- DATASET EXITS AND RACF S/B HAPPY ------*/\n       BYPX:\n          ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"\n          ADDRESS \"ISPEXEC\" \"EDIT DATASET('\"DSNAME\"')\" MACRO PANEL\n          RCX = RC\n          SELECT;\n            WHEN RCX = 0 THEN DO; ZEDSMSG=\"SAVED\";\n             zedlmsg=\"$EDIT 0 - Normal completion, data was saved\";end;\n            WHEN RCX = 4 THEN DO; ZEDSMSG=\"\"; zedlmsg=\"$EDIT RC=4\",\n             \"- Normal completion, data was not saved\"; end;\n            when rcx = 16 then do; zedsmsg=\"No members\";\n             zedlmsg=\"$EDIT 16 - No members in library\";end\n            otherwise\n             if zerrsm = \"DATA SET IN USE\" then  /* RC=14 */\n                 Address \"TSO\" \"WHOGOT\" dsname\n             zedsmsg = zerrsm\n             zedlmsg = zerrlm 'RC='rcx\n             address \"ISPEXEC\" \"setmsg msg(isrz000)\"\n             exit 1\n          end /* of select and other-wise statements(s) */\n          if rcx \\= 4 then\n             ADDRESS \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n          X = MSG('OFF')\n          ADDRESS \"TSO\" \"FREE DATASET('\"RDSNAME\"')\"\n          X = MSG('ON')\n          RETURN RCX\n       END\n       /* ----------- DATASET DOES NOT EXIST ----------------*/\n       SAY \"'\"DSNAME\"'\"   CHK\n       ZEDSMSG = 'INVALID DSN'\n       ZEDLMSG = \"FAILED -- \"CHK\" -- '\"DSNAME\"'\"\n       ADDRESS \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n       SAY \"TSO $EDIT\" DSNAME \"FAILED DUE TO '\"CHK\"'\"\n       SAY \"AN EXAMPLE WITH A CORRECT SYNTAX IS      ===> TSO $EDIT\" ,\n         SYSUID\".LIBR.CNTL\"\n       SAY \"TSO $EDIT FAILED FOR    DSNAME=\"DSNAME\"   DUE TO '\"CHK\"'\"\n       RETURN 12\nPROCESS: PROCEDURE EXPOSE TOKEN\n ARG SUBTOKEN\n I = POS(' '||SUBTOKEN||' ',TOKEN)\n IF I=0 THEN RETURN ''\n TOKENX = SUBSTR(TOKEN,1,I) || SUBSTR(TOKEN,I+2+LENGTH(SUBTOKEN))\n TOKEN = TOKENX\n RETURN SUBTOKEN\n KEYWORD:\n  PARSE ARG KEY\n  KEY1 = ' '||KEY||'('\n  PARSE VAR TOKEN  LEFT   (KEY1) VALUE ')' RIGHT\n  TOKEN = LEFT RIGHT\n  IF VALUE = \"\" THEN RETURN ''\n  RETURN KEY\"(\"VALUE\")\"\nErrMsg: Procedure expose RC;\n   Parse arg Text;\n   Say Center(\" \"Text\" \", 79, \"*\");\n   RC = 12;\n   Exit RC;   /* do not return */\n\n/* In the event of a failure following ListCat, emit it */\nFailure:\n   Do I = 1 to ListCat.0;\n      Say ListCat.I;\n   End;\n   Exit RC;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$FREE": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\n\\x00\\n\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "MCRITCH"}, "text": " PROC 1 FREE$DS\n                CONTROL LIST  /*CONLIST SYMLIST\n   /* PURPOSE: \"FREE\" DATASET AND \"WHOGOT\" DATASET\n   /* CONTRIBUTED:   F. DAVID MCRITCHIE             1985/02/04\n IF &SUBSTR(1:1,&FREE$DS.) = &STR(') THEN DO\n    SET L = &LENGTH(&FREE$DS.)\n    SET FREE$DS = &SUBSTR(2:&EVAL(&L - 1),&FREE$DS)\n END\n FREE DS('&FREE$DS')\n WHOGOT &FREE$DS\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$ISPFSTA": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01\\x8b\\x01\\x8b\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 395, "newlines": 395, "modlines": 0, "user": "MCRITCH"}, "text": "  SYSTECH create/maintains clists in SYS1.TSOCLIST\n ======== 08/08/96 19:16 @DIR 'SYS1.TSOCLIST'  'SYS1.TSOCLIST' L\n$        01.01 96/07/26 96/07/26 20:24  1185  1185    21 IS03\n$BROWSE  01.08 85/07/13 94/05/23 18:23   154    79     0 IS03\n$BUILD$  01.16 85/01/03 91/01/19 20:07   108    99     0 IS03\n$BUSER   01.06 85/02/28 88/09/30 19:52     7     3     5 IS03\n$D       01.00 94/05/16 94/05/16 09:33   857   857     0 IS03\n$DASDERR 01.00 85/09/16 85/09/16 14:39     3     3     0 IS03\n$DASD03  01.00 85/09/16 85/09/16 14:40     3     3     0 IS03\n$DIRPARM 01.02 86/05/06 86/06/25 17:35    12    11     0 IS03\n$DMS6    01.03 87/03/13 88/09/30 19:53    22    15     0 IS03\n$EDIT    01.23 85/12/04 94/05/25 11:13   161    68     0 IS03\n$EDITB   01.04 85/12/16 88/09/30 19:54    39    30    16 IS03\n$FREE    01.00 88/01/19 88/01/19 11:03    10    10     0 IS03\n$INFO    01.02 85/04/09 85/04/10 08:54     3     3     2 IS03\n$INFOX   01.01 85/04/10 85/04/10 09:06     3     3     2 IS03\n$LOG     01.12 93/02/17 93/02/17 11:32    29    26     0 IS03\n$LOGM    01.15 93/02/02 93/02/05 09:20    33     9     0 IS03\n$LOST    01.05 93/09/07 94/04/14 12:41    86    56     0 IS03\n$MIDI    01.01 85/04/05 92/06/02 10:33     3     3     1 IS03\n$MIDITL  01.05 85/04/05 88/09/30 19:55     5     3     3 IS03\n$PRINTB  01.01 86/04/02 88/09/30 19:56    37    34     0 IS03\n$TIME    01.01 93/12/17 93/12/17 11:37     8     8     0 IS03\n$USERS   01.37 85/04/08 95/01/04 13:45   207   112     0 IS03\n$USERSX  01.29 85/04/08 91/11/06 14:22   126   112     0 IS03\n#ESS     01.15 89/04/19 90/11/02 15:21   103     6     0 IS03\n#MAKEMAC 01.27 92/07/29 94/05/06 10:20   105    82     0 IS03\n@AMSRCAT 01.12 87/05/28 94/06/02 10:37   243   168     0 IS03\n@B       01.00 85/11/14 85/11/14 16:35     2     2     0 IS03\n@C       01.07 89/05/12 92/02/12 18:15    19    23     0 IS03\n@CAPS    01.12 85/09/17 94/06/01 09:39    63    14     0 IS03\n@COMPARE 01.24 89/02/24 94/10/21 14:47   413   222     0 IS03\n@COMPARX 01.17 89/02/24 92/01/16 16:44   308   142     0 IS03\n@COMPINX 01.09 92/10/10 92/10/29 22:48    55     6     0 IS03\n@DATE    01.06 86/07/09 94/05/24 18:01    29    22     0 IS03\n@DIR     01.41 85/12/30 96/04/15 16:33  1050   897     0 IS03\n@DIREDIT 01.02 86/05/01 88/09/30 20:34    14     5    10 IS03\n@DIRPARM 01.03 86/04/28 94/06/28 18:23    13    10     0 IS03\n@DIRR    01.83 85/12/30 94/06/08 14:29   991   897     0 IS03\n@DIRSTAT 01.14 86/05/07 94/05/24 18:03   100    30     0 IS03\n@DOCJWK  01.10 88/04/01 93/10/15 11:55    27    10     0 IS03\n@DSN     01.00 91/08/22 91/08/22 11:13     8     8     0 IS03\n@DSNQ    01.03 92/04/28 93/01/20 16:02     9     8     0 IS03A\n@DSNQM   01.00 93/01/20 93/01/20 16:01    10    10     0 IS03A\n@EDITMSK 01.05 89/02/11 94/05/23 19:10   187   159     0 IS03\n@END     01.01 88/02/10 93/10/18 12:49     8     7     0 IS03\n@FIXDAY  01.07 89/02/03 91/07/30 17:27    30    35     0 IS03\n@ICOPY   01.15 86/05/14 95/03/24 10:18   164   198     0 IS03\n@INFO    01.01 94/05/18 94/05/18 15:26     7     7     0 IS03\n@LAB     01.02 89/08/17 93/06/12 19:01     8     3     0 IS03\n@LISTRP  01.04 91/02/27 91/02/28 15:07    47    42     0 IS03\n@NOTE    01.03 87/06/05 94/04/21 19:16     7     3     0 IS03\n@PRINT   01.58 86/02/04 94/05/27 14:44   564    15     0 IS03\n@PRINTH  01.00 92/01/16 92/01/16 18:21   459   459     0 IS03\n@PRINTNX 01.11 92/10/09 94/05/23 18:38   194    34     0 IS03\n@PROD01  01.00 87/05/13 87/05/13 17:54    23    23     0 IS03\n@RENAME  01.09 86/08/28 94/06/01 17:05    65    42     0 IS03\n@SAVE    01.05 87/12/03 93/09/08 20:48    18    15     0 IS03\n@SCRIPT  01.54 86/02/04 95/08/24 09:49   910  1147     0 IS03\n@SCRIPTB 01.18 86/02/04 93/03/01 10:31   764  1424     0 IS03\n@SCRIPTD 01.03 90/08/13 92/02/14 21:15     7     6     0 IS03\n@SCRIPTN 01.00 92/04/03 92/04/03 21:49  1482  1482     0 IS03\n@SCRIPTO 02.04 87/04/10 92/04/03 21:50  1424   777     0 IS03\n@SCRIPTP 01.11 92/04/10 93/02/22 12:28   628    27     0 IS03\n@SCRIPTX 01.01 91/05/22 91/09/19 08:43  1301  1301     0 IS03\n@SCRPTDU 01.17 87/04/30 93/04/14 10:20   117   247     0 IS03\n@SCRPTD2 01.05 87/04/30 94/04/26 17:37    14     8     0 IS03\n@SCRPTD3 01.15 87/05/01 91/04/22 12:37    42     9     0 IS03\n@SCRPTD4 01.09 87/05/01 90/07/23 12:30    16     9     0 IS03\n@SEARCH4 01.06 92/04/30 93/09/20 23:49    48    10     0 IS03\n@SEQ     01.13 86/11/17 94/05/23 13:14   229   190     0 IS03\n@SLCT    01.04 86/11/14 89/04/21 13:19    87    83     0 IS03\n@SLCTDSX 01.01 87/03/04 87/03/05 17:50    72    72     0 IS03\n@SMALLS  01.21 85/09/17 93/09/29 16:13   359    49     0 IS03\n@SOP     01.01 92/07/15 92/07/15 17:27    38    25     0 IS03\n@SPELLS  01.11 94/07/05 94/07/07 17:31   163     4     0 IS03\n@STRAP   01.15 85/08/29 94/05/20 08:51    33    24     0 IS03\n@STRAPD  01.00 86/01/29 86/01/29 18:41    52    52     0 IS03\n@STRAPE  01.03 86/01/29 94/05/23 14:42    52    36    28 IS03\n@STRAPM  01.03 92/05/01 92/06/26 07:46    26    27     0 IS03\n@STRAPO  01.00 86/01/17 91/05/20 09:27    27    27     0 IS03\n@STRAPQ  01.07 87/05/15 94/05/23 14:41    75    35     0 IS03\n@STRAPQQ 01.01 90/12/17 90/12/17 21:40    41    41     0 IS03\n@TIME    01.00 93/12/17 93/12/17 11:33     8     8     0 IS03\n@TPP     01.08 87/08/15 94/06/02 20:18    63    53     0 IS03\n@TPP2    01.05 87/08/14 88/02/11 21:12    47    47     0 IS03\n@TSO     01.07 85/11/14 94/06/01 16:46    17     9     0 IS03\n@TSOX    01.04 86/06/05 94/06/01 16:37    33    11     0 IS03\n@TSOXD   01.05 86/06/05 94/08/08 20:48    44    33     0 IS03\n@VP      01.07 89/05/11 91/09/19 08:43   154   142     0 IS03\n@XMIT    01.05 88/05/20 90/02/19 13:58    83    50     0 IS03\nABJSPF   01.03 90/10/02 90/12/08 14:52    51    48     0 IS03\nAFP      01.09 90/09/25 94/05/17 09:24   139   114     0 IS03\nAFPRINT  01.01 87/04/16 87/06/17 13:45    23    22     0 IS03\nAHCINFO2 01.03 85/07/12 85/07/18 10:11    61    59    61 IS03\nALIGNJCL 01.07 85/12/24 92/07/28 08:44    85    32     0 IS03\nALIGNTAB 01.08 92/07/26 94/05/23 18:41   144   142     0 IS03\nAPPEND   01.01 94/04/07 94/06/24 14:41   213    66     0 IS03\nBIGS     01.11 91/05/03 94/05/23 19:10  1247  1251     0 IS03\nBK000    01.13 93/02/20 94/11/02 10:24    96    26     0 IS03\nBK001    01.06 93/02/21 93/02/21 15:03    30    24     0 IS03\nBK003    01.06 94/11/01 94/12/13 10:02   163    97     0 IS03\nBK004    01.02 94/11/01 94/11/02 12:59   163   108     0 IS03\nBLOCK    01.04 87/05/14 91/05/09 08:47    39    33     0 IS03\nBLOCK5   01.09 93/01/25 93/06/12 23:39   756  1242     0 IS03\nBMCDLIO  01.02 90/10/22 91/03/12 16:21    19    12     0 IS03\nBMC030   01.01 90/10/22 90/10/23 11:46     8     6     0 IS03\nBMDP     01.00 88/12/15 88/12/15 19:15   124   124     0 IS03\nBOOKBLD  01.02 94/02/03 94/02/09 21:56    94    94     0 IS03\nBOOKINX  01.01 94/02/09 94/02/09 21:56    94    94     0 IS03\nBOOKREAD 01.10 92/05/22 95/05/17 07:38   110    73     0 IS03\nBRODCAST 01.29 84/07/03 91/10/23 11:14   302   173   302 IS03\nBROWSE$  01.02 87/02/02 88/09/30 21:02    66    62     0 IS03\nCALCR    01.02 94/06/29 94/06/29 14:37     4     3     0 IS03\nCBT      01.02 91/07/19 94/05/17 10:28    74    51     0 IS03\nCHANGER  01.00 86/09/12 86/09/12 20:38    58    58     0 IS03\nCHECKDUP 01.02 90/09/15 91/03/27 18:04    68    41     0 IS03\nCHECKSUM 01.15 90/06/14 96/04/26 14:33   266    39     0 IS03\nCHECK72  01.04 85/09/23 94/06/03 08:33    23    18     0 IS03\nCK3084   01.08 88/01/19 88/09/30 21:11    22    18     0 IS03\nCLIST    01.53 85/07/10 94/09/19 09:15   361    31     0 IS03\nCLISTBOX 01.03 91/05/10 94/05/23 18:43    64    67     0 IS03\nCLOSING  01.10 86/05/16 89/03/27 20:29    21    12    21 IS03\nCOLS     01.03 93/10/04 95/10/19 13:06    71    24     0 IS03\nCOLSUM   01.15 91/04/08 94/05/23 18:44   120   231     0 IS03\nCOMPUTE  01.01 91/10/22 92/01/17 19:39    13    13     0 IS03\nCOPYFROM 01.27 88/05/18 94/06/01 08:17    54    18     0 IS03\nCOPYTO   01.01 89/04/29 89/05/26 12:44    23    22     0 IS03\nCPUID    01.00 93/12/16 93/12/16 13:06   129   129     0 IS03\nCSON     01.01 94/05/19 94/05/23 18:45    54    54     0 IS03\nCSTBLKX  01.00 88/06/02 88/06/02 17:48    99    99     0 IS03\nCSTLCFL  01.02 87/03/31 87/03/31 15:43    21    18     0 IS03\nCSTLISTD 01.08 89/05/25 89/06/30 11:41    74    20     0 IS03\nCSTSCRP  01.01 86/02/04 92/05/22 15:38  1466  1425     0 IS03\nCSTSOP   01.32 85/07/12 90/08/09 13:14   100    19   100 IS03\nCSTSOP1  01.33 85/07/12 93/04/14 09:44    56    23     0 IS03\nCSTSOP2  01.18 85/07/18 93/04/14 09:45    50    35    22 IS03\nCSTSOP3  01.11 86/01/23 93/04/14 09:45    50    45     9 IS03\nCSTSOP4  01.03 93/05/17 93/05/17 19:11    70    18     0 IS03\nCSTSVW   01.02 92/05/22 93/04/14 10:24   135   135     0 IS03\nCSTTLM11 01.02 89/07/13 89/09/06 14:14    16     9     0 IS03\nCST806   01.02 91/04/25 91/04/25 14:02    18     8     0 IS03\nCUSTBOX  01.00 93/01/25 93/01/25 15:03    36    36     0 IS03\nCUT      01.05 94/04/07 94/11/11 18:18   204    66     0 IS03\nDALIAS   01.03 88/10/11 88/10/11 19:12   455   449     0 IS03\nDATASPAN 01.12 85/11/05 90/07/24 19:29     7    14     0 IS03\nDATECONV 01.01 85/09/11 93/06/08 11:47    56    55     1 IS03\nDCFBOX   01.02 91/11/13 94/05/23 19:10    64    66     0 IS03\nDCFMSGS  01.05 93/10/14 93/10/28 10:16   235   210     0 IS03\nDDNAME   01.01 85/09/12 85/11/26 12:11    19     3    16 IS03\nDELXID   01.00 88/03/02 88/03/02 10:10     2     2     0 IS03\nDMSRSEND 01.05 87/08/10 87/08/10 15:12    11    11     0 IS03\nDOCIBMIN 01.15 89/03/24 91/07/03 20:20   125    71     0 IS03\nDONEMAC  01.06 86/02/12 90/04/20 19:57    36    11     0 IS03\nDSINFO   01.04 91/04/08 94/06/08 11:04   159   116     0 IS03\nDSMPROF3 01.20 87/11/11 93/04/14 09:31    38     4     0 IS03\nDSMPROF4 01.03 92/12/18 94/12/08 12:58    39    36     0 IS03\nDUADD    01.26 85/08/05 94/07/12 10:13   386   142     0 IS03\nDUADDC   01.04 85/08/27 94/05/23 14:39   360    30     0 IS03\nDUADDX   01.01 87/03/06 94/05/23 14:35    74    65     0 IS03\nDV2MM    01.14 92/01/17 92/01/21 19:04    50    14     0 IS03\nEDCHECK  01.02 94/08/19 94/08/19 16:32    10     9     0 IS03A\nEDCHEK   01.02 94/08/19 94/08/19 16:32    10     8     0 IS03A\nEDITAFP  01.02 92/03/18 92/03/18 15:38    72    36     0 IS03\nEDITCHEK 01.35 88/02/02 94/05/19 22:37   167    45     0 IS03\nEDITC001 01.12 86/05/02 86/05/08 09:37    59    26    59 IS03\nEDITDSN  01.02 92/03/26 93/05/19 09:20    17    17     0 IS03\nEDITD001 01.15 86/05/02 86/05/14 18:20   109    50     0 IS03\nEDITLL   01.01 94/03/31 94/04/01 09:31    57    40     0 IS03\nEDITMEM  01.13 91/05/06 94/07/12 09:23    75    17     0 IS03\nEDITOL   01.19 88/02/25 93/10/18 11:02   258   221     0 IS03\nEDITOLO  01.17 88/02/25 92/07/15 18:44   350   221     0 IS03\nEDITPAGE 01.16 88/01/29 94/06/03 09:59    85     7     0 IS03\nEDITPAIR 01.04 88/02/02 94/06/03 10:22    30    20     0 IS03\nEDITPR   01.12 89/02/11 94/05/23 18:47   238   255     0 IS03\nEDITPS   01.06 92/01/15 93/08/19 13:43    67    53     0 IS03\nEOL      01.11 93/08/04 94/09/19 09:27    92    44     0 IS03\nESHSC10A 01.00 96/06/20 96/06/20 08:17     1     1     0 IS03\nESHSC10C 01.00 96/06/20 96/06/20 08:18    31    31     0 IS03\nFALL     01.14 90/08/08 90/08/08 14:07    50    72     0 IS03\nFC       01.01 91/05/06 91/05/06 19:30    10    15     0 IS03\nFEDT1993 01.09 94/04/14 94/05/13 15:59   197   109     0 IS03\nFED1040  01.02 94/04/19 95/03/18 07:53   123   119     0 IS03\nFEVERY   01.11 86/04/28 94/05/23 14:33   223   171   112 IS03\nFGROUP   01.01 94/05/20 94/05/20 14:18    73    64     0 IS03\nFICHE    01.09 89/09/19 93/06/11 09:47   199   200   199 IS03\nFIXJCL   01.08 91/05/23 94/11/21 15:07   139   162     0 IS03\nFIXLI    01.17 88/01/30 94/06/03 10:37    39    64     0 IS03\nFIXP     01.10 88/02/09 94/06/03 11:02    40    24     0 IS03\nFIXPI    01.12 88/02/24 94/06/03 11:16   160    11     0 IS03\nFIXQUOTE 01.46 88/01/20 94/06/03 13:18    98     8     0 IS03\nFIXREXX  01.31 93/06/09 96/05/24 14:34   297   107     0 IS03\nFIXSCRP  01.13 88/02/10 88/02/24 09:54    24    14     0 IS03\nFLIPFLOP 01.04 90/12/27 93/05/18 14:27    63   107     0 IS03\nFLOC     01.15 86/05/03 94/06/28 12:49    80     4     0 IS03\nFLOW     01.02 91/10/09 93/05/18 17:16   111   111     0 IS03\nFOCTST08 01.00 89/05/17 89/05/17 18:52    34    34     0 IS03\nFOCTST14 01.00 89/05/17 89/05/17 18:57    16    16     0 IS03\nFOCUS    01.06 84/11/08 88/10/11 11:30    71    47    71 IS03\nFOCUS501 01.07 85/09/17 85/12/23 09:59    72    55    17 IS03\nFOCUS502 01.00 85/12/31 85/12/31 12:47    72    72     1 IS03\nFOCUS55X 01.00 88/01/25 88/01/25 15:11    72    72     1 IS03\nFWORD    01.00 94/05/17 94/05/17 18:51     5     4     0 IS03\nGDOC     01.03 92/07/08 92/07/08 11:16    39    14     0 IS03\nGETMACRO 01.01 86/06/02 86/09/05 20:50    12    12     0 IS03\nGETTRID  01.20 92/05/27 94/07/06 11:19    60    60     0 IS03\nGML      01.19 88/04/09 94/06/03 14:49    67    22     0 IS03\nGMLTP    01.00 90/12/27 90/12/27 14:05   150   150     0 IS03\nGOTDSN   01.00 89/09/06 89/09/06 11:17    29    29     0 IS03\nHEXES    01.03 90/09/21 94/05/23 18:49    71    64     0 IS03\nHEXSHOW  01.09 90/12/09 93/12/29 19:01    62    53     0 IS03\nHEXUS    01.03 90/12/07 94/04/20 09:33    62    38     0 IS03\nIDATA    01.03 92/03/10 92/03/11 13:41     7     4     0 IS03\nIFPSFOC  01.09 88/12/21 90/07/24 19:40    74    91     0 IS03\nILISTC   01.01 94/05/19 94/07/05 08:59    24    22    24 IS03\nINFO     01.00 85/04/09 85/04/09 17:05     3     3     0 IS03\nINFOHELP 01.08 85/04/25 94/05/17 11:27    42     3    42 IS03\nINFOLIB  01.11 90/02/22 90/04/26 15:49    91    33     0 IS03\nINFOSOP  01.20 86/05/29 88/10/03 18:33    47    11     0 IS03\nINSERT   01.02 92/01/17 94/05/23 14:07    51    47     0 IS03\nINVERT   01.02 90/04/19 94/06/03 15:19    31    22     0 IS03\nIOFIOF   01.05 86/06/13 89/09/29 15:04    20     3    20 IS03\nJCLBOX   01.06 91/05/10 94/05/24 18:10    68    68     0 IS03\nJOB      01.01 86/04/02 92/02/02 09:52    58    55     5 IS03\nJOBCARD  01.23 85/09/23 94/04/11 17:16   277   115     0 IS03\nJOBCARDO 01.20 85/09/23 93/04/23 11:06   226   115     0 IS03\nKILL     01.19 85/12/31 95/08/24 08:57   107    39     0 IS03\nKILLTHIS 01.00 91/08/27 91/08/27 13:03    56    56     0 IS03\nLABNX    01.11 87/11/12 94/06/24 10:45   154   185     0 IS03\nLCFIX    01.04 88/10/14 92/04/01 09:21    36    18     0 IS03\nLEFT@    01.05 92/04/07 94/05/23 18:55    59    37     0 IS03\nLISTDD   01.07 91/03/04 94/05/16 09:00    42    20     0 IS03\nLISTDDJ  01.01 92/03/29 92/04/03 21:53    52    49     0 IS03\nLISTRP   01.17 93/01/29 94/05/23 13:45   499   371     0 IS03\nLOADMOD  01.48 85/09/04 94/11/04 13:15   148    50     0 IS03\nLOADMODC 01.41 85/09/04 94/05/16 11:20   183    50     0 IS03\nMACMAC   01.02 91/02/14 91/02/14 17:23    42    42     0 IS03\nMACMACS  01.03 91/02/14 91/02/14 17:23    42    42     0 IS03\nMAIL     01.09 82/07/15 86/06/04 11:17   147   122    32 IS03\nMAKEADD  01.03 92/02/06 94/05/25 10:13    45    16     0 IS03\nMANRLAB  01.00 88/12/01 88/12/01 09:34   174   174     0 IS03\nMANUAL1  01.00 83/09/14 83/09/14 17:29    21    21     0 IS03\nMODELC   01.04 85/07/02 87/01/30 13:48    25    25     8 IS03\nMODELL   01.03 85/07/02 85/07/03 16:16    57    13     0 IS03\nMODELT   01.13 85/06/20 94/05/17 09:23    40     3    40 IS03\nMOREMAC  01.03 86/05/31 90/05/24 11:06    27    17     0 IS03\nMSDSDICT 01.01 93/10/06 94/05/18 15:04    20    16     0 IS03\nMSDSTEST 01.09 93/10/06 93/10/07 11:04    40    16     0 IS03\nMSGALLNX 01.00 90/04/18 90/04/18 18:14    21    21     0 IS03\nMSPELL   01.04 93/10/05 94/05/18 14:28     5   262     0 IS03\nMURPHY   01.22 94/06/28 96/04/23 15:56  5378  4994     0 IS03\nMURPHYXX 01.29 91/04/08 94/06/29 22:41  1594  1435     0 IS03\nM0282    01.03 91/01/24 91/01/25 14:51    33    32     0 IS03A\nM0282C   01.02 91/01/24 91/01/24 13:02     8     7     0 IS03\nM0282P   01.04 91/01/24 93/02/22 12:36    32    29     0 IS03\nM0282S   01.02 91/01/24 91/01/24 13:03    68    67     0 IS03\nNASPA    01.06 91/07/19 94/11/09 13:18   126    94     0 IS03\nNESTCHK  01.02 86/04/25 86/05/23 21:50   291   290     8 IS03\nNESTCHKO 01.02 86/04/24 86/04/24 18:22   224   213   111 IS03\nNEWCLIST 01.02 91/05/06 91/05/07 11:01    34    37     0 IS03\nNEWS     01.07 92/04/14 93/11/03 16:34   108    48     0 IS03\nNOBLANKS 01.01 93/10/27 93/10/27 12:15    13    10     0 IS03\nNOTENX   01.04 93/02/22 94/03/09 10:00    11    10     0 IS03\nNXNX     01.10 87/04/20 96/04/12 16:53   206   178     0 IS03\nPANCTM   01.03 90/04/18 90/04/18 16:26    60    36     0 IS03\nPANELS   01.16 89/08/23 94/05/23 13:39   256   143     0 IS03\nPANELS2  01.01 85/07/12 85/12/16 15:04    21    19     6 IS03\nPASTE    01.10 91/04/24 94/09/06 10:39   339   120     0 IS03A\nPAYDAY   01.00 95/11/07 95/11/07 17:14    12    12     0 IS03\nPBOX     01.00 93/01/25 93/01/25 15:05    33    33     0 IS03\nPDIRFIX2 01.04 88/12/09 89/03/01 10:30    43    29     0 IS03\nPDSDD    01.14 86/01/17 94/05/23 18:58   307   297     0 IS03\nPERIOD   01.13 88/03/20 93/05/19 23:13    36    34     0 IS03\nPHONEDD  01.02 94/08/25 94/08/25 17:31    32    28     0 IS03\nPHSKP    01.00 91/06/13 91/06/13 14:01    13    13     0 IS03\nPI       01.00 86/09/10 86/09/10 15:06    93    93     0 IS03\nPINX     01.07 86/09/10 94/05/23 12:54   247   192     0 IS03\nPINXDOIT 01.03 86/09/12 94/05/23 13:42   196     2     0 IS03\nPIR      01.12 86/09/11 94/06/03 22:19   289   199     0 IS03\nPLACE    01.07 92/02/06 92/10/15 17:02   138   126     0 IS03\nPLICHK   01.28 85/07/24 94/05/23 13:34   261   175     0 IS03\nPLIDCLS  01.00 90/06/27 90/06/27 15:29    40    40     0 IS03\nPLRHELP  01.00 92/11/12 92/11/12 15:22    13    13     0 IS03\nPMF      01.07 87/08/26 92/04/22 10:30   170   160     0 IS03\nPMFD     01.02 87/08/26 89/03/29 11:25   160   156     0 IS03\nPMFDOLD  01.00 87/08/26 87/08/26 15:12   156   156     0 IS03\nPRINTESX 01.02 87/10/27 87/10/27 18:49    67    67     0 IS03\nPRINTP   01.04 93/01/20 93/01/20 15:54    80    75     0 IS03A\nPRINTSOP 01.18 85/07/18 93/04/14 09:54    18     9    15 IS03\nPROC     01.15 85/07/10 94/05/17 09:24   163   107     0 IS03\nPROD01   01.03 87/05/13 94/05/17 12:34    29    19     0 IS03\nPROPER   01.07 92/02/11 93/05/19 12:59   847   788     0 IS03\nPSAFTSTS 01.00 87/05/05 87/05/05 16:50     2     2     0 IS03\nPU00L    01.13 93/10/19 94/05/13 13:38   389   147     0 IS03\nQ        01.15 86/08/22 93/05/28 08:07   323   256     0 IS03\nQCHK     01.01 94/05/02 94/05/02 10:13    33    33     0 IS03\nQHELP    01.07 90/12/17 90/12/20 23:50    22    10     0 IS03\nQHELP@   01.03 90/12/17 90/12/26 20:00    47    45     0 IS03\nR        01.02 86/04/22 87/02/06 12:13    46     8     0 IS03\nRCVYON   01.04 88/07/20 90/07/11 09:02    28     3     0 IS03\nRCVYWARN 01.09 91/07/24 91/08/13 21:21    39    34     0 IS03\nREFORMAC 01.38 85/08/30 92/08/22 09:21   383   171     0 IS03\nREFORMAT 01.54 85/08/30 95/10/19 13:55   258   171     0 IS03\nREFORMXX 01.36 85/08/30 91/01/12 20:55   338   171     0 IS03\nREMBLANK 01.05 91/10/11 94/05/23 19:02    98    84     0 IS03\nREMDUPS  01.20 85/09/17 93/09/29 16:17   268   251     0 IS03\nREMDUPSC 01.18 85/09/17 92/05/15 14:46   373   251     0 IS03\nREPEATNX 01.03 89/03/13 95/04/24 13:40    37    33     0 IS03\nREPLAY   01.11 83/05/05 83/10/25 13:38     6     6     5 IS03\nREVERSEX 01.02 93/05/18 96/07/26 17:30    10     8     0 IS03\nREXXBOX  01.01 91/10/14 94/05/23 19:10    64    66     0 IS03\nSAS      01.35 81/07/28 92/09/10 12:19   203    28     0 IS03\nSASALOC  01.08 81/07/31 83/10/25 11:43    40    35    40 IS03\nSASBMDP6 01.00 90/12/05 90/12/05 14:03   236   236     0 IS03\nSASFREE  01.06 81/07/31 85/01/23 12:46     7    13     7 IS03\nSASJUNK  01.00 87/07/22 87/07/22 10:18    44    44     0 IS03\nSASLH    01.01 90/11/15 90/11/15 13:31   202   202     0 IS03\nSAS5     01.02 86/06/05 92/09/08 18:20   207   205     0 IS03\nSAS606   01.08 90/08/01 92/04/16 14:12   243   241     0 IS03\nSAS606M  01.00 91/03/15 91/03/15 10:33   241   241     0 IS03\nSAS607   01.01 92/05/14 92/07/10 16:18   294   290     0 IS03\nSAS608   01.00 93/05/21 93/05/21 11:31   294   294     0 IS03\nSAS608M  01.00 95/12/05 95/12/05 14:20   294   294     0 IS03\nSBOX     01.00 93/01/25 93/01/25 15:02    38    38     0 IS03\nSCLIST72 01.22 88/05/16 91/07/26 16:04   122    23     0 IS03\nSCOPY    01.04 86/05/19 86/05/22 10:01    56    39    19 IS03\nSCOPYNX  01.05 86/05/19 86/05/22 09:01    27     5    23 IS03\nSCRIPTPS 01.63 91/09/05 96/07/09 14:39   425     5     0 IS03\nSEARCH4  01.09 91/10/24 93/09/20 23:54    46    11     0 IS03\nSENTRY   01.03 85/11/01 88/07/28 12:15    13    12     0 IS03\nSETSIZE  01.02 82/02/16 92/06/18 20:36    22    21     1 IS03\nSHIFT    01.12 86/04/21 94/05/24 17:54   186   194     0 IS03\nSHIFTNX  01.16 86/04/18 93/09/29 16:06   183   109     0 IS03\nSHOWDATE 01.03 86/07/09 94/05/24 14:25   126   111     0 IS03\nSHOWHDRS 01.00 94/02/18 94/02/18 09:13   157   157     0 IS03\nSKELCHEK 01.01 95/10/20 95/10/20 19:39   139   125     0 IS03\nSOP      01.04 93/04/05 95/01/07 14:50   142   132   142 IS03\nSOPA#### 01.04 89/01/28 92/07/16 10:57    99    55     0 IS03\nSOPDU    01.01 89/08/12 89/08/12 13:45     2     3     0 IS03\nSOPDUFIX 01.00 89/08/12 89/08/12 14:08    10    10     0 IS03\nSOPS#### 01.01 89/01/28 92/07/16 10:59    62    57     0 IS03\nSOPT#### 01.19 89/03/05 92/07/16 10:59    79    57     0 IS03\nSOP3328  01.18 87/02/02 92/04/22 10:46   120    29     0 IS03\nSORTCR   01.09 85/11/22 94/04/26 11:40   402   249     0 IS03\nSORTEM   01.14 85/10/30 94/04/26 11:39   239   150     0 IS03\nSORTG    01.08 90/02/05 94/04/26 11:42   252   225     0 IS03\nSPELIST  01.02 92/01/05 92/01/05 15:47    84    80     0 IS03\nSPELL    01.48 91/04/08 94/07/06 17:42   306   155     0 IS03\nSPFDSPN  01.01 89/11/08 90/07/06 14:08     3     3     0 IS03\nSPFIFPS  01.00 86/03/06 86/03/06 11:59     3     3     0 IS03\nSPFMAN   01.03 84/11/14 89/07/25 10:08     9     4     6 IS03\nSPRTAUTO 01.00 90/12/05 90/12/05 14:03    12    12     0 IS03\nSRCH400  01.07 88/05/14 92/08/28 13:58    19     2     0 IS03\nSRCH401  01.09 88/05/14 93/09/01 15:59    57    14     0 IS03\nSTAMPIT  01.07 92/08/03 92/08/04 08:55    19     9     0 IS03\nSUBMITIT 01.01 87/03/13 94/05/19 15:29     7     4     0 IS03\nSUBMITK  01.00 88/08/16 88/08/16 13:56    26    26     0 IS03\nSUPERC   01.05 88/03/11 93/02/17 13:16   464   443     0 IS03\nSUPPORT  01.00 90/12/05 90/12/05 14:03    15    15     0 IS03\nSYSDSN   01.29 92/03/25 96/06/03 09:49   174    81     0 IS03\nSYSIN    01.00 91/05/23 91/05/23 17:29     8     8     0 IS03\nTAGX     01.02 90/10/23 94/06/03 23:59   162   176     0 IS03\nTEAR     01.08 91/11/14 96/07/26 17:57   179   163     0 IS03\nTECHPS   01.31 94/02/16 96/06/11 17:50   513   310     0 IS03\nTECHSEND 01.02 85/11/18 90/09/02 12:42    23    21     0 IS03\nTIFCONV  01.02 87/11/02 88/06/29 17:05    38    12    38 IS03\nTIMEDIFF 01.05 92/07/27 93/09/29 21:36    74    62     0 IS03\nTLMSINQ  01.07 92/07/12 94/02/03 12:56    40    19    40 IS03\nTLMSTST  01.00 87/05/04 87/05/04 17:14    35    35     0 IS03\nTLMSUSER 01.11 84/07/23 89/07/14 09:30     3     8     3 IS03\nTLMSUSR  01.06 85/06/27 91/05/20 14:47    91    82     0 IS03\nTLMSUSRX 01.08 85/05/17 87/04/06 15:11    51    34    18 IS03\nTLOG     01.04 87/09/28 94/02/16 09:50    62    57    62 IS03\nTLOGEDIT 01.14 86/10/23 89/03/04 21:29    72    13     0 IS03\nTOD      01.06 93/09/28 93/11/30 17:32    66    45     0 IS03\nTODO     01.17 86/02/12 93/09/29 09:09    67    51     0 IS03\nTODOMAC  01.06 86/02/12 90/07/10 08:36    33    10     0 IS03\nTSOOS2   01.12 93/05/20 94/04/25 19:41    59    19     0 IS03\nTSOTRAP  01.09 93/01/19 94/06/30 14:26    61    57     0 IS03\nUNGML    01.03 88/04/09 94/05/23 19:10    42    42     0 IS03\nUNIQUE   01.00 94/04/22 94/04/22 13:31    41    41     0 IS03\nUSERSDCF 02.05 88/11/03 96/04/11 18:08   480   121     0 IS03\nWHEREIS  01.01 93/10/04 93/10/04 21:15   122   120     0 IS03\nWHICH    01.11 84/11/12 90/09/24 10:41    87    80    87 IS03\nWHO      01.02 87/02/10 94/07/06 14:34    15     8    15 IS03\nWHOPIMS  01.00 90/11/26 90/11/26 18:37    11    11     0 IS03\nWHOPUP   01.02 87/01/21 87/01/21 17:24   165   121     0 IS03\nWHOTUP   01.01 87/01/21 87/01/21 17:16    84    83     0 IS03\nWORDS    01.00 93/11/09 93/11/09 18:37    39    39     0 IS03\nXEVERY   01.09 86/04/28 86/05/23 21:40   167   181     0 IS03\nX0289    01.01 91/01/19 91/03/21 13:05    32    32     0 IS03\nX0289C   01.03 91/01/18 91/01/18 22:51     7     3     0 IS03A\nX0289P   01.07 91/01/22 93/02/22 12:34    29     5     0 IS03\nX0289S   01.15 91/01/18 91/01/22 23:42    67    56     0 IS03\nZ        01.01 91/06/05 91/06/05 14:10    50    50     0 IS03\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$MIDI": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x03\\x00\\x03\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 3, "newlines": 3, "modlines": 0, "user": "MCRITCH"}, "text": "00010001 PROC 0\n00020000 ISPEXEC BROWSE DATASET('SYS6.MIDILIST.LISTING')\n00030000 EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MIDITL": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x05\\x00\\x05\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "MCRITCH"}, "text": "00010000 ISREDIT MACRO\n00012005         SET &VSTSRVTI = &STR(SYS6.MIDILIST.TLMSCOMB -- TLMS AND +\n00012105           MIDILIST COMBINED)\n00020004 ISPEXEC BROWSE DATASET('SYS6.MIDILIST.TLMSCOMB') PANEL(SYSBROBF)\n00030000 EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$USERS": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xcf\\x00\\xcf\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 207, "newlines": 207, "modlines": 0, "user": "MCRITCH"}, "text": " /* rexx ---- $USERS clist converted to rexx  for fun */\n /* EDIT G(0) FAX NET NET04 B ALL NET02A OLD$USERS WHOGOT PROFS*/\n /*         BW PHONE */\n arg  token\n token = \" \"TOKEN\" \"\nEDIT='';fax='';net='';net04='';b='';all='';net02a='';\nold$users='';whogot='';profs='';g='';cmdvar='';\nparse var token left \" G(\" G \") \" right\ntoken = left || ' ' || right\nif g = '' then g = \"0\"\nEDIT      = process('EDIT')\nFAX       = process('FAX')\nNET       = process('NET')\nNET04     = process('NET04')\nB         = process('B')\nALL       = process('ALL')\nNET02A    = process('NET02A')\nOLD$USERS = process('OLD$USERS')\nWHOGOT    = process('WHOGOT')\nPROFS     = process('PROFS')\nPHONE     = process('PHONE')\nSSNO      = process('SSNO')\nBW        = process('BW')\nif token /= \"\" then do;\n   CMDVAR = \"FIND \"token\n   if net = \"NET\" then if ^datatype(word(token,1),'N') then\n      CMDVAR = \"FIND 12 \"token;\nend\naddress \"TSO\"\n  /* provided by David McRitchie 1985/04/08, \"The REXX Macros Toolbox\" */\n  /* (default) -- PHO.GENERAL.GENERAL.ZZ2B0702(0)                    */\n  /*  PURPOSE: quick access to list of TSO users                     */\n  /*     other files with related data also available by option usage*/\n  /*  -------------- companion clist   USERSDCF                      */\n  /*  ------------- which dataset name, mutually exclusive options --*/\n  /* old$users -- PHO.GENERAL.GENERAL.ZZ2B1001(0)                    */\n  /* net04  -- pho.general.general.zz1p6701(0) -- all alphabetical   */\n  /* net    -- pho.general.general.zz1p6701(0) -- all alphabetical   */\n  /* net02a -- is03.net02a.ioflist                                   */\n  /* profs  -- pho.general.general.zz5e0601(0) -- location / name    */\n  /* B      -- is03.net04B.sortin                                    */\n  /* ALL    -- is03.net04all.sortin   all by location                */\n  /* FAX    -- PHO.GENERAL.GENERAL.ZZ5E1001 -- non GDG,manual updated*/\n  /*  -------------- other opitions ---------------------------------*/\n  /* EDIT   -- to use edit instead of browse                         */\n  /* WHOGOT -- invoke WHOGOT before edit/browse, N/A with G(*), FAX  */\n  /*  -------------- specific generations -------------------------- */\n  /* G(0)   -- current generation, DEFAULT, if applicable            */\n  /* G(-2)  -- back two generations, if applicable                   */\n  /* G(*)   -- DSLIST invoked dsn ending .G*  to pick up .GxxxxV00   */\n  /*           descriptive headings not available when using DSLIST. */\n  /*  -------------------------------------------------------------- */\n /* formerly used tech.info.text(users) */\n IF FAX = \"FAX\" THEN DO\n    ADDRESS \"ISPEXEC\" \"BROWSE DATASET('PHO.GENERAL.GENERAL.ZZ5E1001')\"\n    /* Marcia Hoffman -- Sandy Boupane */\n    EXIT 0\nEND\n IF PHONE = \"PHONE\" THEN DO\n    ADDRESS \"ISPEXEC\" \"BROWSE DATASET('IS03.JCLPCALL.LIST')\"\n    EXIT 0\nEND\n IF BW = \"BW\" THEN DO\n    ADDRESS \"ISPEXEC\" \"BROWSE DATASET('IS03.JCLPCBW.LIST')\"\n    EXIT 0\nEND\n IF FAX = \"FAX\" THEN DO\n    ADDRESS \"ISPEXEC\" \"BROWSE DATASET('PHO.GENERAL.GENERAL.ZZ5E1001')\"\n    /* Marcia Hoffman -- Sandy Boupane */\n    EXIT 0\nEND\n IF PROFS =  \"PROFS\" THEN DO\n    ADDRESS \"TSO\" ,\n          \"$BROWSE PHO.GENERAL.GENERAL.ZZ5E0601.*\"\n    /* Marcia Hoffman -- Dean Williams */\n    EXIT 0\nEND\n   GDSN = \"PHO.GENERAL.GENERAL.ZZ2B0702\"\n IF NET04 = \"NET04\" THEN   NET = \"NET\"\n IF NET = \"NET\"   THEN   GDSN = \"PHO.GENERAL.GENERAL.ZZ1P6701\"\n IF NET02A = \"NET02A\" THEN   GDSN = \"IS03.NET02A.IOFLIST\"\n IF NET02A = \"NET02A\" THEN   G = \"\"\n IF B      = \"B\"      THEN   GDSN = \"IS03.NET04B.SORTIN\"\n IF B      = \"B\"      THEN   G = \"\"\n IF B      = \"B\"      THEN   NET = \"NET\"\n IF ALL    = \"ALL\"    THEN   GDSN = \"IS03.NET04ALL.SORTIN\"\n IF ALL    = \"ALL\"    THEN   G = \"\"\n IF ALL    = \"ALL\"    THEN   NET = \"NET\"\n if ALL = \"ALL\" | B = \"B\" | NET02A = \"NET02A\" then do;\n    x = SYSDSN(GDSN)\n    if x /= \"OK\" then do\n        ZEDSMSG = x\n        ZEDLMSG = x \"--\" GDSN\n        ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n        RETURN 1\n    end\n end\n IF NET /= \"NET\" THEN DO\n   IF OLD$USERS = \"OLD$USERS\" THEN DO\n        GDSN = \"PHO.GENERAL.GENERAL.ZZ2B1001\"\n       DSNDESC      = \"STR(01-08 Userid   43-IMS  48-VSPC  49 ICCF  \",\n         \"54-58 Emp#\"\n       DSNDESC3 = \"STR(09-38 Name         44-45 TSO/SPART  50-53    \",\n         \"59-62 cccc\"\n       DSNDESC4 = \"STR(39-42 Out/Dest 46-47 CICS/SPART 63-72 \",\n         \"Phone,73-82 Room\"\n   END\n   ELSE DO\n        GDSN = \"PHO.GENERAL.GENERAL.ZZ2B0702\"\n       DSNDESC      = \"  01-08 Userid   09-09 Emp/Non \",\n          \"11-26 Lst Nme   27-42 Fst Nme\"\n       DSNDESC3     = \"  43-45 Phn Xch  47-50 Phn Ext  51-60 Bld/Rm \",\n          \"  61-63 BU Cd     65-67 Loc Cd\"\n       DSNDESC4     = \"  69-72 Dpt Cd   73-92 Pos Tle  93-96 Out Dst\",\n          \" 97-116 reserved\"\n       if SSNO = \"SSNO\" then do\n        DSNDESC4     = \"  69-72 Dpt Cd   73-92 Pos Tle  93-96 Out Dst\",\n          \" 97-116 SSNO/EMP#\"\n        GDSN = \"PHO.GENERAL.GENERAL.ZZ2B0701\"  /*authorization needed*/\n       end\n       DSNDESC5   = \" 117-118 EmpSta 119-128 Exp Dt 129-131 CICS Opr\"\n   END\n END\n ELSE DO\n  DSNDESC      = \"01-01 Header(H), Function(F), Phone(P) 02-11 \",\n      \"phone#\"\n  DSNDESC3 = \"12-40 Name         \",\n      \"41-56 Title (reserved 41-70)\"\n  DSNDESC4 = \"71-74, 75-84 internal mail, \",\n      \" # in col 85 secretary format\"\n END\n IF G /= \"\" THEN DO\n    IF G = \"*\" THEN DO\n       Address \"TSO\" \"$EDIT \"GDSN\".G*\"\n       return lastcc\n    END\n    ELSE   GDSN = GDSN\"(\"G\")\"\n END\n  VSTSRVTI =  GDSN\n IF WHOGOT = \"WHOGOT\" THEN \"WHOGOT\" \"GDSN\"\n IF EDIT = \"EDIT\" THEN DO\n    address \"ISPEXEC\" \"CONTROL ERRORS RETURN\"\n    IF DSNDESC5 /= \"\" THEN DO\n       Address \"ISPEXEC\" ,\n           \"VPUT (DSNDESC,DSNDESC3,DSNDESC4,DSNDESC5) SHARED\"\n       Address \"ISPEXEC\" \"EDIT DATASET('\"GDSN\"') PANEL(SYSEDDE5)\"\n    END\n    ELSE DO\n       Address \"ISPEXEC\" \"VPUT (DSNDESC,DSNDESC3,DSNDESC4) SHARED\"\n       Address \"ISPEXEC\" \"EDIT DATASET('\"GDSN\"') PANEL(SYSEDDE4)\"\n    END\n    ZEDSMSG = ZERRSM\n    ZEDLMSG = ZERRMSG ZERRLM\n    ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    EXIT 0\n END\n Address \"ISPEXEC\" ,\n      \"VPUT (VSTSRVTI,DSNDESC,DSNDESC3,DSNDESC4,DSNDESC5) SHARED\"\n    IF DSNDESC5 /= \"\"     THEN do\n             Address \"ISPEXEC\" \"CONTROL NONDISPL ENTER\"\n             Address \"ISPEXEC\" ,\n                 \"BROWSE DATASET('\"GDSN\"') PANEL(SYSBROB5)\"\n    end\n    ELSE do\n             Address \"ISPEXEC\" \"CONTROL NONDISPL ENTER\"\n             Address \"ISPEXEC\" ,\n                 \"BROWSE DATASET('\"GDSN\"') PANEL(SYSBROB4)\"\n    end\n /* ---------- */\n return\n /* ---------- */\nProcess: procedure expose token\n arg subtoken\n i = index(token,' '||subtoken||' ')\n if i=0 then return ''\n tokenx = substr(token,1,I) || substr(token,I+2+length(subtoken))\n token = tokenx\n return subtoken\nProcessB: procedure expose token\n arg subtoken\n x = process(subtoken)\n if x /='' then x = ' '||x\n return x\n/*********************************************************************/\n/* =========== Wish List ====(additional fields)=========            */\n/* char(4) notify=userid  for mailing and notifications  (dms        */\n/*           backups, library tapes, letters) when a terminated user */\n/*           is involved, also to be used for preferred userid of    */\n/*           multiple id user Some persons have multiple userids,    */\n/*           would be nice if their primary USERID could be          */\n/*           identified                                              */\n/*             e.g.  managers seem to accrue lots of userids of      */\n/*                   terminated/transferred employees.               */\n/* 9-digit ssec# is used instead of 5-digit emp# for all old celanese*/\n/*       locations; therfore, should be accomodated                  */\n/* char(1) INFO CENTER NewsLetter checkoff-- would probably simplify */\n/*       distribution, because labels could be generated from new    */\n/*       list                                                        */\n/* char(30) job title -- hopefully it will be put back to 30 and not */\n/*        be limited to 16 byte shorter form used by Celanese) this  */\n/*        would facilitate making up distribution lists with job     */\n/*        titles.                                                    */\n/*  ???  Does cost center match employee master.                     */\n/* usage notes:                                                      */\n/*        employee# and phone# and room# usually indicates a current */\n/*         employee, even though termination indicator is on.        */\n/*********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@AMSRCAT": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xf3\\x00\\xf3\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 243, "newlines": 243, "modlines": 0, "user": "MCRITCH"}, "text": "   ISREDIT MACRO (DSN ENTRY VOLSER)\n /* EXAMPLE  ==> @AMSRCAT *\n /* EXAMPLE  ==> @AMSRCAT INTERNAL.SMF.IV3H0101\n /* EXAMPLE  ==> @AMSRCAT PSAF LEVEL\n /* EXAMPLE  ==> @AMSRCAT PSAF LEVEL MVSX20\n /* EXAMPLE  ==> @AMSRCAT PSAF LEVEL MVSD   (AS IN MVSDLB)\n /* AUTHOR -- DAVID MCRITCHIE,             1987/05/29 */\n /* PURPOSE: ABILITY TO REDEFINE GDG LIMIT */\n /*            ==> @AMSRCAT INTERNAL.SMF.IV3H0101\n /* PURPOSE: ABILITY TO RECATALOG NVSAM ENTRIES INDIRECTLY */\n /*            ==> @AMSRCAT PSAF LEVEL ?VOLSER?\n IF &STR(&ENTRY) = &STR() THEN SET ENTRY = ENTRY\n IF &STR(&ENTRY) = &STR(LVL) THEN SET ENTRY = LEVEL\n IF &STR(&ENTRY) ^= ENTRY AND &STR(&ENTRY) ^= LEVEL -\n    THEN DO\n        SET &ZEDSMSG = &STR(&ENTRY?)\n        SET &ZEDLMSG = &STR(&ENTRY.  2ND PARAMETER UNKNOWN TO CLIST +\n          @AMSRCAT, MUST BE ENTRY | LEVEL)\n        ISPEXEC     SETMSG MSG(ISRZ000)\n        EXIT CODE(12)\n    END\n IF &LENGTH(&STR(&VOLSER)) > 6  -\n    THEN DO\n        SET &ZEDSMSG = &STR(&VOLSER?)\n        SET &ZEDLMSG = &STR(&VOLSER. -- 3RD PARAMETER  VOLSER IS +\n          LIMITED TO 6 CHARACTERS)\n        ISPEXEC     SETMSG MSG(ISRZ000)\n        EXIT CODE(12)\n    END\n IF LEVEL ^= &STR(&ENTRY) THEN SET VOLSER = &STR()\n SET XDSN0 = XDSN0\n SET XVOL0 = XVOL0\n SET RC = &STR(0)\n SET DSN = &STR(&SYSCAPS(&STR(&DSN)))\n SET B = &STR(                                            )\n SET B = &STR(&B.&B.&B.)\n SET XSEQ = &STR(&B.)\n IF &STR(&DSN) = &STR(*) THEN SET DSN = PHO.INTERNAL.BILLBACK.IV7B0202\n IF &SUBSTR(8:8,&DSN.&B.) = &STR( ) THEN DO\n    IF ENTRY = &STR(&ENTRY) THEN DO\n       WRITE \"&DSN.\" IS TOO SHORT FOR A DSNAME\n       EXIT CODE(8)\n    END\n END\n SET LP = &STR((\n SET RP = &STR())\n SET SYSOUTTRAP = 4600\n LISTCAT &ENTRY.('&DSN.') ALL\n IF &LASTCC ^= 0 THEN EXIT CODE(12)\n SET N = &SYSOUTLINE\n SET SYSOUTTRAP = 0\n SET RC = 0   /* FILES TO BE CHECKED LATER RACF/BROWSE */\n SET I = 0\n SET G = 0\n SET HIT2 = 0\n SET HIT1 = 0\n DO WHILE &I <= &N\n    SET X = &STR(&&SYSOUTLINE&I..)\n    SET X = &STR(&X.)\n /*        WRITE &I. &RC. |1...5...10...15...20...25...30...35...40...+\n   45...50...55...60\n /*        WRITE &I. &RC. |&X.\n    IF &SUBSTR(1:3,&STR(&X.&B)) = &STR(IDC) THEN WRITE &X.\n    IF &SUBSTR(1:16,&STR(&X.&B.)) = &STR(   NONVSAM ---- ) THEN DO\n       SET RC = &RC + 1\n       IF DEBUG = &DEBUG THEN WRITE &I. &RC. |&X.\n       SET XDSN&RC = &SUBSTR(17:60,&STR(&X.&B))\n       SET XVOL = &STR()\n       SET XSEQ = &STR()\n       SET XDEV = &STR()\n       GOTO NIX\n    END\n    IF &SUBSTR(3:11,&STR(&X.&B.)) = &STR(   IN-CAT) THEN DO\n       SET CAT = &SUBSTR(17:60,&STR(&X.&B))\n       SET CAT = &CAT\n       SET CAT&RC = &CAT\n       GOTO NIX\n    END\n    IF &SUBSTR(1:12,&STR(&X.&B.)) = &STR(NONVSAM ----) THEN DO\n       SET RC = &RC + 1\n       IF &RC < 40 THEN  WRITE &X. -- LINE 73\n       ELSE DO\n          SET A = &RC / 10\n          SET A = &A * 10\n          IF &RC = &A THEN WRITE &X. -- @73 -- &A\n       END\n       IF DEBUG = &DEBUG THEN WRITE &I. &RC. |&X.\n       SET XDSN&RC = &SUBSTR(17:60,&STR(&X.&B))\n       SET XVOL = &STR()\n       SET XSEQ = &STR()\n       SET XDEV = &STR()\n       GOTO NIX\n    END\n    IF &SUBSTR(1:14,&STR(&X.&B.)) = &STR(       LIMIT--) THEN DO\n       SET K = 31\n       SET LIMIT =\n      LPK:    IF &SUBSTR(&K,&STR(&X.&B)) >= &STR(0) THEN DO\n          SET LIMIT=&SUBSTR(&K,&STR(&X.&B))&LIMIT.\n          SET K = &K - 1\n          GOTO LPK\n       END\n       SET SCRATCH = &SUBSTR(33:80,&X.&B.)\n       SET SCRATCH = &SCRATCH.\n       GOTO NIX\n    END\n    IF &SUBSTR(1:13,&STR(&X.&B.)) = &STR(       VOLSER) THEN DO\n       IF &RC = 0 THEN DO\n          WRITE &X. -- LINE 95\n          GOTO NIX\n       END\n       IF &STR(&XVOL) ^= &STR() THEN SET XVOL = +\n         &STR(&XVOL.,)&SUBSTR(26:31,&STR(&X.&B))\n       ELSE SET XVOL = &SUBSTR(26:31,&STR(&X.&B))\n       SET XVOL&RC = &STR(&XVOL)\n       /* -------------------------------------------- */\n       SET TDEV   = &SUBSTR(52:59,&STR(&X.&B))\n       IF &STR(&TDEV) = 3010200E THEN SET TDEV = &STR(3380    )\n       IF &STR(&TDEV) = 3010200F THEN SET TDEV = &STR(3390    )\n       IF &STR(&TDEV) = 24008003 THEN SET TDEV = &STR(3400-3  )\n       IF &STR(&TDEV) = 34208003 THEN SET TDEV = &STR(3400-4  )\n       IF &STR(&TDEV) = 32008003 THEN SET TDEV = &STR(3400-5  )\n       IF &STR(&TDEV) = 32108003 THEN SET TDEV = &STR(3400-6  )\n       IF &STR(&TDEV) = 78008080 THEN SET TDEV = &STR(3480    )\n       IF &STR(&XDEV) ^= &STR() THEN SET XDEV = &STR(&XDEV.,&TDEV.)\n       ELSE SET XDEV = &STR(&TDEV)\n       SET XDEV&RC = &STR(&XDEV)\n       /* -------------------------------------------- */\n       SET TSEQ = &SUBSTR(85:89,&STR(&X.&B))\n       IF &SUBSTR(1:4,&STR(&TSEQ.&B.)) = &STR(----) THEN SET TSEQ = +\n         &SUBSTR(5:5,&STR(&TSEQ))\n       IF &SUBSTR(1:3,&STR(&TSEQ.&B.)) = &STR(---) THEN SET TSEQ = +\n         &SUBSTR(4:5,&STR(&TSEQ))\n       IF &SUBSTR(1:2,&STR(&TSEQ.&B.)) = &STR(--) THEN SET TSEQ = +\n         &SUBSTR(3:5,&STR(&TSEQ))\n       IF &SUBSTR(1:1,&STR(&TSEQ.&B.)) = &STR(-) THEN SET TSEQ = +\n         &SUBSTR(2:5,&STR(&TSEQ))\n       IF &STR(&XSEQ) ^= &STR() THEN SET XSEQ = &STR(&XSEQ.,&TSEQ.)\n       ELSE SET XSEQ = &STR(&TSEQ.)\n       SET XSEQ&RC = &STR(&XSEQ.)\n       /* -------------------------------------------- */\n       IF DEBUG = &DEBUG THEN WRITE &I. &RC. |&X.\n       GOTO NIX\n    END\nNIX: -\n    SET I = &I. + 1\n END\n /****************\n SET XDSN = &&XDSN&RC\n IF ENTRY = &ENTRY THEN WHOGOT &XDSN\n IF BROWSE = &BROWSE THEN DO\n    $BROWSE &XDSN\n    IF ONLY = &ONLY THEN DO\n       WRITE  USED&LP.&RC.&RP. OF &STR(&LIMIT)\n    END\n END\n /****************\n SET I = 0\n IF ENTRY = &ENTRY THEN DO\n    IF &EVAL(&RC) = &EVAL(0) THEN EXIT CODE(12)\n END\n ISREDIT LINE_AFTER .ZLAST = \"//+\n             * ---- GENERATED BY THE CLIST ==> @AMSRCAT &DSN.\"\n ISREDIT LINE_AFTER .ZLAST = \"// EXEC AMS,SYSOUT=V \"\n DO WHILE &I < &RC\n    SET I = &I + 1\n    SET XDSN = &&XDSN&I\n    SET XDSN = &XDSN\n    IF &STR(&VOLSER) = &STR() THEN DO\n       ISREDIT LINE_AFTER .ZLAST = \" DELETE &XDSN. NOSCRATCH - \"\n       ISREDIT LINE_AFTER .ZLAST = \"     CATALOG(&CAT) \"\n    END\n END\n IF LEVEL ^= &ENTRY THEN DO\n    ISREDIT LINE_AFTER .ZLAST = \" DELETE &DSN GDG NOFORCE -\"\n    ISREDIT LINE_AFTER .ZLAST = \"     CATALOG(&CAT) \"\n    IF &EVAL(&RC) = &EVAL(0) THEN EXIT CODE(12)\n    WRITE  USED&LP.&RC.&RP. OF &STR(&LIMIT)\n    ISREDIT LINE_AFTER .ZLAST = \"//+\n             * ---- GENERATED BY THE CLIST ==> @AMSRCAT &DSN.\"\n    ISREDIT LINE_AFTER .ZLAST = \"//+\n             * ----  LIMIT(&LIMIT.)  FOUND &RC. DATASETS\"\n    ISREDIT LINE_AFTER .ZLAST = \"// EXEC AMS,SYSOUT=V \"\n    ISREDIT LINE_AFTER .ZLAST = \" DEFINE GDG - \"\n    ISREDIT LINE_AFTER .ZLAST = \"    (NAME(&DSN) - \"\n    IF &EVAL(&RC.+10000) > &EVAL(&LIMIT.+10000) THEN -\n    ISREDIT LINE_AFTER .ZLAST = \"     LIMIT(&RC.) &SCRATCH.) - \"\n    ELSE -\n    ISREDIT LINE_AFTER .ZLAST = \"     LIMIT(&LIMIT.) &SCRATCH.) - \"\n    ISREDIT LINE_AFTER .ZLAST = \"     CATALOG(&CAT) \"\n END\n ISREDIT LABEL .ZLAST = .RCAT 0\n SET I = 0\n DO WHILE &I < &RC\n    SET I = &I + 1\n    SET XDSN = &&XDSN&I\n    SET XDSN = &XDSN\n    SET XVOL = &STR(&&XVOL&I)\n    SET XDEV = &&XDEV&I\n    SET XSEQ = &&XSEQ&I\n    IF &STR(&XSEQ.) = &STR(0) THEN SET XSEQ = &STR(1)\n    IF &STR(&VOLSER) ^= &STR() THEN DO\n       SET L = &LENGTH(&STR(&VOLSER))\n       IF &SUBSTR(1:&L,&STR(&XVOL)) ^= &STR(&VOLSER) THEN GOTO XVOLS\n       ISREDIT LINE_AFTER .ZLAST = \" DELETE &XDSN. NOSCRATCH - \"\n       ISREDIT LINE_AFTER .ZLAST = \"     CATALOG(&CAT) \"\n    END\n    WRITE  &I.&STR(/)&RC &XDSN   &STR(&LP.-)&EVAL(&RC.-&I)&STR(&RP)\n    WRITE &STR(      )&XVOL &XDEV &XSEQ\n    ISREDIT LINE_AFTER .ZLAST = \" DEFINE NVSAM - \"\n    ISREDIT LINE_AFTER .ZLAST = \"    (NAME(&XDSN.) - \"\n    IF &SUBSTR(54:54,&XDEV.&B.) = &STR(,) THEN DO\n       ISREDIT LINE_AFTER .ZLAST = \"     DEVT(&SUBSTR(1:54,&XDEV) - \"\n       SET XDEV = &SUBSTR(55:&LENGTH(&XDEV),&XDEV)\n       DO WHILE &SUBSTR(54:54,&XDEV.&B) = &STR(,)\n        ISREDIT LINE_AFTER .ZLAST = \"          &SUBSTR(1:54,&XDEV) - \"\n        SET XDEV = &SUBSTR(55:&LENGTH(&XDEV),&XDEV)\n       END\n       ISREDIT LINE_AFTER .ZLAST = \"          &XDEV.) - \"\n    END\n    ELSE DO\n       ISREDIT LINE_AFTER .ZLAST = \"     DEVT(&XDEV) - \"\n    END\n    IF &SUBSTR(42:42,&XVOL.&B.) = &STR(,) THEN DO\n       ISREDIT LINE_AFTER .ZLAST = \"      VOL(&SUBSTR(1:42,&XVOL) - \"\n       SET XVOL = &SUBSTR(43:&LENGTH(&XVOL),&XVOL)\n       DO WHILE &SUBSTR(42:42,&XVOL.&B) = &STR(,)\n        ISREDIT LINE_AFTER .ZLAST = \"          &SUBSTR(1:42,&XVOL) - \"\n        SET XVOL = &SUBSTR(43:&LENGTH(&XVOL),&XVOL)\n       END\n       ISREDIT LINE_AFTER .ZLAST = \"          &XVOL.) - \"\n    END\n    ELSE DO\n     ISREDIT LINE_AFTER .ZLAST = \"       VOL(&XVOL) - \"\n    END\n    ISREDIT LINE_AFTER .ZLAST = \"       FSEQN(&XSEQ.) ) - \"\n    ISREDIT LINE_AFTER .ZLAST = \"       CATALOG(&CAT) \"\n XVOLS: -\n END\n ISREDIT CHANGE ALL .RCAT .ZLAST 1 72 ' ' '\u00a2'\n ISREDIT CHANGE ALL .RCAT .ZLAST \"\u00a2\u00a2,\" \",\"\n ISREDIT CHANGE ALL .RCAT .ZLAST \"\u00a2\" \" \"\n ISREDIT CHANGE ALL .RCAT .ZLAST 'FSEQN(0)' 'FSEQN(1)'\n ISREDIT RESET      .RCAT .ZLAST\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@C": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x13\\x00\\x13\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "MCRITCH"}, "text": " /*REXX:CAPITALIZE ALL WORDS IN LIST, LABELS PREFIX CHARS--OPTIONAL*/\n /* CONTRIBUTED  F. DAVID MCRITCHIE, \"THE REXX MACROS TOOLBOX\" 1989/05/12 BWTR*/\n     ADDRESS \"ISREDIT\"    /* CONVERTED TO REXX 1992/02/08 FDM */\n     \" MACRO (TOK1,TOK2,TOK3,TOK4,TOK5,TOK6,TOK7,TOK8,TOK9,TOK10,\",\n      ||\"TOK11,TOK12,TOK13,TOK14,TOK15,TOK16,TOK17,TOK18,TOK19)\"\n     WORD = WORD    /* DEFAULT */\n     \"(CSR1,CSR2) = CURSOR\"\n     PREFIX='';CHARS=''; CPREF=''\n     DO I = 1 TO 19 BY 1;\n        TOKINA = VALUE('TOK'||I)\n        TOKEN = TRANSLATE(TOKINA)\n        IF TOKEN = \"\" THEN LEAVE I\n        ELSE IF TOKEN = \"NX\" | \".\" = SUBSTR(TOKEN,1,1) THEN ,\n           CPREF = CPREF  || \" \"   || TOKINA\n        ELSE IF \"WORD\" = TOKEN | \"PREFIX\" = TOKEN | \"CHAR\" = TOKEN ,\n           | \"CHARS\" = TOKEN  THEN WORD = TOKEN\n        ELSE  \"C ALL \"WORD   CPREF  TOKINA TOKEN\n      END I\n ENDTOK: \"CURSOR = \" CSR1 CSR2; \"LOC\" CSR1; RETURN 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@CAPS": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00?\\x00?\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "MCRITCH"}, "text": "/* Change all lowercase to UPPPERCASE                        (REXX) */\nADDRESS \"ISREDIT\";\"MACRO (ADDPARM)\"\n /* --------CONTROL ASIS ----------*/\n/*  DESCRIPTION:   CHANGE ALL LOWERCASE TO UPPERCASE                 */\n/*  PURPOSE:       THE ANTITHESIS OF THE EDIT CLIST MACRO    @SMALLS */\n/*                 MOST TSO USERS WOULD USE THE PICTURE FORM         */\n/*                 OF THE CHANGE COMMAND THEMSELVES                  */\n/*                                                                   */\n/*   ALTHOUGH NOT USED/NEEDED IN THIS PROCEDURE, IF exec  REQUIRES   */\n/*     CAPITALS FOR A PARAMETER IT CAN OBTAIN THEM THUSLY:           */\n/*              --  PARM1 = TRANSLATE(PARM1)                         */\n/*  1985/09/17 created by David McRitchie, \"The REXX Macros Toolbox\" */\n/*  1994/06/01 converted to REXX and removed AUTOSAVE OFF.           */\n \"(MEMNAME) = MEMBER \"\n \"CHANGE ALL\" addparm \"P'<' P'>'\"\n CC = RC\n IF cc = 0 then do\n    IF ADDPARM \\= \"\" then do\n       ZEDSMSG = \"uppercased\" addparm\n       ZEDLMSG = \"Have converted range\" addparm \"from lower\",\n          \"to UPPER case\"\n       Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n       EXIT 0\n    END\n END\n if CC = 4 then do\n    ZEDSMSG = \"NOT LOWERCASE\" addparm\n    ZEDLMSG = \"no effect caused by -- \",\n          \"CHANGE ALL\" addparm \"P'<' P'>'\"\n    Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n    EXIT 0\n END\n /***** YOU MUST SAVE MEMBER AS NAME THAT YOU WANT*****/\n ZEDSMSG = \"rc=\"cc\" COMPLETED\"\n ZEDLMSG = \"member=\"MEMNAME\" changed by            CHANGE ALL\",\n        ADDPARM \"p'<' p'>' \"\n Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n /***** YOU MUST SAVE MEMBER AS NAME THAT YOU WANT*****/\n ZEDSMSG = \"rc=\"cc\" COMPLETED\"\n ZEDLMSG = \"member=\"MEMNAME\" changed by            CHANGE ALL\",\n        ADDPARM \"p'<' p'>' \"\n Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n \"LINE_BEFORE .ZFIRST = NOTELINE \"\"    \" ,\n \"=================================================================\"\"\"\n \"LINE_BEFORE .ZFIRST = NOTELINE \"\"    \" ,\n \"ALL  'lowercase'  have been changed to  'UPPERCASE'\"\"\"\n \"LINE_BEFORE .ZFIRST = NOTELINE \"\"    \" ,\n \"actually invoked       CHANGE ALL\" addparm \"p'<' p'>'\"\"\"\n \"LINE_BEFORE .ZFIRST = NOTELINE \"\"    \" ,\n  \".labels   X|NX    are also acceptable on the CHANGE command\"\"\"\n \"LINE_BEFORE .ZFIRST = NOTELINE \"\"    \" ,\n  \"================================================================\"\"\"\n \"LINE_BEFORE .ZFIRST = NOTELINE \"\"    \" ,\n \"The antithesis of @CAPS is @SMALLS, which does do more for you.\"\"\"\n \"LINE_BEFORE .ZFIRST = NOTELINE \"\"    \" ,\n \"================================================================\"\"\"\n \"LINE_BEFORE .ZFIRST = NOTELINE \"\"    \" ,\n \"You may now wish to invoke  'CAPS ON'                  \"\"\"\n \"LINE_BEFORE .ZFIRST = NOTELINE \"\"    \" ,\n \"==================================================================\"\"\"\n \"LINE_BEFORE .ZFIRST = NOTELINE \"\"    \"\"\"\n \"LOC 0              \"\n Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@COMPARE": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01\\x9d\\x01\\x9d\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 413, "newlines": 413, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX  -- @COMPARE maro to compare file in edit with another file --.\n  Author: David McRitchie, created 1989/02/24 is03\n          \"The REXX Macros Toolbox\",        DMcRitchie@aol.com\n  Macro:  is03.spf2.macro(@COMPARE)      -- CopyFile on MVS for OS/2\n          C:\\spfmacro\\@COMPARE.SPF macro -- Private copy on OS/2\n          is03.libr.clist(@COMPARE)      -- Development on TSO\n          -- no changes required from TSO to SPF/PC using OS/2 2.1\n            ...........................\n    Updated 1992/01/16 16:44 is03\n    REXX converted 1992/05/29 D.McRitchie from clist\n    Updated 1993/01/21 13:56 is03 -- utilize cursor\n    REXX rewritten 1994/04/29 D.McRitchie for TSO and SPF/PC\n      Rewritten to do either even though more coding used.\n      (Old Rexx version is @COMPold).\n Title:       @COMPARE text in edit with dsn(member)\n Users:       TSO ISPF edit users   | Script/VS users\n Contributed: 1988/02/24 David McRitchie \"The REXX Macros Toolbox\"\n\n ===> @COMPARE *         -- Compare workspace to current member/file\n                            cannot be use with another dataset.\n ===> @COMPARE **        -- Compare curr. member/file to file at CURSOR\n ===> @COMPARE           -- Compare curr. member/file to file at CURSOR\n\n ___SPF/PC implementation of @COMPARE\n ===> @COMPARE *             -- Compare active session to saved file\n ===> @COMPARE filename.ext  -- Compare current saved file to filename\n ===> @COMPARE filename.     -- Compare single node filename w/o .EXT\n ===> @COMPARE file.name.ext -- Compare to fully qualified filename\n ===> @COMPARE * R           -- Reverse NEW/OLD datasets\n\n ___TSO  implementation   of @COMPARE\n ===> @COMPARE sys1.tsoclist    -- TSO compare to member in dataset\n ===> @COMPARE data.set(member) -- TSO comparison to oldfile\n ===> @COMPARE 'data.set.name'  -- Compare curr. to a sequential file\n ===> @COMPARE member           -- Compare curr. to another member\n ===> @COMPARE (member)         -- Compare curr. to explicit member\n ===> @COMPARE CLIST            -- Compare curr. sys1.tsoclist\n ===> @COMPARE member R         -- Reverse NEW/OLD datasets\n ===> @COMPARE SYS6..           -- Old begins SYS6 rest like curr dsn\n\n   @COMPARE simplifies use of SuperC w/o PDF 3.11 SuperC panel\n     SuperC can be invoked  ===> TSO q superc\n     use listing type: delta    process options: seq | noseq\n\n  options:                     ( ---- for SuperC )\n      LISTING(OVSUM|DELTA|CHNG|LONG|NOLIST)\n      CTYPE(FILE|LINE|WORD|BYTE)\n      process(cmpcol 2:72)  limit compare to cols 2:72\n        seq noseq cobol anyc dpplcmt dpcbcmt\n             SEQ/NOSEQ will be created provided SYSIN() not presented\n             and seq or noseq is not already in PROCESS() options.\n      EDIT      override normal browse mode of results\n      PRINT     at ahcenter using vpsprint, forces edit option\n  other options:\n      R         reverse olddsn with newdsn for compare.\n*----------------------------------------------------------*/\n\naddress \"ISREDIT\";\n\"macro (file2)\"\n\"(DCHANGED) = DATA_CHANGED\"\ncall note time('N') \"@COMPARE\" file2\nif file2 = \"?\" /*help*/ | FILE2 = \"FILE2\" /*misuse, is not TSO*/ then\n   do; address \"TSO\" \"clist @compare help\";exit 1;end;\nParse version V1 V2 V3 V4 V5\n\n/* initializations for TSO comparison using SuperC ----------*/\nR=\"\"; call initTSO  /* mainly though R is valid for SPF/PC */\nfile2=strip(file2)\n\n\"(dataset) = dataset\"; dsname=dataset /*dsname is current TSO*/\n\"(member) = member\"\nif v1 = \"REXX370\" then do\n   if member \\= \"\" then dataset=dataset\"(\"strip(member)\")\"\n   i = pos('..',file2)\n   if i \\=0 then if memberx \\= \"\" then do\n       if substr(file2,I+2)='' then\n          file2 = substr(file2,1,i-1)||substr(dataset,i)\n       i=pos(')',file2)\n       if i = 0 then do\n          x=listdsi(\"'\"file2\"'\")\n          say file2 '--' memberx\n          if sysdsorg = \"PO\" then\n             file2 = file2||'('||strip(memberx,\"T\")||\")\"\n       end\n   end\nend\nnewfile=translate(strip(dataset))\n\nif file2 = '' | file2 = '**' | file2 = 'CURSOR' then do\n   /* obtain file2 at .zcsr*/\n   /* for a PDS must be complete name, * not valid spf/pc or TSO*/\n   file2 = ''\n   \"(LINE) = line .zcsr\"\n   \"(row,col) = cursor\"\n   if row=0 | col = 0 then do;\n      zedsmsg=\"CURSOR\";zedlmsg=\"Place CURSOR on filename\"\n      if v1=\"REXX370\" then\n           ZEDLMSG = \"dataset '\"oldx\"' --\" SYSDSN(\"'\"oldx\"'\"),\n           dsninfo0 dsninfo1\n      call msg0\n      exit 12\n   end\n   \"label .zcsr = .dsn 0\"\n   line=translate(line)\n   i=verify(substr(line,col),,\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.\\:_-@#$()''');\n   line = substr(line,1,col+i-2)\n   B =  col+i-2\n   do i= col+i-2  to 1 by -1\n     j = pos(substr(line,i,1),,\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.\\:_-@#$()'\")\n     if j=0 then leave;\n   end;\n   /* try to determine if it is the same file as one we are in*/\n   /* comparison not too good since dataset is fully qualified */\n   file2   = substr(line,i+1)\n   if file2='' then do;call note ' sorry, No Name at .ZCSR';exit 12;end\n   file2 = translate(file2)\nend        /*there will be more complete test for PC equivalents */\n\nif v1 = \"REXX370\" then do;  /* file2 in --> oldfile out */\n   if substr(file2,1,1) = \"'\" then parse var file2  \"'\"oldfile\"'\" /*'*/\n   else do\n     if file2 \\= '*' then\n        if substr(file2,length(file2),1) = ')' then oldfile=file2\n        else do\n          idot = pos('.',file2)\n          if idot = 0 then oldfile = dsname\"(\"file2\")\"\n                      else oldfile = file2\"(\"member\")\"\n       end\n   end\nend\n                            /* file2 in --> oldfile out, below*/\nif v1 = \"REXXSAA\" then do;  /* DOS, if no period use same .EXT*/\n  if file2 \\= '*' then do;\n    f2dot = pos('.',file2)\n    if length(file2)<9 then if  f2dot = 0 then do\n       l=length(dataset);\n       if substr(dataset,l-3,1)='.' then\n          file2=file2||substr(dataset,l-3)\n    end\n    /* use PATH to see if datasets compared really have same name*/\n    Call RxFuncAdd \"SysSearchPath\", \"REXXUTIL\", \"SysSearchPath\";\n    fspec = SysSearchPath('PATH', file2)\n    oldfile = fspec\n    if oldfile = \"\" then do\n      call note \" FSPEC from SysSearchPath was empty -- use file2\"\n      env=\"OS2ENVIRONMENT\"\n      call note \" Current Path =\" value('path',,env)\n      call note \" file2=\"file2\n      oldfile = file2\n    end\n  end\nend\nnewfile=translate(newfile)\noldfile=translate(oldfile)\nif newfile = oldfile then do\n  if dchanged = \"YES\" then do\n   call note \" \"file2\" is the old file entered on parm,\"\n   call note \"      comparison will be to the active session\"\n   call note \"      as if entered as   ===> @COMPARE *\"\n   file2 = '*';  /* so will use already programmed  usage*/\n  end\n  else do\n    ZEDSMSG = \"SAVED equal\";ZEDLMSG = \"Member\" member \"has been\",\n    \"saved (or is unchanged), can only compare as equal to itself,\",\n    \"in other words you goofed\";call msg0\n    call note \" If you wish to compare the unsaved workspace to\"\n    call note \"   the saved file use  ===> @COMPARE *\"\n    exit 1\n  end\nend\n\nif file2  \\= '*' then do;\n   If dchanged = \"YES\" then call NOTsaved /** may EXIT if not saved */\n   call COMPARE newfile oldfile\n   return rc\nend\n/* Asterisk -- we will compare changes in workspace to saved file */\nIF DCHANGED = \"NO\" THEN DO\n   ZEDSMSG = \"Saved Equal\"\n   ZEDLMSG  = \"No point to checking UNCHANGED dataset to itself\"\n   /*--- address is required below, but not permitted in SPF/PC */\n   call msg0      /* ISPEXEC MSG(ISRZ000) */\n   exit 0\nEND\n/* create temporary dataset from workspace */\nif v1 = \"REXX370\" then call TSOwork\nelse if v1 = \"REXXSAA\" then call PCwork\nelse do; call note \" error not REXX370 and not REXXSAA\";exit 12;end;\n\n/* compare workspace dataset as NEW to saved dataset as OLD */\ncall compare newfile oldfile\nreturn 0\n\nNOTE: parse arg arg; \"line_before .zf = noteline (arg)\"; return\n\nNOTsaved:\n    SAY '*************************************************************'\n    SAY '*     YOUR FILE HAS NOT BEEN SAVED AFTER MAKING CHANGES     *'\n    SAY '*                                                           *'\n    SAY '* CANNOT COMPARE UNLESS YOU SAVE -- Hit enter to terminate  *'\n    SAY '************************* -- OR -- **************************'\n    SAY ' REPLY <ENTER KEY> or type in \"CAN\" to terminate request'\n    SAY ' REPLY \"SAVE\"   | \"SAV\" to save then resume @COMPARE'\n    SAY ' REPLY \"CANCEL\" | \"CAN\" if you do not want to COMPARE',\n                'at this time'; SAY ' '\n    SAY ' You could have compared to workfile with ===> @COMPARE *'\n    pull PARM1;parm1 = translate(parm1)\n    if SUBSTR(PARM1,1,3) \\= \"SAV\" then do ;\n       call note \" \"time('n')\" @COMPARE terminated due to UNSAVED data\"\n       zedlmsg = \"Data Has not been SAVED -- NOT @COMPAREed\"\n       call msg0;Exit 1\n    end\n    \"SAVE\"\n    if rc > 1 then do\n      call note \" SAVE failed,  save file before invoking @COMPARE\"\n      exit 1\n    end\n    call note \" You chose to SAVE after @COMPARE was invoked\"\nreturn\n\nMSG0: /* SPF/PC invokes SETMSG in incorrectly */\n      if v1 = \"REXXSAA\"\n         then /*Address*/ \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n         else Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      \"UP max\"\n  return  0\n\nTSOwork:  /* create temporary file from TSO ISPF workspace */\n   call note \" @COMPARE -- You are in TSOwork\"\n   cutddsn = userid\".cutddsn.list\" /*userid preferred to prefix*/\n   test = SYSDSN(\"'\"cutddsn\"'\")\n   status = msg('on')\n   if test = \"OK\" then do\n     Address \"TSO\" ,\n      'ALLOC FI(CUTDDSN) old     SPACE(45 45) TRACKS UNIT(SYSDA)' ,\n        'LRECL(255) RECFM(V B M) BLKSIZE(3156)' ,\n         \"DSN('\"cutddsn\"') REUSE\"\n   end\n   else do\n     Address \"TSO\" ,\n      'ALLOC FI(CUTDDSN) NEW CAT SPACE(45 45) TRACKS UNIT(SYSDA)' ,\n        'LRECL(255) RECFM(V B M) BLKSIZE(3156)' ,\n        \"DSN('\"cutddsn\"') REUSE\"\n   end\n   \"(last)  = linenum .zlast\"; q.0 = last\n   do i = 1 to q.0\n      \"(line) = line\" i\n      q.i=line\n   end\n   status = msg('off')\n   Address \"TSO\" \"EXECIO * DISKW CUTDDSN (STEM Q. FINIS\"\n   address \"TSO\" \"FREE FILE(CUTDDSN)\"\n   /*if autoedit = 1 then address \"TSO\" \"$EDIT\" cutddsn */\n   oldfile=newfile\n   newfile=cutddsn\n   return\n\nPCwork:     /* create temporary file from SPF/PC workspace */\n   if v1 \\= \"REXXSAA\" then exit 16\n            /* md c:\\junk  -- if you do not have one already*/\n   filex = \"c:\\junk\\contrast.xxx\" /* approx. of a temporary file*/\n   address \"CMD\" \"del\" filex\n   \"(last)  = linenum .zlast\"\n   do i = 1 to last\n      \"(line) = line\" i\n      call lineout filex,line\n   end\n   call lineout filex\n   /*if autoedit = 1 then address \"CMD\" \"SPF2\" filex */\n   oldfile=newfile\n   newfile=filex\n   return\n\nInitTSO:\n \"(row,col) = cursor\";row=row+0;col=col+0\n dsninfo0=  \" as identified with cursor at (\"row\",\"col\"). \",\n            \"When no options are specified,\",\n            \"or the ** option is used, the cursor must be\",\n            \"placed at a valid member, dsn, or dsn(member). \"\n dsninfo1 =  \" Dataset options may be specified --- \",\n       \"Use * to compare workspace to actual saved data.  Use **\",\n       \"to compare workspace to dataset or member at cursor. \",\n       \"Use DSN to specify dataset later. \",\n       \"For other @COMPARE options see help information\",\n       \"  COMMAND ====> TSO clist @COMPARE help \",\n       \"       <hit ENTER to restore screen>\"\n r=\"\"; BROWSE=\"BROWSE\"; DSN=\"\"; PRINT=\"\"; macrox=\"\"\n file2=translate(\" \"file2\" \")\n i=pos(' R ',file2);\n if i\\=0 then do; R=\"R\"; file2=substr(file2,1,I)||substr(file2,i+3);end\n i=pos(' INX ',file2);\n if i\\=0 then do; INX='*'; macrox=\"MACRO(@COMPINX)\"; BROWSE=\"EDIT\";\n                  file2=substr(file2,1,I)||substr(file2,i+5);end\n i=pos(' PRINT ',file2);\n if i\\=0 then do; PRINT=\"PRINT\";\n                  file2=substr(file2,1,I)||substr(file2,i+7);end\n if v1 = \"REXXSAA\" then return  /* rest only for SuperC under TSO */\n userid = strip(SYSVAR('SYSUID'))\n prefix = strip(sysvar(syspref)); if prefix='' then prefix=userid\n\n Parse var file2 file2 \" LIST(\" list \") \" remain\n file2=file2 remain\n parse var file2 file2 \" CTYPE(\" ctype \") \" remain\n file2=file2 remain\n parse var file2 file2 \" PROCESS(\" process \")\" remain\n file2=file2 remain\n i=pos(' ANYC ',file2);\n if i\\=0 then do; process = \"ANYC\" process;\n                  file2=substr(file2,1,I)||substr(file2,i+6);end\n parse var file2 file2 \" SYSIN(\" sysin \")\" remain\n file2=file2 remain\n \"(NUMBER) = NUMBER\"\n if process = \"\" then if sysin = \"\" then do;\n    IF substr(number,1,2) = \"ON\" then process = \"SEQ\" process;\n                                 else PROCESS=\"NOSEQ\" process;\n end;\n file2=file2 remain\n i=pos(' EDIT ',file2);\n if i\\=0 then\n    do; browse=\"EDIT\"; file2=substr(file2,1,I)||substr(file2,i+6);end;\n file2=strip(file2)\n if file2 = \"CLIST\" then file2 = \"SYS1.TSOCLIST\"\n else if file2 = \"DSN\" then do /* prompt for dsname*/\n    say \"For DSN what value would you like to use?\"\n    pull file2;\n end\n else if file2 = \"*PASTE*\" then file2 = userid\".CUTDSN.LIST\"\n else if file2 = \"CMD\"     then file2 = \"IS03.PC.CMD\"\n else if file2 = \"CLIST\"   then file2 = \"SYS1.TSOCLIST\"\n else if file2 = \"EMERG\"   then file2 = \"EMERG.LIBR.CNTL\"\n else if file2 = \"PROC\"    then file2=\"SYS1.USERPROC\"\n else if file2 = \"PROD01\"  then file2=\"TSOPROD.PROD01.CNTL\"\n else if file2 = \"SPF2\"    then file2=\"is03.spf2.macros\"\n i=words(file2)\n if i > 1 then do;\n   file2 = strip(file2)\n   i = pos(' ',file2)\n   remain = substr(file2,I+1)\n   file2 = substr(file2,1,I-1)\n   call note \"Remaining will be entered--\" remain\n end  /* next line provides for a member named CLIST or PROC */\n if substr(file2,1,1) = \"(\" then parse var file2 \"(\"file2\")\"\n return\nCOMPARE:    /* compare  newfile  to oldfile */\n   arg newfile oldfile\n   if r=\"R\" then do; x=oldfile; oldfile=newfile; newfile=x; end;\n   call note \" NewFile=\"newfile\", OldFile=\"oldfile\n   if v1 = \"REXXSAA\" then do\n      call note \" GFC -- Graphical File Compare\"\n      call note \" GFC\" newfile oldfile\n      if newfile=\"OLDFILE\" | newfile =\"NEWFILE\",\n       | oldfile=\"OLDFILE\" | oldfile =\"NEWFILE\" then do\n        call note 'BIG trouble in River City -- You''re all '||\n            \"washed up in this town, Mister\"\n        env=\"OS2ENVIRONMENT\"\n        call note \" Current Path =\" value('path',,env)\n        call note \" file2=\"file2\n        exit 1\n      end\n      address \"CMD\" \"GFC\" newfile oldfile\n      return\n   end;\n   else call note \" Options: list(DELTA|chng|long)\",\n          \"ctype(LINE|word|byte) PROCESS(seq|noseq)\"\n   /* TSO comparison using SuperC ------------------------*/\n   if ctype=\"\" then ctype=\"LINE\"\n   if process\\=\"\" then process=\"process(\"strip(process)\")\"\n   if sysin \\= \"\" then sysin=\"SYSIN(\"sysin\")\"\n   listing=list; if listing=\"\" then listing=\"DELTA\"\n   x = sysdsn(\"'\"oldfile\"'\")\n   if x = \"OK\" then do\n      Address \"TSO\" \"%SUPERC NEWFILE('\"newfile\"')\",\n         \"OLDFILE('\"oldfile\"')\" BROWSE \"ctype(\"ctype\")\",\n         \"listing(\"listing\")\" process sysin macrox remain\n      rcx = rc\n      call note \" SuperC:  \"process sysin macrox remain\n      if rcx  = 1 then if INX = \"*\" then do\n        address \"ISPEXEC\" \"EDIT dataset('\"prefix\".SUPERC.LIST')\",\n            \"MACRO(@COMPINX)\"\n        Address \"TSO\" \"COPY SUPERC.LIST libr.clist(ZCOMPX99) NONUM\"\n        ZEDSMSG = \"ready for %ZCOMPX99\"\n        ZEDLMSG = 'ZCOMPX99 is in your LIBR.CLIST and ready to use'\n        call note \" \"zedlmsg\n        call msg0\n        return 1\n      end\n   end\n   else do;call note \" Sorry --\" oldfile \"--\" x;\n           zedsmsg=\"DSN?\"\n           zedlmsg=\"Sorry --\" oldfile \"--\" x; call msg0\n           \"up max\";exit 0\n        end;\n return rc\n\n/* The coding of @COMPARE has been tested on SPF/PC and on TSO.  Our\n   version of the %SUPERC clist includes a BROWSE/EDIT option and\n   therefore differs slightly from the orginal example %SUPERC clist\n   formerly installed into SYS1.SAMPLIB(ISRSCLST) which is now\n   installed into SYS1.ISPFPDF.ISRSAMP(ISRSCLST).  */\n\n/*********************************************************************/\n/* In SPF/PC 3.0 SuperC is not available so GFC was used             */\n/* If SPF/PC 4.0 provides SuperC, then this macro possibly can be    */\n/*  changed to use SuperC in place of the Graphical File Compare(GFC)*/\n/* Comparison is done using the GRAPHICAL FILE COMPARE (GFC) program */\n/*  from IBM.  It supercedes a previous ESDTOOLS program named       */\n/*  CONTRAST that had been made available on IBM bulletin boards.    */\n/* -Yellow -- FileA -- current (NEW) file,   (workspace,  if * used) */\n/* -Red    -- FileB -- specified (OLD) file, (saved file, if * used) */\n/* Invocation of GFC is as follows:  GFC <fileA fileB>               */\n/*********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@DATE": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00k\\x00k\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 107, "newlines": 107, "modlines": 0, "user": "MCRITCH"}, "text": "/* rexx:  @DATE yy/mm/dd | yyddd                                     */\n/*  Converted to REXX from own @DATE clist 1993/06/07 David McRitchie*/\n/*  @DATE  created 1986/07/09 David McRitchie                        */\n/*   updated for year 2000 using obtained coding, 1997/05/12 D.McR   */\nAddress \"ISREDIT\";\"MACRO\"\njdate=\"\"; gdate=\"\";\narg xdate test\nxdatex = xdate\nif xdate=\"\" |  xdate=\"*\" then xdate=date('s');\nL = length(xdate)\np = pos(\"/\",xdate)\nif p > 0 then do\n   xdate = left(xdate,p - 1)||right(xdate,p + 1)\n   p = pos(\"/\",xdate); pm1 = p - 1; pp1 = P + 1;\n   if pos <> 0 then xdate = left(xdate,pm1)||right(xdate,pp1)\n   L = length(xdate)\nend\nif datatype(xdate,\"n\") = 0 then signal errx\nif L = 5 | L = 6 then\n   if left(xdate,2) < '70' then xdate=\"20\"xdate; else xdate=\"19\"xdate\nL = length(xdate)\nif l = 8 then do; call convert1 xdate; signal reporting; end;\nif l = 7 then do; call convert2 xdate; signal reporting; end;\nerrx:\nzedlmsg = \"@DATEW:\" xdatex \" is invalid, expect YYYYMMDD or YYYYNNN\"\n/*adDRESS*/ \"ISPEXEC\"   \"SETMSG MSG(ISRZ001)\"\nreturn 4\nreporting:\n   zedsmsg = gdate jdate day_of_week\n   zedlmsg = day_of_week gdate jdate\", the time now is\" time('n')\n   if test \\= \"\" then \"line_before .zfirst = noteline (zedlmsg)\"\n/*adDRESS*/ \"ISPEXEC\"   \"SETMSG MSG(ISRZ001)\"\nreturn 0\n\n/*********************************************************************/\n/* Coding implementation obtained from internet with better algorithm*/\n/*    indicated as verified correct 15 Oct 1582 thru  31 Dec 9999.   */\n/*********************************************************************/\n\nCONVERT1:\n/* REXX exec CONVERT1\n   Converts \"YYYYMMDD\" into (1) Julian date \"YYYYNNN\" (NNN is 001-366)\n                        and (2) day-of-week.\n   (1): Algorithm 398 in the Oct 1970 Communication of the ACM,\n        by Richard A. Stone.\n   (2): added by Harold Zbiegien.\n*/\narg YYYY +4 MM +2 DD\nif YYYY //   4 = 0 then LY = 1 ; else LY = 0\nif YYYY // 100 = 0 then LY = 0\nif YYYY // 400 = 0 then LY = 1        /* LY is 1 if it is a leap year\n*/\nNNN = TRUNC(((MM + 2) * 3055) / 100) + DD - 91\nif NNN > (59 + LY) then NNN = NNN - 2 + LY\nNNN = RIGHT(NNN,3,0)\nT = TRUNC(YYYY / 100) - 6 - TRUNC(YYYY / 400)\nDOW = (NNN + TRUNC((YYYY * 5) / 4) - LY - T) // 7\n                             /* DOW is 0-6, 0=Sunday, 1=Monday, etc.)\n*/\narray = 'Sun Mon Tues Wed Thurs Fri Sat'\nday_of_week = WORD(array,DOW+1)\nmm = right(mm,2,\"0\")\ndd = right(dd,2,\"0\")\nnnn = right(nnn,3,\"0\")\ngdate = YYYY\"/\"MM\"/\"DD\njdate = yyyy\"/\"nnn\n/*day_of_week*/\nsignal reporting\n\n\nconvert2:\n/*********************************************************************/\n/*    REXX exec CONVERT2                                             */\n/*    Converts Julian date \"YYYYNNN\" into (1) \"YYYYMMDD\"             */\n/*                                    and (2) day-of-week.           */\n/*    This is a reversal of routine CONVERT1, worked out by Harold   */\n/* Zbiegien                                                          */\n/*********************************************************************/\nyyyy = substr(xdate,1,4); nnn = right(xdate,3)\narg YYYY +4 NNN\nif YYYY //   4 = 0 then LY = 1 ; else LY = 0\nif YYYY // 100 = 0 then LY = 0\nif YYYY // 400 = 0 then LY = 1        /* LY is 1 if it is a leap year\n*/\nWORK = NNN\nif WORK > (59 + LY) then WORK = WORK + 2 - LY\nMM = TRUNC(((WORK + 91) * 100) / 3055)\nDD = (WORK + 91) - TRUNC((MM * 3055) / 100)\nDD = RIGHT(DD,2,0)\nMM = MM - 2\nMM = RIGHT(MM,2,0)\nT = TRUNC(YYYY / 100) - 6 - TRUNC(YYYY / 400)\nDOW = (NNN + TRUNC((YYYY * 5) / 4) - LY - T) // 7\n            /* DOW is 0-6, 0=Sunday, 1=Monday, etc.)*/\narray = 'Sun Mon Tues Wed Thurs Fri Sat'\nday_of_week = WORD(array,DOW+1)\nmm = right(mm,2,\"0\")\ndd = right(dd,2,\"0\")\nnnn = right(nnn,3,\"0\")\njdate = yyyy||nnn\ngdate = yyyy||mm||dd\n/* day_of_week*/\nsignal reporting\n\n/* @DATE: in \"The REXX Macros Toolbox\" is located 1995/05/12    */\n/* at http://members.aol.com/dmcritchie/nclist.htm              */\n/* should be indexed in AltaVista if it moves.  David McRitchie */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@DATEXX": {"ttr": 1796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x1d\\x00\\x1d\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "MCRITCH"}, "text": "/*REXX:  @DATE YY/MM/DD | YYDDD   */\n/* CONVERTED TO REXX FROM OWN @DATE CLIST 1993/06/07 DAVID MCRITCHIE */\n/* @DATE  CREATED 1986/07/09 DAVID MCRITCHIE */\nADDRESS \"ISREDIT\";\"MACRO (XDATE TEST)\"\nIF XDATE = \"\" | XDATE = \"*\" THEN XDATE = \"*\"\nPTIME = TIME()\nADDRESS \"TSO\" \"%SHOWDATE\" XDATE \"NOWRITE\"\nCC = RC\nIF CC = 0 THEN DO\n   ADDRESS \"ISPEXEC\" \"VGET (JDATE,GDATE,SDATE,WDATE)\"\n   /* IN OS/2 USE  PULL JDATE; PULL GDATE; PULL SDATE; PULL WDATE;*/\n   ZEDSMSG = GDATE JDATE WDATE\n   IF XDATE  = '*'\n      THEN ZEDLMSG = GDATE   JDATE   SDATE  '--  TODAY IS',\n             WDATE  SUBSTR(SDATE,3,3) SUBSTR(SDATE,1,2)\",\",\n             \"19\"||SUBSTR(SDATE,6,2) \"AND THE TIME IS\" PTIME\n      ELSE ZEDLMSG = PTIME \"ENTERED AS  @DATE\" GDATE  \"|\",\n              JDATE \"|\" SDATE\" -- A\" WDATE\n   ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   IF TEST = \"TEST\" THEN\n      \"LINE_BEFORE .ZLAST  = NOTELINE \"\"\"JDATE,\n                  GDATE SDATE WDATE  \"-- @DATE\" XDATE \"--\" PTIME\"\"\"\"\n   EXIT 0\nEND\nZEDSMSG = \"--ERROR--\"\nZEDLMSG = \"@DATE\" XDATE \"  - INVALID ARGUMENT  RC=\"CC||,\n     \", NEED MMDDD OR YYMMDD OR DDMMMYY\"\nADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\nEXIT CC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@DIR": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x04\\x1a\\x04\\x1a\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 1050, "newlines": 1050, "modlines": 0, "user": "MCRITCH"}, "text": "           CONTROL ASIS\n    /* PURPOSE: SHOW DIRECTORY NAMES FOR EVERY MEMBER OF THE PDS\n    /*          BEGIN EDITED, OR IF NO DSNAME INCLUDED, FOR DSN IF IT\n    /*                                               IS\n    /* CONTRIBUTED:   F. DAVID MCRITCHIE             1985/12/04 (AHC)\n    /* USER CONTACT:  F. DAVID MCRITCHIE\n    /* CODE MAINT.:   SYSTECH GROUP\n    /* ASSOCIATED CLISTS:  @DIREDIT,  @DIRPARM\n    /**************************************************************\n    /* DOCUMENTED  IS03.SHARE.TEXT(@DIR)\n    /* EXAMPLES:   ==> @DIR                 DEFAULT IS LIBRARY IN EDIT\n    /*             ==> @DIR IS03.SHARE.CNTL\n    /*             ==> @DIR IS03.SHARE.TEXT 1986/01/01 UPDATED ON/AFTER\n    /**************************************************************\n    /* ADDING DIRECTORY ENTRIES TO END OF MEMBER IN EDIT\n    /*             ==> @DIR LISTMEM\n    /****************************************************************\n    /* IF THIS MACRO CLIST TERMINATES DUE TO STRANGE MEMBERNAMES  ***\n    /*   LIKE \") FCCARQ\" YOU MAY TRY USING A BATCH JOB INSTEAD    ***\n    /*      //  EXEC DIRLIST,SYSOUT=V,LIB='IMSVS.FORMAT'          ***\n    /****************************************************************\n    /*  DSN   <DSNAME>    CAN BE PROVIDED WITH OR WITHOUT QUOTES\n    /*                    -- WILL NOT PREFIX THE USERID TO THE DSNAME.\n    /*        (OMITTED)   DISPLAY OF MEMBERS IN LIBRARY CURR. IN ISPF\n    /*                    EDIT\n    /*  USER  (OMITTED)   DISPLAY ALL MEMBERS IN LIBRARY\n    /*        <USERID>    DISPLAY ONLY MEMBERS UPDATED BY THIS USERID\n    /*         *          DISPLAY ALL MEMBERS AND UPDATING USERID\n    /*  INDEX()  SELECTION CRITERIA BASED ON FINDING STRING WITHIN\n    /*  MASK()   SAME AS USED BY PGM=IZ2019\n    /*    A-Z 0-9   MUST BE AN EXACT MATCH TO CORRESPONDING POSITION\n    /*              OF MEMBERNAME\n    /*    *         MUST BE BLANK  IN CORRESPONDING POSITION OF\n    /*              OF MEMBERNAME\n    /*    %         MUST BE ALPHA  IN CORRESPONDING POSITION OF\n    /*              OF MEMBERNAME\n    /*              MUST BE 0-9 (NUMERIC DIGIT)  IN CORRESPONDING\n    /*              POSITION OF MEMBERNAME\n    /*    -         IGNORE CHECKING\n    /*    (BLANK)   IGNORE CHECKING\n    /*  ONAFTER 1986/01/01 RESTRICT DISPLAY TO UPDATED ON/AFTER 1986/01/01\n    /*  LISTMEM           ADD SELECTED MEMBER LINES TO END OF MEMBER\n    /*              IN EDIT\n    /*                    AUTOMATIC WITH  ALIGN,$BUILD$, OR $BUILD$T\n    /*  BEGIN()           LISTMEM  DIRECTORY STRING PREFIXED BY CONTENT\n    /*  COL()             IF MEMBERNAME ALREADY EXISTS IN THE CURRENT\n    /*             MEMBER, IN THIS\n    /*                    COLUMN THEN DIRECTORY STRING NOT APPENDED\n    /*                    TO MEMBER.\n    /*  RECS(RR)          COLUMN THAT NUMBER OF RECORDS WILL GO INTO\n    /*                    IF COL(NN) HITS\n    /*                    REQUIRES SIX BLANK COL AT COL RR, LAST\n    /*                    COLUMN REMAINS BLANK\n    /*  FOUND(FF)         REQUIRES ONE BLANK COL AT COL FF, WILL\n    /*                    RECEIVE \"*\" IF FOUND  -- DEFAULT AST(*)\n    /*  ALIGN             CREATES/MODIFIES BEGIN() SO THAT RESULT\n    /*                    MATCHES COL() CHOICE\n    /*  FROM1:TO2         LIMIT SELECTIONS TO MEMBERS NAMED FROM1 THRU\n    /*                    TO2.   SEE ALSO FROM() AND TO().\n    /*  FROM1:            *INVALID*, USE FROM1:Z, OR USE MASK(FROM1)\n    /*  FROM()            LIMIT SELECTIONS TO MEMBERS NAMED FROM(XXX)\n    /*                    OR LATER\n    /*  TO()              LIMIT SELECTIONS TO MEMBERS NAMED   TO(XXX)\n    /*                    OR EARLIER.   ALSO SEE FORM  FROM:TO\n    /*  LIST              SAME AS LIST(1), SELECT FROM PRE-SORTED\n    /*                    LIST AT COLUMN 1\n    /*  LIST()            MEMBER IN EDIT SHOULD BE A PRE-SORTED LIST\n    /*                    OF MEMBERS\n    /*                    WANTED AND WHOSE MEMBER NAMES BEGIN IN\n    /*                    COLUMN  LIST(NN).\n    /*  FIND()            SELECTION MUST BE AMONG MEMBERS LISTED IN\n    /*                    COLUMN FIND(NN).  MUST BE FOUND AS A WORD.\n    /*                    SLOWER THAN LIST() OPTION BUT MAY BE EASIER\n    /*                TO USE.\n    /*  FINDMEM()         SELECTION MUST BE AMONG MEMBERS LISTED IN\n    /*                    COLUMN FIND(NN).  MAY GET A HIT IF MEMBERNAME\n    /*                    LISTED IS LONGER THAN ACTUAL MEMBERNAME.\n    /*                TO USE.\n    /*  TEXT          USED WITH FIND() -- TEXT OF LINE STORED AS    */\n    /*                @DIRTEXT FOR USE OF MACRO().                  */\n    /*  IMAC          USE IF @DIR WILL BE AN INITIAL MACRO --DWIDTH*/\n    /*  NUSER(XXX)    REASSIGN SELECTED MEMBER(S) TO A NEW USERID.\n    /*  $NDU          UPDATE LINE_AFTER WITH @DIRNOTE FROM MACRO,X-*/\n    /*  NDU           DO NOT UPDATE DATES, USE X-USERID FOR USERID\n    /*  STET          DO NOT UPDATE DATES, OR USERID\n    /*   FIND()        SELECTION MUST NOT BE AMONG MEMBERS LISTED IN\n    /*                    COLUMN XFIND(NN).  WORD SEARCH IS USED.\n    /*                FINDMEM(), XFIND(), FIND() ARE MUTUALY EXCLUS.\n    /*  L8            FORCE $NAME$ SUBSTITUTIONS TO THE FULL 8 CHARACTERS\n    /*                OF THE PDS MEMBERNAME.\n    /*  PATTERN(XXX)  COPY INDICATED PATTERN AFTER LAST CARD, THEN\n    /*                  CHANGE $NAME$ TO MEMBERNAME ON THE ADDED CARDS.\n    /*  DOITMAC()         -OBSOLETE USE MACRO()-- INVOKE AN EDIT\n    /*                CLIST FOR EACH SELECTED MEMBER\n    /*  CMD(COPYAFT)  COPY SELECTED MEMBER AFTER .ZLAST\n    /*  MACRO()           INVOKE AN EDIT CLIST FOR EACH SELECTED MEMBER\n    /*  NX                RESTRICT COL() FOUND TO NX LINES\n    /*  SPECIAL           AFTER INITIAL PREFIX \"&MEMBER.:^^\" FOR\n    /*                IS03.SHARE.CNTL(@INDEX)\n    /*  $BUILD$           USE ZLMDATE ZLMTIME ZLUSER\n    /*                ZLCNORC    AFTER MEMBERNAME\n    /*  $BUILD$80         USE ZLMDATE ZLMTIME ZLUSER ZLCNORC\n    /*                ....ZLUSER.... ZLUSER AFTER MEMBERNAME\n    /*  $BUILD$T          USE ZLMDATE ZLMTIME ZLUSER ZLCNORC ZLUSER\n    /*                ....... ZLUSER AFTER MEMBERNAME\n    /*  ..DEFAULT..       MEMBER   VV.MM LCDATE   LMDATE  MTIME\n    /*                LCNORC LINORC LMNORC LUSER\n    /*  ..DEFAULT..       AFIXNC78 01.02 1985/12/27 1985/12/27 17:32\n    /*                24 23 0 IS03....\n    /*****************************************************************\n    /** NO CHANGES TO MEMBER IN EDIT -- REASON THIS IS AN EDIT MACRO\n    /**   IS SO THAT THE DATAID CAN BE OBTAINED\n    /**     -- SO THAT DSNAME NEED NOT BE SPECIFIED.\n    /*****************************************************************\n ISREDIT   MACRO (TOK1,TOK2,TOK3,TOK4,TOK5,TOK6,TOK7,TOK8,TOK9,TOK10,+\n         TOK11,TOK12,TOK13,TOK14,TOK15,TOK16,TOK17,TOK18,TOK19,TOK20,+\n         TOK21,TOK22,TOK23,TOK24,TOK25,TOK26,TOK27,TOK28,TOK29,TOK30,+\n         TOK31,TOK32,TOK33,TOK34,TOK35,TOK36,TOK37,TOK38,TOK39,TOK40,+\n         TOK41,TOK42,TOK43,TOK44,TOK45,TOK46,TOK47,TOK48)\n       SET AST = &STR(*)\n       SET B40 = &STR(                                        )\n       SET B40     = &STR(                                        )\n       SET BLANK80 = &STR(&B40.&B40.)\n       SET USERLIST = &STR()\n       SET NEGU = 0\n       SET MASKMAX = 0\n       SET U = 0\n       SET I = 1\n       ISREDIT (DMEMBER) = MEMBER\n       ISPEXEC VGET (@DIRPARM) SHARED\n       SET @DIRSAVE = &STR(&@DIRPARM)\n      DO WHILE &I <= 48\n       SET TOKEN = &&TOK&I\n       SET TOKEN = &STR(&SYSCAPS(&TOKEN))\n       SET ARGSL = &STR(&ARGS.)\n       SET ARGS  = &STR(&ARGS. &TOKEN.)\n       IF &STR(&TOKEN) = &STR() THEN GOTO END_TOK\n /*       SET JUNK = &SUBSTR(3,&STR(&TOKEN)     )\n       IF DSN = &STR(&TOKEN) THEN DO\n          WRITE SUPPLY FULLY QUALIFIED DATASET NAME WITHOUT QUOTES\n          READ DSN\n          IF &STR() = &DSN. THEN EXIT CODE(12)\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(3,&STR(&TOKEN       )) = &STR(/) THEN DO\n          IF &STR(&ONAFTER) = &STR() THEN DO\n             SET ONAFTER = &STR(&TOKEN)\n             GOTO NXT_TOK\n          END\n          IF &STR(&TODATE) = &STR() THEN DO\n             SET TODATE = &STR(&TOKEN)\n             GOTO NXT_TOK\n          END\n          SET &ZEDSMSG = &STR(3RD DATE????)\n          SET &ZEDLMSG = &STR(CAN'T HANDLE \"&TOKEN.\" IN CONTEXT OF +\n            \"&ONAFTER.\" THRU \"&TODATE.\")\n          ISPEXEC     SETMSG MSG(ISRZ000)\n          EXIT CODE(12)\n       END\n       SET J = 1\n       DO WHILE &J <= 11\n          IF &SUBSTR(&J,&STR(&TOKEN.)             ) = &STR(.)  OR +\n            &SUBSTR(&J,&STR(&TOKEN.)             ) = &STR(') THEN DO\n                SET DSN = &TOKEN\n                SET ARG = &STR(&ARGL.)\n                GOTO NXT_TOK\n          END\n          SET J = &J + 1\n       END\n       IF &STR(&TOKEN) = HELP    THEN DO\n          SET HELP = &STR(&TOKEN)\n          GOTO NXT_TOK\n       END\n       IF &STR(&TOKEN) = TEXT    THEN DO\n          SET TEXT = &STR(&TOKEN)\n          GOTO NXT_TOK\n       END\n       IF &STR(&TOKEN) = LIB     THEN DO\n          SET LIB = &STR(&TOKEN)\n          GOTO NXT_TOK\n       END\n       IF &STR(&TOKEN) = IMAC    THEN DO\n          SET IMAC = &STR(&TOKEN)\n          GOTO NXT_TOK\n       END\n       IF &STR(&TOKEN) = L8      THEN DO\n          SET L8   = &STR(&TOKEN)\n          GOTO NXT_TOK\n       END\n       IF &STR(&TOKEN) = NX      THEN DO\n          SET NX   = &STR(&TOKEN)\n          GOTO NXT_TOK\n       END\n       IF &STR(&TOKEN) = NDU     THEN DO\n          SET NDU  = &STR(&TOKEN)\n          GOTO NXT_TOK\n       END\n       IF &STR(&TOKEN) = STET    THEN DO\n          SET NDU  = NDU\n          SET STET = STET\n          GOTO NXT_TOK\n       END\n       IF &STR(&TOKEN) = $NDU     THEN DO\n          SET NDU  = NDU\n          SET $NDU  = $NDU    /* SORT OF A LISTMEM OPTION */\n          GOTO NXT_TOK\n       END\n       IF &STR(&TOKEN) = $BUILD$ | &STR(&TOKEN) = $BUILD$80 | +\n         &STR(&TOKEN) = $BUILD$T THEN DO\n          SET $BUILD$ = &STR(&TOKEN)\n          IF  $BUILD$80 = &STR(&TOKEN) THEN DO\n             SET $BUILD$ = $BUILD$T\n             SET $BUILD$80 = $BUILD$80\n          END\n          SET LISTMEM = LISTMEM         /* IMPLIED */\n          GOTO NXT_TOK\n       END\n       /************* FROM(MEMBER1) TO(MEMBER2) INDEX(STRING)  ***/\n       SET LP = &STR((\n       SET RP = &STR())\n       SET T1 = &SYSINDEX(&STR(:),&NRSTR(&TOKEN.)\n       IF &T1 > 1 THEN DO\n          SET FROM = &SUBSTR(1:&EVAL(&T1.-1),&STR(&TOKEN.))\n          SET TO = &SUBSTR(&EVAL(&T1.+1):&LENGTH(&STR(&TOKEN.)),+\n            &STR(&TOKEN.))\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:6,&STR(&TOKEN)     ) = &STR(INDEX&STR(&LP)) +\n       THEN DO\n          SET INDEX = &SUBSTR(7:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN.)          )\n          SET T1 = &SYSINDEX(&STR(-),&NRSTR(&INDEX.))\n          IF &T1 > 1  THEN DO\n             SET INDEX = &SUBSTR(1:&EVAL(&T1.-1),&STR(&INDEX.))\n             SET INDEX = &NRSTR(&INDEX. )\n          END\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:5,&STR(&TOKEN)     ) = &STR(FROM&STR(&LP)) THEN DO\n          SET FROM = &SUBSTR(6:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:3,&STR(&TOKEN)     ) = &STR(TO&STR(&LP))  THEN DO\n          SET TO   = &SUBSTR(4:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:6,&STR(&TOKEN)       ) = &STR(BEGIN&STR(&LP))  +\n         THEN DO\n          SET BEGIN = &SUBSTR(7:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:4,&STR(&TOKEN)     ) = &STR(COL&STR(&LP))  THEN DO\n          SET COL   = &SUBSTR(5:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          SET COL   = &EVAL(&COL)\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:4,&STR(&TOKEN)     ) = &STR(AST&STR(&LP))  THEN DO\n          SET AST   = &SUBSTR(5:5,&STR(&TOKEN)         )\n          /* DO NOT USE AS A PATTERN BECAUSE ONLY ONE COLUMN IS USED*/\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:5,&STR(&TOKEN)     ) = &STR(RECS&STR(&LP))  THEN DO\n          SET RECS  = &SUBSTR(6:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          SET RECS  = &EVAL(&RECS)\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:5,&STR(&TOKEN)     ) = &STR(MASK&STR(&LP))  THEN DO\n          /*  MUST USE   MASK(--A)  AS  MASK(  A)  WILL NOT WORK   */\n          SET MASKMAX = &MASKMAX + 1\n          SET MASK  = &SUBSTR(6:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          SET MASK  = &SUBSTR(1:8,&STR(&MASK.           )\n          SET MASK&MASKMAX = &STR(&MASK.)\n          GOTO NXT_TOK\n       END\n       /* ----- BEGIN -- LIST(NN) 1987/06/01\n       IF &STR(&TOKEN) = LIST THEN SET TOKEN = LIST(1)\n       IF &SUBSTR(1:5,&STR(&TOKEN)     ) = &STR(LIST&STR(&LP))  THEN DO\n          SET LISTP = &SUBSTR(6:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          SET LISTP = &LISTP + 0\n          SET LISTP2 = &LISTP + 7\n          ISREDIT (LISTLAST) = LINENUM .ZLAST\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:5,&STR(&TOKEN)     ) = &STR(FIND&STR(&LP))  THEN DO\n          SET FINDP = &SUBSTR(6:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          ISREDIT LABEL .ZLAST = .FINDPL\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:6,&STR(&TOKEN)     ) = &STR(NUSER&STR(&LP)) THEN DO\n          SET NUSER = &SUBSTR(7:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          SET NUSER = &SUBSTR(1:7,&STR(&NUSER.         )\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:8,&STR(&TOKEN)        ) = +\n         &STR(FINDMEM&STR(&LP))  THEN DO\n          SET FINDP = &SUBSTR(9:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          SET FINDMEM = &FINDP.\n          ISREDIT LABEL .ZLAST = .FINDPL\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:6,&STR(&TOKEN)     ) = &STR(XFIND&STR(&LP)) THEN DO\n          SET FINDP = &SUBSTR(7:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          SET FINDMEM = &FINDP.\n          SET XFIND   = &FINDP.\n          ISREDIT LABEL .ZLAST = .FINDPL\n          GOTO NXT_TOK\n       END\n       /* ----- END ---- LIST(NN) 1987/06/01\n       IF &STR(&TOKEN) = LISTMEM THEN DO\n          SET LISTMEM = LISTMEM\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:5,&STR(&TOKEN.)        ) = &STR(VPUT&STR(&LP))  +\n         THEN DO\n          SET @DIRVPUT     = &SUBSTR(7:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          ISPEXEC VPUT (@DIRVPUT) SHARED\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:6,&STR(&TOKEN)        ) = &STR(FOUND&STR(&LP))  +\n         THEN DO\n          SET FOUND    = &SUBSTR(7:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:6,&STR(&TOKEN)        ) = &STR(MACRO&STR(&LP))  +\n         THEN DO\n          SET DOITMAC  = &SUBSTR(7:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          SET @DIRPARM = &DOITMAC\n          ISPEXEC VPUT (@DIRPARM) SHARED\n          IF &DOITMAC = @DIREDIT THEN SET SUPPRESS = SUPPRESS\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:6,&STR(&TOKEN)        ) = &STR(PANEL&STR(&LP))  +\n         THEN DO\n          SET PANEL = &TOKEN.\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:8,&STR(&TOKEN)        ) = &STR(PROFILE&STR(&LP))  +\n         THEN DO\n          SET PROFILE = &TOKEN.\n          GOTO NXT_TOK\n       END\n       /* DOITMAC() STILL INCLUDED BECAUSE WAS DOCUMENTED OTHERWISE +\n         SINCE 1986/05/23 MACRO() IS AVAILABLE\n       IF &SUBSTR(1:8,&STR(&TOKEN)        ) = &STR(DOITMAC&STR(&LP))  +\n         THEN DO\n          SET DOITMAC  = &SUBSTR(9:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          SET @DIRPARM = &DOITMAC\n          ISPEXEC VPUT (@DIRPARM) SHARED\n          IF &DOITMAC = @DIREDIT THEN SET SUPPRESS = SUPPRESS\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:8,&STR(&TOKEN)        ) = &STR(PATTERN&STR(&LP))  +\n         THEN DO\n          SET PATTERN  = &SUBSTR(9:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:7,&STR(&TOKEN)        ) = &STR(CMDAFT&STR(&LP))  +\n         THEN DO\n          SET CMDAFT  = &SUBSTR(8:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:4,&STR(&TOKEN)        ) = &STR(CMD&STR(&LP))  +\n         THEN DO\n          SET CMD  = &SUBSTR(5:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          GOTO NXT_TOK\n       END\n       IF EDIT = &STR(&TOKEN) THEN DO\n          SET DOITMAC  = @DIREDIT\n          SET @DIRPARM = &DOITMAC\n          ISPEXEC VPUT (@DIRPARM) SHARED\n          IF &DOITMAC = @DIREDIT THEN SET SUPPRESS = SUPPRESS\n          GOTO NXT_TOK\n       END\n       IF &STR(&TOKEN) = BROWSE  THEN DO\n          SET BROWSE  = BROWSE\n          SET DOITMAC  = &STR(BROWSE)\n          SET @DIRPARM = &STR(&DOITMAC)\n          ISPEXEC VPUT (@DIRPARM) SHARED\n          SET SUPPRESS = SUPPRESS\n          GOTO NXT_TOK\n       END\n       IF &STR(&TOKEN) = SUPPRESS THEN DO\n          /* DO NOT SHOW DIRECTORY LIST WITH WRITE STATEMENTS*/\n          SET SUPPRESS = SUPPRESS\n          GOTO NXT_TOK\n       END\n       IF &STR(&TOKEN) = ALIGN THEN DO\n          SET ALIGN = ALIGN\n          SET LISTMEM = LISTMEM\n          GOTO NXT_TOK\n       END\n       /******************************************************/\n       /**  SAMPLE  DOITMAC CLIST\n       /**  ISREDIT MACRO\n       /**  ISREDIT X ALL\n       /**  ISREDIT F ALL ' STRING1 '\n       /**  ISREDIT F ALL ' STRING1 '\n       /**  ISREDIT SEEK NX P'-'\n       /**  ISREDIT (SEEKSTRS,SEEKLNS) = SEEK_COUNTS\n       /**  IF &EVAL(&SEEKSTRS) = 0 THEN ISREDIT CANCEL\n       /**  .... YOU REMAIN IN EDIT AND MUST SAVE OR CANCEL\n       /********************************************************\n       IF &STR(&TOKEN) = &STR(*) THEN DO\n          SET SHOWUSER = SHOWUSER\n          GOTO NXT_TOK\n       END\n       IF &STR(&TOKEN) = NOSHOW  THEN DO\n          SET NOSHOW   = NOSHOW\n          GOTO NXT_TOK\n       END\n       IF &STR(&TOKEN) = DATE    THEN DO\n          SET SHOWDATE = SHOWDATE\n          SET SHOWUSER = SHOWUSER\n          GOTO NXT_TOK\n       END\n       IF &STR(&TOKEN) = &STR(^*) THEN DO\n          SET SHOWBLANK = SHOWBLANK\n          GOTO NXT_TOK\n       END\n       IF &STR(&TOKEN) = &STR(**) | &STR(&TOKEN) = &STR(*^*) THEN DO\n          SET SHOWBLANK = SHOWBLANK\n          SET SHOWDATE = SHOWDATE\n          SET SHOWUSER = SHOWUSER\n          GOTO NXT_TOK\n       END\n       IF &TOKEN = &STR()) THEN DO\n          SET &ZEDSMSG = &STR(LOST PARENTHESIS)\n          SET &ZEDLMSG = BLANKS SEPARATE ALL OPERANDS; THEREFORE +\n            INVALID IN FROM() TO() COL() BEGIN()\n          ISPEXEC SETMSG MSG(ISRZ000)\n          EXIT CODE(12)\n       END\n       SET J = 1 + 0\n       DO WHILE &J <= &LENGTH(&STR(&TOKEN))\n          IF &J > 8 | &SUBSTR(&J,&STR(&TOKEN.)             ) = +\n            &STR(&LP.)  THEN DO\n             SET &ZEDSMSG = &STR(PARM? &STR(&TOKEN.))\n             SET &ZEDLMSG = &STR(PARAMETER UNKNOWN TO @DIR -- +\n               &STR(&TOKEN.) -- NOT A USERID)\n             ISPEXEC     SETMSG MSG(ISRZ000)\n             EXIT CODE(12)\n          END\n          SET J = &J + 1\n       END\n       SET &USERLIST = &STR(&USERLIST. &TOKEN)\n       SET U = &U + 1\n       SET USER&U   = &STR(&TOKEN)\n       SET USERCX    = &STR(USER)&U\n       SET &USERCX   = 0\n       IF &SUBSTR(1,&STR(&TOKEN) ) = &STR(^) THEN SET NEGU = &NEGU + 1\n NXT_TOK: -\n       SET I = &I + 1\n     END\n END_TOK: SET I = &I\n     /*****************************************************************\n       /**************************************************************\n       IF &FROM. NE &STR() THEN +\n           IF &SUBSTR(1:&LENGTH(&TO.),&FROM.        ) > &TO. THEN DO\n              SET &ZEDSMSG = &STR(&FROM.:&TO REVERSED)\n              WRITE          &STR(FROM(&FROM.) > TO(&TO.) OR &FROM.+\n                 :&TO.  VALUES REVERSED OR INCORRECT)\n              SET &ZEDLMSG = &STR(FROM(&FROM.) > TO(&TO.) OR &FROM.+\n                 :&TO.  VALUES REVERSED OR INCORRECT)\n      /*      ISPEXEC CONTROL DISPLAY LOCK\n              ISPEXEC     SETMSG MSG(ISRZ000)\n              SET @DIRPARM = &STR(&@DIRSAVE)\n              ISPEXEC VPUT (@DIRPARM) SHARED\n              ISPEXEC     SETMSG MSG(ISRZ000)\n              EXIT CODE(12)\n          END\n       IF $NDU = &$NDU THEN ISREDIT LINE_AFTER .ZL = +\n           DATALINE  \"=== &SYSDATE. &SYSTIME. @DIR &ARGS =====\"\n       IF &STR(&RECS.&FOUND.) ^= &STR() THEN DO\n          SET LISTMEM = LISTMEM\n          IF &STR() = &COL THEN DO\n            SET &ZEDSMSG = &STR(COL&LP.NN&RP.)\n            SET &ZEDLMSG = &STR(COL&LP.NN&RP. MUST BE SPECIFIED WHEN +\n              USING RECS&LP.&RP.|FOUND&LP.&RP.)\n            ISPEXEC     SETMSG MSG(ISRZ000)\n            EXIT CODE(12)\n          END\n       END\n       ISREDIT (LASTLN) = LINENUM .ZLAST\n /*    IF &STR(&TODATE) = THEN SET TODATE = &STR(1999/12/31)\n       IF &NEGU ^= 0 THEN DO\n          IF &NEGU ^= &U THEN DO\n             SET &ZEDSMSG = &STR(^USER AND USER)\n             SET &ZEDLMSG = &STR(CANNOT ASK FOR SPECIFIC USERS AND +\n               REJECT SPECIFIC USERS AT SAME TIME)\n             ISPEXEC     SETMSG MSG(ISRZ000)\n             EXIT CODE(12)\n          END\n          SET SHOWUSER = SHOWUSER\n          SET NEGU = NEGU\n       END\n       SET B25     = &STR(                         )\n       IF IMAC NE &IMAC THEN DO\n          ISREDIT (DAR019,DAR030) = DISPLAY_COLS\n          SET LLEN = 0&DAR030 + 1 - 0&DAR019\n          IF &LLEN < 40 THEN SET LLEN = 72\n          ISREDIT (DWIDTH) = DATA_WIDTH\n       END\n       ELSE DO\n          SET DWIDTH = 80\n          SET LLEN = 72\n       END\n       IF &HELP = HELP THEN IF &STR(&USER) = &STR() THEN DO\n          WRITE HELP REQUESTED FOR  @DIR   MACRO  USED WITHIN ISPF +\n            EDIT MEMBER\n          WRITE DSNAME IS OPTIONAL   WILL USE  &SYSUID..LIBR.CNTL\n          WRITE USER IS OPTIONAL     (ONLY BYTES 1-4 OF ACTUAL USERID +\n            WILL BE COMPARED HOWEVER)\n          WRITE &B             &SYSUID.   SELECT ONLY THIS +\n            USERID,       SHORT FORMAT\n          WRITE &B            ^&SYSUID.   SELECT ONLY IF NOT THIS +\n            USERID, LONG FORMAT\n          WRITE &B           *^&SYSUID.   SELECT ONLY IF NOT THIS +\n            USERID, LONG FORMAT PLUS LMOD-DATE\n          WRITE &B             *          SELECT USERID OR BLANK +\n            USERID,  LONG FORMAT\n          WRITE &B            ^*  | *^*   SELECT ONLY BLANK +\n            USERID,      SHORT FORMAT\n          WRITE &B             (BLANK)    IGNORE SELECTION/REJECTION  +\n            CHOOSE ALL\n          WRITE MASK()  IS OPTIONAL   A-Z 0-9   %=ALPHA  +=NUMERIC +\n            ^=NON-BLANK .=IGNORE\n          SET   DSN     = &STR(&SYSUID..LIBR.CNTL)\n          SET   USER    = &STR(&SYSUID.)\n          SET   ONAFTER = &STR(&SYSDATE.)\n          SET   ONAFTER = &STR(&SUBSTR(1:3,&ONAFTER)01&SUBSTR(6:8,+\n            &ONAFTER))\n          WRITE ONAFTER IS OPTIONAL  WILL USE  &ONAFTER\n          WRITE AS IF YOU HAD ENTERED        ===> @DIR &DSNAME. +\n            &USER. &ONAFTER. <==========\n          WRITE SHOULD ALSO TRY              ===> @DIR\n          WRITE AND                          ===> @DIR *\n          WRITE AND                          ===> @DIR ^*\n          WRITE AND                          ===> @DIR ^&SYSUID.\n       END\n       IF &STR(&ALIGN) = ALIGN AND &STR(&BEGIN.) =  AND &COL > 1 AND +\n         &COL < 26 THEN DO\n          SET LISTMEM = LISTMEM\n          SET ALIGN = &EVAL(&COL.-1)\n          SET BEGIN =  &STR(&BEGIN.&B25.)\n          SET BEGIN = &SUBSTR(1:&ALIGN,&STR(&BEGIN))\n       END\n       /***************** DSNAME SUPPLIED TO LMINIT ****************\n       IF &STR(&DSN) = &STR() THEN DO  /*NO DSN SUPPLIED*/\n          ISREDIT (DSN) = DATASET\n          SET DSN = '&DSN'\n          SET DSNUSED = 1\n       END\n       IF &SUBSTR(1:1,&STR(&DSN.) ) ^= &STR(') THEN DO  /* ATTEMPT TO +\n         PREFIX USERID*/\n          SET DSNAME = &STR('&SYSUID..&SYSCAPS(&DSN.)')\n          SET CHK = &STR(&SYSDSN(&DSNAME.)\n          IF &STR(&CHK.) = OK THEN SET DSN = &STR(&DSNAME)\n       END\n       IF LIB = &LIB. THEN DO\n          WRITE PLEASE SUPPLY FULLY QUALIFIED DATASET NAME +\n              FOR DIRECTORY ENTRIES\n          READ DSN\n          WRITE YOUR CHOICE IS \"&DSN.\"\n       END\n       SET DSNAME  = &STR(&SYSCAPS(&DSN.))\n       IF &SUBSTR(1:1,&STR(&DSNAME.) ) ^= &STR(') THEN -\n          SET DSNAME = &STR('&DSNAME.')\n       SET CHK =  &STR(&SYSDSN(&DSNAME.)\n       IF &STR(&CHK.) = OK THEN DO\n          ISPEXEC LMINIT DATAID(XCX) DATASET(&STR(&DSNAME))\n              /* ENQ(SHRW) ORG(PDSORG) -- POSSIBLE ADDITION TO ABOVE*/\n       END\n       ELSE DO\n          SET &ZEDSMSG = &STR(DSNAME)\n          SET &ZEDLMSG = &STR(&ZEDSMSG.=&DSNAME &CHK.)\n          ISPEXEC     SETMSG MSG(ISRZ000)\n          EXIT CODE(16)\n       END\n       /************************************************************\n       IF &STR(&USERLIST) ^= &STR() THEN -\n          WRITE UPDATE USER ID MUST MATCH ONE OF THESE <&USERLIST. >\n       IF &STR(&ONAFTER) ^= &STR() THEN -\n          SET ONAFTER2 = &STR(&SUBSTR(7:8,&ONAFTER          +\n            )/&SUBSTR(1:5,&STR(&ONAFTER.)         ))\n       IF &STR(&TODATE) ^= &STR() THEN -\n          SET TODATE2 = &STR(&SUBSTR(7:8,&TODATE            +\n            )/&SUBSTR(1:5,&STR(&TODATE.)          ))\n       IF &SHOWDATE = SHOWDATE THEN DO\n             IF &STR(&USER) = &STR() THEN DO\n                 SET USER = &STR(%****)   /* FIRST TIME ONLY  ??? */\n             END\n             SET USER = &SUBSTR(2:&EVAL(&LENGTH(&STR(&USER))),+\n               &STR(&USER) )\n       END\n       IF LISTMEM = &LISTMEM THEN DO\n          ISREDIT (VAR037) = LINENUM .ZLAST\n          IF &VAR037 = 000000 THEN ISREDIT LINE_AFTER 0 = \" \"\n       END\n       ELSE DO\n          IF &STR(&COL.) = &STR() THEN ISREDIT LINE_AFTER 0 = +\n             NOTELINE \"LISTMEM OPTION NOT USED, OR MISSING\"\n       END\n       /********** @DIR  WILL SAVE CURRENT PFKEYS -- USER MAY CHANGE +\n         DURING INVOCATION BUT WILL BE RESET\n       ISPEXEC VGET (ZPF01 ZPF02 ZPF03 ZPF04 ZPF05 ZPF06 ZPF07 ZPF08 +\n         ZPF09 ZPF10 ZPF11 ZPF12) PROFILE\n       ISPEXEC VGET (ZPF13 ZPF14 ZPF15 ZPF16 ZPF17 ZPF18 ZPF19 ZPF20 +\n         ZPF21 ZPF22 ZPF23 ZPF24) PROFILE\n       /* -- */\n       ISPEXEC   LMOPEN DATAID(&XCX) OPTION(INPUT)\n          /* OPEN DATAID + FOR INPUT    */\n       SET LMRC = &LASTCC\n       /* --  CONTROL NOLIST NOCONLIST NOSYMLIST\n       SET MEMBER = &FROM.\n       DO WHILE (&LMRC = 0 )\n          IF &LMRC = 0 THEN DO    /* IF RETURNED A MEMBERNAME*/\n             ISPEXEC LMMLIST DATAID(&XCX) -\n               OPTION(LIST) MEMBER(MEMBER) STATS(YES)\n                  /* BUILD MEMBERLIST AND ...\n                  /* RETURN + NEXT MEMBER NAME */\n             SET &LMRC = &LASTCC  /*CAPTURE RETURN CODE */\n          END\n          IF &LMRC = 0 THEN DO   /* IF RETURNED A MEMBERNAME */\n             SET CNTT = 0&CNTT + 1   /* CONTAINED IN FILE */\n             /* ----- BEGIN -- LIST(NN) 1987/06/01\n             IF &STR(&LISTP) ^= &STR() THEN DO\n               LPCHK: -\n                IF XX&STR(&LISTPMEM) < XX&STR(&MEMBER) THEN DO\n                   SET LISTPL = 0&LISTPL + 1\n                   IF &LISTPL > &LISTLAST THEN SET LISTPMEM = +\n                     &STR(0Z000000)\n                   ELSE DO\n                      ISREDIT (VAR036) = LINE &LISTPL.\n                      IF &LENGTH(&STR(&VAR036)) < &LISTP THEN +\n                        GOTO LPCHK\n                      SET LISTPP = &STR(&LISTPMEM)\n                      SET LISTPMEM = +\n                        &SUBSTR(&LISTP.:&LISTP2.,+\n                          &STR(&VAR036)          )\n                      IF &STR(&LISTPMEM) < &STR(&LISTPP) THEN DO\n                         SET &ZEDSMSG = &STR(&LISTPMEM. +\n                              < &LISTPP.)\n                         SET &ZEDLMSG = &STR(&ZEDSMSG. -- THIS +\n                           LIST NOT SORTED ON COLUMNS &LISTP. +\n                             &LISTP2.)\n                         ISPEXEC     SETMSG MSG(ISRZ000)\n                         EXIT CODE(16)\n                      END\n                      GOTO LPCHK\n                   END\n                END\n                IF XX&STR(&LISTPMEM) ^= +\n                  XX&STR(&MEMBER) THEN GOTO +\n                  IGNORE\n             END\n             IF &STR(&FINDP) ^= &STR() THEN DO\n                IF &STR(&FINDMEM.) ^= &STR() THEN DO\n                   IF &STR(&XFIND.) ^= &STR() THEN DO\n                      SET FINDMEM = &MEMBER.\n                      ISREDIT FIND FIRST &NX &FINDP .ZFIRST +\n                        .FINDPL WORD \"&FINDMEM.\"\n                      IF &LASTCC = 0 THEN GOTO IGNORE\n                   END\n                   ELSE DO\n                      ISREDIT FIND FIRST &NX &FINDP .ZFIRST +\n                        .FINDPL WORD \"&FINDMEM.\"\n                      IF &LASTCC ^= 0 THEN GOTO IGNORE\n      /*              ISREDIT (@DIRTEXT) = LINE .ZCSR\n        /*            ISPEXEC VPUT (@DIRTEXT) SHARED\n          /*          WRITE &@DIRTEXT. = @DIR WRITE\n                   END\n                END\n                ELSE DO\n                   SET MEMBER = &MEMBER.    /* 1993/09/30 */\n                   ISREDIT FIND FIRST &NX &FINDP .ZFIRST .FINDPL +\n                     WORD \"&MEMBER.\"  /* ADDED WORD 1993/09/30*/\n                   IF &LASTCC ^= 0 THEN GOTO IGNORE\n                      ISREDIT (@DIRTEXT) = LINE .ZCSR\n                      ISPEXEC VPUT (@DIRTEXT) SHARED\n         /*           WRITE &@DIRTEXT. = @DIR WRITE22\n                END\n             END\n             /* ----- END -- LIST(NN) 1987/06/01\n             IF &STR(&FROM) ^= &STR() THEN -\n                IF &SUBSTR(1:&LENGTH(&FROM),&MEMBER        ) < +\n                  &STR(&FROM.) THEN GOTO IGNORE\n             IF &STR(&TO) ^= &STR() THEN -\n                IF &SUBSTR(1:&LENGTH(&TO),&MEMBER        ) > &TO +\n                  THEN GOTO IGNORE\n             SET CNTR = 0&CNTR + 1  /* WITHIN  MEMBERNAME RANGE\n             IF &STR(&INDEX.) ^= &STR() THEN DO\n                SET T1 = &SYSINDEX(&NRSTR(&INDEX.),&STR(&MEMBER.))\n                IF &EVAL(&T1.) ^= &EVAL(0) THEN GOTO MASKOK\n                GOTO IGNORE\n             END\n             IF &MASKMAX > 0  THEN DO\n                SET T1 = 1\n      MASKCHKA: SET MASK = &STR(&&MASK&T1)\n                SET MASK = &STR(&MASK        )\n                SET P1 = 1\n      MASKTSTP: SET X1 = &SUBSTR(&P1:&P1,&STR(&MASK.)          )\n                SET X2 = &SUBSTR(&P1:&P1,&STR(&MEMBER.)        )\n                IF &STR(&X1) = &STR(&X2) THEN GOTO NXTMASKP\n                IF &STR(&X1) = &STR( ) OR &STR(&X1) = &STR(-) +\n                  THEN GOTO NXTMASKP\n                IF &STR(&X1) = &STR(*) AND &STR(&X2) = &STR( ) +\n                  THEN GOTO NXTMASKP\n                IF &STR(&X1) = &STR(+) AND &STR(&X2) >= &STR(0) +\n                  THEN GOTO NXTMASKP\n                IF &STR(&X1) = &STR(%) THEN DO\n                   IF &STR(&X2) > &STR(Z) THEN GOTO MASKTNXT\n                   IF &STR(&X2) = &STR(@) | &STR(&X2) = &STR(#) +\n                     | &STR(&X2) = &STR($) THEN GOTO NXTMASKP\n                   IF &STR(&X2) < &STR(A) THEN GOTO MASKTNXT\n                   GOTO NXTMASKP\n                END\n                IF &STR(&X1) ^= &STR(^) THEN GOTO MASKTNXT\n          NXTMASKP: SET P1 = &P1 + 1\n                IF &P1 < 9 THEN GOTO MASKTSTP\n                GOTO MASKOK\n      MASKTNXT: SET T1 = &T1 + 1\n                IF &EVAL(&T1) > &EVAL(&MASKMAX) THEN GOTO IGNORE\n                GOTO MASKCHKA\n             END\n      MASKOK: -\n             IF &U = 0 THEN GOTO OKUSER\n             IF &STR(&ZLUSER.) = &STR() THEN DO\n                IF SHOWBLANK = &SHOWBLANK THEN DO\n                   SET CNTU = 0&CNTU + 1\n                   GOTO OKUSER\n                END\n                GOTO IGNORE\n             END\n             SET I = 1\n             DO WHILE &I <= &U\n                SET USERX = &&USER&I\n                SET USERX = &USERX\n                SET USERCX = &&USERC&I\n                SET USERCX = &USERX\n                IF NEGU = &NEGU THEN DO\n                   IF &SUBSTR(2:5,&STR(&USERX.)    ) = +\n                     &SUBSTR(1:4,&STR(&ZLUSER.     )  THEN DO\n                      GOTO IGNORE\n                   END\n                   GOTO NREJECTD\n                END\n                IF &SUBSTR(1:4,&STR(&USERX)    ) = +\n                  &SUBSTR(1:4,&STR(&ZLUSER.    ) THEN DO\n       /* DOESN'T WORK           SET USERC&I =  &EVAL(&&USERC&I) + 1\n                   GOTO OKUSER\n                END\n    NREJECTD: -\n                SET I = &I + 1\n             END\n             IF &NEGU = NEGU THEN GOTO OKUSER\n             GOTO IGNORE\n   OKUSER:   IF &STR(&ONAFTER2) ^= &STR() THEN DO\n                IF &STR(&ZLMDATE.) < &STR(&ONAFTER2.) THEN DO\n                   SET CNTB = 0&CNTB + 1\n                   GOTO IGNORE\n                END\n             END\n             IF &STR(&TODATE2) ^= &STR() THEN DO\n                IF &STR(&ZLMDATE.) > &STR(&TODATE2.) THEN DO\n                   SET CNTA = 0&CNTA + 1\n                   GOTO IGNORE\n                END\n             END\n             IF &STR(&PATTERN.) ^= &STR() THEN DO\n                ISREDIT (VAR037) = LINENUM .ZLAST\n                SET VAR037 = &VAR037 + 1\n                ISREDIT COPY &PATTERN AFTER .ZL\n                ISREDIT LABEL &VAR037 = .AA\n                IF &STR(&L8.) = &STR(L8) THEN -\n                   SET MEMBRRR = &STR(&MEMBER.)\n                ELSE SET MEMBRRR = &MEMBER.\n                ISREDIT C ALL .AA .ZL '$NAME$' '&MEMBRRR.'\n                GOTO IGNORE\n             END\n             IF NOSHOW = &NOSHOW THEN GOTO IGNORE\n     /*    CONTROL NOLIST NOCONLIST NOSYMLIST\n             IF &STR(&CMD.) ^= &STR() THEN DO\n                IF &STR(&CMD.) = COPYAFT THEN DO\n                   IF &MEMBER ^= &DMEMBER. THEN +\n                       ISREDIT COPY &MEMBER. AFTER .ZLAST\n                   ELSE WRITE (&MEMBER. NOT COPIED)\n                END\n                ELSE WRITE FUTURE -- ISREDIT &CMD. &MEMBER.\n             END\n             IF &STR(&CMDAFT.) ^= &STR() THEN DO\n                WRITE FUTURE -- ISREDIT &CMDAFT. &MEMBER. .ZLAST\n             END\n             IF LISTMEM = &LISTMEM THEN DO\n                 SET MP03 = 0&MP03. + 1        /* PROCESS CNT -- +\n                   SAME USER */\n                 /* JUST TESTED FOR A MATCHING USERID IN STATS +\n                   TO CONTINUE PROCESSING*/\n                 IF $BUILD$ = &$BUILD$ | $BUILD$T = &$BUILD$ +\n                   THEN DO\n                    SET XYZ = &STR(&MEMBER. &ZLMDATE. &ZLMTIME. +\n                      &ZLCNORC.)\n                    IF $BUILD$T = &$BUILD$ THEN DO\n                       IF $BUILD$80 = &$BUILD$80 -\n                          THEN SET XYZ = &STR(&XYZ. +\n                            ....&SUBSTR(1:4,&ZLUSER.    )&STR(.)\n                          ELSE SET XYZ = &STR(&XYZ. &ZLUSER. )\n                       IF &STR(&DWIDTH.) > 131 THEN DO\n                          SET XYZ = &STR(&XYZ.-------------------+\n                            --------------------------------- +\n                            &ZLUSER.-----)\n                          SET XYZ = &STR(&XYZ.XXX +\n                            &ZLCDATE.--&ZLUSER.)\n                       END\n                       ELSE SET XYZ = +\n                         &STR(&XYZ...............................+\n                           &ZLUSER.)\n                    END\n                 END\n                 ELSE DO\n                    SET XYZ = &STR(&MEMBER &ZLVERS..&ZLMOD. +\n                      &ZLCDATE &ZLMDATE.)\n                    SET XYZ = &STR(&XYZ. &ZLMTIME. &ZLCNORC +\n                      &ZLINORC. &ZLMNORC.)\n                    SET XYZ = &STR(&XYZ. &ZLUSER.)\n                 END\n                 SET MP04 = 0&MP04. + 1     /* PROCESS CNT -- +\n                   MACRO USED*/\n                 /********** BEGIN INSERTED UNIQUE CODE +\n                   *********************/\n                 IF SPECIAL = &SPECIAL THEN SET XYZ = +\n                   &STR(&MEMBER.:^^&XYZ.)\n                 ISREDIT LOCATE 0\n                 ISREDIT FIND FIRST &NX &COL  \"&MEMBER.\"\n                 SET CC = &LASTCC\n                 IF &STR(&COL) = &STR() THEN SET CC = 4\n                 IF &CC ^= 0 THEN DO\n                    SET CNTADDED = 0&CNTADDED + 1\n                    IF &EVAL(&CNTADDED.) = 1 THEN DO\n                       ISPEXEC LMINIT DATAID(DATA1) +\n                         DATASET(&STR(&DSNAME))\n                       ISREDIT LINE_AFTER  .ZLAST = DATALINE +\n                         \"&BEGIN. ======== &SYSDATE. +\n                           &SUBSTR(1:5,&SYSTIME.) @DIR &DSN +\n                             &ARGS.==============================+\n                               ======================\"\n                       IF &LENGTH(&STR(&ARGS)) > 20  AND &LLEN < +\n                         81 THEN +\n                           ISREDIT LINE_BEFORE .ZLAST = DATALINE +\n                             \"&BEGIN. ======== &SYSDATE. +\n                             &SUBSTR(1:5,&SYSTIME.) @DIR &ARGS. +\n                             &DSN.===============================+\n                              ====================\"\n                    END\n                    ISREDIT LINE_AFTER .ZLAST = DATALINE +\n                      \"&BEGIN.&XYZ\"\n                 END\n                 ELSE DO\n                    IF &STR(&RECS) ^= &STR() THEN DO\n                       IF &STR(&ZLCNORC)^=&STR() THEN ISREDIT +\n                         CHANGE .ZCSR .ZCSR FIRST &NX &RECS +\n                           '      ' '&ZLCNORC. '\n                    END\n                    IF &STR(&FOUND) ^= &STR() THEN ISREDIT +\n                      CHANGE .ZCSR .ZCSR FIRST &NX &FOUND ' ' +\n                        '&STR(&AST)'\n                    IF &STR(&FOUND) ^= &STR() THEN ISREDIT +\n                      CHANGE .ZCSR .ZCSR FIRST &NX &FOUND '-' +\n                        '&STR(&AST)'\n                    IF SPECIAL = &SPECIAL AND  &EVAL(6) = +\n                      &EVAL(&COL) AND &STR(&BEGIN.) = +\n                        &STR(00006) THEN -\n                       ISREDIT CHANGE .ZCSR .ZCSR 1 3 ALL '000' +\n                         '*00'\n                 END\n                 /********** END OF CODE INCLUDED FOR AN EDIT +\n                   *************/\n             END\n             IF &SHOWDATE = SHOWDATE  | &SHOWUSER = +\n               SHOWUSER       -\n             | &SUBSTR(1:1,&STR(&USER)   ) = &STR(^) THEN DO\n                IF &SHOWDATE = SHOWDATE THEN DO\n                   SET G = +\n                     &SUBSTR(1:23,&STR(&MEMBER.-&SUBSTR(1:5,+\n                       &ZLUSER.      )-&ZLMDATE.###&B25))\n                   SET CNTL = 0&CNTL + 23\n                END\n                ELSE DO\n                   SET G = &STR(&MEMBER.&STR(-&ZLUSER))\n                   SET G = +\n                     &SUBSTR(1:16,&STR(&G.                   )\n                   SET CNTL = 0&CNTL + 16\n                END\n             END\n             ELSE DO\n                SET G = &STR(&MEMBER.)\n                SET CNTL = 0&CNTL + 8\n             END\n             SET CNTL = 0&CNTL + 2  /*WRITE HAS AUTOMATIC +\n               1-SPACE, AND I ADD 1-SPACE BELOW*/\n             SET CNTF = 0&CNTF + 1\n             IF &EVAL(&CNTF) = &EVAL(1) THEN DO\n                SET CNTL = &CNTL + &CNTL\n             END\n             IF &EVAL(0&CNTL) > &EVAL(&LLEN. + 2) THEN DO\n                IF &STR(&SUPPRESS) = &STR() THEN WRITE &STR(&G. )\n                SET CNTL = &LENGTH(&STR(&G.  )\n             END\n             ELSE DO\n               IF &STR(&SUPPRESS) = &STR() THEN WRITENR &STR(&G. )\n             END\n             IF &STR(&NUSER.) ^= &STR() THEN DO\n                /* SPECIAL ABILITY TO CHANGE USERID */\n                ISPEXEC LMMSTATS DATAID(&XCX.) MEMBER(&MEMBER.) +\n                   USER(&NUSER.)\n                GOTO IGNORE\n             END\n             IF &STR(&DOITMAC) ^= &STR() AND X&STR(&MEMBER.) +\n             ^= X&STR(&DMEMBER.) +\n               THEN DO\n                SET XYZ = &STR(&MEMBER &ZLVERS..&ZLMOD. &ZLCDATE +\n                  &ZLMDATE.)\n                SET XYZ = &STR(&XYZ. &ZLMTIME. &ZLCNORC +\n                  &ZLINORC. &ZLMNORC.)\n                SET XYZ = &STR(&XYZ. &ZLUSER.)\n                SET @DIRSTAT = &STR(&XYZ)\n                ISPEXEC VPUT (@DIRSTAT) SHARED\n                IF BROWSE = &STR(&BROWSE) THEN DO\n                   SET VSTSRVTI = &STR(&DSN. MEMBER=&MEMBER.)\n                   SET DSNDESC = +\n                     &SUBSTR(9:80,&STR(&@DIRSTAT.&BLANK80))\n                   SET SYSBROX2 = &STR(M&SYSLC(EMBER) &MEMBER. -- &DSNDESC.)\n                   SET SYSBROX3 = &STR(===== TO TERMINATE @DIR QUICKLY   +\n                        ==> @DIRPARM ABORT    THEN 'CANCEL')\n                   ISPEXEC VPUT (DSNDESC SYSBROX2 SYSBROX3) SHARED\n                   ISPEXEC BROWSE DATAID(&XCX) MEMBER(&MEMBER) +\n                     PANEL(SYSBROX3)\n                   SET LRC = &LASTCC\n                END\n                ELSE DO\n                  SET @DIRNOTE = &STR(&$NDU.)\n                  ISPEXEC VPUT (@DIRNOTE) SHARED\n                  ISPEXEC EDIT DATAID(&XCX) MEMBER(&MEMBER) +\n                    MACRO(&DOITMAC) &PANEL. &PROFILE.\n                  SET LRC = &LASTCC\n                END\n                IF &LRC > 4 THEN GOTO ABORT\n                ISPEXEC VGET (@DIRPARM) SHARED\n                IF &@DIRPARM ^= &STR(&DOITMAC) THEN DO\n                   WRITE QUICK TERMINATION REQUESTED   @DIRPARM +\n                     IS SET TO \"&@DIRPARM.\"\n                   GOTO ABORT\n                END\n                /*  TO MAKE THIS HAPPEN FROM EDIT TYPE ===> +\n                  @DIRPARM ABORT\n                /**************---*/\n                IF NDU = &NDU. AND &EVAL(&LRC.) = &EVAL(0) THEN DO\n                  /* NDU -- NO DIRECTORY UPDATE (EXCEPT USERID */\n                  SET NDUSER = &STR(&ZLUSER.)\n                  IF &SUBSTR(1:1,&ZLUSER.X) ^= X THEN SET -\n                     NDUSER = &SUBSTR(1:7,&STR(X-&NDUSER.)        )\n                  ELSE -\n                     SET NDUSER = &SUBSTR(1:7,&STR(&NDUSER.)$       )\n                  IF STET = &STET THEN +\n                     SET NDUSER = &SUBSTR(1:7,&STR(&ZLUSER.)        )\n                  ISPEXEC LMMSTATS DATAID(&XCX.) MEMBER(&MEMBER.) +\n                     VERSION(&ZLVERS)  MODLEVEL(&ZLMOD) +\n                     CREATED(&ZLCDATE) MODDATE(&ZLMDATE) +\n                     MODTIME(&ZLMTIME) INITSIZE(&ZLZLINORC) +\n                     USER(&NDUSER.)\n                END\n                IF $NDU = &$NDU. THEN DO\n                   ISPEXEC VGET (@DIRNOTE) SHARED\n                   IF &STR(&@DIRNOTE.) ^= &STR() THEN -\n                     ISREDIT LINE_AFTER .ZL = DATALINE \"&STR(&MEMBER. +\n                        &SYSDATE. &SYSUID. &SYSTIME.) &@DIRNOTE.\"\n                END\n              /**************---*/\n              END\n    IGNORE:   SET II = 0\n           END\n        END\n    ABORT: -\n        ISPEXEC LMMLIST DATAID(&XCX) OPTION(FREE)\n          /* ... FREE MEMBER LIST         */\n        ISPEXEC LMCLOSE DATAID(&XCX)\n          /* ... CLOSE DATAID           */\n        ISPEXEC LMFREE  DATAID(&XCX)\n          /* ... FREE  DATAID           */\n     ENDEND: -\n        IF &CNTB = THEN SET CNTB = 0\n        IF &CNTA = THEN SET CNTA = 0\n        IF &CNTU = THEN SET CNTU = 0\n        IF &CNTF = THEN SET CNTF = 0\n        WRITE\n        WRITENR **SELECTED &CNTF   OF &CNTT,\n        IF &STR(&USER.) = &STR() THEN DO\n           WRITENR NO SELECTION CRITERION ON USERID,\n        END\n        ELSE DO\n           IF &CNTU = 0 THEN WRITENR NO UNMATCHED USERIDS,\n           ELSE              WRITENR REJECTED &CNTU W/O USERID +\n             &USERLIST.,\n        END\n        IF &STR(&ONAFTER2.) = &STR() THEN DO\n           WRITE NO SELECTION CRITERION ON LAST MODIFIED DATE.\n        END\n        ELSE DO\n           IF &CNTB = 0 AND &CNTA = 0 THEN WRITE ALL MEMBERS +\n             CHOSEN WERE WITHIN &ONAFTER. THRU &TODATE.\n           ELSE DO\n               WRITE REJECTED &CNTB BEFORE LMOD-DATE &ONAFTER.\n               WRITE REJECTED &CNTA AFTER  LMOD-DATE &TODATE.\n           END\n        END\n        IF &CNTADDED > 0 THEN DO\n           ISREDIT LOC &LASTLN\n           ISREDIT UP 5\n        END\n       /* ALLOW @DIR TO BE USED RECURSIVELY BY RESETTING @DIRPARM\n       SET @DIRPARM = &STR(&@DIRSAVE)\n       ISPEXEC VPUT (@DIRPARM) SHARED\n       CONTROL NOMSG\n       /* ATTEMPT TO FREE DATASET IF NOT THE ONE CURRENTLY IN EDIT*/\n       IF &STR(&DSNUSED.) NE 1  THEN FREE DA(&DSN.)\n       CONTROL MSG\n       /********** @DIR  WILL RESTORE ORIGINAL PFKEYS -- USER CHANGES +\n         DURING INVOCATION LOST.\n       ISPEXEC VPUT (ZPF01 ZPF02 ZPF03 ZPF04 ZPF05 ZPF06 ZPF07 ZPF08 +\n         ZPF09 ZPF10 ZPF11 ZPF12) PROFILE\n       ISPEXEC VPUT (ZPF13 ZPF14 ZPF15 ZPF16 ZPF17 ZPF18 ZPF19 ZPF20 +\n         ZPF21 ZPF22 ZPF23 ZPF24) PROFILE\n         EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@DIRPARM": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\r\\x00\\r\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- converted to rexx on 1994/06/02, prev update 1986/05/06 */\n ADDRESS \"ISREDIT\"; \"MACRO (@DIRPARM)\"\n /* THIS MACRO IS USED BY @DIR WHEN  BROWSE  IS INVOKED           */\n /* THIS MACRO IS USED BY @DIR WHEN  DOITMAC(NAME) IS INVOKED     */\n /* THERE IS ALSO A TSO VERSION, IT IS NAMED $DIRPARM             */\n /* TO MAKE SURE THAT CONTINUATION OF THE MACRO PROCESS IS WANTED */\n /* DAVID MCRITCHIE,  MAY 28, 1986,                               */\n     IF @DIRPARM = \"\" THEN  DO\n       Address \"ISPEXEC\" \"VPUT (@DIRPARM)  SHARED\"\n       Exit 12\n    END\n    Address \"ISPEXEC\" \"VPUT (@DIRPARM)  SHARED\"\n    Exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@DIRSTAT": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00d\\x00d\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 100, "newlines": 100, "modlines": 0, "user": "MCRITCH"}, "text": "/*  REXX  -- @DIRSTAT, DIRECTORY STATS FOR MEMBER CURR. IN EDIT      */\nAddress \"ISREDIT\"; \"MACRO (TOKEN)\"\nTOKEN = TRANSLATE(TOKEN)\n/*********************************************************************/\n/*  CREATED BY DAVID MCRITCHIE, APR 2, 1986,                         */\n/*              OLD CLIST VERSION STILL AVAILABLE AS  @DIRSTAC       */\n/*  CONVERTED  BY DAVID MCRITCHIE TO REXX  1992/10/09                */\n/*  AVAILABLE TO ANYONE WHILE IN EDIT                                */\n/*      @DIRSTAT  DATA,  WILL PLACE NOTE MATERIAL AFTER LINE 0       */\n/*                INSTEAD OF USING NOTELINES                         */\n/*********************************************************************/\n/* ------ example run as ===> @DIRSTAT DATA  (starry box begin col 2)*/\n/* MEMBER-- VV.MM CREATED- ---MODIFIED---  CURR  INIT   MOD LASTUSER */\n/* @DIRSTAT 01.17 1986/05/07 1992/10/09 22:14 84   68     0 IS03     */\n/*                IS03     1992/10/09 22:14:10 92283 -- Data Unchanged */\n/*                IS03     1992/10/09 22:14:31 92283 -- Data Changed */\n/* ==================================================================*/\n/*                                                                   */\n/* ------ example run as ===> @DIRSTAT      (starry box not included)*/\n/*      DCB=(LRECL=255,BLKSIZE=19069,RECFM=VB,DSORG=PO)  NUMBER OFF) */\n/*== MEMBER-- VV.MM CREATED-  ---MODIFIED---  CURR  INIT   MOD LAST..*/\n/*== @DIRSTAT 01.17 1986/05/07 1992/10/09 22:14 84   68     0 IS03 ..*/\n/*=======================================================DATA-CHANGED*/\n  \" (VAR018) = DATAID\"\n  \" (VAR018A) = DATASET\"\n  \" (VAR043) = MEMBER\"\n  \" (DSNX)          = DATASET\"\n  \" (NUMX)          = NUMBER\"\n  IF \"DATA\" = TOKEN THEN NULL\n  ELSE IF TOKEN \\= \"\" then VAR043 = TOKEN\n x = LISTDSI(\"'\"DSNX\"'\") \"DIRECTORY\"\n ZEDLMSG = \"DCB=(LRECL=\"SYSLRECL\",BLKSIZE=\"SYSBLKSIZE\",\",\n   ||\"RECFM=\"SYSRECFM\",DSORG=\"SYSDSORG\")  NUMBER \"NUMX\")\"\n         Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n  LMRC = rc                    /* CAPTURE RETURN CODE      */\n  IF VAR043 = \"\" THEN DO\n        \"LINE_AFTER 0 = NOTELINE \"\"STATISTICS NOT AVAILABLE FOR \",\n          \"A SEQUENTIAL FILE, ONLY AVAILABLE FOR PDS FILES\"\"\"\n        \" LOC 0\"\n        return 1\n  END\n  Address \"ISPEXEC\" \"LMINIT DATAID(VAR018) DATASET('\"VAR018A\"')\"\n  Address \"ISPEXEC\" \"LMOPEN DATAID(&VAR018)\"\n  Address \"ISPEXEC\" \"LMMFIND DATAID(&VAR018) MEMBER(&VAR043)\",\n          \"STATS(YES)\"\n  LRC = RC\n  IF LRC = 8 THEN  NOTFOUND = 1\n  STARAST = \"/\"||\"*\"  /* split so it will not look unmatched*/\n  ASTSTAR = \"*\"||\"/\"  /* works w/o concatenation also*/\n  VAR043 = SUBSTR(VAR043,1,8)\n  /************************************************************/\n   XYZ = VAR043 ZLVERS\".\"ZLMOD ZLCDATE ZLMDATE\n   XYZ = XYZ ZLMTIME ZLCNORC ZLINORC ZLMNORC\n   XYZ = XYZ LEFT(ZLUSER,8)\n   \" (VAR037) = LINENUM .ZLAST\"\n   IF ZLCNORC =\"\" THEN XYZ = VAR043,\n     \"                                  \"VAR037\"   *NO \",\n     \"STATISTICS*   \"\n   IF NOTFOUND = \"\" THEN XYZ = VAR043  ,\n       \"<<--------------- MEMBER DOES NOT EXIST -------------->>\"\n   \"(VAR014A) = DATA_CHANGED\"\n   if VAR014A = \"NO\" then do\n      changed = \"-- Data Unchanged\"\n   end\n   else do\n      changed = \"-- Data Changed\"\n   end\n   IF VAR014A = \"YES\" THEN\n      \" LINE_AFTER 0 = NOTELINE \"\"\"||,\n        \"===========================================================\",\n        ||\"=DATA-CHANGED=\"CHG\"\"\"\"\n ELSE\n     \" LINE_AFTER 0 = MSGLINE  \"\"\"||,\n       \"===========================================================\",\n       ||\"=================\"\"\"\n   \" LINE_AFTER 0 = NOTELINE \"\"=== \"XYZ\" ==\"\"\"\n   \" LINE_AFTER 0 = NOTELINE \"\"=== MEMBER-- VV.MM CREATED- \",\n     \"---MODIFIED---  CURR  INIT   MOD LASTUSER ==\"\"\"\n   IF TOKEN = \"DATA\" THEN DO\n       q.1 = \"MEMBER-- VV.MM \"||,\n        \"CREATED- ---MODIFIED---  CURR  INIT   MOD LASTUSER\"\n       q.2 = XYZ\n       q.3 = \"              \" LEFT(SYSVAR(SYSUID),8),\n       date('o') time('n') date('j') changed\n       Q.4 = substr('=',1,72,'=')\n       Q.5 = \"    \"\n       do qq = 5 to 1 by -1;\n          \"LINE_AFTER 0 = DATALINE \"\" /\"||\"* \"||,\n              substr(q.qq,1,66)||\"*\"||\"/\"\"\"\n       end\n   END\n   \" LOC 0\"\n   IF ZLCNORC  =\"\" THEN return 1\n   Address \"ISPEXEC\" \"LMCLOSE DATAID(&VAR018)\"\n   Address \"ISPEXEC\" \"LMFREE DATAID(&VAR018)\"\n/*********************************************************************/\n/*    say 'rc='rc 'from lmfree'                                      */\n/*          Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"                  */\n/*********************************************************************/\n   return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@DSN": {"ttr": 2310, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x08\\x00\\x08\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "MCRITCH"}, "text": " /*REXX  @DSN   INVOKE  COMMAND @DSN OTHER OPERANDS    */\n /*  E.G.     @DSN WHOGOT    --GENERATES  WHOGOT DSNAME */\n /*  WARNING DATASET WILL NOT BE ENCLOSED IN QUOTES    */\n      \"ISREDIT MACRO (COMMAND OPTIONS)\"\n      \" ISREDIT (MEMBERX) = MEMBER \"\n      \" ISREDIT (DSNX)    = DATASET\"\n SAY  COMMAND    DSNX  OPTIONS\n      COMMAND    DSNX  OPTIONS\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@DSNQ": {"ttr": 2312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\t\\x00\\t\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX  @DSN   INVOKE  COMMAND @DSN OTHER OPERANDS  *****************/\n/*   ===>  @DSNQ SEARCH4 -- GENERATES  SEARCH4 'FULL.QUALIFIED.DSN   */\n/*     WARNING DATASET WILL BE ENCLOSED IN QUOTES                    */\n/*     RELATED TO  @DSN, WHERE DATASET NOT ENCLOSED IN QUOTES        */\n/*********************************************************************/\n/* CONTRIBUTED: DAVID MCRITCHIE, \"THE REXX MACROS TOOLBOX\", 1992/04/28 */\n\"ISREDIT MACRO (COMMAND OPTIONS)\"\n\" ISREDIT (DSNX)    = DATASET\"\nCOMMAND    \"'\"DSNX\"'\"  OPTIONS\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@EDITMSK": {"ttr": 2314, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xbb\\x00\\xbb\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 187, "newlines": 187, "modlines": 0, "user": "MCRITCH"}, "text": "/*  TITLE:       @EDITMSK THE INCLUSIVE LINES BETWEEN TWO LABELS   */\n/*                                           *GENERALIZED @EDITMSK* */\n/*  USERS:       TSO ISPF EDIT USERS   | SCRIPT USERS              */\n/*  CONTRIBUTED: 1989/02/10 DAVID MCRITCHIE                        */\n/*                                                                 */\n/*  EXAMPLE:     @EDITMSK .ZFIRST .ZLAST NX                        */\n/*                                                                 */\n/*  OPTIONS:                                                       */\n/*      NX        (OPTIONAL)  NON-EXCLUDED,                        */\n/*      LPTR-RANGE | ENTIRE   (REQUIRED) LINE POINTER RANGE        */\n/*                (CC-CC  LINE RANGEALSO AVAILABLE                */\n/*      SHORT      SKELETAL FORM WITHOUT SCRIPT TEXT               */\n/*                                                                 */\n/*  REQUIREMENTS:                                                  */\n/*            DEFAULT WILL EDITORIZE ENTIRE DOCUMENT               */\n/*            MUST BE ACCEPTABLE TO  SHIFT                         */\n           CONTROL ASIS\nISREDIT MACRO NOPROCESS (TOK1,TOK2,TOK3,TOK4,TOK5,TOK6,TOK7,TOK8,+\n               TOK9,TOK10,TOK11,TOK12,TOK13,TOK14,TOK15,+\n               TOK16,TOK17,TOK18,TOK19)\n       SET BEGIN = 1\n       SET INCR  = 1\n       SET BLANKS = &STR(                          )\n       SET BLANKS = &STR(&BLANKS&BLANKS)\n       SET BLANKS = &STR(&BLANKS&BLANKS)\n       SET BLANKS = &STR(&BLANKS&BLANKS)\n       SET LP = &STR((\n       SET RP = &STR())\n       SET N0 = 20\n       SET N  = 0\n       SET I = 0\n       SET L = 0\n       /*********\n       ISREDIT PROCESS RANGE C\n       IF &LASTCC = 0 THEN DO\n          SET LABF = &STR(.ZFRANGE)\n          SET LABL = &STR(.ZLRANGE)\n       END\n       /*********\n       SET I = 1\n      DO WHILE &I <= 100\n       SET TOKEN = &&TOK&I\n       SET TOKEN = &STR(&SYSCAPS(&TOKEN))\n       IF &SUBSTR(1,&STR(&TOKEN.) ) = &STR(') THEN DO\n          /* REMOVE QUOTES WATCH OUT DSNAMES  E.G.   'CHARS(GT10 GT12)'\n          IF &SUBSTR(&LENGTH(&STR(&TOKEN.)),&STR(&TOKEN)) = &STR(') +\n          THEN DO\n             SET TOKEN = &SUBSTR(2:&EVAL(&LENGTH(&STR(&TOKEN.))-1),+\n                 &STR(&TOKEN))\n          /* WRITE &TOKEN.\n          END\n       END\n       IF DEBUG = &DEBUG THEN WRITE  &I  TOK&&I=&&TOK&I  TOKEN=&TOKEN\n       IF &STR(&TOKEN) = &STR() THEN GOTO END_TOK\n       IF ALL = &STR(&TOKEN) | NEXT = &STR(&TOKEN) | FIRST = +\n         &STR(&TOKEN) | LAST = &STR(&TOKEN) | PREV = &STR(&TOKEN) +\n       THEN DO\n          SET &ZEDSMSG = &STR(&TOKEN INVALID)\n          SET &ZEDLMSG = &STR(\"&TOKEN\" NOT PROVIDED FOR NOR ARE NEXT +\n            ALL FIRST LAST PREV)\n          ISPEXEC   SETMSG MSG(ISRZ000)\n          EXIT CODE(12)\n       END\n       IF HELP = &STR(&TOKEN) | DEBUG = &STR(&TOKEN) +\n          | LEFT = &STR(&TOKEN) | RIGHT = &STR(&TOKEN) +\n          | NX   = &STR(&TOKEN) | X     = &STR(&TOKEN) +\n          | ENTIRE = &STR(&TOKEN) -\n          | SHORT  = &STR(&TOKEN) -\n          THEN DO\n            SET &&TOKEN.    = &STR(&TOKEN)\n            IF DEBUG = &DEBUG THEN WRITE  &I  TOK&I=&TOK&&I +\n               TOKEN=&TOKEN\n            GOTO NXT_TOK\n          END\n       IF &SUBSTR(1:6,&STR(&TOKEN)       ) = &STR(BEGIN&STR(&LP))  +\n       THEN DO\n          SET BEGIN = &SUBSTR(7:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1:5,&STR(&TOKEN)       ) = &STR(INCR&STR(&LP))  +\n       THEN DO\n          SET BEGIN = &SUBSTR(6:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n            &STR(&TOKEN)         )\n          GOTO NXT_TOK\n       END\n       IF &SUBSTR(1,&TOKEN) = &STR(.) THEN DO\n          IF &LABF = &STR() THEN DO\n             SET LABF = &STR(&TOKEN)\n             GOTO NXT_TOK\n          END\n          IF &STR(&LABL) = &STR() THEN DO\n             SET LABL = &STR(&TOKEN)\n             GOTO NXT_TOK\n          END\n         SET &ZEDSMSG = &STR(LABEL &STR(&TOKEN))\n         SET &ZEDLMSG = &STR(EXACTLY TWO LABELS ARE REQUIRED FOUND   +\n           \"&LABF\", \"&LABL\" AND  \"&STR(&TOKEN)\")\n         ISPEXEC   SETMSG MSG(ISRZ000)\n         EXIT CODE(12)\n       END\n       IF &STR(&TOKEN) = &STR()) THEN DO\n          SET &ZEDSMSG = &STR(LOST PARENTHESIS)\n          SET &ZEDLMSG = BLANKS SEPARATE ALL OPERANDS; THEREFORE +\n          INVALID IN FROM() TO() COL() BEGIN()\n          ISPEXEC SETMSG MSG(ISRZ000)\n          EXIT CODE(12)\n       END\n       WRITE &TOKEN  NOT PROVIDED FOR IN CLIST\n       SET REMAIN = &STR(&REMAIN &STR(&TOKEN))\nNXT_TOK: +\n       SET I = &I + 1\n     END\nEND_TOK: SET I = &I\n     IF &STR(&REMAIN.) ^= &STR() THEN -\n       WRITE &REMAIN -- NOT PROVIDED FOR IN CLIST\n     /*****************************************************************\n       /***************************************************************\n       IF NX = &STR() THEN DO\n          SET X = X\n          SET NX = NX\n       END\n       IF ENTIRE = &ENTIRE THEN DO      /*** LABELS ARE REQUIRED ******\n          IF &LABF = &STR() THEN DO\n             SET LABF = .ZFIRST\n             SET LABL = .ZLAST\n          END\n          ELSE DO\n             SET &ZEDSMSG = &STR(LABEL CONFLICT)\n             SET &ZEDLMSG = &STR(\"ENTIRE\" IMPLIES .ZFIRST .ZLAST +\n               CONFLICTS WITH \"&LABF\" AND \"&LABL\")\n             ISPEXEC     SETMSG MSG(ISRZ000)\n             EXIT CODE(12)\n          END\n       END\n       IF &LABF = &STR() THEN DO\n          SET &ZEDSMSG = &STR(MISSING .LABELS)\n          SET &ZEDLMSG = &STR(REFORMAT WITHOUT LABEL-RANGE REFUSED)\n          ISREDIT     LINE_AFTER  .ZCSR    = NOTELINE \"*ERROR** +\n            @EDITMSK &ZEDLMSG.\"\n          ISPEXEC     SETMSG MSG(ISRZ000)\n          EXIT CODE(4)\n       END\n/***************\n        ISREDIT (MEMBERX) = MEMBER\n        ISREDIT (DSNX)    = DATASET\n/***************\n        ISREDIT SHIFTNX &LABF. &LABL. &X &NX. RIGHT 7\n        ISREDIT @SEQ  &LABF. &LABL. &NX. COL(1) L(6) BEGIN(&BEGIN.) +\n          INCR(&INCR.)\n        IF SHORT = &SHORT THEN DO\n           ISREDIT LINE_BEFORE &LABF. = DATALINE \"COMMAND ===>\"\n           ISREDIT LINE_BEFORE &LABF. = DATALINE +\n             \"=COLS> ----+----1----+----2----+----+\n                3----+----4----+----5----+----6----\"\n           EXIT CODE(1)\n        END\n        /******************\n        ISREDIT LABEL &LABF. = .BEGIN 2\n        ISREDIT LABEL &LABL. = .END   2\n        SET LABF = &STR(.BEGIN)\n        SET LABL = &STR(.END)\n        /******************\n        ISREDIT LINE_BEFORE &LABF = DATALINE \"&SYSLC(.SK 1)\"\n        ISREDIT LINE_BEFORE &LABF = DATALINE \"&SYSLC(.KP ON;.FO OFF)\"\n        ISREDIT LINE_BEFORE &LABF = DATALINE \"&SYSLC(:GT12.)\"\n        ISREDIT LINE_BEFORE &LABF = DATALINE \"&SYSLC(.SK 1)\"\n        ISREDIT LINE_BEFORE &LABF. = -\n           \":&SYSLC(HP2).EDIT:&SYSLC(EHP)2.:&SYSLC(HP)2.---- +\n           IS03.SHARE.TEXT(EDITXXXX) - 01.00 - +\n           COLUMNS 001 124:&SYSLC(EHP2.)&RBL.\"\n        ISREDIT LINE_BEFORE &LABF. = -\n           \":&SYSLC(HP)2.COMMAND ===>:&SYSLC(EHP)+\n           2.                                  :&SYSLC(HP)2.SCROLL +\n           ===> CSR:&SYSLC(EHP)2.&RBL.\"\n        ISREDIT LINE_BEFORE &LABF. = -\n           \":&SYSLC(HP)2.******:&SYSLC(EHP)2. *********************+\n          ******* TOP OF DATA *****************************\"\n        /* FOLLOWING LINE GO OUT IN REVERSE ORDER...\n        ISREDIT LINE_AFTER  &LABL = DATALINE \"&SYSLC(.KP OFF)\"\n        ISREDIT LINE_AFTER  &LABL = DATALINE \"&SYSLC(:EGT12.)\"\n        ISREDIT LINE_AFTER &LABL. = -\n           \".*---- - - - - - - - - - - - +\n         - - - - - - - - - - - NN LINES(S) NOT DISPLAYED\"\n        ISREDIT LINE_AFTER &LABL. = -\n           \":&SYSLC(HP)2.******:&SYSLC(EHP)2. ***********************+\n         ** BOTTOM OF DATA *****************************\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@END": {"ttr": 2318, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x08\\x00\\x08\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "MCRITCH"}, "text": "      /* @END: END IF DATA HAS NOT BE CHANGED -- REXX*/\n      /* @END:     END  MEMBER IN EDIT IF CONTENT WAS - NOT - MODIFIED*/\n      /* CREATED BY DAVID MCRITCHIE, FEB 10, 1988                  */\n      /* AVAILABLE TO ANYONE WHILE IN EDIT -- FOR @DIR MACRO(MACRO) */\n      ADDRESS \"ISREDIT\";\"MACRO\"\n      \"(VAR014A) = DATA_CHANGED\"\n      IF VAR014A = \"NO\" THEN ADDRESS \"ISREDIT\" \"END\"\n      RETURN 1   /* PUT CURSOR ON COMMAND LINE */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE380": {"ttr": 2320, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x046\\x00\\x00\\x01\\x021?\\x01\\x021? E\\x00\\x11\\x00\\x11\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf5\\xf4@@@'", "ispf": {"version": "04.54", "flags": 0, "createdate": "2002-11-09T00:00:00", "modifydate": "2002-11-09T20:45:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "CBT-454"}, "text": "//***FILE 380 is from F. David McRitchie, and contains REXX execs   *   FILE 380\n//*           and other goodies he has written.  This file is       *   FILE 380\n//*           several years old (dated approximately 1999), and is  *   FILE 380\n//*           in the category of what I call \"rabbit-hole ware\".    *   FILE 380\n//*           That is, Dave submitted it for the CBT Tape several   *   FILE 380\n//*           years ago, I had some trouble processing it at that   *   FILE 380\n//*           time, and it kind of \"fell through the cracks\" until  *   FILE 380\n//*           I found it recently.  So here it is:  Please enjoy    *   FILE 380\n//*           Dave's good work!  (SBG-11/02)                        *   FILE 380\n//*                                                                 *   FILE 380\n//*           For now, please refer to Sam Golob for questions      *   FILE 380\n//*           and help:                                             *   FILE 380\n//*                                                                 *   FILE 380\n//*           email:  sbgolob@attglobal.net                         *   FILE 380\n//*                   sbgolob@cbttape.org                           *   FILE 380\n//*                   sbgolob@aol.com                               *   FILE 380\n//*                                                                 *   FILE 380\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@ICOPY": {"ttr": 2322, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xa7\\x00\\xa7\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 167, "newlines": 167, "modlines": 0, "user": "MCRITCH"}, "text": "/* @ICOPY:  Interleaved COPY         REXX */\n/*\n/* 1 */\n/* 2 */\n USERS:       TSO ISPF EDIT USERS   | SCRIPT USERS\n                 .ADDRA .ADDRB COPY THE CONTENT OF .ADDRC .ADDRD\n CONTRIBUTED: 1986/05/10 David McRitchie\n     \"The REXX Macros Toolbox\"\n\n   Converted to REXX 1993/05/17 by David McRitchie original author.\n   Can do BEFORE and AFTER at same time, if it makes sense to do so.\nMEMBER-- VV.MM CREATED- ---MODIFIED---  CURR  INIT   MOD LASTUSER\n@ICOPY   01.07 1986/05/10 1991/04/22 16:18 236 238     0 IS03     =\n@ICOPY   01.04 1986/05/14 1994/04/11 16:34 163 154     0 IS03     ==\n\n EXAMPLE:     @ICOPY   .A .B .LINA .LINB\n              @ICOPY   .RA .RB MEMBNAM\n              @ICOPY   .RA .RB MEMBNAM.ext    on PC using SPF/PC\n\n DOCUMENTED:  IS03.SHARE.TEXT(@ICOPY)\n              IS03.IDREDIT.HELP(@ICOPY)\n              http://members.aol/rexx01/txt/@icopy.txt\n\n OPTIONS:\n     LPTR-Dest-Range | ENTIRE   (required) Line pointer range.\n     LPTR-Source-Pair | membername | BLANK\n               The source of the material to be copied.  The use\n               of BLANK indicate a single blank line.  You may\n               not copy a membername named BLANK, nor X, nor NX.\n     AFTER     Source lines or membername copied AFTER each dest\n               line.  AFTER is the default if BEFORE not specified.\n     BEFORE    Source lines or membername copied BEFORE each dest line.\n\n     X         Affects only lines that are EXCLUDED from the display\n     NX        Affects  only  lines  that  are NOT EXCLUDED from the\n               display.\n\n ************************************************************/\n Address 'ISREDIT'; 'MACRO (PARMS)';\n NOTE = 'LINE_BEFORE .zfirst = NOTELINE '\n blank=''; debug=''; entire=''; memb=''; help=''; labc=''; labd='';\n labf=''; labl=''; nx=''; x=''; test=''; zedsmsg=''; zedlmsg=''\n file='';before=''; after=''; iii=0;dataline='DATALINE'\n insertc=0;\n\n /* Collect Parameters */\n if parms = '' then do;  /* no parameters -- default to a test*/\n    test='TEST'; labf = '.ZFIRST'; labl = '.ZLAST'; BLANK = 'BLANK'\n    after='AFTER'; signal start;\n end\n\n do iii = 1 to 8;\n   token = word(parms,iii)\n   if token = '' then leave\n   token = translate(token); tokenx = ' '||token||' '\n   i = pos(tokenx,' ALL NEXT FIRST LAST PREV RIGHT ')\n   if i \\= 0 then do;\n      zedsmsg = token 'invalid, RC=8'\n      zedlmsg = token 'not allowed ALL NEXT FIRST LAST PREV RIGHT'\n      call reporter 042; exit 8\n   end;\n   j = pos(tokenx,' AFTER BEFORE BLANK DEBUG ENTIRE HELP NX TEST X ')\n   if j \\= 0 then do;\n      string = token ' = '''token''''\n      interpret  string\n      iterate iii\n   end;\n   if substr(token,1,1) = '.' then do\n      select\n         when labf = '' then labf = token\n         when labl = '' then labl = token\n         when labc = '' then labc = token\n         when labd = '' then labd = token\n         otherwise\n            zedsmsg = '.LABEL RC=8'\n            zedlmsg = 'too many labels --' labf labl labc labd token\n            call reporter\n            exit 8\n      end /* select */\n      iterate iii\n   end\n\n   if file <> '' then do;\n      zedsmsg = 'multi files' token file\n      zedlmsg = 'attempt to use multiple members/files, limit is one'\n      call reporter 053; exit 8\n   end;\n   file = token\n end iii\n fini0: nop\n\n if labl  = '' then do;\n    zedsmsg = '.labels rc=8'\n    zedlmsg = 'Label range is required'\n    call reporter 062; exit 8\n end;\n\n/* Process collected parameters */\nstart: ,\n '(LABFNO) = LINENUM' labf\n '(LABLNO) = LINENUM' labl\n insert.='';\n if labd ='' then if file = '' then if blank='' then do;\n     zedsmsg = 'Insert?'\n     zedlmsg = 'Insert cards missing: BLANK | filename | insert range'\n     call reporter 70; blank = 'BLANK'; test='TEST'\n end;\n if test = 'TEST' then dataline = 'NOTELINE'\n\n if blank = 'BLANK' then do; insert.1 = ' ';insertc=1; end;\n else if file \\= '' then nop\n else if labd \\= '' then do;\n    '(LABCNO) = LINENUM' labc\n    '(LABDNO) = LINENUM' labd\n    insertc = labdno + 1 - labcno\n    if labcno > labdno then do;\n       zedsmsg=labc '>' labd\n       zedlmsg='labels out of order,' zedsmsg\n       call reporter 082; exit 8\n    end;\n    j=0\n    do i=labcno to labdno;\n       '(LINE) = line' i\n       j=j+1;insert.j = line\n       /* insertc has already been set */\n    end;\n end;\n\n if before = '' then if after = '' then after = 'AFTER'\n usenxt = lablno; xnx = x||nx;\n\n /* Process the lines in the selected range */\n lup1: nop\n      if usenxt < labfno | usenxt = 0 then do;\n        zedsmsg = 'completed RC=0';\n        zedlmsg = '@ICOPY completed successfully, RC=0'\n        call reporter 000; exit 0\n      end\n      i = usenxt\n      usenxt = usenxt - 1\n      if xnx \\= '' then do\n         '(xstatus) = xstatus' i\n         if xnx   \\= xstatus then signal nxti\n      end\n      if 'AFTER' = after then do\n         if insertc = 0  then 'copy' file 'after' i\n         else do ii = insertc to 1 by -1\n            x = insert.ii\n            \"LINE_AFTER\" i \"=\" DATALINE \"(X)\"\n         end\n      end\n      if 'BEFORE' = before then do\n         /* usenxt is the previous line should work if usenxt=0*/\n         if insertc = 0 then 'copy' file 'before' i\n         else do ii = 1 to insertc;\n            x = insert.ii\n            \"LINE_BEFORE\" i \"=\" DATALINE \"(X)\"\n            i = i + 1;\n         end;\n      end\n  nxti: signal lup1  /* usenxt has already been set*/\n   exit 0\n\n reporter: arg arx;   note '(zedsmsg)'; note '(zedlmsg)';\n     /* ISPEXEC not available on OS2 in SPF2 or SPFPC */\n     ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n return;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@INFO": {"ttr": 2326, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x07\\x00\\x07\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "MCRITCH"}, "text": "/*  Pass parameters to NOTELINE and place before .zfirst (REXX)*/\nADDRESS \"ISREDIT\"\n\"macro (note)\"\n\"(notecaps) = caps\"\n\"caps off\"\n\"line_before .zfirst = infoline (note)\"\n\"caps\" notecaps\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@LAB": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x08\\x00\\x08\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "MCRITCH"}, "text": "/**REXX**** LABEL LINE THAT THE CURS IN ON AS <TOK> ****************/\n ADDRESS 'ISREDIT'; 'MACRO (TOK1)';\n \"LABEL .ZCSR =\" TOK1 \"0\"\n EXIT RC\n/* @LAB:  F. DAVID MCRITCHIE--\"THE REXX MACROS TOOLBOX\"--1989/08/17, REXX 1993/0\n   LABEL LINE THAT THE CURSOR IS ON AS <TOK1>\n   DESIGNED TO BE USABLE ON A PFKEY  (ALSO IS SHORT FOR A CLISTNAME) **\n   X ALL;F FIRST :TABLE 1;@LAB .A;F LAST :ETABLE 1;RESET .A .ZCSR ****/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@LISTRP": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00/\\x00/\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "MCRITCH"}, "text": "/*REXX -- MAKE  %LISTRP  LISTING INTO SCRIPTABLE MATERIAL*/\nADDRESS \"ISREDIT\";\"MACRO (PARM)\"\nPARM = TRANSLATE(PARM)\n\"LINE_AFTER .ZL = DATALINE \"\".* ===> @SCRIPT DOWN  \",\n     \"--Corporate SITE ONLY--FP(1)\"\"\"\n\"LINE_AFTER .ZL = DATALINE \"\".* CREATED BY @LISTRP CLIST\"\"\"\n\"LINE_AFTER .ZL = DATALINE \"\"                           \"\"\"\n\"(VAR037) = LINENUM .ZLAST\";FIRST = VAR037 + 4\n\"@STRAP  LISTRP \" PARM \" DISPLAY\"\n\"LABEL\" VAR037 \"= .A      0\"\n\"LABEL\" \".ZLAST = .B      0\"\n\"UNGML\"\n\"LINE_BEFORE .a = DATALINE \"\".fo off fold\"\"\"\n\"LINE_BEFORE .A = DATALINE \"\".dm separate on\"\"\"\n\"LINE_BEFORE .A = DATALINE \"\".hr left right;.kp off\"\"\"\n\"LINE_BEFORE .A = DATALINE \"\".if 38PP = &&&&$PDEV.\",\n     ||\";.th .kp on;.el .kp 30\"\"\"\n\"LINE_BEFORE .A = DATALINE \"\".hr left right\"\"\"\n\"LINE_BEFORE .A = DATALINE \"\".dm off\"\"\"\n\"LINE_BEFORE .A = DATALINE \"\".if 38PPx = &&&&$PDEV.x;.th .pm .3i .3i\"\"\"\n\"LINE_BEFORE .A = DATALINE \"\".th .bf gt20 =\"\"\"\n\"LINE_BEFORE .A = DATALINE \"\".llmax;.twocol\"\"\"\n\"LINE_BEFORE .A = DATALINE \"\".vr &&&&$CL.;.ir 2\"\"\"\n\"LINE_BEFORE .A = DATALINE \"\".sv off\"\"\"\n\"LINE_BEFORE .A = DATALINE \"\" Created using ==> @LISTRP \" PARM \"\"\"\"\n\"LINE_BEFORE .A = DATALINE \"\"   by \" SYSVAR(SYSUID) \" on \",\n    DATE('U') \" at \" TIME('N')\"\"\"\"\n\"x all\"\n\"change 1 .a .b all '* * * * * * * *' '.separate;.* * * *'\"\n\"c all .a .b nx p'^' ' '\"\n\"c all .a .b 1 nx ' ' '.separate;.* -- * * * * * * * * * *'\"\n\"x all\"\n\"find .a .b all \"\" NO CATEGORIES\"\"\"\n\"find .a .b all \"\" NO SECURITY LEVEL\"\"\"\n\"find .a .b all \"\" NO SECURITY LEVEL\"\"\"\n\"find .a .b all \"\" NO ENTRIES IN CONDITIONAL ACCESS LIST\"\"\"\n\"nxnx before(2) after(1)\"\n\"del nx all\"\n\"find .a .b all \"\" NO installation data\"\"\"\n\"find .a .b all \"\"COMMAND INVOKING @STRAP CLIST MACRO\"\"\"\n\"find .a .b all \"\"==> TSO LISTRP\"\"\"\n\"nxnx after(1)\"\n\"del nx all\"\n\"Find 'ARE NOT RACF PROTECTED'\"\nIF RC = 0 then\n  \"LINE_BEFORE .ZCSR = DATALINE \" ,\n     \"\"\".hr left right;.kp off;.vr off;.sc;.sk 1 p\"\"\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@NOTE": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x07\\x00\\x07\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "MCRITCH"}, "text": "/*  Pass parameters to NOTELINE and place before .zfirst (REXX)*/\nADDRESS \"ISREDIT\"\n\"macro (note)\"\n\"(notecaps) = caps\"\n\"caps off\"\n\"line_before .zfirst = noteline (note)\"\n\"caps\" notecaps\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@PRINT": {"ttr": 2567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x024\\x024\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 564, "newlines": 564, "modlines": 0, "user": "MCRITCH"}, "text": "            CONTROL ASIS\n ISREDIT  MACRO (TOK1,TOK2,TOK3,TOK4,TOK5,TOK6,TOK7,TOK8,TOK9,TOK10,+\n           TOK11,TOK12,TOK13,TOK14,TOK15,TOK16,TOK17,TOK18,TOK19,+\n           TOK20,TOK21,TOK22,TOK23,TOK24,TOK25,TOK26,TOK27,TOK28,+\n           TOK29,TOK30,TOK31,TOK32,TOK33,TOK34,TOK35,TOK36,TOK37)\n/* TO PRINT IN PORTRAIT FASHION\n/* ===TESTING ON SCRIPT  PAPER\n/*  ===>  @PRINT CLASS(X) FORMDEF(0101PA) PAGEDEF(08080) -- THIS WORKS.\n/* ===TESTING ON REGULAR PAPER\n/*  ===>  @PRINT CLASS(X) FORMDEF(0101LA) PAGEDEF(08081) -- I THINK SO.\n    /* PURPOSE: TSO PRINTOFF FOR MEMBER CURRENTLY DISPLAYED IN EDIT\n    /* CONTRIBUTED:   F. DAVID MCRITCHIE             1986/02/04\n    /* USER CONTACT:  F. DAVID MCRITCHIE\n    /* CODE MAINT.:   SYSTECH GROUP\n  /**************************************************************\n  /* DOCUMENTED  IS03.SHARE.TEXT(@PRINT)\n  /* EXAMPLES: ...\n  /*   ==> @PRINT                   GOES TO BWATER 3800\n  /*   ==> @PRINT DOWN | DOWN8      GOES TO BWATER 3800-5 CLASS=2\n  /*   ==> @PRINT DOWN10            GOES TO BWATER 3800-5 CLASS=2\n  /*   ==> @PRINT DEST(P100E)       GOES TO SYSTECH PRINTER\n  /*   ==> @PRINT SYSTECH           GOES TO SYSTECH PRINTER\n  /*   ==> @PRINT PROFS(MCRITCHI)\n  /*       USES IEBGENER TO SYSUT2 ALLOCATED DEST(BXXXXXXX.MCRITCHI)\n  /*   ==> @PRINT PROFS(MCRITCHI) BATCH\n  /*   SAME AS ==> @PRINT DEST(BXXXXXXX.MCRITCHI) BATCH\n  /*   ==> @PRINT DEST(CGDL2)       DALLAS --- XEROX PRINTER\n  /*   ==> @PRINT OPTCD=J  | OPTCD  | OPTCD(J)\n  /*   ==> @PRINT TEST              TELL OPTIONS DO NOTHING\n  /*\n  /* THE FOLLOWING ARE OPTIONAL TO THE NON-BATCH  COMMAND PRINTOFF\n  /*    LIST/NOLIST PRINT/NOPRINT FOLD/NOFOLD\n  /* THE FOLLOWING ARE OPTIONAL BOTH TO PRINTOFF AND TO BATCH JOB\n  /*    CLASS(X)  DEST(XXXXXX) COPIES(X) VOLUME(XXXXXX) VOL(XXXXXX)\n  /*    HOLD/NOHOLD\n  /* THE FOLLOWING WITH NOTHING ELSE WILL ALLOW IEBGENER TO BE USED\n  /*         IN PREFERENCE TO GENERATING A BATCH JOB\n  /*    PROFS(XXXXX)     <ANYTHING ADDITIONAL WILL CAUSE A BATCH JOB>\n  /* THE FOLLOWING OPTIONS WILL CAUSE A BATCH JOB TO BE USED\n  /*    CHARS(XXXX) GENERATES     CHARS=XXXX,\n  /*    DOWN    GENERATES   PAGEDEF=08081,CLASS=2,CHARS=GT15,  08081\n  /*    MA          GENERATES   PAGEDEF=M13280,CLASS=2,CHARS=GT20,\n  /*    MD          GENERATES   PAGEDEF=M132C1,CLASS=2,CHARS=GT20,\n  /*    FCB(XXXX)   GENERATES   FCB=XXXX,\n  /*    GTXX        GENERATES   FCB=XXXX,\n  /*    OPTCD...    GENERATES   DCB=OPTCD=J,\n  /*    PAGEDEF(XX) GENERATES   PAGEDEF=XX,\n  /*    PAGEDEF(XXXX)   GENERATES  PAGEDEF=XXXX,  ON OUTPUT STATMENT\n  /*    SCRIPT  WHICH IMPLIES   FCB=8X11,CHARS=GT12,\n  /****************************************************************\n SET PROFS = &STR(//)&STR(*)\n SET NPROFS = &STR()\n ISREDIT  LINE_BEFORE .ZFIRST = -\n    NOTELINE \"&SYSTIME. @PRINT &TOK1 &TOK2 &TOK3 &TOK4 &TOK5 &TOK6 +\n      &TOK7 &TOK8 &TOK9 &TOK10 &TOK11 &TOK12 &TOK13 \"\n        SET BLANKS = &STR(                          )\n    ISREDIT (DSNX) = DATASET\n    ISREDIT (MEMBERX) = MEMBER\n        IF &STR(&MEMBERX) = &STR() THEN SET DSNXX = &DSNX\n        ELSE SET DSNXX = &DSNX(&MEMBERX)\n    ISREDIT (DCHG) = DATA_CHANGED\n /* OUTPUT FOR CLASS = A    UNLESS  SCRIPT,         */\n /*           IN WHICH CASE IT OUTPUTS TO CLASS Y   */\n    ISREDIT (VAR016) = DATA_WIDTH\n    SET COPIES = 1\n    SET MSGCLASS = 9\n    SET RP = &STR()\n    IF &DCHG = YES THEN DO\n       WRITE ******************************************************\n       WRITE * YOUR FILE HAS NOT BEEN SAVED AFTER MAKING CHANGES  *\n       WRITE *                                                    *\n       WRITE * THE FILE PRINTED WILL NOT REFLECT CHANGES MADE IN  *\n       WRITE *       THE  CURRENT EDIT SESSION                    *\n       WRITE ******************************************************\n       WRITE REPLY <ENTER KEY> TO PRINT OLD VERSION\n       WRITE REPLY \"SAVE\"   | \"SAV\" TO SAVE THEN PRINT SAVED VERSION\n       WRITE REPLY \"CANCEL\" | \"CAN\" IF YOU DO NOT WANT TO PRINT THE OLD\n       READ PARM1\n       IF &SUBSTR(1:3,&STR(&SYSCAPS(&PARM1.)   )) = CAN THEN DO\n          WRITE TERMINATED BY YOUR COMMAND ... \"CAN\".\n          SET &ZEDSMSG = &STR(TERMINATED)\n          SET &XEDLMSG = &STR(CHANGES DONE SINCE LAST SAVE -- +\n                      YOU HAVE REPLIED TO CANCEL @PRINT)\n          SET &ZEDLMSG = &STR(&XEDLMSG.)\n          ISPEXEC     SETMSG MSG(ISRZ000)\n          EXIT CODE(8)\n       END\n       IF &SUBSTR(1:3,&STR(&SYSCAPS(&PARM1.)   )) = SAV THEN DO\n          ISREDIT SAVE\n          SET RC = &LASTCC.\n          /* 0 - NORMAL SAVE, 4 - NEW MEMBER SAVED, 12 DATA NOT SAVED\n          IF &RC. > 4  THEN DO\n           WRITE ******************************************************\n           WRITE * UNABLE TO SAVE YOUR FILE   RC = &RC.               *\n           WRITE ******************************************************\n           SET &ZEDSMSG = &STR(TERMINATED)\n           SET &XEDLMSG = &STR(UNABLE TO SAVE CHANGES -- +\n                       PERHAPS A COMPRESS IS NEEDED)\n           SET &ZEDLMSG = &STR(&XEDLMSG.)\n           ISPEXEC     SETMSG MSG(ISRZ000)\n           EXIT CODE(8)\n          END\n          GOTO SAVED\n       END\n       SET &ZEDSMSG = &STR(PRINTED/OLD CONTENT)\n       SET &XEDLMSG = &STR(CHANGES DONE SINCE LAST SAVE -- +\n                   CONTENT PRINTED NOT SAME AS DISPLAYED...)\n       SET &ZEDLMSG = &STR(&XEDLMSG.)\n      ISPEXEC     SETMSG MSG(ISRZ000)\n    END\n  SAVED: -\n    IF &STR(&DSNX) = &STR() THEN -\n       EXIT CODE(12)\n        SET BLANKS = &STR(&BLANKS&BLANKS)\n        SET BLANKS = &STR(&BLANKS&BLANKS)\n        SET BLANKS = &STR(&BLANKS&BLANKS)\n        SET LP = &STR((\n        SET RP = &STR())\n        SET N0 = 20\n        SET N  = 0\n        SET I = 0\n        SET L = 0\n        /*********\n        SET I = 1\n       DO WHILE &I <= 100\n        SET TOKEN = &&TOK&I\n        SET TOKEN = &STR(&SYSCAPS(&TOKEN))\n        IF DEBUG = &DEBUG THEN WRITE  &I  TOK&&I=&&TOK&I  TOKEN=&TOKEN\n        IF &STR(&TOKEN) = &STR() THEN GOTO END_TOK\n        IF ALL = &STR(&TOKEN) | NEXT = &STR(&TOKEN) | FIRST = +\n          &STR(&TOKEN) | LAST = &STR(&TOKEN) | PREV = &STR(&TOKEN) +\n            THEN DO\n          SET &ZEDSMSG = &STR(&TOKEN INVALID)\n          SET &ZEDLMSG = &STR(\"&TOKEN\" NOT PROVIDED FOR NOR ARE NEXT +\n            ALL FIRST LAST PREV)\n          ISPEXEC   SETMSG MSG(ISRZ000)\n          EXIT CODE(12)\n        END\n        IF TEST =  &STR(&TOKEN) THEN DO\n            SET TEST = TEST\n            GOTO NXT_TOK\n        END\n        IF OUTDES = &STR(&TOKEN) THEN DO\n            SET OUTDES = OUTDES\n            GOTO NXT_TOK\n        END\n        IF 3900 =  &STR(&TOKEN) THEN DO\n            SET WRITER = &STR(,WRITER=T3900)\n            SET BATCH = BATCH\n            SET MSGCLASS = T\n            SET CLASS = X\n            GOTO NXT_TOK\n        END\n        IF &STR(&TOKEN) = SYSTECH | &STR(&TOKEN) = P100E | +\n          &STR(&TOKEN) = TECH -\n                                  | &STR(&TOKEN) = SYSTECH THEN DO\n           SET TOK&I = DEST(P100E&RP.\n           SET DESTG = &STR(AHCENTER.P100E)\n           SET DESTJ = &STR(DEST=AHCENTER.P100E,)\n           SET BATCH = BATCH\n           GOTO NXT_TOK\n        END\n        IF &STR(&TOKEN) = SYSTECHL | &STR(&TOKEN) = PU00L | +\n          &STR(&TOKEN) = TECHL -\n                                  | &STR(&TOKEN) = SYSTECHL THEN DO\n           SET TOK&I = DEST(PU00L&RP.\n           SET DESTG = &STR(AHCENTER.PU00L)\n           SET DESTJ = &STR(DEST=AHCENTER.PU00L,)\n           SET BATCH = BATCH\n           GOTO NXT_TOK\n        END\n        IF SCRIPT = &STR(&TOKEN) THEN DO\n           IF &STR(&CHARS) = THEN SET CHARS = &STR(CHARS=GT12,)\n           IF &STR(&FCB) = THEN SET  FCB = &STR(FCB=8X11,)\n           IF &STR(&CLASS) = THEN SET  CLASS = Y\n           SET BATCH = BATCH\n           GOTO NXT_TOK\n        END\n        IF DOWN8 = &STR(&TOKEN) THEN -\n             IF &STR(&CHARS.) = &STR() THEN DO\n                IF &VAR016 > 83 THEN DO\n                   ISREDIT SEEK FIRST 84 &VAR016. P'^'\n                   IF &LASTCC = 0 THEN SET CHARS = &STR(CHARS=GT15,)\n                   ELSE SET CHARS = &STR(CHARS=GT12,)\n                END\n                ELSE SET CHARS = &STR(CHARS=GT12,)\n             END\n             ELSE DO\n                IF &STR(&CHARS.) = GT20 THEN DO\n                   IF &STR(&LINECT) = THEN SET  LINECT = 0\n                END\n             END\n        IF DOWN = &STR(&TOKEN) THEN DO\n           IF &STR(&CHARS.) = &STR() THEN DO\n              IF &VAR016 > 90 THEN DO\n                 ISREDIT SEEK FIRST 91 &VAR016. P'^'\n                 IF &LASTCC = 0 THEN SET CHARS = &STR(CHARS=GT15,)\n                 ELSE SET CHARS = &STR(CHARS=GT12,)\n              END\n              ELSE SET CHARS = &STR(CHARS=GT12,)\n           END\n           IF &STR(&CHARS) = THEN SET CHARS = &STR(CHARS=GT15,)\n           IF &STR(&PAGEDEF) = THEN SET PAGEDEF = &STR(PAGEDEF=08081,)\n           IF &STR(&LINECT) = THEN SET  LINECT = 77\n           IF &STR(&CLASS) = THEN SET  CLASS = 2\n           SET BATCH = BATCH\n           GOTO NXT_TOK\n        END\n        IF IDATA = &STR(&TOKEN) THEN DO\n          IF &STR(&CHARS) = THEN SET CHARS = &STR(CHARS=GT15,)\n          IF &STR(&PAGEDEF) = THEN SET PAGEDEF = &STR(PAGEDEF=A08682,)\n          /* A08682 IS 86LINE/PAGE,   A06462 IS 64 LINES /PAGE*/\n          IF &STR(&FORMDEF) = THEN SET FORMDEF = &STR(FORMDEF=A10110,)\n          IF &STR(&LINECT) = THEN SET  LINECT = 86\n          IF &STR(&CLASS) = THEN SET  CLASS = S\n          SET BATCH = BATCH\n          GOTO NXT_TOK\n        END\n        IF DOWN8 = &STR(&TOKEN) +\n        | DOWN10 = &STR(&TOKEN) THEN DO\n          IF &STR(&CHARS) = THEN SET CHARS = &STR(CHARS=GT15,)\n          IF &STR(&PAGEDEF) = THEN SET PAGEDEF = &STR(PAGEDEF=&TOKEN.,)\n          IF &STR(&LINECT) = THEN SET  LINECT = 77\n          IF &STR(&CLASS) = THEN SET  CLASS = A\n          SET BATCH = BATCH\n          GOTO NXT_TOK\n        END\n        IF MA   = &STR(&TOKEN) THEN DO   /* MULIPLE-ACROSS */\n           IF &STR(&CHARS) = THEN SET CHARS = &STR(CHARS=GT20,)\n           IF &STR(&PAGEDEF) = THEN SET PAGEDEF = &STR(PAGEDEF=M13280,)\n           IF &STR(&CLASS) = THEN SET  CLASS = A\n           SET BATCH = BATCH\n           GOTO NXT_TOK\n        END\n        IF MD   = &STR(&TOKEN) THEN DO   /* MULIPLE-DOWN   */\n           IF &STR(&CHARS) = THEN SET CHARS = &STR(CHARS=GT20,)\n           IF &STR(&PAGEDEF) = THEN SET PAGEDEF = &STR(PAGEDEF=M132C1,)\n           IF &STR(&CLASS) = THEN SET  CLASS = A\n           SET BATCH = BATCH\n           GOTO NXT_TOK\n        END\n        IF &STR(GT) = &SUBSTR(1:2,&STR(&TOKEN)  )  THEN DO\n           /* E.G.  GT10 GT12 GT15 GT20 GT24 */\n           SET CHARS = &STR(CHARS=&TOKEN.,)\n           SET BATCH = BATCH\n           GOTO NXT_TOK\n        END\n        IF HELP = &STR(&TOKEN) | BATCH = &STR(&TOKEN) -\n           THEN DO\n             SET &&TOKEN.    = &STR(&TOKEN)\n             IF DEBUG = &DEBUG THEN WRITE  &I  TOK&I=&TOK&&I  +\n               TOKEN=&TOKEN\n             GOTO NXT_TOK\n           END\n        IF HOLD = &STR(&TOKEN) THEN DO\n             SET HOLD = &STR(HOLD=YES,)\n             GOTO NXT_TOK\n        END\n        IF NOHOLD = &STR(&TOKEN) THEN DO\n             SET HOLD = &STR(HOLD=NO,)\n             GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:9,&STR(&TOKEN)         ) = +\n         &STR(MSGCLASS&STR(&LP)) THEN DO\n           SET MSGCLASS = &SUBSTR(10:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n             &STR(&TOKEN)        )\n           SET BATCH = BATCH\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:8,&STR(&TOKEN)        ) = &STR(PAGEDEF&STR(&LP)) +\n          THEN DO\n           SET PAGEDEF = &SUBSTR(9:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n             &STR(&TOKEN)        )\n           IF &LENGTH(&PAGEDEF.) > 6 THEN DO\n              SET &ZEDSMSG = &STR(PAGEDEF= INVALID)\n              SET &ZEDLMSG = &STR(&PAGEDEF. EXECEEDS 6 CHAR. LIMIT, +\n                  EXAMPLES:  8X85 08080  8X11 08081\n              ISPEXEC     SETMSG MSG(ISRZ000)\n              EXIT CODE(12)\n           END\n           SET PAGEDEF = &STR(PAGEDEF=&PAGEDEF.,)\n           SET BATCH = BATCH\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:8,&STR(&TOKEN)        ) = &STR(FORMDEF&STR(&LP)) +\n          THEN DO\n           SET FORMDEF = &SUBSTR(9:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n             &STR(&TOKEN)        )\n           IF &LENGTH(&FORMDEF.) > 6 THEN DO\n              SET &ZEDSMSG = &STR(FORMDEF= INVALID)\n              SET &ZEDLMSG = &STR(&FORMDEF. EXECEEDS 6 CHAR. LIMIT, +\n                 EXAMPLES: 0101LA 0101PA 0101PD 0101LA 0101LD)\n              ISPEXEC     SETMSG MSG(ISRZ000)\n              EXIT CODE(12)\n           END\n           SET FORMDEF = &STR(FORMDEF=&FORMDEF.,)\n           SET BATCH = BATCH\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:7,&STR(&TOKEN)       ) = &STR(LINECT&STR(&LP)) +\n          THEN DO\n           SET LINECT = &SUBSTR(8:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n             &STR(&TOKEN)        )\n           SET BATCH = BATCH\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:7,&STR(&TOKEN)       ) = &STR(WRITER&STR(&LP)) +\n          THEN DO\n           SET WRITER = &SUBSTR(8:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n             &STR(&TOKEN)        )\n           WRITE PLEASE USE  WTR(&WRITER.) INSTEAD OF WRITER(&WRITER.)\n           SET WRITER = &STR(WRITER=&WRITER,)\n           SET BATCH = BATCH\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:4,&STR(&TOKEN)       ) = &STR(WTR&STR(&LP)) +\n          THEN DO\n           SET WRITER = &SUBSTR(5:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n             &STR(&TOKEN)        )\n           SET WRITER = &STR(WRITER=&WRITER,)\n           SET BATCH = BATCH\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:7,&STR(&TOKEN)       ) = &STR(COPIES&STR(&LP)) +\n          THEN DO\n           SET COPIES = &SUBSTR(8:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n             &STR(&TOKEN)        )\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:5,&STR(&TOKEN)       ) = &STR(OPTCD) +\n          THEN DO\n           SET OPTCD =  &STR(,DCB=OPTCD=J,CHARS=&LP.GT15,GB15&RP.)\n           SET BATCH = BATCH\n           ISREDIT SEEK FIRST 2 '1'\n           IF &LASTCC ^= 0 THEN DO\n              ISREDIT LINE_BEFORE .ZF = NOTELINE +\n                  \"THERE IS NO '1' IN COLUMN 2 OF ANY LINE\"\n              ISREDIT LINE_BEFORE .ZF = NOTELINE +\n                  \" USE OF '0' AND '1' ARE EXPECTED AS VALUES\"\n              WRITE WARNING -- THERE IS NO \"1\" IN COLUMN 2 OF ANY LINE\n              WRITE WARNING --   USE OF \"0\" AND \"1\" ARE EXPECTED +\n                     AS VALUES\n              SET &ZEDSMSG = &STR(OPTCD? QUESTIONABLE)\n              SET &ZEDLMSG = &STR(NO \"1\" IN COLUMN 2 OF ANY LINE)\n              ISREDIT LINE_BEFORE &REFBEG. = +\n                       NOTELINE \"*ERROR** &XEDLMSG.\"\n              ISPEXEC SETMSG MSG(ISRZ000)\n           END\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:6,&STR(&TOKEN)       ) = &STR(BEGIN&STR(&LP))  +\n          THEN DO\n           SET BEGIN = &SUBSTR(7:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n             &STR(&TOKEN)         )\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:6,&STR(&TOKEN)       ) = &STR(CHARS&STR(&LP))  +\n          THEN DO\n           SET CHARS = &SUBSTR(7:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n             &STR(&TOKEN)         )\n           SET CHARS = &STR(CHARS=&CHARS.,)\n           SET BATCH = BATCH\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:5,&STR(&TOKEN)       ) = &STR(CHARS&STR(&LP))  +\n          THEN DO\n           SET CHARS = &SUBSTR(6:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n             &STR(&TOKEN)         )\n           WRITE **PLEASE USE  CHARS(&CHARS.) -- CHAR IS INVALID.\n           EXIT CODE(12)\n           SET CHARS = &STR(CHARS=&CHARS.,)\n           SET BATCH = BATCH\n           WRITE PLEASE USE &CHARS\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:6,&STR(&TOKEN)       ) = &STR(CLASS&STR(&LP))  +\n          THEN DO\n           SET CLASS = &SUBSTR(7:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n             &STR(&TOKEN)         )\n           SET BATCH = BATCH\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:6,&STR(&TOKEN)       ) = &STR(PROFS&STR(&LP))  +\n          THEN DO\n           SET PROFS = &STR()\n           SET NPROFS = &STR(/)&STR(/)&STR(*)\n           SET MSGCLASS = T\n           SET DEST  = &SUBSTR(7:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n             &STR(&TOKEN)         )\n           SET IX = &SYSINDEX(.,&STR(&DEST.))\n           IF &EVAL(&IX.) = &EVAL(0) THEN DO\n                 SET DEST = &STR(BXXXXXXX.&DEST.)\n                 WRITE 'MSMAILNE ADDRESSES ARE NOT AVAILABLE IN THIS MANNER'\n                 /* FOR MSMAIL USING THE APPLICATION TOOLS PACKAGE...*/\n                 /*   WOULD NEED VALID, FROM ADDRESSEE AND A SUBJECT */\n           END\n           IF &STR(&CLASS.) = &STR() THEN SET CLASS = Z\n           SET GENER = GENER\n           SET DESTG = &STR(&DEST.)\n           SET DESTJ = &STR(DEST=&DEST.,)\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:5,&STR(&TOKEN)       ) = &STR(DEST&STR(&LP))  +\n          THEN DO\n           SET DEST = &SUBSTR(6:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n             &STR(&TOKEN)         )\n           IF DALLAS = &STR(&DEST.) | CCC = &STR(&DEST.) | +\n                XEROX = &STR(&DEST.) THEN DO\n              WRITE CHANGED FROM DEST(&DEST.) TO DEST(CGDL2)\n              SET DEST = CGDL2\n           END\n           SET IX = &SYSINDEX(.,&STR(&DEST.))\n           IF &IX > 0 THEN SET BATCH = BATCH\n           SET DESTG = &STR(&DEST.)\n           SET DESTJ = &STR(DEST=&DEST.,)\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:4,&STR(&TOKEN)       ) = &STR(FCB&STR(&LP))  +\n          THEN DO\n           SET FCB = &SUBSTR(5:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n             &STR(&TOKEN)         )\n           SET FCB = &STR(FCB=&FCB.,)\n           SET BATCH = BATCH\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:4,&STR(&TOKEN)       ) = &STR(VOL&STR(&LP))  +\n          THEN DO\n           SET VOL = &SUBSTR(5:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n             &STR(&TOKEN)         )\n           SET VOL = &STR(UNIT=3380,VOL=SER=&VOL,)\n           GOTO NXT_TOK\n        END\n        SET REMAIN = &STR(&REMAIN &STR(&TOKEN))\n        WRITE  REMAIN = &STR(&REMAIN &STR(&TOKEN))\n NXT_TOK: -\n        SET I = &I + 1\n      END\n END_TOK: SET I = &I\n      /****************************************************************\n      /****************************************************************\n    IF &STR(&OUTDES.) NE &STR() THEN DO\n       WRITE &CHARS. &PAGEDEF.\n       EXIT CODE(1)\n    END\n    IF &STR(&PAGEDEF.) NE &STR() THEN DO\n       SET BATCH = BATCH\n       SET FCB =\n       IF &STR(&CHARS.&PAGEDEF.) = &STR(CHARS=GT10,PAGEDEF=08081,) +\n       THEN DO\n         WRITE ***************************************************\n         WRITE WARNING GT10 MAY RESULT IN LINE LOSS AT TOP OF PAGE\n         WRITE ***************************************************\n         ISREDIT LINE_BEFORE .ZF = NOTELINE +\n            \"WARNING GT10 MAY RESULT IN LOSS OF LINES AT TOP OF PAGE\"\n        SET WARN = &STR(--WARNING GT10 MAY RESULT PAGE TOP LINE LOSSES)\n       END\n    END\n    IF BATCH = &BATCH THEN DO\n       ISREDIT LINE_BEFORE .ZF = NOTELINE \"-- IF YOU ARE +\n          ALLOCATED EXCLUSIVELY TO THIS DATASET YOU MAY HAVE \"\n       ISREDIT LINE_BEFORE .ZF = NOTELINE +\n         \"&RBL. TO EXIT OUT OF THE DATASET -- FOR THE BATCH JOB TO RUN\"\n       IF &MEMBERX. = &STR() THEN -\n         ISREDIT LINE_BEFORE .ZF = NOTELINE +\n         \"&RBL. SEQUENTIAL DATASETS ARE MORE LIKELY TO BE ENQUEUED ON\"\n       ISREDIT LOC 0\n       GOTO SCRIPT\n    END\n    IF GENER = &GENER THEN GOTO GENERX\n   /* ***************************************************************\n    IF &STR(&MEMBERX) = &STR() THEN DO\n       PRINTOFF '&DSNX' -\n             &TOK1 &TOK2 &TOK3 &TOK4 &TOK5 &TOK6 &TOK7 &TOK8 &TOK9 +\n               &TOK10 &TOK11 &TOK12 &TOK13\n       EXIT CODE(0)\n    END\n    IF DEBUG = &DEBUG THEN CONTROL LIST CONLIST SYMLIST\n    PRINTOFF '&DSNX(&MEMBERX)' -\n             &TOK1 &TOK2 &TOK3 &TOK4 &TOK5 &TOK6 &TOK7 &TOK8 &TOK9 +\n               &TOK10 &TOK11 &TOK12 &TOK13\n    EXIT CODE(0)\n  /********************************************************************\n    /* ALLOCATE DOES NOT WORK FOR A PRINTER ONLY A USER */\n    /*  THIS WOULD WORK FOR   BXXXXXXX.MCRITCHI\n    /*  BUT WILL NOT WORK FOR AHCENTER.P100E     A PRINTER\n    /*  AND WILL NOT WORK FOR AHCENTER.IS03      A TSO USERID\n  GENERX: -\n    IF &STR(&CLASS.) = &STR() THEN SET CLASS = A\n    ALLOC FILE(SYSUT2) DEST(&DESTG.) SYSOUT(&CLASS.) REUSE\n    IF &STR(&MEMBERX) = &STR() THEN -\n      ALLOC FILE(SYSUT1) DA('&DSNX.') SHR REUSE\n    ELSE -\n      ALLOC FILE(SYSUT1) DA('&DSNX(&MEMBERX)') SHR REUSE\n      ALLOC FILE(SYSPRINT) DSNAME(*) REUSE\n    ALLOC FILE(SYSIN)  DUMMY BLKSIZE(80) REUSE\n    OLDGENER\n    SET RC = &LASTCC.\n    WRITE RETURN CODE=&RC.\n    FREE FI(SYSPRINT SYSIN SYSUT1 SYSUT2)\n    ALLOC FI(SYSPRINT) DS(*)\n    ALLOC FI(SYSIN) DS(*)\n    EXIT CODE(1)\n  /********************************************************************\n  /*  BATCH JOB WILL BE SUBMITTED -- MAY OR MAY NOT BE SCRIPT PAPER */\n SCRIPT: -\n    ISPEXEC VGET (TACCT) PROFILE\n    IF &STR(&TACCT) = &STR() THEN DO\n       WRITE PLEASE YOUR SUPPLY 4-DIGIT COST CENTER ACCOUNT NUMBER -- +\n         FOR JOBCARD GENERATION\n     READ TACCT\n     ISPEXEC VPUT (TACCT) PROFILE\n    END\n    ISPEXEC VGET (TACCT) PROFILE\n    IF &STR(&TACCT) = &STR() THEN DO\n       WRITE PLEASE YOUR SUPPLY 4-DIGIT COST CENTER ACCOUNT NUMBER -- +\n         FOR JOBCARD GENERATION\n       READ TACCT\n       ISPEXEC VPUT (TACCT) PROFILE\n    END\n    SET BLANKS = &STR(                             ) +\n       &STR(                                    )\n    SET PRTX = &SUBSTR(1:54,&DSNXX.&BLANKS)\n    SET JOBNAME = &SUBSTR(1:8,&SYSUID.$P&MSGCLASS.&CLASS.        )\n    IF &STR(&CLASS) = THEN SET  CLASS = A\n    ISREDIT LINE_BEFORE .ZF = MSGLINE '&TOK1. &TOK2. &TOK3. +\n        &TOK4. &TOK5. -- LINECT=&LINECT.,CLASS=&CLASS.,+\n        &CHARS&FCB&HOLD.COPIES=&COPIES.&OPTCD -- &SYSTIME.'\n   IF TEST = &TEST THEN EXIT CODE(4)\n   SUBMIT * END($$)\n//&JOBNAME. JOB (&TACCT.),\n//   NOTIFY=&SYSUID.,MSGCLASS=&MSGCLASS.,MSGLEVEL=(1,1),CLASS=X\n/*JOBPARM LINECT=0\n//OUTPUT01 OUTPUT &DESTJ.&CHARS.LINECT=0&LINECT.,\n//   &PAGEDEF.&FORMDEF.&WRITER.CLASS=&CLASS.\n//S1      EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*,DCB=BLKSIZE=605  NORMALLY WON'T PRINT\n&NPROFS.//SYSIN    DD  DUMMY\n//SYSUT1   DD  *\n&RBL.  &STR(&PRTX.)&SYSDATE. &SYSTIME.\n&RBL.  @PRINT &TOK1. &TOK2. &TOK3. &TOK4. &TOK5. +\n       &WARN.  &FCB.\n&RBL.  &PAGEDEF. &FORMDEF. &FCB.\n&RBL.  ===============================================================+\n  =======\n&RBL.  &RBL.\n&PROFS. GENERATE MAXFLDS=2,MAXLITS=2\n&PROFS. RECORD FIELD=(80,1,,1),FIELD=(1,'\u00f8',,81)\n//SYSUT2   DD DSN=&&TEMP,DISP=(,PASS),UNIT=VIO,\n//   DCB=&DSNX\n//S2      EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*,DCB=BLKSIZE=605  NORMALLY WON'T PRINT\n&NPROFS.//SYSIN    DD  DUMMY\n//SYSUT1 DD DSN=&&TEMP,DISP=(OLD,DELETE)  1992/08/23 FROM PASS\n//       DD DSN=&DSNXX,\n//          &VOL.DISP=SHR\n//SYSUT2 DD SYSOUT=(,),&CHARS&FCB&HOLD.COPIES=&COPIES.&OPTCD,\n//   OUTPUT=*.OUTPUT01\n&PROFS. GENERATE MAXFLDS=2,MAXLITS=2\n&PROFS. RECORD FIELD=(80,1,,1),FIELD=(1,'\u00f8',,81)\n$$\nIF IS03 = &SUBSTR(1:4,&SYSUID.XXXX) THEN +\n   WRITE &RBL.  @PRINT &TOK1. &TOK2. &TOK3. &TOK4. &TOK5. +\n      &WARN.  &PAGEDEF. &FORMDEF. &FCB.\n/**********/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@PRINTNX": {"ttr": 2820, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xc2\\x00\\xc2\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 194, "newlines": 194, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- @PRINTNX, Print the NX (displayed) lines             */\n/* created by F.David McRitchie, 1992/10/09,                    */\n/*                                                              */\n/*  SYSTECH as the only parameter will equate to DEST(P100E)    */\n/*  DOWN8   as the only parameter will equate to ...            */\n/*     CHARS(GT15) PAGEDEF(DOWN8) LINECT(77) CLASS(A)           */\n/*  no parameters -- defaults to CLASS(A)                       */\n/*  ECHO -- prints to screen, useful for debugging              */\n/*                                                              */\n/*  Otherwise all parameters are OUTDES parameters              */\n/*    refer to help information for OUTDES                      */\n/*      ===> TSO HELP OUTDES                                    */\n/*      ===> TSO CLIST OUTDES HELP                              */\n/*--------------------------------------------------------------*/\n/* Related clists: PU00L, TECHPS, @PRINTNX, SCRIPTPS,  @SCRIPT  */\n/****************************************************************/\nAddress \"ISREDIT\";\"MACRO (OUTXXX)\"\n      \"(MEMBERX) = MEMBER \"\n      \"(DSNX)    = DATASET\"\n\n      ORIG = outxxx\n      OUTXXX = TRANSLATE(OUTXXX)\n      SYSOUT=\"\"\n      i = index(OUTXXX,'CLASS(')\n      if i /= 0 then do\n         sysout = substr(OUTXXX,I+6,1)\n         OUTXXX = left(OUTXXX,(i-1)) substr(OUTXXX,I+8)\n      end\n      /* outxxx  with a value of \"ECHO\" is for debugging */\n      if outxxx = \"SYSTECH\" then OUTXXX = \"DEST(P100E)\"\n      if outxxx = \"DOWN8\"   then DO; OUTXXX = ,\n         \"CHARS(GT15) PAGEDEF(DOWN8) LINECT(77)\"\n         IF sysout='' then sysout=\"A\"\n      end\n if sysout=\"\" then sysout=\"A\"\n rec = 0;\"(MAXREC) = LINENUM .ZLAST\"\n  q. =\n q.0 = 0;qcnt=0\n unshown = 0\n \"(changed) = data_changed\"\n chg=changed\n if changed = \"NO\" then changed = \"-- DATA NOT CHANGED\"\n Else changed = \"-- DATA UNCHANGED\"\n call givemore\n qcnt=qcnt+1;\n q.qcnt = \"        EDIT ---- \"DSNX\"(\"MEMBERX\") contains\",\n     maxrec\" lines\"\n if OUTXXX /= '' then do\n    status = msg('off')\n    Address \"TSO\" \"FREE OUTDES(NAME1) FI(SYSUT2)\"\n    status = msg('on')\n    address \"TSO\" \"OUTDES NAME1\" OUTXXX\n    Address \"TSO\" \"ALLOC FI(SYSUT2) SYSOUT(\"SYSOUT\")\",\n            \"OUTDES(NAME1)\",\n            \"RECFM(V B A) LRECL(255) BLKSIZE(8920)\"\n    lastrc = RC\n    if lastrc /= 0 then do\n            ZEDSMSG = \"OUTDES RC=\"lastrc\n           ZEDLMSG = \"rc=\"lastrc \"for OUTDES \"OUTXXX\n           \"LINE_BEFORE .ZCSR = NOTELINE (ZEDLMSG)\"\n           ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n           RETURN 1\n    end\n end\n else Address \"TSO\" \"ALLOC FI(SYSUT2) SYSOUT(\"SYSOUT\") \",\n            \"RECFM(V B) LRECL(255) BLKSIZE(8920) REUSE\"\n do rec = 1 to maxrec\n    \"(XSTATUS) = XSTATUS\" REC\n    if XSTATUS = \"X\" then do\n       if unshown = 0 then qfrom = rec + 0\n       unshown = unshown + 1\n    end\n    else do\n       if unshown /= 0 then do\n          recm1 = rec - 1\n          qcnt=qcnt+1;\n          q.qcnt = \"        - - - - - - - - -\" unshown \"LINE(S),\" ,\n            \"lines\" right(QFROM,6,'0')\"-\"right(recm1,6,'0'),\n                \"Not Displayed\"\n          unshown = 0\n       end\n       \"(LINE) = LINE\" rec\n       \"(LABEL,NEST) = LABEL\" rec\n       qcnt=qcnt+1;q.qcnt = \" \"left(label,6) right(rec,6,'0') line\n    end\nend\nif unshown /= 0 then do\n   recm1 = maxrec\n   qcnt=qcnt+1;\n   q.qcnt = \"        - - - - - - - - -\" unshown \"LINE(S),\" ,\n       \"lines\" right(QFROM,6,'0')\"-\"right(recm1,6,'0'),\n       \"Not Displayed\"\n   unshown = 0\nend\n if OUTXXX /= 'ECHO' then do\n    Address \"TSO\" \"EXECIO * DISKW SYSUT2 (STEM Q. FINIS\"\n    lrc=rc;  if lrc /=0 then call exorcist;\n    IF OUTXXX /= \"\" then\n    Address \"TSO\" \"FREE FI(SYSUT2) OUTDES(NAME1)     \"\n end\n else do\n    Address \"TSO\" \"ALLOC DDNAME(SYSPRINT) DS(*) REUSE\"\n    Address \"TSO\" \"EXECIO * DISKW SYSPRINT (STEM Q. FINIS\"\n    lrc=rc; if lrc /=0 then call exorcist;\n end\n return 0\n givemore:\n  \" (VAR018) = DATAID\"\n  \" (VAR018A) = DATASET\"\n  \" (VAR043) = MEMBER\"\n  \" (DSNX)          = DATASET\"\n  \" (NUMX)          = NUMBER\"\n  IF VAR043 = \"\" THEN DO\n     qcnt=qcnt+1;q.qcnt= \" STATISTICS NOT AVAILABLE FOR\",\n          \"A SEQUENTIAL FILE, ONLY AVAILABLE FOR PDS FILES\"\"\"\n     return\n  END\n  Address \"ISPEXEC\" \"LMINIT DATAID(VAR018) DATASET('\"VAR018A\"')\"\n  Address \"ISPEXEC\" \"LMOPEN DATAID(&VAR018)\"\n  Address \"ISPEXEC\" \"LMMFIND DATAID(&VAR018) MEMBER(&VAR043)\",\n     \"STATS(YES)\"\n  LRC = RC\n  IF LRC = 8 THEN  NOTFOUND = 1\n  x = LISTDSI(\"'\"DSNX\"'\") \"DIRECTORY\"\n  LMSG = \"DCB=(LRECL=\"SYSLRECL\",BLKSIZE=\"SYSBLKSIZE\",\",\n     ||\"RECFM=\"SYSRECFM\",DSORG=\"SYSDSORG\")  NUMBER \"NUMX\n  ZEDLMSG = lmsg; Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n  VAR043 = SUBSTR(VAR043,1,8)\n  /************************************************************/\n   XYZ = VAR043 ZLVERS\".\"ZLMOD ZLCDATE ZLMDATE\n   XYZ = XYZ ZLMTIME ZLCNORC ZLINORC ZLMNORC\n   XYZ = XYZ LEFT(ZLUSER,8)\n   \" (VAR037) = LINENUM .ZLAST\"\n   IF ZLCNORC =\"\" THEN XYZ = VAR043,\n     \"                                  \"VAR037\"   *NO \",\n     \"STATISTICS*   \"\n   IF NOTFOUND = \"\" THEN XYZ = VAR043  ,\n       \"<<--------------- no prior statistics exist ---------->>\"\n   \"(VAR014A) = DATA_CHANGED\"\n   if VAR014A = \"NO\" then do\n      changed = \"-- Data Unchanged\"\n   end\n   else do\n      changed = \"-- Data Changed\"\n   end\n   IF VAR014A = \"YES\" THEN\n      \" LINE_AFTER 0 = NOTELINE \"\"=== @PRINTNX issued \"||,\n         \"(\"date('j')\")\" date('o') time('n') \"Data has been changed \"||,\n                                    \"===========\"\"\"\n ELSE\n      \" LINE_AFTER 0 = NOTELINE \"\"=== @PRINTNX issued \"||,\n         \"(\"date('j')\")\" date('o') time('n') \"======================\"||,\n                                    \"===========\"\"\"\n   \" LINE_AFTER 0 = NOTELINE \"\"=== \"XYZ\" ==\"\"\"\n   \" LINE_AFTER 0 = NOTELINE \"\"=== MEMBER-- VV.MM CREATED- \",\n     \"---MODIFIED---  CURR  INIT   MOD LASTUSER ==\"\"\"\n   /* ------------------------------*/\n\n   if q.qcnt = 0 then do\n       qcnt=qcnt+1;q.qcnt= \"1\"\n       qcnt=qcnt+1;q.qcnt= \" \"\n       qcnt=qcnt+1;q.qcnt= \" MEMBER-- VV.MM \"||,\n        \"CREATED- ---MODIFIED---  CURR  INIT   MOD LASTUSER\"\n       qcnt=qcnt+1;q.qcnt= \" \"XYZ\n   end\n       qcnt=qcnt+1;q.qcnt= \" \"||substr('=',1,72,'=')\n       qcnt=qcnt+1;q.qcnt= \"  -- @PRINTNX issued by\" ,\n          LEFT(SYSVAR(SYSUID),8) date('o') time('n') date('j') changed\n       if orig /= \"\" then do;\n          qcnt=qcnt+1;q.qcnt = \" @PRINTNX\" ORIG \"-- command as issued\"\n       end;\n       qcnt=qcnt+1;q.qcnt= \" \"||substr('=',1,72,'=')\n       qcnt=qcnt+1;q.qcnt= \" DSN=\"||left(SYSDSNAME,44),\n          \"Created\" SYSCREATE\n       qcnt=qcnt+1;q.qcnt= \"   \"LMSG\n       qcnt=qcnt+1;q.qcnt= \" \"||substr('=',1,72,'=')\n       qcnt=qcnt+1;q.qcnt= \"  \"\n   /* ------------------------------*/\n   IF ZLCNORC  /=\"\" THEN do\n      Address \"ISPEXEC\" \"LMCLOSE DATAID(&VAR018)\"\n      Address \"ISPEXEC\" \"LMFREE DATAID(&VAR018)\"\n   end\n   return\n  exorcist:\n    Select;\n       when lrc = 1 then zedlmsg =\n          \"EXECIO RC=1 Data was truncated during DISKW operation\"\n       when lrc = 2 then zedlmsg =\n          \"EXECIO RC=1 Data was truncated during DISKW operation\"\n       when lrc = 20 then zedlmsg = \"EXECIO RC=20 Severe ERROR\"\n       otherwise zedlmsg = \"EXECIO unknown error RC=\"lrc\n       ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    end\n    return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@RENAME": {"ttr": 2824, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00A\\x00A\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "MCRITCH"}, "text": "ADDRESS \"ISREDIT\"; \"MACRO (NEWNAME OLDNAME)\"     /* REXX -- */\n /*  TITLE:      @RENAME THE MEMBER DISPLAYED IN EDIT TO NEWNAME     */\n /*  USERS:       TSO ISPF EDIT USERS             1986/08/28         */\n /*  CONTRIBUTED: J.FORD, SUPPLIED TO GLORIA CEVALLOS                */\n /*    MODIFIED 1992/06/01 TO PERMIT NEW OPTION -- NEWNAME OLDNAME   */\n /*    REXX     1994/06/01 J.Ford code converted to REXX by D.McRitchie*/\n /*                                                                  */\n /* RENAME    RENAMES MEMBER BEING EDITED TO INDICATED NAME          */\n /*           @RENAME NEWNAME                                        */\n /*           @RENAME NEWNAME OLDNAME                                */\n /*                                                                  */\n /* WITHIN ANOTHER CLIST THE TSO RENAME MAY WORK BETTER..            */\n /*    ... YOU MUST SAVE MEMBER BEFORE RENAMING.............         */\n /*    RENAME 'DATASET.NAME(OLDNAME)' 'DATASET.NAME(NEWNAME)'        */\nIF OLDNAME = \"\"  THEN  \"(OLDNAME) = MEMBER\"\n\"(DSN) = DATASET\"\n\"(FLAG) = DATA_CHANGED\"\n NEWNAME = translate(NEWNAME)\n OLDNAME = translate(OLDNAME)\nIF FLAG = \"YES\" THEN  DO\n   SAY \"'\"DSN\"(\"OLDNAME\")' has been changed\"\n   SAY \"YOU CAN ONLY RENAME SAVED DATA\"\n   SAY \"DO YOU WANT THE MEMBER SAVED? ENTER Y OR N\"\n   PULL ANS;ans = translate(ans)\n   IF ANS = \"Y\" THEN  DO\n      \"SAVE\"\n      SAY \"'\"DSN\"(\"OLDNAME\")' SAVED\"\n    END\nEND\nIF NEWNAME = \"\" THEN  DO\n     ZEDSMSG = \"MISSING MEMBER\"\n     ZEDLMSG = \"MEMBERNAME TO BE RENAMED WAS NOT SPECIFIED\"\n    Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    Exit 0\nEND\n\"(NNAME)  = DATAID\"\nAddress \"ISPEXEC\" \"LMOPEN DATAID(&NNAME) OPTION(INPUT) OPTION(OUTPUT) ORG(POCHK)\n LMRC = RC\nIF POCHK ^ = \"PO\" THEN signal CLOSEX\nIF LMRC = 0 THEN  DO\n    Address \"ISPEXEC\" \"LMMREN DATAID(&NNAME) MEMBER(&OLDNAME) NEWNAME(&NEWNAME)\"\n    LRC = rc\n    IF LRC = 0   THEN  DO\n         ZEDSMSG = OLDNAME \"renamed\"\n         ZEDLMSG = OLDNAME \"renamed to\" NEWNAME\n        Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    END\n    IF LRC = 4 THEN  DO\n        ZEDSMSG =  NEWNAME \"already exists\"\n        ZEDLMSG = NEWNAME \"already exits, request NOT completed\"\n        Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    END\n    IF LRC = 8 THEN  DO\n        ZEDSMSG = OLDNAME \"not found\"\n        ZEDLMSG = OLDNAME \"not found, request NOT completed\"\n        Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    END\n    IF lrc > 8 then do\n        ZEDSMSG = \"ERROR RC=\"LRC\n         &ZEDLMSG = \"ERROR RC=\"LRC NEWNAME \"member NOT renamed\"\n        Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n     END\n END\n CLOSEX: Address \"ISPEXEC\" \"LMCLOSE DATAID(&NNAME)\"\n Exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@SAVE": {"ttr": 2826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x12\\x00\\x12\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "MCRITCH"}, "text": "/*REXX:  @SAVE:    SAVE MEMBER IN EDIT IF CONTENT WAS MODIFIED       */\n/*@SAVE     AUTHOR: DAVID MCRITCHIE, CREATED 1987/12/03 IS03  */\n/*          \"THE REXX MACROS TOOLBOX\", DMCRITCHIE@AOL.COM    */\n/*          UPDATED 1992/02/08 20:37 IS03                     */\n/*  CREATED BY DAVID MCRITCHIE, DEC 12, 1987,                        */\n/*  AVAILABLE TO ANYONE WHILE IN EDIT,  CONVERTED TO REXX 2/8/92     */\n      ADDRESS \"ISREDIT\";\"MACRO (TOKEN) \"\n      \"(VAR014A) = DATA_CHANGED\"\n      IF VAR014A = \"YES\" THEN DO\n         \"(VAR018) = DATAID\"\n         \"(VAR018A) = DATASET\"\n         \"(VAR043) = MEMBER\"\n         IF VAR043 \\= \"\" THEN \"STATS ON\"\n         \"SAVE\"\n         ZEDSMSG = \"MEMBER\"  VAR043 \"SAVED\"\n         ZEDLMSG = VAR043\" WAS SAVED IN \"VAR018A\" -- DATAID \"VAR018\n         ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@SCRIPT": {"ttr": 2828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x03\\x7f\\x03\\x7f\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 895, "newlines": 895, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- @SCRIPT  -- reworked  an exec better than @SCRIPT clist*/\n/*  the old @SCRIPT clist is now in CSTSCRP and CSTSVW            */\n/* Temporary usage until @SCRIPT updated to fully support OUTDES */\n/*********************************************************************/\n/*  @SCRIPT  created by David McRitchie, 1987/04/10, \"The REXX Macros Toolbox\" *\n/*      rewritten in REXX 1992/04/10, by David McRitchie.            */\n/*********************************************************************/\n/* The following prevent printing                                    */\n/*    BROWSE | EDIT | NOPRINT | STOP  -- prevent printing            */\n/* The following pertain to OUTDES (printing) options                */\n/*    CLASS()  DEST() GROUPID() FORMDEF() PAGEDEF()                  */\n/*    COPIES()           as OUTDES not as a SCRIPT option            */\n/*    PROFS(profid)      is converted to DEST()                      */\n/*    SYSTECH            equates to DEST(P100E) in SYSTECH           */\n/* To override the input dataset or member                           */\n/*    INPUT(dsn)                                                     */\n/*    MEMBER(member)                                                 */\n/* BookMaster requested with \"B\", alternative to GML starter set     */\n/*    B                  BookMaster formating requested              */\n/* The following are SCRIPT options                                  */\n/*   CHARS(), CONT|CONTINUE|NOCO dsmprof(dsmprof4),                  */\n/*   DEV()|DEVICE(), NOSPELL        NUMBER SYSVAR() TRACE UP         */\n/*           --------- character options ----------                  */\n/*    CHARS(X0....)  used with default device(PG1A), and PG1A90      */\n/*    CHARS(X1....)  used with device(38PPN)                         */\n/*    CHARS(X2....)  used with device(38PPNS90)                      */\n/*    CHARS(X0GT12)    GOTHIC                                        */\n/*    CHARS(X0T0550C)  SONORAN SANS SERIF (US SUBSET)       T1DCDCFS */\n/*    CHARS(X0T0559I)  SONORAN SANS SERIF (International)   T1DCDCFS */\n/*    CHARS(X0H21001)  HELVETICA LATIN1 (USA/Canada - CECP) T1V10037 */\n/*    CHARS(X0422001)  HELVETICA LATIN1 (Latin1 Code Page)  T1000361 */\n/*    SYSVAR(C US)     force codepage T1GI0395                       */\n/* The following are special purpose affect SCRIPT options           */\n/*   DOWN DROPCAP IDATA POINT() DUPLEX(Y|N) PSA STYLE(l3column)      */\n/* The following affect this REXX execute, not SCRIPT                */\n/*   BATCH    job will be submitted in BATCH, using OUTPUT statement */\n/*********************************************************************/\n/*    ------------- options used for testing ------- generates-----  */\n/*    @SCRIPT   B                                                    */\n/*    @SCRIPT   B Q                                                  */\n/*    @SCRIPT   DEST(PU00L)  ------- DEV(1403W8S), with FCB(8X85)    */\n/*    @SCRIPT   DEV(1403W8) FORMDEF(0101LA) -- w/o dest FORMDEF reqd */\n/*    @SCRIPT   L        ----------- DEV(PG1A90) PAGEDEF(c10110)     */\n/*    @SCRIPT   P        ----------- DEV(PG1A) FORMDEF(A10111)----   */\n/*    @SCRIPT            ----------- DEV(PG1A) FORMDEF(A10111)----   */\n/*    @SCRIPT   DEV(PG1A90) -------- DEV(PG1A90) PAGEDEF(C10110)     */\n/*    @SCRIPT   SYSTECH  ----------- DEV(1403W6) DEST(P100E) -----   */\n/*    @SCRIPT   SYSTECH  ----------- DEV(1403W6) DEST(P100E) -----   */\n/*    @SCRIPT   BATCH                                                */\n/*    @SCRIPT   DOWN     ----------- DEV(38PPNS90) chars(X2T0550C)   */\n/*    @SCRIPT   ACROSS   ----------- DEV(38PPNS)   chars(X1T0550C)   */\n/*                                   uses FORMDEF(0101LA) default    */\n/*    @SCRIPT   ACROSS CLASS(1) ---- DEV(38PPN)    chars(X1T0550C)   */\n/*                                   FORDEF(0101PA)                  */\n /********************************************************************/\n /*                                                                  */\n /*  HELP INFORMATION       HH     HH  EEEEEEEE  LL        PPPPPPPP  */\n /*  IS DISPLAYED ON        HH     HH  EE        LL        PP     PP */\n /*  THE LINES ABOVE.       HHHHHHHHH  EEEEE     LL        PPPPPPPP  */\n /*  FOR ADDITIONAL HELP    HH     HH  EE        LL        PP        */\n /*  CONTACT THE AUTHOR     HH     HH  EEEEEEEE  LLLLLLLL  PP        */\n /*  F. David McRitchie                                              */\n /*   \"The REXX Macros Toolbox\" command ===> TSO CLIST @SCRIPT HELP  */\n /********************************************************************/\nAddress \"ISREDIT\";\"MACRO (TOKEN)\"\nAddress \"ISPEXEC\" \"VGET (ZPREFIX) PROFILE\"  /* check for prefix usage*/\nprefix = ZPREFIX\nif zprefix = \"\" then prefix = SYSVAR(SYSUID)  /*normally use SYSUID  */\norigtoken=\" \"token;origtokenUP=\" \"translate(token)\norigtokenLC=\" \"translate(token,'ABCDEFGHIJKLMNOPQRSTUVWXYZ',,\n                               'abcdefghijklmnopqrstuvwxyz')\nmacro=''\nTOKEN = \" \"TRANSLATE(TOKEN)\" \"\n\"(MEMBERX) = MEMBER\";\"(DSNX) = DATASET\"\nIF substr(memberx,1,1) = \"S\" then /* allow AxxxxOLD etc. as valid*/\n  if datatype(substr(memberx,2,4),'W') then /*test for whole number*/\n   if dsnx = \"TECH.LIBR2.TEXT\" then memberx = 'A'||substr(memberx,2)\nparse var token left \" MEMBER(\" memberz \") \" right\n   token = left || ' ' || right\n   if memberz \\= '' then memberx=memberz /* override memberx*/\nIF Memberx \\= \"\" then dsnxx = DSNX\"(\"MEMBERX\")\"\nELSE                  dsnxx = DSNX\nIF token = '' then do ; token = \" P \";\n   \"LINE_BEFORE .zfirst = NOTELINE \"\"Option P has been assumed as\",\n     \"the default, will print in PORTRAIT\"\"\"; end ;\n\"(CARD1ST) = LINE .ZFIRST\"  /* FP(1) DUPLEX(NO) can be defaulted */\ni = index(token,' ? '); if i=0 then\ni=INDEX(token,' HELP '); if i\\=0 then do ;\n /* Address \"TSO\" \"pdsdd sysproc @SCRIPT\";RETURN; end ; */\n    Address \"TSO\" \"clist @SCRIPT help\";RETURN; end ;\n\n/*********** determine release for SCRIPT.Rxx.MACLIB *****/\nREL = \"\"\ni = index(token,' R40 ');\nif i \\=0 then do; REL = \"R40\"\n   parse var token left \" R40 \" right\n   token = left || ' ' || right\nend\nif rel = \"\" then rel = \"R40\"   /* use default */\n\n/******* special testing ***********/\ndocument = '';\nIF DSNX = \"IS03.LIBR.CLIST\" then if SYSVAR(SYSUID) = \"IS03\" then if ,\n  substr(memberx,1,1) = 'Z'  then token = token \" DOC \"; /*special*/\ni = index(token,' DOC ');if i \\=0 then document = \"DOC\"\nif document = \"DOC\" then do\n   \"FIND 1 last ' '\"\n   \"LABEL .ZCSR = .OLD 0\"\n   \"FIND 1 next '='p\"\n   \"LABEL .ZCSR = .BOT 0\"\n   \"LINE_BEFORE .BOT = DATALINE \"\" \"DATE('N') TIME('N') ,\n      \" ===>\" SYSVAR(SYSICMD) origtokenUP\"\"\"\"\n   parse var token left \" DOC \" right\n   token = left || ' ' || right\nend\n/***********************************/\n \"ISREDIT (DCHG) = DATA_CHANGED\"\n IF DCHG = \"YES\" then if document \\= \"DOC\" then do\n    SAY '*************************************************************'\n    SAY '*     YOUR FILE HAS NOT BEEN SAVED AFTER MAKING CHANGES     *'\n    SAY '*                                                           *'\n    SAY '* CANNOT SCRIPT UNLESS YOU SAVE -- Hit enter to terminate   *'\n    SAY '************************* -- OR -- **************************'\n    SAY ' REPLY <ENTER KEY> or type in \"CAN\" to terminate request'\n    SAY ' REPLY \"SAVE\"   | \"SAV\" to save then @SCRIPT saved version'\n    SAY ' REPLY \"CANCEL\" | \"CAN\" if you doo not want to @SCRIPT' ,\n                'at this time'\n    pull PARM1;parm1 = translate(parm1)\n    if SUBSTR(PARM1,1,3) \\= \"SAV\" then do ;\n       \"LINE_BEFORE .ZFIRST = NOTELINE \"\"Not SCRIPTing UNSAVED data\"\"\"\n       ZEDLMSG = \"Data Has not been SAVED -- NOT SCRIPTED\"\n       ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\";Return 1\n    end\n    \"@SAVE\"\n    if rc > 1 then do\n       \"LINE_BEFORE .ZFIRST = NOTELINE \"\"SAVE before SCRIPT failed\"\"\"\n       return\n    end\nend\n/*********************************************************************/\n\"LINE_BEFORE .ZFIRST = NOTELINE \"\"\",\n      ||TIME('N') SYSVAR(SYSICMD) origtokenUP\"\"\"\"\n/*   set variables to nulls  or initial values */\ndsmprof = '*';pointv='';codepage='';ochars='';delay='';\nspellchk='';continue='';nospell='';NOPRINT=\"\";device=\"\";trace=\"\";\nfontlib=\"\";fontlibx=\"\";nochars=''; writer='';\noutdes = \" \";edit=\"\";\npage=''\nprofile = \" PRO('SCRIPT.R40.MACLIB(DSMPROF4)')\" /*unless option B*/\nlibrary = \"SCRIPT.R40.MACLIB\"  /* unless option B (book)*/\nCECP = '(Country Extended Code Page)'\n/*********/\ni = index(token,' B '); if i=0 then Book = ' ';\nelse do ; /* BookMaster */ Book = \"BookMaster\"\n   profile = \" PRO('SCRIPT.EDF.EDFMAC(EDFPRF40)')\"\n   library = \"SCRIPT.EDF.EDFMAC\"   /* SCRIPT.EDF.EDFMAC VERSION LATER*/\n   parse var token left \" B \"  right\n   token = left || ' ' || right\nend\nparse var token left \" BIND(\" bind \") \" right\n   if bind = '' then parse var token left \" B(\" bind \") \" right\n   if bind \\= '' then do ; bind = \" B(\"bind\")\"\n      token = left || ' ' || right\n   end\nparse var token left \" CHARS(\" chars \") \" right\n   token = left || ' ' || right\nparse var token left \" CLASS(\" class \") \" right\n   token = left || ' ' || right\nparse var token left \" /*\" comment \"*/ \" right\n   token = left || ' ' || right\n   /* observe comment delimitors in quotes do not \"LOSE DATA\" */\nparse var token left \" COPIES(\" copies \") \" right\n   token = left || ' ' || right\nif fontlib = \"\" then FONTLIB = \"SYS1.PROD.FONTLIB\"\nparse var token left \" DCFINDEX(\" DCFINDEX \") \" right\n    token = left || ' ' || right\nparse var token left \" DEST(\" dest \") \" right\n   token = left || ' ' || right\nparse var token left \" DEVICE(\" device \") \" right\n   token = left || ' ' || right\n  if device ='' then do ;\n   parse var token left \" DEV(\" device \") \" right /*DEVICE contd*/\n   token = left || ' ' || right\n  end ;\nparse var token left \" DSMPROF(\" DSMPROF \") \" right\n   token = left || ' ' || right\nparse var token left \" DUPLEX(\" duplex \") \" right\n   token = left || ' ' || right\n   duplex = substr(duplex,1,1)\n   i = index(card1st,'DUPLEX(NO)')\n   if i \\=0 then do;\n     say \"Found DUPLEX(NO) \",\n        \"on first card will include SYSVAR(D N)\"\n     if duplex = '' then duplex = \"N\"\n   end   /* save duplex for sysvar later on */\nparse var token left \" FCB(\" fcb \") \" right\n   token = left || ' ' || right\nparse var token left \" FORMDEF(\" formdef \") \" right\n   token = left || ' ' || right\nparse var token left \" FP(\" fp \") \" right\n   token = left || ' ' || right\n   if fp \\='' then fp = ' FP('fp')';\n   if fp ='' then do\n      i = index(card1st,'FP(1)')\n      if i \\=0 then do ; fp = ' FP(1) ';say \"Found FP(1) \",\n         \"on first card will format one pass only\"\n      end\n   end\nparse var token left \" GROUPID(\" groupid \") \" right\n   token = left || ' ' || right\nparse var token left \" INPUT(\" input \") \" right\n   token = left || ' ' || right\n   if input \\= '' then dsnxx = input\n   if substr(dsnxx,1,1) = \"'\" then parse var dsnxx \"'\"dsnxx\"'\" /*'*/\nparse var token left \" LINECT(\" LINECT \") \" right\n   token = left || ' ' || right;if linect = '' then linect=0\nparse var token left \" LL(\" ll \") \" right\n   token = left || ' ' || right\n   /* will be included with sysvar*/\nparse var token left \" PAGE(\" page \") \" right\n   token = left || ' ' || right\n   if page = '' then page='';else page=' PAGE('page') ';\n   if page \\= '' then do  /* catch lowercase prefixes */\n      i = index(origtokenUP,' PAGE(')\n      j = index(substr(origtokenUP,i),')');\n      LCpage = substr(origtokenLC,i,j)\n      xxpage = substr(origtoken,i,j)\n      if LCpage \\= xxpage then page=' PAGE('||substr(origtoken,i+6,j-6)\n      if substr(origtokenUP,i+6,j-6) \\= substr(origtokenLC,i+6,j-6) ,\n      then say \"Warning \"page\" is lettercase sensitive\"\n   end\nparse var token left \" MACRO(\" macro \") \" right\n   token = left || ' ' || right\nparse var token left \" PAGEDEF(\" pagedef \") \" right\n   token = left || ' ' || right\nparse var token left \" POINT(\" point \") \" right\n   token = left || ' ' || right\nparse var token left \" WTR(\" writer \") \" right\n   token = left || ' ' || right\nif writer = \"\" then do\n   parse var token left \" WRITER(\" writer \") \" right\n      token = left || ' ' || right\nend\nif device = '' then do\n   /* must be filled in before DEST default */\n   if writer = 'PODU' | writer = 'POSI' | writer = 'MSDS',\n      then device = '1403N6'\nend\nparse var token left \" PROFS(\" profs \") \" right\n   if profs \\= '' then do\n      token = left || ' ' || right\n      dest = ''\n      bind = \" B(0 0)\"\n      outdes = outdes \"DEST(bbbbbbbb.\"profs\") \"\n      if class = '' then class = 'S'\n      if ll = '' then ll = '78'\n      device = '1403W8'\n   end ;\n\nparse var token left \" PSEGLIB(\" pseglib \") \" right\n   token = left || ' ' || right\nif pseglib = \"\" then do\nparse var token left \" SEG(\" pseglib \") \" right\n   token = left || ' ' || right\n   if pseglib = '' then pseglib= 'SYS1.PROD.PSEGLIB';\nend\nparse var token left \" SYSVAR(\" sysvar \") \" right\n   token = left || ' ' || right\n   parse var token left \" STYLE(\" STYLE \") \" right\n   /* Style() must be checked after SYSVAR */\n   if style \\= '' then do\n       token = left || ' ' || right\n       style=translate(style)\n       SYSVAR = SYSVAR \"1\" style\n       Book = \"BookMaster\"\n       profile = \" PRO('script.edf.edfmac(EDPRF40)')\"\n       library = \"script.edf.edfmac\"\n       IF style = \"L3COLUMN\" | style = \"L2OFFSET\" ,\n          | style = \"L2COLUMN\" then\n          if device='' then device='PG1A270'\n    end ;\n    i = index(token,' SCRPTLIB ');if i \\= 0 then do ;\n        parse var token left \" SCRPTLIB \" right;\n        token = left right\n        library = ''\n    end ;\n    i = index(token,' SCRPTLIB ');if i \\= 0 then do ;\n        parse var token left \" SCRPTLIB \" right;\n        token = left right\n        library = ''\n    end ;\n\n\n/********* single word parameters d.o.n.e after keyword parens ****/\nacross    = process('across')\nbatch     = process('BATCH')\nbold      = process('bold')\ndirect    = process('direct')  /*not for general use */\ndown      = process('DOWN')\ndropcap   = process('dropcap');\nedit      = process('EDIT');if edit = \"\" then edit= process('BROWSE')\n/* edit and relationship to spellchk below*/\ngt12      = process('gt12')\ngt15      = process('gt15')\nhelvetica = process('helvetica')\nitalic    = process('italic')\nnochars   = process('nochars')\nnospell   = process('nospell')\nnoprint   = process('noprint')\nnowait    = process('nowait')\nnofcb     = process('nofcb')\nnumber    = processB('NUMBER')\nP         = process('P');if P='' then P = process('L')\nsans      = process('SANS');\nsonoran   = process('sonoran')\nspellchk  = process('spellchk')\nif macro \\= \"\" then do; macro=\"MACRO(\"macro\")\"; edit=\"EDIT\"; end;\nif edit \\= \"\" then if NOSPELL = '' then SPELLCHK = 'SPELLCHK'\nstop      = process('stop')\nsystech   = process('systech')\ntechpsf   = process('techpsf')\nsystechl  = process('systechl')  /* laser in landscape*/\nsystechp  = process('systechp')  /* laser in portrait */\ntiming    = process('timing')    /* useful with idata */\nif trace = '' then trace     = processB('trace')\nif delay = '' then delay     = processB('delay')\nup        = process('up')\nview      = process('view')\nreview      = process('review')\n\nCONTINUE = process('NOCO');\nif CONTINUE = '' then CONTINUE = process('CONTINUE')\nif CONTINUE = '' then CONTINUE =process('CONT')\nif CONTINUE = '' then CONTINUE =process('CO')\nif substr(CONTINUE,1,2) = \"CO\" then CONTINUE = \"CO\"\nif CONTINUE = 'NOCO' then CONTINUE = ''\n\ni = index(token,' IDATA '); if i=0 then idata='';\nif i ^= 0 then do ;\n       parse var token left\" IDATA \"right;token=left||' '||right;\n    /* if dest='' then dest = 'PROG1A3A' -- olde defaulte*/\n       if dest='' then dest = 'P12W6';   /*new default*/\n       say '------ DEST('dest')---------- for your IDATA'\n       class = 'S';  sysvar=sysvar \"M IDATA\";\n       if device = '' then device = 'PG1A';\nend\n\n\ni = index(token,' PSA '); if i=0 then psa='';\nelse do ;psa='PSOUT(A)';\n       dcfindex='SCRIPT.'rel'.FONTPS'; /* script.r40.fontps */\n       FONTLIB = ' ';\n       if device = '' then device = 'PSA';\n       pseglib  = \"\"\n       parse var token left\" PSA \"right;token=left||' '||right; end ;\n\nif substr(device,1,3) = 'PSA' then do\n   dcfindex = \"FO('SCRIPT.\"rel\".FONTPS')\" /* script.r40.fontps */\n   if FONT3820 = \"FONT3820\" then dcfindex=\"FO('SYS1.FONT3820')\"\n   if device = '' then device = psa;\n   FONTLIB = ' ';\n   pseglib  = \"\"\n   chars = 'PSFHV'  /* helvetica */\nend\ni = index(token,' Q ');\nif i \\= 0 then do ;\n       parse var token left\" Q \"right;token=left||' '||right\n       bind = \" B(0 0)\"\n       if Book = \"\" then if dsmprof = \" \" then dsmprof = \"DSMPROFL\"\n       if device = \"\" then device = \"1403W6\"\n       if edit = '' then edit = \"EDIT\"\n       if NOSPELL = '' then SPELLCHK = 'SPELLCHK';CONTINUE = \"CO\"\n       trace = ' TRACE'\n       /* delay = ' DELAY'  -- not included automatically */\n       noprint = 'NOPRINT'\n       \"line_before .zf = noteline \"\"===> DCFMSGS @SCRIPT may be\",\n          \"used to merge error messages after @SCRIPT Q\"\"\"\nend\n\n/* CHECK that all variables in TOKEN were accepted ------ */\nif token \\='' then do\n    Address \"ISREDIT\"\n    ZEDLMSG = \"remaining values unknown to @SCRIPT -- \"token\n    Address \"ISREDIT\" \"LINE_AFTER .ZCSR = NOTELINE \",\n     \"\"\"\"TIME('N') \"remaining values unknown to @SCRIPT -- \"token\"\"\"\"\n    ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    RETURN 12\nend\n/* REPROCESS variables ---------------------------------- */\nif dropcap = 'DROPCAP' then sysvar = sysvar \"I YES\"\nif systech = 'SYSTECH' then dest=\"P100E\"\n   /*SYSTECH - DEV(1403W6) DEST(P100E) FCB(Z666) */\n   /*SYSTECH  DEV(1403W8) -- DEST(P100E) FCB(Z888) */\nif systechl = 'SYSTECHL'  then do  /* LANDSCAPE on Laser */\n   device = '1403W8S';FCB='8X85' /* your only choice*/\n   SYSVAR = SYSVAR \"M SYSTECHL\" /* coding in ccc@SYM profile ext.*/\n   dest=\"PU00L\"\nend\nif systechp = 'SYSTECHP' then do   /* PORTRAIT on Laser */\n   if device ='' then device = '1403W8'\n   /* will pick up FCB later either Z888 or Z666 */\n   dest=\"PU00L\";sysvar = sysvar \"M SYSTECHP\"\n   /*If portrait were used again -- 11 inches long  */\n   /*         -- DEV(1403W8) DEST(xxxxx) FCB(Z888) */\nend\nif techpsf = \"TECHPSF\" then dest=TECHPSF\nif dest = \"TECHPSF\" then do\n   if device ='' then device = \"PG4A\"; /* as a 4028 */\n   if fontlib = '' then fontlib = duvt\nend\nif view = \"VIEW\" then do\n   profile = \" PRO('SCRIPT.R40.MACLIB(DSMVIEW4)')\"\n   /* line length will be set to 78 in DSMVIEW4 */\n   CONTINUE = ' CO '\n   BIND = ' B(0 0)'\n   if device = '' then device = '1403W6'\nend\n/* not really JCL but it will stand out if shown as JCL */\nAddress \"TSO\" \"CLS\"\nAddress \"TSO\" \"$time @SCRIPT --\"\naddress \"TSO\" \"LISTDDJ SCRPTLIB TEXTLIB\"\naddress \"TSO\" \"%MURPHY\"\nAddress \"TSO\" \"$time @SCRIPT --\"\nstatus = msg('off')\n/*********************************************************************/\n/* Address \"TSO\" \"FREE FILE(SCRPTLIB TEXTLIB)\"                       */\n/*********************************************************************/\nAddress \"TSO\" \"FREE DA('\"dsnxx\"')\"\nAddress \"TSO\" \"FREE DA(dsmutmsg.text)\"\nLISTXDSN = \"'\"prefix\".S9999.LIST'\" /*also used by view*/\nAddress \"TSO\" \"Free da(\"listxdsn\")\"\nAddress \"TSO\" \"DEL \"listxdsn\nstatus = msg('on')\na='1'\n\n/* set outdes not previously set*/\nif dest = '' | dest = \"AHCENTER\" then do\n   if pagedef='' & fcb='' then do\n      if '1403W8S' = device then do;FCB='8X85';ochars='GT12';end;\n      if '1403W6' = device then do;FCB='8X85';ochars='GT12';end;\n      if '1403W8' = device then do;notell = \"DEV(1403W8) is useable\",\n         \" at AHCENTER only if line length remains < 95\";say ,\n         left('-',60,'-');\"LINE_BEFORE .zf = noteline \"\"\"notell\"\"\"\";\n         pagedef='down8';say notell;say left('-',60,'-');\n      end\n   end\nend\nelse do\n   if device = '' then device = '1403W6'\n   if pagedef='' & fcb='' then if NOFCB='' then do\n      if '1403W6' = device then fcb='Z666'\n      if '1403W8' = device then fcb='Z888'\n   end\nend\nif device = \"\" then do\n   if DOWN = \"DOWN\" then device = \"38PPNS90\"\n   if ACROSS = \"ACROSS\" then\n      if CLASS = \"1\" then device = \"38PPN\"\n      else device = \"38PPNS\"\n   if P = \"L\" then device = \"PG1A90\"\n   if P = \"P\" then device = \"PG1A\"\n   if device /*is still*/ = '' then device = \"PG1A\"\n   if edit = \"EDIT\" then device = '1403W8'\nend\n\nif formdef = '' then do\n   if device = '38PPN' then formdef = '0101PA';\n   if device = '38PPNS' | device = '38PPNS90' then formdef = '0101LA';\n   if substr(device,1,4) = 'PG1A' then formdef = 'A10111';\n   if substr(device,1,4) = 'PG4A' then formdef = 'A10111';\n       /*PG1A  PG1A90  PG1A180  PG1A270 */\n   if device = 'PG1A90' then formdef = 'C10110' /*F1c10110*/\nend\nif nofcb = \"NOFCB\" then FCB=\"\"\nif class = '' then class = 'A'\nif class   \\= '' then outdes = outdes \"CLASS(\"class\")\"\nif ochars  \\= '' then outdes = outdes \"CHARS(\"ochars\")\"\nif copies  \\= '' then outdes = outdes \"COPIES(\"copies\")\"\nelse copies = '1'\nif dest    \\= '' then outdes = outdes \"DEST(\"dest\")\"\nif fcb     \\= '' then outdes = outdes \"FCB(\"fcb\")\"\nif formdef \\= '' then outdes = outdes \"FORMDEF(\"formdef\")\"\nif LINECT \\= '' then outdes = outdes \"LINECT(\"linect\")\"\nif pagedef \\= '' then outdes = outdes \"PAGEDEF(\"pagedef\")\"\nif writer  \\= '' then outdes = outdes \"WRITER(\"writer\")\"\nif groupid  = '' then do /* basically as a comment on OUTDES */\n   if   style \\= '' then groupid = style\n   else if memberx \\= '' then do ; if 0 = verify(memberx,'@#$','M') ,\n         then groupid=memberx; end ;\n   else if formdef \\= '' then groupid = formdef\n   else if dest    \\= '' then groupid = dest\n   else if device  \\= '' then groupid = device\n   else groupid = '@SCRIPT'\nend ;\nif groupid \\= '' then outdes = outdes \"GROUPID(\"groupid\")\"\n\nif direct = \"DIRECT\" | batch = \"BATCH\" ,\n          then  FILE = \" PRINT(\"copies\",\"class\")\"\n          else  FILE = \" FILE(\"listxdsn\")\"\n\nif LL \\= '' then SYSVAR = SYSVAR' L 'LL\n/* place our default SYSVAR in font of any supplied*/\nSYSVAR = 'X NO H NO 'SYSVAR\nif duplex = \"Y\" | duplex = \"YES\" | duplex = \"\" then duplex = \"Y\"\nsysvar = strip(sysvar) \"D\" duplex\n\n/*********************************************************************/\nif Review = 'REVIEW' then do; Address \"TSO\" \"CSTSVW\"  'REVIEW';\n       return 1; end   /* tie into ccc on-line in color viewing */\nsay \"Abbreviations used on SCRIPT command, due to 250 byte maximum\"\nsay \"  B=BIND, CH=CHARS, CO=CONTINUE, DEV=DEVICE, FI=FILE\"\nSAY \"  FO=FONTLIB, FP=FPASSES, PRO=PROFILE, SP=SPELLCHK\"\nSAY \"----  \" STOP\nif spellchk = '' then spell = ''\nelse do; spell = ' SP';if edit = 'EDIT' then delay = ' DELAY';end\nif device = \"4250A\"     then FONTLIB = \"sys1.fontlibb\" /*not sure*/\nif substr(device,1,4) = \"PG4A\" then do;\n   FONTLIB = \"DUVTT.V1R1M0.FONT300\"\n   FONTLIB = \"SYS1.PROD.FONT300\"\n   if chars='' then chars=\"X0H21001\";    /* 10 point HELVETICA */\n   if formdef='' then formdef=\"A10111\"\nend\nfontlibx = fontlib;\nif fontlib \\= '' then FONTLIB = \" FO('\"fontlib\"')\"\nif PSEGLIB \\= '' then PSEGLIB = \" SEG('\"PSEGLIB\"')\"\nif dsmprof ^='' then do\n     profile = \" PRO('SCRIPT.\"rel\".MACLIB(\"dsmprof\")')\"\n     if BOOK \\= \" \" then\n        profile = \" PRO('SCRIPT.EDF.EDFMAC(\"dsmprof\")')\"\nend\n  /* CREATE CHAR(XXX) NAME BASED ON POINT() */\nif chars ^= '' then do\n   AA =\"X0GT89 X0H4106C X0H5106C X0H2106C X0H3106C X0N4106C X0N5106C\",\n     \"X0N2106C X0N3106C X044107C X045107C X042107C X043107C\",\n     \"X0H4107C X0H5107C X0H2107C X0H3107C X0N4107C X0N5107C\",\n     \"X0N2107C X0N3107C X0CB59 X0CR59 X0CD59 X0CW59 X0CI59\",\n     \"X044108C X045108C X042108C X043108C X0GT59 X0GL59 X0H4108C\",\n     \"X0H5108C X0H2108C X0H3108C X0ST59 X0N4108C X0N5108C X0N2108C\",\n     \"X0N3108C X0CBE9 X0CIE9 X0CRE9 X0GBE9 X0GTE9 X0GIE9 X0GLE9\"\n  BB=\"X0GPE9 X0H4109C X0H5109C X0H2109C X0H3109C X0LBE9 X0LRE9\",\n     \"X0PBE9 X0PRE9 X0PIE9 X0SBE9 X0STE9 X0SIE9 X0SOE9 X0N4109C\",\n     \"X0N5109C X0N2109C X0N3109C X0BRR9 X0BIR9 X0DOR9 X0CB09\",\n     \"X0CR09 X0CI09 X044100C X045100C X042100C X043100C X0EBR9\",\n     \"X0ELR9 X0ESR9 X0EIR9 X0GB09 X0GT09 X0GL09 X0GR09 X0H4100C\",\n     \"X0H5100C X0H2100C X0H3100C X0PR09 X0RT09 X0ST09 X0SI09\",\n     \"X0A10500 X0T10500 X0N4100C X0N5100C X0N2100C X0N3100C\"\n  CC=\"X0H410AC X0H510AC X0H210AC X0H310AC X0N410AC X0N510AC\",\n     \"X0N210AC X0N310AC X04410BC X04510BC X04210BC X04310BC\",\n     \"X0H410BC X0H510BC X0H210BC X0H310BC X0N410BC X0N510BC\",\n     \"X0N210BC X0N310BC X04410DC X04510DC X04210DC X04310DC\",\n     \"X0H410DC X0H510DC X0H210DC X0H310DC X0N410DC X0N510DC\",\n     \"X0N210DC X0N310DC X0H410FC X0H510FC X0H210FC X0H310FC\",\n     \"X0N410FC X0N510FC X0N210FC X0N310FC X0H410HC X0H510HC\"\n  DD=\"X0H210HC X0H310HC X0N410HC X0N510HC X0N210HC X0N310HC\",\n     \"X04410JC X04510JC X04210JC X04310JC X0H410JC X0H510JC\",\n     \"X0H210JC X0H310JC X0N410JC X0N510JC X0N210JC X0N310JC\",\n     \"X0H410NC X0H510NC X0H210NC X0H310NC X0N410NC X0N510NC\",\n     \"X0N210NC X0N310NC X0H410TC X0H510TC X0H210TC X0H310TC\",\n     \"X0N410TC X0N510TC X0N210TC X0N310TC X0H410ZC X0H510ZC\",\n     \"X0H210ZC X0H310ZC X0N410ZC X0N510ZC X0N210ZC X0N310ZC\"\n   T1V10500 = AA BB CC DD EE\n   ii = index(T1v10500,chars)\n   if ii ^= 0 then if point = '' then do; sysvar = SYSVAR \"C US\"\n      /* unfortunately only T1V10500 has all point sizes */\n       codepage = \"T1V10500 International #5, will become\",\n          \"T1V10037 USA/CAN - CECP with DSMPROF4/ccc@SYM profile\"\n       say '        ' codepage\n   end\nend\nIF POINT \\= '' THEN do ;\n      POINTV = POINT\n      IF POINTV ='10'  THEN POINTV ='0'\n      IF POINTV ='11'  THEN POINTV ='A'\n      IF POINTV ='12'  THEN POINTV ='B'\n      IF POINTV ='14'  THEN POINTV ='D'\n      IF POINTV ='16'  THEN POINTV ='F'\n      IF POINTV ='18'  THEN POINTV ='H'\n      IF POINTV ='20'  THEN POINTV ='J'\n      IF POINTV ='24'  THEN POINTV ='N'\n      IF POINTV ='30'  THEN POINTV ='T'\n      IF POINTV ='36'  THEN POINTV ='Z'\n      IF LENGTH(POINTV) > 1 THEN do ; SAY \"POINT(\"POINT\")\",\n        \" INVALID MUST BE 4-9,10-12,14,16,18,20,24,30,36\"\n        RETURN 20\n        end ;\nend\nelse pointv=''\nif pointv \\= '' then do\n   if chars = 'X0H21001' then\n      chars = substr(chars,1,6)||pointv||substr(chars,8,1)\nend\nif chars = '' then if '' \\= ,\n  pointv||helvetica||italic||down||across||GT15||GT12||SANS||bold ,\n  ||techpsf ,\n  then do\n   chars = 'X0T0550C'\n   if techpsf = \"TECHPSF\" then chars=\"X0H22001\"\n   if gt12 = \"GT12\" then chars='X0GT12'\n   if gt15 = \"GT15\" then chars='X0GT15'\n   if pointv \\= '' then\n       chars=substr(chars,1,6)||pointv||substr(chars,8,1)\n   if ACROSS = \"ACROSS\" then chars='X1'||substr(chars,3)\n   if DOWN = \"DOWN\" | device = '38PPN8S' ,\n      then chars='X2'||substr(chars,3)\n   if device = ''       then device = \"PG1A\"\n   if sans   = 'SANS'   then\n       chars=substr(chars,1,2)||'A'||substr(chars,4)\n   if italic = 'ITALIC' then\n       chars=substr(chars,1,3)||'1'||substr(chars,5)\n   if bold   = 'BOLD'   then\n       chars=substr(chars,1,4)||'7'||substr(chars,6)\n   if HELVETICA = 'HELVETICA' then do\n      chars=substr(chars,1,2)||'H21001' /*X0H22001 HELVETICA LATIN1*/\n      if pointv \\= '' then\n          chars=substr(chars,1,6)||pointv||substr(chars,8,1)\n      else do ;point = 10;pointv='0'; end\n      if BOLD||ITALIC='ITALIC' then\n          chars=substr(chars,1,3)||'3'||substr(chars,5)\n      if BOLD||ITALIC='BOLD' then\n          chars=substr(chars,1,3)||'4'||substr(chars,5)\n      if BOLD||ITALIC='BOLDITALIC' then\n          chars=substr(chars,1,3)||'5'||substr(chars,5)\n      font = 'HELVETICA LATIN1'\n   end\nend\n IF CHARS \\= '' THEN IF SUBSTR(CHARDS,5,1) = ' ' THEN DO\n    PERINCH= SUBSTR(CHARS,3,2);\n    IF '24' = PERINCH THEN POINT =       04\n    IF '20' = PERINCH THEN POINT =       05\n    IF '15' = PERINCH THEN POINT =       08\n    IF '12' = PERINCH THEN POINT =       09\n    IF '10' = PERINCH THEN POINT =       10\n    IF CHARS = \"GC15\" THEN POINT = 07\n    SAY \"PRINTING WILL BE DONE IN POINT REL 2 \",\n      \"COMPATIBILITY USING CHARS(\"CHARS\")\"\n end ;\n IF SUBSTR(CHARS,8,1) \\= ' ' THEN DO\n    if substr(chars,3,1) \\= 'H' then do\n       IF SUBSTR(chars,7,1) = 'A' then ,\n           FONT = 'SONORAN SANS SERIF'\n       IF SUBSTR(chars,7,1) = 'T' then ,\n           FONT = 'SONORAN SERIF'\n       IF SUBSTR(chars,7,1) = 'J' then ,\n           FONT = 'SONORAN DISPLAY'\n       if substr(font,1,3) = 'SON' then do\n          IF SUBSTR(chars,7,1) = '1' then ,\n              ITALIC = ITALIC\n          IF SUBSTR(chars,5,1) = '7' then Bold = \"BOLD\"; else BOLD = \"\"\n       end\n    end\n    if substr(chars,3,1) = \"H\" then do\n       pointx = substr(chars,7,1)\n       font = \"HELVETICA\"\n       if substr(chars,5,1) = \"2\" then font=\"HELVETICA LATIN1\"\n       if substr(chars,5,1) = \"1\" then font=\"HELVETICA\"\n    end\n    /*         12 WIDTH ULTRA-CONDENSED, MEDIUM, ULTR-EXPANDED*/\n    POINTX = SUBSTR(CHARS,8,1)\n    IF POINTX= \"0\" THEN POINT = 10\n    IF POINTX= \"A\" THEN POINT = 11\n    IF POINTX= \"B\" THEN POINT = 12\n    IF POINTX= \"D\" THEN POINT = 14\n    IF POINTX= \"F\" THEN POINT = 16\n    IF POINTX= \"H\" THEN POINT = 18\n    IF POINTX= \"J\" THEN POINT = 20\n    IF POINTX= \"N\" THEN POINT = 24\n    IF POINTX= \"T\" THEN POINT = 30\n    IF POINTX= \"Z\" THEN POINT = 36\n    if substr(chars,8,1) = '1' then\n       codepage = 'T1000361  LATIN1 Code Page (full set)'\n    if substr(chars,2,6) = 'H21071' then\n       codepage = 'T1V10037  USA/Canada CECP' CECP\n    if substr(chars,2,6) = 'H21001' then\n       codepage = 'T1V10037  USA/Canada CECP' CECP\n    if substr(chars,8,1) = 'E' then\n       codepage = 'T1000395  LATIN1 Code Page (10 only)'\n    if substr(chars,8,1) = 'C' then\n       codepage = 'T1DCDCFS  U.S. Text Subset (full set)'\n    if substr(chars,8,1) = 'I' then\n       codepage = 'T1GI0361  International Set 5 (full set)'\n    if substr(chars,8,1) = '5' then codepage = ,\n       'T1Gi0395  United States, Canada (English) --(10 only)'\n    SAY \"Printing will begin with     TYPE (\"POINT\"  '\"FONT\"' \",\n        ITALIC  BOLD \")  codepage\" substr(codepage,1,8)\n    SAY '         ' codepage\nEND\nif CHARS \\= '' then do\n   if fontlibx = \"\" then fontlibx = \"SYS1.PROD.FONTLIB\"\n   x = SYSDSN(\"'\"fontlibx\"(\"chars\")'\")\n   if x \\= 'OK' then do\n      say fontlibx\"(\"chars\") -- \"||x\n      if substr(device,1,4) = 'PG1A' then return\n   end\n   charsx = ' CHARS('chars') '\nend\nelse charsx=''\nif FORMDEF \\= '' then do\n   x = SYSDSN(\"'SYS1.PROD.FDEFLIB(F1\"FORMDEF\")'\")\n   if x \\= 'OK' then do\n      xa= SYSDSN(\"'SYS1.FDEFLIB(F1\"FORMDEF\")'\")\n      if xa \\= 'OK' then\n      xa= SYSDSN(\"'SYS1.FDEFLIB(F1\"FORMDEF\")'\")\n      if xa \\= 'OK' then do\n         say \"SYS1......FDEFLIB(f1\"formdef\") -- \"||x\n         return 12\n      end\n   end\nend\nif fp ='' then fp = ' FP(2)'\n\nif library \\= '' then  library = \" LIB('\"library\"')\"\nSAY /* S -s- */\"SCRIPT '\"DSNXX\"'\"||profile,\n number||library||fontlib||INDEX||PSEGLIB,\n \"DEV(\"device\")\"charsx  continue||PSA||UP||FP\"SYS(\"sysvar\")\",\n \"M(ID\"trace||delay\")\"||PAGE FILE bind||spell\nIf dest = 'PU00L' then do\n   if device \\= '1403W8S' then\n      call sayboth('Incorrect device for SYSTECH, s/b 1403W8S')\n   if linect \\= 0        then\n      call sayboth('Incorrect LINECT('||linect||') s/b 0')\n   if fcb \\= '' then if fcb \\= '8X85' then\n      call sayboth('Incorrect FCB('||fcb||') s/b blank or 8X85')\nend\nif dest = \"\" then sysvar = sysvar \"Z Unknown\"\nelse sysvar = sysvar \"Z\" dest\nif nowait = \"NOWAIT\" then\n   call sayboth('  ---- The use of NOWAIT is no longer '||,\n        'meaningful on your @SCRIPT command ---------------')\nif document = \"DOC\" then do\n  \"LINE_BEFORE .BOT = dataline \"\"        -- \"INDEX ,\n     \"DEV(\"device\")\"charsx continue||PSA||UP||FP\"SYS(\"sysvar\")\",\n     \"M(ID\"trace||delay\")\"||page bind||spell\"\"\"\"\n  \"LINE_BEFORE .BOT = dataline \"\"        -- OUTDES NAME1\" OUTDES\"\"\"\"\nend\nIF STOP = \"STOP\" then do ;\n  say \"OUTDES NAME1\" OUTDES \"<-- ended by STOP\"\n  ZEDSMSG = \"STOP\"\n  ZEDLMSG = 'STOP option indicates not to do SCRIPTing'\n  return 1  /* STOP option is for checking SCRIPT statement*/\nend\nif document = \"DOC\" then \"@SAVE\"\nif BATCH = 'BATCH' then do\n   if copies ='' then copies='1'\n   LISTXDSN = \"'\"prefix\".S9999B.LIST'\"\n   if direct = \"DIRECT\" | batch = \"BATCH\" ,\n          then  FILE = \" PRINT(\"copies\",\"class\")\"\n          else  FILE = \" FILE(\"listxdsn\")\"\n   SAY \"------------- BATCH Script will be invoked now --------------\"\n   ADDRESS \"TSO\"\n   QUEUE \"//IS03XX JOB (0289,O179),'D.MCR TEST',CLASS=9,MSGCLASS=T\"\n   QUEUE \"//TS0 EXEC PGM=IKJEFT01,DYNAMNBR=20,REGION=6M\"\n   QUEUE \"//DEFAULT OUTPUT FORMDEF=\"FORMDEF\",DEFAULT=YES,DEST=\"dest\n   QUEUE \"//\"||\"*SYSTSPRT ------------ SCRIPT COMMAND AND ERR MSGS\"\n   QUEUE \"//SYSTSPRT DD SYSOUT=T,DEST=AHCENTER,HOLD=YES\"\n   QUEUE \"//SYSPROC DD DSN=SYS1.TSOCLIST,DISP=SHR ?SCRPTLIB?\"\n   x = outtrap('var.')\n   \"listddj SCRPTLIB\";\n   if var.0 > 0 then do i=1 to var.0; queue var.i; say var.i; end ;\n   x = outtrap('var.')\n   \"listddj TEXTLIB\"\n   if var.0 > 0 then do i=1 to var.0; queue var.i; say var.i; end ;\n   QUEUE \"//SYSTSIN DD *\"\n   QUEUE \"SCRIPT '\"DSNXX\"'\" \" +\"\n   QUEUE profile\"+\"\n   QUEUE number||library||fontlib\" +\"\n   QUEUE INDEX||PSEGLIB\" +\"\n   QUEUE \"DEV(\"device\")\"charsx continue||PSA||UP||FP\"SYS(\"sysvar\") + \"\n   QUEUE \"M(ID\"trace||delay\")\"||PAGE||FILE bind||spell\n   QUEUE \" SEND 'BATCH   SCRIPT RC=\"RC\"',U(IS03)\"\n   QUEUE \"$$\"\n   \"SUBMIT * END($$)\"\n    return 1\nend\nSAY \"------------- Script will be invoked now --------------\"\nAddress \"TSO\" \"SCRIPT '\"DSNXX\"'\"||profile,\n number||library||fontlib||INDEX||PSEGLIB,\n \"DEV(\"device\")\"charsx continue||PSA||UP||FP\"SYS(\"sysvar\")\",\n \"M(ID\"trace||delay\")\"||page||FILE bind||spell\nScriptRC = rc\nScriptRCc = ScriptRC\nSAY \"Script/VS RC=\"ScriptRC\", OUTDES=OUTDES NAME1 \"outdes\n Address \"TSO\" \"$time @SCRIPT --\"\nIF EDIT = \"BROWSE\"  &  substr(device,1,2) = \"PG\"  then do\n   VSTSRVTI = listxdsn    /* e.g.  PG1A, PG1A90, PG4A, PG4A90 */\n   Address \"ISPEXEC\" \"VPUT (VSTSRVTI) SHARED\"\n   DSNDESC = \"Page count may be determined with   F X'D3A8AF' ALL\"\n   ADDRESS \"ISPEXEC\" \"VPUT (DSNDESC) SHARED\"\n   /* PANEL SYSBROB2 WILL TREAT CMDVAR  AS INITIAL COMMAND*/\n   CMDVAR = \"F X'D3A8AF' ALL\"\n   ADDRESS \"ISPEXEC\" \"CONTROL NONDISPL ENTER\"\n   ADDRESS \"ISPEXEC\" \"BROWSE DATASET(\"listxdsn\") PANEL(SYSBROB2)\"\n   if ScriptRC = 0 then do  /* give a chance to cancel */\n    say \"Hit ENTER to print, type CANCEL to not print\";say '***'\n    Address \"REXX\"\n    pull answer\n    Address \"TSO\"\n    answer = translate(answer)\n    ZEDSMSG = \"Not Printed, Script/VS RC=\"ScriptRC\n    ZEDLMSG = \"SCRIPT invoked by\" SYSVAR(SYSICMD) ,\n         \"RC=0, not printed by your request to CANCEL\"\n    Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    if \"CAN\" = substr(answer,1,3) then return 1\n   end\nend\nelse IF EDIT \\= '' then do\n   if edit = 'BROWSE' then say ,\n     \"page count may be determined with  F x'D3A8AF' all\"\n   address \"TSO\" \"$\"EDIT  listxdsn  macro\n   return 1\nend\nif VIEW = \"VIEW\" then do\n   Address \"TSO\" \"%CSTSVW   VIEW\"\n   return 1\nend\nif ScriptRC \\= 0 then do\n    ZEDSMSG = \"Script/VS RC=\"ScriptRC\n    ZEDLMSG = \"SCRIPT invoked by\" SYSVAR(SYSICMD) ,\n         \", please fix your text, Script/VS RC=\"ScriptRC\n    Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    say '==========> Your SCRIPT text has errors.  <================='\n    say '=====> Please make a note of errors shown above. <=========='\n    say 'Then hit ENTER, to return to your text and to fix errors.   '\n    say '***                   TO FORCE PRINTING, reply with CONTINUE'\n    Address \"ISREDIT\" \"F ':docprof' 1 first\"\n    if rc = 0 then say '*** :docprof -- use option  B  for BookMaster'\n    Address \"ISREDIT\" \"F ':userdoc' 1 first\"\n    if rc = 0 then say '*** :userdoc -- use option  B  for BookMaster'\n    Address \"ISREDIT\" \"F ':prolog' 1 first\"\n    if rc = 0 then say '*** :prolog  -- use option  B  for BookMaster'\n    say '***'\n    Address \"REXX\"\n    arg answerx  /* eliminate any garbage */\n    pull answer\n    Address \"ISREDIT\"\n    answer = translate(answer)\n    /*testing -- if device = 'PG1A90' then answer = \"CONTINUE\"*/\n    if answer = \"CONTINUE\" then ScriptRCc = 0\nend\nIF ScriptRCc = 0 THEN DO\n   ZEDSMSG = \"Script/VS RC=\"ScriptRC\n   ZEDLMSG = \"SCRIPT invoked by\" SYSVAR(SYSICMD) \"ran fine RC=0\"\n   if ScriptRCc \\= ScriptRC then\n       ZEDLMSG = \"Script/VS invoked by\" SYSVAR(SYSICMD) ,\n          \"(forced to continue) RC=\"ScriptRC\n   Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   if \"NOPRINT\" = noprint then do\n       say \"ended by NOPRINT option\"\n       return 1\n   end\n   Address \"TSO\"\n   status = msg('off')\n   \"FREE OUTDES(NAME1) FI(SYSUT1 SYSUT2 SYSPRINT)\"\n   status = msg('on')\n   if groupid = '' then if formdef \\= '' then\n      outdes = outdes 'GROUPID('formdef')'\n   SAY \"OUTDES NAME1 \" OUTDES\n   \"OUTDES NAME1\" OUTDES\n   if rc \\=0 then do\n   end\n   \"ALLOC FI(SYSPRINT) DUMMY                 \"\n   \"ALLOC FI(SYSUT1) DA(\"listxdsn\") SHR\"\n   \"ALLOC FI(SYSUT2) SYSOUT(\"class\") OUTDES(NAME1) \"\n   \"ALLOC FI(SYSIN) DUMMY REUSE              \"\n   \"CALL 'SYS1.LINKLIB(IEBGENER)'            \"\n   if rc = 0 then\n   SAY \"Document has been Printed to CLASS(\"class\")\"\n   \"FREE FI(SYSUT1 SYSUT2) OUTDES(NAME1)     \"\n   \"ALLOC FI(SYSIN) DA(*) REUSE              \"\n   \"ALLOC FI(SYSPRINT) DA(*) REUSE           \"\n   if idata = \"IDATA\" then if timinig = \"TIMING\" then \"%IDATA1\"\nEND\nAddress \"ISREDIT\" ,\n\"LINE_BEFORE .ZCSR = NOTELINE \"\"\"TIME('N') \" ===> \" SYSVAR(SYSICMD),\n   \"--completed Script/VS RC=\"ScriptRC  Date('U') \"\"\"\"\nexit\nSayboth: procedure expose document\n arg saying\n Say saying\n address \"ISREDIT\" \"LINE_BEFORE .ZF = NOTELINE \"\"\"Saying\"\"\"\"\n if document = \"DOC\" then do\n    address \"ISREDIT\" \"LINE_BEFORE .ZL = DATALINE \"\"     \"Saying\"\"\"\"\n end\n return\nProcess: procedure expose token\n arg subtoken\n i = index(token,' '||subtoken||' ')\n if i=0 then return ''\n tokenx = substr(token,1,I) || substr(token,I+2+length(subtoken))\n token = tokenx\n return subtoken\nProcessB: procedure expose token\n arg subtoken\n x = process(subtoken)\n if x \\='' then x = ' '||x\n return x\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@SCRPTDU": {"ttr": 3331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00u\\x00u\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 117, "newlines": 117, "modlines": 0, "user": "MCRITCH"}, "text": "   ISREDIT  MACRO\n  /*            CONTROL LIST CONLIST SYMLIST\n  /* SET PREFIX = &SUBSTR(1:4,&SYSUID.XXXX) */\n     IF &SYSPREF = THEN SET PREFIX = &SYSUID.\n     ELSE SET PREFIX = &SYSPREF.\n /* TITLE:        @SCRPTDU THE MEMBER CURRENTLY DISPLAYED IN EDIT\n /* CONTRIBUTED:   F. DAVID MCRITCHIE             1986/02/04\n /* USER CONTACT:  F. DAVID MCRITCHIE\n /* CODE MAINT.:   SYSTECH GROUP\n /*                                                                  */\n /*  EXAMPLES:    @SCRPTDU                                           */\n /****************************                                       */\n /*   BATCH OPTIONS                                                  */\n /*@SCRPTDU BATCH VIEW                                               */\n /*     *BATCH JOB SUBMITTED -- WHEN MESSAGE IS RECEIVED ENTER:*     */\n /*@SCRPTDU REFORMAT                                                 */\n /****************************                                       */\n /*    THE DEFAULT FOR BOTH .CL AND .LL IS 60                        */\n /*    THE FOLLOWING CODE WILL BE GENERATED BY DSMPROF4 TO FACILITATE*/\n /*    PROPER VIEWING.  (NORMALLY DSMPROF4 IS IN USE)                */\n /*            .LL 78;.SE PCLL = 78;.CM              LOWERCASE       */\n /*            .CL 78;.SE PCLL = 78;.CM          ALL LOWERCASE       */\n /*            .SE PROF4LL = 78;.SE PROF4CL = 78;.CM   CAPITALS      */\n /***************************************************************    */\n /** DOCUMENTED  IS03.SHARE.TEXT(@SCRPTDU)                           */\n /*****************************************************************  */\n        ISREDIT (MEMBERX) = MEMBER\n        ISREDIT (DSNX)    = DATASET\n        IF MANUAL = &MEMBERX THEN DO\n            ISREDIT END\n            EXIT CODE(1)\n        END\n VIEWMEM: -\n   ISREDIT (DCHG) = DATA_CHANGED\n    IF &DCHG = YES THEN DO\n       WRITE *******************************************************\n       WRITE * YOUR FILE HAS NOT BEEN SAVED AFTER MAKING CHANGES   *\n       WRITE * SPELLING CHECK REQUIRES ABILITY TO SCRIPT YOUR DATA.*\n       WRITE *                                                     *\n       WRITE * CANNOT SCRIPT UNLESS YOU HAVE SAVED YOUR DATA AFTER *\n       WRITE * MAKING CHANGES.                                     *\n       WRITE *                                                     *\n       WRITE * THE CLIST  \"@SAVE\"  CAN BE USED TO SAVE  IF,        *\n       WRITE *     AND ONLY IF, DATA CHANGED                       *\n       WRITE *******************************************************\n       WRITE REPLY <ENTER KEY> OR TYPE \"CAN\": TO TERMINATE REQUEST\n       WRITE REPLY \"SAVE\"   | \"SAV\" TO SAVE THEN BEGIN SCRIPT\n       WRITE REPLY \"CANCEL\" | \"CAN\" IF YOU WANT TO TERMINATE REQUEST\n       READ PARM1\n       IF &SUBSTR(1:3,&STR(&SYSCAPS(&PARM1.)   )) = CAN THEN DO\n          WRITE TERMINATED BY YOUR COMMAND ... \"CAN\".\n          SET &ZEDSMSG = &STR(TERMINATED)\n          SET &XEDLMSG = &STR(CHANGES DONE SINCE LAST SAVE -- +\n                      YOU HAVE REPLIED TO CANCEL @SCRIPT)\n          SET &ZEDLMSG = &STR(&XEDLMSG.)\n          ISPEXEC     SETMSG MSG(ISRZ000)\n          EXIT CODE(8)\n       END\n       IF &SUBSTR(1:3,&STR(&SYSCAPS(&PARM1.)   )) = SAV THEN DO\n          ISREDIT SAVE\n          SET RC = &LASTCC.\n          /* 0 - NORMAL SAVE, 4 - NEW MEMBER SAVED, 12 DATA NOT SAVED\n          IF &RC. > 4  THEN DO\n           WRITE ******************************************************\n           WRITE * UNABLE TO SAVE YOUR FILE   RC = &RC.               *\n           WRITE ******************************************************\n           SET &ZEDSMSG = &STR(TERMINATED)\n           SET &XEDLMSG = &STR(UNABLE TO SAVE CHANGES -- +\n                       PERHAPS A COMPRESS IS NEEDED)\n           SET &ZEDLMSG = &STR(&XEDLMSG.)\n           ISPEXEC     SETMSG MSG(ISRZ000)\n           EXIT CODE(8)\n          END\n          GOTO SAVED\n       END\n       SET &ZEDSMSG = &STR(CHANGED DATA)\n       SET &XEDLMSG = &STR(CHANGES DONE SINCE LAST SAVE -- +\n                   @SCRPTDU TERMINATED FOR THIS READON...)\n       SET &ZEDLMSG = &STR(&XEDLMSG.)\n       ISPEXEC     SETMSG MSG(ISRZ000)\n       EXIT CODE(8)\n    END\n  SAVED: -\n  SET R40 = R40\n/*  ISREDIT (MEMBERX) = MEMBER\n/*  ISREDIT (DSNX)    = DATASET\n  SET MEMBERA = &MEMBERX.\n  IF S = &SUBSTR(1:1,&MEMBERX.X) THEN DO\n     IF &SUBSTR(6:8,&MEMBERX.         ) = &STR(   ) THEN DO\n       IF &STR(&DSNX) = &STR(TECH.LIBR2.TEXT) THEN DO\n        IF NUM = &DATATYPE(&SUBSTR(2:5,&MEMBERX.XXXXXXXX)) THEN DO\n          IF  X = X&SUBSTR(6:6,&MEMBERX.        ) THEN DO\n           SET MEMBER2 = A&SUBSTR(2:5,&MEMBERX.        )\n           WRITE SUBSTITUTION \"&MEMBER2.\" FOR \"&MEMBERX.\"\n           SET MEMBERA = &MEMBER2.\n          END\n        END\n       END\n    END\n  END\n  IF &STR(&MEMBERX.) ^= &STR() THEN SET DSNXX = &STR(&DSNX.)&LP.&MEMBERX.&RP.\n  CONTROL LIST CONLIST\n   SCRIPT '&DSNX(&MEMBERA)'  -\n     PRO('SCRIPT.&R40..MACLIB(DSMPROF4)') L('SCRIPT.&R40..MACLIB') -\n     INDEX BIND(0 0) -\n     CONT SPELLCHK SYSVAR(X NO H NO D NO) M(ID DELAY) -\n     FILE('&PREFIX..DUDUDU.LIST(&MEMBERX)')\n   $EDIT  '&PREFIX..DUDUDU.LIST(&MEMBERX)'  MACRO(@SCRPTD2)\n   COPY   '&PREFIX..DUDUDU.LIST(&MEMBERX)'  '&DSNX(JUNKDU)' NONUM\n   $EDIT  '&DSNX(JUNKDU)' MACRO(@SCRPTD4)\n   ISREDIT LABEL .ZLAST = .SCRP 0\n   SET &ZEDSMSG = &STR(JUNKDU CREATED)\n   SET &ZEDLMSG = &STR(@SCRPTD3 CAN BE USED TO MERGE IN MEMBER JUNKDU)\n   ISREDIT     LINE_BEFORE 1 = NOTELINE \"&ZEDLMSG.\"\n   ISPEXEC     SETMSG MSG(ISRZ000)\n   ISREDIT     LOC 0\n   EXIT CODE(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@SEARCH4": {"ttr": 3334, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x000\\x000\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX test of command for 2.3.14 SearchFor                  */\n/* CREATED by D.McRitchie, \"The REXX Macros Toolbox\", 1991/10/24 */\n/* comparable tso rexx exec is  search4                       */\n/* multiple search arguments must be separated by commas      */\n/*  without intervening spaces unless part of search arg.     */\n/*    e.g.  ===> @SEARCH4 1a 1b,c2 d2 e2,'3f 3g 3h 3i',j4     */\n/* ---------------------------------------------------------- */\n/*********************************************************************/\n/*  Manual for ISPF/PDF Guide and Ref. V3R3 MVS -- SC34-4258-01      */\n/*********************************************************************/\n/*  This macro used to work with the original ISRFSPR panel   */\n/*  but the PGM has probably been changed so that the following*/\n/*  code now must be added to the ISRFSPR panel under )INIT   */\n/*  Related execs and macros: SRCH400, SRCH401                */\n/*********************************************************************/\n/*  IF (&ZSSFNDSN = &Z)                     /-* MCRITCHIE   1993/09/20 */\n/*    IF (&DSSFNDSN ^= &Z)                  /-* MCRITCHIE   1993/09/20 */\n/*      &ZSSFNDSN = &DSSFNDSN               /-* FOR @SEARCH 1993/09/20**/\n/*********************************************************************/\nAddress \"ISREDIT\"; \"MACRO (TOKEN)\"\n\"(DSNX)    = DATASET\"\nParse arg \"'\"DSN\"'\"\nif dsn = '' then dsn = dsnx\ndsn = ''''||DSN||'(*)'''\n/* zssfndsn = dsn */\ndssfndsn = dsn   /* this variable with sept 1993  SYSGEN*/\n\nif token  = '' then\n   Address \"ISPEXEC\" \"VPUT (DSSFNDSN)\"\nelse do\n   /* conditional update of VPUT arguments */\n   parse var token zssfs1 ',' zssfs2 ',' zssfs3 ',' zssfs4 ',' ,\n            zssfs5 ',' zssfs6 ',' zssfs7\n   /*  single imbedded quotes are invalid, even within double quotes*/\n   /*  -- will not be tested for here, left to SEARCHFOR to tell you*/\n   do i = 1 to 7 /*interpret executes expression*/\n      x = \"if zssfs\"i\" /= '' then if substr(zssfs\"i\",1,1) /= ''''\" ,\n      \" then do;j = index(zssfs\"i\",' ');if j/=0 then zssfs\"i ,\n          \" = \"\"'\"\"zssfs\"i\"\"\"'\"\";end\"  /* say x -- to debug*/\n      interpret x; /*change if any blank, unless begins with quote*/\n   end\n   if zssfs2 = '' then zssfmult = 'NO'; else zssfmult = 'YES'\n   Address \"ISPEXEC\" \"VPUT (dssfndsn,ZSSFMULT ZSSFS1 ZSSFS2 \",\n            \"ZSSFS3 ZSSFS4 ZSSFS5 ZSSFS6 ZSSFS7)\"\nend\nAddress \"ISPEXEC\" \"SELECT PGM(ISRSFM)\"  /* OPT 2.3.14  Search*/\n DSSFNDSN=\"\"; ZSSFNDSN=\"\"\n   Address \"ISPEXEC\" \"VPUT (DSSFNDSN ZSSFNDSN)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@SEQ": {"ttr": 3336, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xe5\\x00\\xe5\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 229, "newlines": 229, "modlines": 0, "user": "MCRITCH"}, "text": " /* REXX -- @SEQ Place sequence numbers into data for use of sort etc.\n     Title:       Place sequence numbers into data for use of sort etc.\n     Users:       TSO ISPF edit users\n     Contributed: 1986/11/17 David McRitchie, \"The REXX Macros Toolbox\"\n     Converted to REXX: 1993/05/01 F. David McRitchie, \"The REXX Macros Toolbox\"\n\n     Example:     @SEQ\n     example:     @SEQ     .zfirst .zlast col(100) l(8)   =equivalent=\n     example:     @SEQ     force ast(**) col(100) l(12) nx\n     example:     @SEQ     add(13) .a .b col(53) l(4)   nx\n\n     OPTIONS:\n         NX | X    (optional)  Process all, or non-excluded, or\n                    excluded lines do not exclude .zfirst line since\n                    this clist utilizes \"loc 0\" which will make it no\n                    longer excluded and will alter processing.\n         LPTR-RANGE  (optional) Line pointer range\n         ADD(NN)   (optional) Adds to existing numbers the constant nn\n         COL(NN)   (optional) Default is 100, columm that 8-digit\n                    sequence number will go into\n         INCR(NN)  (optional) Increment used when begin(nn) used\n                    default is 1\n         L(N)      (optional) Default is 8, length of sequence number\n                    field including ast(x) prefix and suffix if\n                    supplied\n         FORCE     Force sequence numbers into specified columns even\n                    if specified columns are non-blank cannot be use\n                    with  the exclude option   \"x\"\n         BEGIN(N)  (optional) Supply a beginning number for\n                    sequencing; otherwise, the  edit sequence number of\n                    the card will be used.  if  nx | x is used only\n                    those lines will be changed and cause an increment.\n         INCR(NN)  (optional) Increment from begin(n) after first is\n                    done\n         REPEATX   Place latest sequence number in x cards -- labels\n                    required\n                    force will cause x cards to be changed as well as\n                    nx cards\n         AST       (optional)  Reset ast value from null to \"*\"\n         AST(CC)   (optional)  Reset ast value  to \"cc\" value specified\n                   may be any number of characters and will surround\n                   the column length defined numbers as a set off.\n      <<<ADDITIONAL operands>>>\n     --- METHOD TO spread numbers in manuals library ----\n         C ALL .A .B 1 P'##$##' '     '\n         X ALL .A .B\n         REMDUPS .A .B SEP 1 20\n         @SEQ .A .B REPEATX COL(1) BEGIN(7701) INCR(11) L(4) FORCE\n         REFORMAT .A .B 1 2 '.' 3 4 '-' 7 250\n         RESET .A .B \\ X .A .B 9 '=====' ALL \\ DEL X .A .B ALL\n\n     REQUIREMENTS:\n       ...............................................*/\n\n ADDRESS 'ISREDIT'; 'MACRO (PARMS) NOPROCESS';\n NOTE = 'LINE_BEFORE .ZFIRST = NOTELINE ';\n INCR=1;ADD='';COL='';BEGIN=\"\";L='';AST='';\n DEBUG='';TEST='';REMAINDER='';LABF='';LABL='';\n X='';NX='';FORCE=''; repeatx='';ast='';\n\n /* COLLECT PARAMETERS */\n IF PARMS = '' THEN DO;  /* NO PARAMETERS -- DEFAULT TO A TEST*/\n    ZEDSMSG = ''\n    ZEDLMSG = \"@SEQ MISSING OPERANDS SUCH AS\",\n       \"COL(3) INCR(1) BEGIN(1)\"\n    ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    EXIT 8\n END\nPARMS = TRANSLATE(PARMS)\n\n/* NOT SUITED FOR IMBEDDED BLANKS BUT WILL SEE INITIAL ENDING QUOTES*/\n DO III = 1 TO 10;\n   TOKEN = WORD(PARMS,III)\n   IF TOKEN = '' THEN LEAVE\n   TOKENX = TRANSLATE(TOKEN);\n   IF TOKENX = \"DEBUG\" THEN DO\n      TRACE INTERMEDIATE\n   END\n   J = POS(TOKENX,' DEBUG TEST FORCE NX X REPEATX AST ')\n   IF J <> 0 THEN DO;\n      STRING = TOKEN ' = '''TOKEN''''; INTERPRET  STRING; ITERATE III;\n   END;\n   IF 'ADD(' = SUBSTR(TOKEN,1,4)     THEN DO;\n      PARSE VAR TOKEN  'ADD(' ADD ')' RIGHT; ITERATE III;\n   END\n   IF 'AST(' = SUBSTR(TOKEN,1,4)     THEN DO;\n      PARSE VAR TOKEN  'AST(' AST ')' RIGHT; ITERATE III;\n   END\n   IF 'COL(' = SUBSTR(TOKEN,1,4)     THEN DO;\n      PARSE VAR TOKEN  'COL(' COL ')' RIGHT; ITERATE III;\n   END\n   IF SUBSTR(TOKEN,1,5) = 'INCR(' THEN DO;\n      PARSE VAR TOKEN  'INCR(' INCR ')' RIGHT; ITERATE III;\n   END\n   IF 'BEGIN(' = SUBSTR(TOKEN,1,6)   THEN DO;\n      PARSE VAR TOKEN  'BEGIN(' BEGIN ')' RIGHT; ITERATE III;\n   END\n   IF 'L(' = SUBSTR(TOKEN,1,2)     THEN DO; /*TEST LATER THAN COL()*/\n      PARSE VAR TOKEN  'L(' L ')' RIGHT; ITERATE III;\n   END\n   IF SUBSTR(TOKEN,1,1) = '.' THEN DO\n      IF LABF = '' THEN LABF = TOKEN\n      ELSE IF LABL = '' THEN LABL = TOKEN\n      ELSE DO\n            ZEDSMSG = '.LABEL RC=8'\n            ZEDLMSG = 'TOO MANY LABELS --' LABF LABL TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            EXIT 8\n      END\n      ITERATE III\n   END\n\n   IF SUBSTR(TOKEN,1,1) = \"'\" THEN DO /* \"'\"*/\n      SEPSTR = SUBSTR(TOKEN,2,VALUE(LENGTH(TOKEN)-2))\n      ITERATE III\n   END\n\n   SAY 'TESTING REMAINDER --' TOKEN '<--'\n   REMAINDER = REMAINDER TOKEN\n END III\n\n IF REMAINDER <> \"\" THEN DO\n    ZEDSMSG =  REMAINDER\n    ZEDLMSG =  REMAINDER \"-- PARAMETERS UNKNOWN TO @SEQ\"\n    ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    EXIT 8\n END\n\n/* PROCESS ADDITIONAL LABEL / RANGE RELATIONSHIPS */\nIF LABL = '' THEN DO\n   \"PROCESS RANGE C\"\n   IF RC = 0 THEN DO\n      \"LABEL .ZFRANGE = .LABF 1\"\n      \"LABEL .ZLRANGE = .LABL 1\"\n      LABF = \".LABF\"\n      LABL = \".LABL\"\n   END\nEND\nIF LABL = '' THEN DO; LABF='.ZFIRST'; LABL='.ZLAST'; END;\n\"(LABFNO) = LINENUM\" LABF\nIF RC \\= 0 THEN EXIT 12\n\"(LABLNO) = LINENUM\" LABL\n\n IF FROMCOL \\= '' THEN IF TOCOL = '' THEN DO\n       ZEDSMSG =  \"FROM/TO\"\n       ZEDLMSG =  \"FROM/TO PAIR INVALID, MISSING TO COLUMN\"\n       \"LINE_BEFORE .ZFIRST = NOTELINE\" \"FROM/TO PAIR INVALID,\",\n            \"MISSING TO COLUMN\"\n       ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n       EXIT 8\n  END\n\n/****** ALL PARAMETERS HAVE BEEN RECEIVED -- PROCESS RELATIONSHIPS */\n        /****************** CODE FOR  @SEQ COMMANDS ***************/\n        /****************** CODE FOR  @SEQ COMMANDS ***************/\n        /****************** CODE FOR  @SEQ COMMANDS ***************/\n    IF REPEATX = \"REPEATX\" THEN NX = \"NX\"\n    IF COL=\"\" THEN COL = 100\n    IF ast = \"AST\" then ast = \"*\"\n    if l = '' then l = 8\n    NDCOL = col + L - 1\n    IF ADD \\= '' THEN SIGNAL ADDEM\n    BLANKS=SUBSTR(' ',1,32)\n    IF FORCE  = \"FORCE\" THEN IF X = \"X\" THEN DO\n       ZEDSMSG = \"FORCE & X\"\n       ZEDLMSG = \"FORCE OPTION INCOMPATIBLE WITH  X OPTION\"\n       ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n       EXIT 12\n    END\n    IF FORCE = \"FORCE\" THEN\n           \"Change\" LABF LABL \"ALL P'^'\" COL VALUE(COL+L-1) \"' '\"  NX\n           /* lines with \"^\" check OS/2 <--> TSO/E bad translations*/\n /* \"LOC 0\"*/\n    \"SEEK\" X  NX  LABF  LABL \"FIRST\" COL \"'\"SUBSTR(' ',1,L)\"'\"\n    IF RC \\=0 THEN SIGNAL DONE\n    astl = l - length(ast) - length(ast)\n    if astl < 1 then do\n       ZEDSMSG = \"L value low\"\n       ZEDLMSG = \"L value must be at least 1 plus 2X length ast Value\"\n       ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n       EXIT 12\n    END\n    /*.....................................*/\n    XYZ = \"@SEQ\" PARM\n    \"LINE_AFTER 0 = NOTELINE (XYZ)\"\n    if begin \\= \"\" then\n       I = BEGIN - incr  /* correction 1993/10/12 D.McR*/\n    SIGNAL R2\n  R: IF REPEATX = \"REPEATX\" THEN DO\n      \"SEEK\" LABF  LABL \"NEXT\"  COL \"'\"SUBSTR(' ',1,L)\"'\"\n      IF RC \\= 0 THEN SIGNAL DONE\n      SIGNAL R2\n    END\n    \"SEEK\" X NX LABF LABL \"NEXT\" COL \"'\"SUBSTR(' ',1,L)\"'\"\n    IF RC \\= 0 THEN SIGNAL DONE\nR2: IF BEGIN = \"\" THEN \"(I) = LINENUM .ZCSR\"\n    ELSE DO\n       IF REPEATX = \"REPEATX\" THEN DO\n          \"(VAR075) = XSTATUS .ZCSR\"\n          IF VAR075 = \"X\" THEN SIGNAL R2U\n       END\n       IF INCR = 0 THEN INCR = 1\n       ELSE I = I + INCR\n    END\nR2U:\n    \"CHANGE .ZCSR .ZCSR FIRST\" COL \"'\"SUBSTR(\" \",1,L)\"' '\"AST,\n          ||RIGHT(I,astL,'0')||AST\"'\"\n    IF X = \"X\" THEN \"EXCLUDE .ZCSR .ZCSR ALL\"\n    IF REPEATX = \"REPEATX\" THEN\n       IF VAR075 = \"X\" THEN \"EXCLUDE .ZCSR .ZCSR ALL\"\n    SIGNAL R\n ADDEM:\n     IF ADD=0 THEN SAY \"..........DEAD.......\"\n     PICSTR =  SUBSTR('###########################',1,L)\n     \"LOC 0\"\n     \"LOC\" LABFNO\n     \"SEEK\" X  NX  LABF  LABL \"FIRST\" COL \"P'\"PICSTR\"'\"\n     IF RC \\= 0 THEN SIGNAL DONE\n     \"LINE_AFTER 0 = NOTELINE \"\"@SEQ\" LABF LABL \"ADD(\"ADD\")\" X,\n          ||NX \"COL(\"COL\") L(\"L\")\"\"\"\n     SIGNAL TADD2\n TADD1: \"SEEK\" X NX LABF LABL \"NEXT\" COL \"P'\"PICSTR\"'\"\n     IF RC \\= 0 THEN SIGNAL DONE\n TADD2: \"(VAR036) = LINE .ZCSR\"\n     I = VALUE(SUBSTR(VAR036,COL,L)) + ADD\n     \"Change ALL .ZCSR .ZCSR\" COL \"P'\"PICSTR\"' '\"RIGHT(I,L,'0')\"'\"\n     IF X = \"X\" THEN \"EXCLUDE .ZCSR .ZCSR ALL\"\n     SIGNAL TADD1\n DONE:  EXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@SLCT": {"ttr": 3341, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00W\\x00W\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 87, "newlines": 87, "modlines": 0, "user": "MCRITCH"}, "text": "      ISREDIT MACRO\n      /* @SLCT -- CREATE JCL TO UTILIZE  PROC=SLCTTSO\n      /*   CREATED BY DAVID MCRITCHIE, NOV 14, 1986,                 */\n      /*   AVAILABLE TO ANYONE WHILE IN EDIT  */\n      /* -- A DOWN OPTION WOULD SAVE TIME BY ELIMINATING EDIT CHANGES*/\n      ISREDIT (VAR018) = DATAID\n      ISREDIT (VAR018A) = DATASET\n      ISREDIT (VAR043) = MEMBER\n      SET EXAMP = &SUBSTR(1:4,&VAR043.     )\n      ISREDIT RESET\n        ISREDIT (DWIDTH) = DATA_WIDTH\n        SET DWIDTH2 = &DWIDTH + &DWIDTH     /* CAN BE USED TO FORCE AN ERROR */\n        ISREDIT (LBOUND,RBOUND) = BOUNDS\n        SET XLBOUND = &EVAL(&LBOUND)\n        SET XRBOUND = &EVAL(&RBOUND)\n        IF XRBOUND = &STR() THEN SET XRBOUND = &EVAL(&DWIDTH.)\n        ISREDIT     (VAR019,VAR020) = DISPLAY_COLS\n /*     WRITE    LBOUND=&LBOUND  RBOUND=&RBOUND  DWIDTH=&DWIDTH  DISPLAY(&VAR019\n        IF &EVAL(1000 + &DWIDTH) > &EVAL(1080) THEN SET TEXT = TEXT\n    ISREDIT FIND '?' FIRST\n  SET $D$ = &STR(LINE_AFTER  .ZLAST = DATALINE)\n  SET $N$ = &STR(LINE_BEFORE .ZLAST = NOTELINE)\n     ISREDIT (VAR037) = LINENUM .ZLAST\n     IF &EVAL(&VAR037)  = &EVAL(0) THEN DO\n     ISREDIT LINE_AFTER 0 = DATALINE -\n                        &STR(\"//* TITLE: LIST    SELECTIVE SEARCH AND PRINT ANY\n  ISREDIT &$N$ &STR(\"............ YOU WILL NEED A JOBCARD, IF YOU DO NOT HAVE A\n  ISREDIT &$N$ &STR(\"............ CLIST, YOU MAY PATTERN ONE FROM IS03.LIBR.CLIS\n     END\n     ELSE  ISREDIT &$D$ &STR(\"//* TITLE: LIST    SELECTIVE SEARCH AND PRINT ANY\n  ISREDIT LABEL .ZLAST = .SLCT\n  ISREDIT &$D$ &STR(\"//* JCL CREATED:   BY THE EDIT MACRO  @SLCT    AT )&SYSTIME\n  ISREDIT &$D$ &STR(\"//* USER CONTACT AND CODE MAINTENANCE: DAVID MCRITCHIE\n  ISREDIT &$D$ &STR(\"//&VAR043. EXEC SLCTTSO,SYSOUT=V,\n  ISREDIT &$D$ &STR(\"//**          OUTPUT='*.DOWN8',LC=78,\n  ISREDIT &$D$ &STR(\"//            LIB='&VAR018A.'  <== ?? CHECK DSNAME\n  ISREDIT &$N$ &STR(\"==========> PLEASE CHECK THAT LIB=  BELOW HAS CORRECT DSNAM\n  ISREDIT &$D$ &STR(\"//PRINTER   DD  SYSOUT=9   DIRECTORY LIST SUPPRESSED IF SYS\n  ISREDIT &$D$ &STR(\"//SEARCH    DD  * OPTIONAL SEARCH CARDS FOLLOW\n  ISREDIT &$D$ &STR(\"//SYSIN     DD  * OPTIONAL SELECT MEMBER CARDS FOLLOW\n  ISREDIT &$N$ &STR(\"*.COPY*            <=== EXAMPLE OF A SEARCH  INPUT CARD\n  ISREDIT &$N$ &STR(\"* EXEC COPY *      <=== EXAMPLE OF A SEARCH  INPUT CARD\n  ISREDIT &$N$ &STR(\"* EXEC COPY,*      <=== EXAMPLE OF A SEARCH  INPUT CARD\n  IF &EXAMP ^= &VAR043. THEN -\n     ISREDIT &$D$ &STR(\"EXCLUDE=&VAR043.*      SPECIFICALLY EXCLUDES MEMBER &VAR\n  ISREDIT &$N$ &STR(\"==========> PLEASE CHECK MEMBER SELECTION AFTER //SYSIN DD\n  ISREDIT &$N$ &STR(\"==========> REMOVE ALL SELECTIONS TO PRINT / SEARCH ENTIRE\n  ISREDIT &$D$ &STR(\"&EXAMP        <=??= WILL SELECT ALL OTHER MEMBERS BEGINNING\n  ISREDIT &$D$ &STR(\"================ PLACEMENT OF ENDING COMMENT ==============\n  ISREDIT &$N$ &STR(\"===========================================================\n  ISREDIT &$N$ &STR(\"| SELECTION CRITERIA  USED BY PGM=IZ2018 IN PROC=SLCTTSO IS\n  ISREDIT &$N$ &STR(\"|      AS USED BY PGM=IZ2019 AND CONSISTS OF EXAMINATION OF\n  ISREDIT &$N$ &STR(\"|      NAMES, CHECKING ON CORRESPONDING POSITIONS OF MEMBER\n  ISREDIT &$N$ &STR(\"| @,#,$,A-Z,0-9   EXACT MATCH IN CORRESPONDING COLUMN REQUI\n  ISREDIT &$N$ &STR(\"| %               MUST BE A LETTER @,#,$,A-Z\n  ISREDIT &$N$ &STR(\"| +               MUST BE A DIGIT 0-9 IN CORRESPONDING COLU\n  ISREDIT &$N$ &STR(\"| *               MUST BE A BLANK, HENCE REMAINDER ALSO BLA\n  ISREDIT &$N$ &STR(\"|//SYSIN  DD *\n  ISREDIT &$N$ &STR(\"|EXCLUDE= BCD      EXCLUDE CARDS MUST PRECEDE INCLUDE=  CAR\n  ISREDIT &$N$ &STR(\"|EXCLUDE=A   E     EXCLUDE MEMBERS BEGINNING WITH 'A', AND\n  ISREDIT &$N$ &STR(\"|INCLUDE=ABCDE     MEMBER ABCDE EXCLUDED ABOVE, BUT ABCDE1\n  ISREDIT &$N$ &STR(\"|ABCED             SAME AS   IF PREFIXED WITH INCLUDE=ABCDE\n  ISREDIT &$N$ &STR(\"===========================================================\n  ISREDIT &$N$ &STR(\"| ------- DEFAULT PRINTS HORIZONTALLY ON 3800 -------------\n  ISREDIT &$N$ &STR(\"| LC=88,OUTPUT=H3800  DEFAULT -- PRINTS HORIZONTALLY ON 380\n  ISREDIT &$N$ &STR(\"| ------- ADD JCL PARAMETERS TO PRINT IN NORMAL CHARACTERS\n  ISREDIT &$N$ &STR(\"| LC=60,OUTPUT=LC60   PRINT USING REGULAR CHARS=GT15,FCB=8X\n  ISREDIT &$N$ &STR(\"|          IN SMALL LETTERS  12/INCH VERICAL, 15/INCH HORIZ\n  ISREDIT &$N$ &STR(\"| ------- PRINT OPTIONS TO PRINT ON VERITICAL -SCRIPT- PAPE\n  ISREDIT &$N$ &STR(\"| LC=80,OUTPUT=LC80    MEMBER NAME, 2 BLANKS, 105 CHAR/LINE\n  ISREDIT &$N$ &STR(\"|LC=120,OUTPUT=V3800   MEMBER NAME, 2 BLANKS, 105 CHAR/LINE\n  ISREDIT &$N$ &STR(\"===========================================================\n  ISREDIT &$N$ &STR(\"|USAGE:         SOURCE TYPE PDS -- NOT RECFM=U\n  ISREDIT &$N$ &STR(\"|PURPOSE: PRINT MEMBERS OF A PDS, AND/OR\n  ISREDIT &$N$ &STR(\"|         SEARCH FOR CHARACTER STRINGS IN A PDS, AND/OR\n  ISREDIT &$N$ &STR(\"|         SELECT MEMBERS BY PGM=IZ2019 STANDARDS\n  ISREDIT &$N$ &STR(\"|         PROC=SLCTTSO SET UP TO PRINT ON A 3800\n  ISREDIT &$N$ &STR(\"|ADDITIONAL INFORMATION:   ===> TSO INFOHELP PGMINDX\n  ISREDIT &$N$ &STR(\"|    PROGRAM   INFORMATION ===> FIND FIRST 'IZ2018:'\n  ISREDIT &$N$ &STR(\"|    MEMBER SELECTION      ===> FIND FIRST 'IZ2019:'\n  ISREDIT &$N$ &STR(\"===========================================================\n  ISREDIT LOCATE .SLCT\n  ISREDIT UP 3\n  ISREDIT FIND NEXT '??'\n  ISREDIT DELETE .ZLAST .ZLAST\n  ISREDIT C ALL 'EXCLUDE=' 'EXCLUDE-'\n  ISREDIT C ALL 'INCLUDE=' 'INCLUDE-'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@SLCTDSX": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00H\\x00H\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 72, "newlines": 72, "modlines": 0, "user": "MCRITCH"}, "text": "      ISREDIT MACRO\n      /* @SLCTDSX -- CREATE JCL TO UTILIZE PROC=SLCTTSO\n      /*   CREATED BY DAVID MCRITCHIE, FEB 04, 1987,                 */\n      /*   AVAILABLE TO ANYONE WHILE IN EDIT  */\n      ISREDIT (VAR018) = DATAID\n      ISREDIT (VAR018A) = DATASET\n      ISREDIT (VAR043) = MEMBER\n      SET EXAMP = &SUBSTR(1:4,&VAR043.     )\n      ISREDIT RESET\n        ISREDIT (DWIDTH) = DATA_WIDTH\n        SET DWIDTH2 = &DWIDTH + &DWIDTH     /* CAN BE USED TO FORCE AN ERROR */\n        ISREDIT (LBOUND,RBOUND) = BOUNDS\n        SET XLBOUND = &EVAL(&LBOUND)\n        SET XRBOUND = &EVAL(&RBOUND)\n        IF XRBOUND = &STR() THEN SET XRBOUND = &EVAL(&DWIDTH.)\n        ISREDIT     (VAR019,VAR020) = DISPLAY_COLS\n /*     WRITE    LBOUND=&LBOUND  RBOUND=&RBOUND  DWIDTH=&DWIDTH  DISPLAY(&VAR019\n        IF &EVAL(1000 + &DWIDTH) > &EVAL(1080) THEN SET TEXT = TEXT\n    ISREDIT FIND '?' FIRST\n  SET $D$ = &STR(LINE_AFTER  .ZLAST = DATALINE)\n  SET $N$ = &STR(LINE_BEFORE .ZLAST = NOTELINE)\n     ISREDIT (VAR037) = LINENUM .ZLAST\n     IF &EVAL(&VAR037)  = &EVAL(0) THEN DO\n     ISREDIT LINE_AFTER 0 = DATALINE -\n                        &STR(\"//* TITLE: XREF  - PDS JCL DSN CROSS-REFERENCE LIS\n  ISREDIT &$N$ &STR(\"............ YOU WILL NEED A JOBCARD, IF YOU DO NOT HAVE A\n  ISREDIT &$N$ &STR(\"............ CLIST, YOU MAY PATTERN ONE FROM IS03.LIBR.CLIS\n     END\n     ELSE  ISREDIT &$D$ &STR(\"//* TITLE: XREF  - PDS JCL DSN CROSS-REFERENCE LIS\n  ISREDIT LABEL .ZLAST = .SLCT\n  ISREDIT &$D$ &STR(\"//* JCL CREATED:   BY THE EDIT MACRO  @SLCTDSX AT )&SYSTIME\n  ISREDIT &$D$ &STR(\"//* USER CONTACT AND CODE MAINTENANCE: DAVID MCRITCHIE\n  ISREDIT &$D$ &STR(\"//* ADDITIONAL INFORMATION:   ===> TSO INFOHELP PGMINDX\n  ISREDIT &$D$ &STR(\"//*                           ===> FIND FIRST 'IV2004:'\n  ISREDIT &$D$ &STR(\"//&VAR043. EXEC SLCTPDS,SYSOUT=V,PGMPARM='NOLIST,LC(88)',\n  ISREDIT &$D$ &STR(\"//           LIB='&VAR018A.'  <== ?? CHECK DSNAME\n  ISREDIT &$D$ &STR(\"//DEFAULT OUTPUT LINECT=0,CHARS=GC15,FCB=2X85\n  ISREDIT &$N$ &STR(\"==========> PLEASE CHECK THAT LIB=  BELOW HAS CORRECT DSNAM\n  ISREDIT &$D$ &STR(\"//SYSIN     DD  * OPTIONAL SELECT MEMBER CARDS FOLLOW\n  IF &EXAMP ^= &VAR043. THEN -\n     ISREDIT &$D$ &STR(\"EXCLUDE-&VAR043.*      SPECIFICALLY EXCLUDES MEMBER &VAR\n     ISREDIT &$D$ &STR(\"INCLUDE-&&              SPECIFICALLY INCLUDE ALL OTHER M\n  ISREDIT &$N$ &STR(\"==========> PLEASE CHECK MEMBER SELECTION AFTER //SYSIN DD\n  ISREDIT &$N$ &STR(\"==========> REMOVE ALL SELECTIONS TO PRINT / SEARCH ENTIRE\n  ISREDIT &$D$ &STR(\"================ PLACEMENT OF ENDING COMMENT ==============\n  ISREDIT &$N$ &STR(\"===========================================================\n  ISREDIT &$N$ &STR(\"| SELECTION CRITERIA  USED BY PGM=IZ2018 IN PROC=SLCTTSO IS\n  ISREDIT &$N$ &STR(\"|      AS USED BY PGM=IZ2019 AND CONSISTS OF EXAMINATION OF\n  ISREDIT &$N$ &STR(\"|      NAMES, CHECKING ON CORRESPONDING POSITIONS OF MEMBER\n  ISREDIT &$N$ &STR(\"| @,#,$,A-Z,0-9   EXACT MATCH IN CORRESPONDING COLUMN REQUI\n  ISREDIT &$N$ &STR(\"| %               MUST BE A LETTER @,#,$,A-Z\n  ISREDIT &$N$ &STR(\"| +               MUST BE A DIGIT 0-9 IN CORRESPONDING COLU\n  ISREDIT &$N$ &STR(\"| *               MUST BE A BLANK, HENCE REMAINDER ALSO BLA\n  ISREDIT &$N$ &STR(\"|//SYSIN  DD *\n  ISREDIT &$N$ &STR(\"|EXCLUDE- BCD      EXCLUDE CARDS MUST PRECEDE INCLUDE-  CAR\n  ISREDIT &$N$ &STR(\"|EXCLUDE-A   E     EXCLUDE MEMBERS BEGINNING WITH 'A', AND\n  ISREDIT &$N$ &STR(\"|INCLUDE-ABCDE     MEMBER ABCDE EXCLUDED ABOVE, BUT ABCDE1\n  ISREDIT &$N$ &STR(\"|ABCED             SAME AS   IF PREFIXED WITH INCLUDE-ABCDE\n  ISREDIT &$N$ &STR(\"===========================================================\n  ISREDIT &$N$ &STR(\"|USAGE:         SOURCE TYPE PDS -- NOT RECFM=U\n  ISREDIT &$N$ &STR(\"|PURPOSE: PRINT MEMBERS OF A PDS, AND/OR\n  ISREDIT &$N$ &STR(\"|         SEARCH FOR CHARACTER STRINGS IN A PDS, AND/OR\n  ISREDIT &$N$ &STR(\"|         SELECT MEMBERS BY PGM=IZ2019 STANDARDS\n  ISREDIT &$N$ &STR(\"|         PROC=SLCTTSO SET UP TO PRINT ON A 3800\n  ISREDIT &$N$ &STR(\"|ADDITIONAL INFORMATION:   ===> TSO INFOHELP PGMINDX\n  ISREDIT &$N$ &STR(\"|    PROGRAM   INFORMATION ===> FIND FIRST 'IV2004:' WITHIN\n  ISREDIT &$N$ &STR(\"|    MEMBER SELECTION      ===> FIND FIRST 'IZ2019:' WITHIN\n  ISREDIT &$N$ &STR(\"===========================================================\n  ISREDIT LOCATE .SLCT\n  ISREDIT UP 3\n  ISREDIT FIND NEXT '??'\n  ISREDIT DELETE .ZLAST .ZLAST\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@SMALLS": {"ttr": 3588, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01g\\x01g\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 359, "newlines": 359, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- Change all UPPERCASE to lowercase                         */\n/*********************************************************************/\n/*         Provision made for   REDO  to fix only words              */\n/*   DESCRIPTION:   CHANGE ALL UPPERCASE TO LOWERCASE                */\n/*                  -- CAPITALIZE SENTENCES                          */\n/*   PURPOSE:       Helps to reduces the number of keystrokes needed */\n/*                  to create text that is more readable.            */\n/*   INSTALL:       You can incorporate with additional changes      */\n/*                  into your own CLIST library                      */\n/*   NOTE:          AUTOSAVE OFF   is invoked                        */\n/*                  DEFAULT LABLES ARE .ZFIRST .ZLAST                */\n/*   Contributed: 1985/09/17 David McRitchie                         */\n/*   Converted  to REXX 1992/02/07 D.McRitchie, more words also added. */\n/*                                                                   */\n/*   OPTIONS:                                                        */\n/*       LPTR-RANGE | ENTIRE   (REQUIRED) LINE POINTER RANGE         */\n/*       REDO       Do everything except initial making all          */\n/*                  into lowercase                                   */\n/*********************************************************************/\n \"ISREDIT  MACRO (TOK1,TOK2,TOK3,TOK4,TOK5,TOK6,TOK7,TOK8,TOK9,TOK10, ,\n           TOK11,TOK12,TOK13,TOK14,TOK15,TOK16,TOK17,TOK18,TOK19, ,\n           TOK20,TOK21,TOK22,TOK23,TOK24,TOK25,TOK26,TOK27,TOK28)\"\n     ALL=\"\"; BEFORE=\"\"; BEGIN=\"\"; DEBUG=\"\"; ENTIRE=\"\"; FIRST=\"\";\n     LABELS=\"\"; LABF=\"\"; LABL=\"\"; PFX=\"\"; REQUIRED=\"\";\n     LEFT=\"\"; RIGHT=\"\"; X=\"\";  /*CLEAR FUTURE USE*/ DEBUG=\"\"\n     REDO=\"\";\n ADDRESS \"ISREDIT\"\n REMAIN = \" \"\n DO I = 1 TO 28 BY 1; DO INNER = 1 TO 1 BY 1;\n        TOKENX = TOK||I\n        TOKENX  = VALUE(TOKENX)\n        TOKEN = TRANSLATE(TOKENX)\n        IF TOKEN = \"\" THEN LEAVE I\n        LNG = LENGTH(TOKEN)\n        IF 'ALL' = TOKEN | 'NEXT' = TOKEN | 'FIRST' = TOKEN ,\n           | 'NX' = TOKEN | 'X' = TOKEN ,\n           | 'LAST' = TOKEN | 'PREV' = TOKEN ,\n        THEN DO\n           ZEDSMSG = \"\"\"\"TOKEN\"\"\" INVALID\"\n           ZEDLMSG = \"\"\"\"TOKEN\"\"\" NOT PROVIDED FOR NOR ARE \" ,\n             \"NEXT ALL FIRST LAST PREV\"\n           ADDRESS 'ISPEXEC' ' SETMSG MSG(ISRZ000)'\n           EXIT 12\n        END\n        IF 'DEBUG'  = TOKEN THEN DO; DEBUG='DEBUG'; LEAVE INNER;END;\n        IF 'ENTIRE' = TOKEN THEN DO; ENTIRE='ENTIRE'; LEAVE INNER;END;\n        IF 'REDO'   = TOKEN THEN DO; REDO='REDO'; LEAVE INNER;END;\n        IF SUBSTR(TOKEN,1,7) = 'BEFORE(' THEN DO\n           BEFORE = SUBSTR(TOKEN,8,LNG-8)\n           LEAVE INNER\n        END\n        IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n           IF  LABF = \"\"     THEN DO\n              LABF = TOKEN\n              LEAVE INNER\n           END\n           IF       LABL  = \"\"     THEN DO\n              LABL = TOKEN\n              LEAVE INNER\n           END\n           ZEDSMSG = \"LABEL TOKENS\"\n           ZEDLMSG = \"EXACTLY TWO LABELS ARE REQUIRED \" ,\n             ||\"FOUND  \" LABF \", \" LABL \" AND  \" TOKEN\n           ADDRESS 'ISPEXEC' ' SETMSG MSG(ISRZ000)'\n           EXIT 12\n        END\n        IF TOKEN = \"'\" THEN DO   /* ' match quote */\n           ZEDSMSG = \"LOST PARENTHESIS\"\n           ZEDLMSG = \"BLANKS SEPARATE ALL OPERANDS; \" ,\n            ||\"THEREFORE INVALID IN FROM() TO() COL() BEGIN()\"\n           ADDRESS 'ISPEXEC' ' SETMSG MSG(ISRZ000)'\n           EXIT 12\n        END\n        SAY TOKEN     NOT PROVIDED FOR IN CLIST\n    REMAIN = REMAIN TOKEN\n  END INNER\n END I\n IF REMAIN \\= \"\" THEN ,\n SAY REMAIN \"-- NOT PROVIDED FOR IN .EXEC\"\n/*********************************************************************/\n/*********************************************************************/\nAddress \"ISREDIT\"\n\"CAPS OFF\"\n        IF LABF = \"\" THEN ENTIRE = \"ENTIRE\" /*MAKE ENTIRE DEFAULT*/\n        IF ENTIRE = \"ENTIRE\" THEN DO     /*** LABELS ARE REQUIRED ***/\n           IF  LABF = \"\"     THEN DO\n              LABF = \".ZFIRST\"\n              LABL = \".ZLAST\"\n           END\n           ELSE DO\n              SAY LENGTH(LABF)  LENGTH(LABL)\n              ZEDSMSG = \"LABEL CONFLICT\"\n              ZEDLMSG = '\"ENTIRE\" IMPLIES .ZFIRST .ZLAST ' ,\n                || 'CONFLICTS WITH ' LABF ' AND ' LABL\n              ADDRESS 'ISPEXEC' ' SETMSG MSG(ISRZ000)'\n              EXIT 12\n           END\n        END\n        IF  LABL = \"\"     THEN DO\n              ZEDSMSG = \"MISSING LABEL(S)\"\n              ZEDLMSG = ZEDSMSG \"- A PAIR OF LABELS OR \" ,\n                || \"\"\"ENTIRE\"\" IS REQUIRED\"\n              ADDRESS 'ISPEXEC' ' SETMSG MSG(ISRZ000)'\n              EXIT 12\n        END\n        \"ISREDIT (#LABF) = LINENUM \" LABF\n        IF RC \\= 0 THEN DO\n                   ZEDSMSG = LABF  \"LABEL\"\n                   ZEDLMSG = ZEDSMSG \"DOES NOT EXIST\"\n                   ADDRESS 'ISPEXEC' ' SETMSG MSG(ISRZ000)'\n                   EXIT 12\n        END\n        \"ISREDIT (#LABL) = LINENUM \" LABL\n        IF RC \\= 0 THEN DO\n                   ZEDSMSG = LABL  \"LABEL\"\n                   ZEDLMSG = ZEDSMSG \"DOES NOT EXIST\"\n                   ADDRESS 'ISPEXEC' ' SETMSG MSG(ISRZ000)'\n                   EXIT 12\n        END\n        /************** END OF LABEL REQUIREMENTS *******************/\n      /*********** MAKE BEGINNINGS OF SENTENCES INTO UPPER CASE ****/\n      \"CAPS OFF\"\n      \"LOC \" LABF\n      range = labf || \" \" || labl\n      IF REDO = 'REDO' THEN signal notall\n      \"change\"  range \"ALL P'>' P'<'\"\n      \"change\"  range \"FIRST PREFIX P'@' P'>'\"\n      \"exclude\" range \"ALL\"\n      \"FIND\"    range \"ALL '. '\"\n      \"exclude\" range \"ALL ':'\"  /* NOT SCRIPT JUNK */\n      \"FIND\"    range \"ALL ':  '\"\n      /* capitalize first letter after colon space */\n      \"LOC \" LABF\n  NEXTC: ,\n      \"FIND\"    range \"NX NEXT ':  '\"\n      IF RC = 0 THEN DO\n         \"change\" range \"NEXT PREFIX p'@' p'>'\"\n         IF RC = 0 THEN SIGNAL NEXTC\n      END\n      \"FIND\"    range \"   all   '  - '\"\n      \"LOC \" LABF\n  NEXTD: ,\n      \"FIND\"    range \"NX NEXT '  - '\"\n      IF RC = 0 THEN DO\n         \"change\" range \"NEXT PREFIX p'@' p'>'\"\n         IF RC = 0 THEN SIGNAL NEXTD\n      END\n      /* capitalize first letter after period space */\n      /* make periods show up so can check by eye   */\n      \"FIND\"    range \"all '. '\"\n      \"LOC \" LABF\n  NECTP: ,\n      \"FIND\"    range \"NX NEXT             '. '\"\n      IF RC=0 then do\n         \"change\" range \"NEXT prefix p'@' p'>'\"\n         IF rc = 0 THEN SIGNAL NECTP\n      END\n      \"CHANGE all prefix '=$ @'p '>= >'p\"   /*  1) Able,  B) Baker*/\n      /*********** MAKE JCL INTO UPPER CASE ************************/\n      \"exclude ALL\"\n      \"FIND 1\" range \"ALL '//'\"\n      \"FIND\"   range \"ALL '//'\"\n      \"change\" range \"P'<' P'>' ALL NX\"\n     /*************** END OF LABEL REQUIREMENTS ********************/\n     \"AUTOSAVE OFF\"\n   NOTALL: ,\n     \"(MEMNAME) = MEMBER\"\n     \"exclude ALL\"\n     \"CAPS OFF\"\n      /* latest additions -- capitalized these words */\n      \" @C \" RANGE \" PLR PLRS PCTM LNG APP TGT I/O VIO\"\n      \" @C \" RANGE \" COPYLIB SYSLIB TELON SYS1 PROCLIB USERPROC LIBR\"\n      \" @C \" RANGE \" MACLIB COB2LIB COBLIB MACLIB VSAMDEF\"\n      \" @C \" RANGE \" SYS5 CISTEST MFS\"\n      \" @C CHAR \" RANGE \" _DATA _LIB _USED _TELON\"\n     \"CHANGE all word\" range \"p'SYS#'      p'>>>>' \"\n     /* program name specialities */\n     \"CHANGE all word\" range \"p'@@@####'      p'>>>>>>>' \"\n     \"CHANGE all word\" range \"ispf            ISPF       \"\n     \"CHANGE all word\" range \"isredit         ISREDIT    \"\n     \"CHANGE all word\" range \"p'@^^^#^^^'     p'>>>>>>>>'\" /*AHIV3H99*/\n     \"CHANGE all word\" range \"p'##@@@##'      p'>>>>>>>'\"  /*31DEC99 */\n     /* proper names */\n     \"CHANGE all word\" range \"'$cntl'p                   '=CNTL'p\"\n     \"CHANGE all word\" range \"'$libr$'p                  '=LIBR='p\"\n     \"change all prefix\" range \"'A-'                     'A-'\"\n     \"CHANGE all word\" range \"'Allison'                  'Allison'\"\n     \"CHANGE all word\" range \"'American'                 'American'\"\n     \"CHANGE all word\" range \"'Autotab'                   AUTOTAB\"\n\n     \"CHANGE ALL word\" range \"'Bruce'                    'Bruce'\"\n     \"CHANGE all word\" range \"'Byerlee'                  'Byerlee'\"\n     \"CHANGE all word\" range \"'Byerlee'                  'Byerlee'\"\n     \"CHANGE all word\" range \"'Celanese'                 'Celanese'\"\n     \"CHANGE all word\" range \"'Clark'                    'Clark'\"\n     \"CHANGE all word\" range \"'Corporation'              'Corporation'\"\n     \"CHANGE all word\" range \"'Dale'                     'Dale'\"\n     \"CHANGE all word\" range \"'Dallas'                   'Dallas'\"\n     \"CHANGE ALL word\" range \"'Dave'                     'Dave'\"\n     \"CHANGE all word\" range \"'David'                    'David'\"\n     \"CHANGE ALL word\" range \"'Donohue'                  'Donohue'\"\n     \"CHANGE all word\" range \"'Fontana'                  'Fontana'\"\n     \"CHANGE all word\" range \"'Fred'                     'Fred'\"\n     \"CHANGE all word\" range \"'Fri'                      'Fri'\"\n     \"CHANGE all word\" range \"'Friday'                   'Friday'\"\n     \"CHANGE all word\" range \"'Gale' \" /* Meyers */ \"    'Gale'\"\n\n     \"CHANGE all word\" range \"'I'                         I\"\n     \"CHANGE all word\" range \"'II'                        II\"\n\n     \"CHANGE all word\" range \"'Jim'                      'Jim'\"\n     \"CHANGE all word\" range \"'Joe'                      'Joe'\"\n     \"CHANGE ALL word\" range \"'John'                     'John'\"\n     \"CHANGE ALL word\" range \"'Kevin'                    'Kevin'\"\n     \"CHANGE ALL word\" range \"'Kyle'                     'Kyle'\"\n     \"CHANGE all word\" range \"'Martowicz'                'Martowicz'\"\n     \"CHANGE all word\" range \"'Mcritchie'                'McRitchie'\"\n     \"CHANGE all word\" range \"'Meyers'                   'Meyers'\"\n     \"CHANGE all word\" range \"'Mohammed'                 'Mohammed'\"\n     \"CHANGE all word\" range \"'Mon'                      'Mon'\"\n     \"CHANGE all word\" range \"'Monday'                   'Monday'\"\n     \"CHANGE all word\" range \"'MVS'                      'MVS'\"\n     \"CHANGE all word\" range \"'New jersey'               'New Jersey'\"\n     \"change all prefix\" range \"'O-'                     'O-'\"\n     \"CHANGE all word\" range \"'O###$'p                   'O===='p\"\n     \"CHANGE all word\" range \"'Os'                       'OS'\"\n     \"CHANGE ALL word\" range \"'Pittson'                  'Pittson'\"\n     \"CHANGE all word\" range \"'QAT'                      'QAT'\"\n     \"change all prefix\" range \"'Qat'                    'QAT'\"\n     \"change all suffix\" range \"'Qat'                    'QAT'\"\n     \"CHANGE ALL word\" range \"'Rita'                     'Rita'\"\n     \"CHANGE all word\" range \"'Rogers'                   'Rogers'\"\n     \"CHANGE all word\" range \"'Sat'                      'Sat'\"\n     \"CHANGE all word\" range \"'Saturday'                 'Saturday'\"\n     \"CHANGE ALL word\" range \"'Scharwath'                'Scharwath'\"\n     \"CHANGE all word\" range \"'script'                   Script\"\n     \"CHANGE all word\" range \"'Stewart'                  'Stewart'\"\n     \"CHANGE all word\" range \"'Sunday'                   'Sunday'\"\n     \"CHANGE all word\" range \"'Thur'                     'Thur'\"\n     \"CHANGE all word\" range \"'Thursday'                 'Thursday'\"\n     \"CHANGE ALL word\" range \"'Tim'                      'Tim'\"\n     \"CHANGE all word\" range \"'Tue'                      'Tue'\"\n     \"CHANGE all word\" range \"'Tuesday'                  'Tuesday'\"\n     \"CHANGE all word\" range \"'Virginia'                 'Virginia'\"\n     \"CHANGE all word\" range \"'VM'                       'VM'\"\n     \"CHANGE all word\" range \"'VSE'                      'VSE'\"\n     \"CHANGE all word\" range \"'Wed'                      'Wed'\"\n     \"CHANGE all word\" range \"'Wednesday'                'Wednesday'\"\n     \"CHANGE all word\" range \"'Wind'                     'Wind'\"\n     \"CHANGE all word\" range \"'XA'                       'XA'\"\n    /* JCL and other terms for complete capitalization, that contain*/\n    /* something to make sure it is JCL, such as = sign      */\n     \"CHANGE all prefix\" range \"'space='                  'SPACE='\"\n    /* JCL and other terms for complete capitalization, that do not */\n    /* interfer with other usages e.g. does not include SPACE*/\n     \"CHANGE all word\" range \"'mvs/xa'                   'MVS/XA'\"\n     \"CHANGE all word\" range \"'AHC'                      AHC\"\n     \"CHANGE all word\" range \"'autotab'                  AUTOTAB\"\n     \"CHANGE all word\" range \"'blksiz'                   BLKSIZ\"\n     \"CHANGE all word\" range \"'bms'                      BMS\"\n     \"CHANGE all word\" range \"'CICS'                     CICS\"\n     \"CHANGE all word\" range \"'cobol'                    COBOL\"\n     \"CHANGE all word\" range \"'cyl'                      CYL\"\n     \"CHANGE all word\" range \"'dasd'                     DASD\"\n     \"CHANGE all word\" range \"'dcb'                      DCB\"\n     \"CHANGE all word\" range \"'db2'                      DB2\"\n     \"CHANGE all word\" range \"'dcf'                      DCF\"\n     \"CHANGE all word\" range \"'dms'                      DMS\"\n     \"CHANGE all word\" range \"'DOS'                      DOS\"\n     \"CHANGE all word\" range \"'fb'                       FB\"\n     \"CHANGE all word\" range \"'fbs'                      FBS\"\n     \"CHANGE all word\" range \"'ibm'                      IBM\"\n     \"CHANGE all word\" range \"'ifps'                     IFPS\"\n     \"CHANGE all word\" range \"'ims'                      IMS\"\n     \"CHANGE all word\" range \"'iof'                      IOF\"\n     \"CHANGE all word\" range \"'IPL'                      IPL\"\n     \"CHANGE all word\" range \"'IPLQAT'                   IPLQAT\"\n     \"CHANGE all word\" range \"'jcl'                      JCL\"\n     \"CHANGE all word\" range \"'jes'                      JES\"\n     \"CHANGE all word\" range \"'mvs'                      MVS\"\n     \"CHANGE all word\" range \"'Nj'                       NJ\"\n     \"CHANGE all word\" range \"'pdf'                      PDF\"\n     \"CHANGE all word\" range \"'pds'                      PDS\"\n     \"CHANGE all word\" range \"'pl/i'                      'PL/I'\"\n     \"CHANGE all word\" range \"'pl/1'                      'PL/1'\"\n     \"CHANGE all word\" range \"'pli'                      PLI\"\n     \"CHANGE all word\" range \"'racf'                     RACF\"\n     \"CHANGE all word\" range \"'recfm'                    RECFM\"\n     \"CHANGE all word\" range \"'rexx'                     REXX\"\n     \"CHANGE all word\" range \"'sas'                      SAS\"\n     \"CHANGE all word\" range \"'smp'                      SMP\"\n     \"CHANGE all word\" range \"'SOP#'                     SOP#\"\n     \"CHANGE all word\" range \"'SOP'                      SOP\"\n     \"CHANGE all word\" range \"'Syslmod'                  SYSLMOD\"\n     \"CHANGE all word\" range \"'Syslib'                   SYSLIB\"\n     \"CHANGE all word\" range \"'Syslibs'                  SYSLIBs\"\n     \"CHANGE all word\" range \"'PARMS'                    PARMs\"\n     \"CHANGE all word\" range \"'PARM'                     PARM\"\n     \"CHANGE all word\" range \"'PLR'                      PLR\"\n     \"CHANGE all word\" range \"'tlms'                     TLMS\"\n     \"CHANGE all word\" range \"'trk'                      TRK\"\n     \"CHANGE all word\" range \"'tso'                      TSO\"\n     \"CHANGE all word\" range \"'db'                       DB\"\n     \"CHANGE all word\" range \"'vb'                       VB\"\n     \"CHANGE all word\" range \"'vbs'                      VBS\"\n     \"CHANGE all word\" range \"'vspc'                     VSPC\"\n     \"CHANGE all word\" range \"'xa'                       XA\"\n    \"CHANGE all word\" range \"t'tsomodel.public' change'TSOMODEL.PUBLIC'\"\n     \"CHANGE all\" range \"'info0' 'INFO0'\"\n     /* PREFIX character strings*/\n     \"CHANGE all prefix\" range \"p'IMS<<<<'               p'IMS>>>>'\"\n     \"CHANGE all prefix\" range \"p'IMS<<<'                p'IMS>>>'\"\n     \"CHANGE all prefix\" range \"p'IMS<<'                 p'IMS>>'\"\n     \"CHANGE all prefix\" range \"p'IMS<'                  p'IMS>'\"\n/*********************************************************************/\n/*      /* Sentence beginning -- period - two spaces - letter*/      */\n/*         has been placed above REDO area                           */\n/*********************************************************************/\n     \"CHANGE ALL prefix\" range \"'<$ ><'p p'>= =='\"\n     \"CHANGE ALL\" range \"word               p'dli======' p'>>>>>>>>>'\"\n     \"CHANGE ALL\" range \"word               p'dli=====' p'>>>>>>>>'\"\n     \"CHANGE ALL\" range \"word               p'dli====' p'>>>>>>>'\"\n     \"CHANGE ALL\" range \"word               p'dli===' p'>>>>>>'\"\n     \"CHANGE ALL\" range \"word               p'dli==' p'>>>>>'\"\n     \"CHANGE ALL\" range \"word               p'dli=' p'>>>>'\"\n     \"CHANGE ALL\" range \"word               p'dli' p'>>>'\"\n     \"CHANGE ALL\" range \"word               p'dbrm' DBRM\"\n     \"CHANGE ALL\" range \"word               vdefine VDEFINE\"\n     \"CHANGE ALL\" range \"word               vreset  VRESET\"\n     \"CHANGE ALL\" range \"word               telon   TELON\"\n\n     \"FIND ALL P'>'\" range \"\"\n     \"LOC \" LABF \"\"\n     ZEDSMSG = \"COMPLETED\"\n     ZEDLMSG = ZEDSMSG \" ==> @smalls\" range\n     ADDRESS 'ISPEXEC' 'SETMSG MSG(ISRZ000)'\n    lb  =   \"LINE_BEFORE \"||LABF||\" = NOTELINE \"\"\";q=\"\"\"\"\n     IF REDO = REDO then return 1\nlb,\n\"+==================================================================+\"Q\nlb,\n\"|| 'UPPERCASE' has been changed to 'lowercase'                 ||\"Q\nlb,\n\"|| This Clist has invoked 'CAPS OFF', 'AUTOSAVE OFF'           ||\"Q\nlb,\n\"|+================================================================+|\"Q\nlb,\n\"|| Use     FIND ' ' ALL     to make lines between ==CHG> visible ||\"Q\nlb,\n\"+==================================================================+\"Q\nlb,\n\"|| change all p'  <<' p'  ><'   may be useful for some situations||\"Q\nlb,\n\"|| change all p'  <<' p'  ><'   may be useful for some situations||\"Q\nlb,\n\"+==================================================================+\"Q\nlb  \" \"Q\n     \"CAPS OFF\"\n     \"LOC 0\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@SOP": {"ttr": 3595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00&\\x00&\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- Invoke @SCRIPT for SOP work outside of tech.libr2.text*/\n/* David McRitchie, \"The REXX Macros Toolbox\", July 15, 1992 */\n/*   @SOP    is a companion to @SCRIPT clist                */\n/*   @DOCJWK is a companion to @SCRIPT clist                */\nAddress \"ISREDIT\"\n\"MACRO (TOKEN)\"\n  /* MACRO CLIST @SOP has been installed in SYS1.TSOCLIST   */\n  /* USED FROM WITHIN EDIT OF outside of TECH.LIBR2.TEXT    */\n  /*   to pull in any members from TECH.LIBR2.TEXT that are */\n  /*   not in the current library                           */\n      \"(MEMBERX) = MEMBER \"\n      \"(DSNX)    = DATASET\"\n      inputdsn = ''\n Token = translate(token);\n if token = \"COMPARE\" | token = \"@COMPARE\" then do\n    \"@COMPARE TECH.LIBR2.TEXT\"\n    return\n end\n Address \"TSO\" \"ALLOCATE DDNAME(TEXTLIB) DA('\"DSNX\"'\" ,\n    \"'TECH.LIBR2.TEXT') SHR REUSE\"\n  IF RC /= 0 THEN DO\n     SAY \"SORRY,  Cannot allocate TEXTLIB datasets\"\n     EXIT 12\n  END\n  if substr(memberx,1,1) = \"S\" then\n     if datatype(substr(memberx,2,4)) = \"NUM\"\n     then do\n       inputdsn = DSNX||'(A'||substr(memberx,2,4)||')'\n       x = sysdsn(\"'\"inputdsn\"'\"); if x /= \"OK\" then do\n          inputdsn = 'TECH.LIBR2.TEXT'||'(A'||substr(memberx,2,4)||')'\n          x = sysdsn(\"'\"inputdsn\"'\"); if x /= \"OK\" then inputdsn=''\n       end\n     end\n  if inputdsn = '' then \"@SCRIPT\" TOKEN\n  else \"@SCRIPT\" \"INPUT(\"inputdsn\")\" TOKEN\n  Address \"TSO\" \"FREE DDNAME(TEXTLIB)\"\n  address \"ISREDIT\"\n  \"LINE_BEFORE .ZF = NOTELINE '  via @SOP\" TOKEN\"'\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@SPELLS": {"ttr": 3597, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xa2\\x00\\xa2\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 162, "newlines": 162, "modlines": 0, "user": "MCRITCH"}, "text": "/*rexx*/ address \"ISREDIT\"; \"MACRO (parm)\"\n/* related macros ----- SPELL  uses SCRIPT/VS */\n/* related macros ----- @SPELLS uses  SAS608  */\n/* JCL used to load dictionary like is03.share.cntl(sasex021) */\n/* Created by: David McRitchie, \"The REXX Macros Toolbox\", 1994/07/06 */\n\"(MEMBERX) = MEMBER \"\n\"(DSNX)    = DATASET\"\n \"(lastno)  = linenum .zlast\"\n parm=translate(parm)\n /**********************************/\n /* options: EDIT NX NOWORDS NOTES */\n editP = pos('EDIT',parm)\n nxP=pos('NX',parm)\n if pos('NOWORDS',parm) > 0 then AUXDICT=\"\";\n else auxdict='auxdict.spell.saswords';\n if pos('NOTES',parm) > 0 | editP >0 then optionsP=\"ls=80\";\n else optionsP='nonotes nonews ls=80 noterminal';\n/***********************************/\n \"ISREDIT (DCHG) = DATA_CHANGED\"\ndd = \"TP\"random()\nuserid = sysvar('sysuid')\nsysuid = sysvar(\"sysuid\")\n/**********************************************************/\nespell=\"'\"userid\".@SPELLS.\"DD\"INP.LIST'\"\nq.=\"\"\nx=msg('off')\nAddress \"TSO\" 'free fi(espell)'\nAddress \"TSO\" 'del' espell\nAddress \"TSO\" 'ALLOC FI(ESPELL) NEW CAT SPACE(45 45) TRACKS' ,\n   'UNIT(VIO) LRECL(255) RECFM(V B M) BLKSIZE(3156)' ,\n   \"DSN(\"espell\") REUSE\"\ndo i = 1 to lastno\n   ADDRESS 'ISREDIT' '(SPELLREC) = LINE' I\n   if nxP > 0 then do\n      ADDRESS 'ISREDIT' '(XSTAT) = XSTATUS' I\n      if xstat   \\= \"NX\" then  spellrec = \" \"\n   end\n   q.i=spellrec; q.0=i\nend\nAddress \"TSO\" \"EXECIO * DISKW ESPELL (STEM Q. FINIS\"\nAddress \"TSO\" \"FREE FI(ESPELL)\"\nq.=\"\";q.0=0\n/**********************************************************/\nAddress \"TSO\" 'free fi(infile) fi(saslog) fi(sysin)'\n\nsaslog  = \"'\"userid\".@SPELLS.\"dd\"LOG.list'\"\nAddress \"TSO\" 'del' saslog\nAddress \"TSO\" 'ALLOC FI(saslog) NEW CAT SPACE(45 45) TRACKS' ,\n   'UNIT(TESTDISK) LRECL(255) RECFM(V B M) BLKSIZE(3156)' ,\n   \"DSN(\"saslog\") REUSE\"\n\nsysinxx = userid\".@SPELLS.\"dd\"SAS.list\"\nsysin = \"'\"sysinxx\"'\"\naddress \"TSO\" \"del\" sysin\n/* file will be created in REXX usin EXECIO below */\n\nspellout = \"'\"userid\".spell.out'\"\naddress \"TSO\" \"del\" spellout\n/* dataset will be created by SAS */\n\n/* create a SAS program in FILE(SYSIN) from q. thru execio */\nq.1=\"options ls=80;\"\nq.2=\"filename print   \" spellout \"unit=testdisk recfm=fb lrecl=80\"\nq.3=\"  blksize=6800 disp=(new,catlg,catlg) reuse;\"\nq.4=\"filename espell \"espell\" disp=shr;\"\nq.5=\"libname AUXDICT  'sys6.sas608.auxdict' disp=shr;\"\nq.6=\"   \"\nq.7=\"PROC PRINTTO PRINT=\"spellout\";\"\nq.8 =\"    \"\nq.9 =\"PROC SPELL IN=espell verify suggest\"\n/* auxdict defaults to auxdict.spell.sasword unless NOWORDS option */\nq.10=\"   dictionary=(\"AUXDICT\" sashelp.base.names \"\nq.11=\"sashelp.base.cities sashelp.base.cntries sashelp.base.states);\"\nq.0=11;\nAddress \"TSO\" 'ALLOC FI(SYSIN) NEW SPACE(5 0) TRACKS UNIT(VIO)' ,\n     'LRECL(80) RECFM(F B)   BLKSIZE(3120) ' ,\n     \"da(\"sysin\") reuse catalog\"\nAddress \"TSO\" \"EXECIO * DISKW sysin (STEM q. FINIS\"\nAddress \"TSO\" \"free file(SYSIN)\"\n/*************************************************************/\n\nZEDLMSG = '** SAS608 invoked to check dictionaries **'\nADDRESS 'ISPEXEC' 'CONTROL DISPLAY LOCK'\nADDRESS 'ISPEXEC' 'DISPLAY MSG(ISRZ000)'\n\naddress \"TSO\" \"sas608 input('''\"sysinxx\"''')\",\n    \"options('\"optionsP\"') ddlog(saslog) log('')\"\n\nZEDLMSG = '** Now processing SAS output for INFOLINEs **'\nADDRESS 'ISPEXEC' 'CONTROL DISPLAY LOCK'\nADDRESS 'ISPEXEC' 'DISPLAY MSG(ISRZ000)'\nx=msg(on)\nx=msg(off)\nif editP > 0 then do  /* possible use for debugging */\n     ZEDSMSG = \"espell\"\n     ZEDLMSG = 'Input file with words to be checked out'\n     ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    Address \"TSO\" \"$EDIT \"espell\n     ZEDSMSG = \"saslog \"\n     ZEDLMSG = 'SASLOG file output'\n     ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    Address \"TSO\" \"$$browse saslog\" /*browse the ddname*/\n  /*Address \"TSO\" \"$EDIT \"saslog*/\n     ZEDSMSG = \"sas sysin\"\n     ZEDLMSG = 'SAS program -- sysin'\n     ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    Address \"TSO\" \"$EDIT \"sysin\n     ZEDSMSG = \"misspelled word list\"\n     ZEDLMSG = 'spellout -- misspelled words, listing of'\n     ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    Address \"TSO\" \"$EDIT \"userid\".spell.out\"\n     ZEDSMSG = \"\"\n     ZEDLMSG = \"\"\n     ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\nend\nAddress \"TSO\" 'free fi(espell) free fi(infile) fi(saslog) fi(sysin)'\naddress \"TSO\" \"del\" espell\naddress \"TSO\" \"del\" saslog\naddress \"TSO\" \"del\" sysin\naddress \"TSO\" \"ALLOCATE FILE(SYSIN) DATASET(*)\"\nq.=\"\"\nAddress   \"TSO\" \"ALLOC FI(infile) DSN('\"SYSUID\".SPELL.OUT') SHR REUSE\"\nq.=\"\"\nADDRESS \"TSO\" \"EXECIO * DISKR infile (STEM Q. FINIS\"\naddress \"TSO\" \"del\" spellout\nx=msg('on')\naddress \"ISREDIT\"\naddress \"ISREDIT\" \"eXclude all\"\ndo qcnt = 1 to q.0;\n   p0=substr(q.qcnt,45,1);\n   p1 = strip(substr(q.qcnt,1,35));\n   p2=substr(q.qcnt,45,36)\n   /* reject if linenumber is non numeric */\n   if datatype(p0,'N') = 0 then   iterate\n   /* reject words with numbers or not a-z, and not A-Z */\n   if datatype(p1,'M') = 0 then   iterate\n   L=length(p1);\n   if L = 1 then iterate\n   if L < 10 then p1 = left(p1,10)\n   qcntp1 = qcnt + 1\n   sugg = \"\"\n   if qcntp1 <= q.0 then\n     if substr(q.qcntp1,10,12)='Suggestions:' then\n         sugg = substr(q.qcntp1,9)\n   do i = 1 to words(p2)\n      word = word(p2,i)\n      word = strip(word,\"T\",\",\")\n      if \"(\" = substr(word,1,1) then iterate\n      errx = \"Word Not Found:  \"p1  sugg\n      wordp1 = word + 1\n      if word < lastno then\n        address \"ISREDIT\" \"LINE_BEFORE\" wordp1 \"= infoline (errx)\"\n        else address \"ISREDIT\" \"LINE_AFTER\" word \"= infoline (errx)\"\n      address \"ISREDIT\" \"XSTATUS\"    word \"= NX\"\n   end\nend\n IF DCHG = \"YES\" then do\n    note = \"@SPELLS\" time('N') '-- current data not saved',\n      'prior to invoking @SPELLS'\n    \"LINE_BEFORE .ZFIRST = Noteline (note)\"\n    \"@DIRSTAT\"\nend\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@STRAP": {"ttr": 3844, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00!\\x00!\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "MCRITCH"}, "text": "/*REXX: @STRAP    creating isredit cards of TSO COMMAND*/\n /* @STRAP: SYSOUT TRAP of TSO COMMAND creating data cards*/\n /*  TITLE:       @STRAP -- trap clist write statements and imbed at */\n /*                         end of file in edit */\n /*  Users:       TSO ISPF EDIT USERS                      */\n /*  Entry:       Used as an EDIT CLIST within ISPF EDIT   */\n /*               ===> @STRAP ddname all                   */\n /*  Contributed: 1985/08/29 David McRitchie                         */\n /*  Rewritten in REXX, D.McRitchie -- 1991/02/28*/\n /*  EXAMPLE:  ===> @STRAP LISTC       */\n /*  EXAMPLE:  ===> @STRAP DDNAME ALL  */\n /*  EXAMPLE:  ===> @STRAP LISTRP      */\nAddress \"ISREDIT\";\"MACRO (TOKEN)\"\ntoken = translate(token)\nx = OUTTRAP('var.','*',\"CONCAT\")\nAddress \"TSO\" TOKEN\ndo i = 1 to var.0;\n  Card = var.i\n  'LINE_AFTER .ZL = (card)'\n  If i = 1 then \"LABEL .ZLAST = .new 0\"\nend\nif var.0 = 0 then do\n      ZEDSMSG = \"No lines found\"\n      ZEDLMSG = 'No lines trapped, please also try @STRAPQ' token\n      \"LINE_BEFORE .ZFIRST = NOTELINE (ZEDLMSG)\"\n      ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      RETURN 1\nend\n/* This clist uses the TSO/E feature SYSOUTTRAP.  Any TSO command */\n/* that uses PUTLINE to display output to the screen can be       */\n/* trapped.    Output using TPUT or WTO macros will go directly   */\n/* to the screen and cannot be trapped.  WRITE output from CLIST  */\n/* commands, and SAY output from REXX commands can be trapped.    */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@STRAPD": {"ttr": 3846, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x004\\x004\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "MCRITCH"}, "text": "00001000 ISREDIT  MACRO (DDNAME DS1)\n00010500 /*  TITLE:       @STRAPD -- CREATE A LIST OF DS1( ) NAMES FROM  \"LISTAL\n00010600 /*  USERS:       SYSTEMS TECHNOLOGY TO UPDATE  CLISTS -- CLIST PANELS L\n00010700 /*  ENTRY:       USED AS AN EDIT MACRO\n00010800 /*  CONTRIBUTED: 1986/01/29 DAVID MCRITCHIE\n00010900 /*  EXAMPLE:  ===> @STRAPD SYSPROC\n00011000 /*            ===> @STRAPD ISPPLIB 8\n00011200 /**********************************************************************\n00011300          SET DDNAME = &SYSCAPS(&STR(&DDNAME))\n00011400          IF &STR(&DS1) = &STR() THEN SET DS1 = 1\n00020000          SET SYSOUTTRAP = 400\n00030000          LISTALC STA\n00040000          SET N = &SYSOUTLINE\n00041000          SET SYSOUTTRAP = 0\n00050000          SET RC = 0   /* FILES TO BE CHECKED LATER RACF/BROWSE */\n00050100          SET I = 2\n00051000          SET HIT2 = 0\n00052000          SET HIT1 = 0\n00060000          DO WHILE &I <= &N\n00070000             SET X = &STR(&&SYSOUTLINE&I..)\n00080000             SET X = &STR(&X.)\n00080100             IF &HIT1 = 1 THEN DO\n00080200                IF &SUBSTR(1:4,&STR(&X.)    ) ^= &STR(    ) THEN SET HIT\n00080500             END\n00080600             IF &HIT1 = 0 THEN DO\n00080700                IF &SUBSTR(1:2,&STR(&X.)  ) ^= &STR(  ) THEN GOTO NIX\n00080800                IF &SUBSTR(1:9,&STR(&X.         )) = &STR(  &STR(&DDNAME\n00080900                ELSE GOTO NIX\n00081000             END\n00090200             SET DX = &STR(&&SYSOUTLINE&EVAL(&I.-1).)\n00090300             SET DX = &STR(&DX)\n00090600             SET RC = &RC + 1\n00090700             SET XDSN&RC = &DX\n00090900             SET I = &I. + 1\n00091100   NIX: -\n00091200             SET I = &I. + 1\n00091300          END\n00104900 /* ---- HAVE OBTAINED ALL DSNAMES NOW DO CHECKING---------------------\n00105000 /* ---- UTILIZING CODE ESSENTIALLY BORROWED FROM THE BROWSE CLIST ----\n00105100          SET I = 1\n00105200          DO WHILE &I <= &RC.\n00105400             SET DSN =  '&STR(&&XDSN&I)'\n00105500             SET DS = &DS1 + &I - 1\n00105700             IF &I ^= &RC THEN -\n00105800                ISREDIT LINE_AFTER .ZLAST = \"          DS&DS.(&STR(&DSN.\n00105900             ELSE -\n00106000                ISREDIT LINE_AFTER .ZLAST = \"          DS&DS.(&STR(&DSN.\n00109200            SET I = &I + 1\n00109300         END\n00111500         SET DSN =\n00112000         SET XDSN =\n00120000 /* ----+++ */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@STRAPE": {"ttr": 3848, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x004\\x004\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "MCRITCH"}, "text": "00010000          CONTROL ASIS\n00010100 ISREDIT  MACRO (COMMAND)\n00011003 /*  TITLE:       @STRAP -- trap clist write statements and imbed at +\n00011103   end of file in edit */\n00012003 /*  Users:       TSO ISPF EDIT +\n00012103   users                                                    */\n00012303 /* modification of @STRAP to facilitate entry into CLIST manual -- +\n00012403   IS03 d.mcr           */\n00013003 /*  Entry:       Used as an EDIT CLIST within ISPF EDIT  ===> &STRAP +\n00013103   ddname all         */\n00014003 /*  Contributed: 1985/08/29 David McRitchie           +\n00014103                                     */\n00015003 /*  EXAMPLE:  ===> @STRAP DDNAME +\n00015103   ALL                                                        */\n00015300         ISREDIT LINE_AFTER .ZLAST = -\n00016003            \":&SYSLC(HP2).EDIT:&SYSLC(EHP)2.:&SYSLC(HP)2.---- +\n00016103              IS03.SHARE.TEXT(EDITXXXX) - 01.00 - COLUMNS 001 +\n00016203                124:&SYSLC(EHP2.)&rbl.\"\n00016400         ISREDIT LINE_AFTER .ZLAST = -\n00017003            \":&SYSLC(HP)2.COMMAND +\n00017103              ===>:&SYSLC(EHP)2.                                 +\n00017203                :&SYSLC(HP)2.SCROLL ===> CSR:&SYSLC(EHP)2.&rbl.\"\n00017400         ISREDIT LINE_AFTER .ZLAST = -\n00018003            \":&SYSLC(HP)2.******:&SYSLC(EHP)2. +\n00018103              **************************** TOP OF DATA +\n00018203                *****************************\"\n00019900         SET IC = 1000010\n00020500         ISREDIT LINE_AFTER .ZLAST = \"&SUBSTR(2:8,&STR(&IC ))\"\n00020600         SET IC = &IC + 10\n00020703         ISREDIT LINE_AFTER .ZLAST = \"&SUBSTR(2:8,&STR(&IC ))COMMAND +\n00020803           INVOKING @STRAP CLIST MACRO ===> @STRAP &STR(&COMMAND)\"\n00021000         SET IC = &IC + 10\n00022000         ISREDIT LINE_AFTER .ZLAST = \"&SUBSTR(2:8,&STR(&IC ))\"\n00030000          SET SYSOUTTRAP = 700\n00031000          &COMMAND\n00040000          SET N = &SYSOUTLINE\n00040100          SET SYSOUTTRAP = 0\n00041000 WRITE    ===> @STRAP &COMMAND\n00050000          SET I = 1\n00060000          DO WHILE &I <= &N\n00070000             SET X = &STR(&&SYSOUTLINE&I..)\n00080000             SET X = &STR(&X.)\n00080100             SET IC = &IC + 10\n00081003             ISREDIT LINE_AFTER .ZLAST = \"&SUBSTR(2:8,&STR(&IC +\n00081103               ))&STR(&X)\"\n00090000 /*          WRITE LINE &I IS \"&X\".\n00091000             SET I = &I. + 1\n00100000          END\n00110000         ISREDIT LINE_AFTER .ZLAST = -\n00120003            \":&SYSLC(HP)2.******:&SYSLC(EHP)2. +\n00121003              ************************* BOTTOM OF DATA +\n00121103                *****************************\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@STRAPQ": {"ttr": 3850, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00K\\x00K\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 75, "newlines": 75, "modlines": 0, "user": "MCRITCH"}, "text": " CONTROL ASIS\n ISREDIT  MACRO (COMMAND)\n /*  TITLE:       @STRAPQ -- TRAP CLIST WRITE STATEMENTS AND IMBED AT +\n /*                          END OF FILE IN EDIT */\n /*  USERS:       TSO ISPF EDIT USERS                               */\n /*  ENTRY:       USED AS AN EDIT CLIST WITHIN ISPF EDIT            */\n /*        ===> &STRAP DDNAME ALL                                   */\n /*  CONTRIBUTED: 1985/08/29 DAVID MCRITCHIE                        */\n /*  EXAMPLE:  ===> @STRAPQ DDNAME ALL                              */\n SET BLANKS = &STR(                                                   +\n   )\n IF &STR(&COMMAND.) = &STR() THEN DO\n     WRITE  PLEASE SUPPLY TSO COMMAND ENTRY FOR @STRAP MACRO CLIST\n     WRITE  &RBL.  USE SINGLE QUOTES OR PARENTHESIS IF\n     WRITE  &RBL.         IF REPLY HAS SPACES OR COMMAS\n     WRITE  &RBL.  TO CANCEL REQUEST HIT ENTER\n     READ COMMAND\n     WRITE BY YOUR COMMAND ... &COMMAND.\n END\n IF &STR() = &STR(&COMMAND) THEN DO\n    WRITE REQUEST TERMINATED DUE TO NULL ENTRY\n    EXIT CODE(0)\n END\n    ISREDIT CAPS OFF\n    ISREDIT LINE_AFTER .ZLAST = DATALINE \"   \"\n    ISREDIT LINE_AFTER .ZLAST = DATALINE \"COMMAND INVOKING @STRAPQ +\n      CLIST +\n      MACRO ===> @STRAPQ &STR(&COMMAND)\"\n    ISREDIT LINE_AFTER .ZLAST = DATALINE \"   \"\n    SET SYSOUTTRAP = 1400\n    &COMMAND\n    SET N = &SYSOUTLINE\n    SET SYSOUTTRAP = 0\n    WRITE    ===> @STRAPQ &COMMAND\n    SET I = 1\n    DO WHILE &I <= &N\n       SET X = &SYSNSUB(2,&&SYSOUTLINE&I..)\n       IF &EVAL(10000 + &I.) > 10050 THEN DO\n          SET XXM =  0&XXM. + 1\n          IF &XXM = 4 THEN WRITENR &STR(....)\n          IF &XXM = 5 THEN DO\n             WRITENR &I\n             SET XXM = 0\n          END\n       END\n       ELSE WRITENR &I\n       SET J = 1\n       SET NJ = 100\n       SET JJJ = &SYSINDEX(&STR(\"),&SYSNSUB(1,&X.))\n       IF &EVAL(&JJJ.) = 0 THEN -\n          ISREDIT LINE_AFTER .ZLAST = DATALINE \"&NRSTR(&X.)\"\n       ELSE DO\n          SET JJJ = &SYSINDEX(&STR('),&SYSNSUB(1,&X.))\n          IF &EVAL(&JJJ.) = 0 THEN -\n             ISREDIT LINE_AFTER .ZLAST = DATALINE '&NRSTR(&X.)'\n          ELSE DO\n             SET J = 1\n             SET NJ = &LENGTH(&STR(&X))\n             DO WHILE &J <= &NJ\n                IF &SUBSTR(&J:&J,&STR(&X)) = &STR(\") THEN DO\n                   SET  JM1 = &J. - 1\n                   SET  JP1 = &J. + 1\n                   SET  X = &SUBSTR(1:&JM1,&STR(&X))~&SUBSTR(&JP1:&NJ,+\n                     &STR(&X))\n                END\n                SET J = &J. + 1\n             END\n           /* WILL BOMB IF HAS AT LEAST ONE OF QUOTE DQUOTE AMPERSAND\n           /* WRITE &NRSTR(&X.) I=&I.\n             ISREDIT LINE_AFTER .ZLAST = DATALINE \"&NRSTR(&X.)\"\n             ISREDIT C .ZLAST .ZLAST \"~\" '\"' ALL\n          END\n       END\n       SET I = &I. + 1\n    END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@STRAPQQ": {"ttr": 3853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00)\\x00)\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "MCRITCH"}, "text": " /*REXX  @STRAPQQ SAME AS @STRAPQ, EXCEPT VGET (QHELP) */\n \"ISREDIT MACRO (COMMAND)              \"\n /*  TITLE:       @STRAPQQ --TRAP CLIST SAY STATEMENTS AND IMBED AT */\n /*                          END OF FILE IN EDIT */\n /*  USERS:       TSO ISPF EDIT USERS                               */\n /*  ENTRY:       USED AS AN EDIT CLIST WITHIN ISPF EDIT            */\n /*        ===> STRAPQQ DDNAME ALL                       */\n /*  CONTRIBUTED: 1985/08/29 DAVID MCRITCHIE                        */\n /*  EXAMPLE:  ===> @STRAPQQ DDNAME ALL                             */\n \"ISREDIT CAPS OFF                     \"\n \"ISREDIT BOUNDS                       \"\n \"ISREDIT AUTOSAVE ON                  \"\n /*\"ISPEXEC VGET (QHELP) SHARED \"  -- THIS LINE IS IN QHELP@ --*/\n /* IF LENGTH(COMMAND) = 0 THEN COMMAND = QHELP   -- IN QHELP@ */\n IF LENGTH(COMMAND) = 0 THEN DO\n     SAY  ' PLEASE SUPPLY TSO COMMAND ENTRY FOR @STRAP MACRO CLIST'\n     SAY  '   USE SINGLE QUOTES OR PARENTHESIS IF            '\n     SAY  '          IF REPLY HAS SPACES OR COMMAS           '\n     SAY  '   TO CANCEL REQUEST HIT ENTER                    '\n     PULL COMMAND\n     SAY \"BY YOUR COMMAND ...\" COMMAND\n END\n IF LENGTH(COMMAND) = 0 THEN DO\n    SAY \"REQUEST TERMINATED DUE TO NULL COMMAND ENTRY\"\n    EXIT 0\n END\n    \"ISREDIT CAPS OFF\"\n    \"ISREDIT LINE_AFTER .ZLAST = '  '\"\n    \"ISREDIT LINE_AFTER .ZLAST = 'COMMAND INVOKING @STRAPQQ EXECUTE,\n      MACRO ===> @STRAPQQ \"||COMMAND||\"'\"\n    \"ISREDIT  LINE_AFTER .ZLAST = '  '  \"\n    RESULT = OUTTRAP(\"SAVE.\",'*')\n    COMMAND\n    N = SAVE.TRAPPED   /* THE LAST LINE # TRAPPED*/\n    RESULT = OUTTRAP(\"OFF\")\n /* SAY \"N=\" N  \"-2-\" SAVE.0 \"--3--\" SAVE.CON \"--4--\" SAVE.TRAPPED */\n /* SAY     \"===> @STRAPQ --\" COMMAND  */\n    DO I = 1 TO N BY 1;IF I > 400 THEN LEAVE I\n    \"ISREDIT LINE_AFTER .ZLAST = DATALINE '\" SAVE.I \"'\"\n    END\n    EXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@TIME": {"ttr": 3855, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x08\\x00\\x08\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "MCRITCH"}, "text": "   address \"ISREDIT\";\"macro (whocall)\"    /*rexx*/\n   /*author: David McRitchie, \"The REXX Macros Toolbox\", 1993/12/17 */\n   if whocall \\= \"\" then whocall = whocall \"-- \"\n   started = time('l') \"started\"\n   zfnote = \"line_before .zfirst = noteline\"\n   ended   = time('l') \"on\" date('n')\n   zfnote \"'\"whocall||sysvar(\"sysicmd\") started\", ended at\" ended\"'\"\n   exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@TPP": {"ttr": 3857, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00?\\x00?\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- Converted to REXX 1994/06/02                             */\nADDRESS \"ISREDIT\"\n  \"MACRO (ADD1 ADD2 ADD3 ADD4)\"\n  /* CONTRIBUTED: DAVID MCRITCHIE  1987/08/06                        */\n  /* THIS CLIST WILL IDENTIFY ALL  NX \"^\" AND CREATE                 */\n  /* A LINE  \".TPP VALA VALA VALA VALA\"                              */\n  /* FOR USE IN SOP MANUAL                                           */\n  /* FOR USE ONLY WITH MEMBERS NOT ALREADY SET UP TO USE TABS.       */\n  /* */\n  /* THIS CLIST IS DESCRIBED IN IS03.SHARE.TEXT(@TPP)                */\n  /*                     AND IN IS03.SHARE.TEXT(STAFF)               */\n  /* */\n  /* TECH.LIBR2.TEXT(FRAME)   .IM FRAME                              */\n  /*       WILL CONVERT  .TPP 5 10 15 20 25 30                       */\n  /* */\n  /* TO EQUIVALENT OF    .TP  5 10 15 20 25 30                       */\n  /* AND                .IF 38PP = &$PDEV  .TP 5M 10M 15, 20M 25M 30M*/\n  /* */\n  /* USEFUL HINTS                                                    */\n  /*  UP A PFKEY  4 = \"=>\"  F '   '\\C '   ' '  ^'                    */\n  /*  THEN DO     ==> @TPP    OR    @TPP 0 5                         */\n  /*              ==> X ALL                                          */\n  /*              ==> F .TPP 1 ALL                                   */\n  /*              ==> REMDUPS NX                                     */\n  add1 = 0; add2=0; add3=0; add4=0; cp12=0;cpxx=0;add4=0\n  vala=\"\";valb=\"\"; nn=0\n IF ADD3 = 0 THEN  ADD3 = ADD1  + 1\n IF ADD4 = 0 THEN  ADD4 = ADD2\n \"LOC 0\"\n \"Exclude ALL '.' 1\"\n \"Find first '^'\"\n AGAIN: ,\n VALA = \"\"\n \"Find FIRST .ZCSR .ZCSR '^'\"\n IF rc \\= 0   THEN  signal DONE\n VALA = \"\"\n VALB = \"\"\n CONTND: ,\n \"(CP11,CP12) = CURSOR\"\n CPXX = CP12\n IF ADD2 \\= 0 THEN CP12 = CP12 / ADD2\n CP12 = CPXX  + ADD1\n VALA = VALA  CP12\n IF ADD4 \\= 0 THEN CP12 = CPXX / ADD4\n CP12 = CPXX  + ADD3\n VALB = VALB  CP12\n \"Find NEXT  .ZCSR .ZCSR '^'\"\n IF rc = 0 THEN  signal CONTND\n DONE: IF VALA \\= \"\" THEN\n     \"LINE_BEFORE .ZCSR = DATALINE \"\".TPP\" VALA\";.IF SYSOUT ne \",\n      \"PRINT .TPP\" valb\"\"\"\"\n NN = NN  + 1\n DONEBEG:\n \"Find NEXT '^' NX\"\n IF rc = 0  THEN  signal AGAIN\n \"LINE_BEFORE .ZFIRST = NOTELINE \"\"Fix up is required, .TPP\",\n     \"must be changed to .TP or make up a .TPP macro\"\"\"\n \"LINE_BEFORE .ZFIRST = NOTELINE \"\"@TPP INVOKED\" time('n') \"AND\",\n     \"ADDED\" NN \".TPP  LINES \"\"\"\n \"LINE_BEFORE .ZFIRST = NOTELINE \"\"  IN FRONT OF  DISPLAYED\",\n     \"LINES CONTAINING TABS '^'\"\"\"\n \"LINE_BEFORE .ZFIRST = DATALINE \"\".*\"  date(\"u\") time(\"n\"),\n    \"@TPP\" ADD1 ADD2 ADD3 ADD4 \"\"\"\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@TSO": {"ttr": 3859, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x11\\x00\\x11\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- */\nADDRESS \"ISREDIT\"\n\"MACRO (TCOMMAND)\"\n/*  DESCRIPTION: MAKE A TSO COMMAND STAY UP FOR REENTRY              */\n/*       YOU MUST BE WITHIN AN EDIT FOR THIS TO FUNCTION             */\n/*       I.E. EDITING A MEMBER OF A PDS                              */\n/*         -- WORKS FOR  &@TSO LISTCAT LEVEL(XXXX)                   */\n/*         -- WORKS FOR  &@TSO $MIDI                                 */\n/*         -- WORKS FOR  &@TSO %TLMSUSER    WORKS -- TSO CLIST  PROC */\n/*         -- FAILS FOR  &@TSO %$MIDI       FAILS -- EDIT MACRO      */\n/*       FROM EDIT THE FOLLOWING ARE VALID                           */\n/*          ===> &@TSO %TLMSUSR          WILL EXECUTE THE CLIST AND THE*/\n/*                        COMMAND REMAINS ON THE COMMAND LINE FOR REUSE*/\n/*          ===> &@TSO LISTCAT LEVEL(XXXX)   WHEN LISTCAT COMPLETES THE*/\n/*                        COMMAND REMAINS ON THE COMMAND LINE FOR REUSE*/\nsay TCOMMAND  \"   /*--- \"date(\"O\") time(\"N\")\" ---*/\"\naddress \"TSO\" TCOMMAND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@TSOX": {"ttr": 3861, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00!\\x00!\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- */\nADDRESS \"ISREDIT\"\n\"MACRO (NAME OPTIONS)\"\n/*********************************************************************/\n/* Purpose:  Macro to exec the TSO clist as existing in sys1.tsoclist*/\n/*           without having to use realloc or making a copy for a day*/\n/*           in user clist.    Named as  @ TSO e(X)ecute.            */\n/* Related Clists -- @TSO @TSOX @TSOD GETCLIST DDNAME                */\n/* Contributed:    F. David McRitchie             1986/06/05         */\n/*                 redone in REXX 1994/06/01                         */\n/* User contact:   F. David McRitchie                                */\n/* Code maint.:    Systech group                                     */\n/* Documented:     is03.share.text(@tsox)                            */\n/* Related clists: @TSO @TSOX @TSOXD @TSOD GETCLIST DDNAME           */\n/*   useful only at \"The REXX Macros Toolbox\"                        */\n/*********************************************************************/\nCHK = SYSDSN(\"'SYS1.TSOCLIST(\"name\")'\")\nIF chk = \"OK\" THEN  DO\n   IF options =  \"\"  THEN  DO\n      SAY \"NOW INVOKING -- EXEC 'SYS1.TSOCLIST(\"NAME\")'\"\n      address \"TSO\" \"EXEC 'SYS1.TSOCLIST(\"name\")'\"\n   Exit RC\n   END\n   ELSE DO\n      SAY \"NOW INVOKING -- EXEC 'SYS1.TSOCLIST(&NAME)' '\"OPTIONS\"'\"\n      address \"TSO\" \"EXEC 'SYS1.TSOCLIST(\"NAME\")' '\"OPTIONS\"'\"\n   END\n   Exit RC\nEND\nSAY \"SYS1.TSOCLIST(\"NAME\") -- \"CHK\n/*CONTROL LIST CONLIST SYMLIST*/\naddress \"TSO\" \"%\"NAME  \"'\"OPTIONS\"'\"\nExit RC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@TSOXD": {"ttr": 3863, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00,\\x00,\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- */\nADDRESS \"ISREDIT\";\"macro (aoptions)\"\n/* PURPOSE:  MACRO TO EXEC THE TSO CLIST CURRENTLY IN EDIT    */\n/*        @ TSO E(X)ECUTE (D)ISPLAY                           */\n/*        RELATED CLISTS -- @TSO @TSOX @TSOD GETCLIST DDNAME  */\n/* CONTRIBUTED:    F. David McRitchie             1986/06/05  */\n/* USER CONTACT:   F. David McRitchie                         */\n/* CODE MAINT.:    SYSTECH GROUP                              */\n/* DOCUMENTED:     IS03.SHARE.TEXT(@TSOXD)                    */\n/* RELATED CLISTS: @TSO @TSOX @TSOD GETCLIST DDNAME           */\n/*  THE SPFPC EQUIVALENT  IS @CMD.CMD  --                     */\n/*   IS03.SPF2.MACROS(CMD) */\n/* @TSOXD   01.03 1986/06/05 1994/05/23 14:40 47   33    47 IS03*/\n/* 1994/06/01 converted to REXX                                 */\n\"(DSNX) = DATASET\"\n\"(MEMBERX) = MEMBER\"\n\"(DCHG) = DATA_CHANGED\"\nAOPTIONS = translate(AOPTIONS)\nIF DCHG = \"YES\" THEN  DO\n   say left(\"*\",71,\"*\")\n   say left(\"*       YOUR FILE HAS NOT BEEN SAVED\",\n            \"AFTER MAKING changes\",70)\"*\"\n   say left('*',70,\"*\")\n   say left(\"* THEREFORE YOUR REQUEST WILL NOT BE HONORED -- SEE\"||,\n       \"ALSO @TSOX  CLIST\",70)\"*\"\n   say left(\"*\",71,\"*\")\n   ZEDSMSG = \"NOT SAVED\"\n   ZEDLMSG = zedsmsg\" -- DID NOT ATTEMPT TO EXECUTE DISPLAYED CLIST\"\n   Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   Exit 12\nEND\nIF MEMBERX \\= \"\" then DSNX = DSNX\"(\"MEMBERX\")\"\ncallx = \"'\"dsnx\"'\"\nCHK = SYSDSN(callx)\ncallx = \"Address \"\"TSO\"\" \"\"EXEC\"\"\" \"\"\"\"callx\"\"\"\"\nIF \"OK\" = CHK THEN  DO\n   IF AOPTIONS = \"\" then null\n   else callx = callx \"\"\"'\"aoptions\"'\"\"\"\n   SAY \"NOW INVOKING --\" callx\n   interpret callx\n   Exit RC\nEND\nSAY DSNX \"--\" chk\nexit rc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@VP": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x9a\\x00\\x9a\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 154, "newlines": 154, "modlines": 0, "user": "MCRITCH"}, "text": "    /* PURPOSE: TSO PRINTOFF FOR MEMBER CURRENTLY DISPLAYED IN EDIT\n    /* CONTRIBUTED:   F. DAVID MCRITCHIE             1989/05/11 BWTR\n    /* USER CONTACT:  F. DAVID MCRITCHIE\n    /* CODE MAINT.:   SYSTECH GROUP\n    /*  RELATED CLISTS\n    /*    @PRINT  USES PRINTOFF IF IT CAN OR CREATES A BATCH JOB\n    /*      OTHERWISE.  CAN PRINT TO A PROFS USERID.\n    /*    @VP     USES ONLY VSPRINT THE DATASET NAME IN EDIT\n    /*      IS ADDED ON YOUR BEHALF.\n  /**************************************************************\n  /* DOCUMENTED  IS03.SHARE.TEXT(@VP)\n  /* EXAMPLES:   ==> @VP                      GOES TO BWATER 3800\n  /*             ==> @VP DOWN           GOES TO BWATER 3800-5 CLASS=2\n  /*             ==> @VP DEST(P100E)          GOES TO SYSTECH PRINTER\n  /*             ==> @VP SYSTECH              GOES TO SYSTECH PRINTER\n  /*             ==> @VP DEST(CGDL2)          DALLAS --- XEROX PRINTER\n  /*             ==> @VP CFO.LASER            CHARLOTTE - LASER PRINTER\n  /*             ==> @VP CFO.LASER            CHARLOTTE - LASER PRINTER\n  /*\n  /* THE FOLLOWING ARE NORMAL VPSPRINT OPTIONS -- ALSO SEE DOCUMENTATED\n  /*             ==> @VP DOUBLE               DOUBLE SPACING\n  /* THERE ARE AT LEAST 60 ADDITIONAL OPTIONS, SOME OF THE MORE INTERESTING INCL\n  /*         HEXSP/HEXS2('BYTES-ACROSS')\n  /*         HX/HEX4/HEX8/X4/X8/XX\n  /*         LMARGIN('INTEGER')\n  /*\n  /* THE FOLLOWING OPTIONS WILL CAUSE A BATCH JOB TO BE USED\n  /*    CHARS(XXXX) GENERATES   CHARS=XXXX,\n  /*    FCB(XXXX)   GENERATES   FCB=XXXX,\n  /*    GTXX        GENERATES   FCB=XXXX,\n  /*    SCRIPT  WHICH IMPLIES   FCB=8X11,CHARS=GT12,\n  /****************************************************************\n            CONTROL ASIS\n ISREDIT    MACRO (TOK1,TOK2,TOK3,TOK4,TOK5,TOK6,TOK7,TOK8,TOK9,TOK10,+\n   TOK11,TOK12,TOK13,+\n          TOK14,TOK15,TOK16,TOK17,TOK18,TOK19,TOK20,TOK21,TOK22,TOK23,+\n             TOK24,TOK25,TOK26,+\n          TOK27,TOK28,TOK29,TOK30,TOK31,TOK32,TOK33,TOK34,TOK35,TOK36,+\n             TOK37,TOK38,TOK39)\n        SET BLANKS = &STR(                          )\n    ISREDIT (DSNX) = DATASET\n    ISREDIT (MEMBERX) = MEMBER\n        IF &STR(&MEMBERX) = &STR() THEN SET DSNXX = &DSNX\n        ELSE SET DSNXX = &DSNX(&MEMBERX)\n    ISREDIT (DCHG) = DATA_CHANGED\n /* OUTPUT FOR CLASS = A    UNLESS  SCRIPT,         */\n /*           IN WHICH CASE IT OUTPUTS TO CLASS Y   */\n    SET COPIES = 1\n    SET MSGCLASS = 9\n    SET RP = &STR()\n    IF &DCHG = YES THEN DO\n       WRITE ******************************************************\n       WRITE * YOUR FILE HAS NOT BEEN SAVED AFTER MAKING CHANGES  *\n       WRITE *                                                    *\n       WRITE * THE FILE PRINTED WILL NOT REFLECT CHANGES MADE IN  *\n       WRITE *       THE  CURRENT EDIT SESSION                    *\n       WRITE ******************************************************\n       WRITE REPLY <ENTER KEY> TO PRINT OLD VERSION\n       WRITE REPLY \"SAVE\"   | \"SAV\" TO SAVE THEN PRINT SAVED VERSION\n       WRITE REPLY \"CANCEL\" | \"CAN\" IF YOU DO NOT WANT TO PRINT THE OLD\n       READ PARM1\n       IF &SUBSTR(1:3,&STR(&SYSCAPS(&PARM1.)   )) = CAN THEN DO\n          WRITE TERMINATED BY YOUR COMMAND ... \"CAN\".\n          SET &ZEDSMSG = &STR(TERMINATED)\n          SET &XEDLMSG = &STR(CHANGES DONE SINCE LAST SAVE -- +\n                      YOU HAVE REPLIED TO CANCEL @VP)\n          SET &ZEDLMSG = &STR(&XEDLMSG.)\n          ISPEXEC     SETMSG MSG(ISRZ000)\n          EXIT CODE(8)\n       END\n       IF &SUBSTR(1:3,&STR(&SYSCAPS(&PARM1.)   )) = SAV THEN DO\n          ISREDIT SAVE\n          SET RC = &LASTCC.\n          /* 0 - NORMAL SAVE, 4 - NEW MEMBER SAVED, 12 DATA NOT SAVED\n          IF &RC. > 4  THEN DO\n           WRITE ******************************************************\n           WRITE * UNABLE TO SAVE YOUR FILE   RC = &RC.               *\n           WRITE ******************************************************\n           SET &ZEDSMSG = &STR(TERMINATED)\n           SET &XEDLMSG = &STR(UNABLE TO SAVE CHANGES -- +\n                       PERHAPS A COMPRESS IS NEEDED)\n           SET &ZEDLMSG = &STR(&XEDLMSG.)\n           ISPEXEC     SETMSG MSG(ISRZ000)\n           EXIT CODE(8)\n          END\n          GOTO SAVED\n       END\n       SET &ZEDSMSG = &STR(PRINTED/OLD CONTENT)\n       SET &XEDLMSG = &STR(CHANGES DONE SINCE LAST SAVE -- +\n                   CONTENT PRINTED NOT SAME AS DISPLAYED...)\n       SET &ZEDLMSG = &STR(&XEDLMSG.)\n      ISPEXEC     SETMSG MSG(ISRZ000)\n    END\n  SAVED: -\n    IF &STR(&DSNX) = &STR() THEN -\n       EXIT CODE(12)\n        SET BLANKS = &STR(&BLANKS&BLANKS)\n        SET BLANKS = &STR(&BLANKS&BLANKS)\n        SET BLANKS = &STR(&BLANKS&BLANKS)\n        SET LP = &STR((\n        SET RP = &STR())\n        SET N0 = 20\n        SET N  = 0\n        SET I = 0\n        SET L = 0\n        /*********\n        SET I = 1\n       DO WHILE &I <= 100\n        SET TOKEN = &&TOK&I\n        SET TOKEN = &STR(&SYSCAPS(&TOKEN))\n        IF DEBUG = &DEBUG THEN WRITE  &I  TOK&&I=&&TOK&I  TOKEN=&TOKEN\n        IF &STR(&TOKEN) = &STR() THEN GOTO END_TOK\n        IF &STR(&TOKEN) = SYSTECH | &STR(&TOKEN) = P100E | +\n          &STR(&TOKEN) = TECH -\n                                  | &STR(&TOKEN) = SYSTECH THEN DO\n           SET REMAIN = &SYSNSUB(1,P100E &REMAIN.)\n           GOTO NXT_TOK\n        END\n        IF HELP = &STR(&TOKEN) +\n           THEN DO\n             SET &&TOKEN.    = &STR(&TOKEN)\n             IF DEBUG = &DEBUG THEN WRITE  &I  TOK&I=&TOK&&I  +\n               TOKEN=&TOKEN\n             GOTO NXT_TOK\n           END\n        IF &SUBSTR(1:5,&STR(&TOKEN)       ) = &STR(DEST&STR(&LP))  +\n          THEN DO\n           SET TOKEN = &SUBSTR(6:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n             &STR(&TOKEN)         )\n           SET REMAIN = &SYSNSUB(1,&TOKEN. &REMAIN.)\n           ISREDIT LINE_BEFORE .ZF = NOTELINE +\n               \"REMOVED DEST( )  PASSING &TOKEN.  TO VPSPRINT\"\n           GOTO NXT_TOK\n        END\n        SET REMAIN = &SYSNSUB(1,&REMAIN. &TOKEN.)\n NXT_TOK: -\n        SET I = &I + 1\n      END\n END_TOK: SET I = &I\n      IF &STR(&REMAIN.) = &STR() THEN SET REMAIN = LOCAL\n       SET REMAIN = &SYSNSUB(1,'&DSNXX.' &REMAIN.)\n      ISREDIT LINE_BEFORE .ZF = NOTELINE +\n                \"&SYSTIME. TSO VP &SYSNSUB(1,&REMAIN.)\"\n       VPSPRINT &REMAIN.\n       SET RC = &LASTCC.\n       IF 0 ^= &RC. THEN DO\n          SET &ZEDSMSG = &STR(PRINTVPS -- RC=&RC.)\n          SET &ZEDLMSG = &STR(&ZEDSMSG. -- ERROR MESSAGE WAS TYPED)\n         ISREDIT     LINE_BEFORE .ZF    = NOTELINE \"*ERROR** &ZEDLMSG.\"\n          ISPEXEC     SETMSG MSG(ISRZ000)\n       END\n       EXIT CODE(1)\n     /*****************************************************************\n     /*****************************************************************\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@XMIT": {"ttr": 4101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00S\\x00S\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 83, "newlines": 83, "modlines": 0, "user": "MCRITCH"}, "text": "  ISREDIT MACRO (TO)\n  ISREDIT (MEMBERX) = MEMBER\n  ISREDIT (DSNX)    = DATASET\n  IF &STR(&MEMBERX.) ^= &STR() THEN SET DSNX = &DSNX.(&MEMBERX.)\n  ISREDIT (DCHG) = DATA_CHANGED\n  IF &DCHG = YES THEN DO\n     IF STR(&TO.) = &STR() THEN SET TO = NODE.USERID\n     WRITE ******************************************************\n     WRITE *          ===> @XMIT &TO.                    *\n     WRITE *                                                    *\n     WRITE * YOUR FILE HAS NOT BEEN SAVED AFTER MAKING CHANGES  *\n     WRITE *                                                    *\n     WRITE * YOUR FILE WILL NOT BE TRANSMITTED                  *\n     WRITE *       ... SORRY BETTER LUCK NEXT TIME              *\n     WRITE ******************************************************\n     SET &ZEDSMSG = &STR(FAILED / NOT SAVED)\n     SET &XEDLMSG = &STR(CHANGES DONE SINCE LAST SAVE -- +\n                 REQUEST TO TRANSMIT NOT COMPLETED)\n     SET &ZEDLMSG = &STR(&XEDLMSG.)\n     ISPEXEC     SETMSG MSG(ISRZ000)\n     EXIT CODE(4)\n  END\n  IF &STR(&TO.) = &STR() THEN DO\n     IF &SYSUID. = IS03  THEN SET TO = CCC.BWDFM\n     IF &SYSUID. = BWDFM THEN SET TO = AHCENTER.IS03\n     IF &SYSUID. = IS0J  THEN SET TO = CCC.BWGWM\n     IF &SYSUID. = BWGWM THEN SET TO = AHCENTER.IS0J\n     IF &SYSUID. = C047  THEN SET TO = CCC.BWAGF\n     IF &SYSUID. = CCAGF THEN SET TO = AHCENTER.C047\n     IF &SYSUID. = IS0R  THEN SET TO = CCC.BWRFM\n     IF &SYSUID. = BWRFM THEN SET TO = AHCENTER.IS0R\n     WRITE TRANSMISSIONS BETWEEN DALLAS -- CCC, AND BBBBBBBBBBR -- CORPORAT\n     WRITE WILL BE ENDING SOON ------ THIS IS A WARNING MESSAGE\n     IF &STR(&TO.) = &STR() THEN DO\n        WRITE PLEASE SUPPLY DESTINATION FOR TRANSMIT  OR CANCEL\n        WRITE      E.G.  CCC.CCFML\n        READ TO\n        WRITE NEXT TIME USE ===> @XMIT &TO.\n        ISREDIT LINE_BEFORE .ZF = NOTELINE \"&SYSTIME. NEXT TIME USE +\n          ===> @XMIT &TO.\"\n     END\n  END\n  IF CANCEL = &STR(&TO.) THEN DO\n     SET &ZEDSMSG = &STR(@XMIT CANCELLED)\n     SET &ZEDLMSG = &STR(&ZEDSMSG. BY YOUR REQUEST)\n     ISREDIT     LINE_BEFORE .ZF = NOTELINE \"&SYSTIME. @XMIT    +\n       &STR(--) CANCELLED\"\n     ISPEXEC     SETMSG MSG(ISRZ000)\n     EXIT CODE(1)\n  END\n  TRANSMIT &TO DA('&DSNX.') SEQ\n  SET I = &SYSINDEX(&STR( MSG),&NRSTR(&TO.))\n  IF &EVAL(&I.) NE &EVAL(0) THEN DO\n     /* ************************************************\n     /* SUCCESS OR FAILURE WILL BE NOTED IN THE TRANSMIT\n     /* IF MSG IS USED CONTINUING CLIST FROM THIS POINT\n     /* MESSES UP SCREEN\n     WRITE\n     WRITE ********** THE USE OF \"MSG\" CAUSES A MINOR PROBLEM RETURNING TO ISPF\n     WRITENR ********         HIT ENTER THEN HIT PA-2 TO FIX SCREEN\n     READ XYZ\n     EXIT CODE(0)\n  END\n  /* ************************************************\n  SET RC = &LASTCC.\n  IF &LASTCC = 0 THEN DO\n  /*     SET &ZEDSMSG = &STR(RC=&RC.)\n     SET &ZEDLMSG = TRANSMIT &STR(&TO.) DA('&DSNX.') SEQ &STR(--) +\n       SUCCESSFUL\n     ISREDIT     LINE_BEFORE .ZF = NOTELINE \"&SYSTIME. +\n                    TRANSMIT &STR(&TO.) DA('&DSNX.')\"\n     ISPEXEC     SETMSG MSG(ISRZ000)\n     EXIT CODE(1)\n  END\n  ELSE DO\n  /*     SET &ZEDSMSG = &STR(RC=&RC.)\n     SET &ZEDLMSG = TRANSMIT &STR(&TO.) DA('&DSNX.')) SEQ &STR(--) +\n       FAILED\n     ISREDIT     LINE_BEFORE .ZF = NOTELINE \"&SYSTIME. +\n                    @XMIT  FAILED\"\n     ISPEXEC     SETMSG MSG(ISRZ000)\n     EXIT CODE(1)\n  END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AFP": {"ttr": 4104, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x8b\\x00\\x8b\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 139, "newlines": 139, "modlines": 0, "user": "MCRITCH"}, "text": " PROC 1 MEMBER DEBUG NB SUMMARY -\n         DS1(SYS1.PROD.FONTLIB) +\n         DS2(SYS1.PROD.FONT3820) +\n         DS3(SYS1.PROD.FONT300) +\n         DS4(SYS1.FONTLIB) +\n         DS5(SYS1.FONTLIBB) +\n         DS6(DUVTT.V1R1M0.FONT300) +\n         DS7(SYS1.PROD.PSEGLIB) +\n         DS8(SYS1.PSEGLIB) +\n         DS9(SYS1.PROD.OVERLIB) +\n         DS10(SYS1.OVERLIB) +\n         DS11(SYS1.PROD.PDEFLIB) +\n         DS12(SYS1.PDEFLIB) +\n        DS13(SYS1.PROD.FDEFLIB) +\n        DS14(SYS1.FDEFLIB) +\n        DS15(SYS1.IMAGELIB) +\n        DS16(SYS1.AIMAGE)\n /* DATASETS BASED ON CONTENT OF  SYS1.PROCLIB(APSWPROC) 1990/05/25 D.MCR\n /*  + SYS1.FONTLIB AND SYS1.PSEGLIB + .IMAGELIB + .AIMAGE\n /* ********************************************************\n /* PURPOSE: BROWSE A AFP OR OTHER RELATED PRINT MEMBERS\n /*  SUPPLIED BY DAVID MCRITCHIE AHC 1985/07/10\n /* ********************************************************\n   CONTROL MAIN\n  SET MULTIMEM = &SYSINDEX(&STR(*),&STR(&MEMBER.))\n  IF &MULTIMEM = 0 THEN -\n     SET MULTIMEM = &SYSINDEX(&STR(%),&STR(&MEMBER.))\n  SET L = &LENGTH(&STR(&MEMBER.))\n  IF &L. > 8 THEN DO\n     SET INVAL = &STR(INVALID MEMBERNAME LENGTH('&MEMBER.') EXCEEDS 8)\n     WRITE &INVAL.\n     SET &ZEDSMSG = &STR(MEMBERNAME)\n     SET &ZEDLMSG = &STR(&INVAL.)\n     ISPEXEC     SETMSG MSG(ISRZ000)\n     EXIT CODE(12)\n  END\n   ISPEXEC CONTROL DISPLAY LINE\n   IF CHKCAT = &SYSCAPS(&CHKCAT.) +\n   | CHKCAT = &SYSCAPS(&STR(&MEMBER.)) THEN DO\n      SET CHKCAT = CHKCAT\n      SET MEMBER = &STR(........)\n      SET SUMMARY = &STR()\n      SET ALL = ALL    /* MIGHT AS WELL CHECK EVERYTHING */\n   END\n   SET BLANKS = &STR(                               )\n   SET BLANKS = &STR(&BLANKS.&BLANKS.&BLANKS.)\n   SET XCNT = 0\n   SET N = 1\n   SET DS = &&DS&N..\n   SET NC = &SYSCAPS(&NC)\n   IF &NC = NC THEN SET SUMMARY = SUMMARY\n   SET SUMMARY = &SYSCAPS(&SUMMARY)\n   IF &SUMMARY = SUMMARY THEN DO\n      WRITE\n      WRITE SUMMARY FROM ===> TSO AFP &MEMBER &NB &SUMMARY\n      WRITE\n   END\n   SET AVAIL = 0\n   DO WHILE &STR(&DS) ^=\n      SET AVAIL = &AVAIL. + 1\n      IF CHKCAT = &SYSCAPS(&CHKCAT.) THEN DO\n         /*    CONTROL NOLIST NOCONLIST NOSYMLIST MSG\n         /*       SYSOUT TRAPS WILL NOT WORK IF YOU USE   LIST\n         SET SYSOUTTRAP = 100\n         SET SYSOUTLINE7 = +\n            &STR(.....................................)\n         LISTCAT ENT('&DS.') VOL\n         SET NS = &SYSOUTLINE\n         SET I = 1\n         DO WHILE &I <= &NS\n            SET X = &STR(&&SYSOUTLINE&I..)\n            SET X = &STR(&X.)\n            SET I = &I. + 1\n         END\n         WRITE &SUBSTR(26:31,&SYSOUTLINE7.&BLANKS.) +\n             &SUBSTR(16:60,&SYSOUTLINE1.&BLANKS.)\n         GOTO AGAIN\n      END   /* OF CHKCAT *******/\n      IF &MULTIMEM. = 0 +\n         THEN SET GOODBAD = &STR(&SYSDSN('&DS.(&MEMBER.)')\n         ELSE SET GOODBAD = &STR(&SYSDSN('&DS.')\n      IF &SUMMARY = SUMMARY THEN DO\n            WRITE '&DS.(&MEMBER.)' -- &STR(&GOODBAD.).\n            IF &STR(&GOODBAD.) = OK THEN -\n               SET XCNT = &XCNT. + 1\n      END\n      ELSE DO\n         IF &STR(&GOODBAD.) = OK THEN DO\n            IF &MULTIMEM ^= 0 THEN ISPEXEC CONTROL ERRORS RETURN\n            ISPEXEC   BROWSE DATASET('&DS.(&MEMBER.)')\n            IF &LASTCC. = 0 THEN SET XCNT = &XCNT. + 1\n         END\n         ELSE DO\n            IF &DEBUG. = DEBUG THEN DO\n               WRITE '&DS.(&MEMBER.)' -- &STR(&GOODBAD.).\n            END\n            ELSE DO\n               IF &STR(&GOODBAD.) ^= &STR(MEMBER NOT FOUND) +\n                 THEN -\n                  WRITE '&DS.(&MEMBER.)' -- &STR(&GOODBAD.).\n            END\n         END\n      END\n    AGAIN: +\n      SET N = &N. + 1\n      SET DS = &&DS&N..\n   END\n   IF CHKCAT = &CHKCAT. THEN RETURN CODE(0)\n   IF &MULTIMEM. ^= 0 THEN DO\n      WRITE PATTERN MEMBER=&MEMBER. WAS FOUND IN &XCNT. OF THE +\n         &AVAIL. AFP LIBRARIES PRESENTED\n      EXIT CODE(0)\n   END\n   %CST806 &MEMBER\n   SET CC = &LASTCC\n   IF &CC = 0 THEN DO\n      IF &XCNT. = 0  THEN DO\n         WRITE &MEMBER EXISTS IN A LOAD LIBRARY BUT NOT IN +\n           THOSE KNOWN TO THIS CLIST\n         EXIT CODE(1)\n      END\n   END\n   IF &CC = 4 THEN -\n         WRITE &MEMBER EXISTS IN A LOAD LIBRARY AND IS MARKED  +\n           NOT-EXECUTABLE\n   IF &CC = 8 THEN DO\n      IF &XCNT. ^= 0  THEN DO\n         WRITE MEMBER=&MEMBER. WAS FOUND IN &XCNT. OF THE +\n           &AVAIL. AFP LIBRARIES PRESENTED, +\n           BUT FOR YOU IS NOT PART OF STEPLIB OR LOAD LIBRARIES\n         EXIT CODE(1)\n      END\n   END\n   IF &XCNT. = 1 THEN EXIT CODE(0)\n   IF &XCNT. = 0 THEN WRITE MEMBER=&MEMBER. WAS NOT FOUND IN +\n     ANY OF THE &AVAIL. SELECTED AFP  LIBRARIES\n   ELSE WRITE MEMBER=&MEMBER. WAS FOUND IN &XCNT. OF THE +\n      &AVAIL. AFP LIBRARIES PRESENTED\n   EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALIGNJCL": {"ttr": 4107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00U\\x00U\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 85, "newlines": 85, "modlines": 0, "user": "MCRITCH"}, "text": "CONTROL ASIS\nISREDIT MACRO NOPROCESS (BEGA,ENDB)\n WRITE In the future please use FIXJCL -- it works better.\n/*  DESCRIPTION:   ALIGN JCL such that \"EXEC\" begin on col 12\n/*                 and \"DD\" begins on col 13.\n/*  PURPOSE:       Create more readable JCL.\n/*  INSTALL:       into SYS1.TSOCLIST for use by everyone\n/*  NOTE:          AUTOSAVE OFF   is not invoked -- no problems expected\n/*                 default pair of labels is  .ZFIRST and .ZLAST\n/*  Contributed: 1985/12/24 David McRitchie                       */\nIF &BEGA. = THEN DO   /* set default labels if none supplied         */\n   SET BEGA = &STR(.ZFIRST) /* default        ALIGNJCL .ZFIRST .ZLAST */\n   SET ENDB = &STR(.ZLAST) /* you could use   ALIGNJCL .ZFIRST .ZLAST */\nEND\nISREDIT (MEMNAME) = MEMBER\nISREDIT (LBOUND,RBOUND) = BOUNDS\nISREDIT BOUNDS 1 71\nISREDIT reset &BEGA. &ENDB.\nISREDIT x all\nISREDIT find all 1 '//'\nIF &LASTCC ^= 0 THEN EXIT CODE(0)\nISREDIT x all    1 '//*'\nISREDIT x all    12 'EXEC'\nISREDIT change &BEGA. &ENDB. all nx 12 ' DD   ' ' DD  '\nISREDIT x all    12 ' DD  '\nISREDIT change &BEGA. &ENDB. all nx  3 ' DD '    '          DD '\nISREDIT change &BEGA. &ENDB. all nx  4 ' DD '    '         DD '\nISREDIT change &BEGA. &ENDB. all nx  5 ' DD '    '        DD '\nISREDIT change &BEGA. &ENDB. all nx  6 ' DD '    '       DD '\nISREDIT change &BEGA. &ENDB. all nx  7 ' DD '    '      DD '\nISREDIT change &BEGA. &ENDB. all nx  8 ' DD '    '     DD '\nISREDIT change &BEGA. &ENDB. all nx  9 ' DD '    '    DD '\nISREDIT change &BEGA. &ENDB. all nx 10 ' DD '    '   DD '\nISREDIT change &BEGA. &ENDB. all nx 11 ' DD '    '  DD '\nISREDIT change &BEGA. &ENDB. all nx 11 '  DD  '  '  DD '\nISREDIT change &BEGA. &ENDB. all nx 11 '  DD '   '  DD  '\nISREDIT change &BEGA. &ENDB. all nx  3 ' EXEC '  '         EXEC '\nISREDIT change &BEGA. &ENDB. all nx  4 ' EXEC '  '        EXEC '\nISREDIT change &BEGA. &ENDB. all nx  5 ' EXEC '  '       EXEC '\nISREDIT change &BEGA. &ENDB. all nx  6 ' EXEC '  '      EXEC '\nISREDIT change &BEGA. &ENDB. all nx  7 ' EXEC '  '     EXEC '\nISREDIT change &BEGA. &ENDB. all nx  8 ' EXEC '  '    EXEC '\nISREDIT change &BEGA. &ENDB. all nx  9 ' EXEC '  '   EXEC '\nISREDIT change &BEGA. &ENDB. all nx 10 ' EXEC '  '  EXEC '\nISREDIT change &BEGA. &ENDB. all nx 11 '  EXEC '  ' EXEC '\nISREDIT change &BEGA. &ENDB. all nx 11 '   EXEC '  ' EXEC '\nISREDIT change &BEGA. &ENDB. all nx 11 '   EXEC  '  ' EXEC '\nISREDIT BOUNDS\nISREDIT BOUNDS &LBOUND. &RBOUND.\nISREDIT x all    72 ' '\nISREDIT x all    71 ','\nISREDIT locate 0\nISREDIT locate ERROR\nIF &LASTCC = 0 THEN DO\n   ISREDIT LINE_BEFORE .ZCSR   = NOTELINE \" \"\n   ISREDIT LINE_BEFORE .ZCSR   = NOTELINE \"UNABLE to REALIGN  JCL for +\n     lines marked ==ERR> \"\n   ISREDIT find .ZCSR .ZCSR \" \" all\nEND\nR: ISREDIT locate ERROR\nIF &LASTCC = 0 THEN DO\n   ISREDIT find .ZCSR .ZCSR \" \" all\n   GOTO R\nEND\nISREDIT locate 0\nISREDIT locate CHANGE\nIF &LASTCC = 0 THEN DO\n   ISREDIT LINE_BEFORE .ZCSR   = NOTELINE \" \"\n   ISREDIT LINE_BEFORE .ZCSR   = NOTELINE \"UNABLE to REALIGN  JCL for +\n     lines marked ==ERR> \"\n   ISREDIT find .ZCSR .ZCSR \" \" all\nEND\nS: ISREDIT locate CHANGE\nIF &LASTCC = 0 THEN DO\n   ISREDIT find .ZCSR .ZCSR \" \" all\n   GOTO S\nEND\nISREDIT locate 0\nISREDIT find nx first 72 p' '\nIF &LASTCC = 0 THEN DO\n   ISREDIT LINE_BEFORE .ZCSR   = NOTELINE \" \"\n   ISREDIT LINE_BEFORE .ZCSR   = NOTELINE \"col 72 not blank for one +\n     or more lines of JCL      ..55...60...65...70.x\"\nEND\nISREDIT locate 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALIGNTAB": {"ttr": 4110, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x90\\x00\\x90\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 144, "newlines": 144, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX: ALIGNTAB -- Align tabs to cols for all lines in CC range   */\n/* author: David McRitchie, \"The REXX Macros Toolbox\", 1992/07/26 */\n/* There are many ways this macro could be set up.  This macro will  */\n/* attempt to align tabs on column indicated by moving TAB and       */\n/* remaining tabs and data left by deleting spaces immediately left; */\n/* or right by adding spaces immediately left of tab and remaining   */\n/* tabs and data.  Text library without sequence numbers (VB 255) is */\n/* recommended; otherwise data may be truncated.                     */\n/*                                                                   */\n/* For each line, each tab will have to be placed.  So will be       */\n/* somewhat CPU intensive.  No tabs will be added (or deleted).      */\n/* lines not up to specs will be labelled  .TABaa, and lines with    */\n/* insufficient tabs will be labelled .ERRaa    Process ALL lines    */\n/* within range unless  NX  is used.                                 */\n/*                                                                   */\n/*    e.g.  ===> ALIGNTAB 10 20 30 40 50 NX  .A .B                   */\n/*                                                                   */\n/* Related macros                                                    */\n/*   REMBLANK - removes blank columns in line range                  */\n/*                                                                   */\nAddress \"ISREDIT\"; \"MACRO NOPROCESS (TOKEN)\"\n\nIf token = \"\" then TOKEN = \"10 20 30 40\"\ntoken = ' '||translate(token)||' '\nNX = Process('NX')\nINSERT = Process('INSERT')\nlabf='';labl='';left='';right=''\nparse var token left ' .' labf ' ' right\nif labf \\= '' then do;\n   token = left right\n   parse var token left ' .' labl ' ' right\n   token = left right\n   labf = '.'||labf\n   labl = '.'||labl\nend\nelse do; labf = '.ZFIRST'; labl = '.ZLAST'; end\n\"PROCESS RANGE C\"\nIF RC = 0 THEN DO\n   LABF = \".ZFRANGE\"\n   LABL = \".ZLRANGE\"\nEND\nLABFEW = 1; LABERR = 1\nAA = '$$',\n|| \"AAABACADAEAFAGAHAIAJAKALAMANAOAPAQARASATAUAVAWAXAYAZ\",\n|| \"BABBBCBDBEBFBGBHBIBJBKBLBMBNBOBPBQBRBSBTBUBVBWBXBYBZ\",\n|| \"CACBCCCDCECFCGCHCICJCKCLCMCNCOCPCQCRCSCTCUCVCWCXCYCZ\",\n|| \"DADBDCDDDEDFDGDHDIDJDKDLDMDNDODPDQDRDSDTDUDVDWDXDYDZ\",\n|| \"EAEBECEDEEEFEGEHEIEJEKELEMENEOEPEQERESETEUEVEWEXEYEZ\",\n|| \"FAFBFCFDFEFFFGFHFIFJFKFLFMFNFOFPFQFRFSFTFUFVFWFXFYFZ\",\n|| \"GAGBGCGDGEGFGGGHGIGJGKGLGMGNGOGPGQGRGSGTGUGVGWGXGYGZ\",\n|| \"HAHBHCHDHEHFHGHHHIHJHKHLHMHNHOHPHQHRHSHTHUHVHWHXHYHZ\"\nAA = AA,\n|| \"IAIBICIDIEIFIGIHIIIJIKILIMINIOIPIQIRISITIUIVIWIXIYIZ\",\n|| \"JAJBJCJDJEJFJGJHJIJJJKJLJMJNJOJPJQJRJSJTJUJVJWJXJYJZ\",\n|| \"KAKBKCKDKEKFKGKHKIKJKKKLKMKNKOKPKQKRKSKTKUKVKWKXKYKZ\",\n|| \"LALBLCLDLELFLGLHLILJLKLLLMLNLOLPLQLRLSLTLULVLWLXLYLZ\",\n|| \"MAMBMCMDMEMFMGMHMIMJMKMLMMMNMOMPMQMRMSMTMUMVMWMXMYMZ\",\n|| \"NANBNCNDNENFNGNHNINJNKNLNMNNNONPNQNRNSNTNUNVNWNXNYNZ\",\n|| \"OAOBOCODOEOFOGOHOIOJOKOLOMONOOOPOQOROSOTOUOVOWOXOYOZ\",\n|| \"PAPBPCPDPEPFPGPHPIPJPKPLPMPNPOPPPQPRPSPTPUPVPWPXPYPZ\"\nAA = AA,\n|| \"QAQBQCQDQEQFQGQHQIQJQKQLQMQNQOQPQQQRQSQTQUQVQWQXQYQZ\",\n|| \"RARBRCRDRERFRGRHRIRJRKRLRMRNRORPRQRRRSRTRURVRWRXRYRZ\",\n|| \"SASBSCSDSESFSGSHSISJSKSLSMSNSOSPSQSRSSSTSUSVSWSXSYSZ\",\n|| \"TATBTCTDTETFTGTHTITJTKTLTMTNTOTPTQTRTSTTTUTVTWTXTYTZ\",\n|| \"UAUBUCUDUEUFUGUHUIUJUKULUMUNUOUPUQURUSUTUUUVUWUXUYUZ\",\n|| \"VAVBVCVDVEVFVGVHVIVJVKVLVMVNVOVPVQVRVSVTVUVVVWVXVYVZ\"\nAA = AA,\n|| \"WAWBWCWDWEWFWGWHWIWJWKWLWMWNWOWPWQWRWSWTWUWVWWWXWYWZ\",\n|| \"XAXBXCXDXEXFXGXHXIXJXKXLXMXNXOXPXQXRXSXTXUXVXWXXXYXZ\",\n|| \"YAYBYCYDYEYFYGYHYIYJYKYLYMYNYOYPYQYRYSYTYUYVYWYXYYYZ\",\n|| \"ZAZBZCZDZEZFZGZHZIZJZKZLZMZNZOZPZQZRZSZTZUZVZWZXZYZZ\"\nT.=;\nParse VAR TOKEN T.1 T.2 T.3 T.4 T.5 T.6 T.7 T.8 T.9 T.10 ,\n     T.11 T.12 T.13 T.14 T.15 T.16 T.17 T.18 T.19 T.20\ndo i = 1 to 20; if t.i \\= '' then t.0 = i; end;\n\"(LINENO) = linenum \"labf\n\"(LASTNO) = linenum \"labl\nblanks = substr(' ',1,255)\nlabfewx=0;laberrx=0\nProcess_CARD:\n  savcard = card; tx=1\n  \"(CARD) = LINE \" lineno;tx = 1\n  \"(LAB)  = LABEL \" lineno\n  If substr(LAB,1,4) = '.FEW' | substr(LAB,1,4) = '.ERR' then\n     \"RESET LABEL\" LAB LAB\n  If NX = \"NX\" then do\n     \"(VAR075) = XSTATUS \" lineno\n     If VAR075 \\= \"NX\" then signal ncard\n  end\n   Do while (TX <= t.0)\n      I = pos('^',card)\n      if i = 0 then do;\n         labfewx = 1\n         if INSERT = \"INSERT\" then do\n            if substr(card,t.tx) = '' then\n               do jj =   tx to t.0\n                  xcard=substr(card,1,t.jj-1)||'^'||substr(card,t.jj+1)\n                  card = xcard\n               end\n         end\n         signal ncard\n      end\n      xcard=substr(card,1,i-1)||x2c('38')||substr(card,I+1);card=xcard\n      l = t.tx - i\n      if i < t.tx then do\n         L1 = i - 1;\n         xcard=substr(card,1,L1)||substr(blanks,1,L)||substr(card,i)\n         card = xcard\n      end\n      if i > t.tx then do\n         if substr(card,t.tx,i-t.tx)='' then do\n            xcard = substr(card,1,t.tx-1)||substr(card,i)\n            card = xcard\n         end\n         else laberrx = 1\n      end\n      tx = tx + 1\n   end\n ncard:\n   if labfewx = 1 then do; labfewx = 0;\n      labfew = labfew + 2\n      \"label\" lineno \"= .FEW\"||substr(aa,labfew,2) \"0\"\n   end\n   if laberrx = 1 then do; laberrx = 0;\n      laberr = laberr + 2\n      \"label\" lineno \"= .ERR\"||substr(aa,laberr,2) \"0\"\n   end\n   card = translate(card,'^',x2c('38'))\n   /*if card ^= savcard then */\n   \"LINE\" lineno \"= (CARD)\"\n   lineno = lineno + 1\n   if lineno <=lastno then signal process_CARD /* work in range */\n   null=''\nreturn\nexit\nProcess: procedure expose token\n arg subtoken\n null=''\n i = pos(' '||subtoken||' ',token)\n if i=0 then return null\n tokenx = substr(token,1,I) || substr(token,I+2+length(subtoken))\n token = tokenx\n return subtoken\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "APPEND": {"ttr": 4356, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xd5\\x00\\xd5\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 213, "newlines": 213, "modlines": 0, "user": "MCRITCH"}, "text": "/*APPEND:   APPEND portions of file in EDIT                 (REXX)   */\n/*APPEND:   Author: David McRitchie, \"The REXX Macros Toolbox\"          */\n/*     1994/04/07 Converted to REXX from specs in use since 1991/12/24 */\n/*     1994/06/24 Ability to used numbered CUTDSN## datasets         */\n/*-------------------------------------------------------------------*/\n/*       Macro:   APPEND         (CUTR  for SPF/PC usage)            */\n/*       Purpose: Append CC-Range and/or NX lines into               */\n/*                userid.CUTDSN.LIST for later use with PASTE macro. */\n/*       Companion Macros: CUT, PASTE      --  spf/pc CUTR, PASTER   */\n/*       Related Macros:   CUTD, CUTDD, REFORMAT                     */\n/*********************************************************************/\n/* Highlights: This set of CUT/APPEND/PASTE macros will mark the     */\n/*   changes in the affected file with NOTELINEs.  This allows easy  */\n/*   comparison between old material and new material, etc.  Some    */\n/*   other versions of CUT/APPEND/PASTE use ISPF variables causing   */\n/*   serious problems with your profile dataset when large files are */\n/*   copied.  This will not happen with these macros, also your data */\n/*   being in a distinct dataset is protected across logons/crashes. */\n/*   Written in REXX readily permits later customizations.           */\n/*   Other cut/paste macros: NaSPA 0004, CBT 95, 161, 168, 194, 270  */\n/*********************************************************************/\n/*  THIS EDIT MACRO CLIST AND ITS COMPANIONS                         */\n/*                                                                   */\n/*  CUT ---------- ** THIS EDIT MACRO ** ------------                */\n/*     Take selected lines specified by the user and copy/move       */\n/*     them to a sequential work dataset used later by the paste     */\n/*     command.                                                      */\n/*  APPEND ------- ** COMPANION EDIT MACRO ** -------                */\n/*    Will append additional information a header will be created,   */\n/*    and information will be appended to your cut dataset.          */\n/*  PASTE -------- ** COMPANION EDIT MACRO ** -------                */\n/*    Take the output dataset created by cut and move it to          */\n/*    anywhere in the current dataset being edited.                  */\n/* Options of CUT and APPEND  (all options are optional)             */\n/*    CC-range -- restrict selected lines -- normal usage            */\n/*    NX   -- Include only NX lines within CC-Range or entire range  */\n/*    DOC  -- (opt.) document with date/timestamp and source dsn.    */\n/*    NX       Copy NX lines,  CC-range becomes optional             */\n/*    EDIT     edit the paste dataset                                */\n/*    ? |HELP  Show help information                                 */\n/*    ##   -- 1 or 2 digit number  to cut into a different dsn       */\n/*             i.e.   userid.CUTDSN##.LIST                           */\n/* Options of PASTE ---------------------------------                */\n/*    KEEP -- Keep work dataset, default is to delete work file      */\n/*    COL(nn),VALUE(xxxx) -- include only lines with value in col nn */\n/*    (member),  paste member from permanent pds PASTE library       */\n/*    ##   -- 1 or 2 digit number  to paste from a different dsn     */\n/*             i.e.   userid.CUTDSN##.LIST                           */\n/* WARNINGS: ----- WARNINGS -------------------------                */\n/*    The CUT file attributes are based on the original file cut --  */\n/*    you may lose later information added if the recordsize is      */\n/*    larger than the original -- especially for fixed records.      */\n/*    m<n> or mm line options will alter your dataset by removing    */\n/*    lines.      Other cut/paste clists may eat up your profile     */\n/*    dataset, this clist uses a work file and therefore does not    */\n/*    affect your profile.                                           */\n/*                                                                   */\n/*  EXAMPLE :                                                        */\n/*     CUT     USE   CC  OR MM LINE RANGE,  OR C<N> OR M<N>          */\n/*     APPEND  USE   CC  OR MM LINE RANGE,  OR C<N> OR M<N>          */\n/*     PASTE   USE   B   OR A   LINE RANGE                           */\n/*********************************************************************/\n/* NOTE:  QWPASTE MUST BE USED WHEN USING PASTE FACILITIES OF       */\n/*        MVS/QUICKREF 3.2 INVOKED VIA QW.                          */\n/*********************************************************************/\n/*                                                                   */\n    Address \"ISREDIT\";\"MACRO (TOKEN) NOPROCESS\"\n    possible=0; copied=0;\n    possible=0; copied=0;other=\"\";CUTDSNnn=\"CUTDSN\"\n    token = ' 'translate(token)' '\n    i=pos(' HELP ',token); if i=0 then i=pos('?',TOKEN);\n    if i \\= 0 then do; Address \"TSO\" \"CLIST CUT HELP\"; exit 1;end;\n    i =pos(' NX ',token)\n    if i \\= 0 then do;nxopt=1;\n       token = substr(token,1,i-1)||substr(token,i+3)\n    end; else nxopt = 0\n    i =pos(' DOC ',token)\n    if i \\= 0 then do;docopt=1;\n       token = substr(token,1,i-1)||substr(token,i+4)\n    end; else docopt = 0\n    i =pos(' EDIT ',token)\n    if i \\= 0 then do;editopt=1;\n       token = substr(token,1,i)||substr(token,i+6)\n    end; else editopt = 0\n    zedsmsg = '**';zedlmsg='**'\n    if token \\= \"\" then do\n       token = strip(token)\n       if datatype(token,'N') = 1 then do\n          other = token + 0; token=\"\"\n          CUTDSNnn = CUTDSNnn||other\n       end\n    end\n    if token \\= \"\" then do\n       ZEDSMSG = \"unknown\" token\n       ZEDLMSG = token \"-- unknown to CUT/APPEND/PASTE\"\n       ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    end\n    \"(rowx,colx) = cursor\"\n    qcnt = 0\n    q.=\"\"\n    Address 'ISREDIT' '(dsn) = dataset'\n    Address 'ISREDIT' '(member) = member'\n    parse version v1 v2 v3 v4 v5\n    if v1 = \"REXXSAA\" then do  /* obtain membername */\n       do i = 1 to 8\n          parse var member left '\\' right\n          if right \\= \"\" then member = right\n       end\n       parse var member member '.' right\n       dochdr = dsn\n    end\n    if member = \"\" then dochdr=\"-----\" dsn\n    else dochdr=strip(dsn)\"(\"strip(member)\")\"\n    first = 99999999; last = 00000000;\n    Address \"ISPEXEC\" \"control errors return\"\n    \"PROCESS RANGE C M\"\n    rcx=rc\n    \"(RANGE) = RANGE_CMD\"\n    Address \"ISPEXEC\" \"control errors cancel\"\n    if rcx > 4 then do\n       ZEDSMSG = ZERRSM\n       ZEDLMSG = ZERRMSG ZERRLM \"RC=\"rcx\n       Address \"ISPEXEC\" \"setmsg msg(isrz000)\"\n       exit rcx\n    end\n    LABF = \".ZFRANGE\"\n    LABL = \".ZLRANGE\"\n    \"(first) = linenum .zfrange\"\n    \"(last) = linenum .zlrange\"\n    if docopt = 1 then qcnt = 2 /* will fill in later*/\n    do i = first to last\n       possible= possible+1\n       if nxopt = 1 then do\n          Address \"ISREDIT\" \"(xstatus) = xstatus\" i\n          if xstatus \\= \"NX\" then iterate i\n       end\n       Address \"ISREDIT\" \"(line) = line\" i\n       qcnt=qcnt+1; q.qcnt = line\n       copied = copied + 1\n    end\n    q.0 = qcnt\n    if docopt = 1 then do\n       if nxopt = 1 then\n       q.1 = left('.***',40) \"Copied\" copied \"of\" possible\n       else q.1 = '.***'\n       q.2 = '.***' date(\"U\") time() dochdr '-- Lines',\n           strip(first,'l','0')'-'strip(last,'l','0')\n    end\n    if v1 = \"REXX370\" then call mainframe\n    if v1 = \"REXXSAA\" then call PComputer\n    if range  = \"M\" then do;\n       Address \"ISREDIT\"\n       \"delete\" first last\n       var1=first-1; var2=last-first+1;\n       \"line_after\"      var1 \"= noteline \"\"\"time() \"APPEND --\",\n           var2 \"lines removed and placed into \"CUTDSNnn\"\"\"\"\n       \"line_before .zfirst = msgline \"\"\"time() \"APPEND --\",\n           var2 \"lines removed and placed into \"CUTDSNnn\"\"\"\"\n    end\n    /* would be nicer to report the visible line number */\n    if range  = \"C\" then do;\n       Address \"ISREDIT\"\n       \"line_before\" first \"= noteline \"\"\"time() \"start APPEND --\",\n           copied \"lines\" \"copied to \"CUTDSNnn\", lines(\"||,\n           strip(first,\"l\",\"0\")\"-\"strip(last,\"l\",\"0\")\")\"\"\"\n       \"line_after\" last  \"= noteline \"\"\"time() \"-end- APPEND --\",\n           copied \"lines\" \"copied to \"CUTDSNnn\", lines(\"||,\n           strip(first,\"l\",\"0\")\"-\"strip(last,\"l\",\"0\")\")\"\"\"\n       \"line_before .zfirst    =  msgline \"\"\"time() \" APPEND --\" copied,\n           \"lines\" \"copied to \"CUTDSNnn\", lines(\"||,\n           strip(first,\"l\",\"0\")\"-\"strip(last,\"l\",\"0\")\")\"\"\"\n    end\n  return  0\n  mainframe: procedure expose q.  qcnt CUTDSN autoedit editopt other,\n           CUTDSNnn;\n    userid = SYSVAR('SYSUID')\n    userid = strip(sysvar('sysuid'))\n    prefix = strip(sysvar(syspref)); if prefix='' then prefix=userid\n    CUTDSN = \"'\"prefix\".CUTDSN\"||other||\".list'\"\n      /* i.e.   userid.CUTDSN.LIST */\n    test = SYSDSN(CUTDSN)\n    status = msg('off')\n    if test = \"OK\" then\n       Address \"TSO\" \"alloc file(CutDsn) da(\"CutDsn\") mod\"\n    status = msg('on')\n    if test \\= \"OK\" then do\n    Address \"TSO\" ,\n     'ALLOC FI(CUTDSN) NEW CAT SPACE(45 45) TRACKS UNIT(SYSDA)' ,\n       'LRECL(255) RECFM(V B M) BLKSIZE(3156)' ,\n       \"DSN(\"CUTDSN\") REUSE\"\n       ZEDSMSG = ZERRSM\n       ZEDLMSG = ZERRMSG ZERRLM\n       if zedsmsg = \"\" then do; zedlmsg = \"APPEND has acted\",\n            \"like CUT to create the PASTE dataset\" zedsmsg \"CUT\"\n          zedsmsg=\"CUT\"\n          say cutdsn \"APPEND has acted like CUT to create the\",\n              \"PASTE dataset on your behalf, within APPEND\"\n       end;\n       Address \"ISPEXEC\"\n       \"SETMSG MSG(ISRZ000)\"\n    end\n    status = msg('off')\n    Address \"TSO\" \"execio * diskw CutDsn (stem q. finis\"\n    Address \"TSO\" \"free file(CutDsn)\"\n    if editopt = 1 then Address \"TSO\" \"$edit\" CutDsn\n    return\n  PComputer: procedure expose q.  qcnt nxopt editopt;\n    /* macros named cutR, appendR, pasteR */\n    CUTDSN = \"c:\\junk\\\"CUTDSNnn\".dat\"\n    do i=1 to qcnt; call lineout CUTDSN, q.i;end;\n    call lineout CUTDSN    /* close file*/\n    if editopt = 1 then Address \"cmd\" \"spf2\" CutDsn\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BIGS": {"ttr": 4361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x04\\xdf\\x04\\xdf\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 1247, "newlines": 1247, "modlines": 0, "user": "MCRITCH"}, "text": " ADDRESS \"ISREDIT\";\"MACRO (BETWEEN SLANT VERT LETTERX)\"  /*REXX*/\n/*********************************************************************/\n/*  OBTAINED FROM CBT TAPE 95  TAPE #9102    BIG AND BIGS (COMBINED) */\n/*  RELATED CLIST  BLOCK5 WAS CREATED LATER FROM BIGS                */\n/*********************************************************************/\n/*  EXTENSIVELY MODIFIED BY D.MCRITCHIE, \"THE REXX MACROS TOOLBOX\" 1991/04/29 */\n/*  NOT COMPATIBLE WITH THE ORIGINAL  HAS BEEN CHANGED TO HANDLE     */\n/*  1. MULTIPLE LETTERS                                              */\n/*  2. PROVIDE A VARIETY OF SLANTS, TILTS,                           */\n/*  3. PROVIDE ADDITIONAL CHARACTERS BEYOND A-Z, 0-9                 */\n/*  4. ADDS LINES AS NEEDED -- ADDING COLUMNS IS YOUR PROBLEM        */\n/*  5. THE FIRST CHARACTER OF THE GROUP WILL BE PLACED AT THE CURSOR */\n/*     LOCATION SUCH THAT IT ALIGNS VERTICALLY ON THE TOPMOST        */\n/*     POSITION OF THE LETTER AND HORIZONTALLY ON THE LEFTMOST       */\n/*     POSITION OF THE LETTER WHETHER VISIBLE OR NOT.  FOR TESTING   */\n/*     AN M WILL OCCUPY LEFT MOST, RIGHT MOST, TOP MOST, AND BOTTOM  */\n/*     A \"B\" IS BETTER FOR MOST TESTING PURPOSES, BUT THE \"M\" IS     */\n/*     WIDER.                                                        */\n/*  6. VISIBLE LABELS, NOTABLY                                       */\n/*       .SSS   STARTING POSITION, OR .ERRSS IF ERROR FOUND          */\n/*       .NCUR  NEXT PRESUMED STARTING POINT FOR CURSOR PLACEMENT    */\n/*  EXAMPLE:  ENTER AFTER PLACING CURSOR ON 1ST POS OF 1ST LINE.     */\n/*     ===> BIGS 4 0 0 BLOCK; BIGS 2 0 0 LETTERS                     */\n/*     ===> BIGS 4 1 0 TILT; BIGS 4 1 1 SKEW                         */\n/*  MOST LETTERS  ARE NO LONGER THAN 12 CHARACTERS WIDE; HOWEVER,    */\n/*    THE CHARACTER M IS ACTUALLY 13 CHARACTERS WIDE; WHICH IS THE   */\n/*    DIFFERENCE BETWEEN LEFT SIDES, SO MM WILL SHOW WITH NO SPACE   */\n/*    BETWEEN CHARACTERS -- THIS IS NOT A FAULT, YOU ARE EXPECTED TO */\n/*    USE A 4 AS THE 1ST PARAMETER, FOR PRETTIEST RESULTS.           */\n/*           IF &STR(&LETTER) = ? THEN +                             */\n/*                THIS PANEL I THINK WOULD BE MEANINGLESS TO OUR USE */\n/*             DO                                                    */\n/*               ISPEXEC DISPLAY PANEL(BIGS)                         */\n/*               EXIT CODE(1)                                        */\n/*             END                                                   */\n/*                                                                   */\n/*********************************************************************/\n\n/*********************************************************************/\n/*  BIGS 1 0 0 BL   -- CURSOR PLACED AT POSITION + UPPER LEFT OF B   */\n/*  BIGS 1 -1 0 OC  -- CURSOR PLACED AT POSITION _ UPPER LEFT OF O   */\n/*  BIGS 1 0 0 K    -- CURSOR PLACED AT POSITION * UPPER LEFT OF K   */\n/*  BIGS 1 -1 0 OC  -- CURSOR PLACED AT POSITION _ UPPER LEFT OF O   */\n/*  CLISTBOX        -- LINE COMMAND  CC CC TO INDICATE LIMITS        */\n/*********************************************************************/\n\n/*********************************************************************/\n/*                                                                   */\n/* +BBBBBBBBBB   LL    _OOOOOOOOOOO   CCCCCCCCCC    *K         KK    */\n/* BBBBBBBBBBBB  LL     OOOOOOOOOOOO  CCCCCCCCCCCC  KK        KK     */\n/* BB        BB  LL      OO        OO  CC        CC KK       KK      */\n/* BB        BB  LL       OO        OO  CC          KK      KK       */\n/* BB       BB   LL        OO        OO  CC         KK     KK        */\n/* BBBBBBBBBB    LL         OO        OO  CC        KKKKKKK          */\n/* BBBBBBBBBB    LL          OO        OO  CC       KKKKKKK          */\n/* BB       BB   LL           OO        OO  CC      KK     KK        */\n/* BB        BB  LL            OO        OO  CC     KK      KK       */\n/* BB        BB  LL             OO        OO  CC        CC   KK      */\n/* BBBBBBBBBBBB  LLLLLLLLLLLL    OOOOOOOOOOOO  CCCCCCCCCCCC   KK     */\n/* BBBBBBBBBBB   LLLLLLLLLLLL     OOOOOOOOOOOO   CCCCCCCCCC    KK    */\n/*                                                                   */\n/*********************************************************************/\n/* EXCEPT FOR THE CHARACTERS THEMSELVES BIGS AND BLOCK5 ARE ALMOST  */\n/* THE SAME.  DIFFERENCE IN MACRO NAME, OF COURSE, AND ROW AND COL. */\n/*********************************************************************/\n\n  IF BETWEEN = DEBUG THEN DO\n     BETWEEN = 4\n  END\n         \"(LNUM2) = LINENUM .NCUR\"\n  IF RC <> 0 THEN DO\n     MAXCC = 0\n     NOTES = 1\n  END\n\n/*********************************************************************/\n/*  FIX UP FOR LAZY ENTRY -- ONLY GOOD IF CONTAINS LETTERS           */\n/*********************************************************************/\n  IF VERT = '' /* | DATATYPE(BETWEEN,\"CHAR\") = 1 */ THEN DO\n            \"LINE_AFTER  .ZCSR = NOTELINE \"\"GUESSING YOU WANTED --\",\n                \"BIGS 2 0 0\" BETWEEN \"\"\"\"\n     LETTERX = BETWEEN\n     BETWEEN = 2         /*BIGS-- 2 / 1 --BLOCK5*/\n     SLANT = 0\n     VERT      = 0\n  END\n\n/*********************************************************************/\n/*  ALLOW USE OF AN EMPTY MEMBER IN EDIT WITH UNPLACED CURSOR        */\n/*********************************************************************/\n         \"(ROW) = LINENUM .ZLAST\"\n  IF ROW = 0 THEN DO\n            \"LINE_AFTER 0 = DATALINE \"\" \"\"\"\n            \"CURSOR = 1 1\"\n  END\n\n/*********************************************************************/\n/*        MAKE SURE ENOUGH SPACE EXISTS ABOVE STARTING POSITION      */\n/*        MAY CAUSE STARTING POINT (.SSSS) TO SHIFT DOWNWARD         */\n/*********************************************************************/\n         \"(ROW,COL)  = CURSOR\"\n        IF  COL  = 0 THEN        \"CURSOR = ,1\"\n         \"RESET\" VALUE(ROW - 1) ROW\n  LM1 = LENGTH(LETTERX) - 1\n  IF VERT < 0 THEN DO\n     NEEDUP = -LM1  *  VERT   + 1\n     DO WHILE  NEEDUP  >  ROW\n               \"LINE_BEFORE &ROW = DATALINE \"\" \"\"\"\n        ROW =  ROW  + 1\n               \"CURSOR =\" ROW   COL\n     END\n  END\n         \"LABEL\" ROW \"= .SSSS 0\"\n/*********************************************************************/\n/*        MAKE SURE ENOUGH SPACE EXISTS BELOW STARTING POSITION      */\n/*        4 EXTRA LINES BELOW NEXT EXPECTED STARTED POINT ALSO ADDED */\n/*********************************************************************/\n         \"(LROW) = LINENUM .ZLAST\"\n   NEEDDN = 18     +  ROW  /* ABOUT 4 LINES AFTER .NCUR*/\n   IF  VERT   > 0 THEN NEEDDN =  LM1  *  VERT   + NEEDDN\n   DO WHILE  NEEDDN  >  LROW\n             \"LINE_AFTER .ZLAST = \"\" \"\"\"\n      LROW =  LROW + 1\n   END\n\n/*********************************************************************/\n/*  MSG1 AND MAKE SPECIAL TESTING ALLOWANCES IF MEMBER IS       Z    */\n/*********************************************************************/\n\n  MSG1 = \"ROW=\"ROW\",COL=\"COL \"--\",\n     \"AT START  -- BIGS\" BETWEEN\",\"SLANT\",\"VERT\",\"LETTERX\n         \"LINE_BEFORE .ZCSR = MSGLINE (MSG1)\"\n\n         \"(MEMBERX) = MEMBER\"\n  TMASK = TMASK\n  IF Z <> MEMBERX THEN TMASK = \"\"\n  IF TMASK = \"TMASK\" THEN DO\n            \"LINE &EVAL(&ROW.) = LINE\", < 60 (MSG1)>\n            \"LINE\" ROW       \" = LINE + <\" COL \"'_'>\"\n  END\n\n  MAXCC = 0\n\n/*********************************************************************/\n/*   STARTING ON LETTER -- LOOPS BACK BELOW IF MORE THAN ONE LETTER  */\n/*********************************************************************/\n\n  ROWN =      ROW + 14\n  COLN = COL\n  IF SLANT < 0 THEN COL = -SLANT * 5 + COLN\n  ROWX =  ROW\n  COLX = COL\n\n  MORE:\n   ROW = ROWX\n   COL = COLX\n   LETTER = SUBSTR(LETTERX,1,1)\n   IF LETTERX = \"\"  THEN SIGNAL PROCESS\n   LETTERX = SUBSTR(LETTERX,2)\n   ROWX =  ROWX + VERT\n   COLX = COLX + 13 + BETWEEN       /* + &SPL.*/\n\n   /* ATTEMPT TO ADJUST SPACING  */\n   IF  LETTER = \"\" THEN SIGNAL MORE\n\n   ROW0  = ROW + 00\n   ROW1  = ROW + 01\n   ROW2  = ROW + 02\n   ROW3  = ROW + 03\n   ROW4  = ROW + 04\n   ROW5  = ROW + 05\n   ROW6  = ROW + 06\n   ROW7  = ROW + 07\n   ROW8  = ROW + 08\n   ROW9  = ROW + 09\n   ROW10 = ROW + 10\n   ROW11 = ROW + 11\n\n   COL0  = 11 * SLANT  + COL\n   COL1  = 10 * SLANT  + COL\n   COL2  = 09 * SLANT  + COL\n   COL3  = 08 * SLANT  + COL\n   COL4  = 07 * SLANT  + COL\n   COL5  = 06 * SLANT  + COL\n   COL6  = 05 * SLANT  + COL\n   COL7  = 04 * SLANT  + COL\n   COL8  = 03 * SLANT  + COL\n   COL9  = 02 * SLANT  + COL\n   COL10 = 01 * SLANT  + COL\n   COL11 = 00 * SLANT  + COL\n\n  /*ISPEXEC CONTROL ERRORS RETURN*/\n  I = POS(LETTER,'ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  IF  I <> 0 THEN INTERPRET \"SIGNAL\" LETTER\n  IF LETTER = 1 THEN SIGNAL N1\n  IF LETTER = 2 THEN SIGNAL N2\n  IF LETTER = 3 THEN SIGNAL N3\n  IF LETTER = 4 THEN SIGNAL N4\n  IF LETTER = 5 THEN SIGNAL N5\n  IF LETTER = 6 THEN SIGNAL N6\n  IF LETTER = 7 THEN SIGNAL N7\n  IF LETTER = 8 THEN SIGNAL N8\n  IF LETTER = 9 THEN SIGNAL N9\n  IF LETTER = 0 THEN SIGNAL N0\n  /* EBCDIC OR ASCII -- EBCDIC ASSIGNMENTS BUT WORKS FOR EITHER*/\n  IF LETTER =     \"\u00a2\"            THEN SIGNAL X4A\n  IF LETTER =     \".\"            THEN SIGNAL X4B\n  IF LETTER =     \"<\"            THEN SIGNAL X4C\n  IF LETTER =     \"(\"            THEN SIGNAL X4D\n  IF LETTER =     \"+\"            THEN SIGNAL X4E\n  IF LETTER =     \"|\"            THEN SIGNAL X4F\n  IF LETTER = \"&\" THEN SIGNAL X50\n  IF LETTER =     \"!\"            THEN SIGNAL X5A\n  IF LETTER =     \"$\"            THEN SIGNAL X5B\n  IF LETTER =     \"*\"            THEN SIGNAL X5C\n  IF LETTER =     \")\"            THEN SIGNAL X5D\n  IF LETTER =     \";\"            THEN SIGNAL X5E\n  IF LETTER =     \"^\"            THEN SIGNAL X5F\n  IF LETTER =     \"-\"            THEN SIGNAL XA0\n  IF LETTER =     \"/\"            THEN SIGNAL X61\n  IF LETTER =     \"\u00f8\"            THEN SIGNAL X6A\n  IF LETTER =     \",\"            THEN SIGNAL X6B\n  IF LETTER =     \"%\"            THEN SIGNAL X6C\n  IF LETTER =     \"_\"            THEN SIGNAL X6D\n  IF LETTER =     \">\"            THEN SIGNAL X6E\n  IF LETTER =     \"?\"            THEN SIGNAL X6F\n  IF LETTER =     \"`\"            THEN SIGNAL X79\n  IF LETTER =     \":\"            THEN SIGNAL X7A\n  IF LETTER =     \"#\"            THEN SIGNAL X7B\n  IF LETTER =     \"@\"            THEN SIGNAL X7C\n  IF LETTER =     \"'\"  THEN SIGNAL X7D  /*'*/\n  IF LETTER =     \"=\"            THEN SIGNAL X7E\n  IF LETTER =     \"\"\"\"           THEN SIGNAL X7F\n  IF LETTER =     \"~\"            THEN SIGNAL XA1\n  IF LETTER =     \":\"            THEN SIGNAL XAE\n  IF LETTER =     \"{\"            THEN SIGNAL XC0\n  IF LETTER =     \"}\"            THEN SIGNAL XD0\n  IF LETTER =     \"\\\"            THEN SIGNAL XE0\n  \"LINE_BEFORE .ZCSR = NOTELINE \"\"CHAR\" LETTER \"N/F, SUBSTITUTING #\"\"\"\n  SIGNAL X7A\n\nA:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  ' AAAAAAAAAA'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'AAAAAAAAAAAA'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'AA        AA'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'AA        AA'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'AA        AA'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  'AAAAAAAAAAAA'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  'AAAAAAAAAAAA'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  'AA        AA'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  'AA        AA'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'AA        AA'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'AA        AA'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" 'AA        AA'>\"\nSIGNAL PROCESS\nB:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  'BBBBBBBBBBB'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'BBBBBBBBBBBB'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'BB        BB'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'BB        BB'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'BB       BB'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  'BBBBBBBBBB'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  'BBBBBBBBBB'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  'BB       BB'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  'BB        BB'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'BB        BB'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'BBBBBBBBBBBB'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" 'BBBBBBBBBBB'>\"\nSIGNAL PROCESS\nC:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  ' CCCCCCCCCC'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'CCCCCCCCCCCC'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'CC        CC'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'CC'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'CC'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  'CC'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  'CC'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  'CC'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  'CC'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'CC        CC'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'CCCCCCCCCCCC'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" ' CCCCCCCCCC'>\"\nSIGNAL PROCESS\nD:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  'DDDDDDDDD'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'DDDDDDDDDD'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'DD       DD'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'DD        DD'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'DD        DD'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  'DD        DD'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  'DD        DD'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  'DD        DD'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  'DD        DD'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'DD       DD'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'DDDDDDDDDD'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" 'DDDDDDDDD'>\"\nSIGNAL PROCESS\nE:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  'EEEEEEEEEEEE'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'EEEEEEEEEEEE'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'EE'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'EE'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'EE'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  'EEEEEEEE'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  'EEEEEEEE'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  'EE'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  'EE'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'EE'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'EEEEEEEEEEEE'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" 'EEEEEEEEEEEE'>\"\nSIGNAL PROCESS\nF:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  'FFFFFFFFFFFF'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'FFFFFFFFFFFF'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'FF'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'FF'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'FF'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  'FFFFFFFF'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  'FFFFFFFF'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  'FF'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  'FF'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'FF'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'FF'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" 'FF'>\"\nSIGNAL PROCESS\nG:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  ' GGGGGGGGGG'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'GGGGGGGGGGGG'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'GG        GG'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'GG'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'GG'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  'GG'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  'GG     GGGGG'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  'GG     GGGGG'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  'GG        GG'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'GG        GG'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'GGGGGGGGGGGG'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" ' GGGGGGGGGG'>\"\nSIGNAL PROCESS\nH:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  'HH        HH'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'HH        HH'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'HH        HH'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'HH        HH'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'HH        HH'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  'HHHHHHHHHHHH'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  'HHHHHHHHHHHH'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  'HH        HH'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  'HH        HH'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'HH        HH'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'HH        HH'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" 'HH        HH'>\"\nSIGNAL PROCESS\nI:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  ' IIIIIIIIII'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  ' IIIIIIIIII'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '     II'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '     II'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '     II'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '     II'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '     II'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '     II'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '     II'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '     II'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" ' IIIIIIIIII'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" ' IIIIIIIIII'>\"\nSIGNAL PROCESS\nJ:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '  JJJJJJJJJJ'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '  JJJJJJJJJJ'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '      JJ'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '      JJ'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '      JJ'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '      JJ'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '      JJ'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '      JJ'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  'JJ    JJ'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'JJ    JJ'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'JJJJJJJJ'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" ' JJJJJJ'>\"\nSIGNAL PROCESS\nK:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  'KK         KK'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'KK        KK'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'KK       KK'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'KK      KK'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'KK     KK'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  'KKKKKKK'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  'KKKKKKK'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  'KK     KK'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  'KK      KK'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'KK       KK'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'KK        KK'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" 'KK         KK'>\"\nSIGNAL PROCESS\nL:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  'LL'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'LL'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'LL'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'LL'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'LL'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  'LL'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  'LL'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  'LL'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  'LL'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'LL'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'LLLLLLLLLLLL'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" 'LLLLLLLLLLLL'>\"\nSIGNAL PROCESS\nM:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  'MM         MM'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'MMM       MMM'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'MMMM     MMMM'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'MM  MM  MM MM'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'MM   MMMM  MM'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  'MM    MM   MM'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  'MM         MM'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  'MM         MM'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  'MM         MM'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'MM         MM'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'MM         MM'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" 'MM         MM'>\"\nSIGNAL PROCESS\nN:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  'NN        NN'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'NNN       NN'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'NNNN      NN'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'NN NN     NN'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'NN  NN    NN'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  'NN   NN   NN'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  'NN    NN  NN'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  'NN     NN NN'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  'NN      NNNN'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'NN       NNN'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'NN        NN'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" 'NN         N'>\"\nSIGNAL PROCESS\nO:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  'OOOOOOOOOOOO'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'OOOOOOOOOOOO'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'OO        OO'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'OO        OO'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'OO        OO'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  'OO        OO'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  'OO        OO'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  'OO        OO'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  'OO        OO'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'OO        OO'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'OOOOOOOOOOOO'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" 'OOOOOOOOOOOO'>\"\nSIGNAL PROCESS\nP:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  'PPPPPPPPPPP'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'PPPPPPPPPPPP'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'PP        PP'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'PP        PP'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'PP        PP'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  'PPPPPPPPPPPP'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  'PPPPPPPPPPP'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  'PP'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  'PP'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'PP'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'PP'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" 'PP'>\"\nSIGNAL PROCESS\nQ:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  ' QQQQQQQQQQ'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'QQQQQQQQQQQQ'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'QQ        QQ'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'QQ        QQ'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'QQ        QQ'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  'QQ        QQ'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  'QQ        QQ'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  'QQ    QQ  QQ'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  'QQ     QQ QQ'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'QQ      QQQQ'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'QQQQQQQQQQQ'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" ' QQQQQQQQ QQ'>\"\nSIGNAL PROCESS\nR:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  'RRRRRRRRRRR'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'RRRRRRRRRRRR'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'RR        RR'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'RR        RR'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'RR        RR'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  'RRRRRRRRRRRR'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  'RRRRRRRRRRR'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  'RR    RR'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  'RR     RR'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'RR      RR'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'RR       RR'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" 'RR        RR'>\"\nSIGNAL PROCESS\nS:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  ' SSSSSSSSSS'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'SSSSSSSSSSSS'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'SS        SS'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'SS'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'SSS'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  ' SSSSSSSSS'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '  SSSSSSSSS'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '         SSS'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '          SS'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'SS        SS'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'SSSSSSSSSSSS'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" ' SSSSSSSSSS'>\"\nSIGNAL PROCESS\nT:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  'TTTTTTTTTTTT'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'TTTTTTTTTTTT'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '     TT'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '     TT'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '     TT'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '     TT'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '     TT'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '     TT'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '     TT'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '     TT'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '     TT'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '     TT'>\"\nSIGNAL PROCESS\nU:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  'UU        UU'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'UU        UU'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'UU        UU'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'UU        UU'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'UU        UU'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  'UU        UU'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  'UU        UU'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  'UU        UU'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  'UU        UU'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'UU        UU'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'UUUUUUUUUUUU'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" ' UUUUUUUUUU'>\"\nSIGNAL PROCESS\nV:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  'VV        VV'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'VV        VV'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'VV        VV'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'VV        VV'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'VV        VV'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  'VV        VV'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  'VV        VV'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  ' VV      VV'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '  VV    VV'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '   VV  VV'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '    VVVV'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '     VV'>\"\nSIGNAL PROCESS\nW:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  'WW        WW'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'WW        WW'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  'WW        WW'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  'WW        WW'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  'WW        WW'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  'WW        WW'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  'WW   WW   WW'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  'WW  WWWW  WW'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  'WW WW  WW WW'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  'WWWW    WWWW'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'WWW      WWW'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" 'WW        WW'>\"\nSIGNAL PROCESS\nX:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  'XX        XX'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'XX        XX'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  ' XX      XX'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '  XX    XX'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '   XX  XX'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '    XXXX'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '    XXXX'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '   XX  XX'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '  XX    XX'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  ' XX      XX'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" 'XX        XX'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" 'XX        XX'>\"\nSIGNAL PROCESS\nY:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  'YY         YY'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'YY        YY'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  ' YY      YY'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '  YY    YY'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '   YY  YY'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '    YYYY'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '     YY'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '     YY'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '     YY'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '     YY'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '     YY'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '     YY'>\"\nSIGNAL PROCESS\nZ:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  'ZZZZZZZZZZZZ'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  'ZZZZZZZZZZZZ'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '         ZZ'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '        ZZ'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '       ZZ'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '      ZZ'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '     ZZ'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '    ZZ'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '   ZZ'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '  ZZ'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" ' ZZZZZZZZZZZ'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" 'ZZZZZZZZZZZZ'>\"\nSIGNAL PROCESS\nN1:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '    11'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '    111'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '   1111'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '     11'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '     11'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '     11'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '     11'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '     11'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '     11'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '     11'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" ' 1111111111'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" ' 1111111111'>\"\nSIGNAL PROCESS\nN2:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '2222222222'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '222222222222'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '22        22'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '          22'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '          22'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '        22'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '       22'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '     22'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '   22'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  ' 22'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '222222222222'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '222222222222'>\"\nSIGNAL PROCESS\nN3:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '3333333333'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '333333333333'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '33        33'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '          33'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '          33'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '       3333'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '       3333'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '          33'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '          33'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '33        33'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '333333333333'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" ' 3333333333'>\"\nSIGNAL PROCESS\nN4:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '     444'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '     4444'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '    44 44'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '   44  44'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '  44   44'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  ' 44444444444'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '444444444444'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '       44'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '       44'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '       44'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '       44'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '       44'>\"\nSIGNAL PROCESS\nN5:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '555555555555'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '555555555555'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '55'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '55'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '55'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '555555555'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '5555555555'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '         55'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '          55'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '          55'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '555555555555'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" ' 5555555555'>\"\nSIGNAL PROCESS\nN6:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '6666666666'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '666666666666'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '66        66'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '66'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '66'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '66666666666'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '666666666666'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '66        66'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '66        66'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '66        66'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '666666666666'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" ' 6666666666'>\"\nSIGNAL PROCESS\nN7:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '777777777777'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '77777777777'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '77      77'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '       77'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '      77'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '     77'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '     77'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '     77'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '     77'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '     77'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '     77'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '     77'>\"\nSIGNAL PROCESS\nN8:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '8888888888'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '888888888888'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '88        88'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '88        88'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  ' 88      88'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '  88888888'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '  88888888'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  ' 88      88'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '88        88'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '88        88'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '888888888888'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" ' 8888888888'>\"\nSIGNAL PROCESS\nN9:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '9999999999'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '999999999999'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '99        99'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '99        99'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '99        99'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '999999999999'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '999999999999'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '          99'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '          99'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '99        99'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '999999999999'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" ' 9999999999'>\"\nSIGNAL PROCESS\nN0:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '  00000000'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  ' 0000000000'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '00        00'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '00        00'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '00        00'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '00        00'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '00        00'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '00        00'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '00        00'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '00        00'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" ' 0000000000'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '  00000000'>\"\nSIGNAL PROCESS\nXA0:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '            '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '            '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '            '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '            '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '            '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '  --------  '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '  --------  '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '            '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '            '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '            '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '            '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '            '>\"\nSIGNAL PROCESS\nXA1:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '  ~~~       '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '~~   ~~   ~~'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '       ~~~  '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '            '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '            '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '            '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '            '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '            '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '            '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '            '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '            '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '            '>\"\nSIGNAL PROCESS\nXC0:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '      {{    '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '    {{      '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '   {{       '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '   {{       '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '  {{        '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '{{          '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '{{          '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '  {{        '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '   {{       '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '   {{       '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '    {{      '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '      {{    '>\"\nSIGNAL PROCESS\nXD0:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '    }}      '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '      }}    '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '       }}   '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '       }}   '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '        }}  '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '          }}'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '          }}'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '        }}  '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '       }}   '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '       }}   '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '      }}    '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '    }}      '>\"\nSIGNAL PROCESS\nXE0:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '\\           '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '\\\\          '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  ' \\\\         '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '  \\\\        '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '   \\\\       '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '    \\\\      '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '     \\\\     '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '      \\\\    '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '       \\\\   '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '        \\\\  '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '         \\\\ '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '          \\\\'>\"\nSIGNAL PROCESS\nX4A:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '     \u00a2\u00a2     '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '     \u00a2\u00a2     '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '   \u00a2\u00a2\u00a2\u00a2\u00a2\u00a2   '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '  \u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2  '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '\u00a2\u00a2   \u00a2\u00a2   \u00a2\u00a2'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '\u00a2\u00a2   \u00a2\u00a2     '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '\u00a2\u00a2   \u00a2\u00a2     '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '\u00a2\u00a2   \u00a2\u00a2   \u00a2\u00a2'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '  \u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2\u00a2  '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '   \u00a2\u00a2\u00a2\u00a2\u00a2\u00a2   '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '     \u00a2\u00a2     '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '     \u00a2\u00a2     '>\"\nSIGNAL PROCESS\nX4C:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '            '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '            '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '            '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '        <<  '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '      <<    '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '    <<      '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '  <<        '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '    <<      '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '      <<    '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '        <<  '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '            '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '            '>\"\nSIGNAL PROCESS\nX4D:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '     ((     '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '    ((      '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '   ((       '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '   ((       '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '  ((        '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '  ((        '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '  ((        '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '  ((        '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '   ((       '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '   ((       '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '    ((      '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '     ((     '>\"\nSIGNAL PROCESS\nX4E:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '            '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '            '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '            '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '     ++     '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '     ++     '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '  ++++++++  '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '  ++++++++  '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '     ++     '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '     ++     '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '            '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '            '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '            '>\"\nSIGNAL PROCESS\nX4F:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '     ||     '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '     ||     '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '     ||     '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '     ||     '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '     ||     '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '     ||     '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '     ||     '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '     ||     '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '     ||     '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '     ||     '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '     ||     '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '     ||     '>\"\nSIGNAL PROCESS\nX5A:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '     !!     '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '     !!     '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '     !!     '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '     !!     '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '     !!     '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '     !!     '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '     !!     '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '     !!     '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '     !!     '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '            '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '     !!     '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '     !!     '>\"\nSIGNAL PROCESS\nX5B:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '   $$  $$   '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  ' $$$$$$$$$$ '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '$$ $$  $$ $$'>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '$$ $$  $$  $'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '$$ $$  $$   '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  ' $$$$$$$$$  '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '  $$$$$$$$$ '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '   $$  $$ $$'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '$  $$  $$ $$'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '$$ $$  $$ $$'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" ' $$$$$$$$$$ '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '   $$  $$   '>\"\nSIGNAL PROCESS\nX5C:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '            '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '            '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '            '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '     **     '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '  ** ** **  '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '    ****    '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '    ****    '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '  ** ** **  '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '     **     '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '            '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '            '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '            '>\"\nSIGNAL PROCESS\nX5D:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '     ))     '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '      ))    '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '       ))   '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '       ))   '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '        ))  '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '        ))  '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '        ))  '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '        ))  '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '       ))   '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '       ))   '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '      ))    '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '     ))     '>\"\nSIGNAL PROCESS\nX5E:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '            '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '            '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '            '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '            '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '    ;;;     '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '    ;;;     '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '            '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '            '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '            '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '    ;;;     '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '    ;;;     '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '     ;;     '>\"\nSIGNAL PROCESS\nX5F:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '            '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '            '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '            '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '            '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '^^^^^^^^^^^^'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '^^^^^^^^^^^^'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '          ^^'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '          ^^'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '            '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '            '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '            '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '            '>\"\nSIGNAL PROCESS\nX50:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '    &&&&&&&&    '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '  &&&&&&&&&&&&&&   '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  ' &&&&     &&&&  '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  ' &&&&         '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '  &&&&        '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '  &&&&&&&&      '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '  &&&&&&&&      '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '  &&&&        '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  ' &&&&    &&&&&&&& '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  ' &&&&     &&&&  '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '  &&&&&&&&&&&&&&   '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '    &&&&&&&&    '>\"\nSIGNAL PROCESS\nX6A:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '     \u00f8\u00f8     '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '     \u00f8\u00f8     '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '     \u00f8\u00f8     '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '     \u00f8\u00f8     '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '     \u00f8\u00f8     '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '            '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '            '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '     \u00f8\u00f8     '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '     \u00f8\u00f8     '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '     \u00f8\u00f8     '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '     \u00f8\u00f8     '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '     \u00f8\u00f8     '>\"\nSIGNAL PROCESS\nX6B:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '            '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '            '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '            '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '            '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '            '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '            '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '            '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '            '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '            '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '    ,,,     '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '    ,,,     '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '     ,,     '>\"\nSIGNAL PROCESS\nX6C:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  ' %%%       %'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '%   %     %%'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '%   %    %% '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  ' %%%    %%  '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '       %%   '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '      %%    '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '     %%     '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '    %%      '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '   %%   %%% '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '  %%   %   %'>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" ' %%    %   %'>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '%%      %%% '>\"\nSIGNAL PROCESS\nX6D:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '            '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '            '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '            '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '            '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '            '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '            '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '            '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '            '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '            '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '            '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '            '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '____________'>\"\nSIGNAL PROCESS\nX6E:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '            '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '            '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '            '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '  >>        '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '    >>      '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '      >>    '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '        >>  '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '      >>    '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '    >>      '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '  >>        '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '            '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '            '>\"\nSIGNAL PROCESS\nX6F:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '    ????    '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '  ????????  '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  ' ???    ??? '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  ' ??      ?? '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '        ??  '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '       ??   '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '      ??    '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '     ??     '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '     ??     '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '            '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '     ??     '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '     ??     '>\"\nSIGNAL PROCESS\nX61:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '           /'>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '          //'>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '         // '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '        //  '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '       //   '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '      //    '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '     //     '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '    //      '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '   //       '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '  //        '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" ' //         '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '//          '>\"\nSIGNAL PROCESS\nX7A:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '            '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '            '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '            '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '            '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '    :::     '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '    :::     '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '            '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '            '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '            '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '    :::     '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '    :::     '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '            '>\"\nSIGNAL PROCESS\nX7B:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '            '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '  ##    ##  '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '  ##    ##  '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '############'>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '############'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '  ##    ##  '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '  ##    ##  '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '############'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '############'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '  ##    ##  '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '  ##    ##  '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '            '>\"\nSIGNAL PROCESS\nX7C:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '            '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '   @@@@@@   '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '  @      @  '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  ' @  @@@@  @ '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '@  @@@@@@  @'>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '@ @@    @@ @'>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '@ @@    @@ @'>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '@  @@@@@@@ @'>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  ' @  @@@@@@@@'>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '  @         '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '   @@@@@@@@ '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '            '>\"\nSIGNAL PROCESS\nX7D:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  \"     ''     \">\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  \"     ''     \">\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  \"     ''     \">\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  \"            \">\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  \"            \">\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  \"            \">\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  \"            \">\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  \"            \">\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  \"            \">\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  \"            \">\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" \"            \">\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" \"            \">\"\nSIGNAL PROCESS\nX7E:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '            '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '            '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '            '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '            '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  ' ========== '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  ' ========== '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '            '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  ' ========== '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  ' ========== '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '            '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '            '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '            '>\"\nSIGNAL PROCESS\nX7F:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '   \"\"  \"\"   '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '   \"\"  \"\"   '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '   \"\"  \"\"   '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '            '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '            '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '            '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '            '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '            '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '            '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '            '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '            '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '            '>\"\nSIGNAL PROCESS\nX4B:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '            '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '            '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '            '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '            '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '            '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '            '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '            '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '            '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '            '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '            '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '    ...     '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '    ...     '>\"\nSIGNAL PROCESS\nX79:\n       \"LINE\" ROW0 \" = LINE + <\" COL0 \"  '   ``       '>\"\n       \"LINE\" ROW1 \" = LINE + <\" COL1 \"  '     ``     '>\"\n       \"LINE\" ROW2 \" = LINE + <\" COL2 \"  '       ``   '>\"\n       \"LINE\" ROW3 \" = LINE + <\" COL3 \"  '            '>\"\n       \"LINE\" ROW4 \" = LINE + <\" COL4 \"  '            '>\"\n       \"LINE\" ROW5 \" = LINE + <\" COL5 \"  '            '>\"\n       \"LINE\" ROW6  \"= LINE + <\" COL6 \"  '            '>\"\n       \"LINE\" ROW7  \"= LINE + <\" COL7 \"  '            '>\"\n       \"LINE\" ROW8  \"= LINE + <\" COL8 \"  '            '>\"\n       \"LINE\" ROW9  \"= LINE + <\" COL9 \"  '            '>\"\n       \"LINE\" ROW10  \"= LINE + <\" COL10\" '            '>\"\n       \"LINE\" ROW11  \"= LINE + <\" COL11\" '            '>\"\n SIGNAL PROCESS\n\n/*********************************************************************/\n/*   P R O C E S S :    SETTING UP FOR THE NEXT LETTER IF ANY        */\n/*********************************************************************/\nPROCESS:\n    IF  MAXCC  > 0 THEN DO\n       ZEDSMSG = \"INCOMPLETE BOX\"\n       ZEDLMSG = \"NOT ENOUGH LINES/COLUMNS\",\n          \"TO DRAW COMPLETE BOX MAX=\"MAXCC\n       ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ001)\"\n              \"(ERRSS) = LINENUM .ERRSS\"\n       IF  ERRSS  <> 0 THEN        \"LABEL .SSS = .ERRSS 0\"\n    END\n\n    ROW =      ROW +  VERT\n\n/*********************************************************************/\n/*  ADJUSTING THE END PLACEMENT OF THE CURSOR, NOT A VERY PRECISE    */\n/*  MECHANISM BUT IT SHOULD WORK WELL TO KEEP LINES REASONABLY       */\n/*  SPREAD APART WITH THE SAME FEATURES.                             */\n/*********************************************************************/\n\n  IF     LETTERX     ^= \"\"     THEN SIGNAL MORE\n\n  IF VERT < 0 THEN AVERT = -   VERT\n  IF SLANT > 0 THEN DO\n     IF  VERT   > 0 THEN ROWN = ROWN +    VERT\n     IF  VERT   < 0 THEN ROWN = ROWN -    VERT\n  END\n  IF SLANT < 0 THEN DO\n     IF  VERT   > 0 THEN ROWN = ROWN +    VERT\n     IF  VERT   < 0 THEN ROWN = ROWN -    VERT\n  END\n\n   IF 1 = NOTES THEN DO\n       \"LINE_BEFORE .ZFIRST = NOTELINE \"\"\"||,\n           \"------ SAMPLE USAGE OF -- BIGS -- CLIST\"\"\"\n       \"LINE_BEFORE .ZFIRST = NOTELINE \"\"\"||,\n           \"CURSOR MUST BE PLACED ON A LINE, UNLESS MEMBER IS EMPTY\"\"\"\n       \"LINE_BEFORE .ZFIRST = NOTELINE \"\"BIGS <SPACE BETWEEN\",\n           \"CHAR|1|4> <SLANT|0> <VERT|0> LETTERS\"\"\"\n        \"LINE_BEFORE .ZFIRST = NOTELINE \"\" E.G. BIGS 1 0 0 HELLO\"\"\"\n        \"LINE_BEFORE .ZFIRST = NOTELINE \"\"\"||,\n           \"    E.G.  BIGS 1 1 1 DEMO\"\"\"\n        \"LINE_BEFORE .ZFIRST = NOTELINE \"\"\"||,\n           \"    E.G.  BIGS 1 -1 1 A B C\"\"\"\n  END\n         \"LABEL\" ROWN \"= .NCUR 0\"\n         \"LOC\" ROWN\n         \"UP 18\"\n         ROWN=ROWN+0;COLN=COLN+0\n         \"CURSOR =\" ROWN COLN\n  /********************** END OF 1991/04/29 ADDITIONS */\n  EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BOOKREAD": {"ttr": 4871, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00o\\x00o\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 111, "newlines": 111, "modlines": 0, "user": "MCRITCH"}, "text": "          /* SYS1.TSOCLIST(BOOKREAD)                              *     /\n\n          PROC 0 HELP\n          IF &LIST = LIST THEN CONTROL MAIN MSG LIST CONLIST SYMLIST\n                          ELSE CONTROL MAIN NOMSG\n          IF HELP = &HELP. THEN DO\n             SET TECHX = &SUBSTR(1:4,&SYSPROC.XXXX)\n             $BROWSE IBMBK.IS03.BOOKLIST\n             IF &LASTCC ^= 0 THEN DO\n                CLS\n                WRITE ======= HELP FILE MISSING BUT CAN BE RECREATED +\n                     =============================\n                WRITE THE DATASET IBMBK.IS03.BOOKLIST WHICH CONTAINS +\n                      THE NAMES AND DESCRIPTIONS\n                WRITE OF ALL BOOKREAD FILES IS MISSING.  IT CAN BE +\n                      RECREATED WITH THE CLIST\n                WRITE FOUND IN IS03.LIBR.CLIST(BK000).\n                WRITE\n                WRITE ADDITIONAL DOCUMENTATION CAN BE FOUND +\n                      IN IS03.SHARE.TEXT(BOOKR001)\n                WRITE ===============================================+\n                     =============================\n             END\n             EXIT CODE(1)\n          END\n          WRITE FOR LIST A OF BOOKS USE COMMAND ===> TSO BOOKREAD HELP\n          WRITE  &SYSLC(WAIT FOR THREE ASTERISKS TO APPEAR AND THEN HIT ENTER)\n\n          SET &EXECFLAG = OFF\n          SET &STEP = 999\n          SET &RC   = &STEP\n          IF &SYSISPF. ^= ACTIVE THEN GOTO ERROR\n\n          SET &ISPPLIB  = SYS1.SEOYPENU                /* PANEL LIBRARY */\n          SET &ISPMLIB  = SYS1.SEOYMENU                /* MSG   LIBRARY */\n          SET &ISPTLIB  = SYS1.SEOYTENU                /* TLIB  LIBRARY */\n          SET &EXEC     = SYS1.SEOYCLIB                /* EXEC  LIBRARY */\n\n          SET &STEP = 100\n          EXECUTIL SEARCHDD(YES)\n          ALTLIB ACTIVATE APPLICATION(EXEC) DATASET('&EXEC')\n          SET &RC=&LASTCC\n          IF &RC^=0 THEN GOTO ERROR\n                    ELSE SET &EXECFLAG = ON\n\n          SET &STEP = 110\n          ISPEXEC CONTROL ERRORS RETURN\n          ISPEXEC LIBDEF ISPPLIB DATASET ID('&ISPPLIB')\n          SET &RC=&LASTCC\n          ISPEXEC CONTROL ERRORS CANCEL\n          IF &RC^=0 THEN GOTO ERROR\n\n          SET &STEP = 120\n          ISPEXEC CONTROL ERRORS RETURN\n          ISPEXEC LIBDEF ISPMLIB DATASET ID('&ISPMLIB')\n          SET &RC=&LASTCC\n          ISPEXEC CONTROL ERRORS CANCEL\n          IF &RC^=0 THEN GOTO ERROR\n\n          SET &STEP = 140\n          ISPEXEC CONTROL ERRORS RETURN\n          ISPEXEC LIBDEF ISPTLIB DATASET ID('&ISPTLIB')\n          SET &RC=&LASTCC\n          ISPEXEC CONTROL ERRORS CANCEL\n          IF &RC^=0 THEN GOTO ERROR\n\n\n          ISPEXEC SELECT CMD(%EOXVSTRT) MODE(FSCR) SUSPEND NEWAPPL(EOXR) NOCHECK\n\n          /* COMMON EXIT  POINT\n\n          EXIT: SET &NOP=NOP\n\n          IF &EXECFLAG = ON +\n          THEN DO\n            SET &STEP = 160\n            ALTLIB DEACTIVATE APPLICATION(EXEC)\n            SET &RC=&LASTCC\n            IF &RC^=0 THEN GOTO ERROR\n          END\n\n          EXIT\n\n          /*\n          /* COMMON ERROR POINT\n          /*\n          ERROR: SET &NOP=NOP\n          WRITE *******************************************************\n          WRITE ***\n          WRITE *** BOOK(&STEP.E): BOOKMANAGER STARTUP ERROR\n          WRITE ***                  RC=&RC\n          WRITE ***\n          WRITE *******************************************************\n          IF &STEP = 160 THEN EXIT\n          ELSE\n            GOTO EXIT\n /*******************************************************************/\n\n/*  --- MODS TO SYS1.SEOYCLIB(EOYBLDBK)                            */\n /*      INCREASED SPACE FOR TEMPFILE IN TEMPALLOC FROM (1,5)       */\n /*        THIS IS THE FILE(...), GENERATED DSNAME TYPICALLY ENDS   */\n /*        WITH SOMETHING LIKE THE FOLLOWING:                       */\n /*         .LIST, .LIST3820, .LIST4250, .LIST4028, .LISTPS         */\n /*      INCREASED SPACE FOR BOOKFILE IN BOOKALLOC FROM (1,5)       */\n /* --------------------------------------------------------------- */\n /* BOOKALLOC = \"RECFM(F,B) LRECL(4096) SPACE(8,15) CYLINDERS \",    */\n /*             \"RELEASE BLKSIZE(4096) DSORG(PS)\"                   */\n /* TEMPALLOC = \"NEW CYLINDERS SPACE(8,15) DSORG(PS) DIR(0)\",       */\n /*             \"RECFM(V,B)\",                                       */\n /*             \"LRECL(8300) BLKSIZE(8304)\"                         */\n /*******************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CBT": {"ttr": 4874, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00J\\x00J\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 74, "newlines": 74, "modlines": 0, "user": "MCRITCH"}, "text": "PROC 1 FILE TO(0) ONLY DOC M() ART\n/* DOCUMENTATION FOR CBT AND NASPA -- IN \"THE REXX MACROS TOOLBOX\" -- SOP #6260*\n/* PROGRAMS, CLISTS, DOCUMENTATION, ETC. FROM PROFESSIONAL PROGRAMMERS*/\n/*\n/* COMPANION CLIST IS  NASPA -- SAME TECHNIQUES USED AS IN CBT */\n/*  --------- EXAMPLES ------------------. */\n/*   ==> TSO CBT DOC\n/*   ==> TSO CBT 50\n/*   ==> TSO CBT 50 M(%OC*)\n/*   ==> TSO CBT 50 TO(55)\n/*  --------- USEFUL TECHNIQUES ---------. */\n/*   ==> TSO CBT DOC\n/*   ==> X ALL;FIND SMF WORD ALL\n/*   ==> APPEND DOC    -- IDENTIFY WITH CC-CC RANGE\n/*   ==> TSO CBT 97    -- OR  TSO CBT 97 M($DOC)\n/*   ==> APPEND DOC    -- IDENTIFY WITH CC-CC RANGE\n/*   ==> $EDIT USERID.CUTDSN.LIST\n/*   ==> @PRINT DOWN8\n/*\nCONTROL NOFLUSH NOMSG\n/* DOCUMENTATION FOR CBT AND NASPA -- IN \"THE REXX MACROS TOOLBOX\" -- SOP #6260*\n/* PROGRAMS, CLISTS, DOCUMENTATION, ETC. FROM PROFESSIONAL PROGRAMMERS*/\nSET LP = &STR((\nSET RP = &STR())\nIF &STR(&M.) ^= &STR() THEN DO\n  SET M = &STR(&M.)\n  SET M = &STR(&LP.&STR(&M.)&RP.)\n   SET MULTIMEM = &SYSINDEX(&STR(*),&STR(&MEMBER.))\n   IF &MULTIMEM = 0 THEN -\n      SET MULTIMEM = &SYSINDEX(&STR(%),&STR(&MEMBER.))\n  SET ONLY = ONLY\nEND\nELSE SET M = &STR()\nIF DOC = &DOC | DOC = &SYSCAPS(&FILE.) THEN DO\n  ISPEXEC EDIT DATASET('TECH.CBT.FILE001.DATA')\n  EXIT CODE(0)\nEND\nIF ART = &ART | ART = &SYSCAPS(&FILE.) THEN DO\n  WRITE ART OPTION APPLIES TO NASPA ONLY, NOT FOR CBT\n  EXIT CODE(4)\n  ISPEXEC EDIT DATASET('TECH.CBT.ARTICLES')\n  EXIT CODE(0)\nEND\nIF &TO. = 0 THEN SET TO = &FILE.\nSET TO = &TO.\nSET FILE = 1000 + &FILE.\nSET MAX = 0\nBACK: -\nSET MAX = &MAX. + 1\nIF &MAX. = 5  THEN DO\n  SET &ZEDSMSG = &STR(CBT &SUBSTR(2:4,&FILE.)\n  SET &ZEDLMSG = &STR(===> TSO &ZEDSMSG   -- TO CONTINUE WHERE LEFT OFF)\n  ISPEXEC     SETMSG MSG(ISRZ000)\n  EXIT CODE(0)\nEND\nSET FILE = &SUBSTR(2:4,&FILE.)\nIF &EVAL(&FILE.) > 900 THEN EXIT CODE(8)\nIF MULTIMEM = 0 +\n   THEN SET DSN = 'TECH.CBT.FILE&FILE..PDS&STR(&M.)'\n   ELSE SET DSN = 'TECH.CBT.FILE&FILE..PDS'\nSET XX = &SYSDSN(&DSN.)\nIF &XX = OK THEN DO\n SET DSN = 'TECH.CBT.FILE&FILE..PDS&STR(&M.)'\n ISPEXEC EDIT DATASET(&DSN.)\nEND\nELSE DO\n   SET XX = &SYSDSN('TECH.CBT.FILE&FILE..DATA')\n   IF &XX = OK THEN ISPEXEC EDIT DATASET('TECH.CBT.FILE&FILE..DATA')\nEND\nIF ONLY = &ONLY THEN EXIT CODE(0)\nIF &EVAL(&TO.) NE 0 THEN -\n  IF &EVAL(&FILE.) GE &EVAL(&TO.) THEN EXIT CODE(0)\nSET FILE = 1001 + &FILE.\nGOTO BACK\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHECKDUP": {"ttr": 4877, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00D\\x00D\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- CHECKDUP */\n/* CHECKDUP: Checks SCRIPT or other material for repeated words*/\n/* author: David McRitchie, \"The REXX Macros Toolbox\" Corp, 1990/09/15 */\n/* contact: David McRitchie,  \"The REXX Macros Toolbox\" */\n/*         \"The REXX Macros Toolbox\"                                */\n/* documentation available: //members.aol.com/rexx01/txt/checkdup.txt */\n/* This clist is universally available with the stipulation that */\n/*  the original author remains credited  */\n/*  and that no charge or licensing fee accrues to any party.  */\n/* This is my second meaningful REXX execute */\n/* TEST WITH DATA IN -- Self testing, or use IS03.LIBR.CLIST(duptest)*/\nAddress \"ISREDIT\"           /* this and that and that and that*/\nxcnt = 0\n\"MACRO\"\n\"LOC 0\"             /* word repeated is the word reset */\n\"reset\"\n\"exclude all\"\nMAXCC = 0\nLASTWORD = '##'       /*self-testing duplicate is ... dodo  dodo  */\ndo  forever\n\"LABEL .zcsr = .aa 0\"\n\"SEEK NEXT PREFIX P'@' \"\nlastrc = rc\nIF lastrc <> 0 THEN do; \"loc 0\";\n    ZEDSMSG = \"duplicates rc=\"||maxcc\n    ZEDLMSG = zedsmsg\n    \"LINE_BEFORE .ZF   =  MSGLINE '\" zedsmsg \"'\"\n    address ISPEXEC 'SETMSG MSG(ISRZ000)'\n    return(maxcc);\nend;\n\"(RECORD) = LINE .ZCSR \"\nRECORD = translate(RECORD,' ','!%^&*()+={}[]:\"~;''`|<>?\u00a2,./') ||' '\nword# = 0\ndo  while(lastrc = 0);      /* second dumb dodo dodo*/\n   \"(LINE#,COL1) = CURSOR\"\n   \"SEEK NEXT ' ' .ZCSR .ZCSR\"\n   lastrc = rc\n   IF lastrc = 0 then do;\n      \"(LINE#,COL2) = CURSOR\"\n      THATWORD = substr(record,col1,(col2 - col1 + 1))\n      THATWORD = word(THATWORD,1)\n      THISWORD = translate(THATWORD)\n      if  thisword =  'END'  ,\n          |   thisword =  'GT'   |   thisword =  'HP'  ,\n          |   thisword =  'RELATED' ,\n          |   thisword =  'SK' ,\n          |   thisword =  'ZCSR'  ,\n      then do;xcnt=xcnt+1;\n         if xcnt = 1 then \"line_before .zf = msgline '\" ,\n            \"words not checked for duplication include -- \" ,\n            \"END, GT, HP, RELATED, SK, ZCSR'\"\n      end;\n      else do;\n         if thisword = lastword then do;\n           \"LINE_BEFORE .ZCSR = noteLINE 'Duplicate word -- \" ,\n                                \"\"\"\"thatword\"\"\"'\"\n           \"reset .ZCSR .zcsr \"\n           if word# = 0 then \"reset .AA .aa \"\n           IF 4 > maxcc then maxcc = 4\n         end;\n      end;\n      LASTWORD = thisword\n      \"SEEK NEXT PREFIX P'@' .ZCSR .ZCSR\"\n      lastrc = rc\n      word# = word# + 1\n   end;\nend;\nend;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHECKSUM": {"ttr": 5121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01\\t\\x01\\t\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 265, "newlines": 265, "modlines": 0, "user": "MCRITCH"}, "text": "/****************************************/\n/* REXX -- CHECKSUM for AHMASPZAP       */\n/* Checks AMASPZAP cards to checksum    */\n/* author: David McRitchie,  06/14/1990 */\n/* Copyright 1990, 1991 David McRitchie\n.go xxx;.ct */\n/*        update 1991/05/14 D.McRitchie               */\n/* F. David McRitchie -- \"The REXX Macros Toolbox\"    */\n/*   last update 1996/04/26 D.McRitchie               */\n/*     restored/added CCHHR, SETSSI, VERIFY           */\n/*                                                    */\n/* This macro is universally available with the       */\n/*   stipulation that that the original               */\n/*   author remains credited and that no charge       */\n/*   or licensing fee accrues to any party.           */\n/* This macro is my first meaningful                  */\n/*   REXX code -- the columns are narrow              */\n/*   to provide for printing using a non-typographic  */\n/*   font.                                            */\n/* This macro was changed to use only single          */\n/*   quotes since double quotes are not very          */\n/*   friendly on a magazine page.  Normally           */\n/*   double quotes would be used except where         */\n/*   quotes are embedded.                             */\n/* 1991/08/29 Allow CHECKSUM (blanks)                 */\n/* 1996/04/26 in addition to NAME, REP, VER,          */\n/*    and CHECKSUM, now also handles VERIFY,          */\n/*    BASE, CCHHRR, and SETSSI                        */\n/*    PC some nonIBM REXX messes with CURSOR          */\n/* remove ----these lines non-FDM users               */\n/* || test data in CLIST  zap$                        */\n/* || test data in CNTL   zap$$                       */\n/* || Doc available sop #6250                         */\n/* || Macro reprocessed to print in 35 n-Spaces       */\n/* remove ----these lines non-FDM users               */\n/******************************************************/\n/*-- ,\n...xxx;.ct */\nAddress 'ISREDIT'\nNumeric digits 20\n'MACRO (TOKEN)'\n'reset'\n'(CAPS)=CAPS'  /*will restore at exit*/\n'caps off'  /*for msglines*/\n'X all '; 'find all word VER';\n'find all word rep'; 'find all word name';\n'find all word base'; 'find all word cchhr';\n'find all word idrdata'; 'find all 1 //'\n'find all word checksum';\n'find all word setssi';\ntoken=translate(token) /*capitals*/\nnull=''; /*easier to read later*/\nMSGAC= ,\n  'LINE_AFTER  .zcsr = msgline '\nMSGBC= ,\n  'LINE_BEFORE .zcsr = msgline '\nMSGB1= ,\n  'LINE_BEFORE 1 = msgline '\naddends=null; addendx=null; x8=null;\nchecksum=0; cntidr=0; cntname=0;\nII=0; notice=0; check=null; ret=0;\nhex='0123456789ABCDEF';\npcrow=1;pccol=0;\nDo forever\n   'cursor =' pcrow pccol\n   'find next P''='' 1 nx'\n   If RC \\= 0 then leave /*exit point*/\n   '(PCROW,PCCOL) = CURSOR'\n   /* some pc implementations mess */\n   /* with the CURSOR for line_after */\n   '(CARD) = line' PCROW\n   Parse var CARD ,\n      Opcode Address Operand Comment;\n   Do forever; /*remove commas*/\n     Parse var Operand Left','Right;\n     If Right=null then Leave;\n     Operand=Left || Right;\n   End\n   xok = 2\n   If verify(operand,hex) \\=0 then xok=1\n   If verify(address,hex) \\=0 then xok=0\n\n   Select;\n   When Opcode='VER',\n       | Opcode='VERIFY',\n       | Opcode='REP' then Do\n     If xok < 2 then Call NOGOOD\n     Else Do\n       'exclude .zcsr .zcsr all'\n       Call evendig(operand);\n       addends=addends||address||operand\n       Call evendig(operand);\n       Call evendig(address);\n     End\n   End\n\n   When Opcode = 'BASE' then Do\n      If xok < 1 then Call NOGOOD\n      Else addends = addends||address;\n      Call evendig(address);\n   End\n\n   When Opcode = 'SETSSI' then Do\n      If xok < 1 then Call NOGOOD\n      If length(address) \\= 8 then do\n        msgbc '''SETSSI incorrect length'''\n        ret=max(ret,8)\n      end\n      else 'exclude .zcsr .zcsr all'\n      'cursor =' pcrow pccol\n   End\n\n   When Opcode = 'CHECKSUM'\n   then Do\n      /*--accept blank checksum as a reset*/\n      If address = '' then Do\n         Address = '00000000'\n         MSGBC '''--CHECKSUM to be reset '''\n         'CURSOR =' pcrow pccol\n         up 8\n         xok=1; /*notouch checksum addends*/\n      End\n      /*--accept blank checksum as a reset*/\n      If xok < 1 | Length(address) \\=8\n      then Call NOGOOD\n      Else Do\n         Check = address\n         Call PROCESS\n         checksum = 0; addends=null;\n      End\n  End\n\n   When Opcode = 'IDRDATA'  then\n      cntidr = cntidr + 1\n\n   When Opcode = 'NAME' then Do\n      cntname = cntname + 1\n      If length(addends) \\= 0 then Do\n        notice = 1\n        MSGBC '''---No CHECKSUM ' ,\n          ||'statement before NAME ' ,\n          ||'-- checksum not reset'''\n       'CURSOR =' pcrow pccol\n      End\n   End\n\n   When Opcode = 'CCHHR' then Do\n      /* treated more like VER than name*/\n      cntname = cntname + 1\n      If length(address) \\= 10 then Do\n         notice = 1\n        MSGAC '''---CCHHR cccchhhhrr, ',\n          ||'must be ten digits long '''\n       'CURSOR =' pcrow pccol\n      End\n      If length(addends) \\= 0 then Do\n        notice = 1\n        MSGBC '''---No CHECKSUM ' ,\n          ||'statement before CCHHR ' ,\n          ||'-- checksum not reset'''\n       'CURSOR =' pcrow pccol\n      End\n      addends=addends||address||operand\n   End\n\n   When substr(card,1,2)='//' then Do\n      check = null\n      If length(addends) \\= 0\n         then Call PROCESS\n      If checksum \\= 0 then Do\n        notice = notice + 1\n        MSGBC '''--Warning CHECK',\n          ||'SUM reset due JCL card'''\n       'CURSOR =' pcrow pccol\n      End\n   End\n\n   Otherwise 'exclude .zcsr .zcsr all'\n   End  /*--- SELECT ---*/\n\nEnd /*forever*/\nIf notice > 0 then\n   MSGB1 '''SPZAP only resets accum',\n       ||'ulation at CHECKSUM cards'''\n   'cursor =' pcrow pccol\nIf cntidr \\= cntname then\n   MSGB1 '''**Warning** ' ,\n      || cntname 'NAME lines, and ' ,\n      || cntidr 'IDRDATA lines, ' ,\n      || 'consider adding IDRDATA'''\nIf length(addends) \\= 0\n   then Call PROCESS\nIf checksum \\= 0 then ,\n  'LINE_AFTER .zl = ' ,\n  || 'msgline ''--missing CHECKSUM ' ,\n  || 'check after last SPZAP card'''\n/*The following remain showing */\n/*  NAME,CHECKSUM,IDRDATA*/\n'loc 0'      /*locate to top*/\n'CAPS' caps  /* ON|OFF as began*/\nIf ret > 0 then Do\n   zedsmsg='CHECKSUM ERRORS'\n   zedlmsg='CHECKSUM errors will ',\n     ||'occur if presented for processing'\n   'line_before .zf = msgline (zedlmsg)'\n   Address ISPEXEC ,\n     'setmsg MSG(isrz001)'\n   'CURSOR =' pcrow pccol\nEnd\nelse Do\n   zedsmsg='OKay'\n   zedlmsg='CHECKSUM appears okay, ',\n     ||'increasing probability of success'\n   Address ISPEXEC ,\n     'setmsg MSG(isrz000)'\n   'CURSOR =' pcrow pccol\nEnd\nReturn(1)    /* cursor to home position*/\n\nNOGOOD: procedure ,\n     Expose MSGBC ret pcrow pccol;\n MSGBC '''?? Next card invalid HEX'''\n address 'ISREDIT'\n 'CURSOR =' PCROW PCCOL\n ret = max(ret,8)\nReturn\n\nEVENDIG: procedure,\n   Expose MSGAC ret PCROW PCCOL;\narg xxx\nLOP=length(xxx)\naddress 'ISREDIT'\nif 0 \\= lop//2 then do\n 'CURSOR =' PCROW PCCOL\n  MSGAC '''Odd Number of digits above'''\n  'reset x .zcsr .zcsr'\n 'CURSOR =' PCROW PCCOL\n  ret = max(ret,8)\nend\nReturn\nPROCESS: procedure  Expose MSGBC,\n     addends checksum check null ret,\n     PCROW PCCOL;\naddress 'ISREDIT'\nNumeric digits 20\nDo Forever\n   L = length(addends)\n   If L = 0 then leave\n   X8 = substr(addends,1,8,'0')  /*0 pad*/\n   If L > 8 then ,\n      addends = substr(addends,9,,' ')\n   Else addends = null\n   decval = X2D(X8)\n   checksum = checksum + decval\nEnd  /* of Forever in PROCESS*/\nC8=Right(x'00000000',\n    || D2X(checksum),8);\nmsg='is the calculated checksum'\nIf check \\=null & check \\= C8 then Do\n    msg=msg||' **** does not match'\n    'CURSOR =' PCROW PCCOL\n    ret = max(ret,8)\nEnd\nMSGBC ''' --------' C8 msg ''''\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLIST": {"ttr": 5126, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01d\\x01d\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 356, "newlines": 356, "modlines": 0, "user": "MCRITCH"}, "text": "  PROC 1 MEMBER ALL NEW SUMMARY NB DEBUG EDIT CHKCAT HELP +\n          DS1('&SYSUID..LIBR.EXEC') +\n          DS2('&SYSUID..LIBR.CLIST') +\n          DS3('TECHTSO.COMBINE.ISRCLIB') +\n          DS4('TSOTEST.LIB01.CLIST') +\n          DS5('TSOPROD.LIB01.CLIST') +\n          DS6('HCCG.CLIST') +\n          DS7('TECH.DALLAS.CLIST') +\n          DS8('&SUBSTR(1:4,&SYSUID.MMMM).LIBR.CLIST') +\n  CL1('TECH.ISRCLIB') +\n  CL2('SYS1.ISPFPDFV.ISRCLIB') +\n  CL3('TECH.ISPFV.ISPCLIB') +\n  CL4('SYS1.VB.SAMPJCL1') +\n  CL5('SYS1.TSOCLIST') +\n  CL6('SYS1.DSQCLSTE') +\n  CL7('SYS1.DSNCLIST') +\n  CL8('SYS1.VB.ICEISPC') +\n  CL9('SYS1.VB.ICEDGTC') +\n CL10('SYS1.VB.VSF2CLIB') +\n CL11('SYS1.VB.COB2CLIB') +\n CL12('SYS6.IOFT7B0.VB.CLIST') +\n CL13('TSOPROD.LIB01.CLIST')\n/*  PERIODICALLY REFRESHED TO MATCH IV2B69, REFRESHED 1992/11/13 D.MCR */\n/*   THE USE OF IS03.LIBR.CLIST(IV2B69R MAY BE USEFUL */\n/**********************************************************************\n/* FOR USE ON THE TEST SYSTEM THE CLIST CAN HAVE MINOR CHANGES MADE   *\n/* TO IT TO SUPPRESS DSNAMES BY PLACING AN ASTERISK OR                *\n/* ASTERISK-SPACE BEFORE DATASET LIST ITEM BASED ON RESULTS OF        *\n/*   ===> TSO CLIST CLIST CHKCAT                                      *\n/**********************************************************************\n/* ALTERNATIVE CLIST THAT CAN BE USED ON TEST SYSTEM IS               *\n/*     ===> TSO PDSDD SYSPROC CLIST                                   *\nIF NEW = &NEW THEN DO\n  IF &STR(&SYSPREF.) = &STR() THEN SET U = &SYSUID\n  ELSE SET U = &SYSPREF.\n  $EDIT &U..LIBR.CLIST(&MEMBER.) NEW\n  EXIT CODE(&LASTCC.)\nEND\nIF SPFTEST = &SYSPROC. THEN DO\n PDSDD SYSPROC &MEMBER. &ALL. &NB.  &EDIT.\n EXIT CODE(0)\nEND\n/**********************************************************************\n/* ***** EXAMPLE OF USAGE:  ===> TSO CLIST <MEMBERNAME>\n/* ***** EXAMPLE OF USAGE:  ===> TSO CLIST <MEMBERNAME> HELP\n/* ***** ALSO OF INTEREST:  ===> TSO PDSDD SYSPROC <MEMBERNAME>\n/* ***** ALSO OF INTEREST:  ===> TSO PDSDD CLIST   <MEMBERNAME>\n/* ***** ALSO OF INTEREST:  ===> TSO DDNAME SYSPROC\n/* ***** ALSO OF INTEREST:  ===> TSO LISTDD SYSPROC\n/* ***** ALSO OF INTEREST:  ===> TSO PROC  <MEMBERNAME>\n/* * ALSO OF INTEREST:  ===> TSO LISTALC (STATUS) (HISTORY) (SYSNAMES)\n/****************************************************************    */\n/* PURPOSE: BROWSE A CLIST MEMBER\n/*          EDIT A CLIST MEMBER IF EDIT IS SPECIFIED\n/*          ACCORDING TO EXPECTED ORDER\n/*  SUPPLIED BY DAVID MCRITCHIE AHC 1985/07/10\n/*  TO CHECK THE LIBRARIES CHECKED IN THIS CLIST YOU MAY WISH TO\n/*   COMPARE DSNAMES WITH  DSNAME SHOWN\n/*   USING \"===> TSO DDNAME SYSPROC\".  TEST WITH MEMBERNAME  \"ISRJC03\"\n/*  OPTIONS -- */\n/*   DEBUG -- TRACING FOR PROGRAMMER\n/*   NB -- NO BROWSE. DS LIBRARIES\n/*   ALL   -- WILL (ALSO) BROWSE THE COMBINED LIBRARIES\n/*   EDIT  -- WILL BE USED INSTEAD OF BROWSE\n/*   SUMMARY -- WILL PRODUCE A SUMMARY LIST AT END\n/*   CONTROL MAIN\n  /*=========== BEGIN SPECIAL CLIST HELP PORTION ================*/\n  SET L = &LENGTH(&STR(&MEMBER.))\n  IF &L. > 8 THEN DO\n     SET INVAL = &STR(INVALID MEMBERNAME LENGTH('&MEMBER.') EXCEEDS 8)\n     WRITE &INVAL.\n     SET &ZEDSMSG = &STR(MEMBERNAME)\n     SET &ZEDLMSG = &STR(&INVAL.)\n     ISPEXEC     SETMSG MSG(ISRZ000)\n     EXIT CODE(12)\n  END\n/*SET TYPE = CLIST    /* WILL APPEAR ON EXTENDED BROWSE MESSAGE*/\n  SET MULTIMEM = &SYSINDEX(&STR(*),&STR(&MEMBER.))\n  IF &MULTIMEM = 0 THEN -\n     SET MULTIMEM = &SYSINDEX(&STR(%),&STR(&MEMBER.))\n  IF &MULTIMEM = 0 THEN SET PATTERN = &STR()\n  ELSE SET PATTERN = &STR(PATTERN )\n  SET RP = )\n  SET LP = &STR((\n  SET HELP = &SYSUC(&STR(&HELP.))\n  IF HELP = &STR(&MEMBER.) THEN DO\n     SET HELP = HELP\n     SET MEMBER = $HELP$\n  END\n   /**          CONTROL LIST CONLIST SYMLIST\n  IF HELP = &STR(&HELP.) THEN DO\n     /* CLIST HELP PLACED WITH JOB IS03.SHARE.CNTL(NCPDSHLP) */\n     SET &VSTSRVTI = IS03.CLISTHLP.HELP(&STR(&MEMBER.))\n     SET &DSNDESC  = &STR(ACTUAL CLIST CAN BE SEEN USING ===>  +\n       TSO CLIST &STR(&MEMBER.))\n     SET &SYSBROX2 = &STR(               ACTUAL CLIST CAN BE +\n       SEEN USING ===> TSO CLIST &STR(&MEMBER.))\n     ISPEXEC  VPUT (VSTSRVTI,DSNDESC) SHARED\n     IF CLIST  = &STR(&MEMBER.) THEN SET MEMBER = PROC\n     IF LOADMOD = &STR(&MEMBER.) THEN SET MEMBER = PROC\n     IF &MULTIMEM. > 0 THEN SET ST = &SYSDSN('IS03.CLISTHLP.HELP')\n     ELSE SET ST = &SYSDSN('IS03.CLISTHLP.HELP(&STR(&MEMBER.))')\n     IF OK = &STR(&ST.) THEN DO\n        IF EDIT = &EDIT. THEN +\n          ISPEXEC  EDIT DATASET('IS03.CLISTHLP.HELP(&STR(&MEMBER.))') +\n            PANEL(SYSEDDE2)\n        ELSE ISPEXEC BROWSE DATASET('IS03.CLISTHLP.HELP+\n               (&STR(&MEMBER.))') +\n            PANEL(SYSBROX2)\n        SET RC = &LASTCC.\n        IF PANELS = &STR(&MEMBER.) THEN WRITE ALSO SEE THE +\n           -- PROC -- CLIST\n        EXIT CODE(&RC.)\n     END\n /* CHECK INTO SYS1.HELP, SYS1.TSOHELP,...,SYS1.DSNHELP,... ETC. */\n    CONTROL FLUSH\n    QHELP &STR(&MEMBER.)\n    SET RC = &LASTCC.\n    CONTROL NOFLUSH\n    IF &RC = 0 THEN EXIT CODE(&RC.)\n    SET &ZEDSMSG = &STR(HELP N/A FOR &STR(&MEMBER.))\n    SET &ZEDLMSG = &STR(RC=&RC. NOT IN IS03.CLISTHLP.HELP, +\n      REENTER WITHOUT \"HELP\" TO BROWSE CLIST)\n    ISPEXEC     SETMSG MSG(ISRZ000)\n    EXIT CODE(1)\n  END\n  IF &MULTIMEM. > 0 THEN SET ST = &SYSDSN('IS03.CLISTHLP.HELP')\n  ELSE SET ST = &SYSDSN('IS03.CLISTHLP.HELP(&STR(&MEMBER.))')\n  IF OK = &STR(&ST.) THEN DO\n    SET &ZEDSMSG = &STR(CLIST HELP AVAILABLE)\n    SET &ZEDLMSG = &STR(===> TSO CLIST &STR(&MEMBER.) HELP <-- BROWSE +\n        IS03.CLISTHLP.HELP(&STR(&MEMBER.)&RP.)\n    ISPEXEC     SETMSG MSG(ISRZ000)\n  END\n  /*============= END SPECIAL CLIST HELP PORTION ================*/\n  SET BLANKS = &STR(                                            )\n  SET BLANKS = &STR(&BLANKS.&BLANKS.)\n  IF CHKCAT = &SYSCAPS(&CHKCAT.) | CHKCAT = &SYSCAPS(&STR(&MEMBER.)) +\n  THEN DO\n     SET CHKCAT = CHKCAT\n     SET MEMBER = &STR(........)\n     SET ALL = ALL\n  END\n  IF &STR(&MEMBER) = BROWSE THEN DO\n   WRITE &STR() THE AHC CLIST NAMED BROWSE  HAS BEEN CHANGED TO $BROWSE\n   WRITE &STR()   TO AVOID FURTHER CONFLICT WITH ISPF IMPLEMENTATIONS\n   WRITE &STR()   PLEASE UPDATE YOUR DOCUMENTATION ACCORDINGLY.\n   WRITE &STR()   T&SYSLC(HE CLIST  )$BROWSE +\n      &SYSLC(WILL BE DISPLAYED INSTEAD.)\n   SET MEMBER = $BROWSE\n  END\n  IF &LENGTH(&STR(&MEMBER.)) > 8 THEN DO\n      WRITE &STR() THE SPECIFIED MEMBERNAME \"&MEMBER\" EXCEEDS 8 +\n          BYTES  LENGTH IS &LENGTH(&MEMBER)\n      EXIT CODE(12)\n  END\n/*SET MULTIMEM = &SYSINDEX(&STR(*),&STR(&MEMBER.))*/\n  IF &MULTIMEM NE 0 THEN DO\n     IVL806 &MEMBER\n     IF &LASTCC = 0 THEN WRITE A LOADMOD (ALSO) EXISTS FOR &MEMBER  +\n          USE THE LOADMOD CLIST FOR MORE INFORMATION\n  END\n  ISPEXEC CONTROL DISPLAY LINE\n  SET DEBUG = &SYSCAPS(&DEBUG)\n  SET NB    = &SYSCAPS(&NB)\n  SET BROWSE = BROWSE\n  IF EDIT = &EDIT THEN SET BROWSE = EDIT\n  IF &NB = NB THEN SET SUMMARY = SUMMARY\n  SET ALL  = &SYSCAPS(&ALL)\n  SET SUMMARY = &SYSCAPS(&SUMMARY)\n  SET XCNT = 0\n  SET RC = 0\n  SET N = 1\n  SET TN = 1\n  SET AVAIL = 0\n  SET DS = &&DS&N..\n  DO WHILE &STR(&DS.) ^=\n     SET AVAIL = &AVAIL. + 1\n     SET RC = &N\n     IF CHKCAT = &SYSCAPS(&CHKCAT.) THEN DO\n        /*    CONTROL NOLIST NOCONLIST NOSYMLIST MSG\n        /*       SYSOUT TRAPS WILL NOT WORK IF YOU USE   LIST\n        SET SYSOUTTRAP = 100\n        SET SYSOUTLINE7 = &STR(.....................................)\n        LISTCAT ENT('&DS.') VOL\n        SET NS = &SYSOUTLINE\n        SET I = 1\n        DO WHILE &I <= &NS\n           SET X = &STR(&&SYSOUTLINE&I..)\n           SET X = &STR(&X.)\n           SET I = &I. + 1\n        END\n        WRITE &SUBSTR(1:4,&TN..    )&STR(DS)&SUBSTR(1:4,&N.    ) +\n           &SUBSTR(26:31,&SYSOUTLINE7.&BLANKS.) +\n           &SUBSTR(16:60,&SYSOUTLINE1.&BLANKS.)\n        GOTO AGAIN\n     END\n /*  SET MULTIMEM = &SYSINDEX(&STR(*),&STR(&MEMBER.))*/\n     IF &MULTIMEM NE 0 THEN DO\n        SET XDSN&RC = &STR(&DS.)\n        SET CHK&RC = &STR(NO MEMBERS FOUND)\n        ISPEXEC CONTROL ERRORS RETURN\n        ISPEXEC &BROWSE DATASET('&DS.(&STR(&MEMBER.))')\n        IF &LASTCC. < 8  THEN DO\n           SET XCNT = &XCNT. + 1\n           SET MULTI&N. = 1  /* WOULD BE NICE TO HAVE A COUNT*/\n           SET CHK&RC = &STR(MEMBER&LP.S&RP. FOUND)\n        END\n        GOTO AGAIN\n     END\n     IF &SUBSTR(1:1,&DS. ) ^= &STR(*) THEN DO\n        SET CHKX = &STR(&SYSDSN('&DS.(&STR(&MEMBER.))'))\n        SET XDSN&RC = &STR(&DS.)\n        SET CHK&RC = &STR(&CHKX)\n        IF &STR(&CHKX) = OK THEN DO\n           SET DSNAME = '&DS.(&STR(&MEMBER.))'\n           IF &NB ^= NB THEN DO\n              ISPEXEC VPUT DSNAME SHARED\n              ISPEXEC   &BROWSE. DATASET('&DS.(&STR(&MEMBER.))')\n              IF &LASTCC. < 8 THEN SET XCNT = &XCNT. + 1\n              SET DSNAME =\n              ISPEXEC VPUT DSNAME SHARED\n           END\n           ELSE SET XCNT = &XCNT. + 1\n        END\n        ELSE IF &DEBUG. = DEBUG THEN DO\n           WRITE &SUBSTR(1:4,&TN.    )&STR(CL)&SUBSTR(1:4,&N.    ) +\n                 '&DS.(&STR(&MEMBER.))' -- &STR(&CHKX).\n        END\n     END\n     ELSE DO\n        SET XDSN&RC = &STR(&DS.)\n        SET CHK&RC = &STR(*SUPPRESSED*)\n     END\n    AGAIN: -\n     SET N = &N. + 1\n     SET TN = &TN. + 1\n     SET DS = &&DS&N..\n     IF &N. > 2 THEN -\n        IF &STR(&DS.) = &STR(&DS2.) THEN GOTO AGAIN\n  END\n  IF &XCNT. ^=0 THEN DO\n      IF &XCNT ^= 1 THEN WRITE &PATTERN.+\n         MEMBER=&STR(&MEMBER.)  WAS FOUND IN &XCNT. +\n         OF &AVAIL. CLIST LIBRARIES\n     IF &ALL ^= ALL AND &SUMMARY ^= SUMMARY THEN EXIT CODE(0)\n  END\n  ELSE WRITE MEMBER=&STR(&MEMBER.) WAS NOT FOUND IN ANY +\n       OF &AVAIL. SELECTED REGULAR CLIST LIBRARIES\n         /*     CONTROL LIST CONLIST SYMLIST */\n  SET DRC = &RC.\n  /************** REDO FOR COMBINED LIBRARIES       ********/\n /* IF &MULTIMEM. > 0 THEN EXIT CODE(1)\n  SET CCNT = 0\n  SET N = 1\n  SET CL = &&CL&N..\n  DO WHILE &STR(&CL) ^=\n     SET RC = &RC + 1\n     IF CHKCAT = &SYSCAPS(&CHKCAT.) THEN DO\n        /*    CONTROL NOLIST NOCONLIST NOSYMLIST MSG\n        /*       SYSOUT TRAPS WILL NOT WORK IF YOU USE   LIST\n        SET SYSOUTTRAP = 100\n        SET SYSOUTLINE7 = &STR(.....................................)\n        LISTCAT ENT('&CL.') VOL\n        SET NS = &SYSOUTLINE\n        SET I = 1\n        DO WHILE &I <= &NS\n           SET X = &STR(&&SYSOUTLINE&I..)\n           SET X = &STR(&X.)\n           SET I = &I. + 1\n        END\n        WRITE &SUBSTR(1:4,&TN..    )&STR(DS)&SUBSTR(1:4,&N.    ) +\n           &SUBSTR(26:31,&SYSOUTLINE7.&BLANKS.) +\n           &SUBSTR(16:60,&SYSOUTLINE1.&BLANKS.)\n        GOTO AGAIN2\n     END\n     SET XDSN&RC = &STR(&CL.)\n     IF &MULTIMEM NE 0 THEN DO\n        SET CHK&RC = &STR(NO MEMBERS FOUND)\n        ISPEXEC CONTROL ERRORS RETURN\n        ISPEXEC &BROWSE DATASET('&CL.(&STR(&MEMBER.))')\n        IF &LASTCC. < 8 THEN DO\n           SET CCNT = &CCNT. + 1\n           SET MULTI&RC. = 1  /* WOULD BE NICE TO HAVE A COUNT*/\n           SET CHK&RC = &STR(MEMBER&LP.S&RP. FOUND)\n        END\n        GOTO AGAIN2\n     END\n     SET CHKX = &STR(&SYSDSN('&CL.(&STR(&MEMBER.))'))\n     SET CHK&RC = &STR(&CHKX)\n     IF &STR(&CHKX) = OK THEN DO\n        IF &ALL = ALL THEN DO\n           SET DSNAME = '&CL.(&STR(&MEMBER.))'\n           ISPEXEC VPUT DSNAME SHARED\n           ISPEXEC   &BROWSE. DATASET('&CL.(&STR(&MEMBER.))')\n           SET DSNAME =\n           ISPEXEC VPUT DSNAME SHARED\n        END\n        SET CCNT = &CCNT. + 1\n     END\n     ELSE IF &DEBUG. = DEBUG THEN DO\n        WRITE &SUBSTR(1:4,&TN.     )&STR(CL)&SUBSTR(1:4,&N.    ) +\n              '&CL.(&STR(&MEMBER.))' -- &STR(&CHKX).\n     END\n   AGAIN2: +\n     SET N = &N. + 1\n     SET TN = &TN. + 1\n     SET CL = &&CL&N..\n  END\n  SET HRC = &RC.\n  /* --------------------------------------------------------------- */\n  IF &SUMMARY ^= SUMMARY THEN DO\n         SET DSN =\n         SET XDSN =\n         EXIT CODE(0)\n  END\n  WRITE  A&SYSLC(S AN ALTERNATIVE TO) SUMMARY +\n      &SYSLC(VERIFICATION YOU COULD ENTER ...)\n  WRITE  &STR()     ===> TSO PDSDD SYSPROC &MEMBER ALL\n  WRITE\n  /* --------------------------------------------------------------- */\n  SET I = 1\n  IF &STR(&DDNAME) ^= &STR(&DDNAMEX) THEN DO\n       WRITE SUMMARY ----------------- CLIST &STR(&DDNAME) &MEMBER +\n           &ALL &SUMMARY &NB &DEBUG DSN1() DSN2()\n  END\n  ELSE WRITE SUMMARY -------- ===> TSO CLIST &DDNAME &MEMBER +\n           &ALL &SUMMARY &NB &DEBUG\n  WRITE AS DETERMINED &SYSDATE. &SYSTIME. FOR &SYSUID. +\n           USING PROC=&SYSPROC.\n  SET STR44 = &STR(............................................)\n  SET SI = 1\n  DO WHILE &I <= &RC\n     IF &I = &EVAL(&HRC + 1) | &I = &EVAL(&DRC + 1) THEN DO\n        IF &I = &EVAL(&DRC + 1) THEN WRITE &STR(------) $BROWSE. +\n             OF COMBINED LIBRARIES OCCURS ONLY WITH 'ALL' OPTION\n        ELSE WRITE &STR(------) $BROWSE. +\n             OF ADDITIONAL LIBRARIES OCCURS ONLY WITH 'ALL' OPTION\n     END\n     SET DSN = '&STR(&&XDSN&I.(&STR(&MEMBER.)))'\n /*  IF &MULTIMEM. > 0 THEN SET DSN = '&STR(&&XDSN&I.)'\n     SET CHK =  &STR(&&CHK&I)\n     IF &I < 10 THEN WRITE +\n          &STR(0)&I.&STR(-)&SUBSTR(1:4,&SI..    ) +\n          &SUBSTR(1:44,&STR(&STR(&DSN) &STR(&STR44))) &CHK.\n     ELSE WRITE +\n          &I.&STR(-)&SUBSTR(1:4,&SI..    ) +\n          &SUBSTR(1:44,&STR(&STR(&DSN) &STR(&STR44))) &CHK.\n     SET I = &I + 1\n     SET SI = &SI + 1\n     IF &I > &DRC. THEN SET SI = &I. - &DRC.\n  END\n  IF &DEBUG = DEBUG THEN WRITE  DRC=&DRC  RC=&RC HRC=&HRC I=&I\n  SET DSN =\n  SET XDSN =\n  /* ----+++ */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLISTBOX": {"ttr": 5378, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00@\\x00@\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "MCRITCH"}, "text": "/***********************************************************REXX******/\n/*  DRAW A BOX AROUND CLIST LINES (COMMENT THEM OUT)                 */\n/*  MODIFIED FROM CBT TAPE #9102 -- FILE095 MEMBER CLISTBOX          */\n/* *******************************************************************/\n/*  USED CLIST WITH PENDING    ADD-LINES, WITH THE RESULT            */\n/*  THAT    ISPF SESSION ABENDED.   WAITING ON PENDING COMMANDS      */\n/*  IS A REQUIREMENT OF THIS CLIST -- APPEARS NOT TO RECUR           */\n/* *******************************************************************/\n/*  ADDED NOTELINES -- D.MCRITCHIE    1991/05/10, TO REXX 1993/06/11 */\n/* *******************************************************************/\n/*********************************************************************/\n   ADDRESS \"ISREDIT\";\"MACRO (HELP) NOPROCESS\"\n   IF HELP = \"?\" THEN DO\n      /*ADDRESS \"ISPEXEC DISPLAY PANEL(CLISTBOX)\"*/\n      CLIST CLISTBOX HELP\n      EXIT\n   END\n   STARS = SUBSTR('*',1,64,'*')\"/\"\n   \"PROCESS RANGE C\"\n   LCC = RC\n   \"(RCMD) = RANGE_CMD\"\n   IF RC = 4 | RCMD \\= \"C\" THEN DO\n      ZEDSMSG = \"NO RANGE SPECIFIED\"\n      ZEDLMSG = \"YOU MUST SPECIFY A RANGE OF LINES TO BE BOXED\",\n          \"USING A \"\"C<N>\"\" OR \"\"CC\"\"\"\n      ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ001)\"\n      EXIT 4\n   END\n   \"(FIRST) = LINENUM .ZFRANGE\"\n   \"(LAST) = LINENUM .ZLRANGE\"\n   \"(FR) = LINENUM .ZFRANGE\"\n   \"(LR) = LINENUM .ZLRANGE\"\n/*********************************************************************/\n/*    THIS IS A STARRY BOX CREATED BY THE CLISTBOX CLIST             */\n/*********************************************************************/\n   \"LINE_BEFORE .ZFRANGE = NOTELINE \"\"\"TIME() \"START OF\",\n      \"CLISTBOX -- LINES\" FR \"TO\" LR \"\"\"\"\n   \"LINE_AFTER         .ZLRANGE = NOTELINE \"\"\"TIME() \"-END OF-\",\n     \"CLISTBOX -- LINES\" FR \"TO\" LR \"\"\"\"\n  \"(LBO,RBO) = BOUNDS\"\n  \"BOUNDS 1 72\"\n\n  DO C = FR TO LR\n    \"SHIFT )\" C \"3\"\n  END\n  \"MASKLINE = \"\"/\"||\"*****\"STARS\"\"\"\"\n  \"LINE_BEFORE\" FIRST \"= MASKLINE\"\n\n  DO I = FR TO LR\n    \"LABEL\" I \"= .LJ\"\n    \"SEEK P'^' .LJ .LJ\" LBO  RBO \"FIRST\"\n    \"SEEK P'^' .LJ .LJ\" LBO  RBO \"LAST\"\n    \"CHANGE P'===' '/\"||\"* ' 1\"\n    \"CHANGE P'==' '*\"||\"/' 70\"\n    IF  I =  FR THEN \"LABEL\" I \"= .LJX\"\n  END\n\n  \"SEEK P'=' .LJX .LJX FIRST\"\n  \"MASKLINE = \"\"/\"||\"*****\"STARS\"\"\"\"\n  LAST =  LAST + 1\n  \"LINE_AFTER\" LAST \"= MASKLINE\"\n  \"MASKLINE = ' '\"\n  \"BOUNDS         \" LBO\",\"RBO\n  EXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COLS": {"ttr": 5380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00G\\x00G\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 71, "newlines": 71, "modlines": 0, "user": "MCRITCH"}, "text": "/*rexx macro to simulate \"cols\" line command entered from the   */\n/*  edit command line - prevents \"COMMAND COLS NOT FOUND\" MSG   */\n/* COLS Macro for REXX Exec, by Phillip Miller of               */\n/*  Oklahoma Farm Bureau Mutual Insurance Company               */\n/*  \"TSO Times\" Summer issue 1993 from Chicago-Soft, Ltd. 1993/10/04*/\n/*  Modifications David McRitchie to use MSGLINE and include parm(s)*/\naddress ISREDIT\n\"MACRO (ColsParm,Data)\"    /* optional ColsWide for additional scales */\n\"(width) = data_width\"\nNOTELINE = \"NOTELINE\"\nParse version V1 V2 V3 V4 V5  /* should be fixed in SPF/PC 4.0 */\nif v1 = \"REXXSAA\" then NOTELINE=\"MSGLINE\"; else NOTELINE=\"INFOLINE\"\nif Data \\= \"\" then NOTELINE = \"DATALINE\"\n\"(USTATE) = USER_STATE\"    /* Save current user state */\nLDATA1 = \"----+----1----+----2----+----3----+----4----+----5\"||,\n         \"----+----6----+----7----+----8----+----9----+----0\"||,\n         \"----+----1----+----2----+----3----+----4----+----5\"||,\n         \"----+----6----+----7----+----8----+----9----+----0\"||,\n         \"----+----1----+----2----+----3----+----4----+----5----+-\"\nLDATA2 = \"1...5...10...15...20...25...30...35...40...45...50\"||,\n         \"...55...60...65...70...75...80...85...90...95..100\"||,\n         \"..105..110..115..120..125..130..135..140..145..150\"||,\n         \"..155..160..165..170..175..180..185..190..195..200\"||,\n         \"..205..210..215..220..225..230..235..240..245..250..255.\"\nif ColsParm \\= \"\" then do\n   if datatype(ColsParm,\"N\") \\= 1 then colswide = 100\n   else colswide = colsparm\n   if colswide > 2048 then do\n      colswide = 2048\n      say \"Apparent limit for noteline of 2048 in SPF/PC\"\n   end   /* limit in tso edit is 256 anyway */\n   if width < colswide then colswide = width\n   if ColsParm < 256 then do\n      ldata1 = left(ldata1,ColsWide)\n      ldata2 = left(ldata2,ColsWide)\n   end\nend\nif width < 256 then do\n     ldata1 = left(ldata1,width)\n     ldata2 = left(ldata2,width)\nend\n\"(num1,num2) = number\"\n\"NUMBER OFF\"                           /* force nonumber mode on    */\n\"(DLF,DLL) = DISPLAY_LINES\"            /* Line no. of 1st in display*/\n/* both of the following should be INFOLINE which is not in SPF/PC  */\n/* suggest using new SPF/PC option  0.5 SCROLL Yes   */\n\"label\" DLF \"= .DLF 1\"\nstring = left(\"--- lines added by COLS\" colsparm data,72,\"-\")\nif noteline = \"DATALINE\" then\n    \"LINE_BEFORE .DLF = NOTELINE (string)\"\n\"LINE_BEFORE .DLF = \" NOTELINE \" (LDATA2)\" /* Insert COLS line    */\n\"LINE_BEFORE .DLF = \" NOTELINE \" (LDATA1)\" /* Insert COLS line    */\n/* if ColsWide not blank then create another set of scales */\nif colsparm \\= \"\" then do\n   do icard = 1 to length(colswide)\n      NCard = \"\"\n      do j = 1 to colswide\n         NCard = NCard||substr(right(j,length(colswide),'0'),icard,1)\n      end\n      \"LINE_BEFORE .DLF = \" NOTELINE \" (NCard)\" /* Insert COLS line */\n   end\n   if noteline = \"DATALINE\" then do\n     \"LINE_BEFORE .DLF = NOTELINE \"\"\"||left(\"-\",72,\"-\")||\"\"\"\"\n     \"LINE_BEFORE .DLF = NOTELINE \"\"\"||left(\"-\",width,\"-\")||\"\"\"\"\n   end\nend\n\"USER_STATE = (USTATE)\"                /* Restore user state        */\nIf colsparm \\= \"\" then \"UP\" length(colswide)\nif noteline \\= \"NOTELINE\" then \"UP\" 3\n\"UP 2\"                                 /* include COLS lines at top */\n\"number\" num1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COLSUM": {"ttr": 5383, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x86\\x00\\x86\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 134, "newlines": 134, "modlines": 0, "user": "MCRITCH"}, "text": " Address \"ISREDIT\"; /*REXX*/\n \"MACRO (PRM1 PRM2 PRM3 PRM4 PRM5 PRM6 PRM7 PRM8 PRM9 PRM10\",\n        \"PRM11 PRM12 PRM13 PRM14 PRM15 PRM16 PRM17 PRM18 PRM19\",\n        \"PRM20) NOPROCESS\"\n    /* COLSUM was changed for PC-side and copied back for TSO */\n    /*  to correct the TSO version.  It has not be retested on TSO */\n    /*  D.McRitchie  05/08/1997 due to unavailability */\n/*********************************************************************/\n/*   COLSUM     Calculate the sum of specified columns within        */\n/*              NX cc-range or label-range                           */\n/*********************************************************************/\n/*   F. David McRitchie, \"The REXX Macros Toolbox\", April 04, 1991   */\n/*   col-pairs (required) indicate column of numbers to be totalled  */\n/*  either lptr-range or cc-range must be used for correct results   */\n/*   lptr-range    specify lines to be included using labels         */\n/*   cc-range      specify included lines using CC-range notation    */\n/*********************************************************************/\n /* 111    333    4444  555   --  Used with builtin  testing defaults*/\n /* 222    000   -1111 -222  */\n /* -.02   000   -1111 -222  */\n/*********************************************************************/\n tok.=\"\"\n If PRM1  = '' then do;\n      ZEDSMSG = \"column pairs\"\n      ZEDLMSG = 'Column pairs are required to ',\n        ||'indicate what columns are to be added'\n      \"LINE_BEFORE .ZCSR = NOTELINE (ZEDLMSG)\"\n      Address \"ISPEXEC SETMSG MSG(ISRZ000)\"\n      RETURN 1\n End;\n Labels = 0\n Pairs = 0\n Do I = 1 to 19;\n    x = value(\"PRM\"I)\n    If substr(x,1,1) = '.' then do\n       If DATATYPE(substr(x,2),\"A\")  then do\n         If LabFrom = \"LABFROM\" then LabFrom = x\n         Else LabTo = x\n         Labels = labels + 1\n       end\n       else do\n          ZEDSMSG = \"Invalid Label(s)\"\n          ZEDLMSG = \"Labels must be alphabetic after period\"\n          Address \"ISPEXEC SETMSG MSG(ISRZ001)\"\n          EXIT 4\n       end\n    end\n    else do\n      pairs = pairs + 1\n      TOK.i  = value(\"PRM\"I)\n    end\n end\n if labels = 2 then do\n    \"(LNEBGN) = LINENUM \" LabFrom\n    \"(LNEEND) = LINENUM \" LabTo\n end\n else do\n    \"PROCESS RANGE C\"\n    rch = RC\n    If rch = 0 then do\n     \"(ZFRANGE) = LINENUM .ZFRANGE\"\n     \"(ZLRANGE) = LINENUM .ZLRANGE\"\n     labels = 2\n    End\n    Else do\n      If rch =  4  then do\n        \"(ZFRANGE) = LINENUM .ZFIRST\"\n        \"(ZLRANGE) = LINENUM .ZLAST\"\n        /*zfrange = 13; zlrange  = 15 */\n        labels = 2\n      End\n      Else do\n         \"LINE_BEFORE .ZFIRST = NOTELINE \",\n          \"'ISREDIT PROCESS C or RANGE CC return code is\" rch\"'\"\n          return 4\n      end\n    End\n    if labels \\= 2 then do\n       if labels \\= 0 then do\n        ZEDSMSG = 'Label Pair'\n        ZEDLMSG = \"Exactly two labels should comprise a\" ,\n           \"label range, not\" pairs\n        Address \"ISPEXEC SETMSG MSG(ISRZ001)\"\n        EXIT 4\n       end\n    end\n    LNEBGN = ZFRANGE\n    LNEEND = ZLRANGE\n end\n If LNEEND < LNEBGN then do\n    x = LNEBGN\n    LNEBGN = LNEEND\n    LNEEND = x\n end\n IF LNEBGN = 0 THEN LNEBGN = 1\n  \"LINE_BEFORE\" LNEBGN \"= NOTELINE \"\"\"||TIME('N')||\" START OF\",\n           \"COLSUM -- NX LINES\" LNEBGN \"TO\" LNEEND\"\"\"\"\n Do J=1 to 20; sum.J=0;end; maxj=0;\n Do I = LNEBGN to LNEEND by 1 /* while TO5 \\= \"TO5\" */\n    \"(XLINE) = LINE \" I\n    \"(XSTATUS) = XSTATUS \" I\n    If xstatus = \"NX\" then do\n       Rowtot = 0\n       Do J = 1 to 19 by 2; jp1 = J+1\n          If  DATATYPE(tok.j,\"N\")         then\n           If  DATATYPE(tok.jp1,\"N\")         then do\n             bb = tok.jp1 - tok.J + 1\n             addend = substr(XLINE,tok.J,bb)\n             If  DATATYPE(addend,\"N\")         then do\n               sum.J = sum.J + addend\n               Rowtot = Rowtot + addend\n             End\n          End\n       End\n       If Rowtot \\= 0 then\n            \"LINE_AFTER\" I \"= NOTELINE \"\"ROW total is \" Rowtot \"\"\"\"\n   End\n End\n sumtot = 0;\n\"(LASTLN) = LINENUM .zlast\"\nIf lastln \\= LNEEND then LNEEND = LNEEND + 1\n Do J=1 to 19 by  2; jp1 = J + 1;\n    If sum.J \\= 0 then do\n       sumtot = sumtot + sum.J\n       \"LINE_BEFORE\" LNEEND \"= NOTELINE \"\"\"||TIME('N') ,\n       \"SUM of NX COLS \" tok.J||\"-\"||tok.jp1||\",total is\" sum.J\"\"\"\"\n    End\nEnd\n\"LINE_BEFORE\" LNEEND \"= NOTELINE '\"||TIME('N'),\n       \"---------------Total of SUMS is \" sumtot \"'\"\n\"LINE_BEFORE\" LNEEND \"= NOTELINE \"\"\"||TIME('N')||\" -END- OF\",\n           \"COLSUM -- NX LINES\" LNEBGN \"TO\" LNEEND\"\"\"\"\n\"Loc \" LNEBGN\n\"UP 10\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPRESS": {"ttr": 5386, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00G\\x00G\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 71, "newlines": 71, "modlines": 0, "user": "MCRITCH"}, "text": "00010008PROC 1 DSNAME SHR OLD LIST NOLIST PRINT(*) VOLUME() UNIT()\n00011010IF &SHR ^= SHR THEN SET OLD = OLD\n00020007CONTROL PROMPT,NOMSG\n00030009IF &VOLUME ^= THEN DO\n00031009   SET VOLUME = VOLUME(&VOLUME)\n00031109   IF &UNIT = THEN DO\n00031209      WRITE ***** ERROR: &VOLUME SPECIFIED WITHOUT UNIT\n00031309      EXIT CODE(8)\n00031409      END\n00032009   END\n00040009IF &UNIT ^= THEN DO\n00041009   SET UNIT = UNIT(&UNIT)\n00041109   IF &VOLUME = THEN DO\n00041209      WRITE ***** ERROR: &UNIT SPECIFIED WITHOUT VOLUME\n00041309      EXIT CODE(8)\n00041409      END\n00042009   END\n00050007FREE DDNAME(SYSIN SYSPRINT SYSUT3 SYSUT4 SYSUT1) ATTRLIST(SYSIN1)\n00060007CONTROL MSG\n00070007ERROR GOTO CLEANUP2\n00080007ATTR SYSIN1 RECFM (F S) LRECL(80) BLKSIZE(80)\n00090007ALLOC DDNAME(SYSIN) NEW USING(SYSIN1) BLOCK(80) UNIT(VIO) SPACE(1)\n00100007ALLOC DDNAME(SYSPRINT) DSNAME(&PRINT)\n00110007ERROR GOTO CLEANUP1\n00120007OPENFILE SYSIN OUTPUT\n00130007IF &LIST=LIST && &NOLIST=NOLIST THEN DO\n00140007  SET LIST=\n00150007  SET NOLIST=\n00160007  WRITENR LIST AND NOLIST ARE EXCLUSIVE -- ENTER THE CORRECT VALUE:\n00170007  READW: READ &WHICH\n00180007  SET &LW=&LENGTH(&WHICH)\n00190007  IF &LW<=6 THEN +\n00200007    IF &SUBSTR(1:&LW,&WHICH)=&SUBSTR(1:&LW,NOLIST) THEN SET NOLIST=NOLIS\n00210007  IF &LW<=4 THEN +\n00220007    IF &SUBSTR(1:&LW,&WHICH)=&SUBSTR(1:&LW,LIST) THEN SET LIST=LIST\n00230007  IF &LIST=&STR() && &NOLIST=&STR() THEN DO\n00240007    WRITENR WHAT?\n00250007    GOTO READW\n00260007    END\n00270007  END\n00280007IF &LIST=LIST THEN SET &LISTNO=&STR()\n00290007ELSE SET &LISTNO=&STR(,LIST=NO)\n00300007SET SYSIN=&STR( COPY OUTDD=SYSUT1,INDD=SYSUT1&LISTNO)\n00310007PUTFILE SYSIN\n00320007CLOSFILE SYSIN\n00330007ERROR GOTO CLEANUP2\n00340011ALLOC DDNAME(SYSUT3) CYL SPA(1 1) UNIT(VIO)\n00350011ALLOC DDNAME(SYSUT4) CYL SPA(1 1) UNIT(VIO)\n00360010ALLOC DDNAME(SYSUT1) DA(&DSNAME) &SHR &OLD &VOLUME &UNIT\n00370007SET MAXCC=0\n00380007CONTROL NOFLUSH\n00381007ERROR DO\n00382007  ERROR GOTO CLEANUP2\n00382107  CONTROL MSG\n00382207  CALL 'SYS1.LINKLIB(IEBCOPY)'\n00382307  GOTO CLEANUP2\n00383007END\n00383107CONTROL NOMSG\n00384007TSOEXEC TIME\n00386007ERROR GOTO CLEANUP2\n00387007CONTROL MSG\n00390007TSOEXEC CALL 'SYS1.LINKLIB(IEBCOPY)'\n00400007GOTO CLEANUP2\n00410007CLEANUP1: ERROR GOTO CLEANUP2\n00420007CLOSFILE SYSIN\n00430007CLEANUP2: ERROR GOTO CLEANUP3\n00440007FREE DDNAME(SYSIN SYSPRINT SYSUT3 SYSUT4 SYSUT1) ATTRLIST(SYSIN1)\n00450007CLEANUP3: ERROR EXIT CODE(&MAXCC)\n00460007ALLOC DDNAME(SYSIN) DSNAME(*)\n00470007ALLOC DDNAME(SYSPRINT) DSNAME(*)\n00480007EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COMPUTE": {"ttr": 5389, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\r\\x00\\r\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "MCRITCH"}, "text": "/*REXX Compute a formula by REXX rules.  e.g  TSO COMPUTE d2x(111111)     */\n/*  Example -- COMMAND ===> TSO COMPUTE d2x(111111)                       */\n/* From an article in Chicago Soft Ltd -- \"TSO TIMES\" issue #5       ---  */\n/*   by Normal Pearl  $250 contest winner for short REXX execute.    ---  */\nparse Arg Formula\nInterpret 'Result = ' Formula\nIf SYSVAR('SYSISPF') = 'ACTIVE'           /* ISPF Environment?            */\n   Then Do                                /* Display as msg if so         */\n        ZEDSMSG = Result/*  short message upper right   */\n        ZEDLMSG = Formula '==>' Result    /*  use help to see long message*/\n        'ISPEXEC SETMSG MSG(ISRZ001)'\n        End\n   Else Say Formula '==>' Result  /* Not ISPF, write to terminal          */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COPY": {"ttr": 5391, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x0c\\x00\\x0c\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "MCRITCH"}, "text": "00001001 PROC 2 FROM TO SHR OLD\n00001101 CONTROL NOMSG\n00002001 FREE FI(SYSUT1 SYSUT2 SYSPRINT)\n00002101 CONTROL MSG\n00002501 ALLOC FI(SYSPRINT) DA(*)\n00003001 ALLOC FI(SYSUT1) DA(&FROM) SHR\n00004001 ALLOC FI(SYSUT2) DA(&TO) &SHR &OLD\n00005001 ALLOC FI(SYSIN) DUMMY REUSE\n00006001 CALL 'SYS1.LINKLIB(IEBGENER)'\n00007001 FREE FI(SYSUT1 SYSUT2)\n00008001 ALLOC FI(SYSIN) DA(*) REUSE\n00009001 ALLOC FI(SYSPRINT) DA(*) REUSE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COPYR": {"ttr": 5393, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x18\\x00\\x18\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "MCRITCH"}, "text": "********************************************************************\n\n  COPYRIGHT (C) BY  F. DAVID MCRITCHIE.  ALL RIGHTS RESERVED.\n\n  The material contained in this library is a part of a collection of\n  coding and documentation.\n\n  Particular license is granted to distribute these programs as part\n  of the CBT collection where a small service charge for distribution\n  is appropriate.\n\n  My name must remain with the coding.\n\n  Commercial distribution and for sale distribution by anyone other\n  than the author is expressly prohibited.\n\n  The material in this library may also be available and located\n  from my website.\n      \"The REXX Macros Toolbox\" which can be found at\n      http://members.aol.com/dmcritchie/home.htm\n\n                               F. David McRitchie\n                               Email: DMcRitchie@aol.com\n********************************************************************\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CPUID": {"ttr": 5395, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x81\\x00\\x81\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 129, "newlines": 129, "modlines": 0, "user": "MCRITCH"}, "text": "/*  CPUID -- Display CPU information from REXX                       */\n/*      article in TSO TIMES, Fall 1993, by John Andrisan            */\n/*      of IBM ISSC subdivision in Long Beach California             */\n/*********************************************************************/\n/* A TSO REXX Exec to get information aobut CPUs from the MVS        */\n/* control blocks: DVT, SMCA, CSD, PCCAVT, and PCCA; then show CPU   */\n/* number, id serial number, type, SMF id letter, and anything else  */\n/* that looks interesting.                                           */\n/*                                                                   */\n/* The control block chain that I want to follow:                    */\n/*   location 10x --> CVT                                            */\n/*        CVT+C4x  -->  SMCA                                         */\n/*            SMCA+16 contains the SMF id                            */\n/*        CVT+294x -->  CSD                                          */\n/*            CSD+4, +8 and + 10 contain                             */\n/*              some interesting cpu counts                          */\n/*        CVT+2FCx -->  PCCAVT                                       */\n/*            PCCAVT+0   -->  PCCA for CPU 0                         */\n/*            PCCAVT+4   -->  PCCA for CPU 1                         */\n/*            ... etc.                                               */\n/*            PCCAVT+60  -->  PCCA for CPU 15                        */\n/*            PCCA+4   contains the cpu id, serial#, type            */\n/*            PCCA+24    -->  virtual PSA                            */\n/*            PCCA+28    -->  real PSA                               */\n/*********************************************************************/\n/* ---------begin available \"The REXX Macros Toolbox\" only portion*/\n   \"CLS\"  /* clear screen*/\n   say '----- information obtained via  WHICH CPU ------'\n  \"WHICH CPU\"\n   say ' '\n   say '----- information from CPUID -- Display CPU information'\n/* ------------ end available \"The REXX Macros Toolbox\" only portion*/\narg what .\nif what='?' then do  /* offer the user some help */\n     say '  use: COMMAND ===> CPUID'\n     say '     No parms are required'\n     say '  You will be shown the SMF id letter defining this system,'\n     say '     the CPU id, serial number, and CPU type of each CPU,'\n     say '  This exec (CPUID) only works on TSO.'\nend\nif address() /='TSO' then do\n   say 'This exec only works in MVS/TSO.'\n   exit 4\nend\ncall init            /* set up some constants */\nCVT=storage('10',4)\nCVT=bitand(CVT,'7FFFFFFF'x)   /* zero high bit */\nSMCA=storage(d2x(c2d(CVT)+x2d('C4')),4)    /* get to SMCA */\nSMCA=bitand(SMCA,'7FFFFFFF'x)\nSMCASID=storage(d2x(c2d(SMCA)+16),4)\nsay 'SMF id=' SMCASID\nCSD=storage(d2x(c2d(CVT)+x2d('294')),4)     /* get to CSD    */\nCSD=bitand(CSD,'7FFFFFFF'x)                 /* zero high bit */\n               /* the counts shown next may change whil you run*/\nnr_cpus=c2d(storage(d2x(c2d(CSD)+10),2))    /* get nr cur alive */\nsay 'nr cpus currently alive:' nr_cpus      /* whatever that is */\njob_avail_cpus=x2b(c2x(storage(d2x(c2d(csd)+4),2)))\nsay count_bits(job_avail_cpus) 'available for jobs'\nsrb_avail_cpus=x2b(c2x(storage(d2x(c2d(csd)+8),2)))\nsay count_bits(srb_avail_cpus) 'available for srbs'\ncur_alive_cpus=x2b(c2x(storage(d2x(c2d(CSD)+10),2)))\nsay count_bits(cur_alive_cpus) 'currently alive'\nsay ' '\nPCCAAVT=storage(d2x(c2d(CVt)+x2d('2FC')),4)  /* get to PCCAVT */\nPCCAAVT=bitand(PCCAAVT,'7FFFFFFF'x)             /* zero high bit*/\n\nsay '-----CPU--------------  PSA       PSA              '\nsay '#  ver id serial  type  vaddr     raddr     status:'\ndo i=0 to 60 by 4\n   PCCA=storage(d2x(c2d(PCCAAVT)+i),4)     /* get the i-th PCCA */\n   PCCA=bitand(PCCA,'7FFFFFFF'x)             /* zero high bit */\n   if PCCA=='00000000'x then iterate i    /* avoid empty entry */\n   info=storage(c2x(PCCA),32)\n   if substr(job_avail_cpus,i%4+1,1)='1' then jobs='jobs'\n   else jobs='no-jobs'\n   if substr(srb_avail_cpus,i%4+1,1)='1' then srbs='srbs'\n   else jobs='no-srbs'\n   if substr(cur_alive_cpus,i%4+1,1)='1' then alive='alive'\n   else alive='no-alive'\n   /*       as run \"The REXX Macros Toolbox\" 1993/12/16\n   SMF id= H901\n   nr cpus currently alive: 5\n   5 available for jobs\n   5 available for srbs\n   2 currently alive\n\n   -----CPU--------------  PSA       PSA\n   #  ver id serial  type  vaddr     raddr     status:\n   00  52  0 12495   3090  8000F6F0  00157240  jobs srbs no-alive\n   01  52  1 12495   3090  7800F9F0  00134030  jobs srbs no-alive\n   02  52  2 12495   3090  0000F980  0002F040  jobs srbs no-alive\n   03  52  3 12495   3090  0000F960  00068040  jobs srbs no-alive\n   04  52  4 12495   3090  1000F7F0  000A2040  jobs srbs no-alive\n   05  a:  9 &             00070C30  0080007B  no-srbs srbs no-alive\n     */\n   say ,\n       /*cpu number:*/ right(i%4,2,'0')' ',\n       /*cpu ver :  */ substr(info,5,2)' ',\n       /*cpuid:     */ substr(info,7,1),\n       /*cpu serial:*/ substr(info,8,5)'  ',\n       /*cpu type:  */ substr(info,13,4)' ',\n       /*PSA vaddr:*/  c2x(substr(info,24,4))' ',\n       /*PSA raddr:*/  c2x(substr(info,28,4))' ',\n             /* the status shown next may change while you run*/,\n       /*status:*/    jobs srbs alive\nend\nexit 0\n/* ------------------- subroutines ---------------------- */\ncount_bits:\n  arg bit_string .\n  bit_sum = 0\n  do bit=1 to length(bit_string)\n    if substr(bit_string,bit,1)='1' then bit_sum=bit_sum + 1\n  end\n  return(bit_sum)\n  X2B:  /* X2B is a function for hex to binary string conversion*/\n  arg arg .\n  bitout=''\n  do i=1 to length(arg)\n      t=substr(arg,i,1)\n      bitout=bitout||hex.t\n  end\n  return bitout\n  init:  /* constants needed in x2b */\n  hex.0='0000'; hex.1='0001'; hex.2='0010'; hex.3='0011';\n  hex.4='0100'; hex.5='0101'; hex.6='0110'; hex.7='0111';\n  hex.8='1000'; hex.9='1001'; hex.A='1010'; hex.B='1011';\n  hex.C='1100'; hex.D='1101'; hex.E='1110'; hex.F='1111';\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CSON": {"ttr": 5633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x006\\x006\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "MCRITCH"}, "text": "/* CSON:   NX the .cs on/of ranges in DCF material       (REXX)*/\n/*********************************************************************\n MACRO:     Reformat lines of data\n PURPOSE:   Reformat data in edit\n EXAMPLES:\n   CSON 6\n   CSON 6 9\n RELATED:  TAGX, LABNX\n***********************************************************************\n  CSON      Author: David McRitchie, created 1994/05/19 is03\n            at \"The REXX Macros Toolbox\", DMcRitchie@aol.com\n            \"The REXX Macros Toolbox\"\n    \"The REXX Macros Toolbox\"\n  *******************************************************************/\n Address 'ISREDIT';'MACRO (token)'\n 'x all'\n if token = '' then token = '1 2 3 4 5 6 7 8 9 0'\ndo i = 1 to words(token)\n   \"seek first p'=' 1\"\n   do forever\n    \"find word '.cs\" word(token,i)\" on'\"\n    if rc \\= 0 then leave\n    \"label .zcsr = .beg 1\"\n    \"find word '.cs\" word(token,i)\" off'\"\n    if rc \\= 0 then do\n      \"line_before .zf = noteline\",\n        \"\"\"Last  .cs\" word(token,i) \"on -- is not matched with off\"\"\"\n        \"reset .beg .beg x\"\n        \"line_after .beg = msgline \",\n        \"\"\"Last  .cs\" word(token,i) \"on -- is not matched with off\"\"\"\n        leave\n    end\n    \"reset .beg .zcsr x \"\n   end\n   \"seek word x '.cs\" word(token,i)\" off'\"\n   if rc = 0 then do\n      \"line_before .zf = noteline\",\n        \"\"\"Last  .cs\" word(token,i) \"on -- is not matched with off\"\"\"\n      \"line_after .zcsr = noteline\",\n        \"\"\"Last  .cs\" word(token,i) \"on -- is not matched with off\"\"\"\n   end\nend\n/*  test\n.cs 3 on\n.*******\n.cs 3 off\n.************\n.cs 2 off\n.cs 1 on\n.*******\n.cs 1 off\n.************\n.cs 2 off\n****************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CUT": {"ttr": 5635, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xcc\\x00\\xcc\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 204, "newlines": 204, "modlines": 0, "user": "MCRITCH"}, "text": "/*CUT:      Cut portions of file in EDIT                    (REXX)   */\n/*CUT:      Author: David McRitchie, \"The REXX Macros Toolbox\"          */\n/*     1994/04/07 Converted to REXX from specs in use since 1991/12/24 */\n/*     1994/06/24 Ability to used numbered CUTDSN## datasets         */\n/*-------------------------------------------------------------------*/\n/*       Macro:   CUT            (CUTR  for SPF/PC usage)            */\n/*       Purpose: Cut CC-Range and/or NX lines into                  */\n/*                userid.CUTDSN.LIST for later use with PASTE macro. */\n/*       Companion Macros: APPEND, PASTE   --  spf/pc APPENDR, PASTER*/\n/*       Related Macros:   CUTD, CUTDD, REFORMAT                     */\n/*********************************************************************/\n/* Highlights: This set of CUT/APPEND/PASTE macros will mark the     */\n/*   changes in the affected file with NOTELINEs.  This allows easy  */\n/*   comparison between old material and new material, etc.  Some    */\n/*   other versions of CUT/APPEND/PASTE use ISPF variables causing   */\n/*   serious problems with your profile dataset when large files are */\n/*   copied.  This will not happen with these macros, also your data */\n/*   being in a distinct dataset is protected across logons/crashes. */\n/*   Written in REXX readily permits later customizations.           */\n/*   Other cut/paste macros: NaSPA 0004, CBT 95, 161, 168, 194, 270  */\n/*********************************************************************/\n/*  THIS EDIT MACRO CLIST AND ITS COMPANIONS                         */\n/*                                                                   */\n/*  CUT ---------- ** THIS EDIT MACRO ** ------------                */\n/*     Take selected lines specified by the user and copy/move       */\n/*     them to a sequential work dataset used later by the paste     */\n/*     command.                                                      */\n/*  APPEND ------- ** COMPANION EDIT MACRO ** -------                */\n/*    Will append additional information a header will be created,   */\n/*    and information will be appended to your cut dataset.          */\n/*  PASTE -------- ** COMPANION EDIT MACRO ** -------                */\n/*    Take the output dataset created by cut and move it to          */\n/*    anywhere in the current dataset being edited.                  */\n/* Options of CUT and APPEND  (all options are optional)             */\n/*    CC-range -- restrict selected lines -- normal usage            */\n/*    NX   -- Include only NX lines within CC-Range or entire range  */\n/*    DOC  -- (opt.) document with date/timestamp and source dsn.    */\n/*    NX       Copy NX lines,  CC-range becomes optional             */\n/*    EDIT     edit the paste dataset                                */\n/*    ? |HELP  Show help information                                 */\n/*    ##   -- 1 or 2 digit number  to cut into a different dsn       */\n/*             i.e.   userid.CUTDSN##.LIST                           */\n/* Options of PASTE ---------------------------------                */\n/*    KEEP -- Keep work dataset, default is to delete work file      */\n/*    COL(nn),VALUE(xxxx) -- include only lines with value in col nn */\n/*    (member),  paste member from permanent pds PASTE library       */\n/*    ##   -- 1 or 2 digit number  to paste from a different dsn     */\n/*             i.e.   userid.CUTDSN##.LIST                           */\n/* WARNINGS: ----- WARNINGS -------------------------                */\n/*    The CUT file attributes are based on the original file cut --  */\n/*    you may lose later information added if the recordsize is      */\n/*    larger than the original -- especially for fixed records.      */\n/*    m<n> or mm line options will alter your dataset by removing    */\n/*    lines.      Other cut/paste clists may eat up your profile     */\n/*    dataset, this clist uses a work file and therefore does not    */\n/*    affect your profile.                                           */\n/*                                                                   */\n/*  EXAMPLE :                                                        */\n/*     CUT     USE   CC  OR MM LINE RANGE,  OR C<N> OR M<N>          */\n/*     APPEND  USE   CC  OR MM LINE RANGE,  OR C<N> OR M<N>          */\n/*     PASTE   USE   B   OR A   LINE RANGE                           */\n/*********************************************************************/\n/* NOTE:  QWPASTE MUST BE USED WHEN USING PASTE FACILITIES OF       */\n/*        MVS/QUICKREF 3.2 INVOKED VIA QW.                          */\n/*********************************************************************/\n/*                                                                   */\n    address \"ISREDIT\";\"MACRO (TOKEN) NOPROCESS\"\n    possible=0; copied=0;other=\"\";CUTDSNnn=\"CUTDSN\"\n    token = ' 'translate(token)' '\n    i=pos(' HELP ',token); if i=0 then i=pos('?',TOKEN);\n    if i \\= 0 then do; address \"TSO\" \"CLIST CUT HELP\"; exit 1;end;\n    i =pos(' NX ',token)\n    if i \\= 0 then do;nxopt=1;\n       token = substr(token,1,i-1)||substr(token,i+3)\n    end; else nxopt = 0\n    i =pos(' DOC ',token)\n    if i \\= 0 then do;docopt=1;\n       token = substr(token,1,i-1)||substr(token,i+4)\n    end; else docopt = 0\n    i =pos(' EDIT ',token)\n    if i \\= 0 then do;editopt=1;\n       token = substr(token,1,i)||substr(token,i+6)\n    end; else editopt = 0\n    remaining = strip(token)\n    if remaining \\= \"\" then do\n       if datatype(remaining,'N') = 1 then do\n          other = remaining + 0; remaining=\"\"\n          CUTDSNnn = CUTDSNnn||other\n       end\n    end\n    if remaining \\= \"\" then do\n       ZEDSMSG = \"unknown\" remaining\n       ZEDLMSG = remaining \"-- unknown to CUT/APPEND/PASTE\"\n       ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    end\n    zedsmsg = '**';zedlmsg='**'\n    \"(rowx,colx) = cursor\"\n    qcnt = 0\n    q.=\"\"\n    ADDRESS 'ISREDIT' '(DSN) = DATASET'\n    ADDRESS 'ISREDIT' '(MEMBER) = MEMBER'\n    parse version v1 v2 v3 v4 v5\n    if v1 = \"REXXSAA\" then do  /* obtain membername */\n       do i = 1 to 8\n          parse var member left '\\' right\n          if right \\= \"\" then member = right\n       end\n       parse var member member '.' right\n       dochdr = dsn\n    end\n    if member = \"\" then dochdr=\"-----\" dsn\n    else dochdr=strip(dsn)\"(\"strip(member)\")\"\n    first = 99999999; last = 00000000;\n    Address \"ISPEXEC\" \"CONTROL ERRORS RETURN\"\n    \"PROCESS RANGE C M\"\n    rcx=rc\n    \"(RANGE) = RANGE_CMD\"\n    Address \"ISPEXEC\" \"CONTROL ERRORS CANCEL\"\n    if rcx > 4 then do\n       ZEDSMSG = ZERRSM\n       ZEDLMSG = ZERRMSG ZERRLM \"RC=\"rcx\n       Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n       exit rcx\n    end\n    LABF = \".ZFRANGE\"\n    LABL = \".ZLRANGE\"\n    \"(first) = linenum .zfrange\"\n    \"(last) = linenum .zlrange\"\n    if docopt = 1 then qcnt = 2 /* will fill in later*/\n    do i = first to last\n       possible= possible+1\n       if nxopt = 1 then do\n          address \"ISREDIT\" \"(xstatus) = xstatus\" i\n          if xstatus \\= \"NX\" then iterate i\n       end\n       address \"ISREDIT\" \"(line) = line\" i\n       qcnt=qcnt+1; q.qcnt = line\n       copied = copied + 1\n    end\n    q.0 = qcnt\n    if docopt = 1 then do\n       if nxopt = 1 then\n       q.1 = left('.***',40) \"Copied\" copied \"of\" possible\n       else q.1 = '.***'\n       q.2 = '.***' date(\"U\") time() dochdr '-- Lines',\n           strip(first,'l','0')'-'strip(last,'l','0')\n    end\n    if v1 = \"REXX370\" then call mainframe\n    if v1 = \"REXXSAA\" then call PComputer\n    if range  = \"M\" then do;\n       address \"ISREDIT\"\n       \"delete\" first last\n       var1=first-1; var2=last-first+1;\n       \"line_after\"      var1 \"= noteline \"\"\"time() \"CUT    --\",\n           var2 \"lines removed and placed into \"CUTDSNnn\"\"\"\"\n       \"line_before .zfirst = msgline \"\"\"time() \"CUT    --\",\n           var2 \"lines removed and placed into \"CUTDSNnn\"\"\"\"\n    end\n    /* would be nicer to report the visible line number */\n    if range  = \"C\" then do;\n       address \"ISREDIT\"\n       \"line_before\" first \"= noteline \"\"\"time() \"start CUT   --\" copied,\n           \"lines\" \"copied to \"CUTDSNnn\", lines(\"||,\n           strip(first,\"l\",\"0\")\"-\"strip(last,\"l\",\"0\")\")\"\"\"\n       \"line_after\" last  \"= noteline \"\"\"time() \"-end- CUT   --\" copied,\n           \"lines\" \"copied to \"CUTDSNnn\", lines(\"||,\n           strip(first,\"l\",\"0\")\"-\"strip(last,\"l\",\"0\")\")\"\"\"\n       \"line_before .zfirst    =  msgline \"\"\"time() \" CUT    --\" copied,\n           \"lines\" \"copied to \"CUTDSNnn\", lines(\"||,\n           strip(first,\"l\",\"0\")\"-\"strip(last,\"l\",\"0\")\")\"\"\"\n    end\n    if editopt = 1 then do\n       if v1 = \"REXX370\" then     address \"TSO\" \"$EDIT\" CUTDSN\n       if v1 = \"REXXSAA\" then address \"cmd\" \"spf2\" cutdsn \"/X\"\n    end\n  return  0\n  mainframe: procedure expose q.  qcnt CUTDSN autoedit editopt other,\n           CUTDSNnn;\n    userid = SYSVAR('SYSUID')\n    userid = strip(sysvar('sysuid'))\n    prefix = strip(sysvar(syspref)); if prefix='' then prefix=userid\n    CUTDSN = \"'\"prefix\".CUTDSN\"||other||\".list'\"\n      /* i.e.   userid.CUTDSN.LIST */\n    test = SYSDSN(CUTDSN)\n    status = msg('off')\n    if test = \"OK\" then address \"TSO\" \"DEL\" CUTDSN\n    status = msg('on')\n    Address \"TSO\" ,\n     'ALLOC FI(CUTDSN) NEW CAT SPACE(45 45) TRACKS UNIT(SYSDA)' ,\n       'LRECL(255) RECFM(V B M) BLKSIZE(3156)' ,\n       \"DSN(\"CUTDSN\") REUSE\"\n    status = msg('off')\n    Address \"TSO\" \"EXECIO * DISKW CUTDSN (STEM Q. FINIS\"\n    address \"TSO\" \"FREE FILE(CUTDSN)\"\n    return\n  PComputer: procedure expose q.  qcnt CUTDSN nxopt CUTDSNnn;\n    /* macros named cutR, appendR, pasteR */\n    CUTDSN = \"c:\\junk\\\"CUTDSNnn\".dat\"\n    stream(cutdsn,'C',\"CLOSE\") /* close the file*/\n    address \"CMD\" \"DEL\" cutdsn\n    do i=1 to qcnt; call lineout CUTDSN, q.i;end;\n    call lineout CUTDSN    /* close file*/\n    stream(cutdsn,'C',\"CLOSE\") /* close the file*/\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DCFBOX": {"ttr": 5639, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00@\\x00@\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "MCRITCH"}, "text": "/***********************************************************REXX******/\n/*  DRAW A BOX AROUND DCF (SCRIPT/VS) LINES (COMMENT THEM OUT)       */\n/*  MODIFIED FROM CBT TAPE #9102 -- FILE095 MEMBER CLISTBOX          */\n/* *******************************************************************/\n/*  USED CLIST WITH PENDING    ADD-LINES, WITH THE RESULT            */\n/*  THAT    ISPF SESSION ABENDED.   WAITING ON PENDING COMMANDS      */\n/*  IS A REQUIREMENT OF THIS CLIST -- APPEARS NOT TO RECUR           */\n/* *******************************************************************/\n/*  ADDED NOTELINES -- D.MCRITCHIE    1991/05/10, TO REXX 1993/06/11 */\n/* *******************************************************************/\n/*********************************************************************/\n   ADDRESS \"ISREDIT\";\"MACRO (HELP) NOPROCESS\"\n   IF HELP = \"?\" THEN DO\n      /*ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(DCFBOX)\"*/\n      CLIST DCFBOX HELP\n      EXIT\n   END\n   STARS = SUBSTR('*',1,64,'*')\"*\"\n   \"PROCESS RANGE C\"\n   LCC = RC\n   \"(RCMD) = RANGE_CMD\"\n   IF RC = 4 | RCMD \\= \"C\" THEN DO\n      ZEDSMSG = \"NO RANGE SPECIFIED\"\n      ZEDLMSG = \"YOU MUST SPECIFY A RANGE OF LINES TO BE BOXED\",\n          \"USING A \"\"C<N>\"\" OR \"\"CC\"\"\"\n      ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ001)\"\n      EXIT 4\n   END\n   \"(FIRST) = LINENUM .ZFRANGE\"\n   \"(LAST) = LINENUM .ZLRANGE\"\n   \"(FR) = LINENUM .ZFRANGE\"\n   \"(LR) = LINENUM .ZLRANGE\"\n/*********************************************************************/\n/*    THIS IS A STARRY BOX CREATED BY THE DCFBOX CLIST               */\n/*********************************************************************/\n   \"LINE_BEFORE .ZFRANGE = NOTELINE \"\"\"TIME() \"START OF\",\n      \"DCFBOX -- LINES\" FR \"TO\" LR \"\"\"\"\n   \"LINE_AFTER         .ZLRANGE = NOTELINE \"\"\"TIME() \"-END OF-\",\n     \"DCFBOX -- LINES\" FR \"TO\" LR \"\"\"\"\n  \"(LBO,RBO) = BOUNDS\"\n  \"BOUNDS 1 72\"\n\n  DO C = FR TO LR\n    \"SHIFT )\" C \"3\"\n  END\n  \"MASKLINE = \"\".\"||\"*****\"STARS\"\"\"\"\n  \"LINE_BEFORE\" FIRST \"= MASKLINE\"\n\n  DO I = FR TO LR\n    \"LABEL\" I \"= .LJ\"\n    \"SEEK P'^' .LJ .LJ\" LBO  RBO \"FIRST\"\n    \"SEEK P'^' .LJ .LJ\" LBO  RBO \"LAST\"\n    \"CHANGE P'===' '.\"||\"* ' 1\"\n    /*\"CHANGE P'==' '*\"||\"/' 70\"*/\n    IF  I =  FR THEN \"LABEL\" I \"= .LJX\"\n  END\n\n  \"SEEK P'=' .LJX .LJX FIRST\"\n  \"MASKLINE = \"\".\"||\"*****\"STARS\"\"\"\"\n  LAST =  LAST + 1\n  \"LINE_AFTER\" LAST \"= MASKLINE\"\n  \"MASKLINE = ' '\"\n  \"BOUNDS         \" LBO\",\"RBO\n  EXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DCFMSGS": {"ttr": 5641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xeb\\x00\\xeb\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 235, "newlines": 235, "modlines": 0, "user": "MCRITCH"}, "text": "/*DCFMSGS -- Place DCF error messages after  line in error.   (REXX) */\n/*  F. David McRitchie, \"The REXX Macros Toolbox\", 1993/10/14        */\n/*  Concept modeled after  SPELL macro by William Horton CBT-103     */\n/*  Will invoke  @SCRIPT  and read back in userid.S9999.LIST         */\n/*  If @SCRIPT Q  -- has already been invoked then ..                */\n/*     ===> DCFMSGS @SCRIPT                                          */\n/*  If @SCRIPT Q  -- has already been invoked then ..                */\n/*     ===> DCFMSGS @SCRIPT                                          */\n/**********************************************************************/\n/*  PARM OPTIONS are same as for @SCRIPT                              */\n/*    @SCRIPT       bypass formatting, no other options are supplied  */\n/*    FP(1)         do not include as this will be included, for you  */\n/**********************************************************************/\n/*   NORMAL USAGE WITHOUT ANY PARAMETERS                              */\n/*      @SCRIPT will be invoked, all lines will be undisplayed,       */\n/*         lines in error will be redisplay.  Error messages merged.  */\n/*-------------------------------------------------------------------*/\n    ADDRESS 'ISREDIT';'MACRO (PARM)'\n   /***********************************/\n    \"ISREDIT (DCHG) = DATA_CHANGED\"\n    IF DCHG = \"YES\" then if document /= \"DOC\" then do\n     SAY '*************************************************************'\n     SAY '*     YOUR FILE HAS NOT BEEN SAVED AFTER MAKING CHANGES     *'\n     SAY '*                                                           *'\n     SAY '* CANNOT SCRIPT UNLESS YOU SAVE -- Hit enter to terminate   *'\n     SAY '************************* -- OR -- **************************'\n     SAY ' REPLY <ENTER KEY> or type in \"CAN\" to terminate request'\n     SAY ' REPLY \"SAVE\"   | \"SAV\" to save then @SCRIPT saved version'\n     SAY ' REPLY \"CANCEL\" | \"CAN\" if you doo not want to @SCRIPT' ,\n                 'at this time'\n     pull PARM1;parm1 = translate(parm1)\n     if SUBSTR(PARM1,1,3) /= \"SAV\" then do ;\n       \"LINE_BEFORE .ZFIRST = NOTELINE \"\"Not SCRIPTing UNSAVED data\"\"\"\n        ZEDLMSG = \"Data Has not been SAVED -- NOT SCRIPTED\"\n        ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\";Return 1\n     end\n     \"@SAVE\"\n     if rc > 1 then do\n       \"LINE_BEFORE .ZFIRST = NOTELINE \"\"SAVE before SCRIPT failed\"\"\"\n       return\n     end\n   end\n   /*********************************************************************/\n    mnote = \"MSGLINE\" /* until DSMDEB323i -- then NOTELINE*/\n    parm = translate(parm)\n    if parm= \"QUICK\"  | parm = \"@SCRIPT\" ,\n       then do;parm='';quick=\"QUICK\";end; else quick='NO'\n    dsm_swt = 0\n    \"reset special\"\n    qcnt = 0\n    q.=''\n    p.='';p.0 = 0\n    ZEDSMSG =\n    ZEDLMSG = '** ERROR location in progress **'\n    ADDRESS 'ISPEXEC' 'CONTROL DISPLAY LOCK'\n    ADDRESS 'ISPEXEC' 'DISPLAY MSG(ISRZ000)'\n    '(dataset) = DATASET'\n    '(MEMBER) = MEMBER'\n    SYSUID = SYSVAR('SYSUID')\n    /*reject special sop usage where current member invoked by Annnn*/\n\n    sstring = \"'\"strip(member)\"'\"\n    REJECT1 = 'DSMMOM397I' SSTRING 'WAS IMBEDDED AT'\n    before = 2\n    after  = 1\n    /* TSO dataset conventions for use w/o quotes */\n\n    if quick=\"QUICK\" then signal quick\n    /* Invoke SCRIPT/VS */\n    if parm = \"\" then do\n      userid = SYSVAR('sysuid')\n      if member = \"\" then dsname = dataset\n      else dsname = dataset'('strip(member)')'\n      address \"TSO\" \"SCRIPT '\"dsname\"' \",\n        \" PRO('SCRIPT.r40.MACLIB(DSMPROFL)') LIB('SCRIPT.r40.MACLIB')\",\n        \" FO('SYS1.prod.FONTLIB')INDEX SEG('SYS1.prod.PSEGLIB')\",\n        \" DEV(1403W6) CO FP(1)SYS(X NO H NO D YES ) M(ID TRACE DELAY)\",\n        \" FILE('\"userid\".S9999.LIST') B(0 0) SP\"\n    end;\n    else do\n    \"(line) = linenum 1\"\n    i = pos('FP(1)',line)\n    if i = 0\n     then \"@SCRIPT Q FP(1)\" parm\n     else \"@SCRIPT Q\" parm\n    end;\n /****************************************************/\n\n  quick:\n    ZEDSMSG =\n    ZEDLMSG = '** ERROR LOCATION IN PROGRESS ** -- FINAL PHASE'\n    ADDRESS 'ISPEXEC' 'CONTROL DISPLAY LOCK'\n    ADDRESS 'ISPEXEC' 'DISPLAY MSG(ISRZ000)'\n\n    \"reset\";\"x .zf .zl ' ' all\"\n    \"(hiline) = linenum .zlast\"\n\n    EOF = 'NO'\n    MISSPELLED = 0\n    Address \"TSO\" \"ALLOC FI(infile)\",\n            \"DSN('\"SYSUID\".S9999.LIST') OLD REUSE\"\n    q.='';p.='';p.0=0\n    ADDRESS 'TSO' 'EXECIO * DISKR infile (STEM Q. FINIS'\n    if q.0 = 0 then do\n       \"line_before .zf = msgline \"\"'\"SYSUID\".S9999.lIST'  is empty\"\"\"\n       lbzf=\"line_before .zf = noteline\" /*reduce continuation lines*/\n       lbzf \"\"\"Try again by issuing...         \"\"\"\n       lbzf \"\"\"   ===> @SCRIPT Q                \"\"\"\n       lbzf \"\"\"   ===> pfk-3 to return to member\"\"\"\n       lbzf \"\"\"   ===> DCFMSGS @SCRIPT          \"\"\"\n       lbzf \"\"\" --------- or -----------------\"\"\"\n       lbzf \"\"\"   ===> DCFMSGS                  \"\"\"\n       return 4\n    end\n\n    /*------------------------------------------------------*/\n    /* Read SCRIPT error messages and create MSG records to */\n    /* show user which card images have misspelled words.   */\n    /*------------------------------------------------------*/\n    /* aaaa aabb aaBB aacc aaCC aaff aagg aahh aaii aajj aakk*/\n\n    dcfrec='';p.='';p.0=0\n    EOF = 'NO'\n    call getpack\n    do while (p.0 \\= 0)\n       after = before - 1\n       address 'ISREDIT' 'LABEL' after  '= .after'\n       address 'ISREDIT' 'LABEL' before '= .before'\n       'reset .after  .after'\n       do i = 1 to p.0;\n          record = p.i\n          record=strip(substr(record,2))\n          'LINE_BEFORE .before  = 'mnote' (record)'\n       end\n       p.0=0\n  /*   if EOF \\= 'NO' then return 0 */\n       if EOF = 'NO' then call getpack\n    END\nreturn 0\n\nDCFINPUT:\n   qcnt=qcnt+1; q.qcnt  = dcfrec\n   Return\nGETPACK:\n   if EOF \\= 'NO' then return\n   p='';p.0 = 0\n   more:\n   call getrec;\n   msg = substr(dcfrec,2,10)\n   msgtext = substr(dcfrec,2)\n   if reject1 = substr(dcfrec,2,length(reject1)) then signal more\n   if msg ='' then signal more;\n   if EOF \\= 'NO'  then return\n   p0 = p.0 + 1; p.p0 = dcfrec; p.0 = p0;\n   if substr(msg,1,3) = 'DSM' then dsm_swt = 1;\n   if substr(msg,1,4) = '*M* ' then dsm_swt = 1;\n   if dsm_swt = 0 then do; p.0=0; signal more; end;\n   select;\n     when msg = 'DSMBEG323I' then do\n        mnote = \"NOTELINE\"\n        signal more\n      end\n     when msg = 'DSMMOM395I' then do\n        igp = pos(sstring,dcfrec)\n        if igp /= 0 then do\n           parse var dcfrec  left ' LINE ' after  ':' right\n           before = after + 1\n        end\n        else \"line_before\" before \" = noteline\",\n           \"'---actual line in error (below) may be hidden in a macro'\"\n        if before > hiline then before = hiline\n        if before < 2     then before = 2\n        call look_ahead;  /* check for continuations */\n        return 0\n      end\n     when msg = 'DSMMOM397I' then do\n        igp = pos(sstring,dcfrec)\n        if igp = 0 then signal more;\n        parse var dcfrec  left ' AT LINE ' after  ' OF ' right\n        before = after + 1\n        if before > hiline then before = hiline\n        if before < 2     then before = 2\n        call look_ahead;  /* check for continuations */\n        return 0\n      end\n     when msg = '*M* MACRO' then do\n        after  = strip(substr(dcfrec,11,12))\n        before = after + 1\n        invoked = strip(substr(dcfrec,28,20))\n        parse var invoked '<' invoked '>'\n        invoked = translate('*M* '||invoked'  ')\n        if before > hiline then before = hiline\n        if before < 2     then before = 2\n      more2:\n        call getrec;\n        if substr(dcfrec,3,1) = ' ' then signal more2;\n        if substr(dcfrec,2,10) /= invoked then do\n           qcnt = qcnt - 1; return;\n        end\n        p0=p.0 + 1; p.p0=dcfrec; p.p0=p0\n        signal more2\n     end\n     otherwise signal more;\n    end; /* of select*/\nGETREC:\n   qcnt = qcnt + 1\n   if qcnt <= q.0 then do\n      dcfrec = q.qcnt\n   end;\n   else do;\n      dcfrec='>>EOF>>'\n      EOF='YES'\n   end;\n   Return\n look_ahead:  /* pick up continuation lines*/\n   lookmore:\n   qcnt = qcnt + 1\n   if qcnt > q.0 then do\n      qcnt = qcnt - 1; return;\n   end\n   x3 = substr(q.qcnt,2,3); x1 = substr(q.qcnt,28,1)\n   if x3 = 'DSM' | x1 = '<' then do\n       qcnt = qcnt - 1;\n       trace off\n       return;\n   end;\n   aft62 = substr(p.p0,62)\n   if aft62 = '' then do;\n    dcfrec=substr(dcfrec,1,61)||substr(q.qcnt,2)\n    p.p0 = substr(p.p0,1,61)||substr(q.qcnt,2)\n   end;\n   else do;\n     p0=p.0 +1; p.p0 = strip(q.qcnt); p.0 = p0\n   end;\n   signal lookmore\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DDNAME": {"ttr": 5646, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x13\\x00\\x13\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "MCRITCH"}, "text": "00010000 PROC 1 DDNAME\n00011002 /* SEE THE NEW CLIST  LISTDD  -- COMPATIBLE WITH  SYSOUT TRAP*/\n00020000 CLRSCRN\n00090000 IVLTIOT &DDNAME\n00100001  /* OPTIONS. ----------------------------------------------------------\n00110001  /*   ALL        WILL LIST ALL DDNAME AND DSNAMES ALLOCATED TO USER\n00120001  /*   <DDNAME>   TO SELECT A SPECIFIC DDNAME ALLOCATED TO USER\n00130001  /* EXAMPLES ----------------------------------------------------------\n00140001  /*   ===> TSO DDNAME ALL\n00141001  /*   ===> TSO DDNAME SYSPROC\n00161001  /* LIBRARY CONCATENATIONS --------------------------------------------\n00170001  /*   SYSPROC:   CLIST LIBRARIES\n00180001  /* LIBRARY CONCATENATIONS USED BY ISPF -------------------------------\n00190001  /*   ISPPLIB:   PANEL DEFINITIONS\n00200001  /*   ISPMLIB:   MESSAGE DEFINITIONS  NEW MESSAGES HAVE ISP PREFIX\n00210001  /*   ISPSLIB:   SKELETON DEFINITIONS.   EDIT MODELS (NAMED ISRE....)\n00220001  /*              AND FILE SKELETONS USED BY BATCH PROCESSING (OPTION 5)\n00230001  /*   ISPTLIB:   TABLE INPUT LIBRARY\n00240001  /*   ISPPROF:   STORED PROFILE FOR EACH USER, INTIAL PROFILES ORIGINAT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DESKCALC": {"ttr": 5648, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 1, "newlines": 1, "modlines": 0, "user": "MCRITCH"}, "text": "00010000VSBASIC 'SYS6.DESKCALC.VSBOBJ' OBJECT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DUADD": {"ttr": 5890, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01{\\x01{\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 379, "newlines": 379, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- */\nADDRESS \"ISREDIT\"\n  \"MACRO NOPROCESS (FLOW)\"\n/* TITLE:   Reformat and sort dictionary update \".du add \" cards     */\n/* Users:   SCRIPT users                                             */\n/* Entry:   Used as an EDIT CLIST within ISPF EDIT  ===> DUADD       */\n/* Contributed: 1985/08/05 David McRitchie                           */\n/*     Converted to REXX mainly line for line on 1994/04/26 D.McR.   */\n/* Options: FLOW option default is 70  e.g.  ===> DUADD 70           */\n/*     The resulting sorted \".du add \" entries will fit within the   */\n/*     column specified since that is what TFLOW does.               */\n/*     The DUADDSTR option default is \".du add \"                     */\n/*       ===> DUADD (,'.du add')                                     */\n/* Requirements:                                                     */\n/*  All \".du add \" in the section must begin in col 1 and have no    */\n/*  other control statements .DUADF  label required at beginning of  */\n/*  a contiguous  \".du add  \" section .DUADX  label immediately      */\n/*  after end of the contiguous  \".du add  \" section.                */\n/*                                                                   */\n/*  The reason that .DUADX must be below the last line is to be able */\n/*  to identify when there is only one line to be processed -- a     */\n/*  possible alternative might have been to pass names of the line   */\n/*  labels when invoking this edit macro, but I think the method     */\n/*  used is better than the alternative.                             */\n/*                                                                   */\n/* SPECIAL OR HIDDEN FEATURES:                                       */\n/*  Used by the CLIST DUADDX to convert an entire list to .DU ADD    */\n/*    cards provided that \"DSMDOT459I WORDS NOT FOUND:\" is found in  */\n/*    appropriate place.                                             */\n/*   e.g.   DUADDX S6133                                             */\n/*      would convert users   SYSVAR(SYSUID).S6133..LIST             */\n/*     dataset by invoking...        Address \"ISPEXEC\",              */\n/*          \"EDIT DATASET(SYSVAR('sysuid').S6133..LIST) MACRO(DUADD)\"*/\n/*                                                                   */\n  /* ************ ADDED D.MCR 1987/05/22 TO add/del list of names */\n  /* example   ===> duadd CNTL MIDILIST hasn haven             */\n  /******************************/\n  \"PROCESS RANGE C\"\n  If rc = 0 then Do\n     /* make CC process range look like original usage */\n     \"(duadfNO) = LINENUM .DUADF\"\n     LCC1 = rc\n     \"(duadlNO) = LINENUM .DUADX\"\n     LCC2 = rc\n     If LCC1  = 0 | LCC2  = 0 then Do\n       ZEDSMSG = \".DUADF CC Conflict\"\n       ZEDLMSG = \".DUADF .DUADX labels conflict with CC range\"\n       Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000) \"\n     END\n     \"LABEL .ZFRANGE = .DUADF 0\"\n     \"(LABL) = LINENUM .ZLRANGE\"\n     LABL = LABL + 1\n     \"LABEL\" labl \"= .DUADX 0\"\n  END\n  /******************************/\n  If flow = \"(1)\" then Do\n     SFLOW = \"(1)\"\n     \"c all .duadf .duadx 1 '.if &&&&locdu. ne no .du add ' '.du add '\"\n     FLOW = 52\n  END\n  If flow = \"(2)\" then Do\n     FLOW = 52\n  END\n  If flow = \"(3)\"  then Do\n     \"c all .duadf .duadx 1 '.du add ' '.if &&&&locdu. ne no .du add '\"\n     EXIT 1\n  END\n  xflow = translate(flow)\n  dflow = datatype(flow)\n  if xflow  = \"DICTIONARY\" then Do\n         Address \"TSO\" \"$EDIT SYS6.DCF40.INSTALL(DSMDMJCL)\"\n         EXIT 1\n  END\n  if dflow = \"CHAR\" & flow \\= \"\" then Do\n      \"(DSNX) = DATASET\"\n      \"F 1 first '.if &&&&locdu. ne no '\"\n      If rc = 0 then DSNX = \"TECH.LIBR2.TEXT\"     /*fake it */\n      If dsnx = \"TECH.LIBR2.TEXT\" then Do\n         \"F 1 first '.if &&&&locdu. ne no .du add '\"\n         If rc = 0 then Do\n            \"LOC 30   \"\n            \"f prev '.if &&&&locdu. ne no .du add '\"\n            \"LINE_AFTER         .ZCSR   = \",\n               \"\"\".if &&&&locdu. ne no .du add\" flow\"\"\"\"\n            \"LINE_AFTER         .ZCSR   = \",\n               \"NOTELINE '.* duadd --------------'\"\n         END\n         ELSE \"LINE_AFTER         .ZFIRST = \",\n            \"'.if &&&&locdu. ne no .du add\" flow\"'\"\n         \"F 1 last '.if &&&&locdu. ne no .du del '\"\n         If rc = 0 then\n              \"LINE_AFTER         .ZCSR   = \",\n                 \"\"\".if &&&&locdu. ne no .du del\" FLOW\"\"\"\"\n         ELSE \"LINE_AFTER         .ZLAST  = \",\n            \"\"\".if &&&&locdu. ne no .du del\" flow\"\"\"\"\n   /*huh?  \"F 1 last '.if &&&&locdu. ne no .du del\" flow\"'\" */\n         \"loc .ZLAST\"\n         \"up 15\"\n      END\n      ELSE Do\n         \"F 1 first '.du add '\"\n         If rc = 0 then Do\n              \"LOC 30 \"\n              \"f prev 1 '.du add '\"\n              \"LINE_AFTER .ZCSR = \"\".du add\" flow\"\"\"\"\n              \"LINE_AFTER         .ZCSR   = \",\n                \"NOTELINE \"\".* duadd --------------\"\"\"\n         END\n         ELSE \"LINE_BEFORE .ZFIRST = '.du add\" FLOW\"'\"\n         \"F 1 last '.du del ' \"\n         If rc = 0 then\n              \"LINE_AFTER .ZCSR   = \"\".du del\" FLOW\"\"\"\"\n         ELSE \"LINE_AFTER .ZLAST  = \"\".du del\" FLOW\"\"\"\"\n         /* huh?  \"F 1 last '.du del $FLOW.'\" */\n         \"loc .ZLAST\"\n         \"up 15\"\n      END\n      \"(DSNX)           = DATASET\"\n      EXIT 1\n  END\n  /*** ADDED D.MCR 1987/03/06 TO ACCOMODATE OUTPUT LIST AS INPUT */\n  \"SEEK FIRST 1 '.'  \"\n  If rc = 0 then SIGNAL NORML01\n  wanted = 0\n  \"SEEK FIRST 1 p'DSMDOT459I=WORDS=NOT=FOUND$'\"\n  If rc = 0 then wanted = 1\n  \"SEEK FIRST 1 p'=DSMDOT459I=WORDS=NOT=FOUND$'\"\n  If rc = 0 then wanted = 1\n  \"SEEK FIRST 1 p'==DSMDOT459I=WORDS=NOT=FOUND$'\"\n  If rc = 0 then wanted = 1\n  If wanted = 0 then SIGNAL NORML01\n  /* modified 1991/04/22 to combine words not found lines*/\n  /* (error message never continues beyond two lines)  */\n  \"X ALL\"\n  \"F ALL         1 X P'=DSMDOT459I=WORDS=NOT=FOUND$='  \"\n  \"X ALL 61 ' '   \"\n  \"F ALL         1 NX P'=DSMDOT459I=WORDS=NOT=FOUND$=' \"\n  \"(,VAR024) = FIND_COUNTS\"\n  Do ii=1 to var024\n     \"(line1) = line .zcsr\"\n     \"(line1NO) = linenum .zcsr\"\n     line2no = line1no + 1\n     \"(line2) = line\" line2no\n     line = strip('.du add '||substr(line1,30,32)||substr(line2,2))\n     \"line\" line1no \"= (line)\"\n     \"del\" line2no\n     \"F next 1 NX P'=DSMDOT459I=WORDS=NOT=FOUND$=' \"\n  END\n  \"C ALL 1 P'=DSMDOT459I=WORDS=NOT=FOUND$=' '.du add ' \"\n  \"C ALL 1  p'dsmdot459i=words=not=found$=' '.du add '\"\n  \"x all\"\n  \"f all 2 \"\"DSMMOM395I '\"\"\" /*'match single quote*/\n  \"f '.du add ' 1 all\"\n  \"c all 1 nx p'=DSMMOM395I ' '.DSMMOM395I '\"\n  \"(change7,change8) = change_counts\"\n  \"(line) = line .zcsr\"\n  parse var line line ' LINE '\n  \"seek 1 \"\"\"line\"\"\" all\"\n  \"(seek7,seek8) = seek_counts\"\n  \"f 1 '.*' all\"\n  if seek7 = change7 then Do\n     \"x all 1 '.dsmmom395i '\"\n     \"del x all\"\n     \"LABEL .zfirst   = .DUADF 0\"\n     \"LINE_AFTER .ZL = dataline \"\".* .DUADX\"\"\"\n     \"LABEL   .ZLAST = .DUADX 0\"\n     signal norml01\n  end\n  \"del x all\"\n  \"x all '.du add ' 1\"\n  \"LABEL             .ZCSR   = .DUADF 0\"\n  \"LINE_AFTER .ZL = dataline \"\".* .DUADX\"\"\"\n  \"LABEL   .ZLAST = .DUADX 0\"\n  \"x .duadx .duadx all\"\n  \"LINE_AFTER 0 = NOTELINE \"\"  ===> duadd \"\"\"\n  \"LINE_AFTER 0 = NOTELINE \",\n     \"\"\"  ===> c all p'.' ' '     << check changes\"\"\"\n  \"LINE_AFTER 0 = NOTELINE\",\n     \"\"\" ===> <LABEL RANGE OF DUADD IS .DUADF .DUADX\"\"\"\n  \"LINE_AFTER 0 = NOTELINE \"\" otherwise you may want to \",\n     \"update several members\"\"\"\n  \"LINE_AFTER 0 = NOTELINE \"\"If it IS -- SIMPLY ISSUE \",\n     \"===> DEL NX ALL\"\"\"\n  \"LINE_AFTER 0 = NOTELINE \"\"CHECK THAT SAME MEMBER\",\n     \"IS USED THROUGHOUT\"\"\"\n  ZEDSMSG = \"read =NOTE= lines\"\n  ZEDLMSG = \"Please read =NOTE= lines, most of\",\n    \"conversion was done for you\"\n  Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n  EXIT 1\n\nNORML01:\n  if flow = \"\" then flow = 70\n  \"(duadfNO) = LINENUM .DUADF \"\n  If rc > 0 then Do\n    ZEDSMSG = .DUADF MISSING\n    ZEDLMSG = A .DUADF label (at the first '.du add ' line) ,\n      is not in the file\n    Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    EXIT 1\n  END\n  \"(duadxNO) = LINENUM .DUADX \"\n  If rc > 0 then Do\n    ZEDSMSG = .DUADX MISSING\n    ZEDLMSG = A .DUADX label (at the line after the last ,\n      '.du add ' line) is not in the      file\n    Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n    EXIT 1\n  END\n  \"F 1 first '.if &&&&locdu. ne no '  \"\n  If rc = 0 then Do\n     DSNX = \"TECH.LIBR2.TEXT\"       /*fake it*/\n     \"c all .DUADF .duadx '.if &&&&locdu. ne no .du add ' \",\n       \"'.du add '\"\n  END\n  If FLOW. = \"\" then Do\n     If  dsnx = \"TECH.LIBR2.TEXT\" then flow = 52\n     ELSE FLOW = 70\n  END\n  ELSE If DATATYPE(FLOW) \\= \"NUM\" then Do\n    ZEDSMSG = BAD PARAMETER\n    ZEDLMSG = flow \"is an unknown parameter.  Use a\" ,\n      \"column number.\"\n    Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n    EXIT  12\n  END\n  \"(LBOUND,RBOUND) = BOUNDS\"\n  \"(DWIDTH) = DATA_WIDTH\"\n  If FLOW = \"\" then nop\n  ELSE If FLOW < 10 then Do\n    ZEDSMSG = \"Parameter too small\"\n    ZEDLMSG = \"The FLOW parameter\" flow \"must be at least 10\"\n    Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n    EXIT  12\n  END\n  If FLOW  = \"\" then nop\n  ELSE If FLOW > RBOUND then Do\n    ZEDSMSG = PARAMETER TOO LARGE\n    ZEDLMSG = \"The parameter must be smaller than or\",\n      \"equal to\" RBOUND\", the right-bound.\"\n    Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n    EXIT  12\n  END\n  \"LABEL\" value(duadxNO-1) \"= .DUADL\"\n  If RBOUND < DWIDTH then Do\n  \"SEEK .DUADF .DUADL P'^'\" value(RBOUND+1) DWIDTH\n    If rc = 0 then Do\n      ZEDSMSG = DATA OUTSIDE BOUNDS\n      ZEDLMSG = \"Non-blank characters exist outside\",\n        \"of the edit bounds.\"\n      Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000) \"\n      EXIT  12\n    END\n  END\n   /* ************ ADDED D.MCR 1985/08/03 TO END ***** */\n  If value(duadxNO) < value(duadfNO) then Do\n      ZEDSMSG = \"LABEL ERR .DUADF/X\"\n      ZEDLMSG = \".DUADF MUST APPEAR EARLIER THAN .DUADX\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      EXIT  12\n  END\n  \"CHANGE ALL 1 .DUADF .DUADL \",\n     \" p'=DSMDOT459I=WORDS=NOT=FOUND$=' '.du add '\"\n  \"CHANGE ALL 1 .DUADF .DUADL \",\n     \"  p'=0DSMDOT459I=WORDS=NOT=FOUND$=' '.du add '\"\n  \"SEEK  .DUADF .DUADL 1 '.du add ' ALL\"\n  \"(SEEK1,SEEK2) = SEEK_COUNTS\"\n  SEEK3 = value(duadxNO - duadfNO )\n  If value(SEEK3) \\= value(SEEK2) ,\n  | seek3  \\= seek1  then Do\n      ZEDSMSG = \"INCORRECT .DU DATA\"\n      ZEDLMSG = \".du add \",\n         \"Must be in pos. 1 of each line beginning .duadf to\",\n         \"the line before .duadx\"\n      Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000) \"\n      say 'You''re all washed up in this town mister' sysvar('sysuid')\n      say \" \"\n      say \"read the upper right hand corner buster\"\n      EXIT  12\n  END\n  \"SEEK .DUADF .DUADL 1 ';.'  ALL\"\n  \"(SEEK1,SEEK2) = SEEK_COUNTS\"\n  If seek2 \\= 0     then Do\n      ZEDSMSG = \"ONE COMMAND PER LINE\"\n      ZEDLMSG = \"CAN ONLY HANDLE \".du add           \" COMMANDS AND\" ,\n         \"THEY MUST BEGIN IN COL 1\"\n      Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000) \"\n      EXIT  12\n  END\n  /*ALL VERIFICATION HAS BEEN COMPLETED ABOVE -- */\n  /*  --NOW SETTING UP TO CHANGE DATA */\n  \" (duadfNO) = LINENUM .DUADF\"\n  \" LABEL\" value(duadxNO - 1) \"= .DUADR 0\"\n  \" LINE_BEFORE .DUADR = DATALINE LINE .DUADR \"\n  \" LABEL\" duadfNO \"= .DUADF\"\n     /*PROVIDED IN CASE .DUADX WAS ENTERED ONE LINE AFTER .DUADF*/\n  \" (duadxNO) = LINENUM .DUADX\"\n     /*RECALCULATED BECAUSE IT HAS MOVED ONE LINE DOWN*/\n  \" LABEL\" value(duadxNO - 1) \"= .DUADR 0\"\n     /*REDOING LABEL BECAUSE OF LINE INSERTED */\n  \" (duadrNO) = LINENUM .DUADR\"\n     /*RECALCULATED BECAUSE IT HAS MOVED ONE LINE DOWN */\n  \" LABEL\" duadfNO \"= .DUADF 0\"\n     /*REDOING LABEL BECAUSE IN CASE COPY WENT BEFORE IT*/\n  \" CHANGE .DUADF .DUADR '.du add    ' '.du add ' 1 ALL   \"\n  \" CHANGE .DUADF .DUADR '.du add   ' '.du add ' 1 ALL    \"\n  \" CHANGE .DUADF .DUADR '.du add '         '        ' 1 8 ALL\"\n  /********** START SPLITTING UP LINES FROM THE FIRST WORD*/\n  \" CURSOR =\" duadfNO \"0\"\n  TSBEG:\n  \" SEEK P' ^'       \"\n  If rc \\= 0 then SIGNAL SORTS\n  TSF1:\n  \" (SEEK1) = LINENUM .ZCSR\"\n  TSF2:\n  \" SEEK P' ^'       \"\n  If rc \\= 0 then SIGNAL SORTS\n  \" (SEEK2) = LINENUM .ZCSR\"\n  If seek2  >= duadrNO then SIGNAL SORTS\n  If seek1 \\= seek2 then SIGNAL TSF1\n  \" TSPLIT           \"\n  \" (duadrNO) = LINENUM .DUADR\"\n  SIGNAL TSBEG\n  SORTS:\n  \" CHANGE .DUADR .DUADR '        ' '.*STOPFLOW' 1 8 ALL  \"\n  \" (CURLINE) = LINENUM .DUADX\"\n  \" LABEL\" value(CURLINE - 2)\"= .DUADL 0\"\n  \"(ifrom) = linenum .duadf\"\n  Do i = ifrom to value(curline -1)\n     \"(line) = line\" i\n     line = substr(line,1,50)||translate(substr(line,1,20))\n     \"line\" i \"= (line)\"\n   end\n  \" SORT .DUADF .DUADL 51 70 1 50\"\n   /* *********** remove any duplicates *****************/\n  /* *********** remove any duplicates *****************/\n  /* sortf to .sortv  (sortv itself never a duplicate) */\n  \"(sortfn) = linenum .duadf\"\n  \"(sortvn) = linenum .duadx\"\n  prevline = \" \"\n  delcnt=0\n  sortvv = sortvn - 2\n  Do i = sortvv to sortfn by -1\n     /* could make line = substr(line,1,50)translate(line,1,20)) */\n     /* and sort 51 70 1 50 */\n     \"(line) = line\" i\n     line=substr(line,1,50)\n     \"line\" i \"= (line)\"\n     if line = prevline then Do;\"delete\" i+1;delcnt=delcnt+1;end;\n     else prevline = line\n  end\n  call note \"There were \"||delcnt||\" duplicate word(s) deleted\"\n   /* ***************************************************/\n  \" (duadxNO) = LINENUM .DUADX\"\n     /*RECALCULATED BECAUSE IT HAS MOVED ONE LINE DOWN */\n  diff = duadxNO - duadfNO   /*number of entries in list*/\n  \" TFLOW .DUADF\" flow\n  \" CHANGE .DUADF .DUADR '        ' '.du add ' 1 8 ALL    \"\n  \" DELETE .DUADR .DUADR\"\n  If rc = 0 then diff = diff - 1\n  \" RESET CHANGE .DUADF .DUADF\"\n     /* RESHOW LABEL EVEN if changed*/\n  If DSNX  = \"TECH.LIBR2.TEXT\" then ,\n     \"c all .duadf .duadx 1 '.du add ' \",\n       \"'.if &&&&locdu. ne no .du add '\"\n  \" RESET COMMAND    \"\n  ZEDSMSG = \"DUADD FINISHED OK\"\n  ZEDLMSG = \"DUADD MACRO FINISHED OKAY -- \"DIFF\" entries\",\n     \"--\"   CHANGED \"LINES INCLUDE  .duadf\"\n  Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n  If diff > 600 then Do\n  \"LINE_BEFORE\" DUADF \"= NOTELINE \"\"\"diff\" ENTRIES APPROACHES\"\"\"\n  \"LINE_BEFORE\" duadfNO \"= NOTELINE \"\"\"CCC\"             MAX OF 804 \",\n     \"WORDS ALLOWED IN ADDENDA DICTIONARY\"\"\"\n  END\n  EXIT 1\n  note: parse arg limey\n      \"line_after .zcsr = noteline (limey)\"\n      return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUADDC": {"ttr": 5897, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01h\\x01h\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 360, "newlines": 360, "modlines": 0, "user": "MCRITCH"}, "text": "  CONTROL ASIS\n  ISREDIT  MACRO NOPROCESS (FLOW)\n/* TITLE:   Reformat and sort dictionary update \".du add \" cards     */\n/* Users:   SCRIPT users                                             */\n/* Entry:   Used as an EDIT CLIST within ISPF EDIT  ===> DUADD       */\n/* Contributed: 1985/08/05 David McRitchie                           */\n/*     This clist replaces John Kennedy's DUADDOUT and DUADDIN.      */\n/* Options: FLOW option default is 70  e.g.  ===> DUADD 70           */\n/*     The resulting sorted \".du add \" entries will fit within the   */\n/*     column specified since that is what ISREDIT TFLOW does.       */\n/*     The DUADDSTR option default is \".du add \"                     */\n/*       ===> DUADD (,'.du add')                                     */\n/* Requirements:                                                     */\n/*  All \".du add \" in the section must begin in col 1 and have no    */\n/*  other control statements .DUADF  label required at beginning of  */\n/*  a contiguous  \".du add  \" section .DUADX  label immediately      */\n/*  after end of the contiguous  \".du add  \" section.                */\n/*                                                                   */\n/*  The reason that .DUADX must be below the last line is to be able */\n/*  to identify when there is only one line to be processed -- a     */\n/*  possible alternative might have been to pass names of the line   */\n/*  labels when invoking this edit macro, but I think the method     */\n/*  used is better than the alternative.                             */\n/*                                                                   */\n/* SPECIAL OR HIDDEN FEATURES:                                       */\n/*  Used by the CLIST DUADDX to convert an entire list to .DU ADD    */\n/*    cards provided that \"DSMDOT459I WORDS NOT FOUND:\" is found in  */\n/*    appropriate place.                                             */\n/*   e.g.   DUADDX S6133                                             */\n/*      would convert users   &SYSUID..S6133..LIST  dataset by invok-*/\n/*      ing  ISPEXEC EDIT DATASET('&SYSUID..S6133..LIST) MACRO(DUADD)*/\n/*                                                                   */\n  /* ************ ADDED D.MCR 1987/05/22 TO add/del list of names */\n  /* example   ===> @duadd CNTL MIDILIST hasn haven             */\n  /******************************/\n  ISREDIT PROCESS RANGE C\n  IF &LASTCC = 0 THEN DO\n     /* make CC process range look like original usage */\n     ISREDIT (#DUADF) = LINENUM .DUADF\n     SET LCC1 = &LASTCC.\n     ISREDIT (#DUADL) = LINENUM .DUADX\n     SET LCC2 = &LASTCC.\n     IF &LCC1. = 0 OR &LCC2. = 0 THEN DO\n       SET &ZEDSMSG = .DUADF CC Conflict\n       SET &ZEDLMSG = .DUADF .DUADX labels conflict with CC range\n       ISPEXEC SETMSG MSG(ISRZ000)\n     END\n     ISREDIT LABEL .ZFRANGE = .DUADF 0\n     ISREDIT (LABL) = LINENUM .ZLRANGE\n     SET LABL = &LABL. + 1\n     ISREDIT LABEL &LABL. = .DUADX 0\n  END\n  /******************************/\n  SET LP = &STR((\n  SET RP = &STR())\n  IF &STR(&FLOW.) = &STR(&LP.1&RP.) THEN DO\n     SET SFLOW = (1)\n     ISREDIT c all .duadf .duadx 1 '.if &&&&locdu. ne no .du add ' +\n        '.du add '\n     SET FLOW = 52\n  END\n  IF &STR(&FLOW.) = &STR(&LP.3&RP.) THEN DO\n     ISREDIT c all .duadf .duadx 1 '.du add ' +\n        '.if &&&&locdu. ne no .du add '\n     EXIT CODE(1)\n  END\n  IF &STR(&FLOW.) = (2) THEN DO\n     SET FLOW = 52\n  END\n  IF &STR() ^= &STR(&FLOW) THEN +\n  IF &SUBSTR(1:1,&STR(&FLOW.)) < &STR(0) THEN DO\n     IF &STR(&SYSCAPS(&FLOW.)) = DICTIONARY THEN DO\n        $EDIT SYS6.DCF40.INSTALL(DSMDMJCL)\n        EXIT CODE(1)\n     END\n     ISREDIT (DSNX)    = DATASET\n     ISREDIT F 1 first '.if &&&&locdu. ne no '\n     IF &LASTCC = 0 THEN SET DSNX = TECH.LIBR2.TEXT   /*fake it */\n     IF &STR(&DSNX) = TECH.LIBR2.TEXT THEN DO\n        ISREDIT F 1 first '.if &&&&locdu. ne no .du add '\n        IF &LASTCC = 0 THEN DO\n           ISREDIT LOC 30\n           ISREDIT f prev '.IF &&&&locdu. ne no .du add '\n           ISREDIT LINE_AFTER  .ZCSR   = +\n              '.if &&&&locdu. ne no .du add &FLOW'\n           ISREDIT LINE_AFTER  .ZCSR   = +\n              NOTELINE '.* duadd --------------'\n        END\n        ELSE ISREDIT LINE_AFTER  .ZFIRST = +\n           '.if &&&&locdu. ne no .du add &FLOW'\n        ISREDIT F 1 last '.if &&&&locdu. ne no .du del '\n        IF &LASTCC = 0 THEN -\n             ISREDIT LINE_AFTER  .ZCSR   = +\n                '.if &&&&locdu. ne no .du del &FLOW'\n        ELSE ISREDIT LINE_AFTER  .ZLAST  = +\n           '.if &&&&locdu. ne no .du del &FLOW'\n        ISREDIT F 1 last '.if &&&&locdu. ne no .du del &FLOW.'\n        ISREDIT loc .ZLAST\n        ISREDIT up 15\n     END\n     ELSE DO\n        ISREDIT F 1 first '.du add '\n        IF &LASTCC = 0 THEN DO\n             ISREDIT LOC 30\n             ISREDIT f prev 1 '.du add '\n             ISREDIT LINE_AFTER  .ZCSR   = '.du add &FLOW'\n             ISREDIT LINE_AFTER  .ZCSR   = +\n                NOTELINE '.* duadd --------------'\n        END\n        ELSE ISREDIT LINE_BEFORE .ZFIRST = '.du add &FLOW'\n        ISREDIT F 1 last '.du del '\n        IF &LASTCC = 0 THEN -\n             ISREDIT LINE_AFTER  .ZCSR   = '.du del &FLOW'\n        ELSE ISREDIT LINE_AFTER  .ZLAST  = '.du del &FLOW'\n        ISREDIT F 1 last '.du del &FLOW.'\n        ISREDIT loc .ZLAST\n        ISREDIT up 15\n     END\n     ISREDIT (DSNX)    = DATASET\n     EXIT CODE(1)\n  END\n   /* +\n  **** ADDED D.MCR 1987/03/06 TO ACCOMODATE OUTPUT LIST AS INPUT\n  ISREDIT SEEK FIRST 1 '.'\n  IF &LASTCC = 0 THEN GOTO NORML01\n  SET WANTED = 0\n  /****THE NEXT LINE CONTAINS X'09'||'DSMDOT459I WORDS NOT FOUND:'\n  ISREDIT SEEK FIRST  1 +\n     '09C4E2D4C4D6E3F4F5F9C940E6D6D9C4E240D5D6E340C6D6E4D5C47A40'X\n     /*  D S M D O T 4 5 9 I   W O R D S   N O T   F O U N D :  */\n  IF &LASTCC = 0 THEN SET WANTED = 1\n  ISREDIT SEEK FIRST  1 +\n     'C4E2D4C4D6E3F4F5F9C940E6D6D9C4E240D5D6E340C6D6E4D5C47A40'X\n    /* D S M D O T 4 5 9 I   W O R D S   N O T   F O U N D :  */\n  IF &LASTCC = 0 THEN SET WANTED = 1\n  IF WANTED = 0 THEN GOTO NORML01\n  ELSE DO\n     /* modified 1991/04/22 to combine words not found lines\n     /* (error message never continues beyond two lines)\n     ISREDIT X ALL\n     ISREDIT C ALL  1 P'= '   '. '\n     ISREDIT C ALL  1 X P'=DSM' '.DSM'\n     ISREDIT C ALL  1 X P'.' '\u00a2'\n     ISREDIT X ALL\n     ISREDIT F ALL  1 X P'=DSMDOT459I=WORDS=NOT=FOUND$='\n     ISREDIT X ALL 61 ' '\n     ISREDIT F ALL  1 NX P'=DSMDOT459I=WORDS=NOT=FOUND$='\n     ISREDIT (,VAR024) = FIND_COUNTS\n     SET VAR024 = &EVAL(&VAR024.)\n     DO WHILE (&VAR024. NE 0)\n        ISREDIT TFLOW .ZCSR\n        ISREDIT X     .ZCSR .ZCSR ALL\n        ISREDIT F NEXT 1 NX P'=DSMDOT459I=WORDS=NOT=FOUND$='\n        SET VAR024 = &VAR024 - 1\n     END\n     ISREDIT C ALL  X  ' \u00a2'  ''\n     /* end modified 1991/04/22 to combine words not found lines\n     ISREDIT C ALL  1 P'=DSMDOT459I=WORDS=NOT=FOUND$=' '.du add '\n   /*    ISREDIT C ALL  1 ' DSMDOT459I WORDS NOT FOUND: ' '.DU ADD '\n     ISREDIT C ALL  1+\n        '09C4E2D4C4D6E3F4F5F9C940E6D6D9C4E240D5D6E340C6D6E4D5C47A40'X +\n        '.du add '\n        /*  D S M D O T 4 5 9 I   W O R D S   N O T   F O U N D :  */\n     ISREDIT C ALL  1 +\n        'C4E2D4C4D6E3F4F5F9C940E6D6D9C4E240D5D6E340C6D6E4D5C47A40'X +\n        '.du add '\n        /*D S M D O T 4 5 9 I   W O R D S   N O T   F O U N D : */\n     ISREDIT F 'DSMMOM395I' ALL\n     ISREDIT F 'DSMDOT459I' ALL\n     ISREDIT F '.DU ADD' ALL\n     ISREDIT C ALL p'.0DSMDOT459I.WORDS.NOT.FOUND$.' +\n        ' DSMDOT459I WORDS NOT FOUND: '\n     ISREDIT C ALL p' DSMDOT459I.WORDS.NOT.FOUND$.' +\n        ' DSMDOT459I WORDS NOT FOUND: '\n     ISREDIT LABEL      .ZCSR   = .DUADF 0\n     ISREDIT DEL X ALL\n     ISREDIT LINE_AFTER  .ZL    = \".* .DUADX\"\n     ISREDIT LABEL      .ZLAST =  .DUADX 0\n     ISREDIT X ALL\n     ISREDIT F 'DSMMOM395I' ALL\n     ISREDIT LINE_AFTER 0 = NOTELINE \" +\n        ===> duadd \"\n     ISREDIT LINE_AFTER 0 = NOTELINE \" +\n        ===> c all p'.' ' '     << check changes\"\n     ISREDIT LINE_AFTER 0 = NOTELINE \" +\n        ===> <LABEL RANGE OF DUADD IS .DUADF .DUADX\"\n     ISREDIT LINE_AFTER 0 = NOTELINE \" otherwise you may want to +\n        update several members\"\n     ISREDIT LINE_AFTER 0 = NOTELINE \" IF IT IS -- SIMPLY ISSUE +\n        ===> DEL NX ALL\"\n     ISREDIT LINE_AFTER 0 = NOTELINE \"CHECK THAT SAME MEMBER +\n        IS USED THROUGHOUT\"\n     SET &ZEDSMSG = &str(read =NOTE= lines)\n     SET &ZEDLMSG = &STR(Please read =NOTE= lines, most of +\n       conversion was done for you)\n     ISPEXEC   SETMSG MSG(ISRZ000)\n     EXIT CODE(1)\n  END\nNORML01: -\n  ISREDIT (#DUADF) = LINENUM .DUADF\n  IF &LASTCC > 0 THEN DO\n    SET &ZEDSMSG = .DUADF MISSING\n    SET &ZEDLMSG = A .DUADF label (at the first '.du add ' line) +\n      is not in the file\n    ISPEXEC SETMSG MSG(ISRZ000)\n    EXIT CODE(1)\n  END\n  ISREDIT (#DUADX) = LINENUM .DUADX\n  IF &LASTCC > 0 THEN DO\n    SET &ZEDSMSG = .DUADX MISSING\n    SET &ZEDLMSG = A .DUADX label (at the line after the last +\n      '.du add ' line) is not in the      file\n    ISPEXEC   SETMSG MSG(ISRZ000)\n    EXIT CODE(1)\n  END\n  ISREDIT F 1 first '.if &&&&locdu. ne no '\n  IF &LASTCC = 0 THEN DO\n     SET DSNX = TECH.LIBR2.TEXT   /*fake it\n     ISREDIT c all .DUADF .duadx '.if &&&&locdu. ne no .du add ' +\n       '.du add '\n  END\n  IF &FLOW. = THEN DO\n     IF  TECH.LIBR2.TEXT = &DSNX THEN SET FLOW = 52\n     ELSE SET FLOW = 70\n  END\n  ELSE IF &DATATYPE(&FLOW) ^= NUM THEN DO\n    SET &ZEDSMSG = BAD PARAMETER\n    SET &ZEDLMSG = &STR('&FLOW' is an unknown paramter.  Use a +\n      column number.)\n    ISPEXEC   SETMSG MSG(ISRZ000)\n    EXIT CODE(12)\n  END\n  ISREDIT (LBOUND,RBOUND) = BOUNDS\n  ISREDIT (DWIDTH) = DATA_WIDTH\n  IF &FLOW. = THEN\n  ELSE IF &FLOW < 10 THEN DO\n    SET &ZEDSMSG = PARAMTER TOO SMALL\n    SET &ZEDLMSG = &STR(The parameter must be at least 10.)\n    ISPEXEC   SETMSG MSG(ISRZ000)\n    EXIT CODE(12)\n  END\n  IF &FLOW. = THEN\n  ELSE IF &FLOW > &RBOUND. THEN DO\n    SET &ZEDSMSG = PARAMETER TOO LARGE\n    SET &ZEDLMSG = &STR(The parameter must be smaller than or +\n      equal to &RBOUND., the right-bound.)\n    ISPEXEC   SETMSG MSG(ISRZ000)\n    EXIT CODE(12)\n  END\n  ISREDIT LABEL &EVAL(&#DUADX-1) = .DUADL\n  IF &RBOUND < &DWIDTH THEN DO\n  ISREDIT SEEK .DUADF .DUADL P'^' &EVAL(&RBOUND+1) &DWIDTH\n    IF &LASTCC. = 0 THEN DO\n      SET &ZEDSMSG = DATA OUTSIDE BOUNDS\n      SET &ZEDLMSG = &STR(Non-blank characters exist outside +\n        of the edit bounds.)\n      ISPEXEC     SETMSG MSG(ISRZ000)\n      EXIT CODE(12)\n    END\n  END\n   /* ************ ADDED D.MCR 1985/08/03 TO END *****\n  IF &EVAL(&#DUADX.) < &EVAL(&#DUADF.) THEN DO\n      SET &ZEDSMSG = &STR(LABEL ERR .DUADF/X)\n      SET &ZEDLMSG = &STR(.DUADF MUST APPEAR EARLIER THAN .DUADX)\n      ISPEXEC SETMSG MSG(ISRZ000)\n      EXIT CODE(12)\n  END\n  ISREDIT CHANGE ALL 1 .DUADF .DUADL +\n      ' DSMDOT459I WORDS NOT FOUND: ' '.du add '\n  ISREDIT CHANGE ALL 1 .DUADF .DUADL +\n      ' 0DSMDOT459I WORDS NOT FOUND: ' '.du add '\n  ISREDIT SEEK    .DUADF .DUADL 1 '.du add ' ALL\n  ISREDIT (SEEK1,SEEK2) = SEEK_COUNTS\n  SET SEEK3 = &EVAL(&#DUADX - &#DUADF )\n  IF &EVAL(&SEEK3.) ^= &EVAL(&SEEK2.) +\n  OR &EVAL(&SEEK3.) ^= &EVAL(&SEEK1.) THEN DO\n      SET &ZEDSMSG = &STR(INCORRECT .DU DATA)\n      SET &ZEDLMSG = &STR(\".du add \" +\n         MUST BE IN POS. 1 OF EACH LINE BEGINNING .DUADF TO +\n         THE LINE BEFORE .DUADX)\n      ISPEXEC     SETMSG MSG(ISRZ000)\n      WRITE YOU'RE ALL WASHED UP IN THIS TOWN  MISTER &SYSUID.\n      WRITE &b.\n      WRITE read the upper right hand corner buster\n      EXIT CODE(12)\n  END\n  ISREDIT SEEK   .DUADF .DUADL 1 ';.'  ALL\n  ISREDIT (SEEK1,SEEK2) = SEEK_COUNTS\n  IF &EVAL(&SEEK2.) ^= &EVAL(0) THEN DO\n      SET &ZEDSMSG = &STR(ONE COMMAND PER LINE)\n      SET &ZEDLMSG = &STR(CAN ONLY HANDLE \".du add  \" COMMANDS AND +\n         THEY MUST BEGIN IN COL 1)\n      ISPEXEC     SETMSG MSG(ISRZ000)\n      EXIT CODE(12)\n  END\n  /*ALL VERIFICATION HAS BEEN COMPLETED ABOVE --\n  /*  --NOW SETTING UP TO CHANGE DATA\n  ISREDIT  (#DUADF) = LINENUM .DUADF\n  ISREDIT  LABEL &EVAL(&#DUADX. - 1) = .DUADR 0\n  ISREDIT  LINE_BEFORE .DUADR = DATALINE LINE .DUADR\n  ISREDIT  LABEL &#DUADF. = .DUADF\n     /*PROVIDED IN CASE .DUADX WAS ENTERED ONE LINE AFTER .DUADF\n  ISREDIT  (#DUADX) = LINENUM .DUADX\n     /*RECALCULATED BECAUSE IT HAS MOVED ONE LINE DOWN\n  ISREDIT  LABEL &EVAL(&#DUADX. - 1) = .DUADR 0\n     /*REDOING LABEL BECAUSE OF LINE INSERTED\n  ISREDIT  (#DUADR) = LINENUM .DUADR\n     /*RECALCULATED BECAUSE IT HAS MOVED ONE LINE DOWN\n  ISREDIT  LABEL &#DUADF. = .DUADF 0\n     /*REDOING LABEL BECAUSE IN CASE COPY WENT BEFORE IT\n  ISREDIT  CHANGE .DUADF .DUADR '.du add    ' '.du add ' 1 ALL\n  ISREDIT  CHANGE .DUADF .DUADR '.du add   ' '.du add ' 1 ALL\n  ISREDIT  CHANGE .DUADF .DUADR '.du add '  '        ' 1 8 ALL\n  /********** START SPLITTING UP LINES FROM THE FIRST WORD\n  ISREDIT  CURSOR = &#DUADF. 0\n  TSBEG: -\n  ISREDIT  SEEK P' ^'\n  IF &LASTCC. ^= 0 THEN GOTO SORTS\n  TSF1: -\n  ISREDIT  (SEEK1) = LINENUM .ZCSR\n  TSF2: -\n  ISREDIT  SEEK P' ^'\n  IF &LASTCC. ^= 0 THEN GOTO SORTS\n  ISREDIT  (SEEK2) = LINENUM .ZCSR\n  IF &EVAL(&SEEK2.) >= &EVAL(&#DUADR.) THEN GOTO SORTS\n  IF &EVAL(&SEEK1.) ^= &EVAL(&SEEK2.) THEN GOTO TSF1\n  ISREDIT  TSPLIT\n  ISREDIT  (#DUADR) = LINENUM .DUADR\n  GOTO TSBEG\n  SORTS: -\n  ISREDIT  CHANGE .DUADR .DUADR '        ' '.*STOPFLOW' 1 8 ALL\n  ISREDIT  (CURLINE) = LINENUM .DUADX\n  ISREDIT  LABEL &EVAL(&CURLINE. - 2) = .DUADL 0\n  ISREDIT  SORT .DUADF .DUADL\n   /* *********** remove any duplicates ****************\n  ISREDIT  REMDUPS .DUADF .DUADL\n   /* **************************************************\n  ISREDIT  (#DUADX) = LINENUM .DUADX\n     /*RECALCULATED BECAUSE IT HAS MOVED ONE LINE DOWN\n  SET #DIFF = &#DUADX. - &#DUADF.         /*number of entries in list\n  ISREDIT  TFLOW .DUADF &FLOW.\n  ISREDIT  CHANGE .DUADF .DUADR '        ' '.du add ' 1 8 ALL\n  ISREDIT  DELETE .DUADR .DUADR\n  IF &LASTCC = 0 THEN SET #DIFF = &#DIFF. - 1\n  ISREDIT  RESET CHANGE .DUADF .DUADF\n     /* RESHOW LABEL EVEN IF CHANGED\n  IF &DSNX. = TECH.LIBR2.TEXT THEN +\n     ISREDIT c all .duadf .duadx 1 '.du add ' +\n       '.if &&&&locdu. ne no .du add '\n  ISREDIT  RESET COMMAND\n  SET &ZEDSMSG = &STR(DUADD FINISHED OK\n  SET &ZEDLMSG = &STR(DUADD MACRO FINISHED OKAY -- &#DIFF. entries +\n     -- #CHANGED LINES INCLUDE  .duadf)\n  ISPEXEC     SETMSG MSG(ISRZ000)\n  IF &EVAL(&#DIFF.) > 600 THEN DO\n  ISREDIT LINE_BEFORE &#DUADF. = NOTELINE \"&#DIFF. ENTRIES APPROACHES\"\n  ISREDIT LINE_BEFORE &#DUADF. = NOTELINE \"&CCC.       MAX OF 804 +\n     WORDS ALLOWED IN ADDENDA DICTIONARY\"\n  END\n  EXIT CODE(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUADDX": {"ttr": 6149, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00J\\x00J\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 74, "newlines": 74, "modlines": 0, "user": "MCRITCH"}, "text": "  ISREDIT MACRO (TOK1)\n        /* PURPOSE: EDIT DATASET('&SYSUID..&TOK..LIST) MACRO(DUADD)\n        /* CONTRIBUTED:   F. DAVID MCRITCHIE             1987/03/06\n        /* USER CONTACT:  F. DAVID MCRITCHIE\n        /* CODE MAINT.:   SYSTECH GROUP\n      SET DSNAME = &STR(&SYSUID..&TOK1..LIST)\n        /* CLIST IS PATTERNED ON THE $EDIT  CLIST\n /****************************************************************\n /*  A COMPLETE DSNAME MUST BE PROVIDED\n /*     -- CAN BE ENCLOSED IN QUOTES, IF YOU SO WISH.\n /*     -- MEMBERNAME MAY BE INCLUDED AS PART OF DSNAME.\n /*     -- WILL NOT PREFIX THE USERID TO THE DSNAME.\n /*****************************************************************\n      /*  ----------- INSURE DSNAME IS SURROUNDED BY QUOTES AND ...  +\n        ---*/\n      /*  ----------- CREATE RDSNAME (WITHOUT MEMBERNAME) TO CHECK +\n        RACF ---------*/\n           SET LP = &STR((\n      LPL: SET L = 0&L + 1\n           IF &EVAL(&L) > &EVAL(&LENGTH(&DSNAME.)) THEN DO\n              SET L = 0\n              GOTO LPLE\n           END\n           IF &SUBSTR(&L.:&L.,&STR(&DSNAME.)) = &STR(&LP.)  THEN GOTO +\n             LPLE\n           GOTO LPL\n    LPLE: -\n        IF &SUBSTR(1:1,&DSNAME.) ^= &STR(') THEN DO\n           SET DSNAME = '&DSNAME.'\n           IF &EVAL(&L) = &EVAL(0) THEN SET RDSNAME = &DSNAME\n           ELSE           SET RDSNAME = &SUBSTR(1:&L.,&DSNAME)&STR(')\n        END\n        ELSE DO\n           IF &EVAL(&L) = &EVAL(0) THEN SET RDSNAME = &DSNAME.\n           ELSE           SET RDSNAME = +\n             &SUBSTR(1:&EVAL(&L.-1),&STR(&DSNAME.))&STR(')\n        END\n      /*  ----------- CHECK FOR EXISTENCE OF THE DATASET ----*/\n       SET CHK =  &STR(&SYSDSN(&DSNAME.)\n       SET CC1 = &LASTCC\n       IF &STR(&CHK.) = OK THEN DO\n          /*  ------- MAKE AVAILABLE TO OTHER CLISTS --------*/\n          ISPEXEC     VPUT DSNAME SHARED\n          ISPEXEC     VPUT RDSNAME SHARED\n          /*  ------- TRAP SYSOUT FOR RACF CHECKING ---------*/\n          SET SYSOUTTRAP = 100\n          LD DATASET(&RDSNAME.)\n          SET SYSOUTTRAP = 0\n          SET N = &SYSOUTLINE\n          IF &SUBSTR(1:3,&STR(&SYSOUTLINE1.)       ) = ICH THEN -\n              IF &SUBSTR(1:8,&STR(&SYSOUTLINE1.)       ) ^= ICH35003 +\n                THEN DO\n                   SET &ZEDSMSG = &STR(NOT AUTHORIZED)\n                   SET &ZEDLMSG = &STR(&SYSOUTLINE1.) &STR(-- HIT +\n                     ENTER NOT PFK-3)\n       ISPEXEC     SETMSG MSG(ISRZ000)\n                   EXIT CODE(12)\n               END\n          /*  ------- DATASET EXITS AND RACF S/B HAPPY ------*/\nISPEXEC     EDIT DATASET(&DSNAME.) MACRO(DUADD)\n          EXIT CODE(0)\n       END\n       /* ----------- DATASET DOES NOT EXIST ----------------*/\n       WRITE &DSNAME. &STR(&CHK.)\n       SET &ZEDSMSG = &STR(INVALID DSN)\n       SET &ZEDLMSG = &STR(FAILED -- &CHK. -- &DSNAME.)\n       ISPEXEC     SETMSG MSG(ISRZ000)\n       WRITE TSO $EDIT FAILED FOR  DSNAME=&DSNAME.   DUE TO +\n         \"&STR(&CHK.)\"\n       WRITE AN EXAMPLE WITH A CORRECT SYNTAX IS    ===> TSO $EDIT +\n         &SYSUID..LIBR.CNTL\n       WRITE TSO $EDIT FAILED FOR  DSNAME=&DSNAME.   DUE TO +\n         \"&STR(&CHK.)\"\n       EXIT CODE(12)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DV2MM": {"ttr": 6152, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x002\\x002\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX: Convert xxxDV and xxxDH space units to xxx.xxMM for NX lines*/\n/* author: David McRitchie, \"The REXX Macros Toolbox\"          Jan 17, 1992 */\n/* FDM updated 1992/01/21 19:03 */\nAddress \"ISREDIT\"\n\"MACRO (TOKEN)\"\nnumeric digits(16)\nIf token = \"\" then token = 2\ndo forever\n   \"F first suffix p'#dv' nx\"\n   if rc /= 0 then leave\n   call common;\nend\ndo forever\n   \"F first suffix p'#dh' nx\"\n   if rc /= 0 then leave\n   call common;\nend\ndo forever\n   \"F first word p'#dv' nx\"\n   if rc /= 0 then leave\n   call common;\nend\ndo forever\n   \"F first word p'#dh' nx\"\n   if rc /= 0 then leave\n   call common;\nend\nreturn\ncommon: procedure expose token;\n   \"(LN,PO2) = CURSOR\"\n   \"f 'd' next nx\"\n   \"F prev  prefix p'#' nx\"\n   \"(LN,PO1) = CURSOR\"\n   \"(LINE) = LINE .ZCSR\"\n   from = substr(line,po1,po2-po1+1)\n   if token = 0 then to =trunc(from * .105833333  + .5)\n   else if token = 1 then to =trunc(from * 105833333   + .05,1)\n   else to =trunc(from * .105833333   + .005,2)\n   to=to; tox=to\n   linex = substr(line,1,po1-1)||TOX||\"mm\"||substr(line,po2+3)\n   \"LINE .zcsr = (linex)\"\n   /* optional  \"c 1 p'=' p'=' .zcsr .zcsr all\"*/\nreturn\n/*********************************************************************/\n/* to convert xxxDH to xxxMM multiply by .105833333                  */\n/*      (= 25.40 mm/in divided by 240 dh/in  )                       */\n/*      (= 25.40 / 240, round to 2 decimal places or as in TOKEN     */\n/* 240 DH/IN on 3800-3, do not use this clist for PostScript         */\n/* by law US inch = 2.54 cm,  or 1 yard = .9144 meters               */\n/*********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDITCHEK": {"ttr": 6154, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xaa\\x00\\xaa\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 170, "newlines": 170, "modlines": 0, "user": "MCRITCH"}, "text": "/* EDITCHEK  Author: David McRitchie, created 1988/02/02 IS03 rexx   */\n/*           at \"The REXX Macros Toolbox\", DMcRitchie@aol.com        */\n/*           For checking SCRIPT/VS tagging errors before use.       */\n/*           Updated 1992/02/03 21:43 IS03                           */\n/*           REXX    1994/04/06 12:49 IS03 conversion to REXX        */\n/*  This is one of many macros found at \"The REXX Macros Toolbox\":   */\n/*        http://members.aol.com/dmcritchie/nclist.htm               */\n/*********************************************************************/\n address \"ISREDIT\";\"MACRO (MAC)\"\n \"x all\" mac\n note = time('n') 'EDITCHEK    began'\n \"line_before .zf = noteline (note)\"\n \"find '########'p 73\"\n if rc = 0 then do\n    \"line_before .zf = noteline \"\"\",\n       \"col 73 may have residual sequence number(s)\"\"\"\n end\n err = 0; listerr = 0;  querr = 0;  qqerr = 0; errwatch=0\n \"find '.qq'\"; if rc = 0 then qqerr=1\n \"find ':qq'\"; if rc = 0 then qqerr=1\n if qqerr \\= 0 then do; err = err + 1\n    \"line_before .zf = noteline \"\".qq  (quick quit) found in data\"\"\"\n end;\n \"find '.qu'\"; if rc = 0 then querr=1\n \"find ':qu'\"; if rc = 0 then querr=1\n if querr = 1 then do; err = err + 1\n    \"line_before .zf = noteline \"\".qu  (quit) found in data\"\"\"\n end\n \"seek first '.rc '\"\n if rc = 0 then do\n /*  err = err + editpair(\"'$rc # on'p\",   \"'$rc # off'p\",  mac) */\n end\n err = err + editpair(\"'.li on'\",  \"'.li off'\", mac)\n err = err + editpair(\"'.su on'\",  \"'.su off'\", mac)\n err = err + editpair(\"x'50d6d84b'\",    \"x'50c3d84b'\", mac)\n err = err + editpair(\"x'50d6d8d84b'\",  \"x'50c3d8d84b'\", mac)\n err = err + editpair(':dt.',     ':dd.'   , mac)\n err = err + editpair(':gb10.',   ':egb10.', mac)\n err = err + editpair(':gb12.',   ':egb12.', mac)\n err = err + editpair(':gt10.',   ':egt10.', mac)\n err = err + editpair(':gt12.',   ':egt12.', mac)\n err = err + editpair(':gt15.',   ':egt15.', mac)\n err = err + editpair(':gt18.',   ':egt18.', mac)\n err = err + editpair(':gt22.',   ':egt22.', mac)\n err = err + editpair(':gt24.',   ':egt24.', mac)\n err = err + editpair(':gt',      ':egt'    , mac)\n err = err + editpair(':gb',      ':egb'    , mac)\n err = err + editpair(':hp0.',    ':ehp0.', mac)\n err = err + editpair(':hp1.',    ':ehp1.', mac)\n err = err + editpair(':hp2.',    ':ehp2.', mac)\n err = err + editpair(':hp3.',    ':ehp3.', mac)\n err = err + editpair(':hp4.',    ':ehp4.', mac)\n err = err + editpair(':hp5.',    ':ehp5.', mac)\n err = err + editpair(':hp6.',    ':ehp6.', mac)\n err = err + editpair(':hp7.',    ':ehp7.', mac)\n err = err + editpair(':hp8.',    ':ehp8.', mac)\n err = err + editpair(':hp9.',    ':ehp9.', mac)\n err = err + editpair(':hp10.',   ':ehp10.', mac)\n err = err + editpair(':hp11.',   ':ehp11.', mac)\n err = err + editpair(':hp12.',   ':ehp12.', mac)\n err = err + editpair(':hp13.',   ':ehp13.', mac)\n err = err + editpair(':hp14.',   ':ehp14.', mac)\n err = err + editpair(':hp15.',   ':ehp15.', mac)\n err = err + editpair(':hp16.',   ':ehp16.', mac)\n err = err + editpair(':hp17.',   ':ehp17.', mac)\n err = err + editpair(':hp18.',   ':ehp18.', mac)\n err = err + editpair(':hp19.',   ':ehp19.', mac)\n err = err + editpair(':hp',      ':ehp',    mac)\n err = err + editpair(':italic.', ':eitalic.', mac)\n err = err + editpair(':lq',      ':elq'  , mac)\n err = err + editpair(':pr12.',   ':epr12.', mac)\n err = err + editpair(':q.',      ':eq.', mac)\n err = err + editpair(':fm',      ':efm'    , mac)\n err = err + editpair(':fp',      ':efp'    , mac)\n err = err + editpair(':fm1.',    ':efm1.', mac)\n err = err + editpair(':fm4.',    ':efm4.', mac)\n err = err + editpair(':fp1.',    ':efp1.', mac)\n err = err + editpair(':fm2.',    ':efm2.', mac)\n err = err + editpair(':fp2.',    ':efp2.', mac)\n /* *******extended check  for :fn  :efn. **************/\n /*   :fnref. is not to be included  */\n \"seek all ':fn '                          \" mac\n \"(fncnt1s,fncnt1l) = seek_counts\"\n \"seek all ':fn.'                          \" mac\n \"(fncnt2s,fncnt2l) = seek_counts\"\n \"seek all ':efn.'                         \" mac\n /*                :efn.               */\n \"(fncnt3a) = seek_counts\"\n fncnt1a = fncnt1s + fncnt2s\n if fncnt1a \\= fncnt3a then do\n    \"line_before .zf = noteline\",\n       \"\"\"Unmatched  :fn(\"fncnt1a\") :efn(\"fncnt3a\")\"\"\"\n end\n /* *******extended check  for .kp on .kp off **************/\n \"seek all '.kp on '                       \" mac\n \"(kpcnt1s,kpcnt1l) = seek_counts\"\n \"seek all '.kp inline'                    \" mac\n \"(kpcnt2s,kpcnt2l) = seek_counts\"\n \"seek all '.kp off'                       \" mac\n \"(kpcnt3a) = seek_counts\"\n kpcnt1s = kpcnt1s + kpcnt2s\n if kpcnt1s \\= kpcnt3a then do\n    \"line_before .zf = noteline\",\n       \"\"\"unmatched  .kp on/inline (\"kpcnt1s\") .kp off (\"kpcnt3a\")\"\"\"\n end\n /* *******extended check  for .bf  .pf **************/\n \"seek all '.bf '                          \" mac\n \"(oqcnt1s,oqcnt2l) = seek_counts\"\n \"seek all '.pf '                          \" mac\n \"(cqcnt1s,cqcnt2l) = seek_counts\"\n \"seek all '.pf;'                          \" mac\n \"(cqcnt1a) = seek_counts\"\n /* .bf */\n cqcnt1s = cqcnt1s + cqcnt1a\n if oqcnt1s \\= cqcnt1s then do\n    \"line_before .zf = noteline\",\n       \"\"\"unmatched  .bf (\"oqcnt1s\") .pf (\"cqcnt1s\")\"\"\"\n end\n /* *******extended check  for lists (ol,dl,gl,sl,ul)        */\n listerr = 0\n listerr = listerr + editpair(':dl', ':edl', word mac)\n listerr = listerr + editpair(':gl', ':egl', word mac)\n listerr = listerr + editpair(':ol', ':eol', word mac)\n listerr = listerr + editpair(':sl', ':esl', word mac)\n listerr = listerr + editpair(':ul', ':eul', word mac)\n if listerr \\= 0 then do\n    \"line_before .zf = noteline \"\"unmatched list tags\",\n          \"(:ol,:dl,:gl,:sl,:ul) were found (see above)\"\"\"\n    /* :eol,:edl,:egl,:esl,:eul*/\n    \"line_before .zf = noteline \"\"      the EDITOL\",\n        \"macro can help determine nesting errors in these lists\"\"\"\n    err = err + listerr\n end\n err = err + editpair(':xmp.',    ':exmp.' , mac)\n if err \\= 0   then do\n    note = time('n') 'EDITCHEK    completed, found errors'\n    \"line_before .zf = noteline (note)\"\n end\n else do\n    note = time('n') 'EDITCHEK    completed,  looks good'\n    \"line_before .zf = noteline (note)\"\n end\n \"loc 0\"\n if rc \\= 0 then exit 1\n /* :ol.  force this as an error if editchek run against itself*/\n /* :ol.  force this as an error if editchek run against itself*/\n\n editpair: procedure expose errwatch\n arg open,close,range\n address \"ISREDIT\"\n \"seek all\" open range\n \"(open1,open1L) = seek_counts\"\n \"seek all\" close range\n \"(close1,close1L) = seek_counts\"\n open1=open1+0; close1=close1+0\n if open1 = close1 then return 0\n if errwatch = 0 then do\n    errwatch = errwatch + 1\n    note=\"Related clists -- checkdup, editol, editpr, period, plichk\"\n    \"line_before .zf = noteline (note)\"\n    note = \"Clists that add entries or change --\",\n        \"fixquote, fixpi, pinx, pinxdoit\"\n    \"line_before .zf = noteline (note)\"\n    note = \"       pir, ungml, lcfix, editpr\"\n    \"line_before .zf = noteline (note)\"\n end\n note = \"EDITCHEK found unmatched--\",\n      open\"(\"open1\"),  \"close\"(\"close1\")\"\n \"line_before .zfirst = noteline (note)\"\n return 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDITMEM": {"ttr": 6158, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00K\\x00K\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 75, "newlines": 75, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- EDITMEM -- edit membername found at cursor location       */\n/*  EDITMEM   ** CREATED BY D.MCRITCHIE 1991/05/06 \"The REXX Macros Toolbox\" */\n/*  REDONE IN REXX -- Feb 21, 1992                                   */\n/* **USAGE WOULD BE TO SET UP A PFKEY SUCH AS 20 ===> EDITCOL1       */\n/*     place curson on the member name,  and then hit PFK20          */\nAddress \"ISREDIT\"\n\"MACRO (TOKEN)\"\n\"(MEMBERX) = MEMBER \"\nmemberx = strip(memberx,'t')\n\"(DSNX)    = DATASET\"\nif token = \"CHK\" | token = \"chk\" then do; token = ''; chk=1; end;\nif token /= \" \" then do; line=token; signal gotone; end;\n\"(ROW,COL) = CURSOR\"\nif rc > 4 then exit\nIF COL = 0 THEN COL = 1\n\"(LINE) = line \" ROW\n\"(LABEL) = LABEL .ZCSR\"\nif rc /= 0 then \"LABEL .zcsr = .EDIT 0\"\nif ROW = 0 then do\n   ZEDSMSG = \"EDITMEM cursor\"\n   ZEDLMSG=\"EDITMEM -- no name found, since cursor has not been placed\"\n   address \"ISPEXEC\" \"SETMSG MSG(ISRZ001)\"\n   return 1\nend\nfrom = COL  /* in case cursor on a blank or something invalid */\ndo i = COL to 1 by -1;\n   L=verify(substr(line,i,1),'1234567890abcdefghijklmnopqrstuvwxyz'||,\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$')\n   if l /= 0 then leave\n   from = i\nend\nline = translate(substr(line,from))\nL=verify(line,'1234567890abcdefghijklmnopqrstuvwxyz'||,\n   'ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$')\nif l /=1 then line=substr(line,1,l-1)\nelse do\n   ZEDSMSG = \"no name\"\n   ZEDLMSG = \"EDITMEM did not find a name at line\" ROW ', col ' COL\n   address \"ISPEXEC\"   \"SETMSG MSG(ISRZ001)\"\n   return 1\nend\ngotone:\nline = translate(line)\nZEDSMSG = \"EDITMEM \"line\nZEDLMSG = \"EDITMEM edit macro invoked at cursor will EDIT \"line\naddress \"ISPEXEC\"   \"SETMSG MSG(ISRZ000)\"\nif dsnx = \"SCRIPT.EDFPRF30.TEXT\" then do\n   Address \"TSO\" \"$EDIT SCRIPT.EDFLIB30.MACLIB(\"line\")\"\n   return  /* group intercepts if BookMaster Profile*/\nend\nx = SYSDSN(\"'\"||dsnx||\"(\"||line||\")'\")\nif x /= \"OK\" then do\n   /* even though ISREDIT EDIT would work -- make this fail*/\n   ZEDSMSG = \"member\" line \"not found\"\n   ZEDLMSG = \"EDITMEM failed to obtain \"line \"--\" x\n   address \"ISPEXEC\"   \"SETMSG MSG(ISRZ001)\"\n   if chk = 1 then return 0; else return 1\nend\nif chk = 1 then do  /* only want to verify that it exits*/\n   ZEDSMSG = \"member\" line \"exists\"\n   ZEDLMSG = \"The member --\" line \"-- exists in the current directory\"\n   address \"ISPEXEC\"   \"SETMSG MSG(ISRZ001)\"\n   return 0\nend\naddress \"ISPEXEC\" \"Control errors Return\"\n\"edit \"line\naddress \"ISPEXEC\" \"Control errors cancel\"\nlastcc = rc\nif lastcc /= 0 then do\n   ZEDSMSG = \"member\" line \"failed rc=\"lastcc\n   line = translate(line)\n   ZEDLMSG = \"EDITMEM failed to obtain \"line \"--\" x\n   address \"ISPEXEC\"   \"SETMSG MSG(ISRZ001)\"\n   return 1\nend\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDITOL": {"ttr": 6401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01\\x02\\x01\\x02\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 258, "newlines": 258, "modlines": 0, "user": "MCRITCH"}, "text": "/*EDITOL    AUTHOR: DAVID MCRITCHIE, CREATED 1988/02/25 IS03 -REXX-  */\n/*          AT \"THE REXX MACROS TOOLBOX\", DMCRITCHIE@AOL.COM    */\n/*          UPDATED 1990/11/14 21:14 IS03                            */\n/*          UPDATED 1992/04/13 09:26 IS03 TO FIT IN 71 COLUMNS       */\n/*********************************************************************/\n/* TITLE:       EDITOL THE INCLUSIVE LINES BETWEEN TWO LABELS        */\n/* USERS:       TSO ISPF EDIT USERS   | SCRIPT USERS                 */\n/* CONTRIBUTED: 1987/02/19 DAVID MCRITCHIE                           */\n/*                                                                   */\n/* EXAMPLE:     EDITOL   .ZFIRST .ZLAST                              */\n/*                                                                   */\n/* OPTIONS:                                                          */\n/*     LPTR-RANGE | ENTIRE   (REQUIRED) LINE POINTER RANGE           */\n/*  <<<ADDITIONAL OPERANDS>>>                                        */\n/* PURPOSE -- CHECK   NESTING OF  :OL :EOL   ETC.                    */\n/*********************************************************************/\n/*  REQUIREMENTS:                                                    */\n/*       TWO LABELS AND SEVERAL PAIRS OF COLUMNS                     */\n/*  OPTIONS:                                                         */\n/*       LVL1       LEVEL 1 :LI LINES SO CAN BE USED WITH PINX       */\n/*       LVL2       LEVEL 2 :LI LINES OF COLUMNS                     */\n/*       LVL3       LEVEL 3 :LI LINES OF COLUMNS                     */\n/*       NEST    SHOW NESTING UNDER EACH :OL :SL :UL (:GL) :DL       */\n/*  EXAMPLES OF USE:                                                 */\n/*       ===> EDITOL                                                 */\n/*       ===>LEDITOL LVL2; LABNX; EDITOL LVL1                        */\n/*       ===>LEDITOL NEST                                            */\n/*  ...............................................                  */\n/*  NEED TO OBTAIN STARTING LABELS OF REFBEG REFEND                  */\n/*  ...............................................                  */\n/*********************************************************************/\n   ADDRESS \"ISREDIT\"; \"MACRO (TOKEN)\"\n   TOKEN = TRANSLATE(' '||TOKEN||' ')\n   LABF='.ZFIRST';LABL='.ZLAST';NOGOOD=''\n   LVLXX=0\n   ECTL = '**ERROR** ATTEMPTING TO USE      ==>',\n         'EDITOL' SUBSTR(TOKEN,1,23) TIME('N')\n   PTR = 1\n   DEBUG  = PROCESS('DEBUG')\n   ENTIRE= PROCESS('ENTIRE')\n   HELP = PROCESS('HELP')\n   LVL1 = PROCESS('LVL1')\n   LVL2 = PROCESS('LVL2')\n   LVL3 = PROCESS('LVL3')\n   NEST = PROCESS('NEST')\n   NX   = PROCESS('NX')\n   X    = PROCESS('X')\n   PARSE VAR TOKEN LEFT '.' LABF ' ' RIGHT\n   TOKEN = LEFT RIGHT\n   IF LABF \\= '' THEN LABF = '.'||LABF\n   PARSE VAR TOKEN LEFT '.' LABL ' ' RIGHT\n   TOKEN = LEFT RIGHT\n   IF LABL \\= '' THEN LABL = '.'||LABL\n   PARSE VAR TOKEN LEFT '.' NOGOOD ' ' RIGHT\n   TOKEN = LEFT RIGHT\n   IF NOGOOD \\= '' THEN DO\n     ZEDSMSG = 'LABEL 'TOKEN''\n     ZEDLMSG = \"EXACTLY TWO LABELS ARE REQUIRED FOUND\",\n            LABF\",  \"LABL\"  AND   .\"NOGOOD\n     ADDRESS \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n     RETURN 12\n   END\n   IF TOKEN \\= '' THEN DO\n     ZEDSMSG = '?' TOKEN\n     ZEDLMSG = 'INVALID PARAMETER(S) FOR EDITOL, REMOVE OR CORRECT'\n     ADDRESS \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n     RETURN 12\n   END\n END_TOK:\n /****************************************************************/\n  /****************** CODE FOR  EDITOL COMMANDS ***************/\n  /****************** CODE FOR  EDITOL COMMANDS ***************/\n  /****************** CODE FOR  EDITOL COMMANDS ***************/\n  ERROR=0; LEVEL=0; LVLDL=0; LVLGL=0; LVLOL=0; LVLSL=0; LVLUL=0;\n  IF  LABF  = '' THEN DO\n     LABF = '.ZFIRST'\n     LABL = '.ZLAST'\n  END\n  IF LABL = '' THEN DO\n     ZEDSMSG = '2ND LABEL'\n     ZEDLMSG = '2ND LABEL IS MISSING'\n     ADDRESS \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n     RETURN 12\n  END\n  \"(PTR) = LINENUM\" LABF\n  \"(PTRL) = LINENUM\" LABL\n  \"X ALL\" LABF   LABL\n  \"LABEL .ZF = .TAGOL 1\"\n  IF RC = 0 THEN \"RESET LABEL .TAGOL .TAGOL\"\n  \"LABEL .ZF = .TAGSL 1\"\n  IF RC = 0 THEN \"RESET LABEL .TAGSL .TAGSL\"\n  \"LABEL .ZF = .TAGUL 1\"\n  IF RC = 0 THEN \"RESET LABEL .TAGUL .TAGUL\"\n LOOP:\n  \"CURSOR =\" PTR  1\n  \"(VAR036) = LINE .ZCSR\"\n  X3 = SUBSTR(VAR036,1,3)\n  X3 = TRANSLATE(X3)\n  X4 = SUBSTR(VAR036,1,4)\n  X4 = TRANSLATE(X4)\n  IF X3 = ':OL' THEN DO\n        IF LVLOL = 0 THEN \"LABEL .ZCSR = .TAGOL 0\"\n        LEVEL =  LEVEL  + 1\n        LVLOL =  LVLOL  + 1\n        CALL   NESTX OL LVLOL\n  END\n  IF X4 = ':EOL' THEN DO\n        LEVEL = LEVEL - 1\n        LVLOL = LVLOL - 1\n        IF LVLOL = 0 THEN \"RESET LABEL .TAGOL .TAGOL\"\n        CALL UNNESTX OL LVLOL\n        SIGNAL TSTLVL\n  END\n  /* -----------*/\n  IF X3 = ':SL' THEN DO\n        IF LVLSL = 0 THEN \"LABEL .ZCSR = .TAGSL 0\"\n        LEVEL = LEVEL + 1\n        LVLSL = LVLSL + 1\n        CALL   NESTX SL LVLSL\n  END\n  IF  X4   = ':ESL' THEN DO\n        LEVEL =  LEVEL - 1\n        LVLSL =  LVLSL - 1\n        IF  LVLSL = 0 THEN \"RESET LABEL .TAGSL .TAGSL\"\n        CALL UNNESTX SL LVLSL\n        SIGNAL TSTLVL\n  END\n  /* -----------*/\n  IF  X3   = ':UL' THEN DO\n        IF LVLUL = 0 THEN \"LABEL .ZCSR = .TAGUL 0\"\n        LEVEL = LEVEL + 1\n        LVLUL = LVLUL + 1\n        CALL   NESTX UL LVLUL\n  END\n  IF  X4   = ':EUL' THEN DO\n        LEVEL = LEVEL - 1\n        LVLUL = LVLUL - 1\n        IF LVLUL = 0 THEN \"RESET LABEL .TAGUL .TAGUL\"\n        CALL UNNESTX UL LVLUL\n        SIGNAL TSTLVL\n  END\n  /* -----------*/\n  IF  X3   = ':DL' THEN DO\n        IF LVLDL = 0 THEN \"LABEL .ZCSR = .TAGDL 0\"\n        LEVEL = LEVEL + 1\n        LVLDL = LVLDL + 1\n        CALL   NESTX DL LVLDL\n  END\n  IF X4 = ':EDL' THEN DO\n        LEVEL = LEVEL - 1\n        LVLDL = LVLDL - 1\n        IF LVLDL = 0 THEN \"RESET LABEL .TAGDL .TAGDL\"\n        CALL UNNESTX DL LVLDL\n        SIGNAL TSTLVL\n  END\n  /* -----------*/\n  IF X3 = ':GL' THEN DO\n        IF LVLGL = 0 THEN \"LABEL .ZCSR = .TAGGL 0\"\n        LEVEL = LEVEL + 1\n        LVLGL = LVLGL + 1\n        CALL   NESTX GL LVLGL\n  END\n  IF X4 = ':EGL' THEN DO\n        LEVEL = LEVEL - 1\n        LVLGL = LVLGL - 1\n        IF LVLGL = 0 THEN \"RESET LABEL .TAGGL .TAGGL\"\n        CALL UNNESTX GL LVLGL\n        SIGNAL TSTLVL\n  END\n  /* -----------*/\n  IF X3 \\= ':LI' THEN SIGNAL TSTHD\n  IF  LEVEL <   1 THEN DO\n     \"LINE_AFTER .ZCSR = NOTELINE\",\n         \"\"\":LI ERROR -- LEVEL =\"LEVEL,\n         \"OL=\"LVLOL\" SL=\"LVLSL\" UL=\"LVLUL\"\" TIME('N')\"\"\"\"\n     ERROR =  ERROR + 1\n     IF ERROR = 1 THEN DO\n        \"LINE_AFTER .ZCSR = MSGLINE 'ERROR=1 \"VAR036\"'\"\n     END\n     IF ERROR    > 20 THEN RETURN 12\n  END\n  /* -----------*/\n TSTLVL:\n  IF  LEVEL < 0 | LVLOL < 0 | LVLSL < 0 | ,\n        LVLUL  < 0 | LVLDL < 0 THEN DO\n     \"LINE_AFTER .ZCSR = NOTELINE \"\"LEVEL=\"LEVEL,\n       \" OL=\"LVLOL\" SL=\"LVLSL\" UL=\"LVLUL\" DL=\"LVLDL\" --\" TIME('N')\"\"\"\"\n     ERROR =  ERROR + 1\n     IF ERROR > 20 THEN RETURN 12\n  END\n  IF LVL1 = \"LVL1\"  THEN IF LEVEL = 1 THEN\n     \"F LAST ' ' .ZCSR .ZCSR\"\n  IF LVL2 = LVL2 THEN IF LEVEL = 2 THEN\n     \"F LAST ' ' .ZCSR .ZCSR\"\n  IF LVL3 = LVL3 THEN IF LEVEL = 3 THEN\n     \"F LAST ' ' .ZCSR .ZCSR\"\n  /* -----------*/\n  TSTHD:\n  IF X3 = ':H1' | X3 = ':H2' | X3 = ':H3' | X3 = ':H4' | X3 = ':H5' |,\n            X3 = ':H6' ,\n        THEN DO\n        IF LEVEL \\= 0 THEN DO\n           ERROR =  ERROR + 1\n           IF  ERROR > 20 THEN RETURN 12\n           \"LINE_BEFORE .ZCSR = NOTELINE \"\"\",\n             \"LEVEL=\"LEVEL \"OL=\"LVLOL\" SL=\"LVLSL\" UL=\"LVLUL,\n              \"DL=\"LVLDL\" GL=\"LVLGL\" -- \"TIME('N')\"\"\"\"\n           \"LINE_AFTER  .ZCSR = NOTELINE \"\"\",\n             \"OPEN OR INVALID LIST STATUS ENCOUNTERED AT\" X3 \"\"\"\"\n           \"RESET .ZCSR .ZCSR X\"\n           IF LVLOL  > 0 THEN \"RESET .TAGOL .TAGOL\"\n           IF LVLSL  > 0 THEN \"RESET .TAGSL .TAGSL\"\n           IF LVLUL  > 0 THEN \"RESET .TAGUL .TAGUL\"\n           IF LVLDL  > 0 THEN \"RESET .TAGDL .TAGDL\"\n           IF LVLGL  > 0 THEN \"RESET .TAGGL .TAGGL\"\n           LVLOL = 0; LVLSL=0; LVLUL=0; LVLDL=0; LVLGL=0; LEVEL=0;\n           \"RESET .ZCSR .ZCSR X\"\n        END\n  END\n  /* -----------*/\n  NXT:\n  PTR =  PTR + 1\n  IF  PTR  <  PTRL  THEN SIGNAL LOOP\n  IF LVLGL  \\= 0 THEN \"LINE_AFTER .ZCSR = NOTELINE\",\n       \"\"\"LEVEL=\"LEVEL\" GL=\"LVLGL\" -- \"TIME('N')\"\"\"\"\n  \"LINE_AFTER .ZL = NOTELINE \",\n       \"\"\"LEVEL =\"LEVEL\"  OL=\"LVLOL\"  SL=\"LVLSL\" UL=\"LVLUL,\n       \"DL=\"LVLDL\" GL=\"LVLGL\" -- \" TIME('N')\"\"\"\"\n  \"LINE_BEFORE .ZF = NOTELINE \"\"EDITOL OPTIONS\",\n    \"AVAILABLE INCLUDE  -- LVL1 LVL2 LVL3 NEST\"\"\"\n  RETURN 0\n NESTX:\n  ARG TYPE LVLXX\n  IF NEST = \"NEST\" THEN\n     \"LINE_AFTER .ZCSR = NOTELINE \",\n       \"\"\"LEVEL=\"LEVEL TYPE\"=\"LVLXX\"\"\"\"\n  IF (LVL1 = \"LVL1\" & LEVEL=1) ,\n   | (LVL2 = \"LVL2\" & LEVEL=2) ,\n   | (LVL3 = \"LVL3\" & LEVEL=3) THEN\n       \"RESET .ZCSR .ZCSR X\"\n RETURN\n UNNESTX:\n  ARG TYPE LVLXX\n  IF NEST = \"NEST\" THEN\n     \"LINE_AFTER .ZCSR = NOTELINE \",\n       \"\"\"LEVEL=\"LEVEL TYPE\"=\"LVLXX\"\"\"\"\n  IF (LVL1 = \"LVL1\" & LEVEL=0) ,\n   | (LVL2 = \"LVL2\" & LEVEL=1) ,\n   | (LVL3 = \"LVL3\" & LEVEL=2) THEN\n       \"RESET .ZCSR .ZCSR X\"\n RETURN;\nPROCESS: PROCEDURE EXPOSE TOKEN\n ARG SUBTOKEN\n I = POS(' '||SUBTOKEN||' ',TOKEN)\n IF I=0 THEN RETURN ''\n TOKENX = SUBSTR(TOKEN,1,I) || SUBSTR(TOKEN,I+2+LENGTH(SUBTOKEN))\n TOKEN = TOKENX\n RETURN SUBTOKEN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDITPAGE": {"ttr": 6406, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00U\\x00U\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 85, "newlines": 85, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- converted to REXX on 1994/06/03 */\nADDRESS \"ISREDIT\"\n/*EDITPAGE  AUTHOR: DAVID MCRITCHIE, CREATED 1988/01/29 IS03    */\n/*          AT \"The REXX Macros Toolbox\", DMcRitchie@aol.com    */\n/*          UPDATED 1988/02/02 20:27 IS03A                      */\n/* Purpose: To identify members and specific text that may have to be\n            changed in upgrading from line printers (1403, 38PP) to\n            page printing (3820, 4028), and/or PostScript (PS). */\n \"MACRO (macarg)\"\n macarg = translate(macarg)\n \"Exclude ALL\"\n ERR = 0\n \"SEEK ALL ':Q.'\"\n \"(OQCNT1S,OQCNT2L) = SEEK_COUNTS\"\n oqcnt1s=oqcnt1s+0; oqcnt2l=oqcnt2l+0\n \"SEEK ALL ':EQ.'\"\n \"(CQCNT1S,CQCNT2L) = SEEK_COUNTS\"\n cqcnt1s=cqcnt1s+0; cqcnt2l=cqcnt2l+0\n IF OQCNT1S \\= CQCNT1S THEN DO\n    \"LINE_BEFORE .ZF = NOTELINE \"\"\"time(\"n\")  \":Q.\",\n    OQCNT1S \":EQ.\" CQCNT1S \" -- PLICHK MAY HELP\"\"\"\n    ERR = ERR  + 1\n END\n \"SEEK ALL ':HP1'\"\n \"(OQCNT1S,OQCNT2L) = SEEK_COUNTS\"\n oqcnt1s=oqcnt1s+0; oqcnt2l=oqcnt2l+0\n \"SEEK ALL ':EHP1'\"\n \"(CQCNT1S,CQCNT2L) = SEEK_COUNTS\"\n cqcnt1s=cqcnt1s+0; cqcnt2l=cqcnt2l+0\n IF OQCNT1S \\= CQCNT1S THEN DO\n    \"LINE_BEFORE .ZF = NOTELINE \"\"\"time(\"n\")  \":Q.\",\n    OQCNT1S \":EQ.\" CQCNT1S \"-- PLICHK MAY HELP\"\"\"\n    ERR = ERR  + 1\n END\n signal SKIP1    /* ------- Signal ----------*/\n \"Find '38PP' WORD FIRST\"\n IF rc = 0 then IF ERR = 0 then do; \"end\"; exit 0; end;\nSKIP1:\n \"Find '.TB' ALL\"\n \"Find '.TP' ALL\"\n \"Find '.BX' ALL\"\n \"Find '.BF' ALL\"\n \"Find '.PF' ALL\"\n \"Find '+--' ALL\"\n \"Exclude 1 '.BX      ' ALL\"\n \"Exclude 1 '.BX OFF    ' ALL\"\n \"Exclude 1 '.BX CAN    ' ALL\"\n\n \"Find FIRST P'^' NX\"\n IF rc \\= 0 & X = \"\" then Do; \"END\"; Exit 0; end\n\n \"SEEK ALL ':Q.'\"\n \"(OQCNT1S,OQCNT2L) = SEEK_COUNTS\"\n oqcnt1s=oqcnt1s+0; oqcnt2l=oqcnt2l+0\n \"SEEK ALL ':EQ.'\"\n \"(CQCNT1S,CQCNT2L) = SEEK_COUNTS\"\n cqcnt1s=cqcnt1s+0; cqcnt2l=cqcnt2l+0\n IF OQCNT1S \\=  CQCNT1S THEN DO\n    call note \"FIXQUOTE results\" time(\"n\") \":Q.\",\n       OQCNT1S \":EQ.=\"CQCNT1S \"-- PLICHK may help\"\n    \"Find FIRST \"Q.\" NX\"\n    ERR = ERR  + 1\n END\n IF OQCNT2L \\= CQCNT2L THEN DO\n     call note \"FIXQUOTE MATCHED(\"CQCNT1S\"), --lines unmatched--\",\n          \":Q.\" OQCNT2L\", :EQ\" CQCNT2L \"--PLICHK may help\"\n END\n call note \"FIXQUOTE\" Substr(time(\"n\"),1,5),\n      \"looks good MATCHED\" OQCNT1S,\n      \":Q strings to :EQ. on\" OQCNT2L \"lines\"\n \"SEEK ALL '\"\"' \"\n \"(CQCNT1S,CQCNT2L) = SEEK_COUNTS\"\n IF CQCNT1S \\= 0 THEN DO\n     cqcnt1s=cqcnt1s+0; cqcnt2l=cqcnt2l+0\n     call note \"   However, found\" cqcnt1s \"stray orphan double\",\n         \"quotes -- PLICHK MAY HELP\"\n     \"Find FIRST \"\"Q.\"\" NX\"\n END\n \"(VAR014A) = DATA_CHANGED\"\n IF macarg = \"END\" THEN IF VAR014A = \"NO\" THEN \"END\"\n return\n\nnote:  parse arg arg\n    \"LINE_BEFORE .ZFIRST = NOTELINE (arg)\"\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDITPAIR": {"ttr": 6409, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x1e\\x00\\x1e\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "MCRITCH"}, "text": " /* REXX -- converted to REXX on 1994/06/03 */\n ADDRESS \"ISREDIT\"\n \"MACRO (MAC1 MAC2 MAC)\"\n /*EDITPAIR  AUTHOR: DAVID MCRITCHIE, CREATED 1988/02/02 IS03  */\n /*          AT \"The REXX Macros Toolbox\", DMcRitchie@aol.com    */\n /*          UPDATED 1990/10/19 16:14 IS03                     */\n /***********************************************************************/\n /*  TITLE:       EDITPAIR -- CHECK FOR MATCHED PAIR COMBINATION       **/\n /*  USERS:       TSO ISPF EDIT USERS   | SCRIPT USERS                 **/\n /*  CONTRIBUTED: 1987/01/20 DAVID MCRITCHIE                           **/\n /*                                                                    **/\n /*  EXAMPLE:     EDITPAIR                                             **/\n /*                                                                    **/\n /*  OPTIONS:                                                          **/\n /*      COL1 COL2  .LABEL1 .LABEL2  NX                                **/\n /*      NX   CANNOT BE USED WITH OTHER OPTIONS                        **/\n /***********************************************************************/\n  /* SCRIPT CONVERSION TO PAGE USAGE -- D.MCR                        */\n  \"SEEK ALL\" mac mac1\n  \"(OQCNT1S,OQCNT2L) = SEEK_COUNTS\"\n  \"SEEK ALL\" mac mac2\n  \"(CQCNT1S,CQCNT2L) = SEEK_COUNTS\"\n IF OQCNT1S \\= CQCNT1S THEN DO\n     \"LINE_BEFORE .ZF = NOTELINE \"\"UNMATCHED     \",\n        MAC1 \"(\"OQCNT1S\"),\" MAC2 \"(\"CQCNT1S\") --\" MAC\"\"\"\"\n     \"LINE_BEFORE .ZF = NOTELINE \"\"TRY USING     \",\n        \"%EDITPR\"  mac1 mac2 mac\"\"\"\"\n     Exit 1\n END\n return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDITPR": {"ttr": 6411, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xee\\x00\\xee\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 238, "newlines": 238, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX ***************************************************************\n   EDITPR    AUTHOR: DAVID MCRITCHIE, CREATED 1989/02/11 IS03         *\n             AT \"THE REXX MACROS TOOLBOX\", DMCRITCHIE@AOL.COM    *\n             UPDATED 1990/10/19 16:11 IS03                            *\n             UPDATED 1992/04/21 IS03 RESET P3 (ERRORS) IF P1 P2 MATCH *\n             UPDATED 1992/05/30 IS03 SINGLE QUOTED STRINGS, OPTIONAL  *\n  *********************************************************************\n   TITLE:       EDITPR   -- CHECK FOR MATCHED PAIR COMBINATION        *\n   USERS:       TSO ISPF EDIT USERS   | SCRIPT USERS                  *\n   CONTRIBUTED: 1989/02/09 DAVID MCRITCHIE                            *\n                                                                      *\n   EXAMPLE:     EDITPR  :GT12. :EGT12.                                *\n                EDITPR  '.KP ON' '.KP OFF'                            *\n                EDITPR  .ZF .ZL .STRING1 .STRING2  (LABELS FIRST HERE)*\n                                                                      *\n   OPTIONS:                                                           *\n       LABEL-PAIR                                                     *\n       COL-PAIR                                                       *\n       NX                                                             *\n       WORD                                                           *\n                                                                      *\n    ANY OTHER OPERANDS CAN BE ADDED AFTER THE EDIT PAIR HAS           *\n      BEEN INCLUDED.  IF EITHER OF THE EDIT PAIR LOOKS LIKE           *\n      A LABEL YOU MUST FIRST INCLUDE  ACTUAL LABELS AT THE            *\n      BEGINNING SUCH AS THE DEFAULTED  .ZF  .ZL  COMBINATION.         *\n  ****************************************************************/\n/*********************************************************************/\n  /*INITIALIZE INIT */\n ADDRESS 'ISREDIT'; 'MACRO (PARMS) NOPROCESS';\n NOTE = 'LINE_BEFORE .ZFIRST = NOTELINE '\n AFTER=0; BEFORE=0; CHANGE='';\n LABF=''; LABL=''; REMAINDER='';\n SEPSTR='';FROMCOL='';TOCOL='';FORCOL='';FLAGS=0;\n DEBUG='';TEST='';X='';NX='';WORD='';PAIR1='';PAIR2='';\n\n /* COLLECT PARAMETERS */\n IF PARMS = '' THEN DO;  /* NO PARAMETERS -- DEFAULT TO A TEST*/\n    ZEDSMSG = ''\n    ZEDLMSG = \"TESTXXXX MISSING OPERANDS SUCH AS\",\n       \"AFTER(N) BEFORE(N) CHG CHANGE\"\n    ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    EXIT 8\n END\nPARMS = TRANSLATE(PARMS)\n\n/* NOT SUITED FOR IMBEDDED BLANKS BUT WILL SEE INITIAL ENDING QUOTES*/\n DO III = 1 TO 10;\n   TOKEN = WORD(PARMS,III)\n   IF TOKEN = '' THEN LEAVE\n   TOKENX = TRANSLATE(TOKEN);\n   IF TOKENX = \"DEBUG\" THEN TRACE INTERMEDIATE\n   J = POS(TOKENX,' X NX WORD DEBUG TEST ')\n   IF J <> 0 THEN DO;\n      STRING = TOKEN ' = '''TOKEN''''; INTERPRET  STRING; ITERATE III;\n   END;\n   IF SUBSTR(TOKEN,1,6) = 'AFTER(' THEN DO;\n      PARSE VAR TOKEN  'AFTER(' AFTER ')' RIGHT; ITERATE III;\n   END\n   IF 'BEFORE(' = SUBSTR(TOKEN,1,7)  THEN DO;\n      PARSE VAR TOKEN  'BEFORE(' BEFORE ')' RIGHT; ITERATE III;\n   END\n   IF SUBSTR(TOKEN,1,1) = '.' THEN DO\n      IF LABF = '' THEN LABF = TOKEN\n      ELSE IF LABL = '' THEN LABL = TOKEN\n      ELSE DO\n            ZEDSMSG = '.LABEL RC=8'\n            ZEDLMSG = 'TOO MANY LABELS --' LABF LABL TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            EXIT 8\n      END\n      ITERATE III\n   END\n\n   IF PAIR1 = '' THEN DO;PAIR1 = TOKEN; ITERATE III; END;\n   IF PAIR2 = '' THEN DO;PAIR2 = TOKEN; ITERATE III; END;\n\n   IF SUBSTR(TOKEN,1,1) = \"'\" THEN DO /* \"'\"*/\n      SEPSTR = SUBSTR(TOKEN,2,VALUE(LENGTH(TOKEN)-2))\n      ITERATE III\n   END\n\n   SAY 'TESTING REMAINDER --' TOKEN '<--'\n   REMAINDER = REMAINDER TOKEN\n END III\n\n IF REMAINDER <> \"\" THEN DO\n    ZEDSMSG =  REMAINDER\n    ZEDLMSG =  REMAINDER \"-- PARAMETERS UNKNOWN TO TESTXXXX\"\n    ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    EXIT 8\n END\n\n/* PROCESS ADDITIONAL LABEL / RANGE RELATIONSHIPS */\nIF LABL = '' THEN DO\n   \"PROCESS RANGE C\"\n   IF RC = 0 THEN DO\n      \"LABEL .ZFRANGE = .LABF 1\"\n      \"LABEL .ZLRANGE = .LABL 1\"\n      LABF = \".LABF\"\n      LABL = \".LABL\"\n   END\nEND\nIF LABL = '' THEN DO; LABF='.ZFIRST'; LABL='.ZLAST'; END;\n\"(LABFNO) = LINENUM\" LABF\n\"(LABLNO) = LINENUM\" LABL\n\n\n/****** ALL PARAMETERS HAVE BEEN RECEIVED -- PROCESS RELATIONSHIPS */\n /************************** CODE FOR EDITPR COMMANDS ***************/\n /************************** CODE FOR EDITPR COMMANDS ***************/\n /************************** CODE FOR EDITPR COMMANDS ***************/\n  IF SUBSTR(PAIR1,1,1) = \":\"  &  SUBSTR(PAIR2,1,1) = \":\"\n     THEN TAG = \"TAG\"; ELSE TAG = \"\"\n  P1 = 0\n  P2 = 0\n  P3 = 0\n  PAIR1X = \"'\"PAIR1\"'\"\n  PAIR2X = \"'\"PAIR2\"'\"\n  \"(VAR013,VAR014) = CURSOR\"\n  \"FIND FIRST\" LABF LABL PAIR1X\n  IF RC \\= 0 THEN DO\n     \"FIND FIRST\" LABF   LABL  PAIR2X\n     IF RC \\= 0 THEN DO\n        ZEDSMSG = \"NOT FOUND\"\n        ZEDLMSG = \"NEITHER\" PAIR1X \"NOR\" PAIR2X \"FOUND WITHIN\",\n             \"DATA\" LABF LABL\n        \"LINE_BEFORE .ZCSR    = NOTELINE \"\"*ERROR**\" ZEDLMSG\"\"\"\"\n        ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n        \"LINE_AFTER\" VAR013 \" =  NOTELINE \"\"NO\" PAIR1X PAIR2X,\n             \"PAIRS FOUND\"\"\"\n        EXIT 8\n     END\n  END\n  \"LOC\" LABF\n  \"CURSOR =\" LABF \"0\"\n  /* NEXT LINE ASSUME YOU HAVE MATCHED ON :_EGT12. */\n/*ISREDIT F PREV P'='*/\n LOOPF:\n   IF P1 \\= P2 THEN DO\n      P3 = P3 + 1\n      IF P3 > 10 THEN DO\n          ZEDSMSG = \"TOO MANY ERRORS\"\n          ZEDLMSG = \"ERROR COUNT LOOP EXCEEDS 10\"\n          \"LINE_BEFORE .ZCSR    = NOTELINE \"\"*ERROR**\" ZEDLMSG\"\"\"\"\n          ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n          FLAGS = FLAGS + 1\n          EXIT 8\n      END\n   END\n  \"(CUR01,CUR02) = CURSOR\"\n  \"FIND NEXT\" NX   WORD    PAIR1X\n  IF RC  = 0 THEN DO\n     \"(CUR11,CUR12) = CURSOR\"\n     VALF =  CUR11 * 1000 +  CUR12\n  END\n  ELSE VALF = 999999999\n  \"CURSOR =\" CUR01   CUR02\n  \"FIND NEXT\" NX WORD PAIR2X\n  IF RC = 0 THEN DO\n     \"(CUR21,CUR22) = CURSOR\"\n     VALLST =  CUR21 * 1000 +  CUR22\n  END\n  ELSE VALLST = 999999999\n  IF VALF = VALLST THEN SIGNAL ENDED\n  IF VALF = 999999999 THEN DO\n     P2 = P2 + 1\n     \"LINE_AFTER .ZCSR = NOTELINE  \"\"\"P1\"-\"P2 \"FOUND\",\n        \"UNMATCHED\" PAIR2X WORD TAG CUR21 CUR22 AFTER \"LAST\",\n        PAIR1X CUR01 CUR02\"\"\"\"\n     \"LABEL .ZCSR = .ERROR  0\"\n     FLAGS = FLAGS + 1\n     IF P1 = P2 THEN P3 = 0\n     EXIT 4\n  END\n  IF VALLST = 999999999 THEN DO\n     P1 = P1 + 1\n     P3 = P3 + 1\n     \"LINE_AFTER .ZCSR =  NOTELINE  \"\"\"P1\"-\"P2\" FOUND\",\n        \"UNMATCHED\" PAIR1X WORD TAG CUR01 CUR02 AFTER \"LAST\" PAIR2X\"\"\"\"\n     FLAGS = FLAGS + 1\n     IF P1 = P2 THEN P3 = 0\n     \"LABEL .ZCSR = .ERROR  0\"\n     SIGNAL FINISH\n  END\n  IF VALF < VALLST THEN DO\n    \"CURSOR =\" CUR11 CUR12\n    \"FIND NEXT\" NX WORD PAIR1X\n    IF RC = 0 THEN DO\n       \"(CUR31,CUR32) = CURSOR\"\n       VALCHK =  CUR31  * 1000  + CUR32\n       IF VALCHK > VALLST THEN DO\n          P1 = P1  + 1\n          P2 = P2  + 1\n          \"CURSOR =\" CUR21 CUR22\n          CUR21 =  CUR21 + 0\n          CUR22 =  CUR22 + 0\n          SIGNAL LOOPF\n       END\n       \"LINE_AFTER\" CUR31  \"= NOTELINE\",\n            \"\"\"\"VALUE(P1+2)\"-\"P2,\n            \"BEGIN\" PAIR1X TAG CUR31\".\"CUR32,\n            \"REPEAT OF\" CUR11\".\"CUR12,\n            \"CHECK FOR MISSING\" PAIR2X TAG\"\"\"\"\n       \"LINE_AFTER\" CUR11 \"= NOTELINE \"\"\"VALUE(P1+1)\"-\"P2,\n         \"BEGIN\" PAIR1X TAG \"ABOVE ON\" CUR11\".\"CUR12 \"IS MISSING\",\n         \"AN ENDING\" PAIR2X TAG\"\"\"\"\n       P1 = P1  + 1\n       FLAGS = FLAGS + 1\n       \"CURSOR =\" CUR11 CUR12\n       SIGNAL LOOPF\n    END\n    P1 = P1  + 1\n    P2 = P2 + 1\n    \"CURSOR =\" CUR21 CUR22\n    SIGNAL LOOPF\n  END\n  P2 = P2 + 1\n  FLAGS = FLAGS + 1\n  \"LINE_AFTER\" CUR21 \"= NOTELINE \",\n     \"\"\"\"P1\"-\"P2\" UNMATCHED END\" WORD PAIR2X TAG \"ABOVE ON\",\n     CUR21 CUR22\"\"\"\"\n  \"CURSOR =\" CUR21 CUR22\n  IF P1 = P2 THEN P3 = 0\n  SIGNAL LOOPF\n ENDED:\n  IF P1 = P2 THEN DO\n     \"LINE_AFTER .ZCSR = NOTELINE\",\n       \"\"\"\"P1\"-\"P2\" MATCHED,\" P1 PAIR1X TAG,\n       APOST||\"S VS\" P2 PAIR2X TAG  APOST||\"S\"\"\"\n     \"CURSOR =\" VAR013 VAR014\n     IF FLAGS \\= 0 THEN EXIT 4\n     EXIT 1\n  END\n  FINISH:\n  \"LINE_AFTER .ZCSR = NOTELINE \"\"\"||,\n    P1\"-\"P2\" UNMATCHED\" WORD\", \" P1 PAIR1X TAG WORD,\n       APOST||\"S VS\" P2 PAIR2X TAG  APOST||\"S\"\"\"\n  EXIT 4\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDITPS": {"ttr": 6659, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00C\\x00C\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 67, "newlines": 67, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- Check for SCRIPT control words that ensure page is started*/\n/* David McRitchie, \"The REXX Macros Toolbox\", January 15, 1992 */\n  Address \"ISREDIT\"\n  \"MACRO NOPROCESS (TOKEN)\"\n  \"PROCESS RANGE C\"\n  IF RC = 0 THEN DO\n     LABF = \".ZFRANGE\"\n     LABL = \".ZLRANGE\"\n     \"reset special \" labf labl\n  END\n  ELSE DO\n     LABF = \".ZFIRST\"\n     LABL = \".ZLAST\"\n  END\n  \"x all         \" labf labl\n  \"f '.dm ' all  \" labf labl\n  \"x on word all \" labf labl\n  \"x off word all\" labf labl\n  \"f first nx '.dm'\" labf labl\n  if rc = 0 then do\n     \"labnx\" labf labl\n     \"line_after .zcsr = msgline 'Warning .DM without ON or OFF'\"\n  end\n  /* Table 18. Control words that Ensure a Page is Started     */\n  /*  as found in Chapter 5 of SCRIPT/VS Lang rel 4.0  SH35-0070-06 */\n  \"find all word \" labf labl \" '.ar'\"    /* Area               */\n  \"find all word \" labf labl \" '.bl'\"    /* Blank Line         */\n  \"find all word \" labf labl \" '.bx'\"    /* Box                */\n  \"find all word \" labf labl \" '.cb'\"    /* Column Begin       */\n  \"find all word \" labf labl \" '.cc'\"    /* Conditional Col Beg*/\n  \"find all word \" labf labl \" '.cp'\"    /* Conditional Page   */\n  \"find all word \" labf labl \" '.ct'\"    /* Continued Text     */\n  \"find all word \" labf labl \" '.fl'\"    /* Float              */\n  \"find all word \" labf labl \" '.fn'\"    /* Footnote           */\n  \"find all word \" labf labl \" '.hr'\"    /* Horizontal Rule    */\n  \"find all word \" labf labl \" '.hw'\"    /* Hyphenate Word     */\n  \"find all word \" labf labl \" '.h0'\"    /* Head Level 0-6     */\n  \"find all word \" labf labl \" '.h1'\"    /* Head Level 0-6     */\n  \"find all word \" labf labl \" '.h2'\"    /* Head Level 0-6     */\n  \"find all word \" labf labl \" '.h3'\"    /* Head Level 0-6     */\n  \"find all word \" labf labl \" '.h4'\"    /* Head Level 0-6     */\n  \"find all word \" labf labl \" '.h5'\"    /* Head Level 0-6     */\n  \"find all word \" labf labl \" '.h6'\"    /* Head Level 0-6     */\n  \"find all word \" labf labl \" ':h0'\"    /* Head Level 0-6     */\n  \"find all word \" labf labl \" ':h1'\"    /* Head Level 0-6     */\n  \"find all word \" labf labl \" ':h2'\"    /* Head Level 0-6     */\n  \"find all word \" labf labl \" ':h3'\"    /* Head Level 0-6     */\n  \"find all word \" labf labl \" ':h4'\"    /* Head Level 0-6     */\n  \"find all word \" labf labl \" ':h5'\"    /* Head Level 0-6     */\n  \"find all word \" labf labl \" ':h6'\"    /* Head Level 0-6     */\n  \"find all word \" labf labl \" '.ie'\"    /* Index Entry        */\n  \"find all word \" labf labl \" '.is'\"    /* Inline Space       */\n  \"find all word \" labf labl \" '.ix'\"    /* Index              */\n  \"find all word \" labf labl \" '.kp'\"    /* Keep               */\n  \"find all word \" labf labl \" '.oi'\"    /* Overlay Include    */\n  \"find all word \" labf labl \"':p'\"      /* paragraph <tag>    */\n  \"find all word \" labf labl \" '.po'\"    /* PostScritp         */\n  \"find all word \" labf labl \" '.rd'\"    /* Read Terminal      */\n  \"find all word \" labf labl \" '.si'\"    /* Segment Include    */\n  \"find all word \" labf labl \" '.sk'\"    /* Skip               */\n  \"find all word \" labf labl \" '.so'\"    /* STAIRS/VS Output   */\n  \"find all word \" labf labl \" '.sp'\"    /* Space              */\n  \"find all word \" labf labl \" '.sx'\"    /* Split Text         */\n  \"find all word \" labf labl \" '.ta'\"    /* Table              */\n  \"find all word \" labf labl \" '.tc'\"    /* Table of Contents  */\n  \"find all word \" labf labl \" '.vr'\"    /* Vertical Rule      */\n  \"find all word \" labf labl \" '.vt'\"    /* Variable Text      */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EOL": {"ttr": 6661, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00[\\x00[\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX */\nADDRESS ISREDIT\n\"ISREDIT MACRO (HELP) NOPROCESS\"\nTRACE\nIF help = '?' |,\n   translate(help) = 'HELP' THEN\n  DO\n    ADDRESS ISPEXEC \"DISPLAY PANEL(#EOL)\"\n    EXIT 1\n  END\n\"ISREDIT (CL,CC) = CURSOR\"\nsave_cc = cc\nCALL find_end\n/* If already at EOL, then jump to next line and go to EOL */\nIF save_cc = cc THEN\n  DO\n    cl = cl + 1\n    CALL find_end\n  END\n\"ISREDIT CURSOR = \" cl cc\nEXIT\nfind_end:\n\"ISREDIT (WIDTH) = DATA_WIDTH\"\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\"ISREDIT (xstatus) = xstatus\" cl\nif rc = 0 then\n   if xstatus = \"X\" then do\n        /* Bypass eXcluded lines */\n        \"ISREDIT FIND p'=' 1 NX\"\n        if rc > 0 then do   /* rc=4 from FIND */\n           ZEDSMSG = '*BOTTOM OF DATA REACHED*'\n           ZEDLMSG = \"EOL found no more NX lines to process\"\n           ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n           EXIT\n        END\n        \"ISREDIT (cl) = cursor\"\n   end\n   else nop\nelse do    /* rc=12 from XSTATUS */\n    \"ISREDIT CURSOR = \" cl-1 cc\n    ZEDSMSG = '*BOTTOM OF DATA REACHED*'\n    ZEDLMSG = 'No more lines to process'\n    ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    EXIT\nEND\n\"ISREDIT (LINE) = LINE\" cl\nDO cc = width to 1 by -1\n  IF SUBSTR(line,cc,1) /= ' ' THEN\n    LEAVE\nEND\nIF cc = width THEN\n  NOP\nELSE\n  cc = cc + 1\nRETURN\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO SET CURSOR AT END OF CURRENT SCREEN LINE          */\n/* changes made to CBT match changes made/accepted by John later   */\n/******************************************************************\n *      1994/06/28 15:56:40 TECH.CBT.FILE078.PDS(REXX)\n *      statistics    0105-93216-93216-1416-00042-00038-00000-REXX\n *          JOHN KALINICH\n *          USA SYSTEMS INTEGRATION &\n *           MANAGEMENT ACTIVITY\n *          AMXSI-TRI, ROOM 7.103\n *          1222 SPRUCE STREET\n *          ST. LOUIS, MO.  63103-2834\n *\n *          314-331-4521\n *          314-331-4520 (FAX)\n ******************************************************************\n The EOL macro is used to position the cursor at the end of the current screen\n line (like most PC editors do when you press the \"End\" scroll key).  Yes, it\n takes some interrupts and a PF key definition, but that is the price you have\n to pay for PC-like features on a 3270.  By pressing the EOL PF key repeatedly,\n you can jump to end of line (EOL) on successive lines.\n\n Use:\n Press appropriate PF key (the one assigned to EOL)\n\n COMMAND ===> <PFn>             Assume cursor was on word IN on line 000020\n Before ********************** TOP OF DATA *************************************\n 000020 D:  IN A858SES FIND ALL RECORDS FOR WHICH\n 000021       REC-TY = 'SESC'\n 000022     END FIND                             .--- Cursor is now here\n                                                 |\n After *********************** TOP OF DATA ***** v *****************************\n 000020 D:  IN A858SES FIND ALL RECORDS FOR WHICH_\n 000021       REC-TY = 'SESC'\n 000022     END FIND\n ..........................*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FED1040": {"ttr": 6664, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00z\\x00z\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 122, "newlines": 122, "modlines": 0, "user": "MCRITCH"}, "text": "/* FED1040: Income Tax calculations -- an incomplete example in REXX\n\n Simplified Spread Sheet, showing ENTRY, Formula, Desc, RESULT\n David McRitchie, April 15, 1994, Example not a complete pkg.\n =============================================================\n Instructions to use  the  FED1040 macro: ....\n   1). Create an empty member name and place\n   2). Comments are indicated with an asterisk (*) in column 1.\n       The line will not be touched by the FED1040 macro.\n   3). Entry values beginning in Column 1 are optional in active\n       cards.  If present they will be assigned to variable 'V'.\n   4). Assignment statements are not optional in active cards.\n       Assignments should normally be placed beginning in column\n       11 so that they line up with other assignment statements.\n       If column 1-11 is blank the assignment statement will be\n         the first word picked up from col 11-59.\n       If column 1-11 is non-blank, there being an entry value,\n         the second word picked up from col 1-59 will be the\n         assignment statement.\n       Assignment statements end with a blank.\n\n Example:\n   1...5...10...15...20...25...30...35...40 ... 60...65...70...75...80\n   ----+----1----+----2----+----3----+----4 ... -6----+----7----+----8\n   20000.00    LN5=V    INVOICED AMOUNT          LN5=        20000.00\n      333.00   A=LN5+V                           A=          20333.00\n   .20         B=V                               B=               .20\n   7           B=B*V                             B=              1.40\n =============================================================\n  An example of a table for 1993 can be found in\n       IS03.LIBR.CLIST(FEDT1993), which you can use to make\n       a copy from into your own RACF protected dataset.\n  Running times with FEDT1993 data was\n      3.19 seconds TSO, and      |Timing begins once macro begins,\n     10.31 seconds OS/2          |so loading macro does not count.\n .............................................................*/\naddress \"ISREDIT\";\"MACRO\"\nS=time('E')\n\"(memberx) = member \"\n\"(dsnx) = dataset \"\n\"(ilast) = linenum .zlast\"\ndo irow = 1 to ilast;\n   \"(line) = line\" irow\n   operands = strip(substr(line,1,59))\n   if substr(line,1,1) = '*' then iterate irow;  /*ignore comments*/\n   if substr(line,1,10) \\= '' then do;\n       v = word(operands,1)\n       calc = word(operands,2)\n       chkb = word(operands||\" XX\",3)\n   end;\n   else do;\n       operands=strip(substr(line,11,49));\n       calc = word(operands,1)\n       chkb = word(operands||\" XX\",2)\n   end;\n   if calc = \"\" then iterate irow;\n   parse var calc assigned '=' drop\n   Test = translate(word(operands,1))\n   if test = \"NOTEV\" then do\n      note = \"\"\n      do inote=2 to words(operands)\n         note=note word(operands,inote)\"=\"value(word(operands,inote))\n      end\n     \"LINE_after\" irow \"= NOTELINE (NOTE)\"\n      iterate irow\n   end\n   if test = \".ZERO\" then do\n      do inote=2 to words(operands)\n         var=word(operands,inote)\n         if substr(var,1,1)='.' then do i=0 to 100;\n           zerovar=substr(var,2)||i||\"=0\"\n           interpret zerovar\n         end\n         else do; zerovar=word(operands,inote)\"=0\"\n           interpret zerovar\n         end;\n      end\n      iterate irow\n   end\n   if test = \"IF\" then calc = substr(line,11)\n   else if calc = assigned then do\n           \"(CAPS) = CAPS\"\n           \"CAPS OFF\"\n           ZEDSMSG = \"Calc invalid\"\n           ZEDLMSG = 'STOPPED -- Calculation at line' irow,\n               'is not an assignment  X=formula'\n           \"LINE_BEFORE .ZFIRST = NOTELINE (ZEDLMSG)\"\n           MOREMSG = 'STOPPED -- due to errors at line' irow,\n               '     Time of error was' time('n')\n           \"LINE_BEFORE .ZFIRST = NOTELINE (MOREMSG)\"\n           \"LINE_AFTER &IROW.   = NOTELINE (MOREMSG)\"\n           \"LINE_AFTER &IROW.   = NOTELINE (ZEDLMSG)\"\n           ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n           \"CAPS\" CAPS\n           return 4\n   end;\n   interpret calc\n   if rc \\= 0 then say 'line' irow 'failure:' calc\n   if test = \"IF\" then do;\n      iterate irow\n   end\n   line =  substr(line,1,59)||left(assigned||'=',10)||,\n           right(value(assigned),10)\n   \"line\" irow \"= (line)\";\n   if pos('+',chkb)>0 | pos('-',chkb)>0 | pos('/',chkb)>0,\n      pos('*',chkb)>0 then do\n           \"(CAPS) = CAPS\"\n           \"CAPS OFF\"\n           ZEDSMSG = \"Check Calc\"\n           ZEDLMSG = 'Calculation for line' irow,\n               'may be incomplete, found +,-,/, or * afterwards'\n           \"LINE_BEFORE .ZFIRST = NOTELINE (ZEDLMSG)\"\n           \"LINE_AFTER &IROW.   = NOTELINE (ZEDLMSG)\"\n           ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n           \"CAPS\" CAPS\n   end;\nend;\n\"Line_before .zf = NOTELINE \"\"FED1040:\" time('N') TIME('E')\"\"\"\"\n/***** May prove useful sometime *************************************/\n/* ABC=123;DEF=345;LINE='LINE = ABC DEF;SAY LINE';                   */\n/* INTERPRET LINE                                                    */\n/*********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FEVERY": {"ttr": 6667, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xdf\\x00\\xdf\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 223, "newlines": 223, "modlines": 0, "user": "MCRITCH"}, "text": "            CONTROL ASIS\n /*  TITLE:       FEVERY  -- FIND EVERY LINE CONTAINING EACH */\n /*                              SPECIFIED STRING            */\n /*  USERS:       SCRIPT USERS                               */\n /*  ENTRY:       USED AS AN EDIT CLIST WITHIN ISPF EDIT     */\n /*              ===> FEVERY   'A' 'B' C                     */\n /*  CONTRIBUTED: 1986/04/28 DAVID MCRITCHIE                 */\n /*      \"THE REXX MACROS TOOLBOX\" -- SYSTECH                */\n /*                                                          */\n /*  EXAMPLE:     FEVERY .ZFIRST .ZLAST NX 'STRING1' \"STRING2\" */\n /*                                 STRING3 STRING4 'STRING5' */\n /*  OPTIONS:                                                 */\n /*      LBL-RANGE    (REQUIRED)  LABEL  RANGE               */\n /*      NX | X       (OPTIONAL)  LIMIT TO NON-EXCLUDED, OR EXCLUDED */\n /*                    EXCLUDED LINES                                */\n /*      <LIST>       (REQUIRED)  STRING OPERAND SUITABLE FOR A FIND */\n /*                     COMMAND                                      */\n /*                                                                 */\nISREDIT     MACRO (TOK1,TOK2,TOK3,TOK4,TOK5,TOK6,TOK7,TOK8,TOK9,TOK10,+\n          TOK11,TOK12,TOK13,+\n          TOK14,TOK15,TOK16,TOK17,TOK18,TOK19,TOK20,TOK21,TOK22,TOK23,+\n          TOK24,TOK25,TOK26,+\n          TOK27,TOK28,TOK29,TOK30,TOK31,TOK32,TOK33,TOK34,TOK35,TOK36,+\n          TOK37,TOK38,TOK39,+\n          TOK40,TOK41,TOK42,TOK43,TOK44,TOK45,TOK46,TOK47,TOK48)\n        ISREDIT (IMAC) = IMACRO\n        SET R  = 0\n        SET SETX  = 0\n        SET SETNX  = 0\n        SET I = 0\n        /*********\n        SET I = 1\n       DO WHILE &I <= 48\n        SET TOKEN = &&TOK&I\n        SET TOKEN = &STR(&SYSCAPS(&TOKEN))\n        IF &STR(&TOKEN) = &STR() THEN GOTO END_TOK\n        IF ALL = &STR(&TOKEN) | NEXT = &STR(&TOKEN) | FIRST = +\n          &STR(&TOKEN) | LAST = &STR(&TOKEN) | PREV = &STR(&TOKEN) +\n            THEN DO\n          SET &ZEDSMSG = &STR(&TOKEN INVALID)\n          SET &ZEDLMSG = &STR(\"&TOKEN\" NOT PROVIDED FOR NOR ARE NEXT +\n            ALL FIRST LAST PREV)\n          ISPEXEC   SETMSG MSG(ISRZ000)\n          EXIT CODE(12)\n        END\n        IF &SUBSTR(1:6,&STR(&TOKEN)       ) = &STR(BEGIN&STR(&LP))  +\n          THEN DO\n           SET BEGIN = &SUBSTR(7:&EVAL(&LENGTH(&STR(&TOKEN))-1),+\n             &STR(&TOKEN)         )\n           GOTO NXT_TOK\n        END\n        IF &STR(&TOKEN) = NX THEN DO\n           SET NX = NX\n           GOTO NXT_TOK\n        END\n        IF &STR(&TOKEN) = X THEN DO\n           SET X = X\n           GOTO NXT_TOK\n        END\n        IF &STR(&TOKEN) = WORD | &STR(&TOKEN) = CHAR | &STR(&TOKEN) = +\n          CHARS -\n        | &STR(&TOKEN) = PREFIX | &STR(&TOKEN) = SUFFIX THEN DO\n           IF &STR(&WORD) ^= &STR() THEN DO\n              SET &ZEDSMSG = &STR(INCONSISTENT PARAMETERS)\n              SET &ZEDLMSG = &STR('&WORD' AND '&TOKEN' CANNOT BOTH BE +\n                SPECIFIED FOR XEVERY CMD.)\n              ISPEXEC     SETMSG MSG(ISRZ000)\n           END\n           SET WORD = &STR( &TOKEN.)\n           GOTO NXT_TOK\n        END\n        IF &STR(&TOKEN) = LEFT THEN DO /* LEFT | RIGHT */\n           SET LEFT = LEFT\n           GOTO NXT_TOK\n        END\n        IF &STR(&TOKEN) = RIGHT THEN DO\n           SET RIGHT = RIGHT\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1,&TOKEN) = &STR(.) THEN DO\n           IF &LABF = &STR() THEN DO\n              SET LABF = &STR(&TOKEN)\n              GOTO NXT_TOK\n           END\n           IF &STR(&LABL) = &STR() THEN DO\n              SET LABL = &STR(&TOKEN)\n              GOTO NXT_TOK\n           END\n          SET &ZEDSMSG = &STR(LABEL &STR(&TOKEN))\n          SET &ZEDLMSG = &STR(EXACTLY TWO LABELS ARE REQUIRED FOUND   +\n            \"&LABF\", \"&LABL\" AND  \"&STR(&TOKEN)\")\n          ISPEXEC   SETMSG MSG(ISRZ000)\n          EXIT CODE(12)\n        END\n        IF &STR(&TOKEN) = &STR()) THEN DO\n           SET &ZEDSMSG = &STR(LOST PARENTHESIS)\n           SET &ZEDLMSG = BLANKS SEPARATE ALL OPERANDS; THEREFORE +\n             INVALID IN FROM() TO() COL() BEGIN()\n           ISPEXEC SETMSG MSG(ISRZ000)\n           EXIT CODE(12)\n        END\n        SET REMAIN = &STR(&REMAIN &STR(&TOKEN))\n        SET R = &R + 1\n        SET FIND&R = &STR(&TOKEN)\n NXT_TOK: -\n        SET I = &I + 1\n      END\n END_TOK: SET I = &I\n      /*****************************************************************\n        /*************************************************************+\n          ****\n        SET RMAX = &R\n        IF &STR(&FIND1) = &STR() THEN DO\n                   SET &ZEDSMSG = &STR(FIND STRINGS)\n                   SET &ZEDLMSG = &STR(&ZEDSMSG ARE MISSING)\n                   ISPEXEC     SETMSG MSG(ISRZ000)\n                   EXIT CODE(12)\n        END\n        IF &LABL = &STR() AND &LABF ^= &STR() THEN DO\n           SET &ZEDSMSG = &STR(LABEL MISSING)\n           SET &ZEDLMSG = &STR(TWO LABELS MUST BE INDICATED FOR A RANGE)\n           ISPEXEC     SETMSG MSG(ISRZ000)\n        END\n        IF &LABF = &STR() THEN SET LABF = &STR(.ZFIRST)\n        IF &LABL = &STR() THEN SET LABL = &STR(.ZLAST)\n        ISREDIT (#LABF) = LINENUM &LABF\n        IF &LASTCC ^= 0 THEN DO\n                   SET &ZEDSMSG = &STR(&LABF. LABEL)\n                   SET &ZEDLMSG = &STR(&ZEDSMSG DOES NOT EXIST)\n                   ISPEXEC     SETMSG MSG(ISRZ000)\n                   EXIT CODE(12)\n        END\n        ISREDIT (#LABL) = LINENUM &LABL\n        IF &LASTCC ^= 0 THEN DO\n                   SET &ZEDSMSG = &STR(&LABL. LABEL)\n                   SET &ZEDLMSG = &STR(&ZEDSMSG DOES NOT EXIST)\n                   ISPEXEC     SETMSG MSG(ISRZ000)\n                   EXIT CODE(12)\n        END\n        /********************************** END OF LABEL REQUIREMENTS +\n          **********************/\n        ISREDIT (DWIDTH) = DATA_WIDTH\n        SET DWIDTH2 = &DWIDTH + &DWIDTH\n        /*   /* CAN BE USED TO FORCE AN ERROR */\n        ISREDIT (LBOUND,RBOUND) = BOUNDS\n        /****************************/\n        ISREDIT (VAR057) = RECFM\n        ISREDIT (VAR049,VAR050) = NUMBER\n        SET LLBOUND = &LBOUND\n        SET LLADJ = 0\n        IF &VAR057 = V AND &VAR049 = ON THEN DO\n           SET LLADJ = 8\n           SET LLBOUND = &LBOUND + 8\n        END\n        /****************************/\n        /************************************** CODE FOR  FEVERY +\n          COMMANDS ***************/\n        /************************************** CODE FOR  FEVERY +\n          COMMANDS ***************/\n        /************************************** CODE FOR  FEVERY +\n          COMMANDS ***************/\n            /******** BEGIN OF INTERFACE TO COMMON PATTERN CLIST  *****/\n            IF &X = X AND &NX = NX THEN DO\n               SET X =\n               SET NX =\n            END\n            /******** END   OF INTERFACE TO COMMON PATTERN CLIST  *****/\n            IF &EVAL(&#LABL.) < &EVAL(&#LABF.) THEN DO\n                SET &ZEDSMSG = &STR(LABEL ERR .LABF/L)\n                SET &ZEDLMSG = &STR(&LABF MUST APPEAR EARLIER THAN +\n                  &LABL)\n    ISPEXEC     SETMSG MSG(ISRZ000)\n                EXIT CODE(12)\n            END\n    /* **************************************************\n     /*   ISREDIT SEEK &LABF. &LABL. &NX&X FIRST &FIND1\n     /*   IF &LASTCC = 0 THEN GOTO NONE\n          SET I = &#LABF\n          DO WHILE &I <= &#LABL\n             ISREDIT (VAR075) = XSTATUS &I\n             IF &VAR075 = &NX OR &VAR075 = &X OR  &STR(&X&NX) = +\n               &STR() THEN DO\n                SET R = 1\n                DO WHILE &R <= &RMAX\n                   ISREDIT LABEL &I = .POINT\n                   SET TOKEN = &STR(&&FIND&R)\n                   SET TOKEN = &STR(&TOKEN)\n                   ISREDIT SEEK .POINT .POINT &TOKEN. &WORD. ALL\n                   IF &LASTCC > 0 THEN GOTO NFOUND\n                   SET R = &R + 1\n                END\n                IF &VAR075 = X THEN DO\n                   SET SETNX = 0&SETNX + 1\n                   ISREDIT XSTATUS .POINT = NX\n                END\n                GOTO NXTT_I\n               NFOUND: -\n                ISREDIT EXCLUDE .POINT .POINT ALL\n                IF &VAR075 = NX THEN SET SETX = 0&SETX + 1\n             END\n   NXTT_I: -\n             SET I = &I. + 1\n          END\n   NONE: -\n          SET &ZEDSMSG = &STR(COMPLETED)\n          SET XXX = &STR()\n          IF &EVAL(&SETX)  ^= &EVAL(0) THEN SET XXX = &STR(&SETX. +\n            NX->X, )\n          IF &EVAL(&SETNX) ^= &EVAL(0) THEN SET XXX = +\n            &STR(&XXX.&SETNX. X->NX, )\n          IF &EVAL(&SETX) = &EVAL(0) AND &EVAL(&SETNX) = &EVAL(0) +\n            THEN DO\n             SET XXX = &STR(DISPLAY NOT CHANGED BY )\n             SET &ZEDSMSG = &STR(NO CHANGE)\n          END\n          ELSE DO\n             ISREDIT F FIRST NX &LABF &LABL ' '\n             IF &STR(&IMAC) = NONE THEN ISREDIT UP 1\n          END\n          SET &ZEDLMSG = &STR(&XXX. -\n===> FEVERY &LABF &LABL &X.&NX.&WORD. &FIND1 &FIND2 &FIND3 &FIND4 +\n  &FIND5 &FIND6 &FIND7.)\n          ISPEXEC     SETMSG MSG(ISRZ000)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FGROUP": {"ttr": 6913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00I\\x00I\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 73, "newlines": 73, "modlines": 0, "user": "MCRITCH"}, "text": "/* FGROUP: NX the lines between find pairs               (REXX)*/\n/*********************************************************************\n MACRO:     NX the lines between find pairs\n PURPOSE:   Unexclude a range of lines\n EXAMPLES:\n   FGROUP \"1 .a .b '.kp on'\" \"1 .a .b '.kp off'\"\n   FGROUP \".kp on\" \".kp off\"\n   FGROUP                                -- default used\n RELATED:  TAGX, LABNX, FGROUP, FGROUP\n***********************************************************************\n  FGROUP    Author: David McRitchie, created 1994/05/19 is03\n            at \"The REXX Macros Toolbox\", DMcRitchie@aol.com\n            \"The REXX Macros Toolbox\"\n    \"The REXX Macros Toolbox\"\n  *******************************************************************/\n Address 'ISREDIT';'MACRO (token)'\n if token = \"\" then token = \"kp\"\n capstok = translate(token)\n if substr(token,1,1) = '\"' then do\n    parse var token '\"' pair1 '\"' token\n end\n else if substr(token,1,1) = \"'\" then do\n    parse var token \"'\" pair1 \"'\" token\n end\n else if capstok = 'KP' | capstok = 'FRAME' then do\n      pair1 =  \"1 word '.\"strip(token)\" on'\"\n      token =  \"\"\"1 word '.\"strip(token)\" off'\"\"\"\n end\n else call dropdead 101\n if substr(token,1,1) = '\"' then do\n    parse var token '\"' pair2 '\"' token\n end\n else if substr(token,1,1) = \"'\" then do\n    parse var token \"'\" pair2 \"'\" token\n end\n else do; msg=\"error in first of pair\"; signal noway; end\n \"(row,col) = cursor\"\n \"seek first p'=' 1 x\"\n if rc \\= 0 then do\n    ZEDSMSG = \"Setup error\"\n    ZEDLMSG = \"Must have some lines excluded before starting\"\n    ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    \"cursor =\" row col\n    exit 1\n end;\n \"cursor =\" row 0\n do forever\n   \"seek\" token pair1\n    if rc \\= 0 then leave\n    \"label .zcsr = .beg 1\"\n   \"seek\" token pair2\n    if rc \\= 0 then do\n      \"line_before .zf = noteline\",\n        \"\"\"Last  .cs\" word(token,i) \"on -- is not matched with off\"\"\"\n        \"reset .beg .beg x\"\n        \"line_after .beg = msgline \",\n        \"\"\"Last  .cs\" word(token,i) \"on -- is not matched with off\"\"\"\n        leave\n    end\n    \"reset .beg .zcsr x \"\n   end\n/*  test\n.kp on\n.*******\n.kp off\n.************\n.cs 2 off\n.cs 1 on\n.*******\n.cs 1 off\n.************\n.cs 2 off\n****************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FIXJCL": {"ttr": 6916, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x8b\\x00\\x8b\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 139, "newlines": 139, "modlines": 0, "user": "MCRITCH"}, "text": "/* TIDY UP YOUR JCL                      REXX              */\n/* OBTAINED FROM CBT TAPE #9102 -- FILE095 MEMBER FIXJCL*/\n/********************************************************************/\n   address \"ISREDIT\";\"macro (help) NOPROCESS\"\n   started = date('n') time('n')\n   help = translate(help)\n   if help = \"?\"  | help = \"HELP\" then do;\n      address \"tso\" \"clist fixjcl help\"   /* --- help information*/\n    /*address \"ispexec\" \"display panel(fixjcl)\" */\n      exit\n   end;\n\n/*                                                                   */\n/*    Align jcl JOB, EXEC, and DD statements on standard boundaries  */\n/*    T. M. Hanes, ASYST Inc. 1988/02/01                             */\n/*    D.E.M.I., 1988/03/01                                           */\n/*    D.McRitchie, 1993/06/14 converted to rexx                      */\n/*    D.McRitchie, 1993/12/16 much faster, less compression          */\n/*       very little, if any, resemblence to the original            */\n/*                                                                   */\n/*      site dependent definitions:                                  */\n/*      alignment columns for card types                             */\n/*                                                                   */\n/*      preserve continuation characters in 72                       */\n   \"process range j\"\n   if rc = 0  then do;\n         \"(rcmd) = range_cmd\"\n         \"(jzf) = linenum .zfrange\"\n         \"(jzl) = linenum .zlrange\"\n   end;\n   else do;\n         \"(jzf) = linenum .zfirst\"\n         \"find last '//' 1\"\n         if rc \\= 0 then do\n           ZEDSMSG = \"NO JCL\"\n           ZEDLMSG = 'Immediate EXIT, because no JCL to fix'\n           ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n           exit 1\n         end\n         \"(jzl) = linenum .zcsr\"\n   end;\n\n   \"label\" jzf \"= .jzf 1\"\n   \"label\" jzl \"= .jzl 1\"\n   ljzf = \".jzf\"\n   ljzl = \".jzl\"\n   if jzf = jzl  then ljzf = \".jzl\"\n\n   \"(cl,cr) = cursor\"\n   \"(lb,rb) = bounds\"; \"(caps) = caps\"\n   \"bounds  = 1 71\"\n   /* JOB, PROC, EXEC, DD and PEND; conversion */\n\n   call process_keywd( 'OUTPUT')\n   call process_keywd( 'PROC' )\n   call process_keywd( 'EXEC' )\n   call process_keywd( 'DD' )\n   call process_keywd( 'PEND' )\n   call process_keywd( 'JOB' )\n   call continuations;\n   \"bounds =\" lb rb; \"caps =\" caps\n   \"left max\"\n   \"reset x\"\n   \"cursor =\" cl cr\n   zfnote = \"line_before .zfirst = noteline\"\n   ended   = time('n')\n   zfnote \"'\"sysvar(\"sysicmd\") \"start:\" started\", end:\" ended\"'\"\n   zfnote \"' after fixjcl recommend use of compare *, and !edchek'\"\n   exit 0\n\n   /* -------------- subroutines ------------------------- */\n   process_keywd:\n      arg keywd\n      \"x all\" ljzf ljzl\n      \"f ' \"keywd\" '      3 25 all\"            ljzf ljzl\n      /* fix common mistake where keyword begins column 13-15*/\n      \"c '    \"keywd\" ' ' \"keywd\" '   11 all nx\" ljzf ljzl\n      \"c '   \"keywd\" ' ' \"keywd\" '   11 all nx\"    ljzf ljzl\n      \"c '  \"keywd\" ' ' \"keywd\" '   11 all nx\"    ljzf ljzl\n      if keywd = 'DD' then do\n         \"x ' DD  ' 11 all\" ljzf ljzl\n         \"c ' DD ' ' DD  ' 11 all nx\" ljzf ljzl\n      end\n      \"x ' \"keywd\" '           all 11\"         ljzf ljzl\n\n      /* insure we have JCL without being able to do a find */\n      /* exclude non-JCL and JCL comment cards.             */\n      \"x 1 2 ' ' all\"       LJZF LJZL\n      \"x 1 2 p'#' all\"      LJZF LJZL\n      \"x 1 2 p'@' all\"      LJZF LJZL\n      \"x 1 '//\"||\"*' all\"   LJZF LJZL\n      \"x 1 '/\"||\"*' all\"    LJZF LJZL\n      do forever;   /* rigorous check make sure jcl continuation*/\n         \"find p'^' 1 next\" LJZF LJZL\n         if rc \\= 0 then leave\n         \"(line) = line .zcsr\"\n        if substr(line,1,2) \\= '//' then \"x all .zcsr .zcsr\"\n      end\n\n      /* I think spaces could lurk in quotes */\n      \"x \"\"'\"\"                    all \"  ljzf ljzl /*'*/\n      \"x '\"\"'                     all \"  ljzf ljzl\n      \"f ' \"keywd\" '      3 25 first nx \"  ljzf ljzl\n      if rc /=0 then return\n\n      /*    let ispf remove extra spaces as needed  */\n      do i = 3 to 10  /* must begin 3 for dd continuations*/\n         \"c\" i \"' \"keywd\" '    '  \"keywd\" ' all nx\"     ljzf ljzl\n         if keywd = 'DD' then do\n            \"x ' DD  ' 11 all\" ljzf ljzl\n            \"c ' DD ' ' DD  ' 11 all nx\" ljzf ljzl\n         end\n         \"x 11 ' \"keywd\" '        all \"  ljzf ljzl\n      end\n   return;\n\ncontinuations:\n   /*      continuation card conversion                       */\n   \"x all\"                         ljzf ljzl\n   \"f '// '         1 all\"         ljzf ljzl\n\n   /* fix common mistake where continued in column 17 */\n   \"c '//              ' all '//             ' nx\"   ljzf ljzl\n   /*  //34567890123456       //3456789012345   */\n\n   /* do not work with continuations that are done*/\n   \"x '//             ' all\"       ljzf ljzl\n   \"x ' OUTPUT ' 3 22 all\"         ljzf ljzl\n   \"x ' PROC '   3 20 all\"         ljzf ljzl\n   \"x ' EXEC '   3 20 all\"         ljzf ljzl\n   \"x ' DD '     3 20 all\"         ljzf ljzl\n   \"x ' PEND '   3 20 all\"         ljzf ljzl\n   \"x ' JOB '    3 20 all\"         ljzf ljzl\n\n   do i = 3 to 14\n     \"c\" i \"   ' ' '  ' all nx\"       ljzf ljzl\n     \"x '//             ' all\"     ljzf ljzl\n   end\n   return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FIXLI": {"ttr": 6919, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00'\\x00'\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- converted to REXX on 1994/06/03 */\nADDRESS \"ISREDIT\"\n /*  TITLE:       FIXLI -- change (\") to use of :Q...:EQ. for SCRIPT text */\n /*  USERS:       TSO ISPF EDIT USERS   | SCRIPT USERS                    */\n /*  CONTRIBUTED: 1988/02/09 DAVID MCRITCHIE                              */\n /*                                                                       */\n /*  EXAMPLE:     FIXLI                                                   */\n /*                                                                       */\n /*  OPTIONS:                                                             */\n /*      col1 col2  .label1 .label2  NX                                   */\n /*      NX   cannot be used with other options                           */\n \"MACRO (RANGE)\"\n /*   CONTROL ASIS -- left over from clist before rexx*/\n IF RANGE. = \"\" THEN  RANGE = \".ZF\"  .ZL\n /* SCRIPT CONVERSION TO PAGE USAGE -- D.MCR                              */\n \"SEEK ALL &RANGE. ':li. ' 1\"\n \"(LICNT1S,LICNT2L) = SEEK_COUNTS\"\n licnt1s=licnt1s+0; licnt2l=licnt2l+0\n IF LICNT1S  = 0  THEN  DO\n     \"LINE_BEFORE .ZF = NOTELINE \"\"time(\"n\") FIXLI   \",\n           \"-- NO CHANGES time(\"n\")\"\"\"\n      Exit 0\n END\n \"LINE_BEFORE .ZF = NOTELINE \"\"\"time(\"n\"),\n       \"FIXLI   -- **CHANGES**\" time(\"n\")\"\"\"\"\n IF RANGE  = \"\" THEN  RANGE = \".ZF\"  .ZL\n \"Exclude ALL &RANGE.\"\n \"Find ALL &RANGE. ':li. ' 1\"\n \"(VAR016) = DATA_WIDTH\"\n \"(VAR057) = RECFM\"\n IF VAR057 = \"V\" THEN  VAR016 = VAR016  - 4\n \"Change ALL &RANGE. NX 1 &VAR016. ' ' '\u00a2'\"\n \"Change ALL &RANGE. NX 1 ':li.\u00a2' ':li.'\"\n \"Change ALL &RANGE. NX 1 ':li.\u00a2' ':li.'\"\n \"Change ALL &RANGE. NX 1 ':li.\u00a2' ':li.'\"\n \"Change ALL &RANGE. NX 1 ':li.\u00a2' ':li.'\"\n \"Change ALL &RANGE. NX 1 &VAR016. '\u00a2' ' '\"\n \"Change ALL &RANGE. NX ':            ' x'508794934b404040404040404040404040'\"\n \"LOC 0\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FIXP": {"ttr": 6921, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00(\\x00(\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- converted to REXX on 1994/06/03 */\nADDRESS \"ISREDIT\"\n /*  TITLE:       FIXP -- Change (\") to use of :Q...:EQ. for SCRIPT text */\n /*  USERS:       TSO ISPF EDIT USERS   | SCRIPT USERS                   */\n /*  CONTRIBUTED: 1988/02/09 DAVID MCRITCHIE                             */\n /*                                                                      */\n /*  EXAMPLE:     FIXP                                                   */\n /*                                                                      */\n /*  OPTIONS:                                                            */\n /*      col1 col2  .label1 .label2  NX                                  */\n /*      NX   cannot be used with other options                          */\n  \"MACRO (RANGE)\"\n /* SCRIPT CONVERSION TO PAGE USAGE -- D.MCR                        */\n \"SEEK ALL\" RANGE \"':P. ' 1\"\n \"(LICNT1S,LICNT2L) = SEEK_COUNTS\"\n LICNT1S=LICNT1S+0; LICNT2L=LICNT2L+0\n IF LICNT1S = 0 THEN  DO\n    \"LINE_BEFORE .ZF = NOTELINE \"\"\"\"TIME(\"N\") FIXP     \",\n           \"-- NO CHANGES - NO BLANKS AFTER ':P.' IN COLUMN 1\"\"\"\n    EXIT 0\n END\n \"LINE_BEFORE .ZF = NOTELINE \"\"\"\"TIME(\"N\") FIXP     -- \",\n              \"********* CHANGES ********** ':P.' IN COLUMN 1\"\"\"\n IF RANGE. = \"\" THEN  RANGE = \".ZF\"  .ZL\n \"EXCLUDE ALL\" RANGE\n \"FIND ALL\" RANGE \"':P. ' 1\"\n \"(VAR016) = DATA_WIDTH\"\n \"(VAR057) = RECFM\"\n IF VAR057 = \"V\" THEN  VAR016 = VAR016  - 4\n \"Change ALL\" RANGE \"NX 1\" VAR016 \"' ' '\u00a2'\"\n \"Change ALL\" RANGE \"NX 1\" VAR016 \"' ' '\u00a2'\"\n \"Change ALL\" RANGE \"NX 1 ':P.\u00a2\u00a2\u00a2' ':P.'\"\n \"Change ALL\" RANGE \"NX 1 ':P.\u00a2\u00a2' ':P.'\"\n \"Change ALL\" RANGE \"NX 1 ':P.\u00a2' ':P.'\"\n \"Change ALL\" RANGE \"NX 1 ':P.\u00a2' ':P.'\"\n \"Change ALL\" RANGE \"NX 1\" VAR016 \"'\u00a2' ' '\"\n \"Change ALL\" RANGE \"NX ':            '\",\n           \"X'508794934B404040404040404040404040'\"\n \"(IMACRO) = IMACRO\"\n \"LOC 0\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FIXPI": {"ttr": 6923, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xa0\\x00\\xa0\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 160, "newlines": 160, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- converted to REXX on 1994/06/03 */\nADDRESS \"ISREDIT\"\n  \"MACRO (TOKEN)\"\n/* FIXPI:   Fix SCRIPT \".PI \"  to mixed Upper/lowercase will        */\n/*          change all \".PI \" entries, recommend use only once      */\n/*          after initial creation of .PI entries.                  */\n/* Author: David McRitchie,  \"The REXX Macros Toolbox\"            */\n/* Options: none -- affects entire member in edit                   */\n/* NOT TO BE USED WITHIN A MACRO -- BY DESIGN                       */\n/*    because will changeletter case of all .PI                     */\n/* Changed so that will not change letter case of all               */\n/*    unless used with FIRSTTIME option.                            */\n/* ==========================================.                      */\n/*    Capitalize First Letter of each Word                          */\n \"LOC 0\"\n \"Caps off\"    /* if it was not it should be */\n \"Exclude ALL\"\n \"Find 1 '.pi ' ALL\"\n \"Find 1 '.th .pi ' ALL\"\n \"Find 1 '.el .pi ' ALL\"\n IF \"FIRSTTIME\" = \"translate(TOKEN)\" THEN DO\n    \"Change ALL NX P'>' P'<'\"\n    \"Change ALL NX PREFIX P'<' P'>'\"\n END\n/* ================================================================ */\n/*    Non-JCL Terminology                                           */\n \"c all nx word  'ahc'             'AHC'\"\n \"c all nx word  'ahf'             'AHF'\"\n \"c all nx word  'american'        'American'\"\n \"c all nx word  'apex'            'APEX'\"\n \"c all nx word  'apxctl'          'APXCTL'\"\n \"c all nx word  'autotab'         'AUTOTAB'\"\n \"c all nx word  'bms'             'BMS'\"\n\n \"c all nx word  'bul'             'bul'\"\n \"c all nx word  'cics'            'CICS'\"\n \"c all nx word  'cis'             'CIS'\"\n \"c all nx word  'cobol'           'COBOL'\"\n \"c all nx word  'com'             'COM'\"\n \"c all nx word  'corporation'     'Corporation'\"\n \"c all nx word  'dave'            'Dave'\"\n \"c all nx word  'david'           'David'\"\n \"c all nx word  'dbc'             'DBD'\"\n \"c all nx word  'dc'              'DC'\"\n \"c all nx word  'dd/ds'           'DD/DS'\"\n \"c all nx word  'dl/i'            'DL/I'\"\n \"c all nx word  'dms'             'DMS'\"\n \"c all nx word  'dpf'             'PCF'\"\n\n\n \"c all nx word  'ims'             'IMS'\"\n \"c all nx word  'john'            'John'\"\n \"c all nx word  'mcritchie'       'McRitchie'\"\n \"c all nx word  'mfs'             'MFS'\"\n \"c all nx word  'mrcs'            'MRCS'\"\n \"c all nx word  'new jersey'      'New Jersey'\"\n \"c all nx word  'nj'              'NJ'\"\n \"c all nx word  'os'              'OS'\"\n \"c all nx word  'pc'              'PC'\"\n \"c all nx word  'pcb'             'PCB'\"\n \"c all nx word  'pl/i'            'PL/I'\"\n \"c all nx word  'pl/1'            'PL/I'\"\n \"c all nx word  'psb'             'PSB'\"\n \"c all nx word  'scharwath'       'Scharwath'\"\n \"c all nx word  'sdb'             'SDB'\"\n \"c all nx word  'sdlc'            'SDLC'\"\n \"c all nx word  'virginia'        'Virginia'\"\n \"c all nx word  'vsam'            'VSAM'\"\n \"c all nx word  'wind'            'Wind'\"\n/* ==========================================.                      */\n/*    Mostly JCL Terminology                                        */\n/*       JCL and other terms for complete capitalization            */\n/*       that do not interfer with other usages e.g. does not include SPACE*/\n \"CHANGE all word nx 'autotab'                  AUTOTAB\"\n \"CHANGE all word nx 'blksiz'                   BLKSIZ\"\n \"CHANGE all word nx 'cyl'                      CYL\"\n \"CHANGE all word nx 'dasd'                     DASD\"\n \"CHANGE all word nx 'dms'                      DMS\"\n \"CHANGE all word nx 'dcb'                      DCB\"\n \"CHANGE all word nx 'fb'                       FB\"\n \"CHANGE all word nx 'fbs'                      FBS\"\n \"CHANGE all word nx 'ibm'                      IBM\"\n \"CHANGE all word nx 'ifps'                     IFPS\"\n \"CHANGE all word nx 'jcl'                      JCL\"\n \"CHANGE all word nx 'jes'                      JES\"\n \"CHANGE all word nx 'mvs/xa'                   'MVS/XA'\"\n \"CHANGE all word nx 'mvs'                      MVS\"\n \"CHANGE all word nx 'pdf'                      PDF\"\n \"CHANGE all word nx 'pds'                      PDS\"\n \"CHANGE all word nx 'racf'                     RACF\"\n \"CHANGE all word nx 'recfm'                    RECFM\"\n \"CHANGE all word nx 'sas'                      SAS\"\n \"CHANGE all word nx 'smp'                      SMP\"\n \"CHANGE all word nx 'trk'                      TRK\"\n \"CHANGE all word nx 'tlms'                     TLMS\"\n \"CHANGE all word nx 'tso'                      TSO\"\n \"CHANGE all word nx 'vb'                       VB\"\n \"CHANGE all word nx 'vbs'                      VBS\"\n \"CHANGE all word nx 'vspc'                     VSPC\"\n \"CHANGE all word nx 'xa'                       XA\"\n \"CHANGE all word nx t'tsomodel.public.text' c'TSOMODEL.PUBLIC.TEXT'\"\n \"CHANGE all nx 'info0' 'INFO0'\"\n/* ==========================================.                      */\n/* *******  for  .PI entries  only  **********                      */\n/* *******  for  .PI entries  only  **********                      */\n/* *******  for  .PI entries  only  **********                      */\n/* *******  for  .PI entries  only  **********                      */\n \"Change ALL NX easytrieve EASYTRIEVE\"\n/* **.......Improve single word PI entries .**                      */\n \"Change ALL NX 6 p'@@@    ' p'>>>    '\"\n \"Change ALL NX 6 p'@@@@    ' p'>>>>    '\"\n \"Change ALL NX 6 p'@@@@@    ' p'>>>>>    '\"\n/* **.......Some words in .PI s/b lowercase.**                      */\n \"Change ALL NX x'50'   'and'   word\"\n \"Change ALL NX 'and'   'and'   word\"\n \"Change ALL NX 'the'   'the'   word\"\n \"Change ALL NX 'from'  'from'  word\"\n \"Change ALL NX 'of'    'of'    word\"\n/* **.......Put .PI back to normal form.....**                      */\n \"Change ALL NX  1 c'.pi ' '.pi '\"\n \"Change ALL NX  1 '.th .PI ' '.th .pi '\"\n \"Change ALL NX  1 '.el .PI ' '.el .pi '\"\n/* **............Label all NX lines.........**                      */\n \"labnx\"\n/* *******  for  .PI entries  only  **********                      */\n/* *******  for  .PI entries  only  **********                      */\n/* ==========================================.                      */\n/*==.                                                               */\n     Exit 0\n/*==.                                                               */\n/* ==========================================.                      */\n/*  If sentences occur in .PI they already                          */\n/*  were capitalized for first word in sentence                     */\n \"CHANGE all nx '.  a' '.  A'\"\n \"CHANGE all nx '.  b' '.  B'\"\n \"CHANGE all nx '.  c' '.  C'\"\n \"CHANGE all nx '.  d' '.  D'\"\n \"CHANGE all nx '.  e' '.  E'\"\n \"CHANGE all nx '.  f' '.  F'\"\n \"CHANGE all nx '.  g' '.  G'\"\n \"CHANGE all nx '.  h' '.  H'\"\n \"CHANGE all nx '.  i' '.  I'\"\n \"CHANGE all nx '.  j' '.  J'\"\n \"CHANGE all nx '.  k' '.  K'\"\n \"CHANGE all nx '.  l' '.  L'\"\n \"CHANGE all nx '.  m' '.  M'\"\n \"CHANGE all nx '.  n' '.  N'\"\n \"CHANGE all nx '.  o' '.  O'\"\n \"CHANGE all nx '.  p' '.  P'\"\n \"CHANGE all nx '.  q' '.  Q'\"\n \"CHANGE all nx '.  r' '.  R'\"\n \"CHANGE all nx '.  s' '.  S'\"\n \"CHANGE all nx '.  t' '.  T'\"\n \"CHANGE all nx '.  u' '.  U'\"\n \"CHANGE all nx '.  v' '.  V'\"\n \"CHANGE all nx '.  w' '.  W'\"\n \"CHANGE all nx '.  x' '.  X'\"\n \"CHANGE all nx '.  y' '.  Y'\"\n \"CHANGE all nx '.  z' '.  Z'\"\n \"LOC 0\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FIXQUOTE": {"ttr": 6927, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00b\\x00b\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 98, "newlines": 98, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- converted to REXX on 1994/06/03 */\nADDRESS \"ISREDIT\"    /* used with SCRIPT/VS GML DCF text preparation */\n /*  TITLE:       FIXQUOTE -- change \"...\" to use of :Q...:EQ.  tags */\n /*  USERS:       TSO ISPF EDIT USERS   | SCRIPT USERS               */\n /*  CONTRIBUTED: 1987/01/20 DAVID MCRITCHIE, \"The REXX Macros Toolbox\" */\n /*                                                                  */\n /*  EXAMPLE:     FIXQUOTE                                           */\n /*                                                                  */\n /*  OPTIONS:                                                        */\n /*      col1 col2  .label1 .label2  NX                              */\n /*      NX   cannot be used with other options                      */\n /*      END  cannot be used with other options                      */\n \"MACRO (RANGE)\"\n range = translate(range)\n /* SCRIPT CONVERSION TO PAGE USAGE -- D.MCR                        */\n \"SEEK ALL\" range \"':Q.'\"\n \"(OQCNT1S,OQCNT2L) = SEEK_COUNTS\"\n oqcnt1s=oqcnt1s+0; oqcnt2l=oqcnt2l+0\n \"SEEK ALL\" range \"':EQ.'\"\n \"(CQCNT1S,CQCNT2L) = SEEK_COUNTS\"\n cqcnt1s=cqcnt1s+0; cqcnt2l=cqcnt2l+0\n IF  OQCNT1S \\=   CQCNT1S THEN DO\n     \"LINE_BEFORE .ZF = NOTELINE \"\"\"Substr(time(\"n\"),1,5),\n        \"FIXQUOTE BEGAN WITH :Q. (\"OQCNT1S\" :EQ. (\"CQCNT1S\")\"\"\"\n END\n  IF RANGE = \"END\" THEN  DO\n    END = \"END\"\n    RANGE = \"\"\n END\n\n  IF RANGE  =  \"\"    THEN  \"Exclude ALL .ZF .ZL\"\n  IF RANGE  \\= \"NX\"  THEN  \"Change ALL\" range \"  1 '\"\"' ':q.'  \"\n/************** Summary of some of the changes ***********************/\n/* ||    '\",\"'    ':eq.,:q.'         ||     '\".'     ':eq..'    ||   */\n/* ||    ' \"'     ' :q.'             ||     '\",'     ':eq.,'    ||   */\n/* ||    '(\"'     '(:q.'             ||     '\": '    ':eq.: '   ||   */\n/* ||    '\" '     ':eq. '            ||     '\")'     ':eq.)'    ||   */\n/* ||--------------------------------XX-------------------------||   */\n/* || If no range or default range:  ':eq.      '  ':eq.&rbl.'  ||   */\n/* ||                                '(:q.)'  '(\")'             ||   */\n/*********************************************************************/\n \"Change ALL\" range \"  '\"\",\"\"'  ':eq.,:q.'\"\n \"Change ALL\" range \"  ' \"\"'    ' :q.'    \"\n \"Change ALL\" range \"  '(\"\"'    '(:q.'    \"\n \"Change ALL\" range \"  '\"\" '    ':eq. '   \"\n \"Change ALL\" range \"  '\"\".'    ':eq..'   \"\n \"Change ALL\" range \"  '\"\",'    ':eq.,'   \"\n \"Change ALL\" range \"  '\"\": '   ':eq.: '  \"\n \"Change ALL\" range \"  '\"\")'    ':eq.)'   \"\n\n IF RANGE = \"\" | range = \".ZF .ZL\" THEN   DO\n    \"Change ALL\" range \"':eq.               ' \",\n                       \"':eq.&rbl.          ' \"\n    \"Change ALL NX '(:q)' '(\"\")'\"   /* --- ambiguous --- */\n END\n \"Find ALL\" range \"  '\"\"'   \"\n \"Find ALL\" range \"'.bf xmpfont        '\"\n \"SEEK ALL\" range \"':Q.'\"\n \"(OQCNT1S,OQCNT2L) = SEEK_COUNTS\"\n \"SEEK ALL\" range \"':EQ.'\"\n \"(CQCNT1S,CQCNT2L) = SEEK_COUNTS\"\n IF OQCNT1S  \\=  CQCNT1S THEN DO\n     \"LINE_BEFORE .ZF = NOTELINE \"\"\"time(\"n\"),\n        \"****************** UNMATCHED QUOTES FOUND **********\"\"\"\n     \"LINE_BEFORE .ZF = NOTELINE \"\"\"time(\"n\") \"FIXQUOTE\",\n        \"RESULTS  :Q. (\"OQCNT1S\") :EQ. (\"CQCNT1S\")\",\n         \"-- PLICHK MAY HELP\"\"\"\n     \"Find FIRST \"Q.\" NX\"\n \"LOC 0\"\n     Exit 4\n END\n IF OQCNT2L \\= CQCNT2L THEN DO\n     \"LINE_BEFORE .ZF = NOTELINE \"\"FIXQUOTE lines matched=\" cqcnt1s,\n        \"--lines unmatched-- :Q. (\"OQCNT2L\") :EQ. (\"cqcnt2l\")\",\n        \"-- PLICHK MAY HELP\"\"\"\n     \"LOC 0\"\n     Exit 4\n END\n \"LINE_BEFORE .ZF = NOTELINE \"\"FIXQUOTE \",\n         Substr(time(\"n\"),1,5) \"RESULTS LOOK GOOD MATCHED\",\n         OQCNT1S\" :Q STRINGS TO :EQ.\",\n       \"on\" OQCNT2L \"lines\"\"\"\n \"SEEK ALL\" range \"  '\"\"'  \"   /* count number of double quotes*/\n \"(CQCNT1S,CQCNT2L) = SEEK_COUNTS\"\n IF  CQCNT1S \\= 0 THEN DO\n     \"LINE_BEFORE .ZF = NOTELINE \"\"\"time(\"n\"),\n       \"****************** WARNING *************************\"\"\"\n     \"LINE_BEFORE .ZF = NOTELINE \"\"  However, found \",\n       CQCNT1S \"stray orphan double quotes -- PLICHK MAY HELP\"\"\"\n     \"Find FIRST \"\"Q.\"\" NX\"\n    \"LOC 0\"\n     Exit 4\n END\n \"(VAR014A) = DATA_CHANGED\"\n IF \"END\" = END THEN  DO\n     IF VAR014A = \"NO\" THEN   \"END\"\n END\n \"LOC 0\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FLIPFLOP": {"ttr": 7169, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00?\\x00?\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "MCRITCH"}, "text": " /* REXX: flipflop -- reverse lines vertically between labels   */\n /*  Title:*REXX* flipflop the inclusive lines between two labels   */\n /*  Users:       TSO ISPF edit users   | SCRIPT users              */\n /*  Contributed: 1990/12/27 David McRitchie                        */\n /*                                                                 */\n /*  Example:     flipflop .zfirst .zlast                           */\n /*                                                                 */\n /*  Options:                                                       */\n /*      lptr-range | entire   (required) line pointer range        */\n /*                                                                 */\n /*  Requirements:                                                  */\n /*    two labels                                                   */\n \"ISREDIT  MACRO (labf,labl,remain)\"\n x2=substr(labf,1,1)||substr(labl,1,1)||remain\n if x2 \\= '..' then do\n    zedsmsg = '.labels'\n    zedlmsg = 'exactly two labels are required and nothing more,',\n       'nothing less'\n    /*Address*/   \"ISPEXEC SETMSG MSG(ISRZ000)\"\n    Exit 12\n end\n   /*****************************************************************/\n   /*****************************************************************/\n \"ISREDIT (LABFNUM) = LINENUM \" labf\n If RC \\= 0 then Do\n            ZEDSMSG = labf  \"LABEL\"\n            ZEDLMSG = ZEDSMSG \"does not exist\"\n            /*address*/ \"ISPEXEC    SETMSG MSG(ISRZ000)\"\n            Exit 12\n End\n \"ISREDIT (LABLNUM) = LINENUM \" labl\n If RC \\= 0 then Do\n            ZEDSMSG = labl  \"LABEL\"\n            ZEDLMSG = ZEDSMSG \"does not exist\"\n            /*Address*/ \"ISPEXEC   SETMSG MSG(ISRZ000)\"\n            Exit 12\n End\n/************** End of LABEL requirements *******************/\n/******************** code for  flipflop commands ************/\n/******************** code for  flipflop commands ************/\n/******************** code for  flipflop commands ************/\nAddress \"ISREDIT\"\n/*********************************************/\n\"LABEL \"LABFNUM\" = .sta 1\"\nPJ    = LABFNUM + 1\nfor = lablnum - labfnum\nDo J = lablnum to PJ by -1\n   \"(MOVELINE) = LINE \" lablnum\n   \"LABEL\" lablnum \"= .out 0\"\n   \"(MOVESTAT) = XSTATUS .out\"\n   \"delete .out .out all\"\n   \"(moved) = LINENUM \" .sta\n   \"LINE_BEFORE .sta   = DATALINE (moveline)\"\n   \"LABEL \" moved \" = .movep\"\n   If \"X\" = movestat then \"XSTATUS .movep = X\"\nEnd J\n/* 2  2  22 */\n/* 1  1  11 */\nIf substr(labf,1,2) \\= '.Z' then \"LABEL \" LABFNUM \"= \"labf \"0\"\nIf substr(labl,1,2) \\= '.Z' then \"LABEL \" LABLNUM \"= \"labl \"0\"\n\"LINE_BEFORE\" labfnum \"= NOTELINE ' *begin of flipflop \" labf labl \"'\"\n\"LINE_AFTER \" lablnum \"= NOTELINE ' *End   of flipflop \" labf labl \"'\"\nExit 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FLOC": {"ttr": 7171, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00P\\x00P\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 80, "newlines": 80, "modlines": 0, "user": "MCRITCH"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "FLOW": {"ttr": 7174, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00o\\x00o\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 111, "newlines": 111, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX  FLOW  edit macro modified from  -- TSO TIMES                */\n/* issue No. 5 --published by chicago-Soft Ltd., contest winner      */\n/*  written by David Leigh at Unipac service corporation.  Entered   */\n/* as a short macro clist of 14 lines, changes have been made to     */\n/* make it a REXX execute, make it move text left as well as well as */\n/* right, and specify right column boundary. David McRitchie 1992/01/10*/\n/* TFLOW can receive without problem a higher number than it can act-*/\n/* ually use, so only reason to limit is to avoid right truncation   */\n/*                                                                   */\n/* Usage MOVE text left or right to CURSOR position and TFLOW lines. */\n/* Optional use of PROCESS C line command as bottom limit of FLOW.   */\n/*                                                                   */\nAddress \"ISREDIT\"\nblanks = '                            '\n\"MACRO NOPROCESS (OPT1)\"\nAddress \"ISPEXEC\" \"control errors return\"\n\"(SLINE,SCOL) = cursor\"               /* retain cursor info at Start */\nif sline = 000 | scol = 000 then do\n   ZEDSMSG = \"CURSOR POS.\"\n   ZEDLMSG = \"CURSOR not placed within a line of text/data\"\n   Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   RETURN 0\nend\n\"PROCESS RANGE C\"                     /* obtain C-range              */\nprocess = rc                          /* check if a C-range exits    */\nIF process = 0 THEN DO\n   \"(ZFRANGE) = LINENUM .ZFRANGE\"     /* will only use ZLRANGE       */\n   \"(ZLRANGE) = LINENUM .ZLRANGE\"     /* will only use ZLRANGE       */\n   If zfrange \\= zlrange then do\n     ZEDSMSG = \"CC Invalid\"\n     ZEDLMSG = \"CC line range invalid, the C line command is optional\"\n     call removal\n   end\n   \"LINE_AFTER \" .zlrange \"= DATALINE '.REMOV'\"\n   remov =  zlrange + 1\n   \"LABEL \" remov \"= .remov 0\"        /* create a FLOW proof line    */\nEND\nelse zlrange = 0\n\"find first p'^' .zcsr .zcsr\"         /* find first non-blank on line*/\n\"(LN,CL) = cursor\"\n\"LABEL .zcsr = .curr \"\n\"(LBND,RBND) = BOUNDS\"\n\"BOUNDS\"\n\"(LCCC,RCCC) = BOUNDS\"\nif lbnd \\= lccc | rbnd \\= rccc then do\n  zedlmsg = \"Warning in use BOUNDS\" LBND RBND||\", \",\n    ||\"default is\" LCCC RCCC\n  \"(RECFM) = RECFM\"\n   IF left(RECFM,1) = \"V\" then\n     zedlmsg = zedlmsg ||\", RECFM=\"||RECFM\" adds +8 to each\"\n end\n\"BOUNDS\" LBND RBND\nif opt1 = '' then opt2 = RBND; else opt2 = opt1\n\nif scol = cl then do\n   \"TFLOW .ZCSR\" opt2\n   call removal  /* and exits */\nend\nif scol > cl then do\n   sright = scol - cl                 /* calculate shift right amt   */\n   flowcols = opt2 - sright\n   \"TFLOW .zcsr \" flowcols\n   \"(X,Y) = FLOW_COUNTS\"              /*  how many lines BEFORE,AFT  */\n   y = y - 1;\n   do i = 0 to y;                     /* y+1 is new lines involved   */\n      csrat = sline + i               /* add  1 to move cursor down  */\n      \"cursor = \" csrat 1             /*   a line and over to col 1  */\n      \"shift ) .zcsr \" sright         /*   shift right               */\n   end\n   call removal  /* and exits */\nend\nif scol < cl then do                  /* make sure, even if redundant*/\n   sleft  = cl - scol                 /* calculate shift left  amt   */\n   csrp = sline + 1\n   if zlrange \\= sline then do\n      \"LABEL \" csrp   \"= .csrp 1\"        /* next line down           */\n      \"SEEK '\"||left(blanks,sleft)||\"' 1 first .csrp .csrp\"\n      if rc \\= 0 then do\n         ZEDSMSG = \"Can't move\"\n         ZEDLMSG = \"Insufficient blanks on left side of \",\n             ||\"next line to shift left by \" sleft \"columns\"\n         Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n         call removal  /* and exit */\n      end\n   end\n   \"cursor = \" sline scol             /* after SEEK put back cursor  */\n   flowcols = opt2 + sleft\n   \"TFLOW .zcsr \" flowcols\n   \"(X,Y) = FLOW_COUNTS\"              /*  how many lines BEFORE,AFT  */\n   y = y - 1\n   do i = 0 to y;                     /* y+1 is new lines involved   */\n      csrat = sline + i               /* add  1 to move cursor down  */\n      \"cursor = \" csrat 1             /*   a line and over to col 1  */\n      \"shift ( .zcsr \" sleft\n   end\n   \"LINE_AFTER \" csrat    \"= DATALINE '.remvx'\"\n   csrat  =  csrat + 1\n   \"LABEL \" csrat  \"= .remvx 0\"       /* create a FLOW proof line    */\n  \"cursor = \" sline scol              /*   a line and over to col 1  */\n   \"TFLOW .zcsr \" opt2\n   \"(X,Y) = FLOW_COUNTS\"              /*  how many lines BEFORE,AFT  */\n   \"del .remvx .remvx all\"\n   call removal  /* and exits */\nend\nreturn\nREMOVAL: procedure expose zedsmsg zedlmsg sline scol;\n  \"del .remov .remov all\"\n  \"cursor = \" sline scol           /*  a line and over to col 1  */\n  Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n  exit 0\nend\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GDGNEW": {"ttr": 7177, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00H\\x00H\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 72, "newlines": 72, "modlines": 0, "user": "MCRITCH"}, "text": "/*   REXX: GDGNEW    test creating new gdg generation                */\n/*     GDGNEW: SYSOUT TRAP of TSO COMMAND creating data cards        */\n/*      TITLE:     GDGNEW -- copy sequential create new GDG level    */\n/*      Users:     TSO user, usage copying to GDG from PC transferred*/\n/*      Entry:     Used as a TSO clist                               */\n/*                 ===> GDGNEW pcname OS.GDGNAME                     */\n/*      Contributed: 1991/09/20 David McRitchie                      */\n/*      EXAMPLE:  ===> GDGNEW userid.FROMPC.DSN  xxxx.xxxx.xxxx      */\n/*         will create a new dataset  xxxx.xxxx.xxxx(+1)             */\n/*   arg From To                                                     */\nFrom = \"is03.share.text(clist)\"\nTo = \"is03.gdg.test\"\n   /* TSO dataset conventions for use w/o quotes */\n   PREFIX = SYSVAR(SYSPREF)\n   if PREFIX = '' then prefix = SYSVAR(SYSUID)\n   /* make up new names for  To and From datasets */\n   To = PREFIX || '.GDG.TEST'\n   From = PREFIX || '.share.text(clist)'\n\n/*translate to and from to uppercase */\nTo = translate(To)\nFrom  = translate(From)\n\n/*Check for existance of GDG */\nx = OUTTRAP('var.')\nAddress \"TSO\" \"LISTC ENT('\"||To||\"') GDG \"\nx = outtrap('OFF')\nif rc /= 0 then do\n   say \"GDG index has not been defined -- lines \" var.0\n   do i = 1 to var.0; say \"***\"||I||\" \"||Var.I;end\n   return 4\nend\nx = outtrap('OFF')\n\n/* Trap output from the statement following OUTTRAP */\nx = OUTTRAP('var.')\nAddress \"TSO\" \"LISTC LVL(\"||To||\")\"\nlastcc = rc\nx = outtrap('OFF')\n\n/* Check for not found condition */\nI = index(Var.1,\"NOT FOUND\")\nIf I /= 0 then Level = \"0001\"\nElse do\n   if lastcc /= 0 then do\n     Say 'Unexpected errors found'\n     do i = 1 to var.0; say \"***\"||I||\" \"||Var.I;end\n     return 4\n   end\n   I = Var.0 - 1\n   Card = Var.I;\n   L = length(Card)\n   Level = substr(Card,L-6,4)\n   Level = Level + 1\n   Level = right(Level,4,'0') /* right justify and zero fill*/\nend\n\nGDGOUT = To||'.G'||Level||'V00'\n\"ALLOCATE FILE(SYSUT2) DA('\"||GDGOUT||\"') UNIT(TESTDISK)\",\n   \" SPACE(10 10) TRACK NEW REUSE RELEASE\"\n\"ALLOCATE FILE(SYSUT1) DA('\"||From||\"') SHR REUSE\"\n\"FREE   FI(SYSUT1 SYSUT2 SYSPRINT)\"\n\"ALLOC  FI(SYSPRINT)  DUMMY\"\n\"ALLOC  FI(SYSUT1)    DA('\"||From\"')  SHR\"\n\"ALLOC  FI(SYSUT2)    DA('\"||GDGOUT||\"')  OLD\"\n\"ALLOC  FI(SYSIN)     DUMMY  REUSE\"\n\"CALL   'SYS1.LINKLIB(IEBGENER)'\"\nlastcc = rc\nif lastcc /= 0 then say IEBGENER in GDGNEW failed.\n\"FREE   FI(SYSUT1 SYSUT2)\"\n\"ALLOC  FI(SYSIN)     DA(*)  REUSE\"\n\"ALLOC  FI(SYSPRINT)  DA(*)  REUSE\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETTRID": {"ttr": 7180, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00<\\x00<\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -\n     statistics      0122-92148-93314-0817-00056-00087-00000-REXX\n     sys6.cbt.file078(rexx)\n     returns the name of the terminal -- e.g.\n          terminal = gettrid(); say terminal\n +------------------------------------------------------------------+\n | Name:       GETTRID                                              |\n | Type:       REXX exec                                            |\n | Purpose:    Extract the ACEETRID from the RACF ACEE.             |\n | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       3/10/93                                              |\n | Abstract:   A sub-function to extract the VTAM terminal id from  |\n |             the RACF Accessor Environment Element.  The ACEE is  |\n |             not fetch protected.  This function works in ACF2    |\n |             systems.                                             |\n |                                                                  |\n | Call Format:  GETTRID()                                          |\n |                                                                  |\n | Logic: Extracts address of ASCB (PSAAOLD at x'224')              |\n |        Extracts address of ASXB (ASCB+x'6C')                     |\n |        Extracts address of ACEE (ASXB+x'C8')                     |\n |        Extracts ACEETRID                                         |\n +------------------------------------------------------------------+ */\ntrace\n\nascb_ptr = get_ptr(224,0)\nasxb_ptr = get_ptr(ascb_ptr,'6c')\nacee_ptr = get_ptr(asxb_ptr,'c8')\naceetrid = get_data(acee_ptr,'40',8)\nexit aceetrid\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE RACF ACEE TERMINAL ID             */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GML": {"ttr": 7182, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00C\\x00C\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 67, "newlines": 67, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- converted to REXX on 1994/06/03 */\nADDRESS \"ISREDIT\"\n /*  TITLE:       GML    -- ENCLOSE 2ND OPERAND WITHIN GML TAGS     */\n /*  USERS:            SCRIPT USERS                                 */\n /*  CONTRIBUTED: 1988/04/09 DAVID MCRITCHIE                        */\n /*     related clists:  ungml -- to changes \";\" to \"&semi\" etc.    */\n /*                                           or reverses process   */\n /*                                                                 */\n /*  EXAMPLE: ===>  gml hp1 'not' word nx                           */\n /*                          ===  -------                           */\n /*                 --GENERATES--                                   */\n /*                     C ALL word nx 'not' ':hp1.not:ehp1.'        */\n /*                           -------  ===        ===               */\n /*   ampersands can be handled by quadrupling them                 */\n /*      since this is now REXX, I will do that for you.            */\n /*    e.g. ===> gml hp1 AT&amp.T                                   */\n /*      appears to generate                                        */\n /*        c all AT&amp.T  :hp1.AT&amp.T:ehp1.                      */\n /*      actually generates..                                       */\n /*        c all AT&&&&amp.T  :hp1.AT&&&&amp.T:ehp1.                */\n /*                                                                 */\n \"MACRO (GML,FROM,TOKENS)\"\n IF from = \"\" then do\n    ZEDSMSG = \"INCORRECT\"\n    ZEDLMSG = \"2 operands REQUIRED e.g. ==> gml hp1 STRING1\"\n    GGG = \"generates ---> c all \"\n    call note \"*ERROR**\" ZEDLMSG\n    call note \"example ===> gml hp2 FORTRAN word\"\n    call note \" or   ===> gml hp2 'FORTRAN' word\"\n    call note GGG \"word 'FORTRAN' ':hp2.FORTRAN:ehp2.'\"\n    call note \"            \"\n    call note \"example   ===> gml hp2 \"\"FORTRAN\"\" word\"\n    call note GGG \"word \"\"FORTRAN\"\" \"\":hp2.FORTRAN:ehp2.\"\"\"\n    Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    \"LOCATE 0\"\n    Exit 4\n END\n GML = translate(gml,\"abcdefghijklmnopqrstuvwxyz\", ,\n                     \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n Q = left(FROM,1)\n IF Q = '\"'  | Q =  \"'\"  then do   /* \" ' so matches on this line*/\n    L = LENGTH(from)\n    call note \"length(\"from\") =\" L\n    If right(from,1) = Q then FROM = SUBSTR(from,2,l-2)\n    ELSE SET Q = \"\"\n END\n ELSE Q = \"\"\n xxx=\"Change all\" TOKENS Q||FROM||Q  Q||\":\"GML\".\"from\":e\"gml\".\"||Q\n call note \"GML--\" xxx\n i = pos('&',xxx)\n if i \\= 0 then do\n    newxxx=\"\"    /* ampersands will be quadrupled for transparency*/\n    do i=1 to length(xxx)\n       if substr(xxx,i,1) = '&' then newxxx=newxxx||'&&&&'\n       else newxxx = newxxx||substr(xxx,i,1)\n    end\n    call note \"The actual command required/entered by macro will be...\"\n    call note \"   --\" newxxx\n    xxx=newxxx\n end\n xxx     /* <--- this is where command is actually invoked */\n call note  time(\"n\") \"-- gml\" GML   TOKENS  Q||FROM||Q\n\n  return\nnote:  parse arg arg\n    \"LINE_BEFORE .ZFIRST = NOTELINE (arg)\"\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GMLTP": {"ttr": 7184, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x96\\x00\\x96\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 150, "newlines": 150, "modlines": 0, "user": "MCRITCH"}, "text": " /*  TITLE:*REXX* GMLTP   CREATE TAGS BETWEEN TAB CHARACTERS        */\n /*               FUNCTIONS ON ON NX LINES                          */\n /*  USERS:       TSO ISPF EDIT USERS   | SCRIPT USERS              */\n /*  CONTRIBUTED: 1990/12/22 DAVID MCRITCHIE                        */\n /*                                                                 */\n /*  EXAMPLE:     GMLTP  2 1 :GT12. :EGT12.                         */\n /*               GMLTP  3 1 MIN(65)                                */\n /*               GMLTP  2 4 :GT12. :EGT12.                         */\n /*               GMLTP  2 4 NOTELINE       (TESTING)               */\n /*                                                                 */\n /*  OPTIONS:                                                       */\n /*      *NUMBER A*   MAKE A-TH \"^\" TO \"^<TAG>\"                     */\n /*      *NUMBER B*   MAKE NEXT B-TH \"^\" TO \"<TAG>^\"                */\n /*         IF NOT FOUND WILL PLACE AFTER LAST CHARACTER FOUND      */\n /*      MIN(N)   IF 2ND TAB NOT FOUND USE COL INSTEAD OF LAST POS  */\n /*      .LABEL1  OPTIONAL START LABEL                              */\n /*      .LABEL2  OPTIONAL LAST LABEL                               */\n /*                                                                 */\n /*  REQUIREMENTS:                                                  */\n /*    TWO NUMBERS TO INDICATE FIRST TAB AND NEXT TAB TO PROCESS    */\n      /*    CONTROL ASIS */\n \"ISREDIT  MACRO (TOK1,TOK2,TOK3,TOK4,TOK5,TOK6,TOK7,TOK8,TOK9,TOK10, ,\n           TOK11,TOK12,TOK13,TOK14,TOK15,TOK16,TOK17,TOK18,TOK19, ,\n           TOK20,TOK21,TOK22,TOK23,TOK24,TOK25,TOK26,TOK27,TOK28)\"\n     TAB1 = 0;TAB2=0;TAB1C=\"^\";TAB2C=\"^\";TAG1=\"<TAG>\";TAG2=\"<ETAG>\"\n     ENTIRE=\"\";MIN=0;LABF='';LABL='';NOTELINE=\"\"\n REMAIN = \" \"\n ADDRESS \"ISREDIT\"\n \"LINE_BEFORE .ZF = NOTELINE '\"||TIME('N')||\" GMLTP: \" ,\n     TOK1 TOK2 TOK3 TOK4 TOK5 \"'\"\n DO I = 1 TO 28 BY 1; DO INNER = 1 TO 1 BY 1;\n        TOKENX = TOK||I\n        TOKENX  = VALUE(TOKENX)\n        TOKEN = TRANSLATE(TOKENX)\n        IF TOKEN = \"\" THEN LEAVE I\n        IF TAB2 = 0 THEN DO\n           IF DATATYPE(TOKEN) = 'NUM' THEN DO\n              IF TAB1 = 0 THEN TAB1 = TOKEN;ELSE TAB2=TOKEN\n              LEAVE INNER\n           END\n        END\n        IF TOKEN= \"ENTIRE\" THEN DO; ENTIRE=TOKEN;LEAVE INNER; END;\n        IF TOKEN=\"NOTELINE\" THEN DO; NOTELINE=TOKEN;LEAVE INNER; END;\n        IF SUBSTR(TOKEN,1,4) = \"MIN(\" THEN DO\n           MIN = SUBSTR(TOKEN,5,LENGTH(TOKEN)-5)\n           MIN = MIN + 1\n           LEAVE INNER\n        END\n        IF SUBSTR(TOKEN,1,1) = \".\" THEN DO\n           IF  LABF = \"\"     THEN DO\n              LABF = TOKEN\n              LEAVE INNER\n           END\n           IF       LABL  = \"\"     THEN DO\n              LABL = TOKEN\n              LEAVE INNER\n           END\n           ZEDSMSG = \"LABEL TOKENS\"\n           ZEDLMSG = \"EXACTLY TWO LABELS ARE REQUIRED \" ,\n             ||\"FOUND  \" LABF \", \" LABL \" AND  \" TOKEN\n           ADDRESS 'ISPEXEC' ' SETMSG MSG(ISRZ000)'\n           EXIT 12\n        END\n        IF TAG1 = \"<TAG>\" THEN DO;    TAG1=TOKENX;LEAVE INNER; END;\n        IF TAG2 = \"<ETAG>\" THEN DO;   TAG2=TOKENX;LEAVE INNER; END;\n    REMAIN = REMAIN TOKEN\n  END INNER\n END I\n IF REMAIN /= \"\" THEN ,\n SAY REMAIN \"-- NOT PROVIDED FOR IN .EXEC\"\n   /*****************************************************************/\n   /*****************************************************************/\n IF LABF = \"\" THEN ENTIRE = \"ENTIRE\"\n IF ENTIRE = \"ENTIRE\" THEN DO     /*** LABELS ARE REQUIRED ***/\n    IF  LABF = \"\"     THEN DO\n       LABF = \".ZFIRST\"\n       LABL = \".ZLAST\"\n    END\n    ELSE DO\n       SAY LENGTH(LABF)  LENGTH(LABL)\n       ZEDSMSG = \"LABEL CONFLICT\"\n       ZEDLMSG = '\"ENTIRE\" IMPLIES .ZFIRST .ZLAST ' ,\n         || 'CONFLICTS WITH ' LABF ' AND ' LABL\n       ADDRESS 'ISPEXEC' ' SETMSG MSG(ISRZ000)'\n       EXIT 12\n    END\n END\n \"ISREDIT (#LABF) = LINENUM \" LABF\n IF RC ^= 0 THEN DO\n            ZEDSMSG = LABF  \"LABEL\"\n            ZEDLMSG = ZEDSMSG \"DOES NOT EXIST\"\n            ADDRESS 'ISPEXEC' ' SETMSG MSG(ISRZ000)'\n            EXIT 12\n END\n \"ISREDIT (#LABL) = LINENUM \" LABL\n IF RC ^= 0 THEN DO\n            ZEDSMSG = LABL  \"LABEL\"\n            ZEDLMSG = ZEDSMSG \"DOES NOT EXIST\"\n            ADDRESS 'ISPEXEC' ' SETMSG MSG(ISRZ000)'\n            EXIT 12\n END\n /************** END OF LABEL REQUIREMENTS *******************/\n /******************** CODE FOR  GMLTP COMMANDS ************/\n /******************** CODE FOR  GMLTP COMMANDS ************/\n /******************** CODE FOR  GMLTP COMMANDS ************/\n ADDRESS \"ISREDIT\"\n \"FIND FIRST NX &LABF. &LABL. '\"||TAB1C||\"'\"\n IF RC ^= 0 THEN EXIT 4\n \"FIND FIRST P'=' .ZCSR .ZCSR\";J=1\n DO FCARDS = 1 TO 20000 BY 1   /*FIX THIS LATER TO FOREVER*/\n   \"FIND NEXT NX '\"||TAB1C||\"'\"\n   IF RC /= 0 THEN EXIT 0\n   DO CARD = 1 TO 1 BY 1\n     \"(VAR036) = LINE .ZCSR\"\n     J=1;\n     DO I=1 TO TAB1 BY 1\n        JJ=INDEX(VAR036,TAB1C,J)\n        IF JJ=0 THEN LEAVE CARD\n        J=JJ+1\n     END\n     VAR036=SUBSTR(VAR036,1,J-1)||TAG1||SUBSTR(VAR036,J)\n     J=J+LENGTH(TAG1)+1\n     DO I=1 TO TAB2 BY 1\n        JJ=INDEX(VAR036,TAB2C,J)\n        IF JJ=0 THEN DO\n          DO J=LENGTH(VAR036) TO 1 BY -1 WHILE(SUBSTR(VAR036,J,1)=' ')\n          END; J=J+2; IF MIN > J THEN J=MIN\n          LEAVE I;\n        END;\n        J=JJ+1\n     END I\n     VAR036=SUBSTR(VAR036,1,J-2)||TAG2||SUBSTR(VAR036,J-1)\n     IF NOTELINE ^= \"NOTELINE\" THEN DO /*REPLACE LINE WITH NEWLINE*/\n       \"(LINE#,COL#) = CURSOR\"\n       VAR036= TRANSLATE(VAR036,X2C('0809'),'\"&')\n       \"LINE_BEFORE .ZCSR = DATALINE \"\"\"||VAR036||\"\"\"\"\n       \"DEL .ZCSR .ZCSR ALL\"\n       \"CURSOR = \" LINE# 0\n       \"ISREDIT CHANGE ALL .ZCSR .ZCSR '\"||X2C('08')||\"' '\"\"'  \"\n       \"ISREDIT CHANGE ALL .ZCSR .ZCSR '\"||X2C('09')||\"' '50'X \"\n     END\n     ELSE DO\n       VAR036= TRANSLATE(VAR036,'~!','\"&')\n       \"LINE_BEFORE .ZCSR = NOTELINE \"\"\"||VAR036||\"\"\"\"\n     END\n     \"FIND LAST P'^' .ZCSR .ZCSR\"\n   END CARD\n END FCARDS\n SAY PROGRAM IN ERROR OR TIME TO REVISE -- HAVE MORE THAN 20 FCARDS\n EXIT CODE(12)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GOTDSN": {"ttr": 7428, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x1d\\x00\\x1d\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "MCRITCH"}, "text": "   PROC 1 DSN INFORM\n   /* GOTDSN:  DETERMINE IF THE PERSON TESTING HAS THE DSNAME ALLOCATED\n   /*    NO PROVISION MADE FOR MEMBERNAME\n   /* CONTRIBUTED: DAVID MCRITCHIE, \"THE REXX MACROS TOOLBOX\", 1989/09/04\n   SET INFORM = &SYSCAPS(&INFORM.)\n   SET SYSOUTTRAP = 400\n   LISTALC STA\n   SET N = &SYSOUTLINE\n   SET SYSOUTTRAP = 0\n   SET I = 1\n   SET LP = &STR((\n   DO WHILE &I <= &N\n      SET DX = &STR(&&SYSOUTLINE&I..)\n      SET DX = &STR(&DX.)\n      SET IX = &SYSINDEX(&STR(&LP.),&STR(&DX.))\n      IF &IX ^= 0 THEN SET DX = &SUBSTR(1:&EVAL(&IX. - 1),&STR(&DX.))\n /*   WRITE &IX. _ &DX. _ &DSN. _ &LP.\n      IF X&SUBSTR(1:1,&STR(&DX.)) = X&STR( ) THEN GOTO NIX\n      IF X&STR(&DX.). = X&STR(&DSN.). THEN DO\n         IF INFORM = &INFORM THEN -\n            WRITE GOTDSN -- YES YOU ARE ALLOCATED TO &DSN. <---<<\n         EXIT CODE(0)\n      END\n   NIX: -\n      SET I = &I. + 1\n   END\n   IF INFORM = &INFORM THEN -\n      WRITE GOTDSN -- YOU ARE NOT ALLOCATED TO &DSN.\n   EXIT CODE(4)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HEXES": {"ttr": 7430, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00G\\x00G\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 71, "newlines": 71, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- HEXES */\n/* HEXES: Substitutes HEX code for *HEX%%xxxx%% string */\n/* author: David McRitchie, \"The REXX Macros Toolbox\"   1990/09/15 */\n/* contact: David McRitchie,  \"The REXX Macros Toolbox\" */\n\n/* documentation available: http://members.aol.com/rexx01/txt/hexes.txt */\n/* This clist is universally available with the stipulation that */\n/*  the original author remains credited  */\n/*  and that no charge or licensing fee accrues to any party.  */\n/* This will be my 3rd    meaningful REXX execute */\n/* TEST WITH DATA IN -- Self testing, or use IS03.LIBR.CLIST(duptest)*/\nAddress \"ISREDIT\"           /* this and that and that and that*/\n\"MACRO\"\nxcnt = 0\n\"LOC .zfirst\"             /* word repeated is the word reset */\n\"reset\"\n\"exclude all\"\n\"LINE_BEFORE .ZFIRST = NOTELINE 'HEXES: converts   \" ,\n         \"*HEX%%string%%   to the hex equivalent of   string'\"\nMAXCC = 0\nLASTWORD = '##'       /*self-testing duplicate is ... dodo  dodo  */\ndo  forever\n\"LABEL .zcsr = .aa 0\"\n\"SEEK NEXT '*HEX%%'\"\nlastrc = rc\nIF lastrc \\= 0 THEN do; \"loc .zfirst\";\n    ZEDSMSG = \"hexes rc=\"||maxcc\n    ZEDLMSG = zedsmsg\n    msg = \"HEXES:\" TIME('N')  zedsmsg ,\n        || \", number of strings converted = \" xcnt  \"'\"\n    \"LINE_AFTER  0  =  MSGLINE (msg)\"\n    address ISPEXEC 'SETMSG MSG(ISRZ000)'\n    \"up max\"\n    return(maxcc);\nend;\n\"(RECORD) = LINE .ZCSR \"\nDRECORD = TRANSLATE(RECORD,x2c(08),x2c(7F)) /* ' \" */\ndo  while(lastrc = 0);      /* second dumb dodo dodo*/\n   \"(LINEx,COL1) = CURSOR\"\n   \"SEEK NEXT '%%' .ZCSR .ZCSR\"\n   \"SEEK NEXT '%%' .ZCSR .ZCSR\"\n   lastrc = rc\n   IF lastrc = 0 then do;\n      \"(linex,COL2) = CURSOR\"\n      /*  *hex%%abc.def%%  */\n      /*  1...5...10...15 */\n      THATWORD = substr(RECORD,(col1+6),(col2 - col1 - 6))\n      NEWWORD  = c2x(thatword)\n      spaced = \"\"\n      do i = (col1+6)  to (col2 - 1);\n         SPACED = SPACED || SUBSTR(DRECORD, I, 1 ) || \" \";\n      end;\n      notex = \"Change \" || SPACED\n      \"LINE_BEFORE .ZCSR = NOTELINE (notex)\"\n      notex = \"To ... \" || NEWWORD\n      \"LINE_BEFORE .ZCSR = NOTELINE (notex)\"\n      \"LINE_BEFORE .ZCSR = MSGLINE (DRECORD)\"\n      \"change '*hex%%\" || THATWORD || \"%%' '\" ,\n         || NEWWORD || \"'  all .zcsr .zcsr \"\n      lastrc = rc\n      if lastrc = 0 then do;\n         xcnt = xcnt + 1\n         \"change '%%OLD%%' '\" || THATWORD || \"' next .zcsr .zcsr\"\n      end;\n      else maxcc = max(maxcc,4)\n      \"RESET .ZCSR .ZCSR CHANGE\"\n      \"SEEK NEXT '*HEX%%'\" .zcsr .zcsr\n      lastrc = rc\n   end;\nend;\nend;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HEXSHOW": {"ttr": 7433, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00>\\x00>\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 62, "newlines": 62, "modlines": 0, "user": "MCRITCH"}, "text": "/*  REXX -- HEXSHOW show as characters hex notation presented        */\n/*  The primary purpose of HEXSHOW is to show characters             */\n/*       corresponding to the HEX notation present in EDIT           */\n/*********************************************************************/\n/*  HEXSHOW     Author: David McRitchie, created 1990/12/09 IS03     */\n/*             at \"The REXX Macros Toolbox\", DMcRitchie@aol.com      */\n/*             Updated 1990/12/10 14:23 IS03, later updated to 72 col. */\n/*             Updated 1992/03/16 14:30 IS03 added missing comma     */\n/*             Updated 1993/12/29 14:25 IS03 handle quote x'7D' in data*/\n/*********************************************************************/\n address \"ISREDIT\"\n \"MACRO (TOK1)\"\n NOTELINE = \"INFOLINE\"\n IF TOK1 = \"DATALINE\" THEN do;\"CAPS OFF\";NOTELINE=\"DATALINE\";END;\n IF TOK1 = \"DATALINE\" THEN NOTELINE=\"DATALINE\";ELSE NOTELINE=\"NOTELINE\"\n \"locate 0\"\n notes = \" -- HEXSHOW show all available hex notatation in char form\"\n \"LINE_BEFORE .ZFIRST = \"||NOTELINE||\" '\"||TIME('N')||\" -- HEXSHOW\" ,\n    || \" DISPLAY CHARACTER VALUES of NX lines'\"\n \"LINE_BEFORE .ZFIRST = \"||NOTELINE||\" '   designed for viewing zaps'\"\n C256 = XRANGE('00'X,'FF'X);\n NX256 = TRANSLATE(C256,' ','0123456789ABCDEF'); /*NX256 all but hex*/\n /* --- ONLYHEX = TRANSLATE(stringxx,' ',NX256) */\n VAR036 = \"VER 0123 C4C1,E5C9,C440 DAVID McRitchie F1F2F3F4 C4C1E5CC4\"\n \"f first p'=' 1 nx\"\n test = 0  /* remove all test material(s) once we know it works*/\n pRC = RC\n do while pRC = 0; pRC = 1\n   \"(VAR036) = LINE .ZCSR\"\n   HOLDs = \" \"||VAR036|| \" \"; /*so that 1st col and last col can work*/\n   HOLDs = substr(HOLDs,1,80);\n   HOLDs = TRANSLATE(HOLDs,' ',NX256); /*only hex digits for search*/\n   holdN = TRANSLATE(' '||VAR036||' ',' ',,' '); /*future noteline*/\n   i=1; /*initialize while variable to non-zero*/\n   do while (i \\=0)\n     i=verify(HOLDs,' ');\n     if i \\= 0 then ,\n       if substr(HOLDs,i+1,1) \\= ' ' then do\n         x2 = substr(HOLDs,i,2);\n         jj=verify(x2,'ABCDEF0123456789')\n         if jj \\= 0 then x1 = ' '\n         else x1 = x2c(x2)\n         xx = c2x(x1)\n         tempN = substr(holdN,1,i-1)||' '||x1 || substr(holdN,I+2)\n         holdN = tempN\n         tempS = substr(HOLDs,1,i-1) || '  '||substr(HOLDs,i+2)\n         HOLDs = tempS\n       end\n       else do\n          tempS = substr(HOLDs,1,i-1)||' '||substr(HOLDs,i+1)\n          HOLDs = tempS\n       end\n       i=verify(HOLDs,' ');\n   end\n   if length(HOLDs) > 72 then HOLDs = substr(HOLDs,1,72)\n   notex = substr(holdN,2,length(HOLDs))\n   note = \"ISREDIT LINE_BEFORE .ZCSR = \"||INFOLINE \"(NOTEX)\"\n   jj = verify(holdN,' ')\n   if jj \\= 0   then note\n   \"find next nx '='p 1\"\n   pRC = RC\n end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HEXUS": {"ttr": 7435, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00>\\x00>\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 62, "newlines": 62, "modlines": 0, "user": "MCRITCH"}, "text": " /*rexx hexus: HEX to/from Character Conversion */\n cls;   /*programmer David McRitchie, \"The REXX Macros Toolbox\", Dec 07, 1990*/\n say \"   HEX to/from Character conversion ------------------- HEXUS\"\n say \"              written by David McRitchie in REXX             \"\n say \"   For conversion to hex  C2X() use X followed by char string\"\n say \"   Uppercase text to hex  C2X() use H followed by char string\"\n say \"   For conversion to char X2C() use C followed by hex string\"\n say \"          Use  R  to clear screen and recall last entry\"\n say  \"-------- Three Examples Follow and then it's your turn ---------\"\n    push \"X hex this \"||DATE('J')\n    push \"H hex this \"||DATE('J')\n    str=\"date: \" || DATE('U')    TIME('N') ||\" \";st2=\"C \"||c2x(str)\n    push st2\n    i = 0; str=\"seed\";say \" \";\n do forever\n    say 'enter C, H, or X conversion, or blank to quit, on next line> ';\n    laststr = str\n    parse pull str\n    op = SYSCAPS(substr(str,1,1))\n    if op = \" \" then return(0);\n    if op = \"R\" then ,\n       do; str=laststr;cls; op = SYSCAPS(substr(laststr,1,1));end;\n    say str;\n    if op = \"C\" then ,\n       do;\n           jj=verify(substr(str,3),'0123456789ABCDEFabcdef')\n           if jj\\=0 then do; c=substr(substr(str,3),jj,1)\n              nstr = '***ERROR*** char('||c||') in pos.' jj ,\n                'of string is not a hex digit'\n           end\n           else if length(str) - trunc(length(str) / 2)*2 = 1 then ,\n              nstr= '***ERROR*** even number of digits required'\n           else do;\n            nstr=X2C(substr(str,3));\n            say scatter(nstr);\n           end\n       end\n    else if op =\"H\" then ,\n       do; str=SYSCAPS(str)\n           nstr=C2X(SYSCAPS(substr(str,3))); say ,\n           \"--H--   Conversion to uppercase, before conversion to hex\"\n           say scatter(substr(str,3))\n       end\n    else if op =\"X\" then do;\n       nstr=C2X(substr(str,3));\n       say scatter(substr(str,3))\n    end\n    else do;say \"Op code \"\"\" op \"\"\" unknown -- must be X, H, C, or R\"\n            nstr=\"-------------invalid---------------\";end;\n    say \"= \"||nstr;  say \" \"\n end;\n syscaps: procedure\n    uppercase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase = \"abcdefghijklmnopqrstuvwxyz\"\n arg argg\n argg = translate(argg,uppercase,lowercase)\n return argg\nscatter: procedure; parse arg str; j=0; str1='> ';\ndo while (j <= length(str)); j=j+1;\n   str1=str1||' '||substr(str,j,1);\nend;\nreturn str1;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IDATA": {"ttr": 7437, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x07\\x00\\x07\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- IDATA interface to SCRIPT */\nAddress \"ISREDIT\"\n\"MACRO (TOKEN)\"\nAddress \"ISPEXEC\" \"CONTROL ERRORS RETURN\"\nif sysdsn(s9999.list) = \"OK\" then\n   Address \"TSO\" \"del s9999.list\"\n\"@SCRIPT DEV(PG1A) CLASS(S) DEST(PROG1A3A) SYSVARM(IDATA)\" TOKEN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INFOHELP": {"ttr": 7439, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00*\\x00*\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "MCRITCH"}, "text": " PROC 1 MEMBER EDIT\n      IF EDIT = &SYSCAPS(&EDIT) THEN SET BROWSE = EDIT\n      ELSE SET BROWSE = BROWSE\n      SET MULTIMEM = &SYSINDEX(&STR(*),&STR(&MEMBER.))\n      IF &MULTIMEM = 0 THEN -\n         SET MULTIMEM = &SYSINDEX(&STR(%),&STR(&MEMBER.))\n      IF &STR(&MEMBER.) = &STR() | &STR(&MEMBER.) = &STR(*) THEN DO\n         SET CHK =  &STR(&SYSDSN('TECH.INFO.TEXT')\n         IF &STR(&CHK.) = OK THEN -\n             ISPEXEC &BROWSE DATASET('TECH.INFO.TEXT')\n         ELSE   WRITE &RBL.    DATASET 'TECH.INFO.TEXT' &STR(&CHK.)\n         EXIT CODE(0)\n      END\n      IF &MULTIMEM = 0 THEN +\n          SET CHK = &STR(&SYSDSN('TECH.INFO.TEXT(&MEMBER.)')\n          ELSE +\n          SET CHK = &STR(&SYSDSN('TECH.INFO.TEXT')\n      IF &STR(&CHK.) = OK THEN -\n         ISPEXEC &BROWSE DATASET('TECH.INFO.TEXT(&MEMBER.)')\n   ELSE -\n   DO\n    WRITE\n    WRITE\n    WRITE\n    WRITE\n    WRITE :  MEMBER &MEMBER NOT FOUND - GIVING YOU BACK THE HELP MEMBER\n    WRITE :       WHEN YOU HAVE LOCATED THE CORRECT MEMBER\n    WRITE :          PLEASE REENTER ON THE COMMAND LINE\n    WRITE :                TSO MODELT XXXXX\n    ISPEXEC &BROWSE DATASET('TECH.INFO.TEXT(HELP)')\n    WRITE\n    WRITE :  YOU CAN &BROWSE ALL MEMBERS IN TURN USING\n    WRITE :        TSO INFOHELP *\n    WRITE\n    WRITE :  A COMPLETE INDEX OF ENTIRES IS IN MEMBER $ WHICH IS NOW\n    WRITE :               MADE AVAILABLE TO YOU\n    WRITE :       WHEN YOU HAVE LOCATED THE CORRECT MEMBER\n    WRITE :          PLEASE REENTER ON THE COMMAND LINE\n    WRITE :                TSO MODELT XXXXX\n    ISPEXEC &BROWSE DATASET('TECH.INFO.TEXT($)')\n       END\n EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSERT": {"ttr": 7441, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x003\\x003\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- INSERT characters before cursor                           */\n/* Created by David McRitchie, \"The REXX Macros Toolbox\", 1992/01/17 */\n/*********************************************************************/\n/*    options:                                                       */\n/*      WORD insert1 insert2                                         */\n/*      insert1                                                      */\n/*      WORD :gt12. :egt12.                                          */\n/*      :gt12.          insert.insert.insert.xxx                     */\n/*********************************************************************/\nAddress \"ISREDIT\"\n\"MACRO (INSERT1,INSERT2)\"\n\"(LN,CL) = CURSOR\"\n\"(BND1,BND2) = BOUNDS\"\nif left(insert1,1) = \"'\" then\n   insert1a = substr(insert1,2,length(insert1)-2)\nelse if left(insert1,1) = '\"' then\n   insert1a = substr(insert1,2,length(insert1)-2)\nelse insert1a=insert1;insert1=insert1a\nif left(insert2,1) = \"'\" then\n   insert2a = substr(insert2,2,length(insert2)-2)\nelse if left(insert2,1) = '\"' then\n   insert2a = substr(insert2,2,length(insert2)-2)\nelse insert2a=insert2;insert2=insert2a\nlinex=\"\"\n\"f last p'^' .zcsr .zcsr\"\n\"(LNX,CL2) = CURSOR\"\n\"(LINE) = LINE \" LN\nif bnd2 < (cl2 + length(insert1) + length(insert2)) then do\n   \"cursor = \" ln cl\n    ZEDSMSG = 'won''t fit'\n    ZEDLMSG = \"REQUEST to insert\" insert1 \"before, and \" insert2 ,\n        'after won''t fit'\n    \"LINE_AFTER  .ZCSR = NOTELINE \"\"*ERROR**\" ZEDLMSG \"\"\"\"\n    ISPEXEC     SETMSG MSG(ISRZ000)\nend\nif length(insert2) \\= 0 then do\n   linex = translate(line,' ',':,&^~|%^*_+=!\u00a2\u00f8;}{><?')\n   i = index(substr(linex,cl),\" \")\n   if i = 0 then return\n   i = i + cl - 2\n   if substr(line,i,1) = \".\" then i = i-1\n   linex = left(line,i)||insert2||substr(line,i+1)\n   line  = linex\nend\nlinex = left(line,cl-1)||insert1||substr(line,cl)\nline  = linex\n\"LINE \" ln \"=  (LINEX)\"\ncl = cl + length(insert1)\n\"CURSOR =\" ln cl\nReturn\n/*  a abc abcde abcdefg hhh iii   */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INVERT": {"ttr": 7443, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- converted to REXX on 1994/06/03 */\nADDRESS \"ISREDIT\"\n /* THIS Macro WILL INVERT LINES BETWEEN TWO LABELS (.A) (.B)   */\n /* DAVID MCRITCHIE, \"The REXX Macros Toolbox\"           1990/04/19 */\n \"MACRO (LABA LABB)\"\n IF laba = \"\" THEN  LABA = \".A\"\n IF labb = \"\" THEN  LABB = \".B\"\n\n \"(FIRST) = LINENUM\" LABA\n x = rc\n \"(LAST)  = LINENUM\" LABB\n x = x + rc\n if rc \\= 0 then do\n    ZEDSMSG = \".A / .B labels\"\n    ZEDLMSG = \"Two labels are required, default is  .A .B\"\n    ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    exit 4\n end\n ccc = \"= noteline \"\"\"time('n') \"INVERT,\"\n \"line_before\" first ccc \"--------------------------------------\"\"\"\n \"line_before\" first ccc \"beginning of lines vertically inverted\"\"\"\n do LineNO = first to last\n     \"LINE_BEFORE\" lineNO \"= DATALINE LINE\" last\n     lastp1 = last + 1\n     \"DELETE\" lastp1\n end\n ccc = \"= noteline \"\"\"time('n') \"INVERT,\"\n \"line_after \" last  ccc \"-------------------------------------\"\"\"\n \"line_after \" last  ccc \"end      of lines vertically inverted\"\"\"\n IF LABA \\= \".ZF\" & LABA ^= \".ZFIRST\" THEN  \"LABEL &FIRST = &LABA. 0\"\n IF LABB \\= \".ZL\" & LABB ^= \".ZLAST\" THEN   \"LABEL &LAST  = &LABB. 0\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IOFIOF": {"ttr": 7445, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x14\\x00\\x14\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "MCRITCH"}, "text": "00010004  PROC 0 USERID() PREFIX() SORT(NULL)\n00011004   /*-------- STRAIGHT   ==> TSO IOF * SORT(NULL) ---- COMMAND FORMS\n00011104   /* SORT(NULL)   NO SORT, LEFT AS FOUND ON JOB QUEUE.\n00011204   /* G            GROUP ATTRIBUTES\n00011304   /* USERID | USERID PREFIX\n00011504   /*---------------------------------------------------------------\n00011605   /* ONCE IN IOF YOU CAN DISPLAY CARRIAGE CONTROL OR TURN OFF USING\n00011705   /*    DISPLAY CC     OR    DISPLAY NOCC\n00011805   /*---------------------------------------------------------------\n00011904   SET LP = &STR((\n00012004   SET RP = &STR())\n00012104   IF SYSLOG ^= &STR(&USERID) THEN -\n00012204        IF &STR(&USERID) ^= &STR() THEN SET USERID = USERID&LP.&STR(&USE\n00013004   IF &STR(&PREFIX) ^= &STR() THEN DO\n00013104     IF SYSLOG ^= &STR(&PREFIX) THEN -\n00013204        SET PREFIX = &STR(&PREFIX. PREFIX)\n00013304  END\n00014004  ELSE SET PREFIX = &STR(*)\n00020004 /*  IOF * SORT(NULL) &USERID &SYSLOG\n00030004     IOF &USERID &PREFIX SORT(&SORT) &SYSLOG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JCLBOX": {"ttr": 7447, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00D\\x00D\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "MCRITCH"}, "text": "/***********************************************************REXX******/\n/*  DRAW A BOX AROUND CLIST LINES (COMMENT THEM OUT)                 */\n/*  MODIFIED FROM CBT TAPE #9102 -- FILE095 MEMBER JCLBOX/CLISTBOX   */\n/* *******************************************************************/\n/*  USED CLIST WITH PENDING    ADD-LINES, WITH THE RESULT            */\n/*  THAT    ISPF SESSION ABENDED.   WAITING ON PENDING COMMANDS      */\n/*  IS A REQUIREMENT OF THIS CLIST -- APPEARS NOT TO RECUR           */\n/* *******************************************************************/\n/*  ADDED NOTELINES -- D.MCRITCHIE    1991/05/10, TO REXX 1993/06/11 */\n/* *******************************************************************/\n/*********************************************************************/\n   ADDRESS \"ISREDIT\";\"MACRO (HELP) NOPROCESS\"\n   IF HELP = \"?\" THEN DO\n      /*ADDRESS \"ISPEXEC DISPLAY PANEL(CLISTBOX)\"*/\n      CLIST CLISTBOX HELP\n      EXIT\n   END\n   STARS = SUBSTR('*',1,64,'*')\"*\"\n   \"PROCESS RANGE C\"\n   LCC = RC\n   \"(RCMD) = RANGE_CMD\"\n   IF RC = 4 | RCMD \\= \"C\" THEN DO\n      ZEDSMSG = \"NO RANGE SPECIFIED\"\n      ZEDLMSG = \"YOU MUST SPECIFY A RANGE OF LINES TO BE BOXED\",\n          \"USING A \"\"C<N>\"\" OR \"\"CC\"\"\"\n      ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ001)\"\n      EXIT 4\n   END\n   \"(FIRST) = LINENUM .ZFRANGE\"\n   \"(LAST) = LINENUM .ZLRANGE\"\n   \"(FR) = LINENUM .ZFRANGE\"\n   \"(LR) = LINENUM .ZLRANGE\"\n/*********************************************************************/\n/*    THIS IS A STARRY BOX CREATED BY THE CLISTBOX CLIST             */\n/*********************************************************************/\n   \"LINE_BEFORE .ZFRANGE = NOTELINE \"\"\"TIME() \"START OF\",\n      \"CLISTBOX -- LINES\" FR \"TO\" LR \"\"\"\"\n   \"LINE_AFTER         .ZLRANGE = NOTELINE \"\"\"TIME() \"-END OF-\",\n     \"CLISTBOX -- LINES\" FR \"TO\" LR \"\"\"\"\n    \"SEEK FIRST 66 72 .ZFRANGE .ZLRANGE P'^'\"\n    IF RC = 0 THEN \"LINE_AFTER .ZLRANGE\",\n       \"= NOTELINE \"\"\"TIME() \"---- INPUT AFTER COL 65 SUBJECT\",\n       \"TO LOSS USING JCLBOX\"\n  \"(LBO,RBO) = BOUNDS\"\n  \"BOUNDS 1 72\"\n\n  DO C = FR TO LR\n    \"SHIFT )\" C \"4\"\n  END\n  \"MASKLINE = \"\"//\"||\"*****\"STARS\"\"\"\"\n  \"LINE_BEFORE\" FIRST \"= MASKLINE\"\n\n  DO I = FR TO LR\n    \"LABEL\" I \"= .LJ\"\n    \"SEEK P'^' .LJ .LJ\" LBO  RBO \"FIRST\"\n    \"SEEK P'^' .LJ .LJ\" LBO  RBO \"LAST\"\n    \"CHANGE P'====' '//\"||\"* ' 1\"\n    \"CHANGE P'=' '*'      72\"\n    IF  I =  FR THEN \"LABEL\" I \"= .LJX\"\n  END\n\n  \"SEEK P'=' .LJX .LJX FIRST\"\n  \"MASKLINE = \"\"//\"||\"*****\"STARS\"\"\"\"\n  LAST =  LAST + 1\n  \"LINE_AFTER\" LAST \"= MASKLINE\"\n  \"MASKLINE = ' '\"\n  \"BOUNDS         \" LBO\",\"RBO\n  EXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JCLCHECK": {"ttr": 7682, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00.\\x00.\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "MCRITCH"}, "text": "WRITE USER = &SYSUID   DATE = &SYSDATE      TIME = &SYSTIME\nWRITE           ****************************************************\nWRITE           ******** OPERATIONS SUPPORT JCL CHECK CLIST ********\nWRITE           ****************************************************\nWRITE             THIS CLIST WILL CHECK A JOB FOR THE FOLLOWING:\nWRITE             CHECK FOR EXISTENCE OF:\nWRITE             COND=         TIME=          PARM=(BMP\nWRITE\nWRITE             NOTE..PARM=(BMP CHECKED TO ENSURE THAT\nWRITE                   JOB IS CLASS=B IF IT EXISTS.\nWRITE\nWRITE             CHECK FOR LACK OF:\nWRITE             PGM=DFSRRCOO  UNIT=TESTDISK  SYSOUT=V     SYS5\nWRITE             SPACE=(CYL    SPACE=(TRK     UNIT=VIO     SYSOUT=(A,,\nWRITE             SYSOUT=(B,,   SYSOUT=(D,,    SYSOUT=(E,,  SYSOUT=(F,,\nWRITE             SYSOUT=(H,,   SYSOUT=(H,,    SYSOUT=(I,,  DLIBATCH\nWRITE\nWRITE             NOTE..SYSOUT PARAMETERS MAY BE VALID FOR REMOTE SITES.\nWRITE                   SPACE=(TRK VALID FOR PGM=IEFBR14 TO DELETE FILE.\nWRITE\nWRITE             TO RESUME NORMAL DISPLAY OF JOB, RETURN CURSOR TO\nWRITE             COMMAND LINE AND ENTER RESET. PLEASE HIT ENTER.\nISREDIT MACRO\nISREDIT X ALL\nISREDIT F 'PGM=DFSRRCOO' ALL\nISREDIT F 'PARM=(DLI' ALL\nISREDIT F 'PARM=(BMP' ALL\nISREDIT F 'TIME=' ALL\nISREDIT F 'COND=' ALL\nISREDIT F 'SYS5' ALL\nISREDIT F 'UNIT=VIO' ALL\nISREDIT F 'UNIT=TESTDISK' ALL\nISREDIT F 'SYSOUT=V' ALL\nISREDIT F \"SYSOUT='V\" ALL\nISREDIT F 'SYSOUT=(A,,' ALL\nISREDIT F 'SYSOUT=(B,,' ALL\nISREDIT F 'SYSOUT=(D,,' ALL\nISREDIT F 'SYSOUT=(E,,' ALL\nISREDIT F 'SYSOUT=(F,,' ALL\nISREDIT F 'SYSOUT=(G,,' ALL\nISREDIT F 'SYSOUT=(H,,' ALL\nISREDIT F 'SYSOUT=(I,,' ALL\nISREDIT F 'SPACE=(CYL' ALL\nISREDIT F 'SPACE=(TRK' ALL\nISREDIT F 'DLIBATCH' ALL\nEXIT CODE(1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JOBCARD": {"ttr": 7684, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01\\x15\\x01\\x15\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 277, "newlines": 277, "modlines": 0, "user": "MCRITCH"}, "text": "/*JOBCARD -- CREATE A JOBCARD AND PLACE CURSOR AT JOB CLASS=  (REXX)..\n  DESCRIPTION: CREATE A JOBCARD AND PLACE CURSOR AT JOB CLASS=\n     **** EXAMPLE:  ==> JOBCARD        (DEFAULTS TO CLASS=S)\n                    ==> JOBCARD X\n     ==> JOBCARD REFRESH\n           (REDO--ACCT SHORTNAME LONGNAME ROOM DEST)\nPURPOSE: TO CREATE A JOBCARD WITH YOUR A CREATED JOBNAME,\n   ACCOUNTING INFORMATION, ALONG WITH YOUR NAME AND JOBCLASS.\n   THE CREATED JOBNAME IS BASED ON YOUR USERID AND MEMBERNAME.\n   THE JOBNAME WILL BE COMPOSED OF AS MANY CHARACTERS OF YOUR\n   USERID THAT YOU WISH TO USE, PLUS THE FIRST CHARACTER OF THE\n   MEMBERNAME, PLUS THE LAST CHARACTERS OF THE MEMBERNAME THAT\n   WILL FIT IN AN 8 CHARACTER JOBNAME.  IF YOUR USERID IS 4 OR\n   LESS CHARACTERS YOUR COMPLETE USERID WILL BE USED.\n******************************************************************\nMAINTENANCE HISTORY:\n MEMBER-- VV.MM CREATED-  ---MODIFIED---  CURR  INIT   MOD LASTUSE\n JOBCARD  01.08 1985/09/23 1993/10/12 18:11 242 199     0 IS03\n CONVERTED TO REXX 1993/10/12 DAVID MCRITCHIE  IS03\n  AND ADDED SUPPORT FOR MORE/LESS THAN 3-CHAR USERID PREFIX\n *********************************************************************/\nADDRESS \"ISREDIT\";\"MACRO (JCLASS REFRESH)\"\n/***** OBTAIN STORED PARAMETERS ****************************** */\n   ADDRESS \"ISPEXEC\",\n      \"VGET (JBXACCT,JBXROOM,JBXNAME,JBXNAMX,JBXDEST,JBXPREF)\"\n   SYSUID = SYSVAR('SYSUID')\n   JCLASS=TRANSLATE(JCLASS); REFRESH = UPPER REFRESH;\n   /*TYPE = \"TEST\" */\n   IF LENGTH(JBXACCT) = 4 THEN ,\n      \"LINE_BEFORE .ZF = NOTELINE\" ,\n       \"'TO CHANGE STORED %JOBCARD VARIABLES USE ==> %JOBCARD REFRESH'\"\n/*********************************************************************/\n/* **** OVERRIDE PARAMETERS FOR PERSONALIZED  JOBCARD CLIST ***      */\n/*    JBXDEST =     -- CREATES OUTPUT STMT., IF GIVEN A VALUE        */\n/*    JBXACCT = '0289'        -- YOUR FOUR DIGIT ACCOUNT CODE        */\n/*    JBXROOM = 'O179'        -- YOUR ROOM NUMBER                    */\n/*    JBXNAME = 'D.MCR'       -- YOUR NAME -- TRY TO LIMIT TO 7 CHAR.*/\n/*    JBXNAMX = 'DAVID MCRITCHIE'       -- FULL NAME                 */\n/*    JBXPREF = 4             -- FOR 4-CHAR SYSUID, NOT EVEN ASKED   */\n/* *  TO TEST AS IF A REGULAR 1ST TIME USER  ==> JOBCARD REFRESH     */\n/*********************************************************************/\n   INITIALS = '';  JBXCRD1B='';\n   IF JCLASS = \"REFRESH\" THEN DO\n      REFRESH = \"REFRESH\"\n      JCLASS = \"S\"\n   END\n   JBXPICN = SYSUID\n   IF REFRESH = \"REFRESH\" THEN DO\n      JBXACCT = '';\n      JBXPREF = '';\n      JBXROOM = '';\n      JBXNAME = '';\n      JBXNAMX = '';\n   END\n   IF  JBXACCT = '' THEN DO\n       SAY \"PLEASE SUPPLY YOUR 4-DIGIT\" ,\n         \"COST CENTER ACCOUNT NUMBER -- FOR JOBCARD GENERATION\"\n       PULL TACCT\n       JBXACCT =  TACCT\n       IF TYPE \\= \"TEST\" THEN\n       ADDRESS \"ISPEXEC\" \"VPUT (JBXACCT,TACCT) PROFILE\"\n       REFRESH = \"REFRESH\"\n   END\n   IF JBXROOM \\= '' THEN IF JBXPREF='' THEN DO\n      JBXPREF = 4;   /* FIX UP FOR PREEXISTING USAGE*/\n      ADDRESS \"ISPEXEC\" \"VPUT (JBXPREF) PROFILE\"\n   END\n   IF  JBXPREF = '' THEN DO\n       IF LENGTH(SYSUID) < 5 THEN JBXPREF = LENGTH(SYSUID)\n       ELSE DO\n          SAY \"IF YOU WISH TO USE MORE THAN THE FIRST FOUR\",\n            \"CHARACTERS OF YOUR USERID IN JOBNAME, SUPPLY NUMBER,\",\n            \" E.G. \" LENGTH(SYSUID)\n          PULL JBXPREF\n          IF JBXPREF='' | JBXPREF < 5 THEN JBXPREF = 4\n          IF JBXPREF > LENGTH(SYSUID) THEN DO\n              SAY 'DENIED REQUEST TO EXCEED LENGTH OF \"'SYSUID'\"'\n              JBXPREF=LENGTH(SYSUID)\n          END\n          IF TYPE \\= \"TEST\" THEN\n          ADDRESS \"ISPEXEC\" \"VPUT (JBXPREF) PROFILE\"\n          REFRESH = \"REFRESH\"\n       END\n   END\n   IF  JBXROOM = '' THEN DO\n       SAY \"PLEASE YOUR SUPPLY ROOM NUMBER FOR JOBCARD,\",\n           \" E.G.  OPA2  O179  BB22  CANA\"\n       PULL JBXROOM\n       IF TYPE \\= \"TEST\" THEN\n       ADDRESS \"ISPEXEC\" \"VPUT (JBXROOM) PROFILE\"\n       REFRESH = \"REFRESH\"\n   END\n   IF  JBXNAME  = '' THEN REDO1N: DO\n       SAY \"PLEASE SUPPLY YOUR NAME 1-11\" ,\n         \"CHARACTERS, PREFERABLY 1-7  E.G.   J.DOAKS  G.WASH\"\n       PULL JBXNAME JBXNAME2\n       IF  JBXNAME2 \\= '' THEN SIGNAL REDO1N\n       IF LENGTH(JBXNAME) > 11 THEN SIGNAL REDO1N\n       IF TYPE \\= \"TEST\" THEN\n       ADDRESS \"ISPEXEC\" \"VPUT (JBXNAME) PROFILE\"\n       REFRESH = \"REFRESH\"\n   END\n   IF  JBXNAMX  = '' THEN REDO2N: DO\n       SAY \"PLEASE SUPPLY YOUR FULL NAME\" ,\n          \"FOR JCL COMMENT NEAR   E.G.  GEORGE WASHINGTON\"\n       PULL JBXNAMX XNAM2 XNAM3\n       JBXNAMX =  JBXNAMX XNAM2 XNAM3\n       JBXNAMX = STRIP(JBXNAMX)\n       IF XNAM2 = ''   THEN SIGNAL REDO2N\n       IF TYPE \\= \"TEST\" THEN\n       ADDRESS \"ISPEXEC\" \"VPUT (JBXNAMX) PROFILE\"\n       REFRESH = \"REFRESH\"\n   END\n   IF REFRESH = \"REFRESH\" THEN DO\n    REDO1D: ,\n      SAY \"SUPPLY    DEST  FOR OUTPUT STATEMENT, HIT ENTER FOR DEFAULT\"\n      PULL JBXDEST\n      IF TYPE \\= \"TEST\" THEN\n      ADDRESS \"ISPEXEC\" \"VPUT (JBXDEST) PROFILE\"\n      SAY \"REFRESHED FOR\" SYSVAR('SYSUID') JBXNAMX ,\n         ||', ('JBXACCT','JBXROOM'),'JBXNAME', DEST='JBXDEST ,\n         ||', CHARS IN JOBNAME PREFIX='JBXPREF\n   END\n/*********************************************************************/\n/* ********* END OF MAKING GENERALIZED CLIST WORK                    */\n/* ************************************************************      */\n/* //&JBXNAME.XXXX JOB (&JBXACCT, ...                                */\n/*   =========          ========  ...                                */\n/*                     &JBXROOM),'&JBXNAME &MEMBER',CLASS=&JBXCLSS   */\n/*                     =========  ========                =========  */\n/* JBXPICN - YOUR PIC# ASSIGNED BY RACF ADMINISTRATOR AS YOUR TSO ID */\n/* JBXNAME - PROGRAMMER NAME ON THE JOB CARD                         */\n/*     SINCE PROGRAMMER NAME IS 20 POSITIONS IN JCL AND AND SINCE    */\n/*     THIS CLIST WILL BE PUTTING  IN THE MEMBERNAME (LOSE 9 CHARS), */\n/*     THE NAME YOU USE SHOULD BE <= 11 CHARACTERS                   */\n/*     TRY LIMITING TO 7 CHAR OR LESS FOR BEST RESULTS               */\n/* JBXACCT AND JBXROOM                                               */\n/*       YOUR FOUR DIGIT COST CENTER (ACCOUNT CODE)   E.G. 0282      */\n/*       YOUR ROOM NUMBER                             E.G. OPA2      */\n/*                                                                   */\n/* USER CONTACT: CREATED BY DAVID MCRITCHIE  \"THE REXX MACROS TOOLBOX\" */\n/* MANUALS: THE FOLLOWING MANUALS ARE LISTED ON-SITE 1993/10/13\n  23.040 -- SC34-4253   ISPF/PDF EDIT AND EDIT MACROS V3 R5\n  23.100 -- SC34-4258   ISPF/PDF GUIDE V3 R5\n  25.350 -- GC28-1869   TSO EXTENSIONS V2 GENERAL INFORMATION\n  25.350 -- SC28-1876   TSO EXTENSIONS V2 CLISTS\n  25.350 -- SC28-1880   TSO EXTENSIONS V2 USER'S GUIDE\n  23.370 -- GC28-1829   JCL REFERENCE\n  23.380 -- GC28 1830   JCL GUIDE\n  43.740 -- SC28-1882   TSO EXTENSIONS V2: REXX USER'S GUIDE\n  43.740 -- SC28-1883   TSO EXTENSIONS V2: REXX REFERENCE\n  DOCUMENTATION:  IS03.SHARE.TEXT(JOBCARD)\n***************************************************************/\n/*********************************************************************/\n BYPASS: ,\n   IF  JCLASS  = \" \" THEN JCLASS = \"S\"        /* DEFAULT JOB CLASS */\n   JCLASS = TRANSLATE(JCLASS)\n   JBXPICN = SUBSTR(SYSUID,1,JBXPREF)\n   JBXPICN = STRIP(JBXPICN)\n   JBXNAMX = SUBSTR(JBXNAMX,1,20)\n   \"(MEMNAME) = MEMBER\"\n   \" (DSNAME) = DATASET\"\n   WHOLEDSN=DSNAME'('STRIP(MEMNAME)')';\n   IF MEMNAME = \"JOBCARD\" THEN DO\n           ZEDSMSG = 'JOBCARD NOT PERMITTED'\n           ZEDLMSG = ,\n            'DO NOT USE JOBCARD CLIST ON A MEMBER NAMED JOBCARD'\n          ADDRESS \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n          RETURN 24       /* NOT ACCEPTABLE  WILL MESS UP CLIST */\n   END\n   \"(VAR037) = LINENUM .ZLAST\"\n   IF  VAR037 = 000000 THEN DO\n       ZEDSMSG = 'EMPTY FILE'\n       ZEDLMSG = ,\n        'ZEDSMSG. TRY AGAIN LATER WHEN YOU HAVE' ,\n          'SOMETHING TO PLACE JOBCARD IN FRONT OF'\n      ADDRESS \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n      RETURN 4\n   END\n   JCLDATE = DATE('O')\n   JCLTIME = TIME('N')\n   JCLUSER = SYSUID   /* SYSVAR('SYSUID') */\n   IF MEMNAME = '' THEN DO; /* PROVIDE FOR NON-PDS DATASET*/\n      I = LASTPOS('.',DSNAME)\n      IF I = 0 THEN MEMNAME = '########';\n      ELSE MEMNAME = SUBSTR(DSNAME,I+1,8)\n      WHOLEDSN=DSNAME\n   END;\n   MEMNAME8 = SUBSTR(MEMNAME,1,8)\n   L=LENGTH(STRIP(MEMNAME)); L2=L+JBXPREF; USE = 8 - JBXPREF - 1\n   IF L2 <= 8 THEN JOBNAME=SUBSTR(SYSUID,1,JBXPREF)||MEMNAME;\n   ELSE JOBNAME = SUBSTR(SYSUID,1,JBXPREF)||SUBSTR(MEMNAME,1,1),\n          || RIGHT(STRIP(MEMNAME),USE);\n   JOBNAME = SUBSTR(JOBNAME,1,8)\n   \"FIND .ZFIRST .ZFIRST 11 ' JOB '\"\n   IF RC \\= 0 THEN DO\n      \"(DSNAME) = DATASET\"\n      JBXCARD1 ,\n         = '//'JOBNAME' JOB ('JBXACCT','JBXROOM'),''',\n           ||JBXNAME MEMNAME||''',CLASS='JCLASS',NOTIFY='SYSUID\n      JBXCARD2 ,\n         = '//'||'****' MEMNAME8,\n                SUBSTR(SYSUID,1,7)'   'SUBSTR(JBXNAMX,1,20)||,\n                SUBSTR(DATE('S'),1,2)||DATE('O') SUBSTR(TIME('N'),1,5)\n      IF LENGTH(WHOLEDSN) <= 34 THEN\n         JBXCARD3 = '//'||'**** JCL' SUBSTR(WHOLEDSN,1,34),\n             SUBSTR(DATE('S'),1,2)DATE('O') SUBSTR(TIME('N'),1,5)\n      ELSE JBXCARD3 = '//'||'**** JCL' WHOLEDSN,\n            SUBSTR(DATE('S'),1,2)DATE('O')\n      IF LENGTH(JBXCARD1) > 70 THEN DO\n         JBXCARD1 = '//                 NOTIFY='SYSUID\n         JBXCRD1B ,\n            = '//'SUBSTR(JOBNAME,1,8)' JOB  ('JBXACCT','JBXROOM'),',\n              ''''JBXNAME MEMNAME''',CLASS='JCLASS')'\n      END\n      /*********** PUT OUT THE JOBCARD(S) CREATED *********/\n      \"LINE_AFTER 0 = (JBXCARD1)\"\n      \"LINE_AFTER 1 = (JBXCARD2)\"\n      \"LINE_AFTER 2 = (JBXCARD3)\"\n      IF JBXDEST \\= '' THEN \"LINE_AFTER 3 =\",\n        \"'//DEFAULT OUTPUT DEST=\"JBXDEST\",DEFAULT=YES,JESDS=ALL'\"\n      IF  JBXCRD1B    \\= '' THEN DO\n         JBXCARD1 = '//                 NOTIFY='SYSUID\n         \"LINE_AFTER 0 = (JBXCRD1B)\"\n      END\n      /**************** END OF JOBCARD(S) CREATION ********/\n   END\n   ELSE DO\n      SAY \"YOU TRICKY DEVIL YOU ALREADY HAVE A JOBCARD\"\n      SAY \"NO FIXUP OF SYSUID, SYSTIME OR SYSDATE WILL BE PERFORMED\"\n      RETURN 12\n   END\n   /* --- &SYSTIME. AND/OR &SYSDATE. SUBSTITUTIONS WILL BE MADE*/\n   \"SEEK   ALL '&&&&SYSUID.'\"\n   \"(SEEK1) = SEEK_COUNTS\"; SEEK1 = SEEK1 + 0\n   \"LINE_BEFORE 4 = MSGLINE \"\"JOBCARD ALSO WILL CHANGE\",\n         \"&SEEK1. OCCURRENCES BELOW OF &&&&SYSUID. TO &SYSUID.\"\"\"\n   \"CHANGE FIRST '&&&&SYSUID.' \"\"\"SYSUID\"\"\"\"\n   DO I = 1 TO SEEK1\n     \"LINE_AFTER .ZCSR = NOTELINE \"\"JOBCARD CHANGED ABOVE (&I.\",\n         \"OF &SEEK1.) OCCURENCE OF   &&&&SYSUID. TO &SYSUID.\"\"\"\n     \"CHANGE NEXT  '&&&&SYSUID.' \"\"\"SYSUID\"\"\"\"\n   END;\n   X5 = SUBSTR(TIME('N'),1,5)\n   \"CHANGE ALL '&&&&SYSTIME.' '\"X5\"'\"\n   \"(CHGT1,CHGT2) = CHANGE_COUNTS\"; CHGT1=CHGT1+0\n   IF CHGT1 \\= 0 THEN\n     \"LINE_BEFORE 4 = MSGLINE \"\"JOBCARD ALSO CHANGED\",\n         \"&CHGT1. OCCURRENCES BELOW OF &&&&SYSTIME. TO &X5.\"\"\"\n   X5 = DATE('O')\n   \"CHANGE ALL '&&&&SYSDATE.' '\"X5\"'\"\n   \"(CHGD1,CHGD2) = CHANGE_COUNTS\"; CHGD1=CHGD1+0\n   IF CHGD1 \\= 0 THEN\n     \"LINE_BEFORE 4 = MSGLINE \"\"JOBCARD ALSO\",\n         \"CHANGED &CHGD1. OCCURRENCES BELOW OF &&&&SYSDATE. TO &X5.\"\"\"\n   MODIFIED = CHGD1+CHGD2+CHGT1+CHGT2\n   IF MODIFIED \\= 0 THEN IF SUBSTR(MEMNAME,1,1) \\= 'Z'\n      /* PREVENT SAVING UNLESS MEMBER BEGINS WITH Z OR NOT IS03. */\n      THEN IF SUBSTR(DSNAME,1,5) = 'IS03.' THEN DO\n         I = POS('.SHARE.',DSNAME) /* PREVENT ACCIDENTALLY SAVING*/\n         IF I \\= 0 THEN DO\n            \"LINE_BEFORE 4 = MSGLINE\",\n              \"\"\"AUTOSAVE OFF -- TO PREVENT ACCIDENTAL SAVING\"\"\"\n            \"AUTOSAVE OFF\"\n         END\n      END\n   /* RELOCATE TO CURSOR TO*/\n   /*    POINT TO THE JOB CLASS (MIGHT FIND MSGCLASS INSTEAD) */\n   \"LOC 0\"\n   \"FIND FIRST \"\"CLASS=\"\"\"\n   \"(CUR1L,CUR1P) = CURSOR\"\n   CUR1P =  CUR1P + 6\n   \"CURSOR =\" CUR1L CUR1P\n   ZEDSMSG = 'JOBCARD CREATED'\n   ZEDLMSG = 'YOUR DEFAULTS CAN BE CHANGED USING ===> JOBCARD REFRESH'\n   ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   /* \"!EDCHEK\" */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KILL": {"ttr": 7689, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00j\\x00j\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 106, "newlines": 106, "modlines": 0, "user": "MCRITCH"}, "text": "   /* REXX -- converted to REXX on 1994/06/03 ------------------*/\n   ADDRESS \"ISREDIT\"\n   /*KILL      Author: David McRitchie, created 1985/12/31 IS03 */\n   /*          at \"The REXX Macros Toolbox\", DMcRitchie@aol.com    */\n   /*          Updated 1991/11/08 11:39 IS03                    */\n   /* KILL  DELETES INDICATED MEMBER FROM THE PDS BEING EDITED  */\n   /*   can delete same member as currently under edit, in which*/\n   /*   case you should terminate the currrent edit with CANCEL */\n   /*   to prevent saving member if CHANGED flag is on.         */\n   /* created by David McRitchie, 1985/12/30 phone              */\n   /* ==========================================================*/\n   /* defect notice:   discovered 1987/04/17                    */\n   /*   Can find no way of determining whether user came into   */\n   /*   ISPF EDIT using the cataloged version or specified a vol*/\n   /*   ser.   In any case passing a DATAID apparently does not */\n   /*   include the volume.  If a member does not exist in the  */\n   /*   cataloged version, but does exist in the one being viewed*/\n   /*   -- clist will FAIL since member not found.   Likewise   */\n   /*   this clist will delete a member by the same dsname as   */\n   /*   specified from the cataloged version which could be more*/\n   /*   serious.                                                */\n   /* cautions:                                                 */\n   /*   The reason the member must be specified is to reduce the*/\n   /*   risk of a mass slaughter by inadvertent IMACRO usage.   */\n   /* problem:                                                  */\n   /*   ISPF EDIT does not use it-s own library services to pass*/\n   /*   the volume id to the DATAID.                            */\n  /*mini-version: ================================================ */\n  /* \"MACRO (KILLMEMB)\"         ---- MEMBER to delete              */\n  /*  \"(DSN) = DATASET\"         ---- obtain dsname w/o quotes      */\n  /*  Address \"ISPEXEC\"  --- for following ISPEXEC commands        */\n  /*     \"LMINIT DATAID(DKILL) DDNAME(&DKILLD) ENQ(SHRW)\"          */\n  /*     \"LMOPEN DATAID(&DKILL) OPTION(OUTPUT) ORG(POCHK) -- Open\" */\n  /*     \"LMMDEL DATAID(&DKILL) MEMBER(&KILLMEMB) -- kill member\"  */\n  /*     \"LMCLOSE DATAID(&DKILL)  ---- Close dataid             \"  */\n  /*     \"LMFREE DATAID(&DKILL) --free dataid assigned by LMINIT\"  */\n  /* ============================================================= */\n   \"MACRO (KILLMEMB)\"          /* MEMBER to delete         */\n   KILLMEMB = translate(KILLMEMB)   /* capitalized parameter*/\n   /*................ (#VER) ............*/\n   parse version v1 v2 v3\n   if v1 = \"REXX370\" then Nop;\n   else do; say \"kill is only for TSO,  sorry\"; exit 12; end\n   /* ...................................*/\n   \"(DSN) = DATASET\"\n   \"(DKILLD)  = DATAID\"            /* obtain dataid  */\n   Address \"ISPEXEC\" /* -- default there are no ISREDIT instruct.*/\n   IF KILLMEMB = \"\" THEN  DO\n      ZEDSMSG = \"MISSING\"  MEMBER\n      ZEDLMSG= \"MEMBERNAME to be deleted from\" DSN \"was NOT SPECIFIED\"\n      \"SETMSG MSG(ISRZ001)\"\n      address \"TSO\" \"CLS\"\n      error = \"ERROR -- ERROR --\"\n      SAY  ERROR \"FROM ATTEMPT TO INVOKE  THE \"\"KILL\"\" MACRO\"\n      SAY  ERROR \"MEMBERNAME TO BE DELETED\" ,\n           \"FROM\" DSN \"WAS NOT SPECIFIED\"\n      SAY  ERROR \"MEMBERNAME TO BE DELETED\",\n           \"FROM\" DSN \"WAS NOT SPECIFIED\"\n      Exit 0\n   END\n\n   \"LMINIT DATAID(DKILL) DATASET('&DSN.') ENQ(SHRW)\"\n   rcx = RC\n   IF rcx  \\= 0 THEN  DO\n      address \"TSO\" \"CLS\"\n      SAY \"Address \"\"ISPEXEC\"\" \"\"LMINIT DATAID(DKILL)\",\n           \"DATASET('\"DSN\"') ENQ(SHRW)\"\n      SAY \"KILL -- LMINIT DATAID not assigned  rcx=\"rcx\n      Exit rcx\n   END\n   \"LMOPEN DATAID(&DKILL) OPTION(OUTPUT) ORG(POCHK)\"\n   /* Open dataid for output (line above) */\n   LMRC = RC\n   IF LMRC \\= 0 THEN    signal CLOSEX\n   IF POCHK \\= \"PO\" THEN  signal CLOSEX\n   IF LMRC = 0 THEN    DO\n      \"LMMDEL DATAID(&DKILL) MEMBER(&KILLMEMB) /* kill member */\"\n      LRC = RC\n      IF LRC = 0 THEN    DO\n         ZEDSMSG = KILLMEMB  \"deleted\"\n         ZEDLMSG = KILLMEMB  \"deleted from\" dsn,\n              \"per your request via \"\"KILL\" KILLMEMB\"\"\"\"\n         \"SETMSG MSG(ISRZ000)\"\n         SAY \"       COMPLETED OK --  DELETED MEMBER \" KILLMEMB,\n              \"FROM\" DSN \"PER YOUR REQUEST VIA \"\"KILL\" KILLMEMB\"\"\"\"\n      END\n      IF LRC = 8 THEN  DO\n         ZEDSMSG = KILLMEMB  \"NOT FOUND\"\n         ZEDLMSG = KILLMEMB  \"NOT FOUND, REQUEST,\",\n              \"NOT COMPLETED, for \"\"KILL\" KILLMEMB\n         \"SETMSG MSG(ISRZ000)\"\n         SAY \"         \"KILLMEMB\" NOT FOUND IN \"DSN\",\" ,\n             \"REQUEST NOT COMPLETED, PER \"\"KILL\" KILLMEMB\"\"\"\"\n      END\n      IF lrc > 0 then do\n         ZEDSMSG = ZERRSM\n         ZEDLMSG = ZERRMSG strip(ZERRLM)\", rc=\"lrc\n         \"SETMSG MSG(ISRZ001)\"\n         SAY \"KILL\" killmemb \"-- via LMMDEL failed RC=\"lrc\", because\"\n         SAY \"     \"zerrmsg strip(zerrlm)\", rc=\"lrc\n      END\n   END                             /* return next member name */\n CLOSEX:\n   \"LMCLOSE DATAID(&DKILL)         /*   Close dataid      */\"\n   \"LMFREE DATAID(&DKILL)          /*finished with LMINIT assigned */\"\n   Exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LABNX": {"ttr": 7692, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x9d\\x00\\x9d\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 157, "newlines": 157, "modlines": 0, "user": "MCRITCH"}, "text": "/*REXX ***************************************************************\n        LABNX       AUTHOR: DAVID MCRITCHIE, CREATED 1987/11/12 IS03\n                    \"THE REXX MACROS TOOLBOX\"\n                    UPDATED 1988/06/01 10:46 IS03\n                    CONVERTED TO REXX 1993/05/21 18:23 IS03\n  ********************************************************************\n        TITLE:   LABNX, LABELS THE INCLUSIVE LINES BETWEEN TWO LABELS\n        USERS:   TSO ISPF EDIT USERS, SPF/PC EDIT USERS, SCRIPT/DCF\n        CONTRIBUTED: 1987/02/19 DAVID MCRITCHIE\n\n        EXAMPLE:     LABNX    .ZFIRST .ZLAST NX\n\n        OPTIONS: (ALL PARAMETERS ARE OPTIONAL)\n            NX           PROCESS ONLY NON-EXCLUDED LINES (DEFAULT)\n            X            PROCESS ONLY EXCLUDED LINES\n            LPTR-RANGE   LINE POINTER RANGE CONSISTS OF TWO POINTERS\n            CC-RANGE     ALTERNATE RANGE UTILIZING CC LINE COMMANDS\n            LAB(RT)      LABEL WILL BEGIN .RTAAA INSTEAD OF .LABAA\n            LAB(1)       LABEL WILL BEGIN .AAAAA INSTEAD OF .LABAA\n            NOPROCESS    AVOID PROCESS COMMAND -- USED BY ANOTHER CLIST\n\n        REQUIREMENTS:  (NONE)\n            WILL DEFAULT TO PROCESSING ALL NX LINES.\n\n        RELATED ISPF USAGE\n            RESET LABEL,  LOC LABEL (NEXT)\n        RELATED CLISTS/EXECUTES\n            NXNX WILL REDISPLAY ALL LABELED LINES IN RANGE\n\n  THIS MACRO IS UNIVERSALLY AVAILABLE WITH THE STIPULATION THAT THAT\n  THE ORIGINAL AUTHOR (DAVID MCRITCHIE) REMAINS CREDITED AND THAT NO\n  CHARGE OR LICENSING FEE ACCRUES TO ANY PARTY.\n\n  DOCUMENTED:  IS03.SHARE.TEXT(LABNX)\n  ON-LINE VIEWING  ===> TSO CLIST LABNX HELP\n  FORMATTED FOR SCREEN IN IS03.CLISTHLP.HELP(LABNX)\n  ================================================================  **/\n\n ADDRESS 'ISREDIT'; 'MACRO (PARMS) NOPROCESS';\n NUMERIC DIGITS 10\n NOTE = 'LINE_BEFORE .ZFIRST = NOTELINE '\n NOPROCESS=0\n AFTER=0; BEFORE=0; CHANGE='';CHG=''; ERR=''; ERROR=''; LAB='';\n LABF=''; LABL=''; REMAINDER=''; ZEDLMSG='' ZEDSMSG='';\n TOP=1; CNT = 5027411 /*AS IN .LABAA */; NX=\"NX\"\n ALPHA='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n /* COLLECT PARAMETERS */\nPARMS = TRANSLATE(PARMS)\n DO III = 1 TO 10;\n   TOKEN = WORD(PARMS,III)\n   IF TOKEN = '' THEN LEAVE\n   TOKENX = TRANSLATE(TOKEN);\n   IF TOKEN = \"X\" |  TOKEN = \"NX\" THEN DO\n      NX = TOKEN\n      ITERATE III\n   END;\n   IF SUBSTR(TOKEN,1,1) = '.' THEN DO\n      IF LABF = '' THEN LABF = TOKEN\n      ELSE IF LABL = '' THEN LABL = TOKEN\n      ELSE DO\n            ZEDSMSG = '.LABEL RC=8'\n            ZEDLMSG = 'TOO MANY LABELS --' LABF LABL TOKEN\n            ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            EXIT 8\n      END\n      ITERATE III\n   END\n   IF TOKEN = \"NOPROCESS\" THEN DO; NOPROCESS = 1; ITERATE III ;END\n   IF SUBSTR(TOKEN,1,4) = 'LAB(' THEN DO\n      PARSE VAR TOKEN \"LAB(\" LABCNX \")\"\n      LABCNT = LEFT(LABCNX||\"AAAAA\",5)\n      IF SUBSTR(LABCNT,1,1) = 'Z' THEN LABCNT = LEFT(\"X\"||LABCNT,5)\n      LABCNT=STRIP(LABCNT)\n      IF DATATYPE(LABCNT,\"U\") = 1  THEN DO\n         MULT = 1; HOLD = 0;\n         DO I = LENGTH(LABCNT) TO 1 BY -1\n            X = SUBSTR(LABCNT,I,1)\n            J = POS(X,ALPHA) - 1\n            HOLD = HOLD + MULT * J\n            MULT = MULT * 26\n         END;\n         CNT = HOLD - 1;\n      END\n      ELSE DO\n         ZEDSMSG = \"LAB() INVALID\"\n         ZEDLMSG = 'MUST BE ALPHABETIC BETWEEN A AND YZZZZ'\n         ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n         EXIT 4\n      END\n      ITERATE III\n   END\n\n   REMAINDER = REMAINDER TOKEN\n END III\n\n IF REMAINDER <> \"\" THEN DO\n    ZEDSMSG =  REMAINDER\n    ZEDLMSG =  REMAINDER \"-- PARAMETERS UNKNOWN TO LABNX\"\n    ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    EXIT 8\n END\n\nIF LABL = '' THEN DO\n IF NOPROCESS = 0 THEN DO  /* LOOKS LIKE A DOUBLE NEGATIVE*/\n   \"PROCESS RANGE C\"\n   IF RC = 0 THEN DO\n      \"LABEL .ZFRANGE = .LABF 1\"\n      \"LABEL .ZLRANGE = .LABL 1\"\n      LABF = \".LABF\"\n      LABL = \".LABL\"\n   END\n END\nEND\nIF LABL = '' THEN DO; LABF='.ZFIRST'; LABL='.ZLAST'; END;\n\"(LABFNO) = LINENUM\" LABF\n\"(LABLNO) = LINENUM\" LABL\nLINENO = LABFNO - 1\n\n/* --- BEGIN CODE SPECIFIC TO LABNX ------------------------ */\n\n   \"(TOP) = DISPLAY_LINES\"; IF TOP > 0 THEN TOP = TOP - 1\n   LABFNO = LABFNO + 0; LABLNO = LABLNO + 0\nNEXT:\n   LINENO = LINENO + 1\n   IF LINENO > LABLNO THEN DO\n      ZEDSMSG = 'COMPLETED'\n      ZEDLMSG = \"LABNX\" PARMS \"-- COMPLETED\"\n      ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      IF TOP = 0 THEN \"LOC 0\"\n      ELSE DO\n         \"(XVAR) = XSTATUS\" TOP\n         RCX = RC\n         \"LOC\" TOP  /* WHERE WE BEGAN BUT UP ONE LINE */\n         \"XSTATUS\" TOP \"=\" XVAR\n      END\n      EXIT 1\n   END\n   \"(XSTATUS) = XSTATUS\" LINENO\n   IF XSTATUS \\= NX THEN SIGNAL NEXT /* NX (LINES BY DEFAULT) */\n HIGHER:\n   \"(LABEL,DEPTH) = LABEL\" LINENO\n  /* \"LINE_AFTER\" LINENO \"= NOTELINE \"\"\"LABEL DEPTH\"\"\"\"*/\n   IF LABEL /= \"\" THEN SIGNAL NEXT\n   CNT = CNT + 1\n   R = CNT;CODE=''; PASS=0\n   DO WHILE (R > 0)\n        RR = R//26 + 1\n        R  = R%26\n        CODE = SUBSTR(ALPHA,RR,1) || CODE\n   END\n   CODE = '.'||RIGHT('AAAAAAA'CODE,5)\n   \"(VAR1) = LINENUM\" CODE\n   IF RC = 0 THEN SIGNAL HIGHER\n   \"LABEL\" LINENO \"= \" CODE 0\n   SIGNAL NEXT\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LCFIX": {"ttr": 7937, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00$\\x00$\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "MCRITCH"}, "text": "/*REXX -- Lower-case fix for lastnames, titles, etc. */\n Address \"ISREDIT\";\"MACRO\"\n /* Created by  F. David McRitchie, \"The REXX Macros Toolbox\", 1988/10/14 */\n /* Content of LCFIX is by David McRitchie and subject to change    */\n /* without notice.  LCFIX is an example and the content should be   */\n /* incorporated as desired within a more comprehensive macro for    */\n /* specific usage.                                                  */\n/*********************************************************************/\n/* \"CONTROL ASIS\"                                                    */\n/*********************************************************************/\n \"CAPS OFF\"\n /* Prior changes may have been something like this */\n /*  c all p'@' p'<'    -- change all letters to lowercase */\n /*  c all p'@' prefix p'>' -- change 1st letter to uppercase */\n\n /* see also is03.libr.clist(users1) for specific column changes*/\n \"C ALL NX 'II'  WORD 'II'\"\n \"C ALL NX 'III' WORD 'III'\"\n \"C ALL NX 'IV'  WORD 'IV'\"\n \"C ALL NX 'II'  WORD 'II'\"\n\n /* ------------- lastname fixup, activate the following ------*/\n /* \"C ALL NX prefix p'Mac<<<' p'Mac><<'\"  */\n /* \"C ALL NX prefix c'MAC' c'Mac'\"        */\n /* \"C ALL NX prefix p'Mc<<<' p'Mc><<'\"    */\n /* \"C ALL NX prefix c'Mc' c'Mc'\"          */\n\n /* ------ fixup for some job titles -----------------*/\n \"C ALL NX word c'SYSTEMS PROGRAMM' 'SYSTEMS PROGRAMMER'\"\n \"C ALL NX word c'Systems Programm' 'Systems Programmer'\"\n \"C ALL NX word C'PROGRAMMER/ANALY' 'PROGRAMMER/ANALYST'\"\n \"C ALL NX word c'Programmer/analy' 'Programmer/Analyst'\"\n \"C ALL NX word c'SYSTEMS PROGR'    'SYSTEMS PROGRAMMER'\"\n \"C ALL NX word c'Systems Progr'    'Systems Programmer'\"\n \"C ALL NX word c'PROGRAMMER/AN'    'PROGRAMMER/ANALYST'\"\n \"C ALL NX word c'Programmer/An'    'Programmer/Analyst'\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LEFT@": {"ttr": 7939, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00;\\x00;\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 59, "newlines": 59, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- LEFT JUSTIFY all lines within C or CC range */\n/* author: David McRitchie, \"The REXX Macros Toolbox\", 1992/04/30 */\n/*  (default)   left justify each line to first non blank (p'^')   */\n/*         NB   left justify each line to first non blank (p'^')   */\n/*          Q   left justify each line to first single quote (\"'\") */\n/*         QQ   left justify each line to first double quote ('\"') */\n/*     string   left justify to any character or string            */\n/* words must be capitalized   C ISPEXEC ISREDIT NOPROCESS PROCESS */\n/* capitalized for comparison  NB Q QQ                             */\n/* on SPF/PC  1) change ^ to \u00c1,  2) comment CONTROL ERRORS lines,  */\n/*            3) remove ADDRESS from MSG(  lines  and capitalize   */\naddress \"ISREDIT\"\n\"macro NOPROCESS (token)\"\ntoken = translate(token)   /* convert to uppercase for comparisons */\nif token = \"\" then token = \"NB\"  /* set default if missing */\naddress \"ISPEXEC\" \"control errors return\"  /* comment out in SPF/PC */\n\"PROCESS range C\"\nif rc < 8 then do /* bug in SPF/PC use  <= 8 in spf/pc, < 8 on tso*/\n   labf = \".zfrange\"\n   labl = \".zlrange\"\nend\nelse do\n  zedsmsg = zerrsm  /* use dialog generated messages */\n  zedlmsg = zerrlm\n  address   \"ISPEXEC\" \"setmsg msg(isrz000)\"\n  return 1  /* move cursor to command line */\nend\naddress \"ISPEXEC\" \"control errors cancel\"  /* comment out in SPF/PC */\n\"(bound1,bound2) = bounds\"\nif bound1 \\= 1 then do\n  zedsmsg = \"BOUNDS error\"\n  zedlmsg = \"use of bounds not permitted, found BOUND\" bound1 bound2\n  address   \"ISPEXEC\" \"setmsg msg(isrz000)\"\n  return 12\nend\n\nif token = \"Q\" then findtok = \"\"\"'\"\"\"\nelse if token = \"QQ\" then findtok = '''\"'''\nelse if token = \"NB\" then findtok = \"p'^'\"\nelse do\n     findtok = ''''token''''\n     i = pos('''',token)\n     if i \\= 0 then findtok = token\nend\nzedlmsg = \"left@\" findtok \" ------ issued or defaulted\"\naddress   \"ISPEXEC\" \"setmsg msg(isrz000)\"\n\"find first nx  \"findtok\" .zfrange .zlrange\"\nif rc \\= 0 then return 1\nmore: \"(row,col) = cursor\"\nif col > 1 then do\n   \"(line) = line .zcsr\"\n    line  = substr(line,col)\n   \"line .zcsr = (line)\"\nend\n\"cursor =\"  row  \"1\"\n\"find last p'^' .zcsr .zcsr\"\n\"find next  nx\"  findtok  \".zfrange .zlrange\"\nif rc \\= 0 then return 1\nsignal more\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTDD": {"ttr": 7941, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00*\\x00*\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "MCRITCH"}, "text": "/*REXX functional  replacement for most of the  ddname clist */\n/*  Example -- COMMAND ===> TSO LISTDD                                    */\n/*  Example -- COMMAND ===> TSO LISTDD ISPPLIB                            */\n/* From an article in Chicago Soft Ltd -- \"TSO TIMES\" Vol. 2 No. 1        */\n/*   by Terry Beadle, President, The Productivity Group                   */\n/*   minor modification at     to have ddname as an argument              */\n/* Includes a correction by Bruce Christopher and Jeff Todd in  Issue #3  */\nArg ddnameS         /* lines with ddname and ddnameX added 1991/10/21     */\nddnameS = translate(\" \"ddnameS\"          \")\n@tcb = Storage(21C,4)                     /* get TCB address from PSAAOLD */\n@tiot = Storage(D2X(C2D(@tcb)+12),4)      /* add 12 to get TIOT address   */\n@1stdd = D2X(C2D(@tiot)+28)               /* point at 1st DD in TIOT      */\n@1stddlen = Storage(D2X(C2D(@tiot)+24),1)  /* get its length              */\n@tiot = D2X(C2D(@tiot)+24)                /* point at 1st TIOT ddname     */\n@jfcb = Storage(D2X(X2D(@tiot)+12),3)     /* get JFCB address from TIOT   */\nSay ' ddname  VOLSER  DATA SET NAME'\nSay '------------------------------------------------------------'\nDo while C2D(@1stddlen) \\= 0              /* loop through entire TIOT     */\n If Storage(@1stdd,1) /= '00'X Then Do\n  If Storage(@1stdd,8) /= '' Then ddnameX = Storage(@1stdd,8)       /*   */\n  j = index(ddnameS,ddnamex);\n  if j/=0 Then ddname=ddnameX\n  If ddnameS= '' | ddname = ddnameX Then                            /*   */\n  Say Storage(@1stdd,8),                  /* display ddname               */\n      Storage(D2X(C2D(@jfcb)+134),6),     /* display VOLSER               */\n      Storage(D2X(C2D(@jfcb)+16),44)      /* display DSNAME               */\n End\n  @tiot = D2X(X2D(@tiot)+C2D(@1stddlen))  /* point to next TIOT entry     */\n  @1stddlen = Storage(@tiot,1)            /* get length of tiot entry     */\n  @1stdd = D2X(X2D(@tiot)+4)              /* point to ddname in TIOT      */\n  @jfcb = Storage(D2X(X2D(@tiot)+12),3)   /* get next JFCB address        */\nEnd\n/* LIBRARY CONCATENATIONS ------------------------------------------------*/\n/*   SYSPROC:   CLIST LIBRARIES                                           */\n/* LIBRARY CONCATENATIONS USED BY ISPF -----------------------------------*/\n/*   ISPPLIB:   PANEL DEFINITIONS                                         */\n/*   ISPMLIB:   MESSAGE DEFINITIONS  NEW MESSAGES HAVE ISP PREFIX         */\n/*   ISPSLIB:   SKELETON DEFINITIONS.   EDIT MODELS (NAMED ISRE....)      */\n/*              AND FILE SKELETONS USED BY BATCH PROCESSING (OPTION 5)    */\n/*   ISPTLIB:   TABLE INPUT LIBRARY                                       */\n/*   ISPPROF:   STORED PROFILE FOR EACH USER, INital profiles             */\n/*              ORIGINATE FROM ISPTLIB.                                   */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTRP": {"ttr": 7943, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01\\xee\\x01\\xee\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 494, "newlines": 494, "modlines": 0, "user": "MCRITCH"}, "text": "PROC 0 DISPLAY DATASET() PREFIX(&SYSUID) Q() L() E() +\n       IGNORE() TERSE\nCONTROL MAIN ASIS\n/**************************************************************/\n/* Note -- have reworked code to add the following options    */\n/*     Q(), E(), L(), IGNORE(), and TERSE.   D.McRitchie      */\n/*     allowing anyone to use this clist in a normal fashion. */\n/*     Formatted document online ===> TSO CLIST LISTRP HELP   */\n/*     Source for documentation  -- IS03.SHARE.TEXT(LISTRP)   */\n/**************************************************************/\n/*  5740-XXH COPYRIGHT IBM CORP 1984                          */\n/*  LICENSED MATERIAL - PROGRAM PROPERTY OF IBM               */\n/*  REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER G120-2083     */\n/*  RESTRICTED MATERIALS OF IBM                               */\n/*                                                            */\n/*  LIST RACF PROTECTION - %LISTRP                            */\n/*                                                            */\n/*  THE PURPOSE OF THIS CLIST IS TO DEMONSTRATE A METHOD      */\n/*  OF COMBINING CATALOG SUPPORT (IDCAMS) AND THE RACF        */\n/*  SEARCH COMMAND TO REPORT ON WHAT DATA SET(S) ARE          */\n/*  PROTECTED BY WHAT RACF GENERIC AND DISCRETE PROFILES.     */\n/*                                                            */\n/*  THIS CLIST INVOKES THE RACF SEARCH COMMAND WITH THE       */\n/*  CLIST OPTION. IF YOU HAVE AN 'USERID.EXEC.RACF.CLIST'     */\n/*  DATA SET, IT WILL BE DELETED BY THIS CLIST. YOU MUST      */\n/*  HAVE THE RACF SPECIAL OR AUDITOR ATTRIBUTES WHEN USING    */\n/*  THE PREFIX OPERAND AND THE PREFIX IS NOT YOUR RACF        */\n/*  USERID.                                                   */\n/*                                                            */\n/*  CONSIDER RUNNING THIS CLIST IN BATCH UNDER THE TMP        */\n/*  WHEN LARGE NUMBERS OF PROFILES AND/OR DATASET NAMES OR    */\n/*  CATALOG ENTRIES ARE INVOLVED.                             */\n/*                                                            */\n/*  THIS CLIST IS AN EXAMPLE ONLY AND IS NOT SUPPORTED IN     */\n/*  ANY WAY.  IT IS PROBABLE THAT MODIFICATIONS TO THIS       */\n/*  CLIST WILL BE NECESSARY BEFORE IT COULD BE CONSIDERED     */\n/*  USEFUL IN ANY PARTICULAR INSTALLATION.                    */\n/*                                                            */\n/*  AS WRITTEN, THIS CLIST PROVIDES THE FOLLOWING FUNCTION.   */\n/*  (1) IF A PREFIX IS SPECIFIED VIA THE PREFIX OPERAND,      */\n/*      THEN THE PREFIX IS USED TO QUALIFY THE RACF PROFILES  */\n/*      AND DATASET NAMES FOR THE PROFILE SEARCH AND THE      */\n/*      CATALOG SEARCH.                                       */\n/*  (2) IF A DATA SET NAME IS SPECIFIED VIA THE DATASET       */\n/*      OPERAND, THEN IT REPORTS WHICH OF THE PROFILES        */\n/*      UNDER 'PREFIX' PROTECTS THE DATA SET.                 */\n/*  (3) IF YOU SPECIFY NO OPERANDS, THEN ALL YOUR CATALOGED   */\n/*      DATA SET ARE MATCHED TO THE PROFILES THAT COVER       */\n/*      THEM.                                                 */\n/*                                                            */\n/*  TO USE THIS CLIST YOUR USERID MUST MATCH THE HIGH LEVEL   */\n/*  INDEX OF THE DATA SET(S) OR YOU MUST HAVE THE RACF        */\n/*  'SPECIAL' ATTRIBUTE.                                      */\n/**************************************************************/\n/*  This clist has been modified at \"The REXX Macros Toolbox\" to make */\n/*  it possible for anyone to check datasets.  Examples:      */\n/*        ===> TSO LISTRF                                     */\n/*        ===> TSO LISTRF PREFIX(userid)                      */\n/*        ===> TSO LISTRF L(userid.LIBR)                      */\n/*        ===> TSO LISTRF Q(fully.qualified.dsname)           */\n/*        ===> TSO LISTRF L(userid.LIBR) DISPLAY              */\n/*        ===> TSO LISTRF E(userid.*.LIBR) DISPLAY            */\n/**************************************************************/\n/*                                                            */\n/*  THE SYNTAX AND OPERANDS OF THE CLIST ARE AS FOLLOWS:      */\n/*                                                            */\n/*  SYNTAX -                                                  */\n/*  LISTRP   DATASET(DATASET-NAME) PREFIX(PREFIX) DISPLAY     */\n/*                                                            */\n/*  REQUIRED - NONE                                           */\n/*                                                            */\n/*  OPERANDS -                                                */\n/*  'Q()'       - FULLY QUALIFIED DATASET NAME W/O QUOTES     */\n/*                DO NOT USE DATASET() OR PREFIX() IF USING.  */\n/*                (OPTION ADDED BY FRUSTRATED  FDM user)      */\n/*                                                            */\n/*  'L()'       - LISTCAT LEVEL()   DATASET NAME W/O QUOTES   */\n/*                DO NOT USE DATASET() OR PREFIX() IF USING.  */\n/*                (OPTION ADDED BY FRUSTRATED  FDM user)      */\n/*                                                            */\n/*  'E()'       - LISTCAT ENT()     DATASET NAME W/O QUOTES   */\n/*                DO NOT USE DATASET() OR PREFIX() IF USING.  */\n/*                E(is03.*.cntl)   e(is03.share.*)            */\n/*                (OPTION ADDED BY FRUSTRATED  FDM user)      */\n/*                                                            */\n/*  'DATASET()' - SPECIFIES A DATA SET NAME FOR WHICH YOU     */\n/*                WANT TO FIND THE RELATED RACF PROFILE.      */\n/*                                                            */\n/*  'PREFIX()'  - SPECIFIES A HIGH-LEVEL QUALIFIER FOR WHICH  */\n/*                YOU WANT TO FIND ALL THE DATASETS AND THE   */\n/*                RELATED RACF PROFILES.  IF THE DATASET      */\n/*                OPERAND IS ALSO SPECIFIED, THEN THE PREFIX  */\n/*                IS USED TO QUALIFY THE DATASET NAME.        */\n/*                                                            */\n/*  'DISPLAY'   - REQUESTS THAT PROFILE INFORMATION BE        */\n/*                DISPLAYED. THE DEFAULT IS NO DISPLAY.       */\n/**************************************************************/\nSET SAVED = &STR(&SYSDATE. &SYSTIME.)\nATTN DO\n       WRITE ATTENTION NOTED.\n       GOTO REALEND\n     END\nSET B44 = &STR(                                            )\nSET LENGLVL = 0\nSET LENGENT = 0\nSET RACFY = 0   /* dataset is   racf protected */\nSET RACFN = 0   /* dataset not  racf protected */\nSET RACFP = 0   /* possibly not racf protected */\nSET RACFU = 0   /* UNMATCHED --DONT CARE IF LVL*/\nSET PMATCHT = 0 /* TOTAL CUMULATIVE MATCHES ON PROFILES\nSET LISTCR = 0  /* listcat records             */\nSET LISTCP = 0  /* listcat records  printed    */\nSET PROFP = 0   /* profile records printed     */\nSET CATWK = &STR(YES)\nSET SINGLELD = &STR()\n/* The following code has been inserted by FDM\n/* The above code and the word ELSE below was inserted by FDM\nIF &LENGTH(&STR(&E.)) ^= 0 THEN +\n   DO\n     SET LENGENT = &LENGTH(&STR(&E.))\n     SET LENGLVL = &LENGTH(&STR(&E.))\n     SET DATASET= &STR(&E.)\n     SET I = &SYSINDEX(.,&DATASET. )\n     IF &I. = 0 THEN +\n        SET PREFIX = &STR(&DATASET.)\n     ELSE DO\n        SET I = &I. - 1\n        SET PREFIX = &SUBSTR(1:&I,&STR(&DATASET.))\n     END\n     SET USED = LISTRP E(&STR(&E.))\n     SET USED2 = LISTC ENT('&STR(&DATASET.)')\n   END\n/* The above code and the word ELSE below was inserted by FDM\nELSE IF &LENGTH(&STR(&L.)) ^= 0 THEN +\n   DO\n     SET LENGLVL = &LENGTH(&STR(&L.))\n     SET DATASET= &STR(&L.)\n     /** removed the following by resetting prefix**/\n     SET I = &SYSINDEX(.,&DATASET. )\n     IF &I. = 0 THEN +\n        SET PREFIX = &STR(&DATASET.)\n     ELSE DO\n        SET I = &I. - 1\n        SET PREFIX = &SUBSTR(1:&I,&STR(&DATASET.))\n     END\n     /** removed the above*/\n     SET PREFIX = &STR(&DATASET.)\n     SET USED = LISTRP L(&STR(&PREFIX.))\n     SET USED2 = LISTC LEVEL(&STR(&DATASET.))\n   END\n/* The following code has been inserted by FDM\nELSE IF &LENGTH(&STR(&Q)) ^= 0 THEN +\n   DO\n     SET USED = LISTRP Q(&STR(&Q.))\n     SET DATASET= &STR(&Q.)\n     SET CATWK = &STR(NO)\n     SET I = &SYSINDEX(*,&DATASET. )\n     IF &EVAL(&I.) ^= &EVAL(0) THEN DO\n        WRITE THE USE OF ASTERISK(*) IS NOT PERMITTED +\n          -- LISTRP L(&STR(&Q.))\n        EXIT CODE(8)\n     END\n     SET I = &SYSINDEX(.,&DATASET. )\n     SET I = &I. - 1\n     SET PREFIX = &SUBSTR(1:&I.,&STR(&DATASET.))\n     SET USED2 = LISTC ENT('&STR(&DATASET.'))\n   END\n/* The above code and the word ELSE below was inserted by FDM\nELSE IF &LENGTH(&STR(&DATASET)) ^= 0 THEN +\n   DO\n     SET USED = LISTRP\n     IF &STR(&PREFIX.) ^= &STR(&SYSUID.) THEN +\n        SET USED = &USED PREFIX(&PREFIX.)\n     IF &STR(&DATASET.)^= &STR() THEN +\n        SET USED = &USED DATASET(&DATASET.)\n     SET DATASET= &STR(&STR(&PREFIX.)&STR(.)&STR(&DATASET.))\n     SET USED2 = LISTC ENT('&STR(&DATASET.'))\n     SET CATWK = &STR(NO)\n   END\nELSE DO\n   SET USED = LISTRP PREFIX(&PREFIX.)\n   SET DATASET = &STR(&PREFIX.)\n   SET USED2 = LISTC LEVEL(&STR(&DATASET.))\n   SET CATWK = &STR(YES)\nEND\nCLS   /* clear screen added FDM */\nSET USED = &STR(&USED.) &DISPLAY. &TERSE.\nIF &TERSE.X = TERSEX THEN GOTO TERSE2\nWRITE &R.\nWRITE YOU ISSUED THE FOLLOWING COMMAND&STR(:)\nWRITE &R.    ===> TSO &USED.\nWRITE &R.\nWRITE Commands issued by LISTRP and merged +\n      to create the LISTRP listing:\nWRITE &R.         &USED2.\nWRITE &R.         SEARCH MASK(&PREFIX..)\nWRITE &R.Issued by LISTRP if DISPLAY is used, or found possible +\n      unprotected datasets:\nWRITE &R.         LD DATASET('dataset') AUTH\nWRITE Syntax of LISTRP:\nWRITE &R.    DATASET(tso.qualified.dsn) and/or PREFIX(prefix), or one of\nWRITE &R.      E(fully.qualified.pattern) | L(dsn.level) | Q(fully.qualified.dsn\nWRITE &R.    DISPLAY  -- display content of PROFILE(S)\nWRITE ================================================================\nTERSE2: SET NOP = NOP\nIF &LENGTH(&STR(&Q)) ^= 0 THEN DO\n   SET CHK = &SYSDSN('&Q.')\n   IF OK ^= &CHK THEN DO\n      WRITE\n      WRITE A check using &&SYSDSN('&Q.') shows\n      WRITE -- &CHK.\n   END\nEND\n/**********************************************************************\n/* Populate the PROFILE list -- SEARCH -- total into COUNT            *\n/**********************************************************************\n/* GENERIC WAS ADDED ALSO BY FDM */\nCONTROL NOFLUSH\nSEARCH MASK(&PREFIX..) CLIST NOLIST GENERIC\nSCAN: +\nALLOC DD(PROFS) DA(EXEC.RACF.CLIST) SHR\nOPENFILE PROFS INPUT\n/*IF &STR() ^= &STR(&IGNORE.) THEN GOTO NOERR1\nERROR DO\n      SET &CC = &LASTCC\n      IF &CC = 400 THEN GOTO EOFPROFS\n      IF &CC > 12 AND &CC ^= 400 THEN DO\n         WRITE ERROR BLOCK ONE ENTERED WITH &CC\n         ERROR\n      END\n      RETURN\n      END\n NOERR1: SET NOP = NOP\n SET COUNT = 0\n DO WHILE 1=1\n   GETFILE PROFS /* READ A PROFILE\n   SET COUNT = &COUNT + 1\n   SET X = &LENGTH(&PROFS)\n   DO WHILE &SUBSTR(&X,&PROFS) ^= &STR(')\n    SET X = &X - 1\n   END\n   SET &ITEM  = &STR(PROF&COUNT)\n   SET &&ITEM = &SUBSTR(10:&X-1,&PROFS)\n END\nEOFPROFS: +\nCLOSFILE PROFS\nFREE F(PROFS)\nCONTROL NOMSG\nDELETE EXEC.RACF.CLIST\nCONTROL MSG\n/**********************************************************************\n/* Populate the DATASET list LISTCAT or put in single dsname          *\n/**********************************************************************\nIF &CATWK = &STR(NO) THEN +\n DO\n  SET COUNT2 = 1       /* ONE DATA SET NAME TO PROCESS\n  SET &ITEM2  = &STR(DS&COUNT2)\n  SET &&ITEM2 = &STR(&DATASET)\n  GOTO COMP\n END\nCATWORK: +\nALLOC F(ALTFILE) NEW REUSE SP(1,1) TR RECFM(V,B,A) LRECL(125) +\n  BLKSIZE(6290)\n&USED2.  OFILE(ALTFILE)   /* LISTCAT ----- */\nOPENFILE ALTFILE INPUT\n/*IF &STR() ^= &STR(&IGNORE.) THEN GOTO NOERR3\nERROR DO\n      SET &CC = &LASTCC\n      IF &CC = 400 THEN GOTO EOFSYSP\n      ERROR\n      IF &CC > 12 AND &CC ^= 400 THEN +\n      WRITE ERROR BLOCK ONE ENTERED WITH &CC\n      RETURN\n      END\nNOERR3: SET NOP = NOP\nSET COUNT2 = 0\nDO WHILE 1=1\n  GETFILE ALTFILE\n  SET LISTCR = &LISTCR + 1\n    /* fix this someday needs more than just NONVSAM  ------*/\n  IF &SUBSTR(2:8,&STR(&ALTFILE        )) =NONVSAM THEN +\n    DO\n      SET &DSN=&SUBSTR(18:&LENGTH(&ALTFILE),&ALTFILE)\n      SET COUNT2 = &COUNT2 + 1\n      SET &ITEM2  = &STR(DS&COUNT2)\n      SET &&ITEM2 = &STR(&DSN)\n    END\nEND\nEOFSYSP: SET NOP = NOP\n/**********************************************************************\n/* Two lists are now stored  PROFILE and DSNAMES, we now cycle        *\n/* through the PROFILE list and the DSNAMES will be in inner cycle.   *\n/*            cycle through the PROFILE list                          *\n/**********************************************************************\nCLOSFILE ALTFILE\nCOMP: SET NOP = NOP\n/*IF &STR() ^= &STR(&IGNORE.) THEN GOTO NOERR5\nERROR OFF\n        ERROR DO\n              SET &CC = &LASTCC\n              IF ( &CC > 12 AND &CC ^= 400 AND &CC ^= 368 ) THEN DO\n                WRITE ERROR BLOCK TWO ENTERED WITH &CC\n                ERROR\n              END\n              RETURN\n              END\nNOERR5: SET NOP = NOP\nSET START=&LENGTH(&PREFIX) + 2\nSET RUNNER = 1\nDO WHILE (&RUNNER <= &COUNT)\n  SET MATCHDS = &STR(NO)      /* INITIALIZE MATCH INDICATOR TO NO */\n  SET PROFILE = &&PROF&RUNNER\n  SET PROFP = &PROFP. + 1\n  SET PMATCH = 0      /* NUMBER OF MATCHES FOR ONE PROFILE */\n  SET PL = &LENGTH(&STR(&PROFILE)) /* SET SCAN LIMIT FOR PROFILE\n  /*****************************************************************\n  /*     inner cycle going through DATASETS for each PROFILE       *\n  /*****************************************************************\n  SET RUNNER2 = 1\n  DO WHILE (&RUNNER2 <= &COUNT2)\n   SET DATASET = &&DS&RUNNER2\n   IF &DATASET = &STR(9) THEN GOTO BYPASSDS\n   /* Could be protected by additional profiles,          */\n   /* we will not list them again even if more restrictive*/\n\n   /**------------- create PSEUDO comparison of PROFILE to dsn--*/\n   SET DL = &LENGTH(&STR(&DATASET)) /* SET SCAN LIMIT\n   SET DC = &START\n   SET PC = &START\n   SET PSEUDO = &STR(&STR(&PREFIX)&STR(.))\n   DO WHILE (&PC <= &PL)\n    IF  &SUBSTR(&PC,&PROFILE) = &STR(%) THEN +\n     DO\n      IF (&DC <= &DL) THEN +\n        SET &PSEUDO = &STR(&PSEUDO&SUBSTR(&DC,&DATASET))\n      SET &PC = &PC + 1\n      SET &DC = &DC + 1\n      GOTO ENDMAIN\n     END\n    IF ( &SUBSTR(&PC,&PROFILE) = &STR(*) AND &PC = &PL ) THEN +\n     DO\n      IF (&DC <= &DL) THEN +\n        SET &PSEUDO = &STR(&PSEUDO&SUBSTR(&DC:&DL,&DATASET))\n      SET &DC = &DL\n      SET &PC = &PC + 1\n      GOTO ENDMAIN\n     END\n    IF ( &SUBSTR(&PC,&PROFILE) = &STR(*) AND &PC < &PL ) THEN +\n     DO\n      IF (&DC <= &DL) THEN +\n        DO\n          SET DCR = &DC  /* SET CURRENT DSN RANGE TO CURRENT DS POIN\n          DO WHILE (&SUBSTR(&DCR,&DATASET) ^= &STR(.) AND &DCR < &DL)\n            SET &DCR = &DCR + 1\n          END\n          SET &PSEUDO = &STR(&PSEUDO&SUBSTR(&DC:&DCR-1,&DATASET))\n        END\n      SET &PC = &PC + 1\n      SET &DC = &DCR\n      GOTO ENDMAIN\n     END\n    SET &PSEUDO = &STR(&PSEUDO&SUBSTR(&PC,&PROFILE))\n    SET &PC = &PC + 1\n    SET &DC = &DC + 1\n    ENDMAIN: +\n    SET PLEN=&LENGTH(&PSEUDO)\n    IF &PLEN > &DL THEN SET PLEN=&DL\n    IF &PSEUDO ^= &SUBSTR(1:&PLEN,&DATASET) THEN SET PC = &PL + 1\n   END            /* END OF PSEUDO NAME BUILD LOOP\n   /**--------- now do     PSEUDO comparison of PROFILE to dsn--*/\n   IF &STR(&PSEUDO) = &STR(&DATASET) THEN +\n     DO\n       SET MATCHDS = &STR(YES)\n       SET PMATCH = &PMATCH + 1\n       SET PMATCHT = &PMATCHT + 1\n       SET LISTCP = &LISTCP. + 1\n       IF &CATWK.=NO THEN +\n          DO\n            IF &PMATCHT = 1 THEN DO\n              IF X&TERSE. = X OR DISPLAY = &DISPLAY THEN +\n                 SET SINGLELD = LD DA('&STR(&PROFILE.)') AUTH\n              WRITE\n              WRITE CATALOGED DATA SET ==> &DATASET\n              WRITE &R  PROTECTED BY  PROFILE ==> &PROFILE\n            END\n            ELSE   WRITE &R      UNAFFECTED BY ... ==> &PROFILE\n           /*GOTO REALEND -- WILL BE CHECKING ALL PROFILES NOW\n          END\n       ELSE +\n        DO\n          IF &PMATCH = 1 THEN DO\n             WRITE\n             IF &DISPLAY = DISPLAY THEN +\n              DO\n                WRITE * * * * * * * * * * * * * * * * * * * * * * * * *\n                LD DA('&PROFILE.') AUTH\n              END\n             ELSE WRITE        PROFILE ==> &PROFILE\n             WRITE     PROTECTS THE FOLLOWING CATALOGED DATA SET(S)\n          END  /* MATCH = 1  */\n          /******/\n          WRITE DATA SET ====> &DATASET\n          NEXTDS: +\n          SET &ITEM2  = &STR(DS&RUNNER2)     /* MARK DATA SET\n          SET &&ITEM2 = &STR(9)              /*     AS MATCHED\n        END\n      END\n    BYPASSDS: +\n    SET RUNNER2 = &RUNNER2 + 1    /* ADVANCE TO NEXT DATA SET NAME\n  END\n IF (&MATCHDS = NO AND &CATWK =YES) THEN +\n    IF &LENGTH(&STR(&E.)) = 0 THEN +\n    DO\n      WRITE\n      WRITE   NO DATASETS IN USE FOR PROFILE -- &PROFILE.\n    END\n NEXTPROF: +\n SET RUNNER = &RUNNER + 1         /* ADVANCE TO NEXT PROFILE\nEND\n/**********************************************************************\n/*  All profiles have be checked to see if they protect datasets      *\n/*  or not.  A final report will be produced with the unprotected     *\n/*  datasets.                                                         *\n/**********************************************************************\nIF &TERSE.X = X THEN RETURN\n IF (&PMATCHT = 0  AND &CATWK = NO THEN +\n  DO\n        WRITE\n        WRITE DATA SET ==> &DATASET       NOT RACF PROTECTED\n        WRITE\n  END\nIF &CATWK = &STR(YES) THEN +\n DO\n   SET RUNNER = 1\n   SET FTIME = YES\n   DO WHILE &RUNNER <= &COUNT2\n   SET DATS = &&DS&RUNNER\n   IF &DATS ^= &STR(9) THEN +\n     DO\n       SET RACFU = &RACFU. + 1\n       /******/\n       IF &FTIME = YES THEN +\n         DO\n          WRITE\n          WRITE THE FOLLOWING DATA SET(S) ARE NOT RACF PROTECTED +\n            OR NOT ACCESSIBLE BY YOU.\n         END\n       SET RACFP = &RACFP. + 1\n       /* WRITE  UNPROTECTED DATA SET ===> &DATS\n       IF &RUNNER. > 204 THEN WRITE POSSIBLE +\n           POSSIBLE UNPROTECTED DATA SET ===> &DATS.\n       ELSE DO\n          SET SYSOUTTRAP = 1\n          LD DATASET('&DATS.') AUTH\n          SET SYSOUTTRAP = 0\n          IF &SUBSTR(1:11,&STR(&SYSOUTLINE1.)) = &STR(INFORMATION) +\n          THEN DO\n             SET RACFY = &RACFY. + 1\n             WRITE <RACF SECURED>  &SYSOUTLINE1.\n          END\n          ELSE DO\n              SET RACFN = &RACFN. + 1\n              WRITE &SYSOUTLINE1.\n          END\n      END\n\n      NEXTQUEST: +\n      SET FTIME = NO\n     END\n   SET RUNNER = &RUNNER + 1\n   END\n   IF &RACFP. ^= 0 THEN DO\n      WRITE\n      WRITE CONCERNING THE POSSIBLY UNPROTECTED DATASETS...\n      WRITE &R.   OF &RACFP. DATASETS HAVE LOOKED AT +\n         &EVAL(&RACFY. + &RACFN.) DATASETS +\n         AND &RACFY. OF THOSE WERE RACF PROTECTED.\n      IF &LENGLVL ^= 0 THEN +\n         WRITE &R.   &RACFU. CHECKED FOR LEVEL MATCHES, FIRST\n   END\n END\nREALEND: +\n IF &STR(&SINGLELD.) ^= &STR() THEN &SINGLELD.\n IF NO = &CATWK THEN EXIT\n WRITE\n WRITE LISTRP COMPLETED -- &USED.\n WRITE &R.  PROCESSED &PROFP. OF &COUNT. RECORDS IN PROFILE\n WRITE &R.  PROCESSED &LISTCP OF &COUNT2 RECORDS FROM LISTCAT\n WRITE LISTRP -- BEGAN &SAVED. -- ENDED &SYSDATE. &SYSTIME.\nEXIT\n/*\n/**********************************************************************\n/*\nICHRTX00 TITLE 'MVS Router exit for JOB verification.'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOADMOD": {"ttr": 8196, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x94\\x00\\x94\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 148, "newlines": 148, "modlines": 0, "user": "MCRITCH"}, "text": "/* LOADMOD: Browse member if it exists in current LNKLSTxx   -- REXX */\n/*********************************************************************/\n/*  Purpose: BROWSE a link-list member                               */\n/*           according to LNKLST00 concatenation                     */\n/*   also included are SYS1.SVCLIB and SYS1.LPALIB                   */\n/*   Created by David McRitchie, \"The REXX Macros Toolbox\", 1985/07/10 */\n/*   Converted to REXX 1994/05/16 with inclusion of CBT 166 $D material*/\n/*   The LNKLST portion has been redone with material obtained from  */\n/*     from CBT file 166 member $D by Vinh Vu  1992/05/21 of Frito Lay */\n/*********************************************************************/\n/*  Four examples:                                                   */\n/*     ===> LOADMOD IEFBR14          ===> LOADMOD IEFBR14 NB         */\n/*     ===> LOADMOD IEFBR1*          ===> LOADMOD IEFBR1* SUMMARY    */\n/*  Options:                                                         */\n/*     SUMMARY,   list each dataset checked                          */\n/*     NB,         no browse, will also cause SUMMARY to be be used  */\n/*     SHORT,      do not show MEMBER NOT FOUND in SUMMARY           */\n/*********************************************************************/\n\narg Member parm /* supply membername i.e.  IEFBR14, IEFBR1*, JES2 */\nparm = translate(\" \"parm\" \"); member=translate(member)\nif member = \"\" then do\n    Zedlmsg = 'Membername required, i.e. ===> TSO LOADMOD IEFBR14'\n    address \"ISPEXEC\" \"setmsg msg(isrz000)\"\n    exit 1\nend\napftable = \"Authorized Program Function Table\"\nq.=\"\";found.=\"\";xcnt=0; apfmsgx.=\"\"\nq.1 = \"sys1.svclib\";  apfmsgx.1='==APF Lib-'\nq.2 = \"sys1.lpalib\";  apfmsgx.2='==APF Lib-'\n\nDo qcnt=1 to 20 until (q.qcnt =\"\"); end; qcnt=qcnt-1;\n\n/* CBT 166 $D portion -- start -------------------------------------*/\nCVTADD  = C2X(Storage(10,4))\nPTR     = D2X(X2D(CVTADD)+196)\nSMCAADD = C2X(STORAGE(PTR,4))                  /* SMCA pointer      */\nSMFID   = Substr(Storage(SMCAADD,20),17,4)     /* Get System SMF ID */\n\nSYSIDL  = C2D('154'x)                          /* SYSID offset      */\nSYSID   = Substr(Storage(CVTADD,SYSIDL+4),SYSIDL+1,4)\n\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*      DISPLAY LINKLIST                                            */\n/*                                                                  */\n/*      LLT = CVT+x'4DC'(1244) = Pointer to Linklist Table          */\n/*      COUNT will be how many DSNames are in Linklist              */\n/*                                                                  */\nLLTDISP:\nLLTOFF  = '4DC'x                               /* Offset of LLT     */\nLLTOFFD = C2D(LLTOFF)                          /* Offset in dec     */\nLLTADD  = C2X(Substr((Storage(CVTADD,LLTOFFD+4)),LLTOFFD+1,4))\nCOUNT   = C2D(Substr((Storage(LLTADD,8)),5,4))\nLLTDEC  = X2D(LLTADD)+9                        /* Ptr to Dsn (dec)  */\nAPFDEC  = X2D(LLTADD)+8+(45*COUNT)             /* Ptr to Flag (dec) */\n\nDO I=1 to COUNT\n   DSNAME=Substr((Storage(D2X(LLTDEC),44)),1,44)\n   LLTDEC = LLTDEC + 45\n   APFFLAG=Substr((Storage(D2X(APFDEC),1)),1,1)\n   If Bitand(APFFLAG,'80'x) = '80'x Then\n      APFMSG = '- APF Lib -'\n   Else\n      APFMSG = '          -'\n   APFDEC = APFDEC + 1\n   /*  Say Format(I,3,0) ' ' APFMSG DSNAME*/\n   qcnt=qcnt+1; q.qcnt=strip(dsname); apfmsgx.qcnt = apfmsg\nend\n/* CBT 166 $D portion -- start of extracted code -------------------*/\n/* last of code from CBT tape 166 which eliminates the need to keep */\n/*   this execute up to date based on LNKLST00 parmlib member.      */\n/* qcnt=qcnt+1; q.qcnt = 'TSOTEST.LIB01.LOAD'*/\n\n\n  q.0 = qcnt; nb=0; short=0\n  If pos(' SUMMARY ',parm) \\=0 then summary=1; else summary=0\n  If pos(' NB ',parm) \\= 0 then do;summary=1;NB=1;end;else nb=0\n  If pos(' SHORT ',parm) \\= 0 then do;summary=1;SHORT=1;end;else short=0\n  If pos('*',member) \\= 0 then multimem=1;\n  else if pos('%',member) \\= 0 then multimem=1; else multimem=0\n  If length(member) > 8 then do\n     inval = \"Invalid membername length(\"member\") exceeds 8\"\n     zedsmsg = \"Membername\"; zedlmsg=inval; say inval\n     ispexec     setmsg msg(isrz000)\n     exit 12\n  end\n  address \"ISPEXEC\" \"CONTROL ERRORS RETURN\"\n  do i = 1 to q.0\n     dsname = \"'\"q.i\"(\"member\")'\"\n     ZEDSMSG = \" \"\n     if apfmsgx.i = \"\"\n       then zedlmsg = \"************* Not found in the\" APFTABLE\n       else zedlmsg = \"************* FOUND in the\" APFTABLE\n     ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n     if multimem=1 then do\n        address \"ISPEXEC\" \"BROWSE DATASET(\"dsname\")\"\n     end\n     else do\n        goodbad = sysdsn(dsname)\n        if goodbad = \"OK\" then do\n           if NB=0 then address \"ISPEXEC\" \"BROWSE DATASET(\"dsname\")\"\n           xcnt=xcnt+1;\n        end;\n        found.i=goodbad\n     end;\n  end;\n  zedsmsg=\"\"; zedlmsg=\"\"; address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n  if multimem = 0 then if xcnt = 0 then do\n     \"IVL806\" member\n     cc = rc\n     if cc = 0 then do\n           say  member \"exists in a load library, but is not\",\n               \"known where by the LOADMOD execute, \"\n           exit code 1\n     end\n     if cc  = 4 then say member \"exists in a load library, but is\",\n        \"marked NOT-EXECUTABLE\"\n     If cc  = 8 THEN DO\n        If xcnt = 0 then do\n           say \"MEMBER=\"member\" was NOT found in LINKLST libraries\"\n           if \"OK\" = SYSDSN(\"'TSOTEST.LIB01.LOAD(\"member\")'\") then\n              say member \"exists in 'TSOTEST.LIB01.LOAD'\"\n           exit 1\n        end\n     end\n     If xcnt = 1 then exit 0\n end\n\n if summary=1 then \"CLS\"\n If xcnt = 0 then do\n      Say \"Member=\"member\"  was not found in \",\n        \"any selected link libraries\"\n end\n else say \"Member=\"member\" was found in\" XCNT \"link libraries\",\n         \"sys1.svclib, or sys1.lpalib\"\n If summary = 1 then do\n    say \" \"\n    Say \"SUMMARY FROM ===> TSO LOADMOD\" MEMBER \"summary\"\n    Say \"    options available    NB  SUMMARY  SHORT\"\n    say\n    do i = 1 to q.0\n       if found.i \\= \"\" then do\n          if short = 0 | found.i \\= \"MEMBER NOT FOUND\"\n             then say right(i,3)\".\" left(q.i,54) apfmsgx.i found.i\n       end\n    end\n end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MACMAC": {"ttr": 8200, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00*\\x00*\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "MCRITCH"}, "text": "/*REXX -- Invoke EDIT  with preset ISREDIT commands       */\n/*     MACMAC and MACMACS same except for delimiter       */\n/*     -------------------------------------------------- */\n/* usage of MACMAC macro clist  from a TSO clist          */\n/*   SET MACPARM = COPY MESSAGE AFTER 0;SAVE;END          */\n/*   ISPEXEC VPUT (MACPARM) SHARED                        */\n/*   ISPEXEC EDIT DATASET('&CNTL.(&D.)') MACRO(MACMAC)    */\n/*   +--------------------------------------------------- */\n/*   | David McRitchie, \"The REXX Macros Toolbox\", 1991/02/14 */\n/*   +--------------------------------------------------- */\nADDRESS \"ISREDIT\";\"MACRO (TOKENS)\"\n\"IMACRO NONE\"\n      \" ISREDIT (MEMBERX) = MEMBER \"\n      \" ISREDIT (DSNX)    = DATASET\"\nZEDSMSG = \"Member=\"||MEMBERX\nZEDLMSG = \"MACMAC processed \"DSNX||\"(\"||memberx||\")\"\nAddress \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\nif TOKENS = \"\" then do\n   Address ISPEXEC VGET (MACPARM)\n   tokens = macparm\nend\n\"(CAPS)=CAPS\"  /*will restore at exit*/\n\"caps off\"  /*for msglines*/\nORIGINAL = TOKENS\nDo forever; /*remove commas*/\n     if tokens = \"\" then leave\n     /* MACMAC and MACMACS same except next line*/\n     Parse var TOKENS Left\";\"Right;\n     Check = translate(left)\n     if \"END\" = check then do\n        \"CAPS\" caps\n        \"END\"\n        return\n     end\n     Address ISREDIT Left\n     TOKENS =  Right;\nEnd;\n \"LINE_BEFORE 1   = noteline \"\"\"TIME('N'),\n       \"MACMAC processed \"DSNX||\"(\"memberx||\")\"\"\"\n \"LINE_BEFORE 1   = noteline  \"\"  with ...  \"ORIGINAL \"\"\"\"\n \"caps\" caps\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAKEADD": {"ttr": 8202, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00-\\x00-\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "MCRITCH"}, "text": " /* REXX        - MAKEADD CREATE IEBUPDTE CARDS FROM PRINTED PANELS */\n\n /*******************************************************************/\n /* NAME        - MAKEADD                                           */\n /* TITLE       - CREATE IEBUPDTE CARDS FROM PRINTED PANELS         */\n /*                                                                 */\n /* DESCRIPTION -                                                   */\n /*   THE RESULTING PDS MEMBERS                                     */\n /*   CAN BE USED AS PATTERNS FOR TAILORING INDIVIDUAL PLR MANUALS  */\n /*                                                                 */\n /* CHANGE ACTIVITY -                                               */\n /*   DDMMMYY  XXX  - XXXXXXX XXXX.                                 */\n /*******************************************************************/\n ADDRESS \"ISREDIT\";\"MACRO\"\n USERID = STRIP(SYSVAR('SYSUID'))\n PREFIX = STRIP(SYSVAR(SYSPREF)); IF PREFIX='' THEN PREFIX=USERID\n \"(FIRST) = LINENUM .ZFIRST\"\n IF FIRST = 00000 THEN RETURN 0\n \"X ALL\"\n \"F ALL 2 'PANEL NAME = '\"\n IF RC = 0 THEN DO\n    \"REFORMAT NX ENTIRE './ ADD NAME=' 15 25\"\n    \"RESET\"\n    \"X ALL 1 './ '\"\n    \"REFORMAT NX  ENTIRE 21 100\"\n END\n ELSE DO\n    \"X ALL\";\"F 22 'PZZ' ALL\";IF RC /= 0 THEN RETURN;\n    \"REPEATNX BEFORE\"\n    \"REFORMAT ENTIRE NX './ ADD NAME=' 22 29\"\n    \"RESET\"\n    \"X ALL 1 './ '\"\n    \"REFORMAT NX  ENTIRE 21 100\"\n END\n \"LABEL .ZFIRST = .TOP\"\n \"LINE_BEFORE .TOP = DATALINE \"||,\n     '\"//SCREENS  EXEC UPDATE,PARM=NEW                            \"'\n \"LINE_BEFORE .TOP = DATALINE \"||,\n     '\"//SYSUT2   DD  DSN='PREFIX'.PLR.PATTERNS,DISP=(,CATLG,DELETE), \"'\n \"LINE_BEFORE .TOP = DATALINE \"||,\n     '\"//             SPACE=(TRK,(2,5,15)),UNIT=TESTDISK,         \"'\n \"LINE_BEFORE .TOP = DATALINE \"||,\n     '\"//             DCB=SYS1.ISPF.ISPPLIB                       \"'\n \"LINE_BEFORE .TOP = DATALINE \"||,\n     '\"//SYSIN    DD  *                                           \"'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAKEMAC": {"ttr": 8204, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00X\\x00X\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 88, "newlines": 88, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- #MAKEMAC -- create REXX edit macro from commands          */\n/*                                                                   */\n/*  The MAIN PURPOSE of this clist is to convert a copy of the edit  */\n/*  commands that you did to an edit macro so that you can repeat    */\n/*  the same commands later.                                         */\n/*                                                                   */\n/*  Related clists:  CUT PASTE APPEND, #P #MAKEMAC, REFORMAT         */\n/*                                                                   */\n/*  All cards are assumed to be edit commands.  This macro adds      */\n/*  double quotes at beginning and end of each line so edit macro    */\n/*  lines are generated.  Special provision has been made to cover   */\n/*  &edit-command  so that they are repeated until they no longer    */\n/*  give RC=0.  If the next line is also an &edit-command, you       */\n/*  should check to see if the the two DO FOREVER loops should be    */\n/*  combined.  Provision is also made for  :TS (text split)  and :TF */\n/*  (text flow).   A | in column one will be used as an escape to    */\n/*  copy a REXX command or other line unchanged  .e.g  |DO|END.      */\n/*                                                                   */\n/*  Author: (do not change the original author thank you)            */\n/*   F. David McRitchie, \"The REXX Macros Toolbox\", July 29, 1992 20:50 */\n/*********************************************************************/\nAddress \"ISREDIT\"\n\"MACRO (TOKEN)\"\n\"(MEMBERX) = MEMBER \"\n\"(DSNX)    = DATASET\"\nif memberx /= \"\" then dsnxx=dsnx\"(\"memberx\")\";else dsnxx=dsnx\nCNT = 1\nblank = substr(' ',1,120)\ni=1;last=20\n\"(LAST) = LINENUM .ZLAST\"\nlast = last + 0\ndo i = 1 to last by 1\n   \"(LINE) = line \" i\n   j = index(line,'&&')\n   if j /=0 then line = \"    \"line\n   l = index(line||blank,blank)\n   lineu=translate(line)\n   /* LABEL .A ----------------> LABEL .ZCSR = .A 0 */\n   /* LABEL .zcsr = .point 0 --> (no changes made)*/\n   if substr(lineu,1,7) = 'LABEL .' then do\n      n = index(lineu,'=')\n      if n = 0 then do\n         line = \"LABEL .ZCSR = \"||substr(line,7,L-6)||\" 0\"\n         l = l + 10\n      end\n   end\n   /* | is used as an excape to put out REXX commands*/\n   if substr(line,1,1)='|' then line = substr(line,2)\n   else line = \"\"\"\"||substr(line,1,l)||\"\"\"\"\n   \"line \"i\" = (line)\"\nend\nlastcc = 0\n\"find first '&&'\"\nlastcc = rc\ndo while (lastcc=0)\n  \"line_before .zcsr = dataline 'Do forever'\"\n  \"line_after  .zcsr = dataline 'End'\"\n  \"line_after  .zcsr = dataline '   if rc /= 0 then leave'\"\n  \"f last p'^' .zcsr .zcsr\"\n  \"(C1) = LINENUM .zcsr\"\n  \"f next '&&'\"\n  lastcc = rc\n  if lastcc /= 0 then leave\n  c1 = c1 + 3  /* two lines added, and next line makes 3 */\n  \"(C2) = LINENUM .zcsr\"\n  c2 = c2 + 0\n  if c1 = c2 then do\n     \"LINE_BEFORE .zcsr = DATALINE \"\"/\"||\"* ...check for \",\n        \"possibly combining  prev/next do/end group ......*\"||\"/\"\"\"\n     \"Label .zcsr = .warn 0\"\n  end\nend\n\"c all ':tf' 'TFLOW .ZCSR '\"  /* :tf20 --> TFLOW .ZCSR 20 */\n\"c all ':ts' 'TSPLIT '\"        /* :TS14 --> TSPLIT 14      */\n\"c all 1 '\"\"&&' '   \"\"'\"\n\"LABEL .zfirst = .start 0\"\nCBS = \"LINE_BEFORE .start = DATALINE \"\"/\"||\"*\"\nCEND = \"*\"||\"/\"\"\"\nCBS \" REXX -- ..................................................\" CEND\n\"LINE_BEFORE .start = DATALINE 'Address \"\"ISREDIT\"\"'\"\n\"LINE_BEFORE .start = DATALINE '\"\"MACRO (TOKEN)\"\"'\"\nCBS \"This edit macro was .......................................\" CEND\nCBS \"    created by #MAKEMAC macro from list of macro commands  \" CEND\nCBS \"    in card image form\" ,\n    date('j') \"--\" date('u') time('n') SYSVAR('sysuid') CEND\nCBS \"    while editing\" dsnxx   cend\nCBS \"It is your responsibility to verify #MAKEMAC conversion. ..\" cend\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MANRLAB": {"ttr": 8207, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xae\\x00\\xae\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 174, "newlines": 174, "modlines": 0, "user": "MCRITCH"}, "text": "            CONTROL ASIS\n /*  TITLE:       RESEQ  LABEL NUMBERS FOR MANUALS LABELS\n /*  USERS:       SYSTECH -- D.MCR, OR MANUAL LIBRARIAN\n /*  CONTRIBUTED: 1988/12/01 DAVID MCRITCHIE\n /*\n /*  EXAMPLE:     MANRLAB .A .B BEGIN(3301) INCR(4)\nISREDIT     MACRO (TOK1,TOK2,TOK3,TOK4,TOK5,TOK6,TOK7,TOK8,TOK9,TOK10,TOK11,TOK1\n          TOK14,TOK15,TOK16,TOK17,TOK18,TOK19,TOK20,TOK21,TOK22,TOK23,TOK24,TOK2\n          TOK27,TOK28,TOK29,TOK30,TOK31,TOK32,TOK33,TOK34,TOK35,TOK36,TOK37,TOK3\n          TOK40,TOK41,TOK42,TOK43,TOK44,TOK45,TOK46,TOK47,TOK48)\n        SET DCTL = +\n          &STR(TOK1,TOK2,TOK3,TOK4,TOK5,TOK6,TOK7,TOK8,TOK9,TOK10,TOK11,TOK12,TO\n          TOK14,TOK15,TOK16,TOK17,TOK18,TOK19,TOK20,TOK21,TOK22,TOK23,TOK24,TOK2\n          TOK27,TOK28,TOK29,TOK30,TOK31,TOK32,TOK33,TOK34,TOK35,TOK36,TOK37,TOK3\n          TOK40,TOK41,TOK42,TOK43,TOK44,TOK45,TOK46,TOK47,TOK48)\n        SET ECTL = &STR(**ERROR** ATTEMPTING TO USE  ==> MANRLAB )&SUBSTR(1:23,&\n        SET INCR = 1\n        SET INCRX = 0\n        SET N0 = 20\n        SET N  = 0\n        SET I = 0\n        SET LP = &STR((\n        SET BLANKS = &STR(                                     )\n        /*********\n        SET I = 1\n       DO WHILE &I <= 48\n        SET TOKEN = &&TOK&I\n        SET TOKEN = &STR(&SYSCAPS(&TOKEN))\n        IF DEBUG = &DEBUG THEN WRITE  &I  TOK&&I=&&TOK&I  TOKEN=&TOKEN\n        IF &STR(&TOKEN) = &STR() THEN GOTO END_TOK\n        IF ALL = &STR(&TOKEN) | NEXT = &STR(&TOKEN) | FIRST = &STR(&TOKEN) | LAS\n          SET &ZEDSMSG = &STR(&TOKEN INVALID)\n          SET &ZEDLMSG = &STR(\"&TOKEN\" NOT PROVIDED FOR NOR ARE NEXT ALL FIRST L\n          ISPEXEC   SETMSG MSG(ISRZ000)\n          EXIT CODE(12)\n        END\n        IF HELP = &STR(&TOKEN) | DEBUG = &STR(&TOKEN) -\n           | NX   = &STR(&TOKEN) | X     = &STR(&TOKEN) -\n           | AST  = &STR(&TOKEN) -\n           | ENTIRE = &STR(&TOKEN) -\n           | REPEATX = &STR(&TOKEN) -\n           | FORCE  = &STR(&TOKEN) -\n           THEN DO\n             SET &&TOKEN.    = &STR(&TOKEN)\n             IF DEBUG = &DEBUG THEN WRITE  &I  TOK&I=&TOK&&I  TOKEN=&TOKEN\n             GOTO NXT_TOK\n           END\n        IF &SUBSTR(1:5,&STR(&TOKEN)       ) = &STR(INCR&STR(&LP))  THEN DO\n           SET INCR   = &SUBSTR(6:&EVAL(&LENGTH(&STR(&TOKEN))-1),&STR(&TOKEN)\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:4,&STR(&TOKEN)       ) = &STR(ADD&STR(&LP))  THEN DO\n           SET ADD   = &SUBSTR(5:&EVAL(&LENGTH(&STR(&TOKEN))-1),&STR(&TOKEN)\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:4,&STR(&TOKEN)       ) = &STR(COL&STR(&LP))  THEN DO\n           SET COL   = &SUBSTR(5:&EVAL(&LENGTH(&STR(&TOKEN))-1),&STR(&TOKEN)\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:6,&STR(&TOKEN)       ) = &STR(BEGIN&STR(&LP))  THEN DO\n           SET BEGIN   = &SUBSTR(7:&EVAL(&LENGTH(&STR(&TOKEN))-1),&STR(&TOKEN)\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:2,&STR(&TOKEN)       ) = &STR(L&STR(&LP))  THEN DO\n           SET L     = &SUBSTR(3:&EVAL(&LENGTH(&STR(&TOKEN))-1),&STR(&TOKEN)\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1:4,&STR(&TOKEN)       ) = &STR(AST&STR(&LP))  THEN DO\n           SET AST   = &SUBSTR(5:&EVAL(&LENGTH(&STR(&TOKEN))-1),&STR(&TOKEN)\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1,&TOKEN) = &STR(.) THEN DO\n           IF &LABF = &STR() THEN DO\n              SET LABF = &STR(&TOKEN)\n              GOTO NXT_TOK\n           END\n           IF &STR(&LABL) = &STR() THEN DO\n              SET LABL = &STR(&TOKEN)\n              GOTO NXT_TOK\n           END\n          SET &ZEDSMSG = &STR(LABEL &STR(&TOKEN))\n          SET &ZEDLMSG = &STR(EXACTLY TWO LABELS ARE REQUIRED FOUND   \"&LABF\", \"\n          ISPEXEC   SETMSG MSG(ISRZ000)\n          EXIT CODE(12)\n        END\n        IF &STR(&TOKEN) = &STR()) THEN DO\n           SET &ZEDSMSG = &STR(LOST PARENTHESIS)\n           SET &ZEDLMSG = BLANKS SEPARATE ALL OPERANDS; THEREFORE INVALID IN FRO\n           ISPEXEC SETMSG MSG(ISRZ000)\n           EXIT CODE(12)\n        END\n        SET REMAIN = &STR(&REMAIN &STR(&TOKEN))\n NXT_TOK: -\n        SET I = &I + 1\n      END\n END_TOK: SET I = &I\n      /*****************************************************************\n        /*****************************************************************\n        IF &STR(&REMAIN) ^= &STR() THEN DO\n               SET &ZEDSMSG = &STR(UNKNOW -- &REMAIN.)\n               SET &ZEDLMSG = &STR(PARAMETERS UNKNOWN -- &REMAIN.)\n               ISPEXEC     SETMSG MSG(ISRZ000)\n               EXIT CODE(12)\n        END\n        IF AST = &STR(&AST) THEN SET AST = &STR(*)\n        IF &STR(&L) = &STR() THEN SET L = 6\n        IF ENTIRE = &ENTIRE  | &STR(&LABL) = THEN DO      /************* LABELS\n           IF &LABF = &STR() THEN DO\n              SET LABF = .ZFIRST\n              SET LABL = .ZLAST\n           END\n           ELSE DO\n              SET &ZEDSMSG = &STR(LABEL CONFLICT)\n              SET &ZEDLMSG = &STR(\"ENTIRE\" IMPLIES .ZFIRST .ZLAST CONFLICTS WITH\n              ISPEXEC     SETMSG MSG(ISRZ000)\n              EXIT CODE(12)\n           END\n        END\n        IF &LABL = &STR() THEN DO\n              SET &ZEDSMSG = MISSING LABEL(S)\n              SET &ZEDLMSG = &STR(&ZEDSMSG -- A PAIR OF LABELS OR \"ENTIRE\" IS RE\n              ISPEXEC     SETMSG MSG(ISRZ000)\n              EXIT CODE(12)\n        END\n        ISREDIT (#LABF) = LINENUM &LABF\n        IF &LASTCC ^= 0 THEN DO\n                   SET &ZEDSMSG = &STR(&LABF. LABEL)\n                   SET &ZEDLMSG = &STR(&ZEDSMSG DOES NOT EXIST)\n                   ISPEXEC     SETMSG MSG(ISRZ000)\n                   EXIT CODE(12)\n        END\n        ISREDIT (#LABL) = LINENUM &LABL\n        IF &LASTCC ^= 0 THEN DO\n                   SET &ZEDSMSG = &STR(&LABL. LABEL)\n                   SET &ZEDLMSG = &STR(&ZEDSMSG DOES NOT EXIST)\n                   ISPEXEC     SETMSG MSG(ISRZ000)\n                   EXIT CODE(12)\n        END\n        /********************************** END OF LABEL REQUIREMENTS **********\n        ISREDIT (DWIDTH) = DATA_WIDTH\n        SET DWIDTH2 = &DWIDTH + &DWIDTH     /* CAN BE USED TO FORCE AN ERROR */\n        ISREDIT (LBOUND,RBOUND) = BOUNDS\n        ISREDIT (VAR019,VAR020) = DISPLAY_COLS\n        /****************************/\n        ISREDIT (VAR057) = RECFM\n        ISREDIT (VAR049,VAR050) = NUMBER\n        SET LLBOUND = &LBOUND\n        SET LLADJ = 0\n        IF &VAR057 = V AND &VAR049 = ON THEN DO\n           SET LLADJ = 8\n           SET LLBOUND = &LBOUND + 8\n        END\n        /****************************/\n        /************************************** CODE FOR  MANRLAB COMMANDS *****\n        /************************************** CODE FOR  MANRLAB COMMANDS *****\n        /************************************** CODE FOR  MANRLAB COMMANDS *****\n        IF &LABL = &STR() THEN DO\n              SET &ZEDSMSG = MISSING LABEL(S)\n              SET &ZEDLMSG = &STR(&ZEDSMSG -- A PAIR OF LABELS OR \"ENTIRE\" IS RE\n              ISPEXEC     SETMSG MSG(ISRZ000)\n              EXIT CODE(12)\n        END\n    WRITE MANRLAB &LABF. &LABL. BEGIN(&BEGIN.) INCR(&INCR.)\n    ISREDIT LINE_BEFORE &LABF = NOTELINE \"MANRLAB &LABF. &LABL. BEGIN(&BEGIN.) I\n    ISREDIT C ALL &LABF. &LABL. 1 P'##$##' '     '\n    ISREDIT X ALL\n    ISREDIT REMDUPS &LABF. &LABL. SEP 1 44\n    ISREDIT @SEQ &LABF. &LABL. REPEATX COL(1) BEGIN(&BEGIN.) INCR(&INCR.) L(4) n\n    ISREDIT REFORMAT &LABF. &LABL. 1 2 '.' 3 4 '-' 7 250\n    ISREDIT x all    &LABF. &LABL.\n    ISREDIT f all    &LABF. &LABL. 7 '====== remdups sep ======'\n    ISREDIT del all  &LABF. &LABL. nx\n    ISREDIT reset    &LABF. &LABF.\n    ISREDIT reset    &LABL. &LABL.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MANUALS": {"ttr": 8450, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x0e\\x00\\x0e\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "MCRITCH"}, "text": "CONTROL NOMSG\nFREE ATTRLIST(VB255)\nDELETE MANUALS.TEMP\nCONTROL MSG\nATTRIB VB255 DSORG(PS) RECFM(V B) LRECL(255) BLKSIZE(6356)\nALLOCATE DDNAME(MANUALS) REUSE DSNAME(&SYSUID..MANUALS.TEMP) NEW  +\n         UNIT(TESTDISK)  BLOCK(6356) SPACE(28,7) USING(VB255)\nFREE ATTR(VB255)\nALLOCATE DDNAME(INPUT) REUSE DSNAME('TECH.LIBR.MANUALS') SHR\nREPRO INFILE(INPUT) OUTFILE(MANUALS)\nFREE DDNAME(INPUT)\nWRITENR EDIT WILL OCCUR AUTOMATICALLY, HIT ENTER WHEN THREE ASTERISKS APPEAR\nISPEXEC EDIT DATASET(&SYSUID..MANUALS.TEMP)\nFREE DDNAME(MANUALS) DELETE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MODELC": {"ttr": 8452, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x19\\x00\\x19\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "MCRITCH"}, "text": "  PROC 1 MEMBER EDIT\n       SET BROWSE = BROWSE\n       IF &SYSCAPS(&STR(&EDIT)) = EDIT THEN SET BROWSE = EDIT\n       IF &STR(&MEMBER.) = &STR(*) THEN DO\n          SET CHK =  &STR(&SYSDSN('TSOMODEL.PUBLIC.CNTL')\n          IF &STR(&CHK.) = OK THEN -\nISPEXEC           &BROWSE DATASET('TSOMODEL.PUBLIC.CNTL')\n          ELSE -\n                  WRITE:  DATASET 'TSOMODEL.PUBLIC.CNTL' &STR(&CHK.)\n          EXIT CODE(0)\n       END\n       SET CHK =  &STR(&SYSDSN('TSOMODEL.PUBLIC.CNTL(&MEMBER.)')\n       IF &STR(&CHK.) = OK THEN -\nISPEXEC     &BROWSE DATASET('TSOMODEL.PUBLIC.CNTL(&MEMBER.)')\n       ELSE -\n       DO\n     WRITE : YOU CAN BROWSE ALL MEMBERS IN TURN USING\n     WRITE :                TSO MODELC *\n     WRITE\n     WRITE\n     WRITE :  MEMBER &MEMBER NOT FOUND - GIVING YOU BACK THE DIRECTORY\n     WRITE :  SAME AS IF YOU USED -      TSO MODELC *\nISPEXEC &BROWSE DATASET('TSOMODEL.PUBLIC.CNTL')\n       END\n EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MODELL": {"ttr": 8454, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x009\\x009\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "MCRITCH"}, "text": "  PROC 1 NODE3\n  SET BLANK =\n       SET DSN = TSOMODEL.PUBLIC\n       SET CHK =  &STR(&SYSDSN('&DSN..&NODE3.')\n       IF &STR(&CHK.) = OK THEN -\nISPEXEC     BROWSE DATASET('&DSN..&NODE3.')\n       ELSE -\n       DO\n/*************************************************************/\n/*MODIFIED SUBSET OF CODE EXTRACT FROM IS0R.LIBR.CNTL(ZCMDOUT) **1985/07/03 ***/\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\nCLRSCRN   /*KLUDGE -- MUST APPEAR BEFORE SYSOUTTRAP*/\n          WRITE PLEASE STAND BY -- NOW DOING LISTCAT FOR &DSN.\n          WRITE WILL TAKE ABOUT ONE SECOND PER DSN FOUND.\nSET SYSOUTTRAP = 120\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/* TRY THE LISTC LEVEL COMMAND                               */\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\nLISTC LEVEL(&DSN.) NAMES\nSET CC = &LASTCC\nCONTROL MSG\nIF &CC ^= 0 +\nTHEN DO\n  WRITE\n  WRITE *** ERROR(&CC):  LISTC LEVEL(&DSN.) FAILED.\n  WRITE\n  GOTO EXIT\nEND\nSET &I = 1\nSET &X = 0\n/*WRITE \"CLEAR SCREEN AND HIT ENTER\"\n/*READ XYZ\nDO WHILE &I <= &SYSOUTLINE\n  SET &DSNT = &&SYSOUTLINE&I\n  SET &LENDSN= &LENGTH(&STR(&DSNT))\n  IF &STR(&SUBSTR(1:7,&DSNT)) = NONVSAM +\n  THEN DO\n    SET &X = &X + 1\n    SET &DSN&X = &STR(&SUBSTR(17:&LENDSN,&DSNT))\n    SET &DSNT = &&DSN&X\n    IF &X. < 10 THEN WRITE 0&X.   &DSNT.\n    ELSE  WRITE &X.   &DSNT.\n  END\n  SET &I = &I + 1\nEND\nEXIT: +\n            WRITE\n/******** END OF CODE EXTRACTED FROM IS0R.LIBR.CNTL(ZCMDOUT) */\n/*************************************************************/\n            WRITE &BLANK.     THIRD NODE WAS INVALID IN ATTEMPT TO BROWSE FROM T\n            WRITE &BLANK.              \"&DSN..&NODE3.\"\n            WRITE\n/*          LISTCAT LEVEL('&DSN.') NAMES\n            WRITE &BLANK.     SELECT CORRECT THIRD NODE FROM THE &X DATASETS SHO\n            WRITE &BLANK.     REENTER CORRECTLY E.G. TSO MODELL ASM\n       END\n EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MODELT": {"ttr": 8456, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00&\\x00&\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "MCRITCH"}, "text": "PROC 1 MEMBER EDIT\nSET BROWSE = BROWSE\nIF &SYSCAPS(&STR(&EDIT)) = EDIT THEN SET BROWSE = EDIT\nIF &STR(&MEMBER.) = &STR(*) THEN DO\n   SET CHK =  &STR(&SYSDSN('TSOMODEL.PUBLIC.TEXT')\n   IF &STR(&CHK.) = OK THEN -\n      ISPEXEC &BROWSE DATASET('TSOMODEL.PUBLIC.TEXT')\n   ELSE WRITE:  DATASET 'TSOMODEL.PUBLIC.TEXT' &STR(&CHK.)\n   EXIT CODE(0)\nEND\nIF &LENGTH(&STR(&MEMBER.)) > 8 THEN DO\n   WRITE &STR() THE SPECIFIED MEMBERNAME \"&MEMBER\" EXCEEDS 8 +\n       BYTES  LENGTH IS &LENGTH(&MEMBER)\n   EXIT CODE(12)\nEND\nSET MULTIMEM = &SYSINDEX(&STR(*),&STR(&MEMBER.))\nIF &MULTIMEM = 0 THEN -\n   SET MULTIMEM = &SYSINDEX(&STR(%),&STR(&MEMBER.))\nIF &MULTIMEM > 0 THEN DO\n   $&BROWSE. TSOMODEL.PUBLIC.TEXT(&MEMBER.)\n   EXIT CODE(&LASTCC.)\nEND\nSET CHK =  &STR(&SYSDSN('TSOMODEL.PUBLIC.TEXT(&MEMBER.)')\nIF &STR(&CHK.) = OK THEN -\nISPEXEC &BROWSE DATASET('TSOMODEL.PUBLIC.TEXT(&MEMBER.)')\nELSE DO\n   WRITE : You can browse all members in turn using\n   WRITE :                tso modelt *\n   WRITE : which gets you to the directory.\n   WRITE\n   WRITE\n   WRITE :  MEMBER &MEMBER NOT FOUND - GIVING YOU BACK THE INDEX MEMBER\n   WRITE :       WHEN YOU HAVE LOCATED THE CORRECT MEMBER\n   WRITE :          PLEASE REENTER ON THE COMMAND LINE\n   WRITE :                TSO MODELT xxxxx\n   ISPEXEC &BROWSE DATASET('TSOMODEL.PUBLIC.TEXT(INDEX)')\nEND\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MURPHY": {"ttr": 8458, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x15\\x02\\x15\\x02\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 5378, "newlines": 5378, "modlines": 0, "user": "MCRITCH"}, "text": "/* Based on CBT 300 -- used in conjunction with Murphy -- REXX*/\n/*  at \"The REXX Macros Toolbox\" for additional sayings.      */\n/*  Murphy STRIKES AGAIN.   Spellings were corrected with the aid */\n/*  our version of SPELL.                                         */\n/*----------------------------------------------------------------- */\n/*  'CBT' FILE429 -- MURPHYVM -- installed as MURPHY                */\n/* THIS IS A REXX EXEC BUT COULD BE CONVERTED TO A CLIST FOR TSO    */\n/* IF YOU DON'T HAVE A RANDOM NUMBER GENERATOR UNDER TSO THEN       */\n/* CONSIDER USING SOME VARIATION OF THE TIME.                       */\n/* Additions after #375 were based on CBT 300 which matched 1-374.  */\n/* Additions after #1228 were added subsequently, and all changes   */\n/* to mixed case and spelling corrections were made locally.        */\n/* CBT -- 300, 429, 472, and locally included material.             */\n/*----------------------------------------------------------------- */\n/*  ===> MURPHY           ===> MURPHY 300:304     ===> MURPHY :     */\n/*  ===> MURPHY ALL DCF                                             */\n MLMAX = 1308\n ML = RANDOM(MLMAX)\n arg user DCF\n user=translate(user)\n\n if user = \"\" then do; fromx=ml; tox=ml; end;\n else if user = \"ALL\" then do; fromx=0; tox=mlmax; end\n else if pos(\":\",user) > 0 then do\n    parse var user fromx \":\" tox;\n    if fromx = \"\" then fromx=ml;\n    if tox = \"\" then tox = ml + 3\n    ml=fromx\n end\n else do; fromx=user; tox=user; end;\n\n if datatype(fromx,'N') = 0  |,\n    if datatype(tox,'N') = 0 then do;   x= 'Murphy''s Law arg' user,\n         'in error, must be blank, number or range'\n       x=x||'<' mlmax ' anyway....'; say x;\n    fromx=random(mlmax); tox=fromx; ml=fromx;\n end\n\n if ml > mlmax then do\n    x=  'Murphy''s Law arg' ml 'in error, exceeds max of ' mlmax'.  ';\n    x=x||'Correct input arg and retry.  (in MURPHY2)'; say x; exit\n end\n If fromx \\= tox then do /* suggest ===> TSO TSOTRAP MURPHY02 ALL DCF*/\n    if \"DCF\" = translate(DCF) then do\n      say '.* ===> SCRIPTPS dev(PSA90) PU FP(1)'\n      say '.pm .7i;.ll 9.8i;.cl 3.0i'\n      say '.cd 3 0 3.3i 6.6i;.fo left'\n      say '.df type7 type(7);.bf type7 =;'\n      say '.su off;.dc gml off;.dc cont off;.tp 0'\n      say '.$id'\n      say '.* indent lines by one, and insert &$TAB. char, or use...'\n      say '.fo off fold;.li on'\n      say date('u') time() 'Murphy';say ' ';say ' '\n    end\n    do ml = fromx to tox;\n       say center('-- '||ML||' --',60)\n       MLS = \"ML\"||ML\n       INTERPRET \"CALL\" MLS\n    end\n    if \"DCF\" = translate(DCF) then do\n       say date('u') time() 'Murphy';say ' ';say ' ';\n       say '.li off'\n       say '.pf;.su on;.lastpage;.pa odd'\n    end\n    EXIT\n end\n /* Normal single use or blank entry comes here*/\n say center('-- '||ML||' in Murphy --',60)\n MLS = \"ML\"||fromx\n INTERPRET \"CALL\" MLS\n exit\nML0:\nsay 'When things are going well, someone will inevitably.'\nsay 'experiment detrimentally.'\n  return\nML1:\nsay 'If not controlled, work will flow to the competent'\nsay 'man until he submerges.'\n  return\nML2:\nsay 'A deficiency will never show itself during the test runs.'\n  return\nML3:\nsay 'The lagging activity in a project will invariably be found'\nsay 'in the area where the highest overtime rates lie waiting.'\n  return\nML4:\nsay 'It is impossible to build a fool proof system;'\nsay 'because fools are so ingenious.'\n  return\nML5:\nsay 'Talent in staff work or sales will continually be'\nsay 'interpreted as managerial ability.'\n  return\nML6:\nsay 'Information travels more surely to those with a'\nsay 'lesser need to know.'\n  return\nML7:\nsay 'The \"think positive\" leader tends to listen to his'\nsay 'subordinate''s premonitions only during the postmortems.'\n  return\nML8:\nsay 'An original idea can never emerge from committee'\nsay 'in its original form.'\n  return\nML9:\nsay 'No good deed goes unpunished.'\n  return\nML10:\nsay 'When the product is destined to fail, the delivery system'\nsay 'will perform perfectly.'\n  return\nML11:\nsay 'Clearly stated instructions will consistently produce'\nsay 'multiple interpretations.'\n  return\nML12:\nsay 'The crucial memorandum will be snared in the out-basket by'\nsay 'the paper clip of the overlying memo and go to file.'\n  return\nML13:\nsay 'On successive charts of the same organization the number of'\nsay 'boxes will never decrease.'\n  return\nML14:\nsay 'It is ok to be ignorant in some areas,'\nsay 'but some people abuse the privilege.'\n  return\nML15:\nsay 'Everyone breaks more than the seven-year-bad-luck allotment'\nsay 'to cover rotten luck throughout an entire lifetime.'\n  return\nML16:\nsay 'Success can be insured only by devising a defense against'\nsay 'failure of the contingency plan.'\n  return\nML17:\nsay 'Adding manpower to a late software product makes it later.'\n  return\nML18:\nsay 'Performance is directly affected by the perversity of'\nsay 'inanimate objects.'\n  return\nML19:\nsay 'Leakproof seals --- Will.'\n  return\nML20:\nsay 'Never offend people with style'\nsay 'when you can offend them with substance.'\n  return\nML21:\nsay 'Our customers paperwork is profit'\nsay 'our own paperwork is loss.'\n  return\nML22:\nsay 'At any level of traffic, any delay is intolerable.'\n  return\nML23:\nsay 'As the economy gets better, everything else gets worse.'\n  return\nML24:\nsay 'This space for rent'\nsay '    ...'\nsay '    ...'\n  return\nML25:\nsay 'The more directives you issue to solve a problem,'\nsay 'the worse it gets.'\n  return\nML26:\nsay 'Cop-out Number 1:'\nsay '  You should have seen it when I got it.'\n  return\nML27:\nsay 'When you''re up to your ass in alligators, it is'\nsay 'difficult to keep your mind on the fact that your primary'\nsay 'objective was to drain the swamp.'\n  return\nML28:\nsay 'The road to hell is paved with good intentions'\nsay 'and littered with sloppy analyses!'\n  return\nML29:\nsay 'Self starters --- Won''t.'\n  return\nML30:\nsay 'If the assumptions are wrong,'\nsay 'the conclusions aren''t likely to be very good.'\n  return\nML31:\nsay 'The organization of any program reflects the organization'\nsay 'of the people who developed it.'\n  return\nML32:\nsay 'There is no such thing as a \"Dirty Capitalist\",'\nsay 'only a capitalist.'\n  return\nML33:\nsay 'Anything is possible, but nothing is easy.'\n  return\nML34:\nsay 'The meek will inherit the earth'\nsay 'after the rest of us go to the stars.'\n  return\nML35:\nsay 'Capitalism can exist in one of only two states:'\nsay '  Welfare or warfare.'\n  return\nML36:\nsay 'History proves nothing.'\n  return\nML37:\nsay 'A lot of what appears to be progress is just so much'\nsay 'technological rococo.'\n  return\nML38:\nsay 'A little humility is arrogance.'\n  return\nML39:\nsay 'Interchangeable parts --- Won''t.'\n  return\nML40:\nsay 'Any time you wish to demonstrate something, the number of'\nsay 'faults is proportional to the number of viewers.'\n  return\nML41:\nsay 'All American cars are basically Chevrolets.'\n  return\nML42:\nsay 'A coup that is known in advance is a coup that does not'\nsay 'take place.'\n  return\nML43:\nsay 'No experiment is ever a complete failure.'\nsay 'it can always be used as a bad example.'\n  return\nML44:\nsay 'Despite the sign that says \"wet paint\",'\nsay 'please don''t'\n  return\nML45:\nsay 'Everything tastes more or less like chicken.'\n  return\nML46:\nsay 'People don''t change; they only become more so.'\n  return\nML47:\nsay 'I finally got it all together...'\nsay 'but I forgot where I put it.'\n  return\nML48:\nsay 'If your next pot of chili tastes better, it probably is'\nsay 'because of something left out, rather than added.'\n  return\nML49:\nsay 'There is always one more bug.'\n  return\nML50:\nsay 'The big guys always win.'\n  return\nML51:\nsay 'Nothing is ever accomplished by a reasonable man.'\n  return\nML52:\nsay 'Any sufficiently advanced technology is'\nsay 'indistinguishable from magic.'\n  return\nML53:\nsay 'It''s always darkest just before the lights go out.'\n  return\nML54:\nsay 'It is better to be part of the idle rich class'\nsay 'than be part of the idle poor class.'\n  return\nML55:\nsay 'Each problem solved introduces a new unsolved problem.'\n  return\nML56:\nsay 'For every credibility gap there is a gullibility fill.'\n  return\nML57:\nsay 'If you have something to do, and you put it off long enough'\nsay 'chances are someone else will do it for you.'\n  return\nML58:\nsay 'Everybody''s gotta be someplace.'\n  return\nML59:\nsay 'Nature is a mother.'\n  return\nML60:\nsay 'If you''ve got them by the balls,'\nsay 'their hearts and minds will follow.'\n  return\nML61:\nsay 'People will accept your idea much more readily if you tell'\nsay 'them Benjamin Franklin said it first.'\n  return\nML62:\nsay 'If at first you don''t succeed, transform your dataset.'\n  return\nML63:\nsay 'Any given program, when running, is obsolete.'\n  return\nML64:\nsay 'Any given program cost more and take longer.'\n  return\nML65:\nsay 'If a program is useful, it will be changed.'\n  return\nML66:\nsay 'If a program is useless, it will be documented.'\n  return\nML67:\nsay 'Any given program will expand to fill all available memory.'\n  return\nML68:\nsay 'The value of a program is proportional'\nsay 'to the weight of its output.'\n  return\nML69:\nsay 'Don''t mess with Mrs. Murphy!'\n  return\nML70:\nsay 'Program complexity grows until it exceeds the capability'\nsay 'of the programmer who must maintain it.'\n  return\nML71:\nsay 'Make it possible for programmers to write programs'\nsay 'in English and you will find that programmers cannot'\nsay 'write in English.'\n  return\nML72:\nsay 'When more and more people are thrown out of work'\nsay 'unemployment results.'\n  return\nML73:\nsay 'If you can''t measure it, I''m not interested.'\n  return\nML74:\nsay 'The best way to lie is to tell the truth.....'\nsay 'carefully edited truth.'\n  return\nML75:\nsay 'There are three ways to get things done'\nsay 'do it yourself'\nsay 'hire someone to do it or'\nsay 'forbid your kids to do it.'\n  return\nML76:\nsay 'I think ... Therefore I am confused'\n  return\nML77:\nsay 'A fail-safe circuit will destroy others.'\n  return\nML78:\nsay 'History repeats itself.'\nsay 'that''s one of the things wrong with history.'\n  return\nML79:\nsay '90% of everything is crud.'\n  return\nML80:\nsay 'Nature will tell you a direct lie if she can.'\n  return\nML81:\nsay 'Those with the best advice offer no advice.'\n  return\nML82:\nsay 'Speak softly and own a big, mean doberman.'\n  return\nML83:\nsay 'Democracy is that form of government where'\nsay 'everybody gets what the majority deserves.'\n  return\nML84:\nsay 'If you''re worried about being crazy,'\nsay 'don''t be overly concerned:'\nsay 'If you were, you would think you were sane.'\n  return\nML85:\nsay 'Pills to be taken in twos always come'\nsay 'out of the bottle in threes.'\n  return\nML86:\nsay 'Flynn is dead'\nsay 'Tron is dead'\nsay 'long live the MCP.'\n  return\nML87:\nsay 'Why worry about tomorrow?  We may not make it through today!'\n  return\nML88:\nsay 'Real programmers don''t number paragraph names'\nsay 'consecutively.'\n  return\nML89:\nsay 'If you''re feeling good, don''t worry,'\nsay 'you''ll get over it.'\n  return\nML90:\nsay 'Real programmers don''t grumble about the disadvantages'\nsay 'of COBOL when they don''t know any other language.'\n  return\nML91:\nsay 'Definition of an elephant:'\nsay '  A mouse built to government specifications.'\n  return\nML92:\nsay 'Real programmers are kind to rookies.'\n  return\nML93:\nsay 'Real programmers don''t notch their desks for each'\nsay 'completed service request.'\n  return\nML94:\nsay 'You don''t have to be crazy to work here'\nsay 'but it sure helps!!!!!!!'\n  return\nML95:\nsay 'Real programmers don''t announce how many times the'\nsay 'operations department called them last night.'\n  return\nML96:\nsay 'A day without sunshine ....'\nsay 'is like ... Night!'\n  return\nML97:\nsay 'Real programmers are secure enough to write readable code,'\nsay 'which they then self-righteously refuse to explain.'\n  return\nML98:\nsay 'Real programmers don''t play video games, they write   them.'\n  return\nML99:\nsay 'Anything that can go wrong, will go wrong.'\n  return\nML100:\nsay 'Real programmers understand Pascal.'\n  return\nML101:\nsay 'Real programmers know it''s not operations'\nsay 'fault if their jobs go into \"hogs.\"'\n  return\nML102:\nsay 'Real programmers do not eat breakfast from the'\nsay 'vending machines.'\n  return\nML103:\nsay 'Real programmers punch up their own programs.'\n  return\nML104:\nsay 'When life hands you a lemon'\nsay 'make lemonade.'\n  return\nML105:\nsay 'Real programmers have read the standards manual'\nsay 'but won''t admit it.'\n  return\nML106:\nsay 'Real programmers don''t advertise their hangovers.'\n  return\nML107:\nsay 'Real programmers don''t dress for success unless'\nsay 'they are trying to convince others that they are'\nsay 'going on interviews.'\n  return\nML108:\nsay 'Real programmers do not practice four-syllable words before'\nsay 'walkthroughs.'\n  return\nML109:\nsay 'All warranties expire upon payment of invoice.'\n  return\nML110:\nsay 'Real programmers argue with the systems analyst as a'\nsay 'matter of principle.'\n  return\nML111:\nsay 'The final test is when it goes production ...'\nsay 'W H E N I T  G O E S   P R O D U C T I O N  ...'\nsay 'W H E N     I  T     G  O  E  S     P  R  O  D  U  C  T'\nsay 'W H  E   N       I   T       G   O   E   S       P   R   O'\n  return\nML112:\nsay 'Real programmers drink too much coffee so that they will'\nsay 'always seem tense and overworked.'\n  return\nML113:\nsay 'Real programmers always have a better idea.'\n  return\nML114:\nsay 'Anyone who follows a crowd will'\nsay 'never be followed by a crowd.'\n  return\nML115:\nsay 'Real programmers can do octal, hexadecimal and'\nsay 'binary math in their heads.'\n  return\nML116:\nsay 'Real programmers don''t write memos.'\n  return\nML117:\nsay 'Real programmers know what saad means.'\n  return\nML118:\nsay 'Real programmers do not utter profanities at an elevated'\nsay 'decibel level.'\n  return\nML119:\nsay 'Where you stand on an issue depends on where you sit.'\n  return\nML120:\nsay 'Real programmers do not apply DP terminology to non-DP'\nsay 'situations.'\n  return\nML121:\nsay 'I no longer get lost in the shuffle....'\nsay 'I shuffle along with the lost.'\n  return\nML122:\nsay 'Real programmers do not read books like'\nsay '\"Effective Listening\" and \"Communication Skills\".'\n  return\nML123:\nsay 'Real programmers print only clean compiles,'\nsay 'fixing all errors through the terminal.'\n  return\nML124:\nsay 'The early worm deserves the bird.'\n  return\nML125:\nsay 'Lead, follow, or get the hell out of the way!!'\n  return\nML126:\nsay 'All good things must come to an end.'\nsay 'I want to know when they start!'\n  return\nML127:\nsay 'A diplomat is someone who can tell you to go to hell'\nsay 'in such a way that you look forward to the trip.'\n  return\nML128:\nsay 'Blessed are those who go around in circles,'\nsay 'for they shall be known as wheels.'\n  return\nML129:\nsay 'Never eat prunes when you are famished.'\n  return\nML130:\nsay 'Keep emotionally active,'\nsay 'cater to your favorite neurosis.'\n  return\nML131:\nsay 'A RACF protected dataset is inaccessible.'\n  return\nML132:\nsay 'RACF is a four letter word.'\n  return\nML133:\nsay 'You may be recognized soon.'\nsay 'Hide!'\nsay 'If they find you, lie.'\n  return\nML134:\nsay 'You can pray hard enough to make water run uphill.'\nsay 'How hard?'\nsay 'Hard enough to make water run uphill.'\n  return\nML135:\nsay 'Avoid reality at all costs.'\n  return\nML136:\nsay 'Program design philosophy:'\nsay 'Start at the beginning and continue until the end,'\nsay 'then stop.            (Lewis Carroll)'\n  return\nML137:\nsay 'A closed mouth gathers no foot.'\n  return\nML138:\nsay 'Only a mediocre person is always at their best.'\n  return\nML139:\nsay 'Friends come and go, but enemies accumulate.'\n  return\nML140:\nsay 'In a hierarchical organization, the higher the level,'\nsay 'the greater the confusion.'\n  return\nML141:\nsay 'The first time is for love'\nsay 'the next time is $200.'\n  return\nML142:\nsay 'Of two possible events,'\nsay 'only the undesired one will occur.'\n  return\nML143:\nsay 'The faster the plane,'\nsay 'the narrower the seats.'\n  return\nML144:\nsay 'If you have to ask, you are not entitled to know.'\n  return\nML145:\nsay 'If on an actuarial basis there is a 50 50 chance that'\nsay 'something will go wrong,'\nsay 'it will actually go wrong nine times out of ten.'\n  return\nML146:\nsay 'A man of quality does not fear a woman seeking equality.'\n  return\nML147:\nsay 'The first rule of intelligent tinkering is to'\nsay 'save all of the parts.'\n  return\nML148:\nsay '1) Things will get worse before they get better'\nsay '2) Who said things would get better?'\n  return\nML149:\nsay 'If you try to please everybody, nobody will like it.'\n  return\nML150:\nsay 'There is a solution to every problem;'\nsay 'the only difficulty is finding it.'\n  return\nML151:\nsay 'Don''t make your doctor your heir.'\n  return\nML152:\nsay 'Don''t ask the barber if you need a haircut.'\n  return\nML153:\nsay 'If there isn''t a law, there will be.'\n  return\nML154:\nsay 'If you don''t like the answer,'\nsay 'you shouldn''t have asked the question.'\n  return\nML155:\nsay 'Do not believe in miracles -- Rely on them.'\n  return\nML156:\nsay 'You can''t expect to hit the jackpot'\nsay 'if you don''t put a few nickels in the machine.'\n  return\nML157:\nsay 'Unless you intend to kill him immediately; never kick a man'\nsay 'in the balls, not even symbolically or perhaps especially'\nsay 'not symbolically.'\n  return\nML158:\nsay 'Freud''s 23rd Law:  Ideas endure and prosper in inverse'\nsay 'proportion to their soundness and validity.'\n  return\nML159:\nsay 'A short cut is the longest distance between two points.'\n  return\nML160:\nsay 'If you want to make an enemy, do someone a favor.'\n  return\nML161:\nsay 'If you know, you can''t say.'\n  return\nML162:\nsay 'The meek shall inherit the earth,'\nsay 'but not its mineral rights.'\n  return\nML163:\nsay '1) You can''t win'\nsay '2) You can''t break even'\nsay '3) You can''t even quit the game.'\n  return\nML164:\nsay 'When eating an elephant take one bite at a time.'\n  return\nML165:\nsay 'Common sense is not so common.'\n  return\nML166:\nsay 'If we learn by our mistakes,'\nsay 'I''m getting one hell of an education!!'\n  return\nML167:\nsay 'Fuzzy project objectives are used to avoid the'\nsay 'embarrassment of estimating the corresponding costs.'\n  return\nML168:\nsay 'Usefulness is inversely proportional to its reputation'\nsay 'for being useful.'\n  return\nML169:\nsay 'You will always find something in the last place you look.'\n  return\nML170:\nsay 'The probability of anything happening is in'\nsay 'inverse ratio to its desirability.'\n  return\nML171:\nsay 'The first myth of management is that it exists'\nsay 'the second myth of management is that success equals skill.'\n  return\nML172:\nsay 'If it''s good they will stop making it.'\n  return\nML173:\nsay 'Inside every large program'\nsay 'is a small program struggling to get out.'\n  return\nML174:\nsay 'A memorandum is written not to inform the reader'\nsay 'but to protect the writer.'\n  return\nML175:\nsay 'Never insult an alligator'\nsay 'until after you have crossed the river.'\n  return\nML176:\nsay 'Anything hit with a big enough hammer will fall apart.'\n  return\nML177:\nsay 'When your opponent is down, kick him.'\n  return\nML178:\nsay 'The man who can smile when things go wrong has thought of'\nsay 'someone he can blame it on.'\n  return\nML179:\nsay 'The chance of a piece of bread falling with the buttered side'\nsay 'down is directly proportional to the cost of the carpet.'\n  return\nML180:\nsay 'In the fight between you and the world, back the world.'\n  return\nML181:\nsay 'Last guys don''t finish nice.'\n  return\nML182:\nsay 'Never admit anything.'\nsay 'never regret anything'\nsay 'whatever it is, you''re not responsible.'\n  return\nML183:\nsay 'If you have always done it that way, it is probably wrong.'\n  return\nML184:\nsay 'When working toward the solution of a problem,'\nsay 'it always helps if you know the answer.'\nsay 'provided of course you know there is a problem.'\n  return\nML185:\nsay 'The usefulness of any meeting'\nsay 'is in inverse proportion to the attendance.'\n  return\nML186:\nsay 'The sun goes down just when you need it the most.'\n  return\nML187:\nsay 'Pure drivel tends to drive ordinary'\nsay 'drivel off the TV screen.'\n  return\nML188:\nsay 'Whatever creates the greatest inconvenience for the largest'\nsay 'number must happen.'\n  return\nML189:\nsay 'No matter how long or hard you shop for an item, after'\nsay 'you have bought it, it will be on sale somewhere cheaper.'\n  return\nML190:\nsay 'Sanity and insanity overlap a fine gray line.'\n  return\nML191:\nsay 'A disagreeable task is its own reward.'\n  return\nML192:\nsay 'If things were left to chance, they''d be better.'\n  return\nML193:\nsay 'The phone will not ring until you leave your desk and walk'\nsay 'to the other end of the building.'\n  return\nML194:\nsay 'Anybody can win - unless there happens to be a second entry.'\n  return\nML195:\nsay 'A president of a democracy is a man who is always ready,'\nsay 'willing, and able to lay down your life for his country.'\n  return\nML196:\nsay 'If a thing is done wrong often enough'\nsay 'it becomes right.'\n  return\nML197:\nsay 'People will buy anything that is one to a customer.'\n  return\nML198:\nsay 'If you just try long enough and hard enough, you can always'\nsay 'manage to boot yourself in the posterior.'\n  return\nML199:\nsay 'No one''s life, liberty, or property are safe'\nsay 'while the legislature is in session.'\n  return\nML200:\nsay 'Never say \"Oops\" after you have submitted a job.'\n  return\nML201:\nsay 'Bad news drives good news out of the media.'\n  return\nML202:\nsay 'Just when you get really good at something,'\nsay 'you don''t need to do it anymore.'\n  return\nML203:           /* expanded version */\nsay 'Maier''s Law  - If facts do not conform to the theory,'\nsay 'they must be disposed of.  Corollaries: '\nsay '1. The bigger the theory, the better.'\nsay '2. The experiment may be considered a success if no more'\nsay '   then 50% of the observed measurements must be'\nsay '   discarded to obtain a correspondence with theory.'\nML204:\nsay 'Almost anything is easier to get into than out of.'\n  return\nML205:\nsay 'When properly administered, vacations do not diminish'\nsay 'productivity.  For every week you are away and get nothing'\nsay 'done, there is another week when your boss is away and you'\nsay 'get twice as much done.'\n  return\nML206:\nsay 'No matter what happens, there is always somebody'\nsay 'who knew that it would.'\n  return\nML207:\nsay 'The other line always moves faster.'\n  return\nML208:\nsay 'Never eat at a place called Mom''s,'\nsay 'never play cards with a man named doc,'\nsay 'and never lie down with a woman who''s got more troubles than you.'\n  return\nML209:\nsay 'In order to get a loan, you must first prove you  don''t  need it.'\n  return\nML210:\nsay 'When all else fails, read the instructions.'\n  return\nML211:\nsay 'Anything you try to fix will take longer and cost more than'\nsay 'you thought.'\n  return\nML212:\nsay 'Close counts in horseshoes, handgrenades and'\nsay 'thermonuclear devices.'\n  return\nML213:\nsay 'The lion and the calf shall lie down together,'\nsay 'but the calf won''t get much sleep.'\n  return\nML214:\nsay 'If you fool around with a thing for very long',\n    'you will screw it up.'\n  return\nML215:\nsay 'It is better for civilization to be going down the drain,'\nsay 'than to be coming up it.'\n  return\nML216:\nsay 'A $300.00 picture tube will protect a 10\u00a2 fuse by blowing first.'\n  return\nML217:\nsay 'Justice always prevails...'\nsay 'three times out of seven.'\n  return\nML218:\nsay 'If it jams --- Force it.  If it breaks,'\nsay 'it needed replacing anyway.'\n  return\nML219:\nsay 'I have yet to see any problem, however complicated, which,'\nsay 'when you looked at it in the right way, did not become'\nsay 'still more complicated.     Poul Anderson'\n  Return\nML220:\nsay 'Any tool dropped while repairing a car will roll underneath'\nsay 'to the exact center.'\n  return\nML221:\nsay 'No matter which direction you start,'\nsay 'it''s always against the wind coming back.'\n  return\nML222:\nsay 'The repairman will never have seen a model quite like'\nsay 'yours before.'\n  return\nML223:\nsay 'Don''t force it,'\nsay 'get a bigger hammer.'\n  return\nML224:\nsay 'When a broken appliance is demonstrated for the repairman,'\nsay 'it will work perfectly.'\n  return\nML225:\nsay 'Pity the poor egg;'\nsay 'it only gets laid once in its life.'\n  return\nML226:\nsay 'An optimist is a person who looks forward to marriage.'\nsay 'a pessimist is a married optimist!'\n  return\nML227:\nsay 'A pessimist is an optimist with experience.'\n  return\nML228:\nsay 'Old programmers never die - they just abend.'\n  return\nML229:\nsay 'The success of any venture will be helped by prayer,'\nsay 'even in the wrong denomination.'\n  return\nML230:\nsay 'Just about the time when you think you can make ends meet'\nsay 'somebody moves the ends!'\n  return\nML231:\nsay 'Just because you are paranoid'\nsay 'doesn''t mean \"they\" aren''t out to get you.'\n  return\nML232:\nsay 'An Irishman is not drunk as long as'\nsay 'he can hang onto a single blade of grass'\nsay 'and not fall off the face of the earth.'\n  return\nML233:\nsay 'If an experiment works, you must be using the wrong equipment.'\n  return\nML234:\nsay 'Some come to the fountain of knowledge to drink,'\nsay 'some prefer to just gargle.'\n  return\nML235:\nsay 'Everything is revealed to he who turns over enough stones.'\nsay '(including the snakes that he did not want to find.)'\n  return\nML236:\nsay 'Everybody should believe in something;'\nsay 'I believe I''ll have another drink.'\n  return\nML237:\nsay 'Those whose approval you seek the most give you the least.'\n  return\nML238:\nsay 'Build a system that even a fool can use,'\nsay 'and only a fool will use it.'\n  return\nML239:\nsay 'You can lead a horticulture, but you can''t make her think .'\n  return\nML240:\nsay 'Everyone has a scheme for getting rich that will not work.'\n  return\nML241:\nsay 'It''s always the wrong time of the month.'\n  return\nML242:\nsay 'In any hierarchy, each individual rises to his own level'\nsay 'of incompetence, and then remains there.'\n  return\nML243:\nsay 'It does not matter if you fall down as long as you pick'\nsay 'up something from the floor while you get up.'\n  return\nML244:\nsay 'You will remember that you forgot to take out the trash'\nsay 'when the garbage truck is two doors away.'\n  return\nML245:\nsay 'Misery no longer loves company'\nsay 'nowadays it insists on it.'\n  return\nML246:\nsay 'The race is not always to the swift nor the battle to the'\nsay 'strong, but that''s the way to bet.'\n  return\nML247:\nsay 'Some of it plus the rest of it is all of it.'\n  return\nML248:\nsay 'There''s never time to do it right, but there''s always'\nsay 'time to do it over.'\n  return\nML249:\nsay 'On a beautiful day like this it''s hard to believe anyone'\nsay 'can be unhappy -- But we will work on it.'\n  return\nML250:\nsay 'When in doubt, mumble.  When in trouble, delegate.'\n  return\nML251:\nsay 'The more ridiculous a belief system,'\nsay 'the higher probability of its success.'\n  return\nML252:\nsay 'Anything good in life is either illegal, immoral or fattening.'\n  return\nML253:\nsay 'Old age is always fifteen years older than I am.'\n  return\nML254:\nsay 'It is morally wrong to allow suckers to keep their money.'\n  return\nML255:\nsay 'When you''re up to your nose .......,'\nsay 'be sure to keep your mouth shut.'\n  return\nML256:\nsay 'One''s life tends to be like a beaver''s,'\nsay 'one dam thing after another.'\n  return\nML257:\nsay 'A bird in hand is safer than one overhead.'\n  return\nML258:\nsay 'The ratio of time involved in work to time available for'\nsay 'work is usually about 0.6'\n  return\nML259:\nsay 'Remember the golden rule:'\nsay '  Those that have the gold make the rules.'\n  return\nML260:\nsay 'Blessed is he who has reached the point of no return and'\nsay 'knows it for he shall enjoy living.'\n  return\nML261:\nsay 'Everything east of the San Andreas fault will eventually'\nsay 'plunge into the Atlantic ocean.'\n  return\nML262:\nsay 'I finally got it all together.....'\nsay 'but I forgot where I put it.'\n  return\nML263:\nsay 'Nature always sides with the hidden flaw.'\n  return\nML264:\nsay 'Blessed is he who expects no gratitude,'\nsay 'for he shall not be disappointed.'\n  return\nML265:\nsay 'The light at the end of the tunnel is the headlamp of'\nsay 'an oncoming train.'\n  return\nML266:\nsay 'Celibacy is not hereditary.'\n  return\nML267:\nsay 'You can observe a lot just by watching.'\n  return\nML268:\nsay 'If it can be borrowed and it can be broken,'\nsay 'you will borrow it and'\nsay 'you will break it.'\n  return\nML269:\nsay 'Never sleep with anyone crazier than yourself.'\n  return\nML270:\nsay 'Live within your income,'\nsay 'even if you have to borrow to do so.'\n  return\nML271:\nsay 'Beauty is only skin deep, ugly goes clear to the bone.'\n  return\nML272:\nsay 'Never go to a doctor whose office plants have died.'\n  return\nML273:\nsay 'To know yourself is the ultimate form of aggression.'\n  return\nML274:\nsay 'An ounce of application is worth a ton of abstraction.'\n  return\nML275:\nsay 'Never play leapfrog with a unicorn.'\n  return\nML276:\nsay 'A bird in the hand is dead.'\n  return\nML277:\nsay 'A Smith and Wesson beats four aces.'\n  return\nML278:\nsay 'Never put all your eggs in your pocket.'\n  return\nML279:\nsay 'If everything seems to be going well,'\nsay 'you obviously don''t know what the hell is going on.'\n  return\nML280:\nsay 'If at first you don''t succeed,'\nsay 'blame it on your supervisor.'\n  return\nML281:\nsay 'If more than one person is responsible for a'\nsay 'miscalculation, no one will be at fault.'\n  return\nML282:\nsay 'Don''t bite the hand that has your pay check in it.'\n  return\nML283:\nsay 'In case of doubt, make it sound convincing.'\n  return\nML284:\nsay 'When in doubt, mumble.'\nsay 'When in trouble, delegate.'\nsay 'When in charge, ponder.'\n  return\nML285:\nsay 'Please don''t steal, the IRS hates competition!'\n  return\nML286:\nsay 'Never argue with a fool,'\nsay 'people might not know the difference.'\n  return\nML287:\nsay 'You can''t guard against the arbitrary.'\n  return\nML288:\nsay 'People can be divided into three groups:'\nsay '  Those who make things happen,'\nsay '  Those who watch things happen and'\nsay '  Those who wonder what happened.'\n  return\nML289:\nsay 'I no longer get lost in the shuffle,'\nsay 'I shuffle along with the lost.'\n  return\nML290:\nsay 'The one thing that money can not buy is poverty.'\n  return\nML291:\nsay 'You are not drunk if you can lay on the floor without holding on.'\n  return\nML292:\nsay 'In any household, junk accumulates to the space'\nsay 'available for its storage.'\n  return\nML293:\nsay 'Don''t stop to stomp on ants'\nsay 'when the elephants are stampeding.'\n  return\nML294:\nsay 'The longer the title the less important the job.'\n  return\nML295:\nsay 'Any improbable event which would create maximum confusion'\nsay 'if it did occur, will occur.'\n  return\nML296:\nsay 'When you are right be logical,'\nsay 'when you are wrong be-fuddle.'\n  return\nML297:\nsay 'For every human problem, there is a neat, plain solution --'\nsay 'and it is always wrong.'\n  return\nML298:\nsay 'There are no winners in life:  Only survivors.'\n  return\nML299:\nsay 'When they want it bad (in a rush), they get it bad.'\n  return\nML300:\nsay 'The yoo-hoo you yoo-hoo into the forest',\n     'is the yoo-hoo you get back.'\n  return\nML301:\nsay 'You can''t tell how deep a puddle is until you step into it.'\n  return\nML302:\nsay 'The idea is to die young as late as possible.'\n  return\nML303:\nsay 'No man is lonely while eating spaghetti.'\n  return\nML304:\nsay 'It''s better to retire too soon than too late.'\n  return\nML305:\nsay 'A man should be greater than some of his parts.'\n  return\nML306:\nsay 'If you don''t say it, they can''t repeat it.'\n  return\nML307:\nsay 'Nothing is ever as simple as it seems.'\n  return\nML308:\nsay 'Everything takes longer than you expect.'\n  return\nML309:\nsay 'Left to themselves, all things go from bad to worse.'\n  return\nML310:\nsay 'If you see that there are four possible ways in which a'\nsay 'procedure can go wrong, and circumvent these, then a'\nsay 'fifth way, unprepared for, will promptly develop.'\n  return\nML311:\nsay 'Things get worse under pressure.'\n  return\nML312:\nsay 'Persons disagreeing with your facts are always emotional'\nsay 'and employ faulty reasoning.'\n  return\nML313:\nsay 'A consultant is an ordinary person a long way from home.'\n  return\nML314:\nsay 'Progress is made on alternate fridays.'\n  return\nML315:\nsay 'The first 80 percent of the task takes 20 percent of the time,'\nsay 'the last 20 percent takes the other 80 percent.'\n  /* appears changed from an earlier version 80/90 20/10 */\n  return\nML316:\nsay 'If two wrongs don''t make a right, try three.'\n  return\nML317:\nsay 'Don''t look back, something may be gaining on you.'\n  return\nML318:\nsay 'All things being equal, all things are never equal.'\n  return\nML319:\nsay 'Even paranoids have enemies.'\n  return\nML320:\nsay 'Incompetence knows no barriers of time or place.'\n  return\nML321:\nsay 'Work is accomplished by those employees who have not yet'\nsay 'reached their level of incompetence.'\n  return\nML322:\nsay 'If at first you don''t succeed, try something else.'\n  return\nML323:\nsay 'If you''re coasting, you''re going downhill.'\n  return\nML324:\nsay 'Never tell them what you wouldn''t do.'\n  return\nML325:\nsay 'The amount of flak received on any subject is inversely'\nsay 'proportional to the subject''s true value.'\n  return\nML326:\nsay 'Indifference is the only sure defense.'\n  return\nML327:\nsay 'Whatever hits the fan will not be evenly distributed.'\n  return\nML328:\nsay 'Never needlessly disturb a thing at rest.'\n  return\nML329:\nsay 'If you want to get along, go along.'\n  return\nML330:\nsay 'Everything happens at the same time with nothing in between.'\n  return\nML331:\nsay 'The easiest way to find something lost around the house'\nsay 'is to buy a replacement.'\n  return\nML332:\nsay 'Bare feet magnetize sharp metal objects so they always'\nsay 'point upward from the floor -- Especially in the dark.'\n  return\nML333:\nsay 'Make three correct guesses consecutively and you will'\nsay 'establish yourself as an expert.'\n  return\nML334:\nsay 'It works better if you plug it in.'\n  return\nML335:\nsay 'Quit while your still behind.'\n  return\nML336:\nsay 'If you plan to leave your mark in the sands of time,'\nsay 'you better wear work shoes.'\n  return\nML337:\nsay 'It''s always easier to go down hill,',\n    ' but the best view is from the top.'\n  return\nML338:\nsay 'Any line, however short, is still too long.'\n  return\nML339:\nsay 'Laziness is the mother of nine inventions out of ten.'\n  return\nML340:\nsay 'If you can''t measure output then you measure input.'\n  return\nML341:\nsay 'Any theory can be made to fit any facts by means of appropriate'\nsay 'additional assumptions.' /* earlier version used story */\n  return\nML342:\nsay 'Old Scottish prayer: O Lord, grant that we may always be'\nsay 'right, for thou knowest we will never change our minds.'\n  return\nML343:\nsay 'Never be first to do anything.'\n  return\nML344:\nsay 'The chief cause of problems is solutions.'\n  return\nML345:\nsay 'The only winner in the war of 1812 was Tchaikovsky.'\n  return\nML346:\nsay 'A little ignorance can go a long way.'\n  return\nML347:\nsay 'Learn to be sincere.  Even if you have to fake it.'\n  return\nML348:\nsay 'Entropy has us outnumbered.'\n  return\nML349:\nsay 'Everything put together sooner or later falls apart.'\n  return\nML350:\nsay 'Do whatever your enemies don''t want you to do.'\n  return\nML351:\nsay 'A little ambiguity never hurt anyone.'\n  return\nML352:\nsay 'Don''t permit yourself to get between a dog and a lamppost.'\n  return\nML353:\nsay 'Go where the money is.'\n  return\nML354:\nsay 'Work may be the crabgrass of life, but money is still the'\nsay 'water that keeps it green.'\n  return\nML355:\nsay 'A stagnant science is at a standstill.'\n  return\nML356:\nsay 'Half of being smart is knowing what you''re dumb at.'\n  return\nML357:\nsay 'For every credibility gap there is a gullibility gap.'\n  return\nML358:\nsay 'Cant produces countercant.'\n  return\nML359:\nsay 'If you see a man approaching you with the obvious intent'\nsay 'of doing you good, you should run for your life.'\n  return\nML360:\nsay 'When you are sure you''re right, you have a moral duty'\nsay 'to impose your will upon anyone who disagrees with you.'\n  return\nML361:\nsay 'If you can''t convince them, confuse them.'\n  return\nML362:\nsay 'Assumption is the mother of all foul-ups.'\n  return\nML363:\nsay 'All general statements are false.  (Think about it)'\n  return\nML364:\nsay 'If it happens, it must be possible.'\n  return\nML365:\nsay 'Them what gets--has.'\n  return\nML366:\nsay 'If you are already in a hole, there''s no use to continue digging.'\n  return\nML367:\nsay 'If builders built buildings the way programmers wrote programs,'\nsay 'then the first woodpecker that came along',\n     'would destroy civilization.'\n  return\nML368:\nsay 'People will believe anything if you whisper it.'\n  return\nML369:\nsay 'A pat on the back is only a few inches from a kick in the pants.'\n  return\nML370:\nsay 'Never leave hold of what you''ve got until you''ve got hold'\nsay 'of something else.'\n  return\nML371:\nsay 'A theory is better than its explanation.'\n  return\nML372:\nsay 'Eat a live toad the first thing in the morning and nothing'\nsay 'worse will happen to you the rest of the day.'\n  return\nML373:\nsay 'Nobody notices when things go right.'\n  return\nML374:\nsay 'There is no safety in numbers, or in anything else.'\n  return\nML375:\nsay 'Roses are red violets are blue'\nsay 'I am schizophrenic and so am I.'\n  return\nML376:\nsay 'If anything can go wrong, it will.'\n  return\nML377:\nsay 'If anything can go wrong, it will.'\nsay 'If anything can''t go wrong it will.'\n  return\nML378:\nsay 'If Murphy''s Law can go wrong, it will.'\n  return\nML379:\nsay 'If a series of events can go wrong, it will do so in'\nsay 'in the worst possible sequence.'\n  return\nML380:\nsay 'After things have gone from bad to worse, the cycle'\nsay 'will repeat itself.'\n  return\nML381:\nsay 'An auditor enters the battlefield after the war is over,'\nsay 'and attacks the wounded.'\n  return\nML382:\nsay 'Nothing is ever so bad that it can''t get worse.'\n  return\nML383:\nsay 'No matter what goes wrong, there is always somebody'\nsay 'who knew it would.'\n  return\nML384:\nsay 'Nature always sides with the hidden flaw.'\n  return\nML385:\nsay 'The hidden flaw never remains hidden.'\n  return\nML386:\nsay '1. Everything depends'\nsay '2. Nothing is always'\nsay '3. Everything is sometimes'\n  return\nML387:\nsay 'If you wait, it will go away'\nsay '....having done it''s damage'\nsay 'it it was bad, it''ll be back.'\n  return\nML388:\nsay 'Complex problems have simple, easy-to-understand'\nsay 'wrong answers.'\n  return\nML389:\nsay 'Opportunity always knocks at the least opportune'\nsay 'moment.'\n  return\nML390:\nsay 'When you need to knock on wood is when you realize the'\nsay 'world''s composed of aluminum and vinyl.'\n  return\nML391:\nsay 'In order for something to become clean, something'\nsay 'else must become dirty.'\nsay '...but you can get everything dirty without getting'\nsay 'anything clean.'\n  Return\nML392:\nsay 'Things equal to nothing else are equal to each other.'\n  return\nML393:\nsay 'The first place to look for anything is the last place'\nsay 'you would expect to find it.'\n  return\nML394:\nsay 'You can always find what you''re not looking for.'\n  return\nML395:\nsay 'If you don''t care where you are, you ain''t lost.'\n  return\nML396:\nsay 'It is impossible for an optimist to be pleasantly'\nsay 'suprised.'\n  return\nML397:\nsay 'A crisis is when you can''t say \"let''s forget the'\nsay 'whole thing\".'\n  return\nML398:\nsay 'Washing your car to make it rain doesn''t work.'\n  return\nML399:\nsay 'When the going gets tough, everyone leaves.'\n  return\nML400:\nsay 'The time it takes to rectify a situation is'\nsay 'inversely proportional to the time it took'\nsay 'to do the damage.'\n  return\nML401:\nsay 'An optimist believes we live in the best of all'\nsay 'possible worlds.'\nsay 'a pessimist fears this is true.'\n  Return\nML402:\nsay 'You can make it foolproof, but you can''t make it'\nsay 'damnfoolproof.'\n  Return\nML403:\nsay 'It takes longer to glue a vase together than to'\nsay 'break one.'\n  return\nML404:\nsay 'It takes longer to lose ''x'' number of pounds than'\nsay 'to gain ''x'' number of pounds.'\n  return\nML405:\nsay 'The item you had your eye on the minute you walked in'\nsay 'will be taken by the person in front of you.'\n  return\nML406:\nsay 'The other line moves faster.'\n  return\nML407:\nsay 'If you change lines, the one you just left will start'\nsay 'to move faster than the one you are now in.'\n  return\nML408:\nsay 'The longer you wait in line, the greater the'\nsay 'likelihood that you are standing in the wrong line.'\n  return\nML409:\nsay 'The slowest checker is always at the quick-check-out'\nsay 'lane.'\n  return\nML410:\nsay 'Whenever you cut your fingernails you will find a'\nsay 'need for them an hour later.'\n  return\nML411:\nsay '1.if the weather is extremely bad,  church attendance'\nsay '     will be down'\nsay '2.if the weather is extremely good, church attendance'\nsay '     will be down'\nsay '3.if the bulletin covers are in short supply church'\nsay '     attendance will exceed all expectations.'\n  return\nML412:\nsay 'If a situation requires undivided attention, it will'\nsay 'occur simultaneously with a compelling distraction.'\n  return\nML413:\nsay 'The further away the disaster or accident occurs, the'\nsay 'greater the number of dead and injured required for it'\nsay 'to become a story.'\n  return\nML414:\nsay 'The closer you are to the facts of a situation, the'\nsay 'more obvious are the errors in all news coverage of'\nsay 'the situation.'\n  return\nML415:\nsay 'The further you are from the facts of a situation,'\nsay 'the more you tend to believe news coverage of the'\nsay 'situation.'\n  return\nML416:\nsay 'The best way to inspire fresh thoughts is to seal'\nsay 'the letter.'\n  return\nML417:\nsay 'The most interesting specimen will not be labeled.'\n  return\nML418:\nsay 'Some errors will always go unnoticed until the book'\nsay 'is in print.'\n  return\nML419:\nsay 'The first page the author turns to upon receiving an'\nsay 'advance copy will be the page containing the worst'\nsay 'error.'\n  return\nML420:\nsay '1. Never draw what you can copy'\nsay '2. Never copy what you can trace'\nsay '3. Never trace what you can cut out and paste down'\n  return\nML421:\nsay 'The best shots happen immediately after the last'\nsay 'frame is exposed.'\n  return\nML422:\nsay 'The best shots are generally attempted through the'\nsay 'lens cap.'\n  return\nML423:\nsay 'Any surviving best shots are ruined when someone'\nsay 'inadvertently open the darkroom door and all of the'\nsay 'dark leaks out.'\n  return\nML424:\nsay 'If a three-story building served by one elevator nine'\nsay 'times out of ten the elevator care will be on a floor'\nsay 'where you are not.'\n  return\nML425:\nsay 'The tendency of smoke from a cigarette, barbecue,'\nsay 'campfire, etc.  To drift into a person''s face varies'\nsay 'directly with that person''s sensitivity to smoke.'\n  return\nML426:\nsay 'The distance to the gate is inversely proportional'\nsay 'to the time available to catch you flight.'\n  return\nML427:\nsay 'As soon as the stewardess serves the coffee, the'\nsay 'airliner encounters turbulence.'\n  return\nML428:\nsay 'Serving coffee on aircraft causes turbulence.'\n  return\nML429:\nsay 'Whatever carrousel you stand by, your baggage will'\nsay 'come in on another one.'\n  return\nML430:\nsay 'When travelling overseas, the exchange rate improves'\nsay 'markedly the day after one has purchased foreign'\nsay 'currency.'\n  return\nML431:\nsay 'Upon returning home, the exchange rate drops again as'\nsay 'soon as one has converted all unused foreign currency.'\n  return\nML432:\nsay 'The bigger they are, the harder they hit.'\n  return\nML433:\nsay 'For every action, there is an equal and opposite'\nsay 'criticism.'\n  return\nML434:\nsay 'Authorization for a project will be granted only when'\nsay 'none of the authorizers can be blamed if the project'\nsay 'fails but when all of the authorizers can claim credit'\nsay 'if it succeeds.'\n  return\nML435:\nsay 'If an idea can survive a bureaucratic review and be'\nsay 'implemented, it wasn''t worth doing.'\n  return\nML436:\nsay 'The greater the cost of putting a plan into operation,'\nsay 'the less chance there is of abandoning the plan - Even'\nsay 'if it subsequently becomes irrelevant.'\n  return\nML437:\nsay 'The higher the level of prestige accorded the people'\nsay 'behind the plan.  The least less chance there is of'\nsay 'abandoning it.'\n  return\nML438:\nsay 'In any organization there will always be one person'\nsay 'who knows what is going on.'\nsay 'this person must be fired.'\n  Return\nML439:\nsay 'It is easier to get forgiveness than permission.'\n  return\nML440:\nsay 'Far-way talent always seems better than home-developed'\nsay 'talent.'\n  Return\nML441:\nsay 'Personnel recruiting is a triumph of hope over'\nsay 'experience.'\n  return\nML442:\nsay 'Some people manage by the book, even though they'\nsay 'don''t know who wrote the book or even what book.'\n  return\nML443:\nsay 'Don''t let your superiors know you''re better than'\nsay 'they are.'\n  return\nML444:\nsay 'You never know who''s right, but you always know'\nsay 'who''s in charge.'\n  return\nML445:\nsay '1. Anyone can make a decision given enough facts'\nsay '2. a Good manager can make a decision without enough'\nsay '   facts'\nsay '3. a Perfect manager can operate in perfect ignorance'\n  return\nML446:\nsay 'The boss who attempts to impress employees with his'\nsay 'knowledge of intricate details has lost sight of his'\nsay 'final objective.'\n  return\nML447:\nsay 'You will save yourself a lot of needless worry if you'\nsay 'don''t burn your bridges until you come to them.'\n  return\nML448:\nsay 'In a hierarchical system, the rate of pay varies'\nsay 'inversely with the unpleasantness and difficulty'\nsay 'of the task.'\n  return\nML449:\nsay 'The client who pays the least complains the most.'\n  return\nML450:\nsay 'A lack of planning on your part'\nsay 'does not constitute an emergency on my part.'\n  return\nML451:\nsay 'I know you believe you understand'\nsay '   what you think I said,'\nsay '      however, I am not sure you realize,'\nsay '         that what I think you heard'\nsay '            is not what I meant.'\n  return\nML452:\nsay 'Real programmers don''t eat muffins.'\n  return\nML453:\nsay 'In any bureaucracy, paperwork increases as you spend'\nsay 'more and more time reporting on the less and less you'\nsay 'are doing.  Stability is achieved when you spend all of'\nsay 'your time reporting on the nothing you are doing.'\n  return\nML454:\nsay 'Consultants are mystical people who ask a company for'\nsay 'a number and then give it back to them.'\n  return\nML455:\nsay 'When somebody drops something, everybody will kick it'\nsay 'around instead of picking it up.'\n  return\nML456:\nsay 'The chances of anybody doing anything are inversely'\nsay 'proportional to the number of other people who are in'\nsay 'a position to do it instead.'\n  return\nML457:\nsay 'Never make a decision you can get someone else to make.'\n  return\nML458:\nsay 'No one keeps a record of decisions you could have made'\nsay 'but didn''t.  Everyone keeps a records of your bad ones'\n  return\nML459:\nsay 'For every vision, there is an equal and opposite revision.'\n  return\nML460:\nsay 'The inside contact that you have developed at great'\nsay 'expense is the first person to be let go in any'\nsay 'reorganization.'\n  return\nML461:\nsay 'It''s tough to get reallocated when you''re the one'\nsay 'who''s redundant.'\n  return\nML462:\nsay 'Whatever hits the fan will not be evenly distributed.'\n  return\nML463:\nsay 'If you''re early, it''be cancelled'\nsay 'if you knock yourself out to be on time, you will'\nsay '   have to wait'\nsay 'if you''re late, you will be too late.'\n  return\nML464:\nsay 'A meeting is an event at which the minutes are kept'\nsay 'and the hours are lost.'\n  return\nML465:\nsay 'If you leave the room, you''re elected.'\n  return\nML466:\nsay 'The cream rises to the top.'\nsay 'so does the scum.'\n  Return\nML467:\nsay 'You can never do just one thing.'\n  Return\nML468:\nsay 'There''s no time like the present for postponing'\nsay 'what you don''t want to do.'\n  return\nML469:\nsay 'Any task worth doing was worth doing yesterday.'\n  Return\nML470:\nsay 'The more complicated and grandiose the plan, the'\nsay 'greater the chance of failure.'\n  return\nML471:\nsay 'Simple jobs always get put off because there will be'\nsay 'time to do them later.'\n  return\nML472:\nsay 'Assumption is the mother of all screw-ups.'\n  return\nML473:\nsay 'A work project expands to fill the space available.'\n  return\nML474:\nsay 'No matter how large the work space, if two project'\nsay 'must be done at the same time they will require the'\nsay 'same part of the work space.'\n  return\nML475:\nsay 'The one wrench or drill bit you need will be the one'\nsay 'missing from the tool chest.'\n  return\nML476:\nsay 'Most projects require three hands.'\n  return\nML477:\nsay 'Leftover nuts never match leftover bolts.'\n  return\nML478:\nsay 'The more carefully you plan a project, the more'\nsay 'confusion there is when something goes wrong.'\n  return\nML479:\nsay 'Murphy''s rule for precision :'\nsay '   Measure with a micrometer'\nsay '   Mark with chalk'\nsay '   Cut with an axe.'\n  return\nML480:\nsay 'You can''t fix it if it ain''t broke.'\n  return\nML481:\nsay 'First rule of intelligent tinkering:'\nsay '  Save all the parts.'\n  return\nML482:\nsay 'Access holes will be 1/2\" Too small'\nsay 'holes that are the right size will be in the wrong place.'\n  return\nML483:\nsay 'If it would be cheaper to buy a new unit, the company'\nsay 'will insist upon repairing the old one.'\n  return\nML484:\nsay 'If it would be cheaper to repair the old one, the'\nsay 'company will insist on the latest model.'\n  return\nML485:\nsay 'The primary function of the design engineer is to make'\nsay 'things difficult for the fabricator and impossible'\nsay 'for the serviceman.'\n  return\nML486:\nsay 'That component of any circuit which has the shortest'\nsay 'service life will be placed in the least'\nsay 'accessible location.'\n  return\nML487:\nsay 'Any circuit design must contain at least one part which'\nsay 'is obsolete, two parts which are unobtainable and three'\nsay 'parts which at still under development.'\n  return\nML488:\nsay 'Important letters which contain no errors will develop'\nsay 'errors in the mail.'\n  return\nML489:\nsay 'Office machines which function perfectly during normal'\nsay 'business hours will break down when you return to the'\nsay 'office at night to use them for personal business.'\n  Return\nML490:\nsay 'Machines that have broken down will work perfectly'\nsay 'when the repairman arrives.'\n  return\nML491:\nsay 'Envelopes and stamps which don''t stick when you lick'\nsay 'them will stick to other things when you don''t want'\nsay 'them to.'\n  return\nML492:\nsay 'Vital papers will demonstrate their vitality by'\nsay 'spontaneously moving from where you left them to where'\nsay 'you can''t find them.'\n  return\nML493:\nsay 'The last person who quit or was fired will be held'\nsay 'responsible for everything that goes wrong -- Until'\nsay 'the next person quits or is fired.'\n  Return\nML494:\nsay 'If you hit two keys on the typewriter, the one you'\nsay 'don''t want his the paper.'\n  return\nML495:\nsay 'The one time in the day that you lean back and relax'\nsay 'is the one time the boss walks through the office.'\n  return\nML496:\nsay 'Hot glass looks exactly the same as cold glass.'\n  return\nML497:\nsay 'When you do not know what you are going, do it neatly.'\n  return\nML498:\nsay 'Teamwork is essential.  It allows you to blame'\nsay 'someone else.'\n  return\nML499:\nsay 'Science is true.  Don''t be misled by facts'\n  return\nML500:\nsay '1. If it''s green or it wiggles, it''s biology'\nsay '2. If it stinks, it''s chemistry'\nsay '3. If it doesn''t work, it''s physics'\n  return\nML501:\nsay 'Nothing improves an innovation like lack of controls'\nML502:\nsay 'The quality of correlation is inversely proportional'\nsay 'to the density of control.'\n  return\nML503:\nsay 'If reproducibility may be a problem conduct the'\nsay 'test only once.'\n  return\nML504:\nsay 'If a straight line fit is required, obtain only two'\nsay 'data points.'\n  return\nML505:\nsay 'Any technical problem can be overcome given enough'\nsay 'time and money.'\n  return\nML506:\nsay 'You are never given enough time or money.'\n  return\nML507:\nsay 'Unless the results are known in advance, funding'\nsay 'agencies will reject the proposal.'\n  return\nML508:\nsay 'It is better to solve a problem with a crude'\nsay 'approximation and know the truth, than to demand an'\nsay 'exact solution and not know the truth at all.'\n  return\nML509:\nsay 'An easily-understood, workable falsehood is more useful'\nsay 'than a complex, incomprehensible truth.'\n  return\nML510:\nsay 'Anyone who make a significant contribution to any field'\nsay 'of endeavor, and stays in that field long enough,'\nsay 'becomes an obstruction at its progress -- In direct'\nsay 'proportion to the importance of his original contribution.'\n  return\nML511:\nsay 'If a scientist encovers a publishable fact, it will'\nsay 'become central to his theory.'\nsay '   '\nsay 'His theory, in turn, will become central to all'\nsay 'scientific thought.'\n  return\nML512:\nsay 'There is no such thing as a  straight line.'\n  return\nML513:\nsay 'In any series of calculations, errors tend to occur'\nsay 'at the opposite end to the end at which you begin'\nsay 'checking for errors.'\n  return\nML514:\nsay 'Only errors exist.'\n  return\nML515:\nsay 'One man''s error is another man''s data.'\n  Return\nML516:\nsay 'To err is human, but to really foul things up requires'\nsay 'a computer.'\n  return\nML517:\nsay 'When putting it into memory, remember where you put it .'\n  return\nML518:\nsay 'Never test for an error condition you don''t know'\nsay 'how to handle.'\n  return\nML519:\nsay 'Everybody lies; but it doesn''t matter, since'\nsay 'nobody listens.'\n  return\nML520:\nsay 'People who love sausage and respect the law should'\nsay 'never watch either one being made.'\n  return\nML521:\nsay 'No matter what they''re telling you, they''re not'\nsay 'telling you the whole truth.'\n  return\nML522:\nsay 'No matter what they''re talking about, they''re'\nsay 'talking about money.'\n  return\nML523:\nsay 'In any dealings with a collective body of people, the'\nsay 'people will always be more tacky than originally expected.'\n  return\nML524:\nsay 'If you can keep your head when all about you are losing'\nsay 'theirs, then you just don''t understand the problem.'\n  return\nML525:\nsay 'Information deteriorates upward through the bureaucracies.'\n  return\nML526:\nsay 'When an exaggerated emphasis is placed upon delegation,'\nsay 'responsibility, like sediment, sinks to the bottom.'\n  return\nML527:\nsay 'When outrageous expenditures are divided finely enough'\nsay 'the public will not have enough stake in any one'\nsay 'expenditure to squelch it.'\n  return\nML528:\nsay 'When the government bureau''s remedies do not match your'\nsay 'problem, you modify the problem, not the remedy.'\n  return\nML529:\nsay 'A fool and your money are soon partners.'\n  return\nML530:\nsay 'You may know where the market is going, but you can''t'\nsay 'possibly know where it''s going after that.'\n  return\nML531:\nsay 'Among economists, the real world is often a special case.'\n  return\nML532:\nsay 'Trial balances don''t.'\n  return\nML533:\nsay 'Working capital doesn''t.'\n  return\nML534:\nsay 'Liquidity tends to run out.'\n  return\nML535:\nsay 'Return on investments won''t'\n  return\nML536:\nsay 'If everybody doesn''t want it, nobody gets it.'\n  return\nML537:\nsay 'Mass man must be served by mass means.'\n  return\nML538:\nsay 'Everything is contagious.'\n  return\nML539:\nsay 'Nothing is ever done for the right reasons.'\n  return\nML540:\nsay 'The secret of success is sincerity.  Once you can fake'\nsay 'that you''ve got it made.'\n  return\nML541:\nsay 'An expert is anyone from out of town.'\n  return\nML542:\nsay 'An expert is one who knows more and more about less'\nsay 'and less until he knows absolutely everything'\nsay 'about nothing.'\n  return\nML543:\nsay 'To spot the expert, pick the one who predicts the job'\nsay 'will take the longest and cost the most.'\n  return\nML544:\nsay 'If it sits on your desk for 15 minutes, you''ve just'\nsay 'become the expert.'\n  return\nML545:\nsay 'Indecision is the basis for flexibility.'\n  return\nML546:\nsay 'Anything is possible if you don''t know what you''re'\nsay 'talking about.'\n  return\nML547:\nsay 'Never create a problem for which you do not have'\nsay 'the answer.'\n  return\nML548:\nsay 'Create problems for which only you have the answer.'\n  return\nML549:\nsay 'A conclusion is the place where you got tired of thinking.'\n  return\nML550:\nsay 'Hindsight is an exact science.'\n  return\nML551:\nsay 'History doesn''t repeat itself -- Historians merely'\nsay 'repeat each other.'\n  return\nML552:\nsay 'Fact is solidified opinion.'\n  return\nML553:\nsay 'Facts may weaken under extreme heat and pressure.'\n  return\nML554:\nsay 'Truth is elastic.'\n  return\nML555:\nsay 'When in doubt, predict that the trend will continue.'\n  return\nML556:\nsay 'When in trouble, obfuscate.'\n  return\nML557:\nsay 'Progress does not consist in replacing a theory that is'\nsay 'wrong with one that is right.  It consists in replacing'\n say 'a theory that is wrong with one that is more subtly wrong.'\n  return\nML558:\nsay 'It is a simple task to make things complex, but a complex'\nsay 'task to make them simple.'\n  return\nML559:\nsay 'If you have a difficult task give it to a lazy man, he'\nsay 'will find an easier way to do it.'\n  return\nML560:\nsay 'Every great idea has a disadvantage equal to or'\nsay 'exceeding the greatness of the idea.'\n  return\nML561:\nsay 'Never attribute to malice that which is adequately'\nsay 'explained by stupidity.'\n  return\nML562:\nsay 'New systems generate new problems.'\n  return\nML563:\nsay 'Systems should not be unnecessarily multiplied.'\n  return\nML564:\nsay 'Systems tend to grow, and as they grow they encroach.'\n  return\nML565:\nsay 'Complicated systems produce unexpected outcomes.'\n  return\nML566:\nsay 'The total behavior of large systems cannot be predicted.'\n  return\nML567:\nsay 'A large system, produced by expanding the dimensions of'\nsay 'A smaller system, does not behave like the smaller system.'\n  return\nML568:\nsay 'People in systems do not do what the systems says'\nsay 'they are doing.'\n  return\nML569:\nsay 'The system itself does not do what it says it is doing .'\n  return\nML570:\nsay 'A complex system that works is invariably found to have'\nsay 'evolved from a simple system that works.'\n  return\nML571:\nsay 'A complex system designed from scratch never works and'\nsay 'cannot be patched up to make it work.  You have to start'\nsay 'over, beginning with a working simple system.'\n  return\nML572:\nsay '1. Everything is a system'\nsay '2. Everything is part of a larger system'\nsay '3. The universe is infinitely systematized both upward'\nsay '   (larger systems) and downward (smaller systems)'\nsay '4. All systems are infinitely complex.  (The illusion'\nsay '   of simplicity comes from focussing attention on'\nsay '   one or a few variables).'\n  return\nML573:\nsay 'Complex systems tend to oppose their own proper function.'\n  return\nML574:\nsay 'If the course you wanted most has room for ''n'' students'\nsay 'you will be the ''n + 1'' to apply.'\n  return\nML575:\nsay 'Class schedules are designed so that every student will'\nsay 'waste the maximum time between classes.'\n  return\nML576:\nsay 'Show me a person who''s never made a mistake and I''ll'\nsay 'show you somebody who''s never achieved much.'\n  return\nML577:\nsay 'When you consider there are 24 hours in a day, it''s'\nsay 'sad to know that only one is called the happy hour.'\n  return\nML578:\nsay 'When you are able to schedule two classes in a row,'\nsay 'they will be held in classrooms at opposite end of'\nsay 'the campus.'\n  return\nML579:\nsay 'A prerequisite for a desired course will be offered'\nsay 'only during the semester following the desired course.'\n  return\nML580:\nsay 'When reviewing your notes before an exam, the most'\nsay 'important ones will be illegible.'\n  return\nML581:\nsay 'The more studying you did for the exam, the less sure'\nsay 'you are as to which answer they want.'\n  return\nML582:\nsay '80% of the final exam will be based on the one lecture'\nsay 'you missed about the one book you didn''t read.'\n  return\nML583:\nsay 'The night before the English history mid-term, your'\nsay 'biology instructor will assign 200 pages on planaria.'\n  return\nML584:\nsay 'Every instructor assumes that you have nothing else'\nsay 'to do except study for that instructor''s course.'\n  return\nML585:\nsay 'If you are given an open-book exam, you will forget'\nsay 'your book'\nsay 'if you are given a take-home  exam, you will forget'\nsay 'where you live.'\n  return\nML586:\nsay 'At the end of the semester you will recall having'\nsay 'enrolled in a course at the beginning of the semester'\nsay '-- And never attending.'\n  return\nML587:\nsay 'The one course you must take to graduate will not be'\nsay 'offered during your last semester.'\n  return\nML588:\nsay 'The more general the title of a course, the less'\nsay 'you will learn from it.'\n  return\nML589:\nsay 'The more specific the title of a course, the less you'\nsay 'will be able to apply it later.'\n  return\nML590:\nsay 'The most valuable quotation will be the one for which'\nsay 'you cannot determine the source.'\n  return\nML591:\nsay 'The source for an unattributed quotation will appear'\nsay 'in the most hostile review of your work.'\n  return\nML592:\nsay 'When a writer prepares a manuscript on a subject he does'\nsay 'not understand, his work will be understood only by'\nsay 'readers who know more about that subject than he does.'\n  return\nML593:\nsay 'Writings prepared without understanding must fail in the'\nsay 'first objective of communication -- Informing'\nsay 'the uninformed.'\n  return\nML594:\nsay 'When a student asks for a second time if you have read'\nsay 'his book report, he did not read the book.'\n  return\nML595:\nsay 'If daily class attendance is mandatory, a scheduled'\nsay 'exam will product increased absenteeism.  If attendance'\nsay 'is optional, a scheduled exam will produce persons you'\nsay 'have never seen before.'\n  return\nML596:\nsay 'Just because your doctor has a name for your condition'\nsay 'doesn''t mean he knows what it is.'\n  return\nML597:\nsay 'The more boring and out-of-date the magazines in the'\nsay 'waiting room, the longer you will have to wait for'\nsay 'your scheduled appointment.'\n  return\nML598:\nsay 'Only adults have difficulty with child-proof bottles.'\n  return\nML599:\nsay 'You never have the right number of pills left on the'\nsay 'last day of a prescription.'\n  return\nML600:\nsay 'The pills to be taken with meals will be the least'\nsay 'appetizing ones.'\n  return\nML601:\nsay 'Even water tastes bad when taken on doctors orders.'\n  return\nML602:\nsay 'If your condition seems to be getting better, it''s'\nsay 'probably your doctor getting sick.'\n  return\nML603:\nsay 'Beware of the physician who is great at getting'\nsay 'out of trouble.'\n  return\nML604:\nsay 'A drug is that substance which, when injected into a'\nsay 'rat,  will produce a scientific report.'\n  return\nML605:\nsay 'Before ordering a test decide what you will do if it'\nsay 'is 1) Positive, or 2) Negative.  If both answers are the'\nsay 'same, don''t do the test.'\n  return\nML606:\nsay 'The radiologists'' national flower is the hedge.'\n  return\nML607:\nsay 'The feasibility of an operation is not the best'\nsay 'indication for its performance.'\n  return\nML608:\nsay 'A physician''s ability is inversely proportional'\nsay 'to his availability.'\n  return\nML609:\nsay 'There are two kinds of adhesive tape:  That which won''t'\nsay '  stay on and that which won''t come off.'\n  return\nML610:\nsay 'Everybody wants a pain shot at the same time.'\n  return\nML611:\nsay 'Everybody who didn''t want a pain shot when you were'\nsay 'passing out pain shots wants one when you are passing'\nsay 'out sleeping pills.'\n  return\nML612:\nsay 'An alcoholic is a person who drinks more that his'\nsay 'own physician.'\n  return\nML613:\nsay 'Fools rush in -- And get the best seats.'\n  return\nML614:\nsay 'At any event, the people whose seats are furthest from'\nsay 'the aisle arrive last.'\n  return\nML615:\nsay 'Exciting plays occur only while you are watching the'\nsay 'scoreboard or out buying a hot dog.'\n  return\nML616:\nsay 'Nothing is ever so bad it can''t be made worse by'\nsay 'firing the coach.'\n  return\nML617:\nsay 'The wrong quarterback is the one that''s in there.'\n  return\nML618:\nsay 'A free agent is anything but.'\n  return\nML619:\nsay 'Hockey is a game played by six good players and the'\nsay 'home team.'\n  return\nML620:\nsay 'Whatever can go to New York, will.'\n  return\nML621:\nsay 'Whenever a superstar is traded to your favorite team,'\nsay 'he fades.  Whenever your team trades away a useless'\nsay 'no-name, he immediately rises to stardom.'\n  return\nML622:\nsay 'Never leave hold of what you''ve got until you''ve'\nsay 'got hold of something else.'\n  return\nML623:\nsay 'A mediocre player will sink to the level of his or'\nsay 'her opposition.'\n  return\nML624:\nsay 'The only way to make up for being lost is to make'\nsay 'record time while you are lost.'\n  return\nML625:\nsay 'The amount of wind will vary inversely with the number'\nsay 'and experience of the people you have on board.'\n  return\nML626:\nsay 'No matter how strong the breeze when you leave the dock'\nsay 'once you have reached the furthest point from port'\nsay 'the wind will die.'\n  return\nML627:\nsay 'The time available to go fishing shrinks as the fishing'\nsay 'season draws nearer.'\n  return\nML628:\nsay 'The least experience fisherman always catches the'\nsay 'biggest fish.'\n  return\nML629:\nsay 'The more elaborate and costly the equipment, the greater'\nsay 'the chance of having to stop at the fish market'\nsay 'on the way home.'\n  return\nML630:\nsay 'The worse your line is tangled, the better is the'\nsay 'fishing around you.'\n  return\nML631:\nsay 'The mountain gets steeper as you get closer.'\n  return\nML632:\nsay 'The mountain looks closer than it is.'\n  return\nML633:\nsay 'All trails have more uphill sections that they have'\nsay 'level or downhill sections.'\n  return\nML634:\nsay 'The one who leasts wants to play is the one who will win.'\n  return\nML635:\nsay 'All things being equal, you lose.'\nsay '    '\nsay 'All things being in your favor, you still lose.'\n  return\nML636:\nsay 'Win or lose, you lose.'\n  return\nML637:\nsay 'No matter where you go, there you are !'\n  return\nML638:\nsay 'It always takes longer to get there than to get back.'\n  return\nML639:\nsay 'If everything is coming your way, you''re in the'\nsay 'wrong lane.'\n  return\nML640:\nsay 'If you allow someone to get in front of you either:'\nsay 'A. The car in front will be the last one over a'\nsay '   railroad crossing, and you will be stuck waiting'\nsay '   for a long, slow-moving train; or'\nsay 'B. You both will have the same destination and the'\nsay '   other car will get the last parking space.'\n  return\nML641:\nsay 'If you have to park six blocks away, you will find two'\nsay 'new parking spaces right in front of the building'\nsay 'entrance.'\n  return\nML642:\nsay 'When you''re not in a hurry, the traffic light will turn'\nsay 'green as soon as your vehicle comes to a complete stop.'\n  return\nML643:\nsay 'A car and a truck approaching each other on an otherwise'\nsay 'deserted road will meet at the narrow bridge.'\n  return\nML644:\nsay 'The speed of an oncoming vehicle is directly proportional'\nsay 'to the length of the passing zone.'\n  return\nML645:\nsay 'The first bug to hit a clean windshield lands directly'\nsay 'in front of your eyes.'\n  return\nML646:\nsay 'If you can get to the faulty part, you don''t have the'\nsay 'tool to get it off.'\n  return\nML647:\nsay 'If you can get the faulty part off, the parts house'\nsay 'will have it back-ordered.'\n  return\nML648:\nsay 'If the faulty part is in stock, it didn''t need replacing'\nsay 'in the first place.'\n  return\nML649:\nsay 'When the need arises, any tool or object closest to you'\nsay 'becomes a hammer.'\n  return\nML650:\nsay 'No matter how minor the task, you will inevitably end'\nsay 'up covered with grease and motor oil.'\n  return\nML651:\nsay 'When necessary, metric and inch tools can be used'\nsay 'interchangeably.'\n  return\nML652:\nsay 'Automotive Engineering Repair Law:'\nsay '  If you drop something, it will never reach the ground.'\n  return\nML653:\nsay 'If you lived here you''d be home now.'\n  return\nML654:\nsay 'If it''s good, they discontinue it.'\n  return\nML655:\nsay 'It the shoe fits, it''s ugly.'\n  return\nML656:\nsay '1. If you like it, they don''t have it in your size'\nsay '2. If you like it and it''s in your size, it doesn''t'\nsay '   fit anyway'\nsay '3. If you like it and it fits, you can''t afford it'\nsay '4. If you like it, it fits and you can afford it, it'\nsay '   falls apart the first time you wear it.'\n  return\nML657:\nsay 'The one you want is never the one on sale.'\n  return\nML658:\nsay 'Anything labeled \"new\" and/or \"improved\" isn''t.'\n  return\nML659:\nsay 'The label \"new\" and/or \"improved\" means the price went up.'\n  return\nML660:\nsay 'The label \"all new,\" \"completely new\" or \"great news\"'\nsay 'means the price went way way up.'\n  return\nML661:\nsay 'If an item is advertised as \"under $50,\" you can bet'\nsay 'it''s not $19.95'\n  return\nML662:\nsay 'Acf2 is a four letter word.'\n  return\nML663:\nsay 'If only one price can be obtained for any quotation,'\nsay 'the price will be unreasonable.'\n  return\nML664:\nsay 'A 60-day warranty guarantees that the product will'\nsay 'self-destruct on the 61st day.'\n  return\nML665:\nsay 'The \"Consumer Report\" on the item will come out a week'\nsay 'after you''ve made your purchase:'\nsay '    '\nsay '  1. The one you bought will be rated \"Unacceptable\"'\nsay '  2. The one you almost bought will be rated \"Best Buy\"'\n  return\nML666:\nsay 'If you don''t write to complain, you''ll never receive'\nsay 'your order.'\nsay 'if you do write, you''ll receive the merchandise before'\nsay 'your angry letter reaches its destination.'\n  return\nML667:\nsay 'The most important item in an order will no longer'\nsay 'be available.'\n  return\nML668:\nsay 'During the time an item is on back-order, it will be'\nsay 'available cheaper and quicker from many other sources.'\n  return\nML669:\nsay 'People will buy anything that''s one to a customer.'\n  return\nML670:\nsay 'Security isn''t.'\n  return\nML671:\nsay 'Management can''t.'\n  return\nML672:\nsay 'Sale promotions don''t.'\n  return\nML673:\nsay 'Consumer assistance doesn''t.'\n  return\nML674:\nsay 'Workers won''t.'\n  return\nML675:\nsay 'Cleanliness is next to impossible.'\n  return\nML676:\nsay 'Multiple-function gadgets will not perform any'\nsay 'function adequately.'\n  return\nML677:\nsay 'The more expensive the gadget, the less often you'\nsay 'will use it.'\n  return\nML678:\nsay 'The simpler the instruction (e.g. \"Press here\"), The'\nsay 'more difficult it will be to open the package.'\n  return\nML679:\nsay 'In a family recipe you just discovered in an old book,'\nsay 'the most vital measurement will be illegible.'\n  return\nML680:\nsay 'Once a dish is fouled up.  Anything added to save it'\nsay 'only makes it worse.'\n  return\nML681:\nsay 'You are always complimented on the item which took the'\nsay 'least effort to prepare'\nsay '    '\nsay 'Example:'\nsay '    '\nsay ' If you make \"duck a l''orange\" you will be'\nsay ' complimented on the baked potato.'\n  Return\nML682:\nsay 'The one ingredient you made a special trip to the store'\nsay 'to get will be the one thing your guest is allergic to.'\n  return\nML683:\nsay 'The more time and energy you put into preparing a meal'\nsay 'the greater the chance you guests will spend the entire'\nsay 'meal discussing other meals they have had.'\n  return\nML684:\nsay 'Souffles rise and cream whips only for the family and'\nsay 'for guests you didn''t really want to invite anyway.'\n  return\nML685:\nsay 'The rotten egg will be the one you break into the'\nsay 'cake batter.'\n  return\nML686:\nsay 'Any cooking utensil placed in the dishwasher will be'\nsay 'needed immediately thereafter for something else.'\n  return\nML687:\nsay 'Any measuring utensil used for liquid ingredients will'\nsay 'be needed immediately thereafter for dry ingredients.'\n  return\nML688:\nsay 'Time spent consuming a meal is in inverse proportion'\nsay 'to time spent preparing it.'\n  return\nML689:\nsay 'Whatever it is, somebody will have had it for lunch.'\n  return\nML690:\nsay 'If you''re wondering if you took the meat out to'\nsay 'thaw, you didn''t.'\n  return\nML691:\nsay 'If you''re wondering if you left the coffee pot'\nsay 'plugged in, you did.'\n  return\nML692:\nsay 'If you''re wondering if you need to stop and pick up'\nsay 'bread and eggs on the way home, you do.'\n  return\nML693:\nsay 'If you''re wondering if you have enough money to take'\nsay 'the family out to eat tonight, you don''t.'\n  return\nML694:\nsay 'The spot you are scrubbing on glassware is always on'\nsay 'the other side.'\n  return\nML695:\nsay 'Washing machines only break down during the wash cycle.'\n  return\nML696:\nsay 'All break downs occur on the plumber''s day off.'\n  return\nML697:\nsay 'Cost of repair can be determined by multiplying the'\nsay 'cost of your new coat by 1.75, or by multiplying the'\nsay 'cost of a new washer by .75'\n  return\nML698:\nsay 'There is always more dirty laundry then clean laundry.'\n  return\nML699:\nsay 'If it''s clean, it isn''t laundry.'\n  return\nML700:\nsay 'A child will not spill on a dirty floor.'\n  return\nML701:\nsay 'An unbreakable toy is useful for breaking other toys.'\n  return\nML702:\nsay 'Any child who chatters non-stop at home will adamantly'\nsay 'refuse to utter a word when requested to demonstrate'\nsay 'for an audience.'\n  return\nML703:\nsay 'A shy, introverted child will choose a crowded public'\nsay 'area to loudly demonstrate new acquired vocabulary.'\n  return\nML704:\nsay 'The probability of a cat eating its dinner has'\nsay 'absolutely nothing to do with the price of the food'\nsay 'placed before it.'\n  return\nML705:\nsay 'The probability that a household pet will raise a fuss'\nsay 'to go in or out is directly proportional to the number'\nsay 'and importance of your dinner guests.'\n  return\nML706:\nsay 'The stomach expands to accommodate the amount of'\nsay 'junk food available.'\n  return\nML707:\nsay 'If you buy bananas or avocados before they are ripe,'\nsay 'there won''t be any left by the time they are ripe.  If'\nsay 'you buy them ripe, they rot before they are eaten.'\n  return\nML708:\nsay 'How long a minute is depends on which side of the'\nsay 'bathroom door you''re on.'\n  return\nML709:\nsay 'The life expectancy of a house plant varies inversely'\nsay 'with its price and directly with its ugliness.'\n  return\nML710:\nsay 'If you have watched a TV series only once, and you watch'\nsay 'it again, it will be a rerun of the same episode.'\n  return\nML711:\nsay 'If there are only 2 shows worth watching, they will be'\nsay 'on together.'\n  return\nML712:\nsay 'The only new TV show worth watching will be cancelled.'\n  return\nML713:\nsay 'The TV show you''ve been looking forward to all week'\nsay 'will be preempted.'\n  return\nML714:\nsay 'Most people deserve each other.'\n  return\nML715:\nsay 'Possessions increase to fill the space available for'\nsay 'their storage.'\n  return\nML716:\nsay 'When you dial a wrong number, you never get a busy signal.'\n  return\nML717:\nsay '1. The telephone will ring when you are outside the'\nsay '   door, fumbling for your keys.'\nsay '    '\nsay '2. You will reach it just in time to hear the click'\nsay '   of the caller hanging up.'\n  Return\nML718:\nsay 'People to whom you are attracted invariably thing you'\nsay 'remind them of someone else.'\n  return\nML719:\nsay 'The one who snores will fall asleep first.'\n  return\nML720:\nsay 'Never get excited about a blind date because of how'\nsay 'it sounds over the phone.'\n  return\nML721:\nsay 'The love letter you finally got the courage to send'\nsay 'will be delayed in the mail long enough for you to'\nsay 'make a fool of yourself in person.'\n  return\nML722:\nsay 'Other people''s romantic gestures seem novel and exciting'\nsay '    '\nsay 'your own romantic gestures seem foolish and clumsy.'\n  return\nML723:\nsay 'The length of a marriage is inversely proportional'\nsay 'to the amount spent on the wedding.'\n  return\nML724:\nsay '   All probabilities are 50%.  Either a thing will'\nsay '   happen or it won''t.'\nsay '    '\nsay '   This is especially true when dealing with women.'\nsay '    '\nsay '   Likelihoods; however, are 90% against you.'\n  return\nML725:\nsay 'Sow your wild oats on Saturday night - then on'\nsay 'Sunday pray for crop failure.'\n  return\nML726:\nsay 'The probability of meeting someone you know increases'\nsay 'when you are with someone you don''t want to be seen with.'\n  return\nML727:\nsay 'If you help a friend in need, he is sure to remember'\nsay 'you - the next time he''s in need.'\n  return\nML728:\nsay 'Virtue is its own punishment.'\n  return\nML729:\nsay 'If you do something right once, someone will ask'\nsay 'you to do it again.'\n  return\nML730:\nsay 'The one day you''d sell your soul for something,'\nsay 'souls are a glut.'\n  return\nML731:\nsay 'The scratch on the record is always through the song'\nsay 'you like most.'\n  return\nML732:\nsay 'Superiority is recessive.'\n  return\nML733:\nsay 'Forgive and remember.'\n  return\nML734:\nsay 'Anything good in life is either illegal, immoral'\nsay 'or fattening.'\n  return\nML735:\nsay 'Anything good in life either causes cancer in'\nsay 'laboratory mice or is taxed beyond reality.'\n  return\nML736:\nsay 'To err is human -- To blame it on someone else is'\nsay 'even more human.'\n  return\nML737:\nsay 'Whatever happens to you, it will previously have'\nsay 'happened to everyone you know only more so.'\n  return\nML738:\nsay 'He who laughs last -- Probably didn''t get the joke.'\n  return\nML739:\nsay 'Don''t worry over what other people are thinking about'\nsay 'you.  They''re too busy worrying over what you are'\nsay 'thinking about them.'\n  return\nML740:\nsay 'In a bureaucratic hierarchy, the higher up the'\nsay 'organization the less people appreciate Murphy''s Law,'\nsay 'the Peter Principle, etc.'\n  Return\nML741:\nsay 'Law expands in proportion to the resources available'\nsay 'for its enforcement.'\n  return\nML742:\nsay 'Bad law is more likely to be supplemented than repealed.'\n  return\nML743:\nsay 'There are some things which are impossible to know -'\nsay 'but it is impossible to know these things.'\n  return\nML744:\nsay 'When we try to pick out anything by itself we find'\nsay 'it hitched to everything else in the universe.'\n  return\nML745:\nsay 'If one views his problem closely enough he will'\nsay 'recognize himself as part of the problem.'\n  return\nML746:\nsay 'ABACUS: A reliable solid-state biquinary computing device'\nsay 'now partly superseded by the CRAY series.'\n  return\nML747:\nsay 'Anything may be divided into as many parts as you please.'\nSay 'Everything may be divided into as many parts as you please'\n return\nML748:\nsay 'If several things that could have gone wrong have not'\nsay 'gone wrong, it would have been ultimately beneficial'\nsay 'for them to have gone wrong.'\n  return\nML749:\nsay 'The quickest way to experiment with acupuncture is to'\nsay 'try on a new shirt.'\n  return\nML750:\nsay 'Absolutely nothing in the world is friendlier than'\nsay 'a wet dog.'\n  return\nML751:\nsay 'The severity of an itch is inversely proportional'\nsay 'to the reach.'\n  return\nML752:\nsay 'A hug is the perfect gift - one size fits all, and'\nsay 'nobody minds if you exchange it.'\n  return\nML753:\nsay 'The only game that can''t be fixed is peek-A-boo.'\n  return\nML754:\nsay 'Ignorance should be painful.'\n  return\nML755:\nsay 'The first insurance agent was David -'\nsay 'he gave Goliath a piece of the rock.'\n  return\nML756:\nsay 'King Arthur ran the first Knight Club.'\n  return\nML757:\nsay 'Magellan was the first Strait man.'\n  return\nML758:\nsay 'If you smile when everything goes wrong, you are'\nsay 'either a nitwit or a repairman.'\n  return\nML759:\nsay 'If it weren''t for the opinion polls we''d never know'\nsay 'what people are undecided about.'\n  return\nML760:\nsay 'No news is... Impossible'\n  return\nML761:\nsay 'Laugh and the world laughs with you.  Cry and ...'\nsay 'you have to blow your nose.'\n  return\nML762:\nsay 'A penny saved is ...not much'\n  return\nML763:\nsay 'He who marries for money...better be nice to his wife'\n  return\nML764:\nsay 'It''s always darkest before ...daylight saving time'\n  return\nML765:\nsay 'If at first you don''t succeed...get new batteries'\n  return\nML766:\nsay 'There is nothing more frightening than ignorance in action.'\n/* Some consider the following in bad taste where blind is ignorance*/\n/*   When the blind leadeth the blind...get out of their way */\n  return\nML767:\nsay 'Life is like an ice-cream cone:  You have to learn to'\nsay 'lick it.'\n  return\nML768:\nsay 'One place where you''re sure to find the perfect'\nsay 'driver is in the back seat.'\n  return\nML769:\nsay 'Nothing is indestructible, with the possible exception'\nsay 'of discount-priced fruitcakes.'\n  return\nML770:\nsay 'How do they know no two snowflakes are alike.'\n  return\nML771:\nsay 'How did they measure hail before the golf ball was invented.'\n  return\nML772:\nsay 'To err is human, to forgive is divine --'\nsay 'but to forget it altogether is humane.'\n  return\nML773:\nsay '\"Watching a birdie\" in hand is safer that watching'\nsay ' one overhead.'\n  return\nML774:\nsay 'The light at the end of the tunnel can be a helluva'\nsay 'nuisance, especially if your''re using the tunnel'\nsay 'as a darkroom.'\n  return\nML775:\nsay 'Never play leapfrog with a photo enlarger.'\n  return\nML776:\nsay 'Never argue with an artist.'\n  return\nML777:\nsay 'When in doubt, don''t mumble, overexpose...then mumble'\n  return\nML778:\nsay 'The light at the end of the tunnel really is a train.'\n  return\nML779:\nsay 'A budget is saving quarters in a mason jar for'\nsay 'Christmas and spending them by Easter.'\n  return\nML780:\nsay 'A budget is spending $15.00 on gas to drive to a'\nsay 'shopping mall to save $4.30 on a 20 pound turkey'\n  return\nML781:\nsay 'A budget is  wondering why you should balance yours'\nsay 'if the government can not balance theirs.'\n  return\nML782:\nsay 'A budget is trying to figure out how the family next'\nsay 'door is doing it.'\n  return\nML783:\nsay 'A budget is a plan that falls apart when the plumber'\nsay 'has to make an emergency visit.'\n  return\nML784:\nsay 'A budget is trying to make $25.00 go as far today as'\nsay 'it did when you were first married.'\n  return\nML785:\nsay 'A budget is buying a dress two sizes too small because'\nsay 'it was marked down.'\n  return\nML786:\nsay 'You sure have to borrow a lot of money these days to'\nsay 'be an average consumer.'\n  return\nML787:\nsay 'He who dies with the most toys wins.'\n  return\nML788:\nsay 'A fool and his money soon go partying.'\n  return\nML789:\nsay 'If his IQ was any lower he''d be a plant.'\n  return\nML790:\nsay 'Everybody is ignorant, only on different subjects.'\n  return\nML791:\nsay 'It is far better to do nothing that to do'\nsay 'something efficiently'\nsay '              Siezbo'\n  return\nML792:\nsay 'The man who has no more problems is out of the game.'\n  return\nML793:\nsay 'The race goes not always to the swift, nor the battle'\nsay 'to the strong, but that''s the way to bet.'\n  return\nML794:\nsay 'A fool and his money are invited places.'\n  return\nML795:\nsay 'All things come to him whose name is on a mailing list.'\n  return\nML796:\nsay 'The hand that rocks the cradle usually is attached'\nsay 'to someone who isn''t getting enough sleep.'\n  return\nML797:\nsay 'After winning an argument with his wife,'\nsay 'the wisest thing a man can do is apologize.'\n  return\nML798:\nsay 'If opportunity came disguised as temptation,'\nsay 'one knock would be enough.'\n  return\nML799:\nsay 'If there was any justice in this world, people would'\nsay 'occasionally be permitted to fly over pigeons.'\n  return\nML800:\nsay 'Easy doesn''t do it.'\n  return\nML801:\nsay 'Most people want to be delivered from temptation but'\nsay ' would like it to keep in touch.'\n  return\nML802:\nsay 'When a distinguished scientist states something is'\nsay 'possible, he is almost certainly right.  When he'\nsay 'states that something is impossible, he is very'\nsay 'probably wrong.'\n  return\nML803:\nsay 'Early to rise and early to bed makes a male'\nsay 'healthy and wealthy and dead.'\n  return\nML804:\nsay 'Everyone gets away with something.'\nsay 'no one gets away with everything.'\n  return\nML805:\nsay 'Remain silent about your intentions until you are sure.'\n  return\n /*-------------------------------------------------------------*/\n /*         Extensions as added by me, Jim Marshall -- CBT 300  */\n /*-------------------------------------------------------------*/\nML806:\nsay 'Calm down .... It is only ones and zeros'\n  return\nML807:\nsay 'Real programmers don''t write COBOL.'\nsay 'COBOL is for wimpy applications programmers.'\n  return\nML808:\nsay 'I have not lost my mind --'\nsay '   it is backed up on tape somewhere.'\n  return\nML809:\nsay 'Real programmers do not document.'\nsay 'documentation is for simps who can''t read listings'\nsay ' or object code.'\n  return\nML810:\nsay 'Real programmers don''t write specs -- Users should'\nsay 'consider themselves lucky to get any programs at all and'\nsay 'take what they get.'\n  return\nML811:\nsay 'Real programmers don''t comment their code.  If it is hard'\nsay 'to write, it should be hard to understand.'\n  return\nML812:\nsay 'Real programmers don''t write applications programs; they'\nsay 'program right down on the bare metal.  Application'\nsay 'programming is for feebs who can''t do systems programming.'\n  return\nML813:\nsay 'Real programmers don''t eat quiche.   In fact, real'\nsay 'programmers don''t know how to spell quiche.  They eat'\nsay 'twinkies and szechwan food.'\n  return\nML814:\nsay 'Real programmer''s programs never work the first time.  But'\nsay 'if you throw them on the machine, they can be patched into'\nsay 'working in \"only a few\" 30-hour debugging sessions.'\n  return\nML815:\nsay 'Real programmers don''t write in FORTRAN. FORTRAN is for'\nsay 'pipe stress freaks and crystallography weenies.'\n  return\nML816:\nsay 'Real programmers never work 9 to 5.  If any real'\nsay 'programmers are around at 9 a.m., it''s because they'\nsay 'were up all night.'\n  return\nML817:\nsay 'Real programmers don''t write in basic.  Actually, no'\nsay 'programmers write in basic after age 12.'\n  return\nML818:\nsay 'Real programmers don''t write in PL/1. PL/1 is for'\nsay 'programmers who can''t decide whether to write in'\nsay 'COBOL or FORTRAN.'\n  return\nML819:\nsay 'Real programmers don''t play tennis or any other sport'\nsay 'that requires you to change clothes.  Mountain climbing is'\nsay 'ok, and real programmers wear their climbing boots to work'\nsay 'in case a mountain should suddenly spring up in the middle'\nsay 'of the machine room.'\n  return\nML820:\nsay 'Real programmers don''t write in Pascal, Bliss, or ADA, or'\nsay 'any of those pinko computer science languages.  Strong'\nsay 'typing is for people with weak memories.'\n  return\nML821:\nsay 'On a clear disk, you can seek forever.'\n  return\nML822:\nsay 'Hollerith got us into this hole mess!'\n  return\nML823:\nsay 'No major project is ever installed on time, within budgets,'\nsay 'with the same staff that started it.  Yours will not be the'\nsay 'first.'\n  return\nML824:\nsay 'When things are going well, something will go wrong.'\nsay 'When things just can''t get any worse, they will.'\nsay 'When things appear to be going better you have overlooked'\nsay 'something.'\nML825:\nsay 'If project content is allowed to change freely, the rate of'\nsay 'change will exceed the rate of progress.'\n  return\nML826:\nsay 'No system is ever completely debugged:  Attempts to debug'\nsay 'a system will inevitably introduce new bugs that are even'\nsay 'harder to find.'\n  return\nML827:\nsay 'A carelessly planned project will take three times'\nsay 'longer than expected; a carefully planned project will'\nsay 'take only twice as long.'\n  return\nML828:\nsay 'After all is said and done, a hell of a lot more is said '\nsay 'than done'\nML829:\nsay 'If it''s not in the computer, it doesn''t exist.'\n/**** Marshall's  ML830-ML879  can be found later in this list*/\nML830:\nsay 'It has been said that the ten most feared words in the'\nsay ' English language are:'\nsay '    '\nsay '   I''m from the federal government and I''m here to help.'\n  return\nML831:\nsay 'I owe, I owe'\nsay 'so it''s off to work I go.'\n  return\nML832:\nsay 'When a distinguised, but elderly, scientist says that'\nsay 'something is impossible, he is probably wrong.'\n  return\nML833:\nsay 'Support your local bloodhound, get lost !'\n  return\nML834:\nsay 'When I fly, I think about only three things --'\nsay '     faith, hope and gravity.'\n  return\nML835:\nsay 'The three stages of being sick: Ill, Pill, Bill.'\n  return\nML836:\nsay 'There are three ways to become a millionaire these'\nsay 'days:  Inherit it, earn it, sue.'\n  Return\nML837:\nsay 'Don''t try to teach a pig to sing .'\nsay 'it won''t work, and it annoys the pig .'\n  Return\nML838:\nsay '  Only four things in life are certain:'\nsay '    1.  Death'\nsay '    2.  Taxes'\nsay '    3.  IBM will dominate in mainframes'\nsay '    4.  IBM will once again jack up software prices'\n  return\nML839:\nsay ' It''s more blessed to give than to receive --'\nsay '       especially kittens.'\n  return\nML840:\nsay 'All the world loves a lover - except those who are'\nsay ' waiting to use the phone.'\n  return\nML841:\nsay 'You can''t fool all the people all the time.'\nsay ' highway-intercahnge signs come pretty close, however.'\n  Return\nML842:\nsay 'Talk is cheap - unless you hire a lawyer.'\n  return\nML843:\nsay 'In spite of the cost of living, it''s still popular.'\n  return\nML844:\nsay 'Winning isn''t everything, but it beats anything that'\nsay ' comes in second.'\n  return\nML845:\nsay ' In the approval cycle for an article:'\nsay '  The first  level of management will add a fact'\nsay '  The second level of management will edit that fact'\nsay '  The third  level of management will remove that fact.'\n  return\nML846:\nsay 'As soon as you sit down to a hot cup of coffee, your'\nsay 'boss will ask you to do something that will last'\nsay 'until the coffee is cold.'\n  return\nML847:\nsay 'A closed mouth gathers no food.'\n  return\nML848:\nsay ' Murphy''s axiom of preventative divorce:'\nsay '  An ounce of \"I don''t\" is worth'\nsay '   megatons of \"I wish I didn''t\"'\n  return\nML849:\nsay ' Marriage is like quicksand:'\nsay '   If you never get into it'\nsay '   you never have to worry about'\nsay '   getting out of it.'\n  return\nML850:           /*  06/87  */\nsay 'If you''re not the lead dog the scenery never changes.'\n  return\nML851:           /*  06/87  */\nsay 'Birds of a feather flock to a newly washed car.'\n  return\nML852:           /*  06/87  */\nsay 'A word to the wise is often enough to start an argument.'\n  return\nML853:           /*  06/87  */\nsay 'A bird in the hand is bad table manners.'\n  return\nML854:           /*  06/87  */\nsay 'Those who can, do.  Those who can''t, Write the instruction'\n  return\nML855:           /*  06/87  */\nsay 'Never serve meals on time; the starving eat anything.'\n  return\nML856:           /*  06/87  */\nsay 'The time it takes to find something is directly'\nsay 'proportional to its importance.'\n  return\nML857:           /*  06/87  */\nsay 'Anyone who even has to think about the cost had'\nsay 'better not get one.'\n  return\nML858:           /*  06/87  */\nsay 'The government''s biggest problem:'\nsay '     Trying to get more money from the'\nsay '     taxpayer without angering the voter.'\n  return\nML859:           /*  07/87  */\nsay ' On the other hand, give some people enough rope and'\nsay ' they''ll hang you.'\n  return\nML860:           /*  07/87  */\nsay 'Real programmers don''t write COBOL.'\nsay 'COBOL is for wimpy applications programmers.'\n  return\nML861:           /*  07/87  */\nsay 'I have not lost my mind -- It is backed up on tape somewhere.'\n  return\nML862:           /*  07/87  */\nsay 'Real programmers do not document.  Documentation is for simps'\nsay 'who can''t read listings or object code.'\n  return\nML863:           /*  07/87  */\nsay 'Real programmers don''t write specs -- Users should'\nsay 'consider themselves lucky to get any programs at all and'\nsay 'take what they get.'\n  return\nML864:           /*  07/87  */\nsay 'Real programmers don''t comment their code.  If it is hard'\nsay 'to write, it should be hard to understand.'\n  return\nML865:           /*  07/87  */\nsay 'Real programmers don''t write applications programs; they'\nsay 'program right down on the bare metal.  Application'\nsay 'programming is for feebs who can''t do systems programming.'\n  return\nML866:           /*  07/87  */\nsay 'Real programmers don''t eat quiche.   In fact, real'\nsay 'programmers don''t know how to spell quiche.  They eat'\nsay 'twinkies and szechwan food.'\n  return\nML867:           /*  07/87  same as ML814 */\nsay 'Real programmer''s programs never work the first time.  But'\nsay 'if you throw them on the machine, they can be patched into'\nsay 'working in \"only a few\" 30-hour debugging sessions.'\n  return\nML868:           /*  07/87  */\nsay 'Real programmers don''t write in FORTRAN. FORTRAN is for'\nsay 'pipe stress freaks and crystallography weenies.'\n  return\nML869:           /*  07/87  */\nsay 'Real programmers never work 9 to 5.  If any real'\nsay 'programmers are around at 9 a.m., it''s because they'\nsay 'were up all night.'\n  return\nML870:           /*  07/87  */\nsay 'Real programmers don''t write in basic.  Actually, no'\nsay 'programmers write in basic after age 12.'\n  return\nML871:           /*  07/87  */\nsay 'Real programmers don''t write in PL/1. PL/1 is for'\nsay 'programmers who can''t decide whether to write in'\nsay 'COBOL or FORTRAN.'\n  return\nML872:           /*  07/87  */\nsay 'Real programmers don''t play tennis or any other sport'\nsay 'that requires you to change clothes.  Mountain climbing is'\nsay 'ok, and real programmers wear their climbing boots to work'\nsay 'in case a mountain should suddenly spring up in the middle'\nsay 'of the machine room.'\n  return\nML873:           /*  07/87  -- same as ML820*/\nsay 'Real programmers don''t write in Pascal, Bliss, or ADA, or'\nsay 'any of those pinko computer science languages.  Strong'\nsay 'typing is for people with weak memories.'\n  return\nML874:           /*  07/87  */\nsay 'On a clear disk, you can seek forever.'\n  return\nML875:           /*  07/87  */\nsay 'Hollerith got us into this hole mess!'\n  return\nML876:           /*  07/87  */\nsay 'No major project is ever installed on time, within budgets,'\nsay 'with the same staff that started it.  Yours will not be the'\nsay 'first.'\n  return\nML877:           /*  07/87  */\nsay 'When things are going well, something will go wrong.'\nsay '- When things just can''t get any worse, they will.'\nsay '- When things appear to be going better you have overlooked'\nsay '  something.'\n  return\nML878:           /*  07/87  */\nsay 'If project content is allowed to change freely, the rate of'\nsay 'change will exceed the rate of progress.'\n  return\nML879:           /*  07/87  same as ML829 */\nsay 'No system is ever completely debugged:  Attempts to debug'\nsay 'a system will inevitably introduce new bugs that are even'\nsay 'harder to find.'\n  return\nML880:           /*  07/87  */\nsay 'A carelessly planned project will take three times'\nsay 'longer than expected; a carefully planned project will'\nsay 'take only twice as long.'\n  return\nML881:           /*  07/87  */\nsay ' \"Mystics always hope that science'\nsay '   will some day overtake them.\"'\nsay '    '\nsay '              Booth Tarkington'\n  return\nML882:           /*  07/87  */\nsay ' \"God bless us every one!\"'\nsay '    '\nsay '              Charles Dickens'\n  return\nML883:           /*  07/87  */\nsay ' \"For there is no such flatterer as a'\nsay '   man''s self; and there is no such remedy'\nsay '   against flattery of a man''s self as the'\nsay '   liberty of a friend.\"'\nsay '              Francis Bacon'\n  return\nML884:           /*  07/87  */\nsay ' \"A door is what a dog is perpetually'\nsay '   on the wrong side of.\"'\nsay '    '\nsay '              Ogden Nash'\n  return\nML885:           /*  07/87  */\nsay ' Trivia:  \"48\"'\nsay '   freckles on puppet Howdy Doody''s face'\nsay '   (stood for the 48 states in the 1950s)'\nsay '          \"1-0\"'\nsay '   score of a forfeited football game.'\n  return\nML886:           /*  07/87  */\nsay ' \"Freedom of the press is limited to'\nsay '   those who own one.\"'\nsay '    '\nsay '              A. J. Liebling'\n  return\nML887:           /*  07/87  */\nsay ' Trivia: \"boopadoop\"'\nsay '  blondie''s maiden name (from comic strip)'\nsay '         \"5\u00a2\"'\nsay '  Lucy van Pelt''s fee for psychiatric'\nsay '  advice (Peanuts comic strip).'\n  return\nML888:           /*  07/87  */\nsay ' \"Hearts will never be practical until'\nsay '   they can be made unbreakable.\"'\nsay '    '\nsay '              the wizard of oz'\nsay '               to the tin man.'\n  return\nML889:           /*  07/87  */\nsay ' Trivia: \"Great Stone Face\"'\nsay '  nickname of Joseph \"Buster\" Keaton'\nsay '         \"Krells\"'\nsay '  super-intelligent creatures that lived'\nsay '  below the surface of Altair iv.'\n  Return\nML890:           /*  07/87  */\nsay ' \"A sharp knife cuts the quickest and'\nsay '   hurts the least.\"'\nsay '    '\nsay '              Katharine Hepburn'\n  return\nML891:           /*  07/87  */\nsay ' \"Women are like elephants to me.'\nsay '   I like to look at them, but I'\nsay '   wouldn''t want to own one.\"'\nsay '    '\nsay '              W.C. Fields'\n  Return\nML892:           /*  07/87  */\nsay ' Trivia: \"Muhammad Ali\"'\nsay '  religious name adopted by Cassius'\nsay '  Marcellus Clay.'\nsay '         \"$400\"'\nsay '  cost of boardwalk (Monopoly game).'\n  Return\nML893:           /*  07/87  */\nsay ' \"The only grounds for divorce in'\nsay '   California are marriage.\"'\nsay '    '\nsay '              Cher'\n  return\nML894:           /*  07/87  */\nsay ' Trivia: Boy Scouts ages:'\nsay '     Cub Scouts-      age  8-10'\nsay '     Boy Scouts-      age 10-13'\nsay '     Explorer Scouts- age 14 and above'\nsay '    '\n  return\nML895:           /*  07/87  */\nsay ' \"When one hundred senators talk for'\nsay '   thirty-seven hours, enough natural gas'\nsay '   is produced.\"'\nsay '    '\nsay '              Henry Kissinger'\n  return\nML896:           /*  07/87  */\nsay ' \"Education is a method by which one'\nsay '   acquires a higher grade of'\nsay '   prejudices.\"'\nsay '    '\nsay '              Laurence J. Peter'\n  return\nML897:           /*  07/87  */\nsay ' \"The secret of education is'\nsay '   respecting the pupil.\"'\nsay '    '\nsay '              Ralph Waldo Emerson'\n  return\nML898:           /*  07/87  */\nsay ' \"History is a set of lies'\nsay '   agreed upon.\"'\nsay '    '\nsay '              Napoleon Bonaparte'\n  return\nML899:           /*  07/87  */\nsay ' \"The natural progress of things is for'\nsay '   liberty to yield and government to'\nsay '   gain ground.\"'\nsay '    '\nsay '              Thomas Jefferson'\n  return\nML900:           /*  07/87  */\nsay ' \"The best audience is one that is'\nsay '   intelligent, well-educated'\nsay '   -and a little drunk.\"'\nsay '    '\nsay '              Alben W. Barkley'\n  return\nML901:           /*  07/87  */\nsay ' \"Problems are only opportunities in'\nsay '   work clothes.\"'\nsay '    '\nsay '              Henry J. Kaiser'\n  return\nML902:           /*  07/87  */\nsay ' \"You can''t sit on the lid of progress.'\nsay '   if you do, you will be blown to pieces.\"'\nsay '    '\nsay '              Henry J. Kaiser'\n  return\nML903:           /*  07/87  */\nsay ' \"It isn''t power, it''s persuasion that'\nsay '   makes things successful.  The more we'\nsay '   grow in size, it will be by'\nsay '   persuasion.\"'\nsay '              Henry J. Kaiser'\n  return\nML904:           /*  07/87  */\nsay ' \"The only limit to our realization of'\nsay '   tomorrow will be our doubts of today.'\nsay '   let us move forward with strong and'\nsay '   active faith.\"'\nsay '              Henry J. Kaiser'\n  return\nML905:           /*  07/87  */\nsay ' \"There''s only one time to do anything'\nsay '   and that''s today.\"'\nsay '    '\nsay '              Henry J. Kaiser'\n  return\nML906:           /*  07/87  */\nsay ' \"Beware of the man who goes to cocktail'\nsay '   parties not to drink but to listen.\"'\nsay '    '\nsay '              Pierre Daninos'\n  return\nML907:           /*  07/87  */\nsay ' \"One nice thing about egotists:'\nsay '   They don''t talk about other people.\"'\nsay '    '\nsay '              Lucille S. Harper'\n  return\nML908:           /*  07/87  */\nsay ' \"Satan hasn''t a single salaried helper;'\nsay '   the opposition employs a million.\"'\nsay '    '\nsay '              Mark Twain'\n  return\nML909:           /*  07/87  */\nsay ' \"Everyone is a genius at least once a'\nsay '   year; a real genius has his original'\nsay '   ideas closer together.\"'\nsay '    '\nsay '              G.C. Lichtenberg'\n  return\nML910:           /*  07/87  */\nsay ' \"Abraham Lincoln wrote the Gettysburg'\nsay '   address while travelling from'\nsay '   Washington to Gettysburg on the back'\nsay '   of an envelope.\" (sic)'\nsay '              Louis Untermeyer'\n  return\nML911:           /*  07/87  */\nsay ' \"The difference between a politician and'\nsay '   a statesman is:  A politician thinks'\nsay '   of the next election and a statesman'\nsay '   thinks of the next generation.\"'\nsay '              James Freeman Clarke'\n  return\nML912:           /*  07/87  */\nsay ' \"Courtroom: A place where Jesus Christ and'\nsay '   Judas Iscariot would be equals, with'\nsay '   the betting odds in favor of Judas.\"'\nsay '    '\nsay '              H.L. Mencken'\n  return\nML913:           /*  07/87  */\nsay ' \"Sanity is madness put to good use.\"'\nsay '    '\nsay '              George Santayana'\n  return\nML914:           /*  07/87  */\nsay ' \"Only the past is immortal.\"'\nsay '    '\nsay '              Delmore Schwartz'\n  return\nML915:           /*  07/87  */\nsay ' \"Whoever named it necking was a poor'\nsay '   judge of anatomy.\"'\nsay '    '\nsay '              Groucho Marx'\n  return\n  return\nML916:           /*  07/87  */\nsay ' \"The end move in politics is always'\nsay '   to pick up the gun.\"'\nsay '    '\nsay '              Buckminster Fuller'\n  return\nML917:           /*  07/87  */\nsay '\"Everyone is the child of his past.\"'\nsay '    '\nsay '              Edna G. Rostow'\n  return\nML918:           /*  07/87  */\nsay ' \"To many people dramatic criticism must'\nsay '   be like trying to tattoo soap bubbles.\"'\nsay '    '\nsay '              John Mason Brown'\n  return\nML919:           /*  07/87  */\nsay ' \"An intellectual is someone whose mind'\nsay '   watches itself.\"'\nsay '    '\nsay '              Albert Camus'\n  return\nML920:           /*  07/87  */\nsay ' \"There''s a sucker born every minute.\"'\nsay '              P. T. Barnum'\n  return\nML921:           /*  07/87  */\nsay ' \"A fool and his money are soon parted.\"'\nsay '              James Howell'\n  return\nML922:           /*  07/87  */\nsay ' \"I know only two tunes:  One of them is'\nsay '   ''Yankee Doodle,''  And the other'\nsay '   isn''t.\"'\nsay '    '\nsay '              Ulysses S. Grant'\n  return\nML923:           /*  07/87  */\nsay ' \"Find a need and fill it.\"'\nsay '    '\nsay '              Henry J. Kaiser'\n  return\nML924:           /*  07/87  */\nsay ' \"Don''t bring me any thing but trouble.'\nsay '   good news weakens me.\"'\nsay '    '\nsay '              Henry J. Kaiser'\n  return\nML925:           /*  07/87  */\nsay ' \"Let''s keep on being the kind of'\nsay '   organization that''s never satisfied'\nsay '   with itself.\"'\nsay '    '\nsay '              Henry J. Kaiser'\n  return\nML926:           /*  07/87  */\nsay ' \"Let''s not stifle ideas by inaction.'\nsay '   we can, if we will, keep forever'\nsay '   building the tomorrow that is better'\nsay '   than yesterday.\"'\nsay '              Henry J. Kaiser'\n  return\nML927:           /*  07/87  */\nsay ' Umbrella Law:'\nsay '  \"you will need three umbrellas:'\nsay '    one to leave at the office, one to'\nsay '    leave at home, and one to leave on the'\nsay '    train.\"'\n  return\nML928:           /*  07/87  */\nsay ' Bell''s Rule. \"The average time between'\nsay '   throwing something away and needing it'\nsay '   badly is two weeks.  This time can be'\nsay '   reduced to one week by retaining the'\nsay '   thing for a long time first.\"'\n  return\nML929:           /*  07/87  */\nsay ' Rowe''s Rule.  \"The odds are 6 to 5 that'\nsay '   the light at the end of the tunnel is a'\nsay '   headlight on an oncoming express'\nsay '   train.\"'\nsay '    '\n  return\nML930:           /*  07/87  */\nsay ' Ogden''s Law:'\nsay ' \"The sooner you fall behind, the more'\nsay '  time you have to catch up.\"'\n  return\nML931:           /*  07/87  */\nsay ' Air Force Law: \"Two % don''t get the word.\"'\nsay '    '\nsay ' Berra''s Law:'\nsay '  \"You can observe a lot just by watching.\"'\nsay '    '\n  return\nML932:           /*  07/87  */\nsay ' \"The devil can cite scripture for his'\nsay '  purpose.\"'\nsay '    '\nsay '              William Shakespeare'\n  return\nML933:           /*  07/87  */\nsay ' \"The good neighbor looks beyond the'\nsay '   external accidents and discerns those'\nsay '   inner qualities that make all men'\nsay '   human and, therefore, brothers.\"'\nsay '              Martin Luther King, Jr'\n  Return\nML934:           /*  07/87  */\nsay ' \"There is a sufficiency in the world'\nsay '   for man''s need but not for man''s'\nsay '   greed.\"'\nsay '    '\nsay '              Mohandas Gandhi'\n  return\nML935:           /*  07/87  */\nsay ' \"Our existence is but a brief crack'\nsay '   of light between two eternities'\nsay '   of darkness.\"'\nsay '    '\nsay '              Vladimir Nabokov'\n  return\nML936:           /*  07/87  */\nsay ' \"Gross ignorance: 144 times worse than'\nsay '  ordinary ignorance.\"'\nsay '              Bennett Cerf'\n  return\nML937:           /*  07/87  */\nsay ' \"Ignorance is no excuse--- It''s the real'\nsay '  thing.\"      Irene Peter'\n  return\nML938:           /*  07/87  */\nsay ' \"The maxim of the British people is'\nsay '  ''business as usual.''\"'\nsay '    '\nsay '    '\nsay '              Winston Churchill'\n  return\nML939:           /*  07/87  */\nsay ' \"Oh, to be in england'\nsay '   now that April''s there.\"'\nsay '    '\nsay '    '\nsay '              Robert Browning'\n  return\nML940:           /*  07/87  */\nsay ' \"Englishman:  A creature who thinks he is'\nsay '   being virtuous when he is only being'\nsay '   uncomfortable.\"'\nsay '    '\nsay '              George Bernard Shaw'\n  return\nML941:           /*  07/87  */\nsay ' \"Contrary to popular belief, English'\nsay '   women do not wear tweed nightgowns.'\nsay '    '\nsay '              Hermione Gingold'\n  return\nML942:           /*  07/87  */\nsay ' \"If a playwright is funny, the English'\nsay '   look for a serious message, and if he''s'\nsay '   serious, they look for the joke.\"'\nsay '    '\nsay '              Sacha Guitry'\n  return\nML943:           /*  07/87  */\nsay ' \"Eternal vigilance is the'\nsay '    price of liberty.\"'\nsay '    '\nsay '              Wendel Phillips'\n  return\nML944:           /*  07/87  */\nsay ' \"No Negro American can be free until the'\nsay '   lowest Negro in Mississippi is no longer'\nsay '   disadvantaged because of his race.\"'\nsay '    '\nsay '              Ralph Bunche'\n  return\nML945:           /*  07/87  */\nsay ' \"Liberty means responsibility.'\nsay '   that is why most men dread it.\"'\nsay '    '\nsay '              George Bernard Shaw'\n  return\nML946:           /*  07/87  */\nsay ' \"Freedom is not enough.\"'\nsay '              Lyndon B. Johnson'\n  return\nML947:           /*  07/87  */\nsay ' \"Liberty doesn''t work as well in practice'\nsay '   as it does in speeches.\"'\nsay '              Will Rogers'\n  return\nML948:           /*  07/87  */\nsay ' \"At no time is freedom of speech more'\nsay '   precious than when a man hits his'\nsay '   thumb with a hammer.\"'\nsay '    '\nsay '              Marshall Lumsden'\n  return\nML949:           /*  07/87  */\nsay ' \"All work and no play makes Jack a dull'\nsay '   boy--- and Jill a wealthy widow.\"'\nsay '    '\nsay '              Evan Esar'\n  return\nML950:           /*  07/87  */\nsay ' \"I''m a great believer in luck,'\nsay '   and I find the harder I work the more'\nsay '   I have of it.\"'\nsay '    '\nsay '              Thomas Jefferson'\n  return\nML951:           /*  07/87  */\nsay ' \"The world will never have lasting'\nsay '   peace so long as men reserve for'\nsay '   war the finest human qualities.\"'\nsay '    '\nsay '              John Foster Dulles'\n  return\nML952:           /*  07/87  */\nsay ' \"It is not the employer who pays the'\nsay '   wages--- He only handles the money.'\nsay '   it is the product that pays wages.\"'\nsay '    '\nsay '              Henry Ford'\n  return\nML953:           /*  07/87  */\nsay ' \"Ask not what your country can do for you'\nsay '   but what you can do for your country.\"'\nsay ' \"The united states has to move very fast'\nsay '   to even stand still.\"'\nsay '              John F. Kennedy'\n  return\nML954:           /*  07/87  */\nsay ' \"One fifth of the people are against'\nsay '   everything all the time.\"        r.f.k.'\n  Return\nML955:           /*  07/87  */\nsay ' \"It isn''t that I''m a saint.  It''s just'\nsay '   that I''ve never found it necessary'\nsay '   to be a sinner.\"                 R.F.K'\n  return\nML956:           /*  07/87  */\nsay ' \"Let us never negotiate out of fear,'\nsay '   but let us never fear to negotiate.\"'\nsay '    '\nsay '              John F. Kennedy'\n  return\nML957:           /*  07/87  */\nsay ' \"Is there such a thing as shoppers'\nsay '   anonymous?\"'\nsay '    '\nsay '   John F. Kennedy, on receiving a $40,000'\nsay '             bill for his wife''s clothes.'\n  Return\nML958:           /*  07/87  */\nsay ' \"If a free society cannot help the many'\nsay '   who are poor, it cannot save the few'\nsay '   who are rich.\"                   J.F.K'\n  return\nML959:           /*  07/87  */\nsay ' \"Mankind must put an end to war, or war'\nsay '   will put an end to mankind.\"     j.f.k.'\n  Return\nML960:           /*  07/87  */\nsay ' \"When choosing between two evils,'\nsay '   I always like to try the one'\nsay '   I''ve never tried before.\"'\nsay '    '\nsay '              Mae West'\n  return\nML961:           /*  07/87  */\nsay ' \"I name thee old glory.\"'\nsay '              Captain William Driver'\n  return\nML962:           /*  07/87  */\nsay ' \"If anyone attempts to haul down the'\nsay '   American flag, shoot him on the spot.\"'\nsay '              John A. Dix'\n  return\nML963:           /*  07/87  */\nsay ' \"Most people like hard work.'\nsay '   particularly when they are'\nsay '   paying for it.\"'\nsay '    '\nsay '              Franklin P. Jones'\n  return\nML964:           /*  07/87  */\nsay ' \"Crime is contagious.'\nsay '   if the government becomes a law-breaker,'\nsay '   it breeds contempt for the law.\"'\nsay '    '\nsay '              Justice Louis D. Brandeis'\n  return\nML965:           /*  07/87  */\nsay ' \"Computers can figure out all kinds of'\nsay '   problems, except the things that'\nsay '   just don''t add up.\"'\nsay '    '\nsay '              James Magary'\n  return\nML966:           /*  07/87  */\nsay ' \"Since we cannot know all that is to be'\nsay '   known of everything, we ought to know'\nsay '   a little about everything.\"'\nsay '    '\nsay '              Blaise Pascal'\n  return\nML967:           /*  07/87  */\nsay ' \"The last thing that we find in making'\nsay '   a book is to know what we must put'\nsay '   first.\"'\nsay '    '\nsay '              Blaise Pascal'\n  return\nML968:           /*  07/87  */\nsay ' \"If all men knew what each said of the'\nsay '   other, there would not be four friends'\nsay '   in the world.\"'\nsay '    '\nsay '              Blaise Pascal'\n  return\nML969:           /*  07/87  */\nsay ' \"Justice without force is powerless;'\nsay '   force without justice is tyrannical.\"'\nsay '    '\nsay '              Blaise Pascal'\n  return\nML970:           /*  07/87  */\nsay ' \"The heart has its reasons which reason'\nsay '   does not understand.\"'\nsay '    '\nsay '              Blaise Pascal'\n  return\nML971:           /*  07/87  */\nsay ' \"I admit I may have dozed though some'\nsay '   of the sessions.  But I haven''t'\nsay '   had a good rest since the campaign.\"'\nsay '    '\nsay '              S. I. Hayakawa'\n  return\nML972:           /*  07/87  */\nsay ' \"More men have been elected between'\nsay '   sundown and sunup than ever were elected'\nsay '   elected between sunup and sundown.\"'\nsay '    '\nsay '              Will Rogers'\n  return\nML973:           /*  07/87  */\nsay ' \"It makes no difference who you vote for--'\nsay '   the two parties are really one party'\nsay '   representing 4 precent of the people.\"'\nsay '    '\nsay '              Gore Vidal'\n  return\nML974:           /*  07/87  */\nsay ' \"We''re going to move left and right'\nsay '   at the same time.\"'\nsay '    '\nsay '              Governor Jerry Brown'\n  return\nML975:           /*  07/87  */\nsay ' \"I always have to dream up there against'\nsay '   the stars.  If I don''t dream I''ll make'\nsay '   it, I won''t even get close.\"'\nsay '    '\nsay '              Henry J. Kaiser'\n  return\nML976:           /*  07/87  */\nsay 'Calm down .... It is only ones and zeros'\n  return\nML977:           /*  07/87  */\nsay ' \"Thank heaven for the military-industrial'\nsay '   complex.  Its ultimate aim is peace'\nsay '   in our time.\"'\nsay '    '\nsay '              Barry Goldwater'\n  return\nML978:           /* 08/01    */\nsay 'All that glitters has a high refractive index.'\n  return\nML979:           /* 08/01    */\nsay 'Manufacturers rebate - company''s way of letting you'\nsay 'know you''ve been overcharged.'\n  return\nML980:           /* 08/87    */\nsay 'Trust everybody but cut the cards.'\n  return\nML981:           /* 08/87    */\nsay 'It''s not the principal of the thing, it''s the interest.'\n  return\nML982:           /* 08/87    */\nsay 'The best helping hand I ever got'\nsay 'was at the end of my own arm.'\n  return\nML983:           /* 09/87    */\nsay 'Never put off till tomorrow what you can do the'\nsay 'day after.'\n  return\nML984:           /*  09/87   */\nsay 'A cliche is only something well said in the first place.'\n  return\nML985:           /*  09/87   */\nsay 'If you can''t be kind, at lease be vague.'\n  return\nML986:           /*  09/87   */\nsay 'All progress is based upon a universal innate desire on'\nsay 'the part of every organism to live beyond its income.'\n  return\nML987:           /*  09/87   */\nsay 'A billion here, a billion there, pretty soon it adds'\nsay 'up to real money.'\nsay '    '\nsay '              Senator Everett Dirksen'\n  return\nML988:           /*  09/87   */\nsay 'Inside every large program is a small program'\nsay 'struggling to get out.'\n  return\nML989:        /* 09/87                  */\nsay 'The attention span of a computer is only as long as'\nsay 'its electrical cord.'\n  return\nML990:        /* 09/87                  */\nsay 'One good reason why computers can do more work than'\nsay 'people is that they never have to stop and answer'\nsay 'the phone.'\n  return\nML991:        /* 09/87                  */\nsay 'VSAM is a four letter word.'\n  return\nML992:        /* 09/87                  */\nsay 'Everyone has the right to do what they want,'\nsay ' but is it right to do it.'\n  return\nML993:\nsay 'The likelihood of someone doing 50 MPH in the fast'\nsay 'lane is directly proportional to how late you are'\nsay 'for work.'\n  return\nML994:\nsay 'Traffic always flows faster in the other lanes.'\n  return\nML995:\nsay 'The changes of someone making a right turn from the'\nsay 'left-turn lane are a constant one in three.'\n  return\nML996:\nsay 'Chances of the individual making this turn while'\nsay 'flashing his left turn signal are a constant one in six.'\n  return\nML997:\nsay 'The windshield wiper on the passenger side always'\nsay 'work better.'\n  return\nML998:\nsay 'The windshield wipers will disintegrate only when'\nsay 'you turn them on during the worst rainstorm of the'\nsay 'decade.'\n  return\nML999:\nsay 'The chances of the spare tire being flat are in direct'\nsay 'ratio to the distance from the nearest town.'\n  return\nML1000:\nsay 'A tire will never go flat unless:'\nsay '     A. The grade is at least 10 percent'\nsay '     B. The tool kit is covered by at least 87 pounds'\nsay '        of luggage'\nsay '     C. You loaned your jack to a friend'\n  return\nML1001:\nsay 'The only point under the car from which oil will drip'\nsay 'is directly above where you will be lying.'\n  return\nML1002:\nsay 'If there is any possibility of installing a part'\nsay 'backwards, that''s the only way it will look correct.'\n  return\nML1003:\nsay 'The usefulness of a computer printout is inversely'\nsay 'proportional to its weight.'\n  return\nML1004:\nsay 'The world is full of willing people, some willing to'\nsay 'work, the rest willing to let them.'\n  return\nML1005:\nsay 'My father taught me to work, he did not teach me to'\nsay 'love it.'\n  return\nML1006:\nsay 'Most people like hard work.'\nsay 'particularly when they are paying for it.'\n  Return\nML1007:\nsay 'If a thing is worth doing, its worth doing badly.'\n  return\nML1008:\nsay 'Work is the greatest thing in the world, so we should'\nsay 'always save some of it for tomorrow.'\n  Return\nML1009:\nsay 'He had insomnia so bad that he couldn''t sleep'\nsay 'when he was working.'\n  return\nML1010:\nsay 'You can''t get there from here.'\n  return\nML1011:\nsay 'If your project doesn''t work, look for the part you'\nsay 'didn''t think was important.'\n  return\nML1012:\nsay 'Nothing is as easy as it looks.'\n  return\nML1013:\nsay 'Beauty is only skin deep, but ugly goes right to the bone.'\n  return\nML1014:\nsay 'You may know where the market is going but you can''t'\nsay 'know where it''s going after that.'\n  return\nML1015:\nsay 'If you''re early, it will be canceled.  It you''re on'\nsay 'time it will be over.'\n  return\nML1016:\nsay 'When opportunity knocks, you''ve got headphones on.'\n  return\nML1017:\nsay 'Any bureaucracy reorganized to enhance efficiency is'\nsay 'immediately indistinguishable from its predecessor.'\n  return\nML1018:\nsay 'Any order that can be misunderstood has been'\nsay 'misunderstood.'\n  return\nML1019:\nsay 'If your condition seems to be getting better, your'\nsay 'doctor is probably getting sick.'\n  return\nML1020:\nsay 'There is always room at the top - after an investigation.'\n  return\nML1021:\nsay 'There are two types of people :'\nsay '    those who divide people into two groups'\nsay '    and those who don''t.'\n  return\nML1022:\nsay 'You are always complimented on the dish that took the'\nsay 'least effort to prepare.'\n  return\nML1023:\nsay 'The person with the least expertise has the most opinions.'\n  return\nML1024:\nsay 'If it''s in French, you can''t afford it.'\n  return\nML1025:\nsay 'The one you want is never the one on sale.'\n  return\nML1026:\nsay 'When you drop change at the vending machine, the'\nsay 'pennies will fall nearby while all the other coins'\nsay 'will roll out of sight.'\n  return\nML1027:\nsay 'Wind velocity increases in direct proportion to the'\nsay 'cost of the hairdo.'\n  return\nML1028:\nsay 'After you''ve mailed your last Christmas card, you'\nsay 'will receive one from someone you''ve overlooked.'\n  return\nML1029:\nsay 'If it weren''t for the last minute, nothing would'\nsay 'ever get done.'\n  return\nML1030:\nsay 'Unbreakable toys aren''t.'\n  return\nML1031:\nsay 'Nothing is ever so bad that it can''t get worse.'\n  return\nML1032:\nsay 'Law of Regressive Achievement:'\nsay '  last year''s was always better.'\n  return\nML1033:\nsay 'Nothing is as inevitable as a mistake whose time'\nsay 'has come.'\n  return\nML1034:\nsay 'If it''s worth doing, it''s worth overdoing.'\n  return\nML1035:\nsay 'The most expensive component is the one that breaks.'\n  return\nML1036:\nsay 'Cleanliness is next to impossible.'\n  return\nML1037:\nsay 'You never want the one you can afford.'\n  return\nML1038:\nsay 'It requires less energy to take an object out of its'\nsay 'proper place than to put it back.'\n  return\nML1039:\nsay 'Everybody should believe in something....I believe'\nsay 'I''ll have another drink.'\n  return\nML1040:\nsay 'When someone you admire appears to be thinking deep'\nsay 'thoughts, he is probably thinking about lunch.'\n  return\nML1041:\nsay 'If anything can''t go wrong it will.'\n  return\nML1042:\nsay 'No matter what goes wrong, there is always someone'\nsay 'who knew it would.'\n  return\nML1043:\nsay 'If they say you''ll get used to it, you won''t.'\n  return\nML1044:\nsay '2 wrongs are only the beginning.'\n  return\nML1045:\nsay 'Government corruption will be reported in the past tense.'\n  return\nML1046:\nsay 'The only way to discover the limits of the possible'\nsay 'is to go beyond them.'\n  return\nML1047:\nsay 'There''s no time like the present for postponing'\nsay 'what you don''t want to do.'\n  return\nML1048:\nsay 'Nobody notices the big errors.'\n  return\nML1049:\nsay 'When the remedies don''t cure the problem, government'\nsay 'modifies the problem not the remedies.'\n  return\nML1050:\nsay 'The one time you relax is the one time the boss walks'\nsay 'into your office.'\n  return\nML1051:\nsay 'Nature will tell you a direct lie if she can.'\n  return\nML1052:\nsay 'Only adults have difficulty with child proof bottles.'\n  return\nML1053:\nsay 'It is a simple task to make things complex, but a'\nsay 'complex task to make them simple.'\n  return\nML1054:\nsay 'A dandelion from a lover means more than an orchid'\nsay 'from a friend.'\n  return\nML1055:\nsay 'Almost anything is easier to get into that to get out of.'\n  return\nML1056:\nsay 'No matter how often a lie is proven to be false, there'\nsay 'will be people who believe it to be true.'\n  return\nML1057:\nsay 'Only God can make a random selection.'\n  return\nML1058:\nsay 'Vital paper will show their vitality be moving from'\nsay 'where you left them to where you can''t find them.'\n  return\nML1059:\nsay 'No man''s life, liberty or property is safe when the'\nsay 'legislature is in session.'\n  return\nML1060:\nsay 'Law of Taxes:  Whatever goes up, stays up.'\n  return\nML1061:\nsay 'All things being equal, you lose.'\n  return\nML1062:\nsay 'Everything put together falls apart sooner or later.'\n  return\nML1063:\nsay 'Women''s liberation didn''t.'\n  return\nML1064:\nsay 'You can always find what you''re not looking for.'\n  return\nML1065:\nsay 'When people are free to do as they please, they'\nsay 'usually imitate each other.'\n  return\nML1066:\nsay 'Iron law of Distribution:'\nsay '  them that has, gets.'\n  return\nML1067:\nsay 'Law of Sports Contracts:'\nsay ' the more money a free agent signs for, the less'\nsay ' effective he becomes.'\n  return\nML1068:\nsay 'The Revolutionary Law:'\nsay ' the scroungier the rebel uniform, the more likely'\nsay ' a coup detat.'\n  return\nML1069:\nsay 'When parking, if you allow someone in front of you,'\nsay 'that driver will take the last available parking space.'\n  return\nML1070:\nsay 'When we try to pick out only one thing, we find it'\nsay 'hitched to everything else in the universe.'\n  return\nML1071:\nsay 'History repeats itself, that''s one of the things'\nsay 'wrong with history.'\n  return\nML1072:\nsay 'Of two possible events, only the undesired one will occur.'\n  return\nML1073:\nsay 'There is nothing so small that it can''t be blown'\nsay 'out of proportion.'\n  return\nML1074:\nsay 'There is always more dirty laundry than clean laundry.'\n  return\nML1075:\nsay 'The colder the x-ray table, the more of your body you'\nsay 'are required to place on it.'\n  return\nML1076:\nsay 'As soon as the stewardess serves the coffee,'\nsay ' the airplace encounters turbulence.'\n  return\nML1077:\nsay 'You can lead a horse to water, but if you get him to'\nsay ' float on his back you''ve got something.'\n  return\nML1078:\nsay 'As soon as you''re doing what you wanted to be doing,'\nsay 'you want to be doing something else.'\n  return\nML1079:\nsay 'It always take longer to get there than to get back.'\n  return\nML1080:\nsay 'Anything can happen, if it''s not covered by your'\nsay 'insurance.'\n  return\nML1081:\nsay 'The candy bar you planned to eat on the way home from'\nsay 'the market is hidden at the bottom of the grocery bag.'\n  return\nML1082:\nsay 'The shopping cart with the worse wheels is the one'\nsay 'you chose.'\n  return\nML1083:\nsay 'Sow your wild oats on Saturday night -- Then on Sunday'\nsay 'pray for a crop failure.'\n  return\nML1084:\nsay 'Where you stand depends on where you sit.'\n  return\nML1085:\nsay 'Doing it the hard way is always easier.'\n  return\nML1086:\nsay 'Wisdom consists of knowing when to avoid perfection.'\n  return\nML1087:\nsay 'The driver behind you always wants to go faster'\nsay 'than you do.'\n  return\nML1088:\nsay 'If it looks easy, it''s tough, if it looks tough,'\nsay 'it''s impossible.'\n  return\nML1089:\nsay 'The lightest-colored fabric attracts the'\nsay ' darkest-colored stain.'\n  return\nML1090:\nsay 'If you understand it, it''s obsolete.'\n  return\nML1091:\nsay 'A crisis is when you can''t say:'\nsay '  let''s forget the whole thing.'\n  return\nML1092:\nsay 'Every solution breeds new problems.'\n  return\nML1093:\nsay 'When you try to prove to someone that a machine'\nsay 'won''t work, it will.'\n  return\nML1094:\nsay 'The bigger they are, the harder they hit.'\n  return\nML1095:\nsay 'Whenever you set out to do something, something else'\nsay ' must be done first.'\n  return\nML1096:\nsay 'The client who pays the least complains the most.'\n  return\nML1097:\nsay 'The one remaining course you must take to graduate will'\nsay 'not be offered during your last semester.'\n  return\nML1098:\nsay 'The only labor worth laboring for is a labor of love.'\n  return\nML1099:\nsay 'Any simple problem can be made insoluble if enough'\nsay 'meeting are held to discuss it.'\n  return\nML1100:\nsay 'Anything that can be changed will be changed until'\nsay 'there is not time left to change anything.'\n  return\nML1101:\nsay 'When you''re not in a hurry, the traffic light will'\nsay 'turn green as soon as your car comes to a complete stop.'\n  return\nML1102:\nsay 'No post office ever loses your junk mail.'\n  return\nML1103:\nsay 'There is no limit to how weird things can get.'\n  return\nML1104:\nsay 'No matter how well you perform your job, a superior'\nsay 'will seek to modify the results.'\n  return\nML1105:\nsay 'Hockey is a game played by six good players and'\nsay 'the home team.'\n  return\nML1106:\nsay 'If something is confidential it will be left'\nsay 'in the copier.'\n  return\nML1107:\nsay 'No patient should attempt to leave the hospital until'\nsay 'he is strong enough to face the cashier.'\n  return\nML1108: say 'ML1108: Missing and presumed censored.';return\nML1109:\nsay 'Tall people have higher standards.'\n  return\nML1110:\nsay 'What can you expect of a day that beings with getting'\nsay 'up in the morning.'\n  return\nML1111:\nsay 'I can''t be overdrawn, I still have some checks.'\n  return\nML1112:\nsay 'Age is a state of mind'\nsay 'don''t ask me what state I''m in.'\n  return\nML1113:\nsay 'I''m not deaf'\nsay 'l'' ignoring you.'\n  return\nML1114:\nsay ' I refuse to have a battle of wits with an'\nsay '  unarmed person.'\n  return\nML1115:\nsay 'Everyone is entitled to my opinion.'\n  return\nML1116:\nsay 'Age is not important unless you''re a bottle of wine.'\n  return\nML1117:\nsay 'Whoever says money can''t buy happiness doesn''t'\nsay 'know where to shop.'\n  return\nML1118:\nsay 'I''m not overweight, I''m undertall.'\n  return\nML1119:\nsay 'Money isn''t everything but it sure keeps the'\nsay 'kids in touch.'\n  return\nML1120:\nsay 'Life is too short to drink cheap wine.'\n  return\nML1121:\nsay 'Neurotics build castles in the sky'\nsay 'psychotics live in them'\nsay 'psychologists collect the rent.'\n  return\nML1122:\nsay 'My tastes are simple'\nsay ' I only like the best.'\n  return\nML1123:\nsay 'Lindberg was the first man to fly the Atlantic alone'\nsay 'and the last to arrive the same time as his luggage.'\n  return\nML1124:\nsay 'Lightning is said never strikes twice in the same place'\nsay 'unless, of course, you let your insurance lapse.'\n  return\nML1125:\nsay 'Always remember that we pass this way but once, unless'\nsay 'you spouse is reading the road map.'\n  return\nML1126:\nsay 'The same work under the same conditions will be'\nsay 'estimated differently by ten different estimators'\nsay 'or by one estimator at ten different times.'\n  Return\nML1127:\nsay 'The most valuable and least used word in a Project'\nsay 'Manager''s vocabulary is \"No\".'\n  return\nML1128:\nsay 'You can con a sucker into committing an unreasonable'\nsay 'deadline, but you can''t bully him into meeting it.'\n  return\nML1129:\nsay 'The more ridiculous the deadline, the more it costs to'\nsay 'try to meet it.'\n  return\nML1130:\nsay 'The more desperate the situation, the more optimistic'\nsay ' the situatee.'\n  return\nML1131:\nsay 'Too few people on a project can''t solve the problems'\nsay 'too many create more problems than they solve.'\n  return\nML1132:\nsay 'You can freeze the user''s specs but he won''t'\nsay 'stop expecting.'\n  return\nML1133:\nsay 'Frozen specs and the abominable snowman are alike:'\nsay 'they are both myth and they both melt when sufficient'\nsay 'heat is applied.'\n  return\nML1134:\nsay 'The conditions attached to a promise are forgotten'\nsay 'and the promise is remembered.'\n  return\nML1135:\nsay 'A user will tell you anything you ask about-nothing more.'\n  return\nML1136:\nsay 'Of several possible interpretations of a communication'\nsay 'the least convenient one is the only correct one.'\n  return\nML1137:\nsay 'What is not on paper has not been said.'\n  return\nML1138:\nsay 'Parkinson and Murphy are alive and well-in your project.'\n  return\nML1139:\nsay 'I lead a life of wine, women and song -'\nsay ' it''s cheaper than gas, food and rent.'\n  return\nML1140:\nsay 'I''m not afraid of the unknown, the stuff we already'\nsay 'knows scares me.'\n  return\nML1141:\nsay 'The best cure for insomnia is a Monday morning.'\n  return\nML1142:\nsay 'It''s a strange world of language in which skating on'\nsay 'thin ice can get you into hot water.'\n  return\nML1143:\nsay 'Good communication is as stimulating as black coffee'\nsay 'and just as hard to sleep after.'\n  return\nML1144:\nsay 'Mondays are the potholes in the road of life.'\n  return\nML1145:\nsay 'Those who flee temptation generally leave a'\nsay '  forwarding address.'\n  return\nML1146:\nsay 'When you get to the end of your rope, tie a knot'\nsay ' and hang on.  And swing!'\n  return\nML1147:\nsay 'Ignorance doesn''t kill you, but it makes you sweat a log.'\n  return\nML1148:\nsay 'The more equipment you own, the less that will work.'\n  return\nML1149:\nsay 'If you fix one thing another thing breaks.'\n  return\nML1150:\nsay 'If one thing breaks, another things mysteriously'\nsay ' resumes working.'\n  return\nML1151:\nsay 'If you want to know what the temperature is, count'\nsay 'cricket chirps for 14 seconds, then add 40.  That''s'\nsay 'the temperature at the crickets'' location.'\n  return\nML1152:\nsay 'RMDS is a four letter word.'\n  return\nML1153:\nsay 'One thing that''s good about procrastination is that'\nsay 'you always have something planned for tomorrow.'\n  return\nML1154:\nsay 'Every morning I get up and look through the Forbes'\nsay 'list of the richest people in america.  If I''m not'\nsay 'there, I go to work.'\n  Return\nML1155:\nsay 'Why is it that you never get a flat tire on the curb side.'\n  return\nML1156:\nsay ' people who arrive late for the theater never have'\nsay ' aisle seats.'\n  return\nML1157:\nsay 'I''m on a rotation diet of my own.  Every time I turn'\nsay 'around I eat!'\n  return\nML1158:\nsay 'The nice thing about buying beer is that no one ever'\nsay ' asks what year you want.'\n  return\nML1159:\nsay 'He''s the kind of friend you can depend on - always'\nsay 'around when he needs you.'\n  return\nML1160:\nsay 'I''m exhausted. I Had to keep insisting to my kids that'\nsay 'I was Santa Claus, and to my wife that I wasn''t.'\n  return\nML1161:\nsay 'I don''t mind him being born again - but did he have'\nsay 'to come back as himself.'\n  return\nML1162:\nsay 'I eat from the three basic food'\nsay ' groups - canned, frozen and take-out.'\n  return\nML1163:\nsay 'Yes, the doctor has no objections to house calls.'\nsay ' what time can you be at his house?'\n  return\nML1164:\nsay 'Anyone who says he can see through women is missing a lot.'\n  return\nML1165:\nsay 'My Program   - a GEM of algoristic precision, offering'\nsay '  the most sublime balance between compact, efficient'\nsay '  coding on the one hand, and fully commented legibility'\nsay '  for posterity on the other.'\nsay 'Your Program - a MAZE of non sequiturs littered with'\nsay '  clever-clever tricks and irrelevant comments.'\n  return\nML1166:\nsay ' \"Start every day off with a smile and'\nsay '   get it over with.\"'\nsay '    '\nsay '              W.C. Fields'\n  Return\nML1167:\nsay 'Osborne computer school of economics:'\nsay 'lose money on each one and try to make it up on the volume.'\n  return\nML1168:\nsay 'Truth emerges more readily from error then from confusion.'\n  return\nML1169:\nsay 'The evolution of every business enterprise is away from'\nsay 'quality.  Products always get smaller, worse and'\nsay 'more expensive.'\n  return\nML1170:\nsay 'People will generally accept facts as truth only if'\nsay 'the facts agree with what they already believe.'\n  return\nML1171:\nsay 'No one wants to read a lot of good writing.  There''s'\nsay ' just so much good writing a reader can take.'\n  Return\nML1172:\nsay 'Getting up early in the morning is a good way to gain'\nsay ' respect without ever actually having to do anything.'\n  Return\nML1173:\nsay 'No matter how big the umbrella you carry or how good'\nsay ' your raincoat is, if it rains you get wet.'\n  Return\nML1174:\nsay 'If dogs could talk, it would take a lot of fun out of'\nsay ' owning one.'\n  Return\nML1175:\nsay 'We''re all proud of admitting little mistakes.  It gives'\nsay ' us the feeling we don''t make any big ones.'\n  return\nML1176:\nsay 'People who are wrong seem to talk louder than anyone else.'\n  return\nML1177:\nsay 'There aren''t many times in your life when your body'\nsay ' has absolutely nothing wrong with it.'\n  return\nML1178:\nsay 'Vacations aren''t necessarily better than other times,'\nsay ' they''re just different.'\n  return\nML1179:\nsay 'Key ring - a device for losing all your keys at once.'\n  return\nML1180:\nsay 'Politics is more dangerous then war, for in war you'\nsay ' are only killed once.'\n  return\nML1181:\nsay 'A consultant is someone who borrows your watch, then'\nsay 'gives you the time.'\n  return\nML1182:\nsay 'People who write subsystems usually use four letter words.'\n  return\nML1183:\nsay 'You can''t fool all the people all the time'\nsay 'highway - interchange signs come pretty close, however.'\n  return\nML1184:\nsay 'Hypocrisy is the homage that vice pays to virture.'\n  return\nML1185:\nsay 'He who laughs last probably has a backup.'\n  return\nML1186:\nsay 'The worst way to make an argument is by reason and'\nsay ' good information.  You must appeal to people''s'\nsay ' emotions and to their fears of being made to'\nsay ' look ridiculous.'\n  Return\nML1187:\nsay 'Few things are more satisfying than seeing your'\nsay 'children have teenagers of their own.'\n  return\nML1188:\nsay 'The optimist is the kind of person who believes a'\nsay 'housefly is looking for a way out.'\n  return\nML1189:\nsay 'Comedy is simply a funny way of being serious.'\n  return\nML1190:\nsay 'It''s not easy taking my problems one at a time when'\nsay 'they fuse to get in line.'\n  return\nML1191:\nsay 'Be cautious.  Opportunity does the knocking for'\nsay ' temptation too.'\n  Return\nML1192:\nsay 'The important thing about your lot in life is whether'\nsay ' you use it for building or parking.'\n  return\nML1193:\nsay 'I used to be indecisive, but now I''m not to sure.'\n  return\nML1194:\nsay 'With proper sleep, diet and care, a healthy body'\nsay ' will last a lifetime.'\n  return\nML1195:\nsay 'While money can''t buy everything, it certainly puts'\nsay ' you in a great bargaining position.'\n  return\nML1196:\nsay 'If you wait for a repairman, you''ll wait all day.'\nsay ' if you go out for five minutes, he''ll arrive and'\nsay ' leave while you''re gone.'\n  Return\nML1197:\nsay ' Zuccini is green tofu.'\n  return\nML1198:\nsay 'People who have the most birthdays live the longest.'\n  return\nML1199:\nsay 'Inside this body is a thin person screaming to get out'\nsay '   ...I ate her'\n  return\nML1200:\nsay 'If a severe problem manifests itself, no solution is'\nsay ' acceptable unless it is involved, expensive and'\nsay ' time consuming.'\n  return\nML1201:\nsay 'Everything takes longer than it takes.'\n  return\nML1202:\nsay 'Nothing is impossible for the person who doesn''t'\nsay '  have to do it.'\n  return\nML1203:\nsay 'In God we trust.  All others we polygraph'\n  return\nML1204:\nsay 'It''s the luck of the draw:'\nsay '   sometimes you get the elevator'\nsay '   sometimes you get the shaft.'\n  return\nML1205:\nsay 'If you don''t find me here look there.'\nsay 'if I''m not there then try some where else.'\nsay 'if you still can''t find me then I don''t want to'\nsay '    found.'\n  return\nML1206:\nsay 'Upper management is where programmers go when'\nsay 'they have forgotten how to program.'\n  return\nML1207:\nsay 'Programmers are the workers.'\nsay 'management is what is left over.'\n  return\nML1208:\nsay 'The day your ship comes in'\nsay 'you will probably be at the airport.'\n  return\nML1209:     /* Jim Marshall CBT 300 -- ML828:*/\nsay 'After all is said and done, a hell of a lot more is'\nsay 'said than done.'\n  return\nML1210:     /* Jim Marshall CBT 300 -- ML829:*/\nsay 'If it''s not in the computer, it doesn''t exist.'\n  return\nML1211:     /* Jim Marshall CBT 300 -- ML830:*/\nsay 'Never wrestle with a pig, you both get dirt, and the'\nsay 'pig likes it.'\n  return\nML1212:     /* Jim Marshall CBT 300 -- ML831:*/\nsay 'Never argue with an idiot: people watching may not be'\nsay 'able to tell the difference.'\n  return\nML1213:     /* Jim Marshall CBT 300 -- ML832:*/\nsay 'Don''t fight with a bear in his own cage.'\n  return\nML1214:     /* Jim Marshall CBT 300 -- ML833:*/\nsay 'The six steps of program management are:'\nsay '     1. Wild enthusiasm'\nsay '     2. Disenchantment'\nsay '     3. Total confusion'\nsay '     4. Search for the guilty'\nsay '     5. Punishment of the innocent'\nsay '     6. Promotion of the non-participants'\n  return\nML1215:     /* Jim Marshall CBT 300 -- ML834:*/\nsay 'He who hesitates is not only lost, but several miles'\nsay 'from the next freeway exit.'\n  return\nML1216:     /* Jim Marshall CBT 300 -- ML835:*/\nsay 'An expert doesn''t know any more than you do, he or she'\nsay 'is merely better organized and uses slides.'\n  return\nML1217:     /* Jim Marshall CBT 300 -- ML836:*/\nsay 'Nothing is impossible for the person who doesn''t have'\nsay 'to do it himself/herself.'\n  return\nML1218:     /* Jim Marshall CBT 300 -- ML837:*/\nsay 'You can lead a horse to water, but if you can get him to'\nsay 'float on his back, you''ve really got something.'\n  return\nML1219:     /* Jim Marshall CBT 300 -- ML838:*/\nsay 'You win some, lose some, and some get rained out: but you'\nsay 'gotta suit up for them all.'\n  return\nML1220:     /* Jim Marshall CBT 300 -- ML839:*/\nsay 'People are promoted not by what they can do, but what'\nsay 'people think they can do.'\n  return\nML1221:     /* Jim Marshall CBT 300 -- ML840:*/\nsay 'Don''t smoke in bed - the ashes on the floor might be yours.'\n  return\nML1222:     /* Jim Marshall CBT 300 -- ML841:*/\nsay 'Project management is the art of creating the illusion    '\nsay 'that an outcome is the result of a series of predetermined'\nsay 'deliberate acts, when in fact, it was dumb luck.'\n  return\nML1223:     /* Jim Marshall CBT 300 -- ML842:*/\nsay 'A MVS/XA system produced by expanding virtual storage of a'\nsay 'MVS/SP system, does not behave nor should be maintained  '\nsay 'like the MVS/SP system.'\n  return\nML1224:     /* Jim Marshall CBT 300 -- ML843:*/\nsay 'Barth''s Distinction:  There are two types of people: Those'\nsay 'who divide people into two types, and those who don''t.'\n  return\nML1225:     /* Jim Marshall CBT 300 -- ML844:*/\nsay 'Boren''s First Law:  When in doubt mumble.'\n  return\nML1226:     /* Jim Marshall CBT 300 -- ML845:*/\nsay 'Contingency Principle of Management:  It all depends.'\n  return\nML1227:     /* Jim Marshall CBT 300 -- ML846:*/\nsay 'Dibble''s First Law of Sociology: Some do and some don''t.'\n  return\nML1228:     /* Jim Marshall CBT 300 -- ML847:*/\nsay 'Dochter''s dictum: somewhere right now, there''s a '\nsay 'committee deciding your future; only you weren''t invited.'\n  return\nML1229:     /* Jim Marshall CBT 300 -- ML848:*/\nsay 'Etorre''s Observation: the other line moves faster.'\n  return\nML1230:     /* Jim Marshall CBT 300 -- ML849:*/\nsay 'First Rule of Motivation:  To err is human, to forgive'\nsay 'is not policy.'\n  return\nML1231:     /* Jim Marshall CBT 300 -- ML850:*/\nsay 'Gardner''s Philosophy:  Brillant opportunities are cleverly'\nsay 'disguised as insolvable problems.'\n  return\nML1232:     /* Jim Marshall CBT 300 -- ML851:*/\nsay 'Gordon''s First Law:  If a research project is worth doing,'\nsay 'then it is not worth doing well.'\n  return\nML1233:     /* Jim Marshall CBT 300 -- ML852:*/\nsay 'Hoar''s Law of Problems:  Inside very large problems is a '\nsay 'small problem struggling to get out.'\n  return\nML1234:     /* Jim Marshall CBT 300 -- ML853:*/\nsay 'Howe''s Law:  Every person has a scheme that won''t work.'\n  return\nML1235:     /* Jim Marshall CBT 300 -- ML854:*/\nsay 'Jenning''s Corollary:  The chance of bread falling with the'\nsay 'jelly side down is directly proportional to the cost of'\nsay 'carpet.'\n  return\nML1236:     /* Jim Marshall CBT 300 -- ML855:*/\nsay 'Law of Expectations:  Negative expectations yield negative'\nsay 'results; positive expectations also yield negative results.'\n  return\nML1237:     /* Jim Marshall CBT 300 -- ML856:*/\nsay 'Law of Probable Dispersal:  Whatever hits the fan will not'\nsay 'be evenly distributed.'\n  return\nML1238:     /* Jim Marshall CBT 300 -- ML857:*/\nsay 'Law of Right Thinking:  If you think you can or if you '\nsay 'think you can''t, you''re absolutley right.'\n  return\nML1239:     /* Jim Marshall CBT 300 -- ML858:*/\nsay 'Law of Selective Gravity:  An object will fall so as to do'\nsay 'the most damage.'\n  return\nML1240:     /* Jim Marshall CBT 300 -- ML859:*/\nsay 'Law of Verbal Burble:  When all is said and done, more is'\nsay 'said than done.'\n  return\nML1241:     /* Jim Marshall CBT 300 -- ML860:*/\nsay 'Longdon''t Law:  The more relevant a piece of information,'\nsay 'the more difficult it is to measure.'\n  return\nML1242:     /* Jim Marshall CBT 300 -- ML861:*/\nsay 'Maier''s Law: If the facts do not conform to the theory,'\nsay 'they must be modified.'\n  return\nML1243:     /* Jim Marshall CBT 300 -- ML862:*/\nsay 'Murphy''s Law:     '\nsay '1.  Nothing is as easy as it looks.           '\nsay '2.  Everything takes longer than you think.'\nsay '3.  If anything can go wrong, it will.'\n  return\nML1244:     /* Jim Marshall CBT 300 -- ML863:*/\nsay 'O''Toole''s Commentary on Murphy:  Murphy was an Optimist.'\n  return\nML1245:     /* Jim Marshall CBT 300 -- ML864:*/\nsay 'Parkinson''s Law:  Work expands so as to fill the time'\nsay 'available for its completion.'\n  return\nML1246:     /* Jim Marshall CBT 300 -- ML865:*/\nsay 'Pubber''s Observation: Anything that begins well, ends'\nsay 'badly.'\n  return\nML1247:     /* Jim Marshall CBT 300 -- ML866:*/\nsay 'Rule of projects:  The first 90% of any project takes 90%'\nsay 'of the time, and the last 10% takes another 90%.'\n  return\nML1248:     /* Jim Marshall CBT 300 -- ML867:*/\nsay 'Saint Benedict''s Dictum:  It is easier to beg forgiveness'\nsay 'than to seek permission.'\n  return\nML1249:     /* Jim Marshall CBT 300 -- ML868:*/\nsay 'Scheuber''s Hypothesis:  \"Don''t try to fix nothing that'\nsay 'ain''t broke.\" '\n  return\nML1250:     /* Jim Marshall CBT 300 -- ML869:*/\nsay 'Schultz''s Speculation:  If you can''t be right, be wrong'\nsay 'at the top of your voice.'\n  return\nML1251:     /* Jim Marshall CBT 300 -- ML870:*/\nsay 'Skinner''s Constant:  Quantity which, when multiplied'\nsay 'by, divided by, added to or subtracted from the answer you'\nsay 'get, gives you the answer you should have gotten.'\n  return\nML1252:     /* Jim Marshall CBT 300 -- ML871:*/\nsay 'The unspeakable law:  As soon as you mention something, if'\nsay 'it''s good, it goes away; if it''s bad, it happens.'\n  return\nML1253:     /* Jim Marshall CBT 300 -- ML872:*/\nsay 'Murphy''s Law of Programming:  The sooner you start coding'\nsay '          your program, the longer it is going to take.'\n  return\nML1254:     /* Jim Marshall CBT 300 -- ML873:*/\nsay 'James Joyce''s Law of Decompiling:  What''s source for the'\nsay '                           goose is object for the gander.'\n/********** end of Jim Marshall's  additions ************/\n  return\nML1255:\nsay 'The only thing we learn from history is that we learn'\nsay ' nothing from history.'\n  return\nML1256:\nsay 'Humpty Dumpty was pushed.'\n  return\nML1257:\nsay 'Forgetfulness is a sign of genius,'\nsay ' but I forgot who said it.'\n  return\nML1258:\nsay 'The Great Debugger is..........'\nsay '  methodical, persistent \"detective\" searching out'\nsay '  the guilty perpetrators of programming crimes.'\n  return\nML1259:\nsay 'The Great Debugger is..........'\nsay '  looking for the proverbial needle-in-the-haystack;'\nsay '  a bug is only a few bits out of 100 million zeroes'\nsay '  and ones.'\n  return\nML1260:\nsay 'The Great Debugger is..........'\nsay '  must use many different tools, never relying on just one.'\n  return\n/* Added by David McRitchie ......................................*/\n/**Wiegers' Laws of Computing */\n/* by Karl Wiegers -- Enterprise Systems Journal (ESJ), Apr. 1991*/\n /*More from ESJ by James E. Wilson, Westlake, OH, about Feb 93 */\nML1261:\nsay 'A half-truth is generally less than that.'\n  Return\nML1262:\nsay 'A penny saved doesn''t earn much. What with some'\nsay 'banks paying only one percent.'\n  Return\nML1263:\nsay 'A penny saved is a penny earned.'\nsay '                           -- Benjamin Franklin'\n  Return\nML1264:\nsay 'All programs are metastable.'\n  Return\nML1265:\nsay 'Almost nothing you can do with a computer is difficult.'\n  Return\nML1266:\nsay 'An undocumented feature is the moral equivalent of a bug.'\nsay '                           -- Karl E. Wiegers --'\n  Return\nML1267:\nsay 'Artificial intelligence is no substitute for the real thing.'\nsay '                           -- Karl E. Wiegers --'\n  Return\nML1268:\nsay 'Computer bugs are always discovered by the CEO of the'\nsay 'corporation.               -- Document Everything!'\n /* submitted to ESJ by James E. Wilson, Westlake, OH, about Feb 93 */\nML1269:\nsay 'Computer security manifest itself only to those who have set it'\nsay 'up for the system.  Just when users become familiar and'\nsay 'comfortable with the system, the IS department will upgrade.'\nsay '                           -- Document Everything!'\n /* submitted to ESJ by James E. Wilson, Westlake, OH, about Feb 93 */\n  Return\nML1270:\nsay 'Data entry errors will only be detected after the checks have'\nsay 'been mailed.               -- Document Everything!'\n  Return\nML1271:\nsay 'Errors will be discovered in the most important file'\nsay 'only after the backup tape has inadvertently been erased'\nsay '                           -- Document Everything!'\n /* submitted to ESJ by James E. Wilson, Westlake, OH, about Feb 93 */\n  Return\nML1272:\nsay 'Hanging is a suspended sentence.'\n  Return\nML1273:\nsay 'Hard work is never easy -- Dennis Devlin'\n  Return\nML1274:\nsay 'Humpty Dumpty sat on a wall,'\nsay 'Humpty Dumpty had a great fall.'\nsay 'All the king''s horses and all the king''s men'\nsay 'Searched in vain for documentation'\nsay 'To put him together again.'\nsay '                           -- Document Everything!'\n /* Enterprise Systems Journal -- humor Jan 1993 page 96 */\n /* Enterprise Systems Journal -- humor Jan 1993 page 96 */\n  Return\nML1275:\nsay 'If it is not in my computer and running, it does not exist.'\n  Return\nML1276:\nsay 'If one piece of valuable information is available'\nsay 'from a computer, it will be found in a 500-page printout.'\nsay '                           -- Document Everything!'\n /* submitted to ESJ by James E. Wilson, Westlake, OH, about Feb 93 */\n  Return\nML1277:\nsay 'If packaged properly, nearly any bug can be sold as a feature'\nsay '                           -- Karl E. Wiegers --'\n  Return\nML1278:\nsay 'If you are one week ahead of the other guy you are a wizard.'\n  Return\nML1279:\nsay 'If you can''t cut the mustard, you have to ketchup'\nsay '                        -- as Pat Testa''s grandpappy used to say'\n  Return\nML1280:\nsay 'Loop: See Loop.'\nsay '           -- definition by John Kador, Geneva, IL in ESJ Feb ''93'\n  Return\nML1281:\nsay 'Never test for a bug you don''t know how to fix.'\nsay 'There are two ways to write bug-free code; only the third way'\nsay 'works.  Debug is human; de-fix divine.  A feature is a bug with'\nsay 'seniority                  -- John Cochrane'\n  Return\nML1282:\nsay 'Nothing defeats prejudice better than excellence'\nsay '                           -- Oprah Winfrey'\n  /* Oprah Winfrey    quoted Larry Thall in PHOTO E.I., Nov92*/\nML1283:\nsay 'Once you have trapped all conceivable errors,  the users become'\nsay 'more creative.             -- Karl E. Wiegers --'\n  Return\nML1284:\nsay 'The additional benefits provided by a new software release in no'\nsay 'way compensates for the pain of installing it.'\nsay '                           -- Karl E. Wiegers --'\n  Return\nML1285:\nsay 'The current backup copy of any file is always  one generation too'\nsay 'old.                       -- Karl E. Wiegers --'\n  Return\nML1286:\nsay 'The error number you see when a program crashes is  the one that'\nsay 'is not described in the manual.  -- Karl E. Wiegers --'\n  Return\nML1287:\nsay 'The fixing of one bug generates at least two new latent bugs.'\nsay '                           -- Karl E. Wiegers --'\n  Return\nML1288:\nsay 'The larger the printout, the more important the bottom line.'\nsay '                           -- Document Everything!'\n /* submitted to ESJ by James E. Wilson, Westlake, OH, about Feb 93 */\n  Return\nML1289:\nsay 'The number of \"upwardly compatible\" software packages in the'\nsay 'world equals the number of unicorns.  -- Karl E.  Wiegers --'\n  Return\nML1290:\nsay 'The number of directors, managers plus operators'\nsay 'is always greater than the number of employees the computer was'\nsay 'bought to replace.'\n  Return\nML1291:\nsay 'The objective of all dedicated company employees should be to'\nsay 'thoroughly analyze all situations, anticipate all problems prior'\nsay 'to their occurrence, have answers for these problems, and move'\nsay 'swiftly to solve these problems when called upon;'\nsay '               HOWEVER,'\nsay 'When you are up to ass in alligators, it is difficult to remind'\nsay 'yourself that your initial objective was to drain the swamp.'\nsay ''\nsay '(We don''t drain swamps anymore, but the rest holds true).'\n  Return\nML1292:\nsay 'The only time a computer will be down is the time of most'\nsay 'critical need to the greatest amount of users.'\nsay '                           -- Document Everything!'\n /* submitted to ESJ by James E. Wilson, Westlake, OH, about Feb 93 */\n  Return\nML1293:\nsay 'The trouble with the RAT RACE is, even if you win,'\nsay 'you''re still a rat.       -- Lily Thomlin'\n  Return\nML1294:\nsay 'To Err is Human'\nsay '                           -- Benson Sloots'\n  Return\nML1295:\nsay 'Tom, Tom, the piper''s son,'\nsay 'Copied a disk and made it run.'\nsay 'Software Publishers caught up with him,'\nsay 'And now his future''s fairly grim.'\nsay '                           -- Believe it!'\n /* Enterprise Systems Journal -- humor Jan 1993 page 96 */\n  Return\nML1296:\nsay 'User manuals are consulted only after all possible  keystroke'\nsay 'combinations have failed.  -- Karl E. Wiegers --'\n  Return\nML1297:\nsay 'When a hammer is your only tool, everything else looks like a nail'\n  Return\nML1298:\nsay 'When a pessimist has the choice of two evils, he chooses both.'\nsay '                           -- Oscar Wilde I'\n  Return\nML1299:\nsay 'When only the bottom line is printed the greatest need will be'\nsay 'for details.               -- Document Everything!'\n  Return\nML1300:\nsay 'You can count on your friends, but it''s better to'\nsay 'count on your own fingers and toes'\nsay '                           -- Bazooka Joe - Bubble Gum'\n  Return\nML1301:\nsay 'If you worry about what people think of you,',\n    'it means that you have more confidence',\n    'in their opinions than you have in your own.'\n    /* attached to notes from  Human Resources */\n  Return\n/* 1302-1308 were gathered when we were on VSPC a long time ago */\nML1302:\nsay 'Bernetic''s Law:  A doggone computer is man''s best friend.'\n  Return\nML1303:\nsay 'A Law for the Future:'\nsay ' If it''s not in a computer, it doesn''t exit.'\n  Return\nML1304:\nsay 'Utvich''s Observation:'\nsay ' One accurate measurement is worth a thousand expert opinions'\n  Return\nML1305:\nsay 'Chicken Little only has to be right once'\n  Return\nML1306:\nML1307:\nsay 'The Law of Devine Intervention:'\nsay '  Alle Kunst is umsunst'\nsay '  Wenn ein Engel auf das'\nsay '  Zundloch brunzt. (Deutsch)'\nsay ' '\nsay ' All skill is in vain when an angel pees in the'\nsay '  in the touchhole of your musket. (English translation)'\n  Return\nML1308:\nsay 'GIGO, garbage in garbage out'\nsay 'GIGO, garbage in Gospel out'\n  Return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "M0282S": {"ttr": 10506, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00D\\x00D\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "MCRITCH"}, "text": "ISREDIT MACRO\n/* CREATED FOR J.MULHEARN FROM X0289.. MEMBER 1991/01/24*/\n        ISREDIT (MEMBERX) = MEMBER\n        ISREDIT (DSNX)    = DATASET\n /*===== MULHEARN PERSONNEL CHANGED FORM 0289 TO 0282 ONLY  ========*/\n /* PURPOSE OF M0282S AND M0282 CLISTS -- MULHEARN CHANGED         */\n /*   CHANGE THE FIRST CARD COST CENTER FROM 0289 TO 0282          */\n /*   CHANGE THE AREA CODE TO 908 ON '(201) 555-' CARDS            */\n /* DIRECTIONS TO USE THE M0282S CLIST AND IT'S COMPANION M0282    */\n /* 1. GET INTO EDIT ON MEMBER ZZ IN THE LIBRARY TO BE CHANGED     */\n /* 2. ON THE COMMAND LINE ENTER   ===> M0282S                     */\n /* 3. CHECK THE SRCHFOR PANEL THAT YOU HAVE                       */\n /*    A. THE CORRECT DSNAME INCLUDING AN (*) FOR MEMBERNAME       */\n /*    B. THAT YOU ARE SEARCHING ON STRINGS                        */\n /*       \"0289,\"   AND \"(201) 555-\"                               */\n /* 4. HIT ENTER TO INVOKE THE SEARCH                              */\n /* 5. HIT PFK-3 TO GET OUT OF BROWSE.                             */\n /* 6. CHANGES WILL COMMENCE, BY INVOKING 2ND CLIST                */\n /*      ISREDIT M0282                                             */\n /* 7. IF THE CLIST STOPS BEFORE COMPLETION ON AN SB37 OR          */\n /*    SOMETHING SIMILAR.  COMPRESS YOUR LIBRARY WITHOUT           */\n /*    LEAVING EDIT.  THEN HIT PFK-3 TO EXIT AND CONTINUE.         */\n /* 8. CHECK NUMBER OF MEMBERS PROCESSED AGAINST NUMBER OF         */\n /*    MEMBERS IN THE ZZ MEMBER.                                   */\n /*================================================================*/\nISREDIT F FIRST '='P\nIF &LASTCC = 0 THEN DO\n   SET &ZEDSMSG = &STR(NOT EMPTY)\n   SET &ZEDLMSG = &STR(&ZEDSMSG. IS A REQUIREMENT, SHOULD BE MEMBER ZZ)\n   ISREDIT LINE_BEFORE .ZF   =  MSGLINE \"&SYSTIME. *ERROR** &ZEDLMSG.\"\n   ISREDIT LINE_BEFORE .ZCSR = NOTELINE \"&SYSTIME. *ERROR** &ZEDLMSG.\"\n   ISPEXEC     SETMSG MSG(ISRZ000)\n   EXIT CODE(1)\nEND\nSET RP = &STR())\nSET LP = &STR())\nSET &ZSSFS1 = &STR('0289,')\nSET &ZSSFS2 = &STR('(201) 555-')\nSET &ZSSFS3 = &STR(   )\nSET &ZSSFNDSN = &STR('&DSNX.(*&RP.'\nSET &ZSSFMULT = &STR(YES)\nISPEXEC VPUT (ZSSFS1,ZSSFS2,ZSSFS3,ZSSFNDSN,ZSSFMULT) SHARED\nISPEXEC SELECT PGM(ISRSFM)\nCOPY SRCHFOR.LIST '&DSNX.(ZZM0282)' NONUM\nISREDIT COPY ZZM0282 AFTER 0\nISREDIT KILL ZZM0282\nISREDIT X 'ZZM0282' ALL\nIF &STR(&SYSUID..ISPF.PROFILE) = &STR(&DSNX.) THEN DO\n   /* CAN NOT DO YOUR OWN PROFILE  */\n   ISREDIT CHANGE  ALL WORD ISRPROF  2 '******* ISPPROF '\n   ISREDIT CHANGE  ALL WORD ISRPROF  2 '******* ISPSPROF '\n   ISREDIT CHANGE  ALL WORD ISRPROF  2 '******* ISRPROF '\nEND\nISREDIT DEL  X ALL\nISREDIT X ALL\nISREDIT F '-----' ALL\nIF &LASTCC. ^= 0 THEN DO\n   SET &ZEDSMSG = &STR(NO STRINGS FOUND)\n   SET &ZEDLMSG = &STR(&ZEDSMSG. -- TERMINATING CLIST)\n   ISREDIT LINE_BEFORE .ZCSR = NOTELINE \"&SYSTIME. *ERROR** &ZEDLMSG.\"\n   ISPEXEC     SETMSG MSG(ISRZ000)\n   EXIT CODE(1)\nEND\nSET I = &SYSINDEX(&STR(ISPF.PROFILE),&STR(&DSNX.            ))\nIF &I = 0 THEN  ISREDIT @DIR STET $NDU IMAC MACRO(M0282) FIND(2)\n          ELSE  ISREDIT @DIR SUPPRESS IMAC MACRO(M0282P) FIND(2)\nSET &ZSSFNDSN = &STR()\nISPEXEC VPUT (ZSSFNDSN) SHARED\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NASPA": {"ttr": 10753, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00~\\x00~\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 126, "newlines": 126, "modlines": 0, "user": "MCRITCH"}, "text": "PROC 1 FILE TO(0) ONLY DOC M() ART\n/* DOCUMENTATION FOR CBT AND NASPA -- IN \"THE REXX MACROS TOOLBOX\" -- SOP #6260*\n/* PROGRAMS, CLISTS, DOCUMENTATION, ETC. FROM PROFESSIONAL PROGRAMMERS*/\n/*\n/* COMPANION CLIST IS  CBT   -- SAME TECHNIQUES USED AS IN NASPA */\n/*  --------- EXAMPLES ------------------. */\n/*   ==> TSO CBT DOC\n/*   ==> TSO CBT 50\n/*   ==> TSO CBT 50 M(%OC*)\n/*   ==> TSO CBT 50 TO(55)\n/*  --------- USEFUL TECHNIQUES ---------. */\n/*   ==> TSO NASPA DOC\n/*   ==> X ALL;FIND SMF WORD ALL\n/*   ==> APPEND DOC    -- IDENTIFY WITH CC-CC RANGE\n/*   ==> TSO NASPA 97  -- OR  TSO NASPA 97 M($DOC)\n/*   ==> APPEND DOC    -- IDENTIFY WITH CC-CC RANGE\n/*   ==> $EDIT USERID.CUTDSN.LIST\n/*   ==> @PRINT DOWN8\n/*\nCONTROL NOFLUSH NOMSG\n/* DOCUMENTATION FOR CBT AND NASPA -- IN \"THE REXX MACROS TOOLBOX\" -- SOP #6260*\n/* PROGRAMS, CLISTS, DOCUMENTATION, ETC. FROM PROFESSIONAL PROGRAMMERS*/\nSET LP = &STR((\nSET RP = &STR())\nIF &STR(&M.) ^= &STR() THEN DO\n  SET M = &STR(&M.)\n  SET M = &STR(&LP.&STR(&M.)&RP.)\n   SET MULTIMEM = &SYSINDEX(&STR(*),&STR(&MEMBER.))\n   IF &MULTIMEM = 0 THEN -\n      SET MULTIMEM = &SYSINDEX(&STR(%),&STR(&MEMBER.))\n  SET ONLY = ONLY\nEND\nELSE SET M = &STR()\nIF DOC = &DOC | DOC = &SYSCAPS(&FILE.) THEN DO\n  ISPEXEC EDIT DATASET('TECH.NASPA.FILE001.DATA')\n  EXIT CODE(0)\nEND\nIF ART = &ART | ART = &SYSCAPS(&FILE.) THEN DO\n  ISPEXEC EDIT DATASET('TECH.NASPA.ARTICLES')\n  EXIT CODE(0)\nEND\nIF &TO. = 0 THEN SET TO = &FILE.\nSET TO = &TO.\nSET FILE = 1000 + &FILE.\nSET MAX = 0\nBACK: -\nSET MAX = &MAX. + 1\nIF &MAX. = 5  THEN DO\n  SET &ZEDSMSG = &STR(NASPA &SUBSTR(2:4,&FILE.)\n  SET &ZEDLMSG = &STR(===> TSO &ZEDSMSG   -- TO CONTINUE WHERE LEFT OFF)\n  ISPEXEC     SETMSG MSG(ISRZ000)\n  EXIT CODE(0)\nEND\nSET FILE = &SUBSTR(2:4,&FILE.)\nIF &EVAL(&FILE.) > 900 THEN EXIT CODE(8)\nIF MULTIMEM = 0 +\n   THEN SET DSN = 'TECH.NASPA.FILE&FILE..PDS&STR(&M.)'\n   ELSE SET DSN = 'TECH.NASPA.FILE&FILE..PDS'\nSET XX = &SYSDSN(&DSN.)\nIF &XX = OK THEN DO\n SET DSN = 'TECH.NASPA.FILE&FILE..PDS&STR(&M.)'\n ISPEXEC EDIT DATASET(&DSN.)\nEND\nELSE DO\n   SET XX = &SYSDSN('TECH.NASPA.FILE&FILE..DATA')\n   IF &XX = OK THEN ISPEXEC EDIT DATASET('TECH.NASPA.FILE&FILE..DATA')\nEND\nIF ONLY = &ONLY THEN EXIT CODE(0)\nIF &EVAL(&TO.) NE 0 THEN -\n  IF &EVAL(&FILE.) GE &EVAL(&TO.) THEN EXIT CODE(0)\nSET FILE = 1001 + &FILE.\nGOTO BACK\n/*   TECH.NASPA.FILE001.DATA\n/*   TECH.NASPA.FILE002.DATA\n/*   TECH.NASPA.FILE003.DATA\n/*   TECH.NASPA.FILE004.PDS\n/*   TECH.NASPA.FILE005.PDS\n/*   TECH.NASPA.FILE006.PDS\n/*   TECH.NASPA.FILE007.PDS\n/*   TECH.NASPA.FILE008.PDS\n/*   TECH.NASPA.FILE009.PDS\n/*   TECH.NASPA.FILE010.PDS\n/*   TECH.NASPA.FILE011.PDS\n/*   TECH.NASPA.FILE012.PDS\n/*   TECH.NASPA.FILE013.PDS\n/*   TECH.NASPA.FILE014.PDS\n/*   TECH.NASPA.FILE015.PDS\n/*   TECH.NASPA.FILE016.PDS\n/*   TECH.NASPA.FILE017.PDS\n/*   TECH.NASPA.FILE018.PDS\n/*   TECH.NASPA.FILE019.PDS\n/*   TECH.NASPA.FILE020.PDS\n/*   TECH.NASPA.FILE021.PDS\n/*   TECH.NASPA.FILE022.PDS\n/*   TECH.NASPA.FILE023.PDS\n/*   TECH.NASPA.FILE024.PDS\n/*   TECH.NASPA.FILE025.PDS\n/*   TECH.NASPA.FILE026.PDS\n/*   TECH.NASPA.FILE027.PDS\n/*   TECH.NASPA.FILE028.PDS\n/*   TECH.NASPA.FILE029.PDS\n/*   TECH.NASPA.FILE030.PDS\n/*   TECH.NASPA.FILE031.PDS\n/*   TECH.NASPA.FILE032.PDS\n/*   TECH.NASPA.FILE033.DATA\n/*   TECH.NASPA.FILE034.PDS\n/*   TECH.NASPA.FILE035.PDS\n/*   TECH.NASPA.FILE036.PDS\n/*   TECH.NASPA.FILE037.PDS\n/*   TECH.NASPA.FILE038.PDS\n/*   TECH.NASPA.FILE039.PDS\n/*   TECH.NASPA.FILE040.PDS\n/*   TECH.NASPA.FILE041.PDS\n/*   TECH.NASPA.FILE042.PDS\n/*   TECH.NASPA.FILE043.PDS\n/*   TECH.NASPA.FILE044.PDS\n/*   TECH.NASPA.FILE045.PDS\n/*   TECH.NASPA.FILE046.PDS\n/*   TECH.NASPA.FILE047.PDS\n/*   TECH.NASPA.FILE048.PDS\n/*   TECH.NASPA.FILE049.PDS\n/*   TECH.NASPA.FILE050.PDS\n/*   TECH.NASPA.FILE051.PDS\n/*   TECH.NASPA.FILE052.PDS\n/*   TECH.NASPA.FILE053.PDS\n/*   TECH.NASPA.FILE054.PDS\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NESTCHK": {"ttr": 10756, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01#\\x01#\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 291, "newlines": 291, "modlines": 0, "user": "MCRITCH"}, "text": "            CONTROL ASIS\n /*  TITLE:       NESTCHK   CHECK NESTING OF \" DO \" AND \" END \" GROUPS\n /*  USERS:       TSO ISPF EDIT USERS   | SCRIPT USERS\n /*  CONTRIBUTED: 1986/04/24 DAVID MCRITCHIE\n /*\n /*  EXAMPLE:     NESTCHK      ...NO OPERANDS REALLY REQUIRED...\n /*\n /*  OPTIONS:\n /*      LPTR-RANGE | ENTIRE   (OPTIONAL) LINE POINTER RANGE\n /*      CLIST | PLI | SAS\n /*\n ISREDIT     MACRO (TOK1,TOK2,TOK3,TOK4,TOK5,TOK6,TOK7,TOK8,TOK9,TOK10,TOK11,TOK\n        TOK14,TOK15,TOK16,TOK17,TOK18,TOK19,TOK20,TOK21,TOK22,TOK23,TOK24,TOK25,\n        TOK27,TOK28,TOK29,TOK30,TOK31,TOK32,TOK33,TOK34,TOK35,TOK36,TOK37,TOK38,\n        TOK40,TOK41,TOK42,TOK43,TOK44,TOK45,TOK46,TOK47,TOK48)\n        ISREDIT (IMAC) = IMACRO\n        SET BLANKS = &STR(\n        SET BLANKS = &STR(&BLANKS.\n        SET E = 0\n        SET P = 0\n        SET I = 1\n        DO WHILE &I <= 48\n           SET TOKEN = &&TOK&I\n           SET TOKEN = &STR(&SYSCAPS(&TOKEN))\n           IF &TOKEN = &STR() THEN GOTO END_TOK\n           IF ALL =&STR(&TOKEN) | NEXT =&STR(&TOKEN) | FIRST =&STR(&TOKEN) -\n              | LAST =&STR(&TOKEN) | PREV =&STR(&TOKEN) -\n              | X    =&STR(&TOKEN) | NX =&STR(&TOKEN) THEN -\n           DO\n             SET &ZEDSMSG = &STR(&TOKEN INVALID)\n             SET &ZEDLMSG = &STR(\"&TOKEN\" NOT PROVIDED FOR NOR ARE NEXT ALL FIRS\n             ISPEXEC   SETMSG MSG(ISRZ000)\n             EXIT CODE(12)\n           END\n           IF DETAIL = &TOKEN THEN DO\n              SET DETAIL = &TOKEN\n              GOTO NXT_TOK\n           END\n           IF CLIST = &TOKEN THEN DO\n              SET CLIST = &TOKEN\n              GOTO NXT_TOK\n           END\n           IF PLI   = &TOKEN THEN DO   /* END */\n              SET PLI   = &TOKEN\n              GOTO NXT_TOK\n           END                          /* DO */\n           IF SAS   = &TOKEN THEN DO\n              SET SAS   = &TOKEN\n              GOTO NXT_TOK\n           END\n           IF &SUBSTR(1:4,&STR(&TOKEN)       ) = &STR(COL&STR(&LP))  THEN DO\n              IF &STR(&COL1) = &STR() THEN DO\n                 SET COL1 = &SUBSTR(5:&EVAL(&LENGTH(&STR(&TOKEN))-1),&STR(&TOKEN\n                 WRITE &COL1\n                 GOTO NXT_TOK\n              END\n              ELSE DO\n                 IF &STR(&COL2) = &STR() THEN DO\n                    SET COL2 = &SUBSTR(5:&EVAL(&LENGTH(&STR(&TOKEN))-1),&STR(&TO\n                    WRITE &COL2\n                    GOTO NXT_TOK\n                 END\n                 SET &ZEDSMSG = &STR(&TOKEN  3RD USE)\n                 SET &ZEDLMSG = COL(&COL1.) COL(&COL2.) ALREADY SPECIFIED FOR LE\n                 ISPEXEC SETMSG MSG(ISRZ000)\n              END\n              EXIT CODE(12)\n           END\n           IF &TOKEN = ENTIRE THEN DO    /* ENTIRE  |  LPTR-RANGE  */\n              SET ENTIRE = ENTIRE\n              GOTO NXT_TOK\n           END\n           IF &TOKEN = &STR()) THEN DO\n              SET &ZEDSMSG = &STR(LOST PARENTHESIS)\n              SET &ZEDLMSG = BLANKS SEPARATE ALL OPERANDS; THEREFORE INVALID IN\n              ISPEXEC SETMSG MSG(ISRZ000)\n              EXIT CODE(12)\n           END\n           SET REMAIN = &STR(&REMAIN &TOKEN)\n   NXT_TOK: -\n           SET I = &I + 1\n        END\n   END_TOK: SET JJ = &I\n        /*****************************************************************\n        /*****************************************************************\n        IF &STR(&LABF) = &STR() THEN SET ENTIRE = ENTIRE\n        IF ENTIRE = &ENTIRE THEN DO      /************* LABELS ARE REQUIRED ****\n           IF &LABF = &STR() THEN DO\n              SET LABF = .ZFIRST\n              SET LABL = .ZLAST\n           END\n           ELSE DO\n              SET &ZEDSMSG = &STR(LABEL CONFLICT)\n              SET &ZEDLMSG = &STR(\"ENTIRE\" IMPLIES .ZFIRST .ZLAST CONFLICTS WITH\n              ISPEXEC     SETMSG MSG(ISRZ000)\n              EXIT CODE(12)\n           END\n        END\n        ISREDIT (#LABF) = LINENUM &LABF\n        IF &LASTCC ^= 0 THEN DO\n                   SET &ZEDSMSG = &STR(&LABF. LABEL)\n                   SET &ZEDLMSG = &STR(&ZEDSMSG DOES NOT EXIST)\n                   ISPEXEC     SETMSG MSG(ISRZ000)\n                   EXIT CODE(12)\n        END\n        ISREDIT (#LABL) = LINENUM &LABL\n        IF &LASTCC ^= 0 THEN DO\n                   SET &ZEDSMSG = &STR(&LABL. LABEL)\n                   SET &ZEDLMSG = &STR(&ZEDSMSG DOES NOT EXIST)\n                   ISPEXEC     SETMSG MSG(ISRZ000)\n                   EXIT CODE(12)\n        END\n        /********************************** END OF LABEL REQUIREMENTS **********\n        ISREDIT RESET\n        ISREDIT (DWIDTH) = DATA_WIDTH\n        SET LLADJ = 0\n        ISREDIT (VAR049) = NUMBER\n        ISREDIT (VAR047) = RECFM\n        IF &VAR047 = V AND &VAR049 = ON THEN DO\n           SET LLADJ = 8\n        END\n        ISREDIT RES .ZFIRST .ZLAST\n /*     ISREDIT LINE_BEFORE .ZFIRST = NOTELINE \"&VAR049 &VAR047 &LLADJ\"\n        /************************************** END OF MODIFIED PATTERN CODE  **\n        /************************************** END OF MODIFIED PATTERN CODE  **\n        ISREDIT FIND .ZFIRST .ZLAST FIRST X'75'\n        SET CC = &LASTCC\n        IF &CC ^= 0 THEN DO\n           ISREDIT FIND .ZFIRST .ZLAST FIRST X'76'\n           SET CC = &LASTCC\n        END\n        IF &CC = 0 THEN DO\n                   SET &ZEDSMSG = &STR(X'75' | X'76')\n                   SET &ZEDLMSG = &STR(&ZEDSMSG. ENCOUNTERED IN YOUR ORIGINAL DA\n                   ISPEXEC     SETMSG MSG(ISRZ000)\n                   ISREDIT     LINE_AFTER &LABL. = NOTELINE \"*ERROR** &ZEDLMSG.\"\n                   ISPEXEC     SETMSG MSG(ISRZ000)\n                   IF &STR(&IMAC) = NONE THEN ISREDIT DOWN MAX\n                   EXIT CODE(12)\n        END\n        /***********************************************************************\n        ISREDIT FIND ';DO;' FIRST\n        SET CC = &LASTCC\n        IF &CC ^= 0 THEN DO\n           ISREDIT FIND ';END;' FIRST\n           SET CC = &LASTCC\n        END\n        IF &CC = 0 THEN DO\n          ISREDIT LINE_BEFORE .ZFIRST = NOTELINE \"&SYSTIME. CANNOT HANDLE ';DO;'\n          ISREDIT LINE_AFTER  .ZLAST  = NOTELINE \"&SYSTIME. FOR BETTER CHECKING\n          ISREDIT LINE_AFTER  .ZLAST  = NOTELINE \"&SYSTIME. CANNOT HANDLE ';DO;'\n        END\n        /***********************************************************************\n        ISREDIT FIND 1 'DO' FIRST\n        SET CC = &LASTCC\n        IF &CC ^= 0 THEN DO\n           ISREDIT FIND 1 'END' FIRST\n           SET CC = &LASTCC\n        END\n        IF &CC = 0 THEN DO\n          ISREDIT LINE_BEFORE .ZFIRST = NOTELINE \"&SYSTIME. CANNOT HANDLE ' DO '\n          ISREDIT LINE_AFTER  .ZLAST  = NOTELINE \"&SYSTIME. FOR BETTER CHECKING\n          ISREDIT LINE_AFTER  .ZLAST  = NOTELINE \"&SYSTIME. CANNOT HANDLE ';DO;'\n        END\n        /***********************************************************************\n        ISREDIT LINE_BEFORE &LABF. = NOTELINE \"&SYSDATE. &SYSTIME. X'75' AND X'7\n        SET PLID1 = ' DO '\n        SET PLIX1 = '\u00c2DO '               /* CONTAINS HEX X'75' */\n        SET PLID2 = ' DO;'\n        SET PLIX2 = '\u00c2DO;'               /* CONTAINS HEX X'75' */\n        SET PLID3 = ' BEGIN;'\n        SET PLIX3 = '\u00c2BEGIN;'            /* CONTAINS HEX X'75' */\n        SET PLID4 = ' PROC '\n        SET PLIX4 = '\u00c2PROC '             /* CONTAINS HEX X'75' */\n        SET PLID5 = ' PROC('\n        SET PLIX5 = '\u00c2PROC('             /* CONTAINS HEX X'75' */\n        SET PLID6 = ' END;'\n        SET PLIX6 = '\u00beEND;'              /* CONTAINS HEX X'76' */\n        SET PLID7 = ' END '\n        SET PLIX7 = '\u00beEND '              /* CONTAINS HEX X'76' */\n        /***********************************************************************\n        /***********************************************************************\n        ISREDIT C ALL &LABF. &LABL. &PLID1. &PLIX1.\n        IF &STR(&PLI) ^= PLI AND &STR(&SAS) ^= SAS THEN GOTO EDCLIST\n        ISREDIT C ALL &LABF. &LABL. &PLID2. &PLIX2.\n        IF &STR(&PLI) = SAS  THEN GOTO EDCLIST\n        ISREDIT C ALL &LABF. &LABL. &PLID3. &PLIX3.\n        ISREDIT C ALL &LABF. &LABL. &PLID4. &PLIX4.\n        ISREDIT C ALL &LABF. &LABL. &PLID5. &PLIX5.\n        ISREDIT C ALL &LABF. &LABL. &PLID6. &PLIX6.\n     EDCLIST: -\n        ISREDIT C ALL &LABF. &LABL. &PLID7. &PLIX7.\n        ISREDIT (#LABF) = LINENUM &LABF\n        ISREDIT (#LABL) = LINENUM &LABL\n        /***********************************************************************\n        SET I = 1\n        IF &STR(&COL1) = &STR() THEN SET COL1 = 1\n        ELSE SET COL1 = &COL1 - &LLADJ.\n        IF &STR(&COL2) = &STR() THEN DO\n           SET COL2 = &DWIDTH\n           IF &COL2 > 80 THEN SET COL2 = 80\n        END\n        ELSE SET COL2 = &COL2 - &LLADJ.\n        ISREDIT EXCLUDE .ZFIRST .ZLAST ALL\n /*     WRITE &COL1 &COL2 LBOUND=&LBOUND + &LLADJ = &LLBOUND   RBOUND=&RBOUND  D\n        DO WHILE &I < &COL2\n           ISREDIT F P'^' &COL1 &I FIRST\n           IF &LASTCC ^= 0 THEN DO\n              IF DETAIL = &DETAIL THEN ISREDIT LINE_BEFORE .ZFIRST = NOTELINE \"C\n              GOTO NXT_III\n           END\n           ISREDIT EXCLUDE &LABF. &LABL. ALL\n           ISREDIT FIND &LABF. &LABL. P'^' &I ALL\n           IF &I > &COL1. THEN  ISREDIT EXCLUDE &LABF. &LABL. ALL &COL1 &EVAL(&I\n  /*       ISREDIT EXCLUDE &LABF. &LABL. ALL &I ' '\n           ISREDIT EXCLUDE &LABF. &LABL. ALL X'75'        /* EXCLUDE DO */\n           ISREDIT EXCLUDE &LABF. &LABL. ALL X'76'        /*EXCLUDE END */\n           ISREDIT FIND    &LABF. &LABL. ALL &I '/*'\n           ISREDIT FIND    &LABF. &LABL. ALL &I \"'\"\n           ISREDIT FIND    &LABF. &LABL. ALL &I \"WRITE \"\n           ISREDIT C ALL NX X'75' ' '\n           ISREDIT C ALL NX X'76' ' '\n           ISREDIT F ALL X'75'\n           ISREDIT F ALL X'76'\n           ISREDIT EXCLUDE &LABF. &LABL. ALL &I ' '\n           ISREDIT FIND &LABF. &LABL. P'^' &I ALL\n           IF &I > &COL1. THEN DO\n              ISREDIT EXCLUDE &LABF. &LABL. ALL 1 &EVAL(&I-1) P'^'\n              ISREDIT FIND  &LABF. &LABL. X'75' &EVAL(&I.-1) ALL\n              ISREDIT FIND  &LABF. &LABL. X'76' &EVAL(&I.-1) ALL\n              IF &I > &EVAL(&COL1.+1) THEN  ISREDIT EXCLUDE &LABF. &LABL. ALL &C\n           END\n           ISREDIT SEEK NX ALL X'75'\n           ISREDIT (VAR023D,VAR024D) = SEEK_COUNTS\n           ISREDIT SEEK NX ALL X'76'\n           ISREDIT (VAR023E,VAR024E) = SEEK_COUNTS\n           IF DETAIL = &DETAIL THEN ISREDIT LINE_BEFORE .ZFIRST = NOTELINE \"COLU\n           IF &EVAL(&VAR023D) ^= &EVAL(&VAR023E) THEN DO\n              IF &STR(&NOTE1) = &STR() THEN DO\n                 SET NOTE1 = NOTE1\n                 ISREDIT LINE_BEFORE .ZFIRST = NOTELINE \"COLUMN XX BEING CHECKED\n                 ISREDIT LINE_BEFORE .ZFIRST = NOTELINE \"COLUMN XX BEING CHECKED\n              END\n              SET P = &E\n              SET E = &I\n              IF &VAR023D > &VAR023E THEN DO\n                 SET T = DO\n                 WRITE &I COLUMN (&EVAL(&I + &LLADJ)) UNMATCHED DO\n        ISREDIT LINE_BEFORE .ZFIRST = NOTELINE \"COLUMN &EVAL(&I + &LLADJ) UNMATC\n              END\n              IF &VAR023D < &VAR023E THEN DO\n                 SET T = END\n                 WRITE &I COLUMN (&EVAL(&I + &LLADJ)) UNMATCHED END\n        ISREDIT LINE_BEFORE .ZFIRST = NOTELINE \"COLUMN &EVAL(&I + &LLADJ) UNMATC\n              END\n              SET BAD = &STR(&BAD.  &EVAL(&I.+&LLADJ.) &T.|&EVAL(&VAR023D.)|&EVA\n           END\n           ELSE DO\n              ISREDIT CHANGE ALL NX X'75' X'40'\n              ISREDIT CHANGE ALL NX X'76' X'40'\n           END\n   NXT_III: -\n           SET I = &I + 1\n        END\n  DONE: -\n        ISREDIT EXCLUDE ALL .ZFIRST .ZLAST    /* DONT TOUCH NOTES THANK-YOU*/\n        ISREDIT CHANGE X'75' X'40' ALL\n        ISREDIT CHANGE X'76' X'40' ALL\n        ISREDIT RESET CHANGE\n        ISREDIT LINE_BEFORE &LABF. = NOTELINE \"&SYSDATE. &SYSTIME. X'75' AND X'7\n        /*************************************************************/\n        IF &STR(&BAD.) = &STR() THEN DO\n           SET &ZEDSMSG = &STR(COMPLETED)\n           SET &ZEDLMSG = &STR(--SUCCESS-- NESTCHK HAS NOT FOUND ANY UNMATCHED D\n           ISREDIT LINE_AFTER  &LABL. = NOTELINE \"&SYSDATE. &SYSTIME. &ZEDLMSG\"\n        END\n        ELSE DO\n           IF &LENGTH(&STR(&BAD)) > 40 THEN SET BAD = &SUBSTR(1:40,&STR(&BAD.&BL\n           SET &ZEDSMSG = &STR(MISALIGNED)\n           SET &ZEDLMSG = &STR(&ZEDSMSG. \" DO \" AND \" END \"  COLS &BAD.)\n           ISREDIT LINE_AFTER &LABL. = NOTELINE \"&B. &BAD.\"\n           IF &STR(&LLADJ) ^= 0 THEN -\n           ISREDIT LINE_AFTER &LABL. = NOTELINE \"&B  HAVE ADDED +&LLADJ. TO COLU\n           ISREDIT LINE_AFTER &LABL. = NOTELINE \"&SYSDATE. &SYSTIME. -- CHECK AL\n           SET COLHD = &STR(1...5...10...15...20...25...30...35...40...45...50..\n           ISREDIT LINE_AFTER &LABL. = NOTELINE \"&SUBSTR(&EVAL(1+&LLADJ):72,&STR\n           ISREDIT LINE_BEFORE &LABF. = NOTELINE \"&SUBSTR(&EVAL(1+&LLADJ):72,&ST\n           IF &STR(&IMAC) = NONE THEN ISREDIT DOWN MAX\n        END\n        ISPEXEC     SETMSG MSG(ISRZ000)\n        EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NETWORK": {"ttr": 10762, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00N\\x00N\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 78, "newlines": 78, "modlines": 0, "user": "MCRITCH"}, "text": " /* rexx ---- NETWORK Phone Directory -- find lastname*/\n /* EDIT G(0) FAX NET NET04 B ALL NET02A OLD$USERS WHOGOT PROFS*/\n /*         BW PHONE */\n arg  token\nwhogot='';profs='';g='';cmdvar='Find ''  |''';\n\nparse var token left \" G(\" G \") \" right\ntoken = left || ' ' || right\ntoken = \" \"TOKEN\" \"\nedit = process('EDIT');\ntoken = substr(token,2);\n\naddress ISPEXEC 'VGET (ZDEL) PROFILE'\nif token /= \"\" then do\n      i=verify(token,'0123456789')\n      if i = 1 then cmdvar = cmdvar||zdel||\"FIND 14\" token\n      else CMDVAR = cmdvar||zdel||\"FIND \"token\n      cmdvar = cmdvar||zdel||\"DOWN 1\"\nend\ncmdvar=cmdvar||zdel||\"cols\"||zdel||\"CURSOR\"\naddress \"TSO\"\n  /* provided by David McRitchie 1985/04/08, \"The REXX Macros Toolbox\" */\n  /* (default) -- PHO.GENERAL.GENERAL.ZZ2B0701(0)                    */\n  /*  PURPOSE: quick access to list of formatted phone directory     */\n  /*  -------------- other opitions ---------------------------------*/\n  /* EDIT   -- to use edit instead of browse                         */\n  /* WHOGOT -- invoke WHOGOT before edit/browse, N/A with G(*), FAX  */\n  /*  -------------------------------------------------------------- */\n /* formerly used tech.info.text(users) */\n   GDSN = \"IS03.public.list.JCLPCALL\"\n   GDSN = \"pho.internal.library.iv2e5602\"\n   VSTSRVTI =  GDSN\n  OK = sysdsn(\"'\"gdsn\"'\")\n  if ok \\= \"OK\" then do\n    say gdsn \"---\" OK\n    say gdsn 'does not exist must be recreated via'\n    say ' jcl in i142.phone.text(jclpcall)'\n    say ' contact David McRitchie,            '\n    EXIT 0\nEND\nif edit = \"EDIT\" then do\n   Address \"TSO\" \"$EDIT '\"gdsn\"'\"\n   exit 0\nend\n/*Address \"ISPEXEC\" ,\n\"VPUT (VSTSRVTI,SYSBROX2,SYSBROX3) SHARED\" */\nAddress \"ISPEXEC\" \"CONTROL NONDISPL ENTER\"\n SYSBROX2='Network                                                ',\n          ||'        Bldg/      Loca-'\n SYSBROX3=' Number     Name (col 14-56 with DISPLAY NOCC)         ',\n          ||' Unit   Room       tion'\naddress ISPEXEC 'VGET (ZCHARCNL) PROFILE'\nCHARCNL = zcharcnl\nif zcharcnl = \"CC\" then do\n   zcharcnl = \"NOCC\"\n   address ISPEXEC 'VPUT (ZCHARCNL) PROFILE'\nend\nAddress \"ISPEXEC\" ,\n\"BROWSE DATASET('\"GDSN\"') PANEL(SYSBRNET)\"\nif charcnl \\= zcharcnl then do\n   zcharcnl = charcnl\n   address ISPEXEC 'Vput (ZCHARCNL) PROFILE'\nend\n /* ---------- */\n return\n /* ---------- */\nProcess: procedure expose token\n arg subtoken\n i = index(token,' '||subtoken||' ')\n if i=0 then return ''\n tokenx = substr(token,1,I) || substr(token,I+2+length(subtoken))\n token = tokenx\n return subtoken\nProcessB: procedure expose token\n arg subtoken\n x = process(subtoken)\n if x /='' then x = ' '||x\n return x\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NOTENX": {"ttr": 10765, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x0b\\x00\\x0b\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- LIST  NX LINES AS NOTE/INFO LINES BEFORE EACH LINE*/\n/* AUTHOR: DAVID MCRITCHIE, \"THE REXX MACROS TOOLBOX\", 1992/02/05 */\nADDRESS \"ISREDIT\";\"MACRO\"\n\"FIND P'=' 1 NX FIRST\"\nDO FOREVER\n   \"(LINE) = LINE .ZCSR\"\n   \"LINE_BEFORE .ZCSR = INFOLINE (LINE)\"\n   \"FIND P'=' 1 NX\"\n   IF RC \\= 0 THEN LEAVE\n END\nRETURN 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NXNX": {"ttr": 10767, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xcc\\x00\\xcc\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 204, "newlines": 204, "modlines": 0, "user": "MCRITCH"}, "text": "/**rexx**************************************************************\n   NXNX     Author: David McRitchie, created 1987/04/17 IS03\n            at \"The REXX Macros Toolbox\"\n            updated 1990/11/13 09:38 IS03\n            updated 1992/03/09 16:30 IS03 line 97 continuation split\n            REXX    1993/05/20 16:05 IS03 converted to REXX\n  *******************************************************************\n   Title:       NXNX, make line before/after NX line also visible\n   Users:       TSO ISPF edit users   or  Script users\n\n   Contributed: 1987/04/17 David McRitchie\n   Author: David McRitchie, \"The REXX Macros Toolbox\" 1987/04/17\n   This clist is universally available with the stipulation that\n    that the original author remains credited\n    and that no charge or licensing fee accrues to any party.\n\n     EXAMPLE:     NXNX  .FIRST .ZLAST AFTER(1)     --DEFAULTS\n                  NXNX  .A .B BEFORE(N)\n                  NXNX  .A .B AFTER(N)\n                  NXNX  .A .B BEFORE(N) AFTER(X)\n                  NXNX  .A .B LABEL               || The only defaults\n                  NXNX  .A .B CHG                 || Are  .ZF .ZL\n                  NXNX  .A .B ERR                 ||\n                  NXNX  .A .B SPECIAL             || AFTER(1)   will\n                  NXNX  .A .B XLABEL              || Default only if\n                                                  || No  other parms\n                  NXNX  .A .B FLIP    -- same as FLIP primary command\n                                         which is available in TSO\n\n     Documented:  IS03.SHARE.TEXT(NXNX)\n\n     OPTIONS:\n         LABEL RANGE\n         AFTER(NN),   Display nn lines after,\n                      AFTER may be used in place of AFTER(1)\n         BEFORE(NN),  Display nn lines before,\n                      BEFORE may be used in place of BEFORE(1)\n         LABEL,       Make LABEL lines visible (any level)\n         CHG,         Make CHG lines visible\n         ERR,         Make ERR lines visible\n         SPECIAL,     Make special lines visible\n         STR(xxx),    Make visible only if line contains the string xxx\n         XLABEL,      Make label lines not visible (any level)\n         FLIP,        X lines become NX and vice versa (FLIP in TSO)\n     USAGE:\n         X ALL \\ F '.PA ' ALL \\ NXNX BEFORE(3) AFTER(3)\n  ================================================================  **/\n/*********************************************************************/\n\n address 'ISREDIT'; 'MACRO (PARMS) NOPROCESS';\n note = 'LINE_BEFORE .zfirst = NOTELINE '\n xstrx='';\n after=0; Before=0; Change='';chg=''; Err=''; Error=''; Lab='';\n label=''; Labf=''; Labl=''; Remainder=''; Special='';\n xlabel=''; Zedlmsg='' Zedsmsg=''; Spe=''; Flip='';\n\n\n /* Collect Parameters */\n if parms = '' Then do;   /* *No parameters -- Default to a test* */\n    zedsmsg = ''\n    zedlmsg = \"NXNX missing operands such as\",\n       \"AFTER(N) BEFORE(N) CHG CHANGE ERR ERROR LAB LABEL \",\n             \"SPE SPECIAL XLABEL\"\n    Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    exit 8\n end\n parms = translate(parms)\n parse var parms left 'STR(' xstrx ')' right\n parms = left right\n do iii = 1 to 10;\n   token = word(parms,iii)\n   if token = '' Then leave\n   tokenx = translate(token);\n   j = pos(tokenx,' AFTER BEFORE CHG CHANGE ERR ERROR LAB LABEL ',\n                  ||'SPE SPECIAL XLABEL FLIP ')\n   if j <> 0 then do;\n      string = token ' = '''token''''\n      interpret  string\n      iterate iii\n   end;\n   if substr(token,1,6) = 'AFTER(' then do;\n      parse var token  'AFTER(' after ')' Right; iterate iii;\n   end\n   if 'BEFORE(' = Substr(token,1,7)  then do;\n      parse var token  'BEFORE(' before ')' Right; iterate iii;\n   end\n   if substr(token,1,1) = '.' Then do\n      if labf = '' Then labf = token\n      else if labl = '' Then labl = token\n      else do\n            zedsmsg = '.LABEL RC=8'\n            zedlmsg = 'too many labels --' Labf labl token\n            Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            exit 8\n      end\n      iterate iii\n   end\n\n   remainder = remainder token\n end iii\n\n if remainder <> \"\" Then do\n    zedsmsg =  Remainder\n    zedlmsg =  remainder \"-- Parameters unknown to NXNX\"\n    Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    Exit 8\n end\n\nif labl = '' Then do\n   \"PROCESS RANGE C\"\n   if RC = 0 THEN DO\n      \"LABEL .zfrange = .labf 1\"\n      \"LABEL .zlrange = .labl 1\"\n      labf = \".labf\"\n      LABL = \".labl\"\n   end\nend\nif labl = '' Then do; labf='.ZFIRST'; labl='.ZLAST'; end;\nif after = \"AFTER\" then after=1\nif before = \"BEFORE\" then before=1\nif xstrx \\= '' then if after=0  then if before=0  then after=1\nif xlabel = \"XLABEL\" then\n   do;\"x 1 p'=' all\" Labf labl;label=\"LABEL\"; end\n\"(LABFNO) = LINENUM\" LABF\n\"(LABLNO) = LINENUM\" LABL\n\nif chg <> '' | Change <> ''  then change = 'CHANGE'\nif err <> '' | Error <> ''   then error = 'ERROR'\nif spe <> '' | Special <> '' Then special = 'SPECIAL'\nif lab <> '' | Label   <> '' Then label = 'LABEL'\n\nif label=\"LABEL\" then\n do i = labfno to lablno\n        \"(var1,var2) = LABEL \" i;if rc = 0 then \"XSTATUS\" i \"= NX\"\n end\n\n\nif change=\"CHANGE\" then do\n    \"loc 0\"; \"cursor = \" Labfno 0;rc=0\n    do while rc=0;  /* Continues on for all occurences to .ZLAST*/\n       \"locate next change\";\n    end\nend\n\nif error=\"ERROR\"  then do\n    \"loc 0\"; \"cursor = \" Labfno 0;rc=0\n    do while rc=0;  /* Continues on for all occurences to .ZLAST*/\n       \"locate next error\";\n    end\nend\n\n if special = \"SPECIAL\" then do\n   \"CURSOR = \" Labfno 0\n   \"CURSOR = \" Value(labfno -1) 0\n   do while rc = 0;\"LOCATE NEXT SPECIAL\";end\n end\n\nif labfno = 0 then do; say 'set to 1'; labfno=1; end;\nif before <> '' Then\ndo i = labfno to lablno\n   \"(VAR075) = XSTATUS\" i\n   if VAR075 = \"NX\" then do\n      if labfno = 0 then iterate\n      lower = i - before; if lower < labfno then lower=labfno\n      upper = i - 1; if upper < labfno then upper = labfno\n      do k = lower to upper;\n         \"CURSOR =\" i 0\n         if xstrx =\"\" then \"XSTATUS\" k \"= NX\";\n         else do; /* special code if xstrx(xxx) in use */\n            address \"ISREDIT\" \"LABEL\" k \"= .KPTR 0\"\n            \"CURSOR =\" k 0\n            address \"ISREDIT\" \"Find .KPTR .KPTR\" xstrx\n         end;\n      end\n   end\nend\nif flip   <> '' Then\ndo i = labfno to lablno\n   \"(VAR075) = XSTATUS\" i\n   if VAR075 = \"NX\" then \"XSTATUS\" i \"= X\"\n   else \"XSTATUS\" i \"= NX\"\nend\n\nif after  <> '' Then\ndo i = lablno to labfno by -1\n   \"(VAR075) = XSTATUS\" i\n   if VAR075 = \"NX\" then do\n      upper = i + after; if upper > lablno then upper = lablno\n      lower = i + 1;if upper > lablno then upper = lablno\n      do k = lower to upper;\n         if xstrx =\"\" then \"XSTATUS\" k \"= NX\";\n         else do; /* special code if xstrx(xxx) in use */\n            address \"ISREDIT\" \"LABEL\" k \"= .KPTR 0\"\n            \"CURSOR =\" k 0\n            address \"ISREDIT\" \"Find .KPTR .KPTR\" xstrx\n         end;\n      end\n   end\nend\nif flip = \"\" then\n  \"(linex,colx) = Cursor\";\nzedsmsg = 'Completed'\nzedlmsg = \"NXNX\" parms \"-- Completed\"\n Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "O": {"ttr": 11012, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\n\\x00\\n\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "MCRITCH"}, "text": "PROC 0\nCONTROL ASIS\nATTN DO\n   EXIT CODE(0)\n   END\nWRITE Logging off...   Press ATTN or PA1 to stay in READY mode.\nTIME\nWAIT FOR 5 SECONDS\nIF &LASTCC = 0 THEN LOGOFF\nEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "P": {"ttr": 11014, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x86\\x00\\x86\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 134, "newlines": 134, "modlines": 0, "user": "MCRITCH"}, "text": "00010000 PROC 0 ARG() DEBUG X0(0) X1(1) X2(2) X3(3) X4(4) X5(5) X6(6) X7(7) X8(8\n00020000 IF &DEBUG = DEBUG THEN CONTROL LIST CONLIST SYMLIST\n00030000 IF &STR(&ARG) ^= THEN DO\n00040000    WRITE &EVAL(&ARG)\n00050000    EXIT CODE(0)\n00060000    END\n00070000 ERROR GOTO NASTY\n00080000 LOOP: -\n00081000    IF &HEX = THEN SET MODE = DECIMAL\n00082000    ELSE SET MODE = HEX\n00090000    WRITENR &MODE ARG:\n00100000    READ\n00110000    IF &STR(&SYSDVAL) = ? THEN DO\n00120000       WRITE ENTER AN AN ALGEBRAIC EXPRESSION, USING DECIMAL INTEGERS AN\n00130000       WRITE START YOUR EXPRESSION WITH +, -, * OR / TO ACCUMULATE RESUL\n00140000       WRITE ENTER THE WORD 'HEX' TO ENTER 'HEX' MODE\n00150000       WRITE ENTER THE WORD 'DECIMAL' TO ENTER 'DECIMAL' MODE\n00160000       WRITE JUST HIT THE 'ENTER' KEY TO END THE PROGRAM\n00170000       WRITE WARNING: IN 'HEX' MODE, YOU MUST ACCUMULATE ONE OPERATION A\n00180000       GOTO LOOP\n00190000       END\n00200000    SET OP =\n00210000    IF &LENGTH(&STR(&SYSDVAL)) = 0 THEN EXIT CODE(0)\n00220000    IF &STR(&SYSDVAL) = HEX THEN DO\n00230000       SET HEX = HEX\n00240000       GOTO LOOP\n00250000       END\n00260000    IF &STR(&SYSDVAL) = DECIMAL THEN DO\n00270000       SET HEX =\n00280000       GOTO LOOP\n00290000       END\n00300000    IF &LENGTH(&STR(&SYSDVAL)) > 1 THEN DO\n00310000       SET OP = &SUBSTR(1,&SYSDVAL)\n00320000       SET SYSDVAL = &SUBSTR(2:&LENGTH(&STR(&SYSDVAL)),&SYSDVAL)\n00330000       END\n00331000    IF &HEX = THEN DO\n00340000       IF &STR(&OP) = &STR(+) OR &STR(&OP) = &STR(-) THEN SET ARG = &STR\n00350000       ELSE IF &STR(&OP) = &STR(*) OR &STR(&OP) = &STR(/) THEN SET ARG =\n00360000       ELSE DO\n00370000          SET SYSDVAL = &STR(&OP.&SYSDVAL)\n00380000          SET ARG = &STR(&SYSDVAL)\n00390000          SET VAL =\n00400000          SET OP =\n00410000          END\n00411000       END\n00412000    ELSE DO\n00413000       IF &STR(&OP) = &STR(+) OR &STR(&OP) = &STR(-) THEN SET ARG = &STR\n00414000       ELSE IF &STR(&OP) = &STR(*) OR &STR(&OP) = &STR(/) THEN SET ARG =\n00415000       ELSE DO\n00416000          SET SYSDVAL = &STR(&OP.&SYSDVAL)\n00417000          SET ARG = &STR(X'&SYSDVAL')\n00418000          SET VAL =\n00419000          SET OP =\n00419100          END\n00419200       END\n00420000    IF &HEX = HEX THEN DO\n00430000       IF &LENGTH(&STR(&SYSDVAL)) < 8 THEN SET SYSDVAL = &SUBSTR(&LENGTH\n00440000       SET X = &SUBSTR(1,&SYSDVAL)\n00450000       IF &X > 7 OR &X < 0 THEN DO\n00460000          SET A = &EVAL(-2147483647)\n00470000          SET B = &STR(&&X)&SUBSTR(1,&SYSDVAL)\n00480000          SET B = &B - 8\n00490000          SET A = &A + &B * 268435456\n00491000          SET C = -1\n00500000          END\n00510000       ELSE DO\n00530000          SET B = &STR(&&X)&SUBSTR(1,&SYSDVAL)\n00540000          SET A = &B * 268435456\n00541000          SET C = 0\n00550000          END\n00560000       SET B = &STR(&&X)&SUBSTR(2,&SYSDVAL)\n00570000       SET A = &A + &B * 16777216\n00580000       SET B = &STR(&&X)&SUBSTR(3,&SYSDVAL)\n00590000       SET A = &A + &B * 1048576\n00600000       SET B = &STR(&&X)&SUBSTR(4,&SYSDVAL)\n00610000       SET A = &A + &B * 65536\n00620000       SET B = &STR(&&X)&SUBSTR(5,&SYSDVAL)\n00630000       SET A = &A + &B * 4096\n00640000       SET B = &STR(&&X)&SUBSTR(6,&SYSDVAL)\n00650000       SET A = &A + &B * 256\n00660000       SET B = &STR(&&X)&SUBSTR(7,&SYSDVAL)\n00670000       SET A = &A + &B * 16\n00680000       SET B = &STR(&&X)&SUBSTR(8,&SYSDVAL)\n00690000       SET A = &A + &B + &C\n00700000       SET SYSDVAL = &A\n00710000       END\n00720000    SET VAL = &EVAL(&VAL &OP &SYSDVAL)\n00770000    SET A = &VAL\n00780000    IF &A < 0 THEN DO\n00790000       SET A = &A + 2147483647\n00800000       SET A = &A + 1\n00810000       SET B = &A\n00820000       SET A = &A / 268435456\n00830000       SET B = &B - &A * 268435456\n00840000       SET HSTR = &SUBSTR(&A+1,89ABCDEF)\n00850000       END\n00860000    ELSE DO\n00870000       SET B = &A\n00880000       SET A = &A / 268435456\n00890000       SET B = &B - &A * 268435456\n00900000       SET HSTR = &SUBSTR(&A+1,01234567)\n00910000       END\n00920000    SET A = &B\n00930000    SET B = &B / 16777216\n00940000    SET A = &A - &B * 16777216\n00950000    SET HSTR = &HSTR.&SUBSTR(&B+1,0123456789ABCDEF)\n00960000    SET B = &A\n00970000    SET A = &A / 1048576\n00980000    SET B = &B - &A * 1048576\n00990000    SET HSTR = &HSTR.&SUBSTR(&A+1,0123456789ABCDEF)\n01000000    SET A = &B\n01010000    SET B = &B / 65536\n01020000    SET A = &A - &B * 65536\n01030000    SET HSTR = &HSTR.&SUBSTR(&B+1,0123456789ABCDEF)\n01040000    SET B = &A\n01050000    SET A = &A / 4096\n01060000    SET B = &B - &A * 4096\n01070000    SET HSTR = &HSTR.&SUBSTR(&A+1,0123456789ABCDEF)\n01080000    SET A = &B\n01090000    SET B = &B / 256\n01100000    SET A = &A - &B * 256\n01110000    SET HSTR = &HSTR.&SUBSTR(&B+1,0123456789ABCDEF)\n01120000    SET B = &A\n01130000    SET A = &A / 16\n01140000    SET B = &B - &A * 16\n01150000    SET HSTR = &HSTR.&SUBSTR(&A+1,0123456789ABCDEF)\n01160000    SET HSTR = &HSTR.&SUBSTR(&B+1,0123456789ABCDEF)\n01170000    WRITE &STR(&ARG) = &VAL = X'&HSTR'\n01180000    GOTO LOOP\n01190000 NASTY: -\n01200000    WRITE &STR(&ARG) CAN NOT BE EVALUATED.  ENTER A QUESTION MARK FOR HE\n01210000    SET ARG =\n01220000    SET VAL =\n01230000    GOTO LOOP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PANELS": {"ttr": 11017, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01\\x00\\x01\\x00\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 256, "newlines": 256, "modlines": 0, "user": "MCRITCH"}, "text": "  PROC 1 MEMBER ALL EDIT SUMMARY NB DEBUG CHKCAT -\n     DS1('&SYSUID..LIBR.PANELS') -\n          DS2('TECH.SYSTECH.ISPPLIB') -\n          DS3('TECHTSO.COMBINE.ISPPLIB') -\n          DS4('TSOTEST.LIB01.PANELS') -\n          DS5('TSOPROD.LIB01.PANELS') -\n  CL1('TECH.ISPPLIB') +\n  CL2('SYS1.ISPFPDF.ISRPLIB') +\n  CL3('SYS1.ISPF.ISPPLIB') +\n  CL4('SYS6.IOF.ISPPLIB') +\n  CL5('SYS1.DSNSPFP') +\n  CL6('SYS1.VSF2PLIB') +\n  CL7('SYS1.COB2PLIB') +\n  CL8('CAI.CAIISPP') +\n  CL9('TSOPROD.LIB01.PANELS') +\n CL10('SYS1.ICEISPP') +\n CL11('SYS1.ICEDGTP') +\n CL12('SYS1.ICQPLIB') -\n CL13('SYS1.HRFPANL') -\n CL14('SYS1.SBLSPNL0') -\n CL15('SYS1.DGTPLIB')\n/*********************************************************************/\n/* *** the following are actually in IV2B69 .... ***                 */\n/*         TECHTSO.COMBINE.ISPPLIB  as of 1993/10/01 contains...     */\n/*  TECH.ISPPLIB           -- SYSTECH common use addit. and overrides*/\n/*  SYS1.ISPFPDF.ISRPLIB   -- IBM supplied ISPF panels (FLM..,ISR..) */\n/*  SYS1.ISPF.ISPPLIB      -- IBM supplied mainly TUTORIAL  (ISP..)  */\n/*  SYS6.IOF.ISPPLIB       -- single panel for IOF -- (VIOFSCRN)     */\n/*  SYS1.DSNSPFP           -- IBM DB2 panels      (DSN..)            */\n/*  SYS1.VSF2PLIB          -- IBM FORTRAN panels  (AFF..)            */\n/*  SYS1.COB2PLIB          -- IBM COBOL panels (IGZT..,ISRFPA)       */\n/*  CAI.CAIISPP            -- Computer Associates panels-- JCLCHECK  */\n/*  TSOPROD.LIB01.PANELS   -- Production panels by CIS programmers   */\n/*  SYS1.ICEISPP           -- IBM SORT panels  (mainly ICE..)        */\n/*  SYS1.ICEDGTP           -- IBM SORT panels  (ICE..)               */\n/*********************************************************************/\n/*     the following libraries exist though not in the TECH.COMBINE..*/\n/*  SYS1.ICQPLIB     Information Center Facility       (ICQ...)      */\n/*  SYS1.HRFPANL     RACF                              (RCH...)      */\n/*  SYS1.SBLSPNL0    DUMP Analysis                                   */\n/*  SYS1.DGTPLIB                              (DFQ,DGT.,ICEHRE50 dup)*/\n/*********************************************************************/\n/* PURPOSE: BROWSE A PANELS MEMBER\n/*          ACCORDING TO EXPECTED ORDER\n/*  SUPPLIED BY DAVID MCRITCHIE AHC 1985/07/10\n/*  TO CHECK THE LIBRARIES CHECKED IN THIS PANELS YOU MAY WISH\n/*   TO COMPARE DSNAMES WITH  DSNAME SHOWN USING \"\n/*         ===> TSO DDNAME SYSPROC\".\n/*  TEST WITH MEMBERNAME  \"ISRJC03\"\n/*  OPTIONS -- */\n/*   DEBUG -- TRACING FOR PROGRAMMER\n/*   NB -- NO BROWSE DS LIBRARIES\n/*   ALL   -- WILL (ALSO) BROWSE THE COMBINED LIBRARIES\n/*   SUMMARY -- WILL PRODUCE A SUMMARY LIST AT END\n/*   CONTROL MAIN\n/*  REFRESHED FROM IV2B69  ON 1992/11/13 -- D.MCR */\n/*    WITH SOME ASSISTANCE IS03.LIBR.CLIST(IV2B69R)  */\n/****************************************************************    */\n/* ***** Example of Usage:  ===> TSO PANELS membername\n/* ***** Also of Interest:  ===> TSO PDSDD ISPPLIB membername\n/* ***** Also of Interest:  ===> TSO PDSDD PANELS  membername\n/* ***** Also of Interest:  ===> TSO DDNAME ISPPLIB\n/* ***** Also of Interest:  ===> TSO CLIST membername\n/* ***** Also of Interest:  ===> TSO PROC  membername\n/* * Also of Interest:  ===> TSO LISTALC (STATUS) (HISTORY) (SYSNAMES)\n/****************************************************************    */\n  SET L = &LENGTH(&STR(&MEMBER.))\n  IF &L. > 8 THEN DO\n     SET INVAL =INVALID MEMBERNAME LENGTH('&MEMBER.') EXCEEDS 8\n     WRITE &INVAL.\n     SET &ZEDSMSG = &STR(MEMBERNAME)\n     SET &ZEDLMSG = &STR(&INVAL.)\n     ISPEXEC     SETMSG MSG(ISRZ000)\n     EXIT CODE(12)\n  END\n   SET MULTIMEM = &SYSINDEX(&STR(*),&STR(&MEMBER.))\n   IF &MULTIMEM = 0 THEN -\n      SET MULTIMEM = &SYSINDEX(&STR(%),&STR(&MEMBER.))\n  ISPEXEC CONTROL DISPLAY LINE\n  SET BLANKS = &STR(                                            )\n  SET BLANKS = &STR(&BLANKS.&BLANKS.)\n  SET DEBUG = &SYSCAPS(&DEBUG)\n  SET NB    = &SYSCAPS(&NB)\n  IF &NB = NB THEN SET SUMMARY = SUMMARY\n  SET ALL  = &SYSCAPS(&ALL)\n  SET SUMMARY = &SYSCAPS(&SUMMARY)\n  SET XCNT = 0\n  SET RC = 0\n  SET N = 1\n  SET DS = &&DS&N..\n  SET BROWSE = BROWSE\n  IF &STR(&EDIT) = EDIT THEN SET BROWSE = EDIT\n  IF CHKCAT = &SYSCAPS(&STR(&CHKCAT.))  +\n   | CHKCAT = &SYSCAPS(&STR(&MEMBER.)) +\n  THEN DO\n     SET CHKCAT = CHKCAT\n     SET MEMBER = &STR(........)\n     SET ALL = ALL    /* MIGHT AS WELL CHECK EVERYTHING */\n  END\n  DO WHILE &STR(&DS) ^=\n     SET RC = &N\n     IF CHKCAT = &SYSCAPS(&CHKCAT.) THEN DO\n        /*    CONTROL NOLIST NOCONLIST NOSYMLIST MSG\n        /*       SYSOUT TRAPS WILL NOT WORK IF YOU USE   LIST\n        SET SYSOUTTRAP = 100\n        SET SYSOUTLINE7 = &STR(.....................................)\n        LISTCAT ENT('&DS.') VOL\n        SET NS = &SYSOUTLINE\n        SET I = 1\n        DO WHILE &I <= &NS\n           SET X = &STR(&&SYSOUTLINE&I..)\n           SET X = &STR(&X.)\n           SET I = &I. + 1\n        END\n        WRITE &SUBSTR(26:31,&SYSOUTLINE7.&BLANKS.) +\n           &SUBSTR(16:60,&SYSOUTLINE1.&BLANKS.)\n        GOTO AGAIN\n     END\n /*  SET MULTIMEM = &SYSINDEX(&STR(*),&STR(&MEMBER.))*/\n     IF &MULTIMEM NE 0 THEN DO\n        SET XDSN&RC = &STR(&DS.)\n        SET CHK&RC = &STR(NO ---MEMBERS FOUND)\n        $&BROWSE. '&DS.(&STR(&MEMBER.))'\n        IF &LASTCC. = 0 THEN DO\n           SET XCNT = &XCNT. + 1\n           SET MULTI&N. = 1  /* WOULD BE NICE TO HAVE A COUNT*/\n           SET CHK&RC = &STR(MEMBER&LP.S&RP. FOUND)\n        END\n        GOTO AGAIN\n     END\n     SET CHKX = &STR(&SYSDSN('&DS.(&MEMBER.)'))\n     SET XDSN&RC = &STR(&DS.)\n     SET CHK&RC = &STR(&CHKX)\n     IF &STR(&CHKX) = OK THEN DO\n        SET DSNAME = '&DS.(&MEMBER.)'\n        IF &NB ^= NB THEN DO\n           ISPEXEC VPUT DSNAME SHARED\n           ISPEXEC   &BROWSE DATASET('&DS.(&MEMBER.)')\n           SET DSNAME =\n           ISPEXEC VPUT DSNAME SHARED\n        END\n        SET XCNT = &XCNT. + 1\n     END\n     ELSE IF &DEBUG. = DEBUG THEN DO\n        WRITE '&DS.(&MEMBER.)' -- &STR(&CHKX).\n     END\n    AGAIN: +\n     SET N = &N. + 1\n     SET DS = &&DS&N..\n  END\n  IF &XCNT. ^=0 THEN DO\n     IF &XCNT ^= 1 THEN -\n        WRITE MEMBER=&MEMBER. WAS FOUND IN &XCNT. PANEL LIBRARIES\n     IF &ALL ^= ALL AND &SUMMARY ^= SUMMARY THEN EXIT CODE(0)\n  END\n  ELSE DO\n  IF CHKCAT ^= &STR(&CHKCAT.) THEN\n     WRITE MEMBER=&MEMBER. WAS NOT FOUND IN ANY OF +\n       SELECTED REGULAR PANEL LIBRARIES\n  END\n  SET DRC = &RC.\n  /************** REDO FOR COMBINED LIBRARIES       ********/\n  SET CCNT = 0\n  SET N = 1\n  SET CL = &&CL&N..\n  DO WHILE &STR(&CL) ^=\n     SET RC = &RC + 1\n     SET XDSN&RC = &STR(&CL.)\n     IF CHKCAT = &SYSCAPS(&CHKCAT.) THEN DO\n        /*    CONTROL NOLIST NOCONLIST NOSYMLIST MSG\n        /*       SYSOUT TRAPS WILL NOT WORK IF YOU USE   LIST\n        SET SYSOUTTRAP = 100\n        SET SYSOUTLINE7 = &STR(.....................................)\n        LISTCAT ENT('&CL.') VOL\n        SET NS = &SYSOUTLINE\n        SET I = 1\n        DO WHILE &I <= &NS\n           SET X = &STR(&&SYSOUTLINE&I..)\n           SET X = &STR(&X.)\n           SET I = &I. + 1\n        END\n        WRITE &SUBSTR(26:31,&SYSOUTLINE7.&BLANKS.) +\n           &SUBSTR(16:60,&SYSOUTLINE1.&BLANKS.)\n        GOTO AGAIN2\n     END\n     IF &MULTIMEM NE 0 THEN DO\n        SET XDSN&RC = &STR(&DS.)\n        SET CHK&RC = &STR(NO ---MEMBERS FOUND)\n        $&BROWSE. '&DS.(&STR(&MEMBER.))'\n        IF &LASTCC. = 0 THEN DO\n           SET CCNT = &CCNT. + 1\n           SET MULTI&N. = 1  /* WOULD BE NICE TO HAVE A COUNT*/\n           SET CHK&RC = &STR(MEMBER&LP.S&RP. FOUND)\n        END\n        GOTO AGAIN2\n     END\n     SET CHKX = &STR(&SYSDSN('&CL.(&MEMBER.)'))\n     SET CHK&RC = &STR(&CHKX)\n     IF &STR(&CHKX) = OK THEN DO\n        IF &ALL = ALL THEN DO\n           SET DSNAME = '&CL.(&MEMBER.)'\n           ISPEXEC VPUT DSNAME SHARED\n           ISPEXEC   &BROWSE DATASET('&CL.(&MEMBER.)')\n           SET DSNAME =\n           ISPEXEC VPUT DSNAME SHARED\n        END\n        SET CCNT = &CCNT. + 1\n     END\n     ELSE IF &DEBUG. = DEBUG THEN DO\n        WRITE '&CL.(&MEMBER.)' -- &STR(&CHKX).\n     END\n    AGAIN2: +\n     SET N = &N. + 1\n     SET CL = &&CL&N..\n  END\n  SET HRC = &RC.\n /* --------------------------------------------------------------- */\n  IF &SUMMARY ^= SUMMARY THEN DO\n         SET DSN =\n         SET XDSN =\n         EXIT CODE(0)\n  END\n  WRITE  As an alternative to SUMMARY verification you could enter ...\n  WRITE  &STR()     ===> TSO PDSDD PANELS &MEMBER ALL\n  WRITE\n /* --------------------------------------------------------------- */\n  SET I = 1\n  IF &STR(&DDNAME) ^= &STR(&DDNAMEX) THEN DO\n       WRITE SUMMARY ----------------- PANELS &STR(&DDNAME) +\n                &MEMBER &ALL &SUMMARY &NB &DEBUG DSN1() DSN2()\n  END\n  ELSE WRITE SUMMARY -------- +\n        ===> TSO PANELS &DDNAME &MEMBER &ALL &SUMMARY &NB &DEBUG\n  WRITE AS DETERMINED &SYSDATE. +\n        &SYSTIME. FOR &SYSUID. USING PROC=&SYSPROC.\n  SET STR44 = &STR(............................................)\n  DO WHILE &I <= &RC\n     IF &I = &EVAL(&HRC + 1) | &I = &EVAL(&DRC + 1) THEN DO\n        IF &I = &EVAL(&DRC + 1) THEN -\n             WRITE ------ &BROWSE OF COMBINED +\n                 LIBRARIES OCCURS ONLY WITH 'ALL' OPTION\n        ELSE WRITE ------ &BROWSE OF ADDITIONAL +\n             LIBRARIES OCCURS ONLY WITH 'ALL' OPTION\n     END\n     SET DSN = '&STR(&&XDSN&I.(&MEMBER.))'\n     SET CHK =  &STR(&&CHK&I)\n     IF &I < 10 THEN WRITE &STR(0&I) +\n        &SUBSTR(1:44,&STR(&STR(&DSN) &STR(&STR44))) &CHK.\n     ELSE             WRITE &STR(&I) +\n        &SUBSTR(1:44,&STR(&STR(&DSN) &STR(&STR44))) &CHK.\n     SET I = &I + 1\n  END\n  IF &DEBUG = DEBUG THEN WRITE  DRC=&DRC  RC=&RC HRC=&HRC I=&I\n  SET DSN =\n  SET XDSN =\n /* ----+++ */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PASTE": {"ttr": 11265, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01R\\x01R\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 338, "newlines": 338, "modlines": 0, "user": "MCRITCH"}, "text": "/* PASTE: Portion of CUT/PASTE, with various options    (REXX)       */\n/* Author: David McRitchie, \"The REXX Macros Toolbox\", 1991/04/24    */\n/*     derived from NaSPA 004 member PASTE, added KEEP,(member)      */\n/*     1994/05/26 Converted to REXX, added COL(),VALUE() options     */\n/*     1994/06/24 Ability to used numbered CUTDSN## datasets         */\n/*-------------------------------------------------------------------*/\n/*       Macro:   PASTE          (PASTER for SPF/PC usage)           */\n/*       Purpose: Paste lines that have previously been cut, or      */\n/*                paste from member in a permanent PASTE pds library.*/\n/*       Companion Macros: CUT, APPEND     --  spf/pc CUTR, APPENDR  */\n/*       Related Macros:   REFORMAT, @IDATA                          */\n/*********************************************************************/\n/* Highlights: This set of CUT/APPEND/PASTE macros will mark the     */\n/*   changes in the affected file with NOTELINEs.  This allows easy  */\n/*   comparison between old material and new material, etc.  Some    */\n/*   other versions of CUT/APPEND/PASTE use ISPF variables causing   */\n/*   serious problems with your profile dataset when large files are */\n/*   copied.  This will not happen with these macros, also your data */\n/*   being in a distinct dataset is protected across logons/crashes. */\n/*   Written in REXX readily permits later customizations.           */\n/*   Other cut/paste macros: NaSPA 0004, CBT 95, 161, 168, 194, 270  */\n/*********************************************************************/\n/*  THIS EDIT MACRO CLIST AND ITS COMPANIONS                         */\n/*                                                                   */\n/*  CUT ---------- ** THIS EDIT MACRO ** ------------                */\n/*     Take selected lines specified by the user and copy/move       */\n/*     them to a sequential work dataset used later by the paste     */\n/*     command.                                                      */\n/*  APPEND ------- ** COMPANION EDIT MACRO ** -------                */\n/*    Will append additional information a header will be created,   */\n/*    and information will be appended to your cut dataset.          */\n/*  PASTE -------- ** COMPANION EDIT MACRO ** -------                */\n/*    Take the output dataset created by cut and move it to          */\n/*    anywhere in the current dataset being edited.                  */\n/* Options of CUT and APPEND  (all options are optional)             */\n/*    CC-range -- restrict selected lines -- normal usage            */\n/*    NX   -- Include only NX lines within CC-Range or entire range  */\n/*    DOC  -- (opt.) document with date/timestamp and source dsn.    */\n/*    NX       Copy NX lines,  CC-range becomes optional             */\n/*    EDIT     edit the paste dataset                                */\n/*    ? |HELP  Show help information                                 */\n/*    ##   -- 1 or 2 digit number  to cut into a different dsn       */\n/*             i.e.   userid.CUTDSN##.LIST                           */\n/* Options of PASTE ---------------------------------                */\n/*    KEEP -- Keep work dataset, default is to delete work file      */\n/*    COL(nn),VALUE(xxxx) -- include only lines with value in col nn */\n/*    (member),  paste member from permanent pds PASTE library       */\n/*    ##   -- 1 or 2 digit number  to paste from a different dsn     */\n/*             i.e.   userid.CUTDSN##.LIST                           */\n/* WARNINGS: ----- WARNINGS -------------------------                */\n/*    The CUT file attributes are based on the original file cut --  */\n/*    you may lose later information added if the recordsize is      */\n/*    larger than the original -- especially for fixed records.      */\n/*    m<n> or mm line options will alter your dataset by removing    */\n/*    lines.      Other cut/paste clists may eat up your profile     */\n/*    dataset, this clist uses a work file and therefore does not    */\n/*    affect your profile.                                           */\n/*                                                                   */\n/*  EXAMPLE :                                                        */\n/*     CUT     USE   CC  OR MM LINE RANGE,  OR C<N> OR M<N>          */\n/*     APPEND  USE   CC  OR MM LINE RANGE,  OR C<N> OR M<N>          */\n/*     PASTE   USE   B   OR A   LINE RANGE                           */\n/*********************************************************************/\n/* NOTE:  QWPASTE MUST BE USED WHEN USING PASTE FACILITIES OF       */\n/*        MVS/QUICKREF 3.2 INVOKED VIA QW.                          */\n/*********************************************************************/\n/*                                                                   */\n/*******************************************************************/\n/* Wait to PROCESS any line commands until MACRO init. completed.  */\n/*******************************************************************/\n  Address \"ISREDIT\";\"macro NOPROCESS (tokens)\"; Itokens=tokens\n  tokens = \" \"translate(tokens)\" \"; Member=\"\"\n  other=\"\";CUTDSNnn=\"CUTDSN\"\n  recno=0\n  /* obtain parameters:  COL(col), VALUE(value), KEEP */\n  i=pos(' HELP ',tokens); if i=0 then i=pos('?',TOKENs);\n  if i \\= 0 then do; address \"TSO\" \"CLIST CUT HELP\"; exit 1;end;\n  i = pos(' KEEP ',tokens);\n  if i =0 then keep=\"\"; else do\n        keep=\"KEEP\"; tokens=substr(tokens,1,i)substr(tokens,I+6);end\n  i = pos(' EDIT ',tokens);\n  if i =0 then edit=\"\"; else do\n        edit=\"EDIT\"; tokens=substr(tokens,1,i)substr(tokens,I+6);end\n  parse var tokens left ' COL(' col ') ' right; tokens = left right\n  parse var tokens left ' VALUE(' value ')' right; tokens=left right\n  parse var tokens left \"(\" member \")\" right;\n  if member \\= \"\" then keep = \"KEEP\"\n  remaining = left right\n  if remaining \\= \"\" then do\n     remaining = strip(remaining)\n     if datatype(remaining,'N') = 1 then do\n        other = remaining + 0; remaining=\"\"\n        CUTDSNnn = CUTDSNnn||other\n     end\n  end\n  if remaining \\= \"\" then do\n    zedsmsg = \"?\" remaining\n    zedlmsg = \"remaining tokens unknown: \"remaining\n    Address \"ISPEXEC\" \"setmsg msg(isrz000)\"\n    exit 1\n  end\n\n  pasting = 1; include = 0;\n  q.=\"\";  truncat=\"\";  rcnote=\"\"\n  parse version v1 v2 v3\n  if v1 = \"REXX370\" then Nop;\n  else if v1 = \"REXXSAA\" then Nop; else do; say \"v1=\"v1;exit 12;end;\n\n/******************************************************************/\n/* Allocate temporary dataset created by PDFCUT edit macro.       */\n/******************************************************************/\n  if v1 = \"REXX370\" then do\n     userid = strip(sysvar('sysuid'))\n     prefix = strip(sysvar(syspref)); If prefix='' then prefix=userid\n     dataset = prefix\".\"CUTDSNnn\".LIST\"\n  end\n  if v1=\"REXXSAA\" then dataset = \"c:\\junk\\\"CUTDSNnn\".dat\"\n  if member \\= \"\" then do\n     dataset = prefix\".LIBR.PASTE\"||other||\"(\"strip(member)\")\"; keep=\"KEEP\"\n     if v1=\"REXXSAA\" then dataset = \"c:\\is03\\\"member\".CMD\"\n  end;\n  if v1 = \"REXX370\" then do\n     x = sysdsn(\"'\"dataset\"'\")\n     if x \\= \"OK\" then do\n        \"PROCESS DEST\"\n   /*   If rcx \\= 8 then do; say \"SORRY\";Exit 12; End  */\n        \"(Cdest) = linenum .zdest\";  CdestP1=Cdest+1\n/*********************************************************************/\n/* Perform RESET operation to get rid of the destination char. \"A\"   */\n/*********************************************************************/\n         ZEDSMSG = \"work dataset not found\"\n         ZEDLMSG = \"PASTE (work) dataset '\"dataset\"',\",\n             \"could not be found\"\n         Address \"ISPEXEC\" \"setmsg msg(isrz001)\" /* alarm */\n         if Cdest > 0 then do\n         \"line_after .zdest = noteline \"\"\"||,\n            \"Have reset .ZDEST command A(fter) or B(efore)\",\n             \"immediate above or below\"\"\"\n         \"reset\" Cdest CdestP1 \"command\"\n         end\n         Exit 12\n     End\n  End\n  If EDIT = \"EDIT\" then do\n     ZEDSMSG = \"PASTE EDIT\"\n     ZEDLMSG = \"You are viewing your paste dataset\"\n     if member \\= \"\" then zedlmsg = \"You are viewing a member\",\n        \"in your permanent PASTE partitioned library\"\n     Address \"ISPEXEC\" \"setmsg msg(isrz001)\" /* alarm*/\n     if v1 = \"REXX370\" then\n         Address \"ISPEXEC\" \"edit dataset('\"dataset\"')\"\n     if v1 = \"REXXSAA\" then address \"cmd\" \"spf2\" dataset\n     ZEDSMSG = \"PASTE EDIT -- COMPLETED\"\n     ZEDLMSG = \"EXAMINATION OF PASTE DATASET COMPLETED\"\n     Address \"ISPEXEC\" \"setmsg msg(isrz000)\"\n     Exit 1\n  End\n  /****************/\n  if col||value \\= \"\" then if value=\"\" | col=\"\" then do\n      /* Only COL() VALUE() provided after     */\n      /*  EDIT, VIEW, or KEEP have been tested for */\n      ZEDSMSG = \"\"\n      ZEDLMSG = \"COL(\"col\") VALUE(\"value\") -- both must be\",\n          \"nonblank when either is used\"\n      Address \"ISPEXEC\" \"setmsg msg(isrz000)\"\n      Exit 9\n  End\n  If col \\= \"\" then\n        do; keep=\"KEEP\";pasting=0; Lvalue = length(value); End;\n\n  if v1 = \"REXX370\" then do;\n    Address \"TSO\" \"ALLOC F(TEMPFLE) DA('\"DATASET\"') SHR REUSE\"\n    ADDRESS \"TSO\" \"EXECIO * DISKR tempfle (STEM Q. FINIS\"\n  end\n  if v1 = \"REXXSAA\" then call PC_QLOAD\n\n  /* If FILE IS EMPTY WE CAN PASTE (NO LABELS DEST OR RANGE EXISTS)*/\n  \"(DEST) = LINENUM .ZFIRST\"\n  If  dest  = \"000000\" then signal USEDEST\n\n\n/*********************************************************************/\n/* Tell macro that  we  will  PROCESS  B (Before)  or  A (After)     */\n/*   destination commands.  Only DEST is valid anything else is not. */\n/* Unexpected  C range caused abend S-0C4, so we will check for it.  */\n/*********************************************************************/\n\n  if v1 = \"REXXSAA\" then \"PROCESS DEST RANGE C M\"\n  if v1 = \"REXX370\" then \"PROCESS DEST RANGE C M\"\n  rcx = rc\n  if v1 = \"REXX370\" then do\n     /************* will not function in SPF/PC due to bugs *****/\n      \"(CMD) = RANGE_CMD\"\n      If rcx = 0 | rcx = 8 then do\n        ZEDSMSG = \"RANGE NOT ALLOWED rc\"=rcx\n        ZEDLMSG = \"RANGE\" cmd \"NOT USED WITH PASTE --\",\n            \"use dest \"\"A\"\" or \"\"B\"\" only\"\n            say zedlmsg; say zedlmsg;\n        Address \"ISPEXEC\" \"setmsg msg(isrz001)\" /* alarm */\n        Exit 12         /* HIGH RETURN CODE LEAVES COMMAND */\n      End\n     If rcx \\= 4 then do\n        ZEDSMSG = \"PASTE PENDING\"\n        ZEDLMSG = \"An \"\"A\"\" or \"\"B\"\" line command has NOT been\",\n             \"specified, or line commands conflict\"\n            say zedlmsg; say zedlmsg;\n        Address \"ISPEXEC\" \"setmsg msg(isrz001)\" /* alarm */\n        Exit 12         /* high return code leaves command */\n      End\n     /************* will not function in SPF/PC due to bugs *****/\n  end\n\n/*********************************************************************/\n/* The DEST line number for \"A\" or \"B\" entered by user.              */\n/*********************************************************************/\n  \"(DEST) = LINENUM .ZDEST\"\n\n/*********************************************************************/\n/* After the ISREDIT LINENUM command, it is necessary to strip the   */\n/* dest variable of any leading zeroes.                              */\n/*********************************************************************/\n\n USEDEST:\n  DEST =  dest + 0\n  sdest = dest\n\n/*********************************************************************/\n/* Find out if sequence numbering is on.                             */\n/*********************************************************************/\n\"(NUMON) = NUMBER\"\n\n/*********************************************/\n/* TSO/E ERROR ROUTINE BEFORE USE OF         */\n/* CLIST QSAM ROUTINES TO READ WORK DATASET. */\n/*********************************************/\n\n   \"(caps) = caps\"\n   Do recno = 1 to q.0;\n      x = q.recno\n      if caps = \"ON\" then do\n        if x \\= translate(x) then do\n           caps = \"OFF\"\n           \"CAPS\" caps\n           \"LINE_AFTER\" dest \"= noteline \"\"Caps turned OFF\"\"\"\n        end\n      end\n      if col \\= \"\" then do j=1 to 1\n         if include = 1 then if x = \"\" then\n              do; include=0; leave j; end;\n         if translate(substr(x,col,lvalue)) \\= value then iterate recno\n         include = 1\n      end\n      \"LINE_AFTER\" dest \"= dataline (x)\"\n      If RC = 4 then Truncat = \" -Data Truncated-\"\n      if dest = sdest then\n         \"LINE_AFTER\" dest \"= NOTELINE \"\"\"time(),\n             \"START OF PASTE\" Itokens\"\"\"\"\n      dest = dest + 1\n   end recno;\n   x = TIME() \"-E\"||\"nd- of PASTE\" Itokens\n   \"line_after\" dest \"= Noteline (x)\"\n   if numon = \"ON\" then if truncat \\= \"\" then \"line_before\",\n      dest \"= noteline \"\"\"time() \"Number mode in effect\",\n      \"truncation loss may or may not be real\"\"\"\n\n   /* Delete  userid.CUTDSN.LIST unless KEEP -- double checking*/\n   c = \"moved\"; if keep = \"KEEP\" then c=\"copied\"\n   if member = \" \" then d=\"dataset\"; else d=\"member\"\n   If keep \\= \"KEEP\" then do; /*insure we d-o not scatch a PDS */\n    if v1 = \"REXX370\" then do\n      x = listdsi(\"'\"dataset\"'\")\n      If SYSDSORG = \"PS\" then do\n        x = msg('off')\n        address \"TSO\" \"DELETE '\"dataset\"'\"\n        x = msg('on')\n      end\n      else c = \"copied\"\n    end;\n    else do; c=\"copied\"; d=\"file\"; end;\n   end\n   ZEDSMSG = \"PASTE SUCCESSFULL\"\n   ZEDLMSG = \"PASTE work dataset was\" c \"into current\" d\n   Address \"ISPEXEC\" \"setmsg msg(isrz000)\"\n   Exit 1\n\nPC_QLOAD:   /* for REXXSAA put entire file into  stem (Q.) . */\n   if v1 \\= \"REXXSAA\" then do; say \"PC_QLOAD not REXXSAA\";exit 12;end\n   CUTDSN = \"c:\\junk\\\"CUTDSNnn\".dat\"; myfile = CUTDSN\n   Call Stream myfile, \"Command\", \"Open read\";\n   If Result \\= \"READY:\" then do;\n      Say \"Output '\"myfile\"' open returned '\"Result\"'\";\n      Signal InnerError;\n   End;\n   qcnt = 0\n   Do forever;\n      X = LineIn(myfile);\n      RC = Stream(myfile, \"Description\");\n      Select; /*match up like a DO */\n         When RC = \"READY:\" then NOp;\n         When RC = \"NOTREADY:EOF\" then Leave;\n         Otherwise\n            Call InputError RC;\n            Signal InnerError;\n            exit\n      End;\n      qcnt = qcnt+1; q.0 = qcnt; q.qcnt = x\n   End\n   Call Stream myfile, \"Command\", \"Close\";\n   If Result \\= \"READY:\" then do;\n      Say \"Output '\"myfile\"' close returned '\"Result\"'\";\n      Signal InnerError;\n   End;\n\n   /********** temporary -- until tested on a PC *********/\n   /*  do i=1 to q.0; say q.i; end;          ------------*/\n   /******************************************************/\n\n   Return\nInnerError:\n   If Stream(myfile, \"Description\") \\= \"UNKNOWN:\" then do;\n      Call Stream(myfile, \"Command\", \"Close\");\n      If Result \\= \"READY:\" then do;\n         Say \"Output '\"myfile\"' emergency close returned '\"Result\"'\";\n         ReturnCode = Max(16, ReturnCode);\n      End;\n   End;\n   Exit Max(12, ReturnCode);\n/*******************************************************/\n/* COL() VALUE() INCLUDE pasting ADDED D.MCR 1992/09/22 */\n/*******************************************************/\n/*********************************************************************/\n/*       111 VALUE OF 111 IS AAAA                                    */\n/*       222 VALUE OF 222 IS BBBB                                    */\n/*           CONTINUED LINE OF 222                                   */\n/*       333 VALUE OF 333 IS CCC                                     */\n/*  &AMP.222 ANOTHER 222 HERE                                        */\n/*           ANOTHER CONTINUED LINE OF 22                            */\n/*********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSDD": {"ttr": 11271, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x013\\x013\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 307, "newlines": 307, "modlines": 0, "user": "MCRITCH"}, "text": "PROC 2 DDNAME MEMBER ALL EDIT NB DSN1() DSN2() DSN3() -\n  DSN4() DSN5() DSN6() DSN7() DSN8() DSN9() DSN10() -\n  DSN11() DSN12() DSN13() DSN14() DSN15() DSN16() DSN17() DSN()\n/*  TITLE: PDSDD  -- PARTITIONED DATASET DISPLAY -- CLIST PANELS PROC\n/*  USERS:       TSO ISPF EDIT USERS\n/*  ENTRY: USED AS A TSO CLIST        COMMAND  ===> PDSDD CLIST CLIST\n/*  CONTRIBUTED: 1986/01/17 DAVID MCRITCHIE\n/*  EXAMPLE:  ===> PDSDD CLIST CLIST\n/*            ===> PDSDD PANELS ISREDDE\n/*===> PDSDD PANELS @INDEX DSN1(IS03.SHARE.CNTL) DSN2(IS03.SHARE.TEXT)\n/****************************************************************    */\n/* ***** Example of Usage:  ===> TSO PDSDD SYSPROC membername\n/* ***** Example of Usage:  ===> TSO PDSDD CLIST   membername\n/* ***** Also of Interest:  ===> TSO CLIST membername\n/* ***** Also of Interest:  ===> TSO DDNAME SYSPROC\n/* ***** Also of Interest:  ===> TSO PROC  membername\n/* * Also of Interest:  ===> TSO LISTALC (STATUS) (HISTORY) (SYSNAMES)\n/****************************************************************    */\n SET DDNAME = &SYSCAPS(&STR(&DDNAME))\n SET MEMBER = &SYSCAPS(&STR(&MEMBER))\n SET MULTIMEM = &SYSINDEX(&STR(*),&STR(&MEMBER.))\n IF &MULTIMEM = 0 THEN -\n    SET MULTIMEM = &SYSINDEX(&STR(%),&STR(&MEMBER.))\n SET DDNAMEX = &STR(&DDNAME)\n SET DSN0 = &STR(&DSN)\n IF &DDNAME = PROC     THEN DO\n    %PROC &MEMBER.\n    IF &STR(&DSN1()&DSN2()&DSN3()&DSN4())  = &STR() THEN DO\n       WRITE ADDITIONAL DSNAMES WILL NOT BE CHECKED\n       EXIT CODE(0)\n    END\n    ELSE WRITE ADDITIONAL DSNAMES WILL NOW BE CHECKED\n    SET DDNAME = &STR(*)    /* PERMIT TO CHECK FOR DSN1() ETC. */\n END\n IF &STR(&DDNAME) = &STR(*) THEN DO\n    SET RCX = 0\n    SET HRC = 0\n    SET DRC = 0\n    GOTO SKIPDD\n END\n IF &DDNAME = CLIST    THEN SET DDNAME = SYSPROC\n IF &DDNAME = MESSAGE  THEN SET DDNAME = ISPMLIB\n IF &DDNAME = PANELS   THEN SET DDNAME = ISPPLIB\n IF &DDNAME = PROFILE  THEN SET DDNAME = ISPTLIB\n IF &DDNAME = SKELETON THEN SET DDNAME = ISPSLIB\n IF &DDNAME = HELP     THEN SET DDNAME = SYSHELP\n SET SYSOUTTRAP = 400\n LISTALC STA\n SET N = &SYSOUTLINE\n SET SYSOUTTRAP = 0\n SET RCX = 0  /* FILES TO BE CHECKED LATER RACF/BROWSE */\n SET I = 2\n SET HIT2 = 0\n SET HIT1 = 0\n DO WHILE &I <= &N\n    SET X = &STR(&&SYSOUTLINE&I..)\n    SET X = &STR(&X.)\n    IF &HIT1 = 1 THEN DO\n       IF &SUBSTR(1:4,&STR(&X.)    ) ^= &STR(    ) THEN SET HIT1 = 0\n    END\n    IF &HIT1 = 0 THEN DO\n       IF &SUBSTR(1:2,&STR(&X.)  ) ^= &STR(  ) THEN GOTO NIX\n       IF &SUBSTR(1:10,&STR(&X.         )) = &STR(  &STR(&DDNAME)) +\n              THEN SET HIT1 = 1\n       ELSE GOTO NIX\n    END\n    SET DX = &STR(&&SYSOUTLINE&EVAL(&I.-1).)\n    SET DX = &STR(&DX)\n    SET RCX = &RCX + 1\n    SET XDSN&RCX = &DX\n    SET I = &I. + 1\nNIX: -\n    SET I = &I. + 1\n END\n/* ------------- ADD ADDITIONAL LIBRARIES IF CLIST IS DDNAME ------- */\n/* ------------- BASED ON A PRODUCTION JOB AHIV2B69 1986/01/21 ------- */\n SET HRC = &RCX\n IF &ALL ^= ALL THEN DO\n    IF &DDNAMEX = CLIST THEN DO\n       SET RCX = &RCX + 1\n       SET XDSN&RCX = &STR(SYS1.TSOCLIST)\n    END\n END\n IF &ALL = ALL THEN DO\n     IF &DDNAMEX = PANELS THEN DO  /* ISPPLIB */\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(TECH.ISPPLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.V2R1M2.ISRPLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.V2R1M2.ISPPLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.ISFPLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS6.ISSCO.TAG60.IVISPLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(DMS70.ISPPLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.SGIMPNL0)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.SBLSPNL0)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS6.IOF.REL5.ISPPLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS6.APEX.SPF)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.DB2.ISPPLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.ICQPLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.QMF.DSQPLIBE)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.HRFPANL)\n     END\n     IF &DDNAMEX = MESSAGE THEN DO    /* ISPMLIB */\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.QMF.DSQMLIBE)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.V2R1M2.ISRMLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.V2R1M2.ISPMLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS6.ISSCO.TAG60.IVISMLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(DMS70.ISPMLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(TECH.ISPMLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.SGIMMSG0)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.SBLSMSG0)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS6.IOF.REL5.ISPMLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.DB2.ISPMLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.ICQMLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.HRFMSG)\n     END\n     IF &DDNAMEX = SKELETON THEN DO   /*ISPSLIB*/\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.QMF.DSQSLIBE)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(TECH.ISPSLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.V2R1M2.ISRSLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.V2R1M2.ISPSLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS6.ISSCO.TAG60.IVISSLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(DMS70.ISPSLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.SGIMPRC0)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.ICQSLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.HRFSKEL)\n     END\n     IF &DDNAMEX = CLIST   THEN DO /* SYSPROC */\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(TECH.V2R1M2VB.ISRCLIB)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.TSOCLIST)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(TECH.IPCS.CLIST)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(DB2PROD.REBLK.CLIST)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS6.ISSCO.TAG60.CLIST)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(TECH.ICQADMIN.CLIST)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(TECH.ICQUSER.CLIST)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(TECH.SMGR.CLIST)\n        SET RCX = &RCX + 1\n        SET XDSN&RCX = &STR(SYS1.QMF120VB.DSQCLSTE)\n     END\n END\n SKIPDD:  SET JJ = 0&JJ + 0\n /* ------------- ADD ADDITIONAL LIBRARIES IF DD1() DD2() ETC. USED- */\n SET DRC = &RCX\n SET J = 0\n DO WHILE &J <= 10\n    SET DSN = &STR(&&DSN&J)\n    IF &SUBSTR(1:1,&STR(&&DSN&J)) = &STR(') THEN DO\n       SET DSN = &SUBSTR(2:&EVAL(&LENGTH(&DSN)-1),&STR(&DSN))\n    END\n    IF &STR(&DSN) ^= &STR() THEN DO\n       SET RCX = &RCX + 1\n       SET XDSN&RCX = &STR(&DSN)\n    END\n    SET J = &J + 1\n END\n /* ---- HAVE OBTAINED ALL DSNAMES NOW DO CHECKING------------------ */\n /* ---- UTILIZING CODE ESSENTIALLY BORROWED FROM THE BROWSE CLIST - */\n SET I = 1\n IF &EVAL(&RCX) = &EVAL(0) THEN DO\n    WRITE &STR()\n    WRITE &STR()\n    WRITE DDNAME OF \"&DDNAME.\" DOES NOT EXIST  +\n          USE CORRECT FORM AS BELOW\n    WRITE ===> TSO PDSDD DDNAME MEMBERNAME    <--- FORMAT\n    WRITE ===> TSO PDSDD   CLIST|MESSAGE|PANELS|PROFILE|SKELETON+\n          HELP &MEMBER.\n    WRITE ===> TSO PDSDD SYSPROC|ISPMLIB|ISPPLIB|ISPTLIB|ISPSLIB+\n          SYSHELP &MEMBER.\n    WRITE ===> TSO PDSDD SYSPROC CLIST   (ALL)\n END\n DO WHILE &I <= &RCX.\n    SET RDSN = '&STR(&&XDSN&I)'\n    SET DSN =  '&STR(&&XDSN&I(&MEMBER.))'\n    IF &MULTIMEM. = 0 THEN +\n       SET CHK =  &STR(&SYSDSN(&DSN))\n       ELSE SET CHK =  &STR(&SYSDSN(&RDSN))\n    SET CHK&I = &STR(&CHK)\n    SET CC1 = &LASTCC\n    IF &STR(&CHK.) = OK THEN DO\n       /*  ------- MAKE AVAILABLE TO OTHER CLISTS --------*/\n       ISPEXEC     VPUT DSN SHARED\n       ISPEXEC     VPUT RDSN SHARED\n       /*  ------- TRAP SYSOUT FOR RACF CHECKING ---------*/\n       SET SYSOUTTRAP = 100\n       LD DATASET(&RDSN)\n       SET SYSOUTTRAP = 0\n       SET N = &SYSOUTLINE\n       IF &SUBSTR(1:3,&STR(&SYSOUTLINE1.)       ) = ICH THEN -\n           IF &SUBSTR(1:8,&STR(&SYSOUTLINE1.)       ) ^= ICH35003  +\n           THEN DO\n                SET &ZEDSMSG = &STR(NOT AUTHORIZED)\n                SET &ZEDLMSG = &STR(&SYSOUTLINE1.) &STR(-- HIT +\n                    ENTER NOT PFK-3)\n    ISPEXEC     SETMSG MSG(ISRZ000)\n                WRITE &ZEDLMSG.\n                SET CHK&I = &STR(&DSN NOT AUTHORIZED TO RACF --  )\n                GOTO BYBROW\n            END\n       /*  ------- DATASET EXITS AND RACF S/B HAPPY ------*/\n       IF &I <= &HRC THEN DO    /* CHECK HI-WATER MARK */\n             SET VSTSRVTI = &STR(&DSN.)\nISPEXEC      VPUT (VSTSRVTI) SHARED\n             SET DSNDESC = &STR(TSO CLIST -- PDSDD &DDNAME +\n                  &MEMBER &ALL)\nISPEXEC      VPUT (DSNDESC) SHARED\n             /*  ------- MAKE AVAILABLE TO OTHER CLISTS --------*/\n             ISPEXEC     VPUT DSN SHARED\n             ISPEXEC     VPUT RDSN SHARED\n             IF &MULTIMEM ^= 0 THEN ISPEXEC CONTROL ERRORS RETURN\n             IF NB ^= &NB THEN +\n             IF EDIT ^= &EDIT +\n               THEN ISPEXEC BROWSE DATASET(&STR(&DSN.)) PANEL(SYSBROB2)\n               ELSE ISPEXEC EDIT   DATASET(&STR(&DSN.))\n       END\nBYBROW: SET KK = 0\n   END\n   IF &STR(&&CHK&I) =  THEN -\n      SET CHK&EVAL(&I) = &STR(&CHK)\n/*     SET CHK&EVAL(&I) = &STR(&CHK)\n   SET I = &I + 1\nEND\n/* ---------------------------------------------------------------- */\nSET RDSN =\nISPEXEC     VPUT RDSN SHARED\nSET DSN =\nISPEXEC     VPUT DSN SHARED\nSET VSTSRVTI =\nISPEXEC  VPUT (VSTSRVTI) SHARED\n/* -------------------------------------------------------------- */\nSET I = 1\nIF &STR(&DDNAME) ^= &STR(&DDNAMEX) THEN DO\n     WRITE SUMMARY ----------------- PDSDD &STR(&DDNAME) +\n           &MEMBER &ALL &NB DSN1() DSN2()\n     WRITE   ENTERED AS ----===> TSO PDSDD &STR(&DDNAMEX) +\n           &MEMBER &ALL &NB\nEND\nELSE WRITE SUMMARY -------- ===> TSO PDSDD &DDNAME &MEMBER &ALL &NB\nWRITE AS DETERMINED &SYSDATE. &SYSTIME. +\n      FOR &SYSUID. USING PROC=&SYSPROC.\nSET STR44 = &STR(............................................)\nDO WHILE &I <= &RCX\n   IF &I = &EVAL(&HRC + 1) | &I = &EVAL(&DRC + 1) THEN DO\n      IF &I = &EVAL(&DRC + 1) THEN -\n           WRITE ------------ NO BROWSE BELOW THIS LINE +\n              -- DSN1(&DSN1) DSN2()  ETC.\n      ELSE WRITE ------------ NO BROWSE BELOW THIS LINE +\n        -- FOR DATASETS IN COMBINED LIBRARIES\n   END\n   SET DSN = '&STR(&&XDSN&I(&MEMBER.))'\n   SET CHK =  &STR(&&CHK&I)\n   IF &I < 10 THEN WRITE &STR(0&I) +\n      &SUBSTR(1:44,&STR(&STR(&DSN) &STR(&STR44))) &CHK.\n   ELSE             WRITE &STR(&I) +\n      &SUBSTR(1:44,&STR(&STR(&DSN) &STR(&STR44))) &CHK.\n   SET I = &I + 1\nEND\nSET DSN =\nSET XDSN =\nISPEXEC     VPUT DSN SHARED\nISPEXEC     VPUT RDSN SHARED\n/* ----+++ */\n/* NOTES   THE CLISTS   \"CLIST\" AND \"PANELS\"  WILL WORK FASTER THAN THE\n/*  PDSDD CLIST HOWEVER THE FASTER CLISTS SPECIFY WHICH DSNAMES ARE TO\n/*  BE USED, THE LIST OF DSNAMES CAN BE UPDATED WITH THE HELP OF THE\n/*  CLIST  @STRAPD\n/*    E.G.    ==> @STRAPD SYSPROC          WHERE SYSPROC IS THE DDNAME\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PERIOD": {"ttr": 11523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00$\\x00$\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "MCRITCH"}, "text": " /*REXX*/\n /*  TITLE:  PERIOD -- CHANGE (\") TO USE OF :Q...:EQ. FOR SCRIPT TEXT*/\n /*  USERS:       TSO ISPF EDIT USERS   | SCRIPT USERS               */\n /*  CONTRIBUTED: 1987/01/20 DAVID MCRITCHIE                         */\n /*                CONVERTED TO REXX 1993/05/19                      */\n /*  EXAMPLE:     PERIOD                                             */\n /*                                                                  */\n /*  OPTIONS:                                                        */\n /*      COL1 COL2  .LABEL1 .LABEL2  NX                              */\n /*      NX   CANNOT BE USED WITH OTHER OPTIONS                      */\n ADDRESS \"ISREDIT\";\"MACRO (RANGE)\"\n /* SCRIPT CONVERSION TO PAGE USAGE -- D.MCR */\n SYSTIME = SUBSTR(TIME('N'),1,8)\n \"SEEK FIRST       P'<$ ><'\"\n \"(LICNT1S,LICNT2L) = SEEK_COUNTS\"\n IF LICNT1S  = 0  THEN DO\n    \"SEEK FIRST       P'>>$ ><'\"\n    \"(LICNT1S,LICNT2L) = SEEK_COUNTS\"\n    IF LICNT1S  =  0 THEN DO\n       \"LINE_BEFORE .ZF = NOTELINE \"\"\"SYSTIME ,\n           \"PERIOD -- NOT FOUND -- P'<$ ><' NOR P'>>$ ><'\"\"\"\n       EXIT 0\n    END\n END\n IF RANGE = '' THEN RANGE = '.ZF .ZL'\n \"X ALL\" RANGE\n \"F ALL\" RANGE \"C'.. T'\"\n \"F ALL\" RANGE \"C'. Th'\"  /* MUST BE A LOWERCASE H */\n \"F ALL\" RANGE \"P'$ $HP#$TH'\"\n \"F ALL\" RANGE \"P'#$ ><'\"\n \"F ALL\" RANGE \"P'<$ ><'\"\n \"F ALL\" RANGE \"P'<$ A '\"\n \"(IMACRO) = IMACRO\"\n \"LOC 0\"\n \"LINE_BEFORE .ZF = NOTELINE \"\"\"SYSTIME ,\n      \"PERIOD -- FOUND -- P'<$ ><'   OR  P'>>$ <>'\"\"\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PINX": {"ttr": 11525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xf7\\x00\\xf7\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 247, "newlines": 247, "modlines": 0, "user": "MCRITCH"}, "text": "/*********************************************************************/\n/* PINX      Author: David McRitchie, created 1986/05/10 IS03        */\n/*           at \"The REXX Macros Toolbox\", DMcRitchie@aol.com    */\n/*           Updated 1989/01/30 22:03 IS03                           */\n/*********************************************************************/\n/* TITLE:       PINX, CREATE \".PI\" FROM NX LINES                     */\n/* USERS:       TSO ISPF EDIT USERS   | SCRIPT USERS                 */\n/*                 .ADDRA .ADDRB COPY THE CONTENT OF .ADDRC .ADDRD   */\n/* CONTRIBUTED: 1986/05/10 DAVID MCRITCHIE                           */\n/*                                                                   */\n/* EXAMPLE:     PINX    .A .B                                        */\n/*                                                                   */\n/* DOCUMENTED:  IS03.SHARE.TEXT(PINX)                                */\n/*              IS03.CLISTHLP.HELP(PINX)                             */\n/*                                                                   */\n/* OPTIONS:                                                          */\n/*     LPTR-DEST-RANGE | ENTIRE   (REQUIRED) LINE POINTER RANGE      */\n/*     LPTR-SOURCE-PAIR | MEMBERNAME         MATERIAL TO BE COPIED   */\n/*     NX | X  (OPTIONAL)  PROCESS ALL, OR NON-EXCLUDED, OR EXCLUDED */\n/*                 lines APPLIES TO THE LPTR-DEST-RANGE  ONLY        */\n/*                                                                   */\n/*********************************************************************/\n            CONTROL ASIS\n ISREDIT  MACRO PROCESS (TOK1,TOK2,K2,TOK3,TOK4,TOK5,TOK6,TOK7,+\n           TOK8,TOK9,TOK10,+\n           TOK11,TOK12,TOK13,TOK14,TOK15,TOK16,TOK17,TOK18,TOK19,+\n           TOK20,TOK21,TOK22,TOK23,TOK24,TOK25,TOK26,TOK27,TOK28,+\n           TOK29,TOK30,TOK31,TOK32,TOK33,TOK34,TOK35,TOK36,TOK37,+\n           TOK38,TOK39,TOK40,TOK41,TOK42,TOK43,TOK44,TOK45,TOK46)\n        SET RP = &STR())\n        SET I = 0\n        /*********\n        SET I = 1\n       DO WHILE &I <= 48\n        SET TOKEN = &&TOK&I\n        SET TOKEN = &STR(&SYSCAPS(&TOKEN))\n        IF &STR(&TOKEN) = RERUN THEN SET RERUN = RERUN\n        IF &STR(&TOKEN) = DONE  THEN SET DONED = DONE\n        IF &STR(&TOKEN) = HOLD  THEN SET HOLD  = HOLD\n        IF DEBUG = &DEBUG | DEBUG = &TOKEN THEN +\n           WRITE  &I  TOK&&I=&&TOK&I  TOKEN=&TOKEN\n        IF &STR(&TOKEN) = &STR() THEN GOTO END_TOK\n        IF &SUBSTR(1,&TOKEN) = &STR(.) THEN DO\n           IF &LABF. = &STR() THEN DO\n              SET LABF = &STR(&TOKEN)\n              GOTO NXT_TOK\n           END\n           IF &STR(&LABL) = &STR() THEN DO\n              SET LABL = &STR(&TOKEN)\n              GOTO NXT_TOK\n           END\n          SET &ZEDSMSG = &STR(LABEL &STR(&TOKEN))\n          SET &ZEDLMSG = &STR(EXACTLY 2 LABELS +\n          REQUIRED FOUND   \"&LABF\", \"&LABL\" AND  \"&STR(&TOKEN)\")\n          ISPEXEC   SETMSG MSG(ISRZ000)\n          EXIT CODE(12)\n        END\n        SET REMAIN = &STR(&REMAIN &STR(&TOKEN))\n NXT_TOK: -\n        SET I = &I + 1\n      END\n END_TOK: SET I = &I\n/*********************************************************************/\n/*********************************************************************/\n        IF &LABF. = &STR() THEN DO\n           SET LABF = .ZFIRST\n           SET LABL = .ZLAST\n        END\n        IF &LABL. = &STR() THEN DO\n              SET &ZEDSMSG = MISSING LABEL(S)\n              SET &ZEDLMSG = &STR(&ZEDSMSG -- TWO +\n              LABELS AND MEMBER, OR 4 LABELS ARE REQUIRED)\n              ISPEXEC     SETMSG MSG(ISRZ000)\n              EXIT CODE(12)\n        END\n        ISREDIT (#LABF) = LINENUM &LABF.\n        IF &LASTCC ^= 0 THEN DO\n                   SET &ZEDSMSG = &STR(&LABF. LABEL)\n                   SET &ZEDLMSG = &STR(&ZEDSMSG DOES NOT EXIST)\n                   ISPEXEC     SETMSG MSG(ISRZ000)\n                   EXIT CODE(12)\n        END\n        ISREDIT (#LABL) = LINENUM &LABL.\n        IF &LASTCC ^= 0 THEN DO\n                   SET &ZEDSMSG = &STR(&LABL. LABEL)\n                   SET &ZEDLMSG = &STR(&ZEDSMSG DOES NOT EXIST)\n                   ISPEXEC     SETMSG MSG(ISRZ000)\n                   EXIT CODE(12)\n        END\n        IF &STR(&REPRO) ^= &STR() THEN GOTO JJJ\n        /*********** END OF LABEL REQUIREMENTS **********************/\n        /*********** CODE FOR  LINE SHIFT COMMANDS ***************/\n        /*********** CODE FOR  LINE SHIFT COMMANDS ***************/\n        /*********** CODE FOR  LINE SHIFT COMMANDS ***************/\n        ISREDIT SEEK X'49' &LABF. &LABL. FIRST\n        IF &LASTCC = 0 THEN GOTO CHKDEST\n        ISREDIT SEEK X'48' &LABF. &LABL. FIRST\n        IF &LASTCC = 0 THEN GOTO CHKDEST\n        ISREDIT SEEK X'47' &LABF. &LABL. FIRST\n        IF &LASTCC = 0 THEN GOTO CHKDEST\n        ISREDIT SEEK X'46' &LABF. &LABL. FIRST\n        IF &LASTCC = 0 THEN GOTO CHKDEST\n        ISREDIT SEEK X'45' &LABF. &LABL. FIRST\n        IF &LASTCC = 0 THEN GOTO CHKDEST\n        GOTO DESTOK\n CHKDEST: WRITE WARNING X'45'-X'49' FOUND IN DATA\n        IF &STR(&RERUN) = RERUN THEN DO\n           WRITE RERUN WAS REQUESTED -- WILL CONTINUE\n        END\n        ELSE DO\n          WRITE A RERUN IS DONE  ===> PINX .LABF .LABL RERUN\n          WRITE RERUN NOT REQUESTED -- ABORTING\n          SET &ZEDSMSG = &STR(NOT A RERUN)\n          SET &ZEDLMSG = &STR(TO RERUN INCLUDE \"RERUN\" ON PINX COMMAND)\n          ISPEXEC     SETMSG MSG(ISRZ000)\n          EXIT CODE(12)\n        END\n        /*************** PERMITTED TO CONTINUE *********************/\n  DESTOK: -\n        IF &STR(&DONED) = DONE THEN GOTO DONE\n        ISREDIT SEEK   &LABF. &LABL. ' ' NX FIRST\n        ISREDIT (I) = LINENUM .ZCSR\n        ISREDIT (LN1) = LINE .ZCSR\n        WRITE &I -- &LN1.\n        ISREDIT CHANGE all nx &LABF. &LABL. '&&' X'49'\n        ISREDIT CHANGE all nx &LABF. &LABL. \"'\"  X'48'\n        ISREDIT CHANGE all nx &LABF. &LABL. '\"'  X'47'\n  BACK:  -\n        ISREDIT (LN1) = LINE .ZCSR\n        IF &STR(&SYSCAPS(&SUBSTR(1:4,&STR(&LN1)))) = +\n             &STR(.PI ) THEN GOTO NXT\n        IF &STR(&SYSCAPS(&SUBSTR(1:8,&STR(&LN1)))) = +\n             &STR(.*--.PI ) THEN GOTO NXT\n        SET LN3 = &STR(.PI \u00f8&STR(&LN1.))\n        SET LN1 = &STR(.*--.PI \u00f8&STR(&LN1.))\n        ISREDIT (LN2) = LINE &EVAL(&I + 1)\n /*     IF &STR(&SYSCAPS(&STR(&LN1))) = &STR(+\n      &SYSCAPS(&STR(&LN2))) THEN GOTO NXT\n /*     IF &STR(&SYSCAPS(&STR(&LN2))) = &STR(+\n      &SYSCAPS(&STR(&LN3))) THEN GOTO NXT\n        ISREDIT SEEK FIRST .ZCSR .ZCSR '\"'\n        IF &LASTCC = 0 THEN ISREDIT LINE_AFTER .ZCSR = \"&NRSTR(&LN1.)\"\n                       ELSE ISREDIT LINE_AFTER .ZCSR = '&NRSTR(&LN1.)'\n        SET I = &I + 1\n  NXT: -\n        ISREDIT (LAST) = LINENUM &LABL.\n        SET I = &I + 1\n        IF &EVAL(1000000 + &I ) >= &EVAL(1000000 + &LAST) +\n             THEN GOTO DONE\n        ISREDIT LABEL &I = .PTR\n        ISREDIT SEEK   .PTR   &LABL. ' ' NX FIRST\n        IF &LASTCC ^= 0 THEN GOTO DONE\n        ISREDIT (XSTATUS) = XSTATUS &I\n        ISREDIT (I) = LINENUM .ZCSR\n        IF &LASTCC = 0 THEN GOTO BACK\n   DONE: -\n        ISREDIT CHANGE all nx '\u00f8&&&&rbl.' ' '\n        ISREDIT CHANGE all nx &LABF. &LABL. X'49' '&&'\n        ISREDIT CHANGE all nx &LABF. &LABL. X'48' \"'\"\n        ISREDIT CHANGE all nx &LABF. &LABL. X'47' '\"'\n        IF &STR(&HOLD) = HOLD THEN EXIT CODE(0)\n        ISREDIT X ALL    &LABF. &LABL.\n        ISREDIT F ALL    &LABF. &LABL. 1 '.*--.PI '\n        ISREDIT CHANGE all nx &LABF. &LABL. ':P ' '\u00f8'\n        ISREDIT CHANGE all nx &LABF. &LABL. ':P.' '\u00f8'\n        ISREDIT CHANGE all nx &LABF. &LABL. ':LI.' '\u00f8'\n        ISREDIT CHANGE all nx &LABF. &LABL. ':GB12.' '\u00f8'\n        ISREDIT CHANGE all nx &LABF. &LABL. ':GP12.' '\u00f8'\n        ISREDIT CHANGE all nx &LABF. &LABL. ':GT12.' '\u00f8'\n        ISREDIT CHANGE all nx &LABF. &LABL. ':GT15.' '\u00f8'\n        ISREDIT CHANGE all nx &LABF. &LABL. ':HP0.' '\u00f8'\n        ISREDIT CHANGE all nx &LABF. &LABL. ':HP1.' '\u00f8'\n        ISREDIT CHANGE all nx &LABF. &LABL. ':HP2.' '\u00f8'\n        ISREDIT CHANGE all nx &LABF. &LABL. ':HP3.' '\u00f8'\n        ISREDIT CHANGE all nx &LABF. &LABL. ':EGB12.' '\u00f8'\n        ISREDIT CHANGE all nx &LABF. &LABL. ':EGP12.' '\u00f8'\n        ISREDIT CHANGE all nx &LABF. &LABL. ':EGT12.' '\u00f8'\n        ISREDIT CHANGE all nx &LABF. &LABL. ':EGT15.' '\u00f8'\n        ISREDIT CHANGE all nx &LABF. &LABL. ':EHP0.' '\u00f8'\n        ISREDIT CHANGE all nx &LABF. &LABL. ':EHP1.' '\u00f8'\n        ISREDIT CHANGE all nx &LABF. &LABL. ':EHP2.' '\u00f8'\n        ISREDIT CHANGE all nx &LABF. &LABL. ':EHP3.' '\u00f8'\n        ISREDIT CHANGE all nx &LABF. &LABL. \"^\" \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. \";\" \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. \".sk 0\" \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. \".sk 1\" \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. \".sp 0\" \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. \".sp 1\" \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. \" - \" \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. \":HDREFID REFID='\" \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. \"'.\" \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. \"' \" \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. \" '\" \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. '\" ' \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. ' \"' \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. ':H3.' ''\n        ISREDIT CHANGE all nx &LABF. &LABL. ':H2.' ''\n        ISREDIT CHANGE all nx &LABF. &LABL. ':H1.' ''\n        ISREDIT CHANGE all nx &LABF. &LABL. ':H0.' ''\n        ISREDIT CHANGE all nx &LABF. &LABL. \":H3 ID='\" \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. \":H2 ID='\" \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. \":H1 ID='\" \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. \":H0 ID='\" \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. \"\u00f8\u00f8\u00f8\u00f8\" \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. \"\u00f8\u00f8\" \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. \"\u00f8\u00f8\" \"\u00f8\"\n        ISREDIT F      all nx &LABF. &LABL. ':H'\n        ISREDIT F      all nx &LABF. &LABL. '.PI '\n        ISREDIT CHANGE all nx &LABF. &LABL. 1 70 X'40'   X'46'\n        ISREDIT CHANGE all nx &LABF. &LABL. +\n             1 70 X'46464646464646464646464646464646' X'46'\n        ISREDIT CHANGE all nx &LABF. &LABL. +\n             1 70 X'4646464646464646' X'46'\n        ISREDIT CHANGE all nx &LABF. &LABL. 1 70 X'464646' X'46'\n        ISREDIT CHANGE all nx &LABF. &LABL. 1 70 X'4646' X'46'\n        ISREDIT CHANGE all nx &LABF. &LABL. 1 70 X'4646' X'46'\n        ISREDIT CHANGE all nx &LABF. &LABL. 1 70 X'4646' X'46'\n        ISREDIT CHANGE all nx &LABF. &LABL. 1 70 X'4646' X'46'\n        ISREDIT CHANGE all nx &LABF. &LABL. 1 70 X'4646' X'46'\n        ISREDIT CHANGE all nx &LABF. &LABL. 1 70 X'4646' X'46'\n        ISREDIT CHANGE all nx &LABF. &LABL. 1 70 X'4646' X'46'\n        ISREDIT CHANGE all nx &LABF. &LABL. 1 70 X'6A46' X'6A'\n        ISREDIT CHANGE all nx &LABF. &LABL. 1 70 X'466A' X'6A'\n        ISREDIT CHANGE all nx &LABF. &LABL. 1 70 X'46'   X'40'\n        ISREDIT CHANGE all nx '/' '\u00f8'\n        ISREDIT CHANGE all nx '.*--.pi\u00f8' '.pi \u00f8'\n        ISREDIT CHANGE all nx '.*--.pi \u00f8' '.pi \u00f8'\n        ISREDIT CHANGE all nx '&&&&gml. ' '\u00f8'\n        ISREDIT CHANGE all nx '&&&&gml.' '\u00f8'\n        ISREDIT CHANGE all nx ': ' '\u00f8'\n  /*    ISREDIT CHANGE all nx ':' '\u00f8'\n        ISREDIT CHANGE all nx ' alarm ' '\u00f8alarm '\n        ISREDIT CHANGE all nx '\u00f8alarm ' '\u00f8alarm\u00f8'\n        ISREDIT CHANGE all nx '\u00f8detection +\n             circuit ' '\u00f8detection\u00f8circuit '\n        ISREDIT CHANGE all nx '\u00f83084 ' '3084\u00f8'\n        ISREDIT CHANGE all nx '\u00f84361 ' '4361\u00f8'\n        ISREDIT CHANGE all nx ' &&&& ' 'and '\n        ISREDIT CHANGE all nx '&&&&rbl.' ' '\n        ISREDIT CHANGE all nx &LABF. &LABL. \"\u00f8\u00f8\" \"\u00f8\"\n        ISREDIT CHANGE all nx &LABF. &LABL. \"\u00f8\u00f8\" \"\u00f8\"\n        ISREDIT RESET         &LABF. &LABL. CHANGE\n DONE2: ISREDIT FIND FIRST NX &LABF. &LABL. \".PI \u00f8                \"\n        IF &LASTCC. EQ 0 THEN DO\n           ISREDIT DELETE .ZCSR .ZCSR\n           GOTO DONE2\n        END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PINXDOIT": {"ttr": 11530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xc4\\x00\\xc4\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 196, "newlines": 196, "modlines": 0, "user": "MCRITCH"}, "text": "   CONTROL ASIS\n /*  TITLE:       PINXDOIT  make up .PI entries from scratch\n /*  USERS:       TSO ISPF EDIT USERS   | SCRIPT USERS               */\n /*  CONTRIBUTED: 1986/05/10 DAVID MCRITCHIE                         */\n /*                                                                  */\n /*  EXAMPLE:     PINXDOIT  BASE                                     */\n /*                                                                  */\n /*  DOCUMENTED:  IS03.SHARE.TEXT(PINXDOIT)                          */\n /*                                                                  */\n /*  OPTIONS:                                                        */\n /*    There are no label options,                                   */\n /*        this clist will process all NX lines.                    */\n /*\n /*  1)  BASE  -- start from scratch\n /*               '.pi /' changed to '.pi \u00f8'\n /*               f all ':h'\n /*               PINX     CLIST IS INVOKED\n /*  2)  START -- Make '.*--.PI\u00f8' entries active\n /*               make appropriate changes to &GML.  &  appearing in NX entries\n /*               Capitalize first letter after \"\u00f8\"\n\n /*  3)  REDO  -- default\n /*  4)  You are ready/not ready to use PIR\n ISREDIT MACRO (OPTION)\n    IF &SYSCAPS(&STR(&OPTION)) = BASE   THEN GOTO BASE\n    ISREDIT SEEK FIRST X ' '\n    IF &LASTCC ^= 0 THEN DO\n          SET &ZEDSMSG = &STR(PINXDOIT NX ONLY)\n          SET RP = &STR())\n          SET &ZEDLMSG = &STR(NOT SET UP FOR CREATING \".PI\" READ IS03.SHARE.TEXT\n          ISPEXEC     SETMSG MSG(ISRZ000)\n          EXIT CODE(12)\n    END\n    IF &SYSCAPS(&STR(&OPTION)) = &STR() THEN GOTO REDO\n    IF &SYSCAPS(&STR(&OPTION)) = REDO   THEN GOTO REDO\n    IF &SYSCAPS(&STR(&OPTION)) = START  THEN GOTO START\n    GOTO REDO\n /*  This code will normally be bypassed *******/\n BASE: -\n ISREDIT x all\n ISREDIT f '.pi /' 1 all\n ISREDIT c all nx '/' '\u00f8'\n ISREDIT x all\n ISREDIT f ':h' all\n ISREDIT PINX\n START: -\n ISREDIT x 1 ':' all\n ISREDIT c all nx '/' '\u00f8'\n ISREDIT c all nx '.*--.pi\u00f8' '.pi \u00f8'\n ISREDIT c all nx '.*--.pi \u00f8' '.pi \u00f8'\n ISREDIT c all nx '&&&&gml. ' '\u00f8'\n ISREDIT c all nx '&&&&gml.' '\u00f8'\n ISREDIT c all nx ': ' '\u00f8'\n ISREDIT c all nx ':' '\u00f8'\n ISREDIT c all nx ' alarm ' '\u00f8alarm '\n ISREDIT c all nx '\u00f8alarm ' '\u00f8alarm\u00f8'\n ISREDIT c all nx '\u00f8detection circuit '  '\u00f8detection\u00f8circuit '\n ISREDIT c all nx '\u00f83084 ' '3084\u00f8'\n ISREDIT c all nx '\u00f84361 ' '4361\u00f8'\n ISREDIT c all nx ' &&&& ' 'and '\n     ISREDIT CHANGE all nx word  'AHC'        AHC\n     ISREDIT CAPS OFF\n     /* proper names\n     ISREDIT CHANGE all nx '\u00f8a' '\u00f8A'\n     ISREDIT CHANGE all nx '\u00f8b' '\u00f8B'\n     ISREDIT CHANGE all nx '\u00f8c' '\u00f8C'\n     ISREDIT CHANGE all nx '\u00f8d' '\u00f8D'\n     ISREDIT CHANGE all nx '\u00f8e' '\u00f8E'\n     ISREDIT CHANGE all nx '\u00f8f' '\u00f8F'\n     ISREDIT CHANGE all nx '\u00f8g' '\u00f8G'\n     ISREDIT CHANGE all nx '\u00f8h' '\u00f8H'\n     ISREDIT CHANGE all nx '\u00f8i' '\u00f8I'\n     ISREDIT CHANGE all nx '\u00f8j' '\u00f8J'\n     ISREDIT CHANGE all nx '\u00f8k' '\u00f8K'\n     ISREDIT CHANGE all nx '\u00f8l' '\u00f8L'\n     ISREDIT CHANGE all nx '\u00f8m' '\u00f8M'\n     ISREDIT CHANGE all nx '\u00f8n' '\u00f8N'\n     ISREDIT CHANGE all nx '\u00f8o' '\u00f8O'\n     ISREDIT CHANGE all nx '\u00f8p' '\u00f8P'\n     ISREDIT CHANGE all nx '\u00f8q' '\u00f8Q'\n     ISREDIT CHANGE all nx '\u00f8r' '\u00f8R'\n     ISREDIT CHANGE all nx '\u00f8s' '\u00f8S'\n     ISREDIT CHANGE all nx '\u00f8t' '\u00f8T'\n     ISREDIT CHANGE all nx '\u00f8u' '\u00f8U'\n     ISREDIT CHANGE all nx '\u00f8v' '\u00f8V'\n     ISREDIT CHANGE all nx '\u00f8w' '\u00f8W'\n     ISREDIT CHANGE all nx '\u00f8x' '\u00f8X'\n     ISREDIT CHANGE all nx '\u00f8y' '\u00f8Y'\n     ISREDIT CHANGE all nx '\u00f8z' '\u00f8Z'\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'ahc'        AHC\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'american'   'American'\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'autotab'    AUTOTAB\n\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'corporation' 'Corporation'\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'dave'       'Dave'\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'david'      'David'\n\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'john'       'John'\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'mcritchie'  'McRitchie'\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'new jersey' 'New Jersey'\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'os'         'OS'\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'nj'         'NJ'\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'scharwath'  'Scharwath'\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'virginia'   'Virginia'\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'wind'       'Wind'\n    /* JCL and other terms for complete capitalization\n    /*that do not interfer with other usages e.g. does not include SPACE\n     ISREDIT CHANGE all nx prefix &LABF. &LABL. 'ahiv2'      AHIV2\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'autotab'    AUTOTAB\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'blksiz'     BLKSIZ\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'cyl'        CYL\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'dasd'       DASD\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'dms'        DMS\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'dcb'        DCB\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'fb'         FB\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'fbs'        FBS\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'ibm'        IBM\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'ims'        IMS\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'ifps'       IFPS\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'jcl'        JCL\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'jes'        JES\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'mvs/xa'     'MVS/XA'\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'mvs'        MVS\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'pcms'       PCMS\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'p.c.m.s'    P.C.M.S\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'pdf'        PDF\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'pds'        PDS\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'recfm'      RECFM\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'sas'        SAS\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'smf'        SMF\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'smp'        SMP\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'trk'        TRK\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'tlms'       TLMS\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'tso'        TSO\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'vb'         VB\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'vbs'        VBS\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'vspc'       VSPC\n     ISREDIT CHANGE all nx word &LABF. &LABL. 'xa'         XA\n     ISREDIT CHANGE all nx word &LABF. &LABL. t'tsomodel.public' c'TSOMODEL.PUBL\n     ISREDIT CHANGE all nx &LABF. &LABL. 'info0' 'INFO0'\n     /* Sentence beginning -- period - two spaces - letter\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  a' '.  A'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  b' '.  B'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  c' '.  C'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  d' '.  D'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  e' '.  E'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  f' '.  F'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  g' '.  G'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  h' '.  H'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  i' '.  I'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  j' '.  J'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  k' '.  K'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  l' '.  L'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  m' '.  M'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  n' '.  N'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  o' '.  O'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  p' '.  P'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  q' '.  Q'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  r' '.  R'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  s' '.  S'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  t' '.  T'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  u' '.  U'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  v' '.  V'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  w' '.  W'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  x' '.  X'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  y' '.  Y'\n     ISREDIT CHANGE all nx &LABF. &LABL. '.  z' '.  Z'\n     ISREDIT CHANGE ALL NX &LABF. &LABL. '\u00f8\u00f8' '\u00f8'\n     ISREDIT CHANGE ALL NX &LABF. &LABL. '\u00f8\u00f8' '\u00f8'\n  REDO: -\n ISREDIT F all nx \"*\"\n         IF &LASTCC = 0 THEN GOTO NOTYET\n ISREDIT F all nx \"/\"\n         IF &LASTCC = 0 THEN GOTO NOTYET\n ISREDIT F all nx \"+\"\n         IF &LASTCC = 0 THEN GOTO NOTYET\n ISREDIT F all nx \"-\"\n         IF &LASTCC = 0 THEN GOTO NOTYET\n ISREDIT F all nx \"&&&&\"\n         IF &LASTCC = 0 THEN GOTO NOTYET\n ISREDIT F all nx \"'\"\n         IF &LASTCC = 0 THEN GOTO NOTYET\n ISREDIT F all nx \":\"\n         IF &LASTCC = 0 THEN GOTO NOTYET\n ISREDIT F all nx '\"'\n         IF &LASTCC = 0 THEN GOTO NOTYET\n     SET &ZEDSMSG = &STR(DATA READY FOR PIR)\n     SET &ZEDLMSG = &STR(No Arithmetic symbols, or \":\" left in DISPLAY)\n     ISPEXEC     SETMSG MSG(ISRZ000)\n     EXIT CODE(0)\n   NOTYET: -\n     SET I = 1\n     SET &ZEDSMSG = &STR(Fix Data/RFIND)\n     SET &ZEDLMSG = &STR(ARITHMETIC SYMBOLS, or \":\" exit in DISPLAY)\n     ISPEXEC     SETMSG MSG(ISRZ000)\n     EXIT CODE(4)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PIR": {"ttr": 11534, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01!\\x01!\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 289, "newlines": 289, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- converted to REXX on 1994/06/03 */\nADDRESS \"ISREDIT\"\n/*********************************************************************/\n/*  PIR       AUTHOR: DAVID MCRITCHIE, CREATED 1986/09/11 IS03       */\n/*            AT \"The REXX Macros Toolbox\", DMcRitchie@aol.com    */\n/*            UPDATED 1992/02/22 20:48 IS03                          */\n/*********************************************************************/\n/*  TITLE:       PIR     \"PUT INDEX ROTATION\" FOR SCRIPT DOCUMENTS   */\n/*  USERS:       TSO ISPF EDIT USERS   | SCRIPT USERS                */\n/*  CONTRIBUTED: 1986/09/11 DAVID MCRITCHIE                          */\n/*  DOCUMENTED:  IS03.SHARE.TEXT(PIR)                                */\n/*                                                                   */\n/*   SUGGEST USE OF PIR CLIST AFTER USE OF  PINX CLIST               */\n/*                                                                   */\n/*   EXAMPLES -- WARNING SEQUENCE NUMBERS COULD FOUL YOU UP          */\n/*      001 :H2.HALON EXTINGUISHERS SET CURSOR                       */\n/*                    _                    PKF SET TO   PIR AT       */\n/*      001 .PI \u00f8EXTINGUISHERS             <-- RESULT                */\n/*      ********************************************************     */\n/*      002 .PI \u00f8HALON FIRE EXTINGUISHER                             */\n/*                          _              PKF SET TO   PIR          */\n/*      002 .PI \u00f8EXTINGUISHER\u00f8HALON FIRE   <-- RESULT                */\n/*      002 .PI \u00f8EXTINGUISHER, HALON FIRE   <-- MIGHT CHANGE TO      */\n/*      ********************************************************     */\n/*                                                                   */\n/*  OPTIONS:                                                         */\n/*            SUGGEST PF13  PIR AT                                   */\n/*            SUGGEST PF14  PIR                                      */\n/*            SUGGEST PF16  PIR S                                    */\n/*  PIR AT --  MAKE A \".PI \" FROM THIS POINT OF LINE,                */\n/*  PIR    --<<DEFAULT>>  ROTATE THE \".PI \" AT THE CURSOR            */\n/*  PIR R  --<<DEFAULT>>  ROTATE THE \".PI \" AT THE CURSOR            */\n/*  PIR S  -- SWAP FIRST TWO NODES    OF \".PI \"                      */\n/*                                                                   */\n/*  INTERNAL ASPECTS:                                                */\n/*    Continues to use EDIT instructions instead of manipulating     */\n/*      within the REXX language, because directly converted from    */\n/*      a clist macro where it would have been very difficult to     */\n/*      manipulate strings within a clist.                           */\n/*                                                                   */\n/*  SUGGESTED IMPLEMENTATION AFTER USE OF CLIST  PINX                */\n/*    C ALL '.*--PI ' '.PI ' NX                                      */\n/*    X ALL                                                          */\n/*    F '.PI /'                                                      */\n/*    C ALL NX '/' '\u00f8'                                               */\n/*                                                                   */\n/*    KEYS                                                           */\n/*     13  PIR AT          CREATES A \".PI \" FROM POS. CURSOR IS AT   */\n/*     14  PIR             ROTATES \".PI \" FROM POS. OF CURSOR        */\n/*     15  * ***pfk15***   WARNING THAT PFKEYS ARE CHANGED (not PF3) */\n/*     16  PIR S           SWAP FIRST TWO NODES OF \".PI\"             */\n/*     17  FIND 7 80 '\u00f8' NX;PIR S;F .PI;F .PI                        */\n/*                                                                   */\n/*                                                                   */\n/*  THIS CLIST CANNOT HANDLE ARITHMETIC OPERATORS WITHIN DATA        */\n/*  USED TO CREATE A NEW \".PI \".    E.G.   / * - ,                   */\n/*                                                                   */\n/*                                                                   */\n/*********************************************************************/\n    \"MACRO (tokens)\"\n    help=\"\"; debug=\"\"; s=\"\"; AT=\"\"; entire=\"\"; remain=\"\"\n    A1=\"\";A2=\"\";a3=\"\";a4=\"\";ln1=\"\";ln2=\"\";d1=\"\"\n    BLANKS = \"                          \"\n    N0 = 20\n    N = 0\n    I = 0\n    L = 0\n    /*********                                                  */\n    I = 1\n    tokens=translate(tokens)\n    DO i = 1 to words(tokens)\n       token = word(tokens,i)\n       IF TOKEN = \"\" THEN  iterate i /* should not happen*/\n       IF pos(\" \"token\" \", \" NEXT FIRST LAST PREV \") > 0 then do\n          zedsmsg = token \"invalid\"\n          zedlmsg = token \"not provided \",\n          \"for nor are next all first last prev\"\n          call note \"PIR\" time(\"n\") zedlmsg\n          Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n          Exit 12\n       END\n       if token = \"AT\"     then do; AT=\"AT\";        iterate i; end\n       if token = \"R\"      then iterate i;   /* this is the default*/\n       if token = \"S\"      then do; S=\"S\";          iterate i; end\n       if token = \"DEBUG\"  then do; DEBUG=\"DEBUG\";  iterate i; end\n       if token = \"ENTIRE\" then do; ENTIRE=\"ENTIRE\"; iterate i; end\n       if token = \"HELP\"   then do; HELP=\"HELP\";    iterate i; end\n         /*(*/\n       IF TOKEN = \")\" THEN  DO\n          ZEDSMSG = \"LOST PARENTHESIS\"\n          ZEDLMSG = \"BLANKS\"  SEPARATE ALL ,\n          OPERANDS; THEREFORE INVALID IN FROM() TO() COL() BEGIN()\n          call note \"PIR\" time(\"n\") zedlmsg\n          Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n          Exit 12\n       END\n       REMAIN = REMAIN token\n    end i\n    if remain \\= \"\" then do\n         ZEDSMSG = REMAIN \"--?\"\n         ZEDLMSG = ZEDSMSG \"invalid parameter(s) for PIR\"\n          call note \"PIR\" time(\"n\") zedlmsg\n         Address \"ISPEXEC\" \"SETMSG MSG(ISRZ001)\"\n         exit 1\n    end\n    /**************** UNIQUE CODE FOR PIR *************************/\n    /**************** UNIQUE CODE FOR PIR *************************/\n    /**************** UNIQUE CODE FOR PIR *************************/\n    /**************** UNIQUE CODE FOR PIR *************************/\n    /* DEBUG = \"DEBUG\" */\n    if debug = \"DEBUG\" then do\n        \"reset\" /* during testing*/\n        \"reset label\" /* during testing*/\n        call note \"DEBUG option in effect\"\n    end\n    \"(CP11,CP12) = CURSOR\"\n    \"LABEL .ZCSR = .PIRX 0\"\n    IF pcs2 = 0 then do\n      IF S \\= \"S\" THEN  DO\n         SAY \"CURSOR HAS NOT BEEN POSITIONED FOR USE OF  PIR S\"\n         ZEDSMSG = \"REPOSITION CURSOR\"\n         ZEDLMSG = ZEDSMSG. -- TO CREATE A \".PI \u00f8\" CARD\n          call note \"PIR\" time(\"n\") zedlmsg\n         Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n         Exit 0\n      END\n    END\n    \"(LN1) = LINE .ZCSR\"\n    ln1=strip(ln1,\"T\")\n    \"(VAR013,VAR014) = CURSOR\"\n    /* ----------------------- PIR AT ----------------------------- */\n    IF AT = \"AT\" THEN  DO\n       \"LABEL .ZCSR = .PIRA 0\"\n       \"LINE_AFTER .ZCSR = DATALINE (ln1)\"\n       \"LABEL\" EVAL(VAR013 + 1) \"= .PIRNW 0\"\n       IF  CP12 > 1 then\n          \"SHIFT ( .PIRNW\" Eval(CP12  - 1)\n       \"SHIFT ) .PIRNW 5\"\n       \"CHANGE .PIRNW .PIRNW 1 '     ' '.PI \u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW 1 4 P'>' P'<'\"\n       \"CHANGE ALL .PIRNW .PIRNW P'$GT##$' '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW P'$H#$' '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW P'$HP#$' '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW P'$HP##$' '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW P'$EGT##$' '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW P'$EHP#$' '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW P'$EHP##$' '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW P'$EPR##$' '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW P'$PR##$' '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW P'$SK $$' '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW P'$SP $$' '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW  ':P ' ''\"\n       \"CHANGE ALL .PIRNW .PIRNW  ':P.' ''\"\n       \"CHANGE ALL .PIRNW .PIRNW ';'  '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW '.\u00f8' '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW '\u00f8.' '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW '\u00f8, ' '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW '\u00f8\u00f8\u00f8\u00f8\u00f8\u00f8' '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW '\u00f8\u00f8\u00f8' '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW '\u00f8\u00f8' '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW '\u00f8\u00f8' '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW '\u00f8\u00f8' '\u00f8'\"\n       \"CHANGE ALL .PIRNW .PIRNW '\u00f8\u00f8' '\u00f8'\"\n       \"RESET CHANGE .PIRNW .PIRNW\"\n       \"CURSOR =\" CP11   CP12\n       Exit 0\n    END\n    /* ------- Common to    PIR R   (default)    ------------------ */\n    /* -------    and to    PIR S   (swap first two nodes) -------- */\n    \"SEEK FIRST NX .ZCSR .ZCSR '.PI'\"\n    IF RC \\= 0 THEN do\n          zedsmsg = token \".PI required\"\n          zedlmsg = token \"PIR R, and PIR S only work on .PI lines\"\n          Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n        Exit 4\n    end\n    \"(CP21,CP22) = CURSOR\"\n    \"LABEL .ZCSR = .PIRR 0\"\n    \"LINE_AFTER .ZCSR = DATALINE (LN1)\"\n    \"LABEL\" Eval(CP21 + 1) \"= .PIRNW 0\"\n    CS11 = CP21  + 1\n    CS12 = CP22\n    \"CURSOR =\" CS11 CS12\n    \"(LN1) = LINE .PIRNW\"\n    L = LENGTH(ln1)\n    /* ------- PIR S ----------------------------- PIR S ---------- */\n    IF S = \"S\" THEN  DO\n       \"LABEL\" CP21 \"= .PIRS 0\"\n       D1 = SUBSTR(ln1,CS12 + 4,1)\n       call note 'd1='d1 'in S-------'\n       \"SEEK NEXT  NX .ZCSR .ZCSR\" d1\n       \"(CS21,CS22) = CURSOR\"\n       \"SEEK NEXT  NX .ZCSR .ZCSR\" d1\n       IF RC \\= 0 THEN        Exit 0\n       \"(CS31,CS32) = CURSOR\"\n       \"SEEK NEXT  NX .ZCSR .ZCSR\" d1\n       IF RC = 0 THEN \"(CS41,CS42) = CURSOR\"\n       ELSE CS42 = L+1\n       A1 =  Substr(LN1,1, CS12 + 3 + 1 - 1)\n                                   /* .PI (BLANK)           */\n       A2 = strip( Substr(LN1, CS22, Eval(CS32 -1 + 1 - CS22)) )\n                                           /* \u00f8STANDARDS            */\n       A3 = strip( Substr(LN1, CS32, Eval(CS42 -1 + 1 - CS32)) )\n                                           /* \u00f8POLICY               */\n       L = L  + 1\n       IF A3 = D1 THEN  DO\n          \"DEL .PIRNW .PIRNW\"\n          \"CURSOR =\" cp21 cp22\n          \"LABEL .ZCSR = .ONE 0\"\n          Exit 4\n       END\n       A4 = strip(Substr(ln1, cs42, L + 1 - CS42) )\n                                           /* \u00f8XXXXXXXXXX           */\n       LN2 = strip( A1||A3||A2||A4 )\n                                        /* .PI \u00f8POLICY\u00f8STANDARDS\u00f8XXX*/\n       ZEDSMSG = \"PIR S\"\n       ZEDLMSG = \"PIR S -- SWAP FIRST TWO NODES  .PIRS\"\n       call note \"PIR\" time(\"n\") zedlmsg\n       Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n       signal FINISR\n    END\n    /******* DEFAULT ----------- PIR R ---------------------------- */\n    A1 = Substr(LN1,1, Eval(CP22 + 4 + 1 - 1))\n                                           /* .PI \u00f8                 */\n    A2 = strip( Substr(LN1,  CP12,  L + 1 - CP12) )\n                                           /* STANDARDS POLICY      */\n    A3 = strip( Substr(LN1, CP22 + 5,  CP12 -1 + 1 - CP22 - 5) )\n    LN2 = strip( A1||A2\"\u00f8\"||A3 )\n    ZEDSMSG = \"PIR R\"\n    ZEDLMSG = \"LABEL .PIRR LINE \",\n        \"ROTATED AT .ZCSR -- NEXT LINE IS RESULT\"\n       call note \"PIR\" time(\"n\") zedlmsg\n    Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\nFINISR:\n    if debug = \"DEBUG\" then do\n       call note \"ln1=\"ln1\n       call note \"   \"left(' ',cp12)\"-\"\n       call note \"a1=\"a1\"<---\"\n       call note \"a2=\"a2\"<---\"\n       call note \"a3=\"a3\"<---\"\n       call note \"a4=\"a4\"<---\"\n       call note \"ln2=\"ln2\n       call note \"d1=\"d1\"<--- which is  x'\"c2x(d1)\"'\"\n       x=\"\"\n       do i = 1 to length(ln2)\n          x = x substr(ln2,i,1)\n       end\n       call note \"ln2=\"||x\n       call note \"ln2=\"c2x(ln2)\n       \"up max\"\n    end\n    \"LINE_AFTER .ZCSR = DATALINE (LN2)\"\n    \"DEL .PIRNW .PIRNW\"\n    \"LABEL\" Eval(CP21 + 1) \"= .PIRNW 0\"\n    \"CHANGE .PIRNW .PIRNW   '\u00f8\u00f8' '\u00f8' ALL\"\n    \"CHANGE .PIRNW .PIRNW   '\u00f8' '\u00f8' ALL\"\n    \"CURSOR =\" cp21 CP22\n    \"RESET CHANGE .PIRNW .PIRNW\"\n    \"RESET LABEL  .PIRNW .PIRNW\"\n    Exit 0\n/*********************************************************************/\n/*   REALISTIC INDEX ENTRIES                                         */\n/*     THIS IS A BRIEF EXCERPT FROM DOCUMENTATION OF THIS CLIST.     */\n/*                                                                   */\n/*      *****GENERATION OF CICS TABLES AND STARTUP JCL************   */\n/*      .PI |TABLES|CICS|GENERATION OF, AND STARTUP JCL              */\n/*      .PI |CICS|TABLES|GENERATION OF, AND STARTUP JCL              */\n/*   NOTE THE COMMA INDICATES SOMETHING REARRANGED AT THAT POINT.    */\n/*                                                                   */\n/*   SIMILAR TO                                                      */\n/*                                                                   */\n/*           DR. ALLEN NEWHOUSE III, DDS                             */\n/*           NEWHOUSE III, ALLEN, DDS, DR.                           */\n/*                                                                   */\n/*           CLISTS THAT MODIFY TEXT                                 */\n/*           THAT MODIFY TEXT, CLISTS                                */\n/*           MODIFY TEXT, CLISTS THAT                                */\n/*           TEXT, CLISTS THAT MODIFY                                */\n/*           CLISTS THAT MODIFY TEXT                                 */\n/*********************************************************************/\n return\nEVAL: procedure   /* simplify some of clist conversion*/\n  arg arg\n  interpret \"x = arg\"\n  return x\n\nnote:  parse arg arg\n    \"LINE_BEFORE .ZFIRST = NOTELINE (arg)\"\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PLACE": {"ttr": 11782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x8a\\x00\\x8a\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 138, "newlines": 138, "modlines": 0, "user": "MCRITCH"}, "text": "ISREDIT MACRO NOPROCESS (MEMBER)\n  /* TITLE -- PLACE\n  /* DESCRIPTION -- USED TO BUILD up text with modified panels\n  /*\n  /* except for the next 2 lines-- ripped out of PASTE macro */\n  SET KEEP = KEEP\n  SET &DATASET = &STR(IS03.PLR.PATTERNS(&MEMBER.))\n\n  IF &SYSDSN('&DATASET') NE &STR(OK) THEN +\n     DO\n        ISREDIT PROCESS DEST\n        IF &LASTCC. ^= 8 THEN DO\n          WRITE SORRY -- &DATASET\n          WRITE &B.        &SYSDSN('&DATASET')\n          EXIT CODE(12)\n        END\n        ISREDIT (DEST) = LINENUM .ZDEST\n        SET DEST = &DEST\n\n/*********************************************/\n/* PERFORM RESET OPERATION TO GET RID OF     */\n/* THE DESTINATION CHARACTER 'A'.            */\n/*********************************************/\n        ISREDIT RESET &DEST &DEST\n        SET &ZEDSMSG = &STR(WORK DATASET NOT FOUND)\n        SET &ZEDLMSG = &STR(PASTE WORK DATASET COULD NOT BE +\n                            FOUND)\n        ISPEXEC SETMSG MSG(ISRZ001)\n        EXIT CODE(12)\n     END\n\n  ALLOC F(TEMPFLE) DA('&DATASET') SHR REUSE\n\n/***********************************************/\n/* TELL MACRO THAN WE WILL PROCESS B (BEFORE)  */\n/*    OR A (AFTER) DESTINATION COMMANDS.       */\n/* ONLY DEST IS VALID ANYTHING ELSE IS NOT.    */\n/* UNEXPECTED  C RANGE CAUSED ABEND S-0C4.     */\n/***********************************************/\n\n  ISREDIT PROCESS DEST RANGE C M\n\n  SET RC = &STR(&LASTCC)\n  ISREDIT (CMD) = RANGE_CMD\n  IF &RC = 0 OR &RC = 8 THEN DO\n     ISREDIT (CMD) = RANGE_CMD\n     SET &ZEDSMSG = &STR(RANGE NOT ALLOWED RC=&RC.)\n     SET &ZEDLMSG = &STR(RANGE \"&CMD.\" NOT USED WITH PASTE -- +\n         USE DEST \"A\" OR \"B\" ONLY)\n     ISPEXEC SETMSG MSG(ISRZ001)\n     EXIT CODE(12)   /* HIGH RETURN CODE LEAVES COMMAND */\n   END\n  IF &RC NE 4 THEN DO\n     SET &ZEDSMSG = &STR(PASTE PENDING)\n     SET &ZEDLMSG = &STR(AN \"A\" OR \"B\" LINE COMMAND HAS NOT BEEN +\n          SPECIFIED, OR LINE COMMANDS CONFLICT)\n     ISPEXEC SETMSG MSG(ISRZ001)\n     EXIT CODE(12)   /* HIGH RETURN CODE LEAVES COMMAND */\n   END\n\n/*********************************************/\n/* SET OUR DEST VARIABLE TO THE LINE NUMBER  */\n/* FOR A 'A' COMMAND ENTERED BY THE USER.    */\n/*********************************************/\n\n  ISREDIT (DEST) = LINENUM .ZDEST\n\n/*********************************************/\n/* AFTER THE ISREDIT LINENUM COMMAND, IT IS  */\n/* NECESSARY TO SET THE DEST VARIABLE TO     */\n/* ITSELF TO DROP ANY LEADING ZEROES IN IT.  */\n/*********************************************/\n\n  SET DEST = &DEST\n  SET SDEST = &DEST\n\n/*********************************************/\n/* FIND OUT IF SEQUENCE NUMBERING ON         */\n/*********************************************/\nISREDIT (NUMON) = NUMBER\n\n/*********************************************/\n/* SET TSO/E ERROR ROUTINE BEFORE USE OF     */\n/* CLIST QSAM ROUTINES TO READ WORK DATASET. */\n/*********************************************/\n\n  ERROR +\n     DO\n        SET RCLINE = &LASTCC.\n        IF &RCLINE. = 4 THEN DO\n           SET TRUNCAT = &STR( -DATA TRUNCATED- )\n           RETURN\n        END\n        IF &RCLINE NE 400  THEN SET RCNOTE = &STR(** RC=&RCLINE.** )\n        ISREDIT LINE_AFTER &DEST. = +\n           NOTELINE \"&SYSTIME. -END- OF PASTE &KEEP. &TRUNCAT.&RCNOTE.\"\n        ISREDIT LINE_AFTER  &DEST. = +\n           DATALINE  \".panel off;.*=====&MEMBER.==============+\n                      =====================================\"\n        SET SDEST = &SDEST. + 1\n        ISREDIT LINE_BEFORE &SDEST. = +\n           DATALINE  \".panel &MEMBER.;.*======================+\n                      =====================================\"\n        IF &NUMON = ON THEN ISREDIT LINE_AFTER &DEST. = NOTELINE +\n           \"&SYSTIME. NUMBER MODE IN EFFECT, TRUNCATION LOSS MAY +\n           OR MAY NOT BE REAL\"\n        CLOSFILE TEMPFLE\n        FREE F(TEMPFLE)\n  /*--REMOVE  CONTROL NOMSG\n  /*--REMOVE        IF KEEP NE &KEEP. THEN DELETE '&DATASET'\n  /*--REMOVE        CONTROL MSG\n        SET &ZEDSMSG = &STR(PASTE SUCCESSFULL)\n        SET &ZEDLMSG = &STR(PASTE WORK DATASET WAS MOVED INTO +\n                            INTO THIS CURRENT DATASET)\n        ISPEXEC SETMSG MSG(ISRZ000)\n        EXIT CODE(1)\n     END\n\n/*********************************************/\n/* USE CLIST QSAM ROUTINES TO WRITE OUT EACH */\n/* RECORD BACK TO THE CURRENT EDITED DATASET.*/\n/*********************************************/\n\n  OPENFILE TEMPFLE INPUT\n\n  LOOP: GETFILE TEMPFLE\n        SET XX = &LASTCC.\n        IF &XX NE 0 THEN DO\n           WRITE LC=&LASTCC.\n           EXIT CODE(12)\n        END\n        /* NEXT LINE  CORRECTED  D.MCRITCHIE 1991/04/24 */\n        ISREDIT LINE_AFTER &DEST = (TEMPFLE)\n        IF &SDEST. = &DEST THEN ISREDIT LINE_AFTER &DEST. = +\n           NOTELINE \"&SYSTIME. START OF PASTE &KEEP.\"\n        SET &DEST = &DEST + 1\n        GOTO LOOP\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PLICHK": {"ttr": 11785, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01\\x05\\x01\\x05\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 261, "newlines": 261, "modlines": 0, "user": "MCRITCH"}, "text": " /*REXX***************************************************************\n      Users:       TSO ISPF EDIT users having PLI programs\n      Entry:       Used as an EDIT CLIST within ISPF EDIT\n                   ===> PLICHK .LABEL1 .LABEL2\n      Contributed: 1985/09/25 David McRitchie\n      Redone in REXX: 1993/06/02 David McRitchie.\n      Related:     QCHK, EDITCHEK, EDITOL, NESTCHK, etc...\n      OPTIONS:\n       TWO LABELS -- WILL DEFAULT TO .ZFIRST\n                     AND .ZLAST IF NONE SUPPLIED\n       THIS MACRO CAN BE USED WITHIN A MACRO\n          FOR INSTANCE WITHIN DUADD IT IS INVOKED\n             USING   ISREDIT  PLICHK .DUADF .DUADL\n       TO RESTRICT USAGE TO SCRIPT ONLY\n          ---  NO CHECK FOR  \"DO\" ... \"END\"\n          ==> PLICHK SCRIPT\n       --  may want to use in combination with  \"FIXQUOTE\" clist\n       To restrict usage to SCRIPT only and only check for quotes use\n          ==> PLICHK SCRIPT QUOTE\n      ...............................................\n      need to obtain starting labels of LABF LABL\n      ...............................................\n  *********************************************************************/\n address 'ISREDIT'; 'MACRO (PARMS) NOPROCESS';\n note = 'LINE_BEFORE .zfirst = NOTELINE '\n Labf=''; Labl=''; Remainder='';\n debug='';test=''; SCRIPT='';colbeg='';colend=''\n i=0;k=0;j=0;quote='';\n\n /* Collect Parameters */\nparms = translate(parms)\n\n/* not suited for imbedded blanks but will see initial ending quotes*/\n do iii = 1 to 10;\n   token = word(parms,iii)\n   if token = '' Then leave\n   tokenx = translate(token);\n   if tokenx = \"DEBUG\" then do\n      TRACE Intermediate\n   end\n   j = pos(tokenx,' SCRIPT DEBUG QUOTE ')\n   if j <> 0 then do;\n      string = token ' = '''token''''; interpret  string; iterate iii;\n   end;\n   if substr(token,1,1) = '.' Then do\n      if labf = '' Then labf = token\n      else if labl = '' Then labl = token\n      else do\n            zedsmsg = '.LABEL RC=8'\n            zedlmsg = 'too many labels --' Labf labl token\n            Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            exit 8\n      end\n      iterate iii\n   end\n\n if colbeg \\= '' then if colend = '' then do\n       zedsmsg =  \"From/To\"\n       zedlmsg =  \"From/To pair invalid, missing TO column\"\n       \"line_before .zfirst = NOTELINE\" \"From/To pair invalid,\",\n            \"missing TO column\"\n       Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n       Exit 8\n  end\n\n\n   say 'testing remainder --' token '<--'\n   remainder = remainder token\n end iii\n\n if remainder <> \"\" Then do\n    zedsmsg =  Remainder\n    zedlmsg =  remainder \"-- Parameters unknown to PLICHK\"\n    Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    Exit 8\n end\n\n/* process additional LABEL / RANGE relationships */\nif labl = '' Then do\n   \"PROCESS RANGE C\"\n   if RC = 0 THEN DO\n      \"LABEL .zfrange = .labf 1\"\n      \"LABEL .zlrange = .labl 1\"\n      labf = \".labf\"\n      LABL = \".labl\"\n   end\nend\nif labl = '' Then do; labf='.ZFIRST'; labl='.ZLAST'; end;\n\"(LABFNO) = LINENUM\" LABF\n\"(LABLNO) = LINENUM\" LABL\n\n/****** all parameters have been received -- process relationships */\n    /********* END OF GENERALIZED INTERFACE CODE ******************/\n    \"(labfno) = LINENUM\" labf\n    \"(lablno) = LINENUM\" LABL\n    \"EXCLUDE ALL\" labf labl\n    K = labfno - 1\nLOOP1:\n    K = K + 1\n    IF k > lablno THEN signal LOOP1E\n    IF k = \"\"       THEN say      \" PASSING BY LINE 8000 NOW\"\n    \"LABEL\" K \"= .TLINE\"\n    ERR = 0\n    \"SEEK .TLINE .TLINE\" colbeg colend \"\"\"'\"\" ALL\"\n    \"(QOT1,QOT2) = SEEK_COUNTS\"\n    \"SEEK .TLINE .TLINE\" colbeg colend \"'\"\"' ALL\"\n    \"(QQT1,QQT2) = SEEK_COUNTS\"\n    QOTI = qot1 // 2  /* only want the remainder */\n    QQTI = qqt1 // 2  /* only want the remainder */\n    err = err + qoti + qqti\n    IF SCRIPT \\= \"SCRIPT\" THEN if err=0 then do\n       \"SEEK .TLINE .TLINE 1 '//*'\"\n       \"(SSA1,SSA2) = SEEK_COUNTS\"\n       IF ssa1  \\= 0 then signal LOOP1\n       /* loop1 -- BYPASS all comment cards */\n       \"SEEK .TLINE .TLINE\" colbeg colend \"'/*' ALL\"\n       \"(SA1,SA2) = SEEK_COUNTS\"\n       \"SEEK .TLINE .TLINE\" colbeg colend \"'*/' ALL\"\n       \"(AS1,AS2) = SEEK_COUNTS\"\n       IF SA1 \\= AS1 THEN ERR = ERR + 1\n    END\n\n    \"SEEK .TLINE .TLINE\" colbeg colend \"':' ALL\"\n    \"(CN1,CN2) = SEEK_COUNTS\"\n    IF cn1 \\= 0 then do\n       \"SEEK .TLINE .TLINE\" colbeg colend \"t':q.' ALL\"\n       \"(EC1,EC2) = SEEK_COUNTS\"\n       \"SEEK .TLINE .TLINE\" colbeg colend \"t':eq.' ALL\"\n       \"(EC3,EC4) = SEEK_COUNTS\"\n       IF EC1 \\= EC3 THEN ERR = ERR + 1\n\n       IF  QUOTE \\= \"QUOTE\" THEN DO\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':hp0.' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':ehp0.' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':hp1.' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':ehp1.' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':hp2.' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':ehp2.' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':hp3.' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':ehp3.' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':hp4.' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':ehp4.' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':hp5.' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':ehp5.' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':hp6.' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':ehp6.' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':hp7.' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':ehp7.' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':hp8.' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':ehp8.' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':hp9.' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':ehp9.' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':gt10.' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':egt10.' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':gb10.' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':egb10.' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':gt12.' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':egt12.' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':gt15.' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':egt15.' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':gt16.' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':egt16.' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':gt17.' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':egt17.' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':gt18.' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':egt18.' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':italic.' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':eitalic.' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':pr12.' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"t':epr12.' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"x'5096984B' ALL\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"x'5083984B' ALL\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n          \"SEEK .TLINE .TLINE\" colbeg colend \"\",\n               \"x'509698984B' all\"\n          \"(EC1,EC2) = SEEK_COUNTS\"\n          \"SEEK .TLINE .TLINE\" colbeg colend \"\",\n               \"x'508398984B' all\"\n          \"(EC3,EC4) = SEEK_COUNTS\"\n          IF EC1 \\= EC3 THEN ERR = ERR + 1\n      END\n   END\n   IF err  \\= 0 THEN  \"RESET  .TLINE .TLINE\"\n   ELSE \"EXCLUDE .TLINE .TLINE ALL\"\n   signal LOOP1\n  LOOP1E:  AAA = BBB\n   CCTOT = 0\n   IF script = \"\" then do\n      \"SEEK .ZFIRST .ZFIRST 'REXX'\"\n      IF RC \\= 0 THEN DO\n          \"SEEK ' DO;' FIRST\"\n          IF RC = 0 THEN DO\n             \"SEEK '       ' FIRST\"\n             IF RC \\= 0 THEN DO\n                 \"SEEK  ':' 1 FIRST\"\n                 IF RC \\= 0 THEN \"FIND\" LABF LABL  \"' END   ' ALL\"\n                 /*HOPEFULLY ONLY PLI GETS CHECKED FOR an end */\n                 /* that is missing a semi-colon*/\n             END\n          END\n      END\n   END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PLIDCLS": {"ttr": 12035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00(\\x00(\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "MCRITCH"}, "text": "ISREDIT MACRO\n/* purpose: facilitate removal of unused declarations  */\n/* programmer: David McRitchie,  \"The REXX Macros Toolbox\", 1990/06/27 */\n/*                                                                */\n/* this clist will sort the pli   attributes and references  list */\n/*  by declaration number (line number order)                     */\n/* directions for use */\n/*  1. SNAP  PLI  compilation list into a dataset */\n/*  2. Run the PLIDCLS clist on the disposable dataset created */\n/*  3. use  ==> @VP systech   or whatever to print listing*/\nISREDIT f first 'attribute and cross-reference'\nIF &LASTCC. ^= 0 THEN EXIT CODE(0)\nISREDIT del .zf .zcsr\nISREDIT f first 'aggregate length table'\nIF &LASTCC. ^= 0 THEN EXIT CODE(0)\nISREDIT del .zcsr .zl\nISREDIT x all\nISREDIT f 2 5 p'@' all\nISREDIT del nx all\nISREDIT f 2 '#'p all\nISREDIT reformat nx entire 1 1 '0' 2 140\nISREDIT x 10 p'#' all\nISREDIT c all nx '0' 2 '00'\nISREDIT x 10 p'#' all\nISREDIT c all nx '0' 2 '00'\nISREDIT x 10 p'#' all\nISREDIT c all nx '0' 2 '00'\nISREDIT x 10 p'#' all\nISREDIT c all nx '0' 2 '00'\nISREDIT x 10 p'#' all\nISREDIT c all nx '0' 2 '00'\nISREDIT x 10 p'#' all\nISREDIT c all nx '0' 2 '00'\nISREDIT x 10 p'#' all\nISREDIT c all nx '0' 2 '00'\nISREDIT f 2 '0' all\nISREDIT reformat nx entire 1 1 3 140\nISREDIT x 10 p'#' all\nISREDIT f 2 p'^' all\nISREDIT sortg 2 9 .zf .zl\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROC": {"ttr": 12037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xa3\\x00\\xa3\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 163, "newlines": 163, "modlines": 0, "user": "MCRITCH"}, "text": "  PROC 1 MEMBER DEBUG NB SUMMARY EDIT +\n     CHKCAT +\n     DS1('SYS1.PROCLIB') +\n     DS2('SYS1.TSOPROC') +\n     DS3('SYS1.USERPROC') +\n     DS4('SYS1.TESTPROC') +\n     DS5('SYS1.CHM1PROC') +\n     DS6('SYS1.FIB1PROC') +\n     DS7('SYS1.FIB1TEST')\n/* PURPOSE: BROWSE A PROCEDURE MEMBER\n/*          ACCORDING TO JES2 PROCLIB CONCATENATION\n/*  SUPPLIED BY DAVID MCRITCHIE AHC 1985/07/10\n/*  OPTIONS -- */\n/*   EDIT    -- USE EDIT INSTEAD OF BROWSE\n/*   SUMMARY -- WILL PRODUCE A SUMMARY LIST AT END\n/*   NB -- NO BROWSE DS LIBRARIES, USE WITH SUMMARY\n/*   CHKCAT -- CHECK THAT DSNAMES ARE CATALOGED\n/*   DEBUG -- TRACING FOR PROGRAMMER\n/* ------------------------------------------------- */\n/* DOCUMENTATION: IS03.SHARE.TEXT(PROC)              */\n/* ------------------------------------------------- */\n/* CLIST NAMED PROC -- REFRESH INFORMATION ......    */\n/*   --ONCE SETUP FOR A SYSTEM DO NOT EXPECT CHANGES */\n/* USE THE PROC00 CONCATENATION IN THE JES2 PROC     */\n/* FOR HCCG.CLIST(PROC) USE THE PROC06 CONCATENATION */\n/* ------------------------------------------------- */\n  SET L = &LENGTH(&STR(&MEMBER.))\n  IF &L. > 8 THEN DO\n     SET INVAL = &STR(INVALID MEMBERNAME LENGTH('&MEMBER.') EXCEEDS 8)\n     WRITE &INVAL.\n     SET &ZEDSMSG = &STR(MEMBERNAME)\n     SET &ZEDLMSG = &STR(&INVAL.)\n     ISPEXEC     SETMSG MSG(ISRZ000)\n     EXIT CODE(12)\n  END\n  ISPEXEC CONTROL DISPLAY LINE\n  SET BLANKS = &STR(                                            )\n  SET BLANKS = &STR(&BLANKS.&BLANKS.)\n  IF CHKCAT = &SYSCAPS(&CHKCAT.) | CHKCAT = &SYSCAPS(&STR(&MEMBER.)) +\n  THEN DO\n     SET CHKCAT = CHKCAT\n     SET MEMBER = &STR(........)\n  END\n  SET DEBUG = &SYSCAPS(&DEBUG)\n  SET NB    = &SYSCAPS(&NB)\n  SET CHKCAT = &SYSCAPS(&CHKCAT)\n  IF EDIT = &SYSCAPS(&EDIT) THEN SET BROWSE = EDIT\n  ELSE SET BROWSE = BROWSE\n  SET MULTIMEM = &SYSINDEX(&STR(*),&STR(&MEMBER.))\n  IF &MULTIMEM = 0 THEN -\n     SET MULTIMEM = &SYSINDEX(&STR(%),&STR(&MEMBER.))\n  SET SUMMARY = &SYSCAPS(&SUMMARY)\n  ISPEXEC CONTROL DISPLAY LINE\n  SET XCNT = 0\n  SET N = 1\n  SET DS = &&DS&N..\n  DO WHILE &STR(&DS) ^=\n     IF CHKCAT = &SYSCAPS(&CHKCAT.) THEN DO\n        /*    CONTROL NOLIST NOCONLIST NOSYMLIST MSG\n        /*       SYSOUT TRAPS WILL NOT WORK IF YOU USE   LIST\n        SET SYSOUTTRAP = 100\n        SET SYSOUTLINE7 = &STR(.....................................)\n        LISTCAT ENT('&DS.') VOL\n        SET NS = &SYSOUTLINE\n        SET I = 1\n        DO WHILE &I <= &NS\n           SET X = &STR(&&SYSOUTLINE&I..)\n           SET X = &STR(&X.)\n           SET I = &I. + 1\n        END\n        WRITE &SUBSTR(1:4,&N..     ) +\n              &SUBSTR(26:31,&SYSOUTLINE7.&BLANKS.) +\n            &SUBSTR(16:60,&SYSOUTLINE1.&BLANKS.)\n        GOTO AGAIN\n     END\n     IF &MULTIMEM NE 0 THEN DO\n        SET MULTI&N = NO MEMBER(S) FOUND\n        $&BROWSE. '&DS.(&STR(&MEMBER.))'\n        IF &LASTCC. = 0 THEN DO\n           SET XCNT = &XCNT. + 1\n           SET MULTI&N = MEMBER(S) FOUND\n        END\n        GOTO AGAIN\n     END\n     /* IF YOU DON'T WANT SUMMARY TO BE ABLE TO BROWSE USE... */\n     /* -- IF &NB = NB OR &SUMMARY = SUMMARY THEN --D-O-- */\n     IF &NB = NB THEN DO\n        SET MULTI&N. = &STR(&SYSDSN('&DS.(&STR(&MEMBER.))'))\n        WRITE SET MULTI&N. = &STR(&SYSDSN('&DS.(&STR(&MEMBER.))'))\n        SET CHK = &STR(&&MULTI&N.)\n        IF &CHK.= OK THEN  SET XCNT = &XCNT. + 1\n     END\n     ELSE DO\n        IF &STR(&SYSDSN('&DS.(&STR(&MEMBER.))')) = OK THEN DO\n           SET DSNAME = '&DS.(&STR(&MEMBER.))'\n           SET MULTI&N = OK\n           ISPEXEC VPUT DSNAME SHARED\n           IF &STR(&DS.) = &STR(SYS1.CHM1PROC) OR -\n              &STR(&DS.) = &STR(SYS1.FIB1TEST) OR -\n              &STR(&DS.) = &STR(SYS1.FIB1PROC) OR -\n              &STR(&DS.) = &STR(SYS1.TESTPROC) THEN DO\n              ISPEXEC VGET VSTSRVTI SHARED\n              SET HLDSRVTI = &STR(&VSTSRVTI.)\n              SET VSTSRVTI = &STR(&DS.(&STR(&MEMBER.)))\n              ISPEXEC VPUT VSTSRVTI SHARED\n              SET DSNDESC = &STR(&STR(/)*JOBPARM PROCLIB=PROC06  -- +\n              REQUIRED, AND IS 1ST IN CONCATENATION)\n              IF &STR(&DS.) = SYS1.TESTPROC THEN -\n              SET DSNDESC = &STR(&STR(/)*JOBPARM P=PROC04 +\n                  | P=PROC03 TO USE BEFORE SYS1.USERPROC)\n              IF &STR(&DS.) = SYS1.FIB1TEST +\n               | &STR(&DS.) = SYS1.FIB1PROC THEN -\n              SET DSNDESC = &STR(&STR(/)*JOBPARM P=PROC07 +\n                  | P=PROC08 TO USE BEFORE SYS1.USERPROC)\n              ISPEXEC VPUT DSNDESC SHARED\n              IF &BROWSE = EDIT THEN -\n               ISPEXEC   EDIT DATASET('&DS.(&STR(&MEMBER.))') +\n                    PANEL(SYSEDDE2)\n              ELSE ISPEXEC BROWSE DATASET('&DS.(&STR(&MEMBER.))') +\n                    PANEL(SYSBROB3)\n               SET VSTSRVTI = &STR(&HLDSRVTI)\n               ISPEXEC VPUT VSTSRVTI SHARED\n           END\n           ELSE ISPEXEC   &BROWSE DATASET('&DS.(&STR(&MEMBER.))')\n           SET DSNAME =\n           ISPEXEC VPUT DSNAME SHARED\n           SET XCNT = &XCNT. + 1\n           END\n        ELSE DO\n           SET MULTI&N = &STR(&SYSDSN('&DS.(&STR(&MEMBER.))')\n           IF &SUMMARY ^= SUMMARY AND &NB ^= NB THEN DO\n              IF &DEBUG = DEBUG THEN -\n                  WRITE &SUBSTR(1:4,&N..     ) '&DS.(&STR(&MEMBER.))' +\n                        -- &STR(&SYSDSN('&DS.(&STR(&MEMBER.))'))\n           END\n        END\n     END\n    AGAIN: +\n     SET N = &N. + 1\n     SET DS = &&DS&N..\n     END\n  IF SUMMARY = &SUMMARY THEN DO\n     SET N = 1\n     WRITE\n     WRITE SUMMARY FOR ===> TSO PROC &MEMBER &NB &SUMMARY &DEBUG\n     WRITE\n     SET DS = &&DS&N..\n     IF &DS NE &BLANK THEN DO\n       AGAIN3: +\n        SET DS = &&DS&N..\n        SET CHK = &STR(&&MULTI&N.)\n        WRITE &SUBSTR(1:4,&N..     ) '&DS.(&STR(&MEMBER.))' -- &CHK.\n        SET N = &N + 1\n        SET DS = &STR(&&DS&N.)\n        IF &DS NE &BLANK THEN GOTO AGAIN3\n     END\n  END\n/*  IF &XCNT. > 0 THEN EXIT CODE(0)\n  IF &XCNT. = 0 THEN WRITE MEMBER=&STR(&MEMBER.) WAS NOT FOUND +\n      IN ANY OF SELECTED PROCEDURE LIBRARIES\n  ELSE WRITE MEMBER=&STR(&MEMBER.) WAS FOUND IN &XCNT. PROCEDURE +\n       LIBRARIES\n  EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PROD01": {"ttr": 12041, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x1d\\x00\\x1d\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "MCRITCH"}, "text": "  PROC 1 MEMBER\n  /* TSO   PROD01  -- EDIT THE PRODUCTION MEMBER SPECIFIED  */\n  /* MACRO @PROD01 -- COPY THE PRODUCTION MEMBER SPECIFIED  TO END OF MEMBER IN\n  IF &STR(&MEMBER) = &STR(PRODLST) THEN DO\n  /* FREE DS(SPROD.TEMP)\n     ALLOCATE DDNAME(EDITPDS) REUSE DSNAME(SPROD.TEMP) -\n         NEW UNIT(TESTDISK)  SPACE(28,7) DIR(1) -\n         LIKE('O010.LIBR.PROD')\n     COPY 'O010.LIBR.PROD(PROD1)' SPROD.TEMP(PROD1) NONUM\n     ISPEXEC EDIT DATASET(SPROD.TEMP(PROD1))\n     DEL SPROD.TEMP\n     FREE DS(SPROD.TEMP)\n     EXIT CODE(&LASTCC)\n  END\n  SET MULTIMEM = &SYSINDEX(&STR(*),&STR(&MEMBER.))\n  IF &MULTIMEM = 0 THEN -\n     SET MULTIMEM = &SYSINDEX(&STR(%),&STR(&MEMBER.))\n  ISPEXEC CONTROL ERRORS RETURN\n  IF &STR(&MEMBER) = &STR(*) THEN -\n     ISPEXEC     EDIT DATASET('TSOPROD.PROD01.CNTL') MACRO(@DIRSTAT)\n  ELSE -\n     ISPEXEC     EDIT DATASET('TSOPROD.PROD01.CNTL(&MEMBER)') MACRO(@DIRSTAT)\n  SET &ZEDSMSG = &ZERRSM.\n  SET &ZEDLMSG = &ZERRMAG &ZERRLM.\n  ISPEXEC     SETMSG MSG(ISRZ000)\n  CONTROL NOMSG\n  FREE DATASET('TSOPROD.PROD01.CNTL')\n  CONTROL MSG\n/*****************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PROPER": {"ttr": 12043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x03O\\x03O\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 847, "newlines": 847, "modlines": 0, "user": "MCRITCH"}, "text": "/*rexx: Make Proper nouns if original strictly lowercase */\n/*PROPER    Author: David McRitchie, created 1992/02/11 IS03  */\n/*          at \"The REXX Macros Toolbox\", DMcRitchie@aol.com    */\n/*          Updated 1992/02/17 20:22 IS03                     */\nAddress \"ISREDIT\"\n\"MACRO (TOKEN)\"\n\"CAPS OFF\"\n/* Contributed: David McRitchie, \"The REXX Macros Toolbox\", 1992/02/11 */\n/* suggest use is AFTER using the @SMALLS macro clist/execute        */\n/* suggest and EXCLUDE of all lines before using PROPER macro.       */\n/*  RELATED CLISTS -- @SMALLS, PERIOD,  SPELL                        */\n/*********************************************************************/\n/* Optional usage -- supply own words -- ignore words BUILTIN        */\n/*      ===> PROPER Librarian SQLNO SYSIN                            */\n/*********************************************************************/\n/* The text is basically same as added to our dictionary, except     */\n/* that words were checked with the SPELLING clist to make sure      */\n/* that none of these words are valid in all lowercase letters.      */\n/* A few of those that were valid in all lowercase letters were      */\n/* left in                                                           */\n/*   1. Take words of dictionary additions                           */\n/*   2. Remove AP and HP prefix in col 1-2                           */\n/*   3. Change all double hyphens (--) to single hyphens (-)         */\n/*   4. Reformat  into two columns as follows:                       */\n/*      .cm Word-A               ;word-a                             */\n/*      with the left-hand side being a comment and the right        */\n/*      side converted to lowercase.                                 */\n/*   5. Exclude all lines and execute  SPELL.                        */\n/*   6. Delete all excluded (or valid in lowercase) lines.           */\n/*   7. REFORMAT words into listing as needed below.                 */\n/* WARNING: do not remove the PROCESS procedure at the end.          */\n/*********************************************************************/\n/* Since word are sorted, it will not make any difference in the     */\n/* results if a word appears both as Albert and ALBERT, since the one*/\n/* with the lowercase letters will have completed and rendered the   */\n/* second form unfindable when checked for in lowercase.             */\n/*********************************************************************/\n\"EXCLUDE ALL\"\n\" ISREDIT (MEMBERX) = MEMBER \"\n\" ISREDIT (DSNX)    = DATASET\"\n\"(LINE) = linenum .zf\"\nIF RC \\= 0 then return\n  twords = 0; cwords=0; owords=0;\n  ZEDSMSG =\n  BEGAN = TIME('N')\n  ZEDLMSG = BEGAN ||\" -- PROPER began\"\n/*********************************************************************/\n/*   Address \"ISPEXEC\" \"CONTROL DISPLAY LOCK\"                        */\n/*********************************************************************/\n  Address \"ISPEXEC\" \"SETMSG  MSG(ISRZ000)\"\nIF TOKEN \\= \"\" then do\n   CALL PROCESS       TOKEN\n   report = \"PROPER changed \" owords \"occurrences of\" ,\n     cwords \"(list\" twords\")\"\n   \"LINE_BEFORE .zf = NOTELINE \"\"\"||began||\"--\"||TIME('N') ,\n       MEMBERX report||\"\"\" \"\n         ZEDSMSG = \"COMPLETED\"\n         ZEDLMSG = BEGAN||\"--\"TIME('N') report\n         Address \"ISPEXEC\" \"SETMSG  MSG(ISRZ000)\"\n   RETURN 1\nEND\n/******************* BUILTIN words portion follows *****************/\n\"CHANGE ALL WORD p'sys#' p'>>>>'\"\n\"CHANGE ALL WORD c'dpt' p'>>>'\"\n\"CHANGE ALL WORD c'VSAM' VSAM\"\n\"CHANGE ALL WORD c'SPF'  SPF\"\nCALL PROCESS \" Albert Alexander Alfisi Alice Alison Allen \"\nCALL PROCESS \" Allentown Allison Alma Alpine Alt-Esc Alunni \"\nCALL PROCESS \" Alvarez Amalia Amolia @AMSRCAT @C @CAPS @COMPARE \"\n/* ...... documentation shows how it works not all words shown ..\n.go xxx;.ct */\nCALL PROCESS \" @DATE @DIR @EDITMSK @EQUFLAG @ICOPY @INDEX @MEMO \"\nCALL PROCESS \" @RENAME @RESQ @RESQTXT @SCRIPT @SCRPTDU @SEQ @SLCT \"\nCALL PROCESS \" @SLCTDSX @SMALLS @STRAPE @STRAPQ @TPP @TSO @TSOX \"\nCALL PROCESS \" @TSOXD @VP @XMIT LaserJet mAh nnnnK nnnK nnFASCIS \"\nCALL PROCESS \" non-ANSI-standard non-Network non-NETWORK \"\nCALL PROCESS \" non-NETWORK-related nonIBM pppppFnn pppppTnn pPUNn \"\nCALL PROCESS \" pRDRn qNCPUxx sPUNn sRDRn titNN x'FE xxxxAGVET \"\nCALL PROCESS \" xxxxCMDS xxxxEDIT xxxxEDRT xxxxFILE xxxxPROF \"\nCALL PROCESS \" xxxxRSR xxFFFFFF yymmIOG Abadie Abee Ada Adobe \"\nCALL PROCESS \" Agrivet Akron Alampi Alan Anaheim Anderson Angeles \"\nCALL PROCESS \" Angstadt Anil Ann Anne Annette Annn Apr Archdale \"\nCALL PROCESS \" Argo Arledge Armstrong Arora Arthur Artis Ashley \"\nCALL PROCESS \" Ashton-Tate Assemblr Assin Asynch Aten Atg Athenian \"\nCALL PROCESS \" Atlanta Aton Auburn Audix Aug Austin Australia \"\nCALL PROCESS \" Austria Authentication Authorizer Autotab Ave Axxxx \"\nCALL PROCESS \" Azoplate AAA AAAAA AAAAAAAAAFF AB ABCDE ABCDEF \"\nCALL PROCESS \" ABCDEFGHIJK ABCDEFGHIJKLMNOPQRSTUVWXYZ ABM ABND \"\nCALL PROCESS \" ABOX ABP ACBLIB ACBNAME ACC ACCCC ACCO ACCTG ACCTIN \"\nCALL PROCESS \" ACCTIO ACCTIVP ACCTOUT ACF ACK ACO ACOPROC ACOS \"\nCALL PROCESS \" ACPRIM ACR ACRITH ACSEC ADDCHK ADDENDEM ADDMSGD \"\nCALL PROCESS \" ADDNAME ADF ADHIN ADLIN ADM ADMGDF ADMINIS ADMN \"\nCALL PROCESS \" ADMOPUT ADMPRINT ADR ADRDMPRS ADRDSSU ADRS ADSMI \"\nCALL PROCESS \" ADUMP ADV ADY AEC AF AFF AFP AFPREFR AFPRINT AG \"\nCALL PROCESS \" AGIN AGRI-VET AGRICULT AGS AGVET AGVT AHnnnn AHC \"\n\nCALL PROCESS \" AHCINDT AHCLINE AHCMAIL AHCNETWORK AHCNOTE AHCPROF \"\nCALL PROCESS \" AHCSCORE AHCSTH AHCTABS AHCTECHS AHCXWTR AHDAILY \"\nCALL PROCESS \" AHDUMPnn AHF AHHEAD AHSYSLOG AHZIMxxx AI AJnnnn AL \"\nCALL PROCESS \" ALAB ALBANY ALIGNJCL ALLEN ALLMBRS ALLOEXIT \"\nCALL PROCESS \" ALOGRECA ALOGRECH ALPHALOW ALTCPy ALTCTL ALTPARM \"\nCALL PROCESS \" ALTRES ALTRNAME ALX AMASPZAP AMBLIST AMDPRDMP AMG \"\nCALL PROCESS \" AMI AMODE AMODGEN AMOLIA AMORG AMPBLK AMRF \"\nCALL PROCESS \" AMS AMSRCAT ANMP ANOPROC ANS ANSI ANSWR \"\nCALL PROCESS \" ANT AO AOR AP APA APAP APF APF-authorized APFLIB \"\nCALL PROCESS \" APFUA APFUD APHDRS API APL APOST APPsnn APPC \"\nCALL PROCESS \" APPLNAME APPN APPOVED APSWPROC APX APXCTL AR ARCnnn \"\nCALL PROCESS \" ARCxxx ARCCRIT ARCHCMDS ARCHIV ARCHIVEC ARCHPOOL \"\nCALL PROCESS \" ARCOS ARCPRINT ARCRESEX ARCRETPD ARCTEST ARCTSO \"\nCALL PROCESS \" ARCVSAM ARF ARFTERM ARJE ARMSTRONG ARSIN ARSYSTEM \"\nCALL PROCESS \" ARY ASAP ASCB ASI ASID ASIN ASIS ASKIP ASM ASS \"\nCALL PROCESS \" ASSETSNW ASSETSRC ASSOC ASSURANCE-DYES ASU ASYNCRTN \"\nCALL PROCESS \" ATBLINK ATC ATD ATMS ATP ATT ATTR ATTRCHAR ATTRIB \"\nCALL PROCESS \" ATZ AU AUL AUT AUTABLE AUTHIVP AUTOEXEC AUTOLOGN \"\nCALL PROCESS \" AUTOM AUTOTAB AUTOTEST AUX AUXLRY AVE AVOSS AVP \"\nCALL PROCESS \" AVPRPRT AYSYNC AZ AZO AZOPLATE Backgrnd Badders \"\nCALL PROCESS \" Bagg Bahama Baime Barbara Barletta Barry Bayport \"\nCALL PROCESS \" Beatrice Beatty Beckman Bedminster Bedminster-Aquet \"\nCALL PROCESS \" Bedminster-Internal Bedminster-SCG Beggs Behring \"\nCALL PROCESS \" Bejgrowicz Belgium Benefitse Benito Bergan Berilla \"\nCALL PROCESS \" Bernardino Bernie Bessie Beta-Max Betty Bi Bickford \"\nCALL PROCESS \" Biolsi Biomedical Bitting Blake Blvd Bolshevik \"\nCALL PROCESS \" BookManager BookMaster Borden Boston Bounpane \"\nCALL PROCESS \" Bradford Bradstreet Brady Branchburg \"\nCALL PROCESS \" Branchburg-Human Branchburg-Meister \"\n\nCALL PROCESS \" Brisbane Britain Britannia British Briton Broteau \"\nCALL PROCESS \" Brower Bruce Bruning Bruno Brunswick Brzycki Btu \"\nCALL PROCESS \" Buchanan Budgest Bulgaria Bunner Burbank Burchfield \"\nCALL PROCESS \" Burke Burnett Burroughs Burton Byerlee Byyyyy BAA \"\nCALL PROCESS \" BAB BAC BACCOUNT BACKME BACKRPT BACKUPDR BADIN BAE \"\nCALL PROCESS \" BAF BAL BALR BANN BARF BASDATA BASICDRN BASICF \"\nCALL PROCESS \" BASICRUN BASOBJ BASSM BAYPORT BAYPRT BB BB-M \"\nCALL PROCESS \" BB-M-Purchasing BB-T BBA BBB BBBBBBBBBB BBBBBBBBBBB \"\nCALL PROCESS \" BBBBBBBBBBBB BBC BBE BBF BBLOCK BBOP BBURG BC BCD \"\nCALL PROCESS \" BCK BCKxxx BCREATOR BD BDAM BDD BDI BDT BEGCOL \"\nCALL PROCESS \" BFRUSE BFT BG BGU BI BIC BILLBACK BILLBACKBLDG \"\nCALL PROCESS \" BIMED BIMEDT BING BIRTHD BIRTHDATE BISAM BKEND BKP \"\nCALL PROCESS \" BKUP BKUPnn BLDGA BLDGD BLDGO BLKCNT BLKSI BLKSIZ \"\nCALL PROCESS \" BLKSZ BLOCKTEST BLP BMC BMDP BMDPLOAD BMDPOPEN BMP \"\nCALL PROCESS \" BMPs BMPMSGRQ BMPSYSCH BMS BMSGRQ BN BNAME BO BOCON \"\nCALL PROCESS \" BOMP BOTTOMKP BPAM BPF BPTAGSA BR BREAKSTA BREK BRG \"\n\n\nCALL PROCESS \" BSB BSB-Fine BSIZ BSIZE BSM BSYSCHG BTAM BTAM-ES \"\nCALL PROCESS \" BTAM-ES BTS BTU BTYPE BU BUF BUFFERRED BUFFERSPACE \"\nCALL PROCESS \" BUFFSIZE BUFNO BUFOFF BUFSIZE BUFSP BUGSDOC BUGSIBM \"\nCALL PROCESS \" BUGSIBMX BUMMDDYY BW BWDFM BXBV BXCX BXLH BXLL BXLR \"\nCALL PROCESS \" BXRH BXTV BXUL BXUR BXVT BZ C-H C-H-R Caesar Cal \"\nCALL PROCESS \" Calbiochem Calif California Callas Campbell Campsen \"\nCALL PROCESS \" Canada Canon Capex Carl Carley Carlo Carnegie Carol \"\nCALL PROCESS \" Carole Carolina Caroline Cary Caserta Casserta \"\nCALL PROCESS \" Catawba Catherine Cathy Cel Celanese Celeste \"\nCALL PROCESS \" Celriver Celtran Centre Centrex Cericola Cesari \"\nCALL PROCESS \" Cevallos Chablis Chad Charlene Charles Charlotte \"\nCALL PROCESS \" Chatham Chem Chesapeake Chester Chet Chicago China \"\nCALL PROCESS \" Chisholm Chk Chow Chris Christi Chrysler Cichetti \"\nCALL PROCESS \" Cindy Cladek Clara Clark Clarkwood Clemons Clifton \"\nCALL PROCESS \" Cobol Colgate Colinas Colodner Colorado Comdisco \"\nCALL PROCESS \" Commtrack Comp Computer-Graphics CompuServ \"\nCALL PROCESS \" Con-nect-i-cut Consultative Cornelius Costa \"\nCALL PROCESS \" Coventry Craig Crocco Cromartie Crosby Crtform Ctlr \"\nCALL PROCESS \" Cursr Custom-Built Customiz Cynthia CA-FINPLAN \"\nCALL PROCESS \" CA-UCANDO CACHOFF CACHON CACHSTAT CADAM CAEDS CAGRP \"\nCALL PROCESS \" CAI CAIDLIB CAILIB CAIM CAISRC CAITGT CALBIOCHEM \"\nCALL PROCESS \" CALCDATE CALLE CALLERR CALLFUNC CAMI CAPEIND CAPEX \"\nCALL PROCESS \" CAROL CAS CASXA CATnnnn CATxxxx CATALOGn CATALOGB \"\nCALL PROCESS \" CATDISP CATIA CATLG CATRES CB CBADATA CBADEC CBAINT \"\nCALL PROCESS \" CBALEN CBASTR CBC CBCVSE CBDS CBIPO CBPDO CBT CCAGF \"\nCALL PROCESS \" CCD CCF CCG CCHAR CCHH CCHHR CCITT CCM CCS CCSS CCU \"\nCALL PROCESS \" CDATE CDELSQST CDINCR CDMsnn CDRM CDRMs CDRMS CDRSC \"\nCALL PROCESS \" CDSEQ CDSSNNN CDT CDU CE CEs CEC CELANESE CELMEX \"\nCALL PROCESS \" CEMT CEO CEPT CER CERES CERTCNT CERTDT CF CFF CFO \"\nCALL PROCESS \" CG CHA CHAN CHANGER CHARLES CHARLOT CHARTST CHD CHE \"\nCALL PROCESS \" CHECKDUP CHECKPT CHECKSUM CHEMPLAS CHGA CHGALL CHGB \"\nCALL PROCESS \" CHGC CHGD CHK CHKLIST CHKLNK CHKNO CHKPT CHMOEX \"\nCALL PROCESS \" CHNGZONE CHP CHPID CHPIDs CHPIDS CHPRECVY CHR CHRON \"\nCALL PROCESS \" CHV CIC CICS CICSz CICSBMS CICSCOB CICSPARS CICSPLI \"\nCALL PROCESS \" CIM CIP CIPREC CIS CISMAN CISPROD CISTEST CISZ \"\nCALL PROCESS \" CJnnnn CJOB CKD CKNO CKPT CKPTDEF CKPTLINE CKPTMODE \"\nCALL PROCESS \" CKPTPAGE CKPTPGS CKPTSEC CLEANCNT CLEANDT CLG CLGP \"\nCALL PROCESS \" CLIN CLISTHLP CLN CLOSFILE CLP CLS CLSDST CLW \"\nCALL PROCESS \" CMDLIB CMDPRINT CMOS CMPR CMR CMRSCS CN CNCL CNM \"\nCALL PROCESS \" CNSL CNSTR CNTR COB COBBAT COBCMD COBDLI COBLIB \"\nCALL PROCESS \" COBMAP COBOL COBOPT COBSKEL COBU COBUC COBUCG \"\nCALL PROCESS \" COBUCL COBUCLGP COBUCLP CODA CODEPGX CODEXOLD \"\nCALL PROCESS \" COLODNER COLPAGE COMIN COMM COMMANDxx COMMNAD \"\nCALL PROCESS \" COMMNDxx COMP COMPAS COMPDATE COMPILETIME COMPIOPT \"\nCALL PROCESS \" COMPLDT COMPLIBS COMPOPT COMPPLI COMPRESSOR \"\nCALL PROCESS \" COMPZONE CONCT COND CONFIGR CONLIST CONN CONTIG \"\nCALL PROCESS \" CONTROLD CONTROLINTERVALSIZE CONTROLM CONVPARM \"\nCALL PROCESS \" COPER COPICS COPIS COPT COPTC COPTCL COPTCLG \"\nCALL PROCESS \" COPTIMS COPYMAN COPYMOD COPYPRD COPYPRO COREDUMP \"\nCALL PROCESS \" CORPACCT CORPTAX COSnnn COSMOS COSTACCT COSTDATA \"\nCALL PROCESS \" CPa CPb CPx CPy CPF CPI-C CPI-C CPLOAD CPM \"\nCALL PROCESS \" CPU-to-CPU CPUs CPUAD CPUS CPX CPXCSL CPXMOPTS \"\nCALL PROCESS \" CPXMRPTS CPXMSNAP CPXOPT CPXTnnnn CPXTxxxx CPXTIMSV \"\nCALL PROCESS \" CPY CPYLIB CRDAT CREDT CRH CRI CRJE CRP CRPROW CRT \"\nCALL PROCESS \" CRTMSGF CRYPTO CSA CSALIMIT CSDB CSERV CSG CSI CSMT \"\nCALL PROCESS \" CSP CSQUEEZE CSRPOS CSRROW CSSF CSSN CSTALCDS \"\nCALL PROCESS \" CSTALCLS CSTALCSY CSTEP CSTMTA CSTRETCH CSTU CSU \"\nCALL PROCESS \" CTC CTCs CTCA CTDATE CTDATES CTIME CTLCARD CTLCARDS \"\nCALL PROCESS \" CTMI CTNL CTR CTRNO CTW CTWED CTY CU CUA CUNIT CURR \"\nCALL PROCESS \" CUS CUSTMVSP CUSTREFA CUSTSVC CUSTVMSP CUTOFWED CUU \"\nCALL PROCESS \" CVAF CVOL CVT CVTSHRVM CVTUCBA CVTUSER CW CWA CWED \"\nCALL PROCESS \" CXI CXS CY CYLAD CYLOFL CYLOV Dahlin Dale Dallas \"\nCALL PROCESS \" Damone Dan Daneshfar Daniel Danny Datacomm \"\nCALL PROCESS \" Datamaster Datapro Dave David Dawson Debbie Deborah \"\nCALL PROCESS \" Decatur Delaware Deltak Dematos Denmark Deremer \"\nCALL PROCESS \" Dermatop Devin-Adair Devlin Dewerth DeRemer Diana \"\nCALL PROCESS \" Diane Diazo Dick Dickey Disoss Displaywrite \"\nCALL PROCESS \" Displaywriter DisplayWrite Dk Dnnnn Doaks Dobbins \"\nCALL PROCESS \" Dominguez Donna Donohue Doreen Doremus Dormanski \"\nCALL PROCESS \" Douglas Drawtwist Dreyfus Drp Dua Dun Durel DuPont \"\nCALL PROCESS \" Dyyzz DAA DACOS DACU DADSCLASS DADSM DADSOR DADSORT \"\nCALL PROCESS \" DADSPLUS DADSRT DADX DADY DAIR DALJCL DALJOBS \"\nCALL PROCESS \" DALLETE DALPFOC DALPSTOP DALTFOC DALTSTOP DANESHFA \"\nCALL PROCESS \" DARCOS DARSIN DASDnn DASDxx DASDADM DASDERR \"\nCALL PROCESS \" DASDEXCP DASDMON DASDMOON DASDPOOL DASPLUS DATAFIL \"\nCALL PROCESS \" DATAGEN DATAID DATAPRO DATATEST DATECD DATEDIFF \"\nCALL PROCESS \" DATEX DATIME DATSETS DAVE DAVETONE DAVID DAVSCALE \"\nCALL PROCESS \" DAYDIFF DAYLIB DAYOFWK DAYSMFR DBase DBA DBA's DBCS \"\nCALL PROCESS \" DBCTL DBDA DBDC DBDEF DBDGEN DBDLIB DBDNAMEA \"\nCALL PROCESS \" DBDNAMEX DBEDIT DBEDITP DBIL DBMAUI DBMS DBR DBRCP \"\nCALL PROCESS \" DBRM DBRMLIB DBS DBSP DBT DBUSS DC-DDP DCA DCB \"\nCALL PROCESS \" DCBDDDDDDDDDD DCBEOBW DCBOFLGS DCBOPTA DCBOPTB \"\nCALL PROCESS \" DCBOPTC DCBOPTCD DCBOPTE DCBOPTF DCBOPTH DCBOPTI \"\nCALL PROCESS \" DCBOPTL DCBOPTM DCBOPTO DCBOPTQ DCBOPTR DCBOPTT \"\nCALL PROCESS \" DCBOPTTO DCBOPTU DCBOPTUF DCBOPTW DCBOPTY DCBOPTZ \"\nCALL PROCESS \" DCC DCE DCF DCFCLIST DCFDSAG DCFDSAGM DCFDUCK \"\nCALL PROCESS \" DCFINDEX DCFJCLDU DCFJCLPC DCFJJCL DCFJONLY DCFLENG \"\nCALL PROCESS \" DCFMAN DCGEN DCK DCLASS DCLGEN DCLGENS DCM DCMS DCQ \"\nCALL PROCESS \" DCT DCTI DDATA DDCAT DDDD DDDEFs DDDEFS DDM DDMCAT \"\nCALL PROCESS \" DDP DDPT DDR DDS DDSRV DDY DDYY DEERFLD DEFALIAS \"\nCALL PROCESS \" DEFDDIR DEFPAGE DEFSWAP DEFVSOP DEHSA DEL-C \"\nCALL PROCESS \" DELAWARE DELETESTA DELPAGE DELSQST DELSWAP DELTAK \"\nCALL PROCESS \" DENVER DEQ DER DERSQNM DES DESC DESKCALC DESTID \"\nCALL PROCESS \" DESTIDs DESTRYDT DET DEVICETYPE DEVT DFDS DFDSS \"\nCALL PROCESS \" DFEF DFH DFHBMSMM DFHDUP DFHPC DFHSM DFHTC DFNAME \"\nCALL PROCESS \" DFP DFSMS DFSORT DFSUDUMP DFSURIDX DFSVSAMP \"\nCALL PROCESS \" DFSXXXXX DFT DFU DG DGN DHCF DHR DIA DIAGFILE \"\nCALL PROCESS \" DIALSURV DICT DIDX DIF DIFF DII DINDEX DIPPIE \"\nCALL PROCESS \" DIREDIT DIRMAINT DIRMDOWN DIRPARM DIRSTAT DIRVSPC \"\nCALL PROCESS \" DIRVSPCX DISA DISKcx DISKnn DISKnx DISKxx DISKACNT \"\nCALL PROCESS \" DISKC DISKCn DISKCx DISKVn DISKVx DISKVA DISKVB \"\nCALL PROCESS \" DISKVC DISKVD DISKXn DISSOS DISSPLA DIST DISTRS \"\nCALL PROCESS \" DIVDESC DIVLUKUP DJnnnn DL DLBL DLDDPCC DLF DLG DLI \"\nCALL PROCESS \" DLIBs DLIBACK DLIBATCH DLIBTCH DLIHDRL DLIHDUL \"\nCALL PROCESS \" DLILIB DLIMAGE DLIPRG DLIPRR DLIPRU DLIRECV DLISASP \"\nCALL PROCESS \" DLITEST DLIWRK DLM DLMDMSDMSTSO DLN DLSE DLTX DLY \"\nCALL PROCESS \" DLZ DLZACT DLZDLTXX DMAP DMAS DMB DMDPOPEN DMJ \"\nCALL PROCESS \" DMJnnnn DMN DMNDSET DMP DMPn DMPNCPU DMSnnn DMSxx \"\nCALL PROCESS \" DMSxxx DMSADM DMSBACK DMSCLASS DMSCUT DMSERR \"\nCALL PROCESS \" DMSFORM DMSLIST DMSLISTD DMSN DMSOS DMSPOOL \"\nCALL PROCESS \" DMSPOOLS DMSPROJ DMSREST DMSTABLE DMSUTIL DMSVSAM \"\nCALL PROCESS \" DMXDBD DNAME DOB DOC DOCC DOCID DOCIT DOCLIST DOCS \"\nCALL PROCESS \" DOM'D DOS DOSCMD DOSF DOSRES DOSVSDMP DP DPCMPARE \"\nCALL PROCESS \" DPCX DPM DPPX DPR DPS DPXCTL DQUOTE DRD DRDsxxnn \"\nCALL PROCESS \" DRDA DRDS DREISAM DRESKEEP DRESTORE DROPDUMP DRPAY \"\nCALL PROCESS \" DSnnnn DSA DSAB DSAG DSBCATEG DSBUSERD DSC DSCL DSD \"\nCALL PROCESS \" DSDR DSDUMP DSE DSECT DSERV DSF DSFORM DSINDEX DSK \"\nCALL PROCESS \" DSKxxx DSL DSList DSLIST DSLO DSMGMT DSMPROFS \"\nCALL PROCESS \" DSMUTMSG DSMXMP DSNn DSNCAPEX DSNDELETE DSNHCOB \"\nCALL PROCESS \" DSNHPLI DSNHSPU DSNINDEX DSNTABLE DSNTIAR DSNUPROC \"\nCALL PROCESS \" DSO DSPLTCEL DSQQMFE DSS DSSA DSSFNN DSSFNNMM \"\nCALL PROCESS \" DSSNNNM DSSNNNN DSSREST DSSTAP DSSTNNN DSSXXXXX DSU \"\nCALL PROCESS \" DSUCATLGY DSUTIL DSUTILSQN DSX DTnnnn DTE DTESTCPU \"\nCALL PROCESS \" DTESTPC DTMS DTS DTSFILE DTSUTIL DUADDT DUAL-DEN \"\nCALL PROCESS \" DUDUDU DUMPnn DUMPxx DUMPA DUMPDIR DUMPDS DUMPEND \"\nCALL PROCESS \" DUMPERn DUMPMASTER DUMPON DUMPPACK DUMPQ DUMPSTAT \"\nCALL PROCESS \" DUMPTAP DUPKEY DUPREC DUREL DVA DVC DVCDN DVCUP DVD \"\nCALL PROCESS \" DVG DVGFID DVGFILEI DVGFILEO DVGFIT DVGFOD DVGFOT \"\nCALL PROCESS \" DVGINCLUDE DVH DVL DVM DVR DW DXT DYN DYNAL DYNAM \"\nCALL PROCESS \" DZDDPDC DZS E-Mail Easter Easytrev Easytrieve \"\nCALL PROCESS \" Edison Edward Edwards Effler Eileen Elaine Electret \"\nCALL PROCESS \" Elizabeth Ellen Ellyce End-of-da Enercell Eng \"\nCALL PROCESS \" Enterprise-wide Epd Esmond Esock Esposito Estelle \"\nCALL PROCESS \" Europe European Evans Execucom Exmpl Exten ExSel \"\nCALL PROCESS \" EAN EASYMOVE EASYTREIVE EASYTREV EASYTRIEVE EB \"\nCALL PROCESS \" EBCDIC EBCIDIC EC ECF ECLEV ECLIST ECODEPTR ECPS \"\nCALL PROCESS \" EDATE EDCHEK EDD EDF EDI EDITCHEK EDITISPF EDITMAC \"\nCALL PROCESS \" EDITOL EDITPAGE EDITPR EDITSOPF EDITSOPS EDITXXXX \"\nCALL PROCESS \" EDL EDON EDREC EDS EDSSNNNX EDT EDTGEN EDTGENs EDX \"\nCALL PROCESS \" EE EEEE EEEEEEEEEEEPPPPPPPP EFFECTOR EHSA EIA EIB \"\nCALL PROCESS \" EIS ELEM ELNE ELTERM EM EMER EMERG EMIMS EML EMOD \"\nCALL PROCESS \" EMP EMPLOYEENAME EMPNAME EMU EN ENA ENAMDLCD ENCO \"\nCALL PROCESS \" ENCO's ENCOxx ENDDATA ENDFILE ENDIF ENDJOB ENDMONTH \"\nCALL PROCESS \" ENDO ENDPAGE ENDQTR ENG ENGR ENQ ENQF ENV EOD EOF \"\nCALL PROCESS \" EOS EOTSPACE EOV EP EPA EPIFILE EPLOAD EPS EQU \"\nCALL PROCESS \" EQUALTO EQUFLAG EQUIV ERE EREP ERF ERFC ERG ERISA \"\nCALL PROCESS \" ERN ERNs ERP ERRORLIMIT ES ESA ESADEV ESCON ESDS \"\nCALL PROCESS \" ESHA ESMOND ESOP ESS ESSL ESTAE ESYS ETESTCPU \"\nCALL PROCESS \" ETESTPC ETHS ETSS EUC EUROPE EXAMP EXCPVR EXDC \"\nCALL PROCESS \" EXECUTIL EXEMPTSO EXLST EXP EXPDSN EXPDSNS EXPDT \"\nCALL PROCESS \" EXPDTUSE EXPERMNT EXPRT EXPVOLS EXTABLE EXTWRITE \"\nCALL PROCESS \" Fairfield Falcon Falk Fareed Faynin Feb Filesave \"\nCALL PROCESS \" Finland Finley Fischer Fisher Fixform Flansburg \"\nCALL PROCESS \" Florence Fluor-Daniels Fm Fontana Foregrnd Fortex \"\nCALL PROCESS \" Fortran Fortron Fran France Frances Francisco \"\nCALL PROCESS \" Franklin Fred Fri Fullerton Fwd FA FAC FALC FALCON \"\nCALL PROCESS \" FALCONB FAS FASTCOPY FASTRES FASTREST FAX-AKRON \"\nCALL PROCESS \" FAX-ATLANTA FAX-AUBURN FAX-BAY FAX-BAYPORT \"\n\nCALL PROCESS \" FAX-BUCKS FAX-BURBANK FAX-CHARLOTTE FAX-CHATHAM \"\nCALL PROCESS \" FAX-CLEAR FAX-CORPUS FAX-COVENTRY FAX-DALLAS \"\nCALL PROCESS \" FAX-EDISON FAX-FAIRFIELD FAX-FLORENCE FAX-GREER \"\nCALL PROCESS \" FAX-HOUSTON FAX-INDIANAPOLIS FAX-IRVING FAX-LONG \"\nCALL PROCESS \" FAX-LOS FAX-MOUNT FAX-NARROWS FAX-NEW FAX-NEWARK \"\nCALL PROCESS \" FAX-PAMPA FAX-PHOENIX FAX-PORTSMOUTH FAX-RANCHO \"\nCALL PROCESS \" FAX-ROCK FAX-SALISBURY FAX-SCHILLER FAX-SHELBY \"\nCALL PROCESS \" FAX-SHORT FAX-SPARTANBURG FAX-SUMMIT FAX-TIGAR \"\nCALL PROCESS \" FAX-WALNUT FAX-WASHINGTON FAX-WEST FAX-WESTLAKE \"\nCALL PROCESS \" FAX-WOODDALE FBA FBADAT FBADEC FBAINT FBALEN FBAS \"\nCALL PROCESS \" FBK FBM FBS FBSA FBSM FC FCL FCOPY FCT FD FDATE \"\nCALL PROCESS \" FDEFLIB FDISK FDM FDMTODO FDR FDRDMP FDRDSF FDRRPT \"\nCALL PROCESS \" FEFORE FEOV FET FETCHABLE FF FFFF FFFFFFFF FFPRINT \"\nCALL PROCESS \" FFT FFTDCA FG FGC FH FHACCT FIBERTST FIBR FIELDNAME \"\nCALL PROCESS \" FILEnn FILEnnn FILEA FILEB FILEC FILECNT FILECONV \"\nCALL PROCESS \" FILECOPY FILEDEF FILELST FILESZ FILETRAN FILPRINT \"\nCALL PROCESS \" FILSZ FINIS FIOA FIPS FIXLI FIXP FIXPI FIXQUOTE \"\nCALL PROCESS \" FIXSCRP FL FLASHTST FLD FLGS FLIST FLOC FLPA \"\nCALL PROCESS \" FLUOR-DANIELS FMID FMIDs FMT FNAM FNCHK FNEND \"\nCALL PROCESS \" FOCDEF FOCEXEC FOCNET FOCSU FOCTEL FOCUSCDB \"\nCALL PROCESS \" FOCUSDUP FOCUSEND FOCUSPDN FOCUSPUP FOCUSTDN \"\nCALL PROCESS \" FOCUSTUP FONTPS FONTSNU FORMCHAR FORMDEF FORMDEFS \"\nCALL PROCESS \" FORTEX FORTHCLG FORTLIB FORTRAN FORTRON FORTX \"\nCALL PROCESS \" FORTXCLG FOUT FP FPARM FPASSES FPS FR FREESPACE \"\nCALL PROCESS \" FRIDEN FRMT FROMADDR FROMADDRESS FROMDEV FROMKEY \"\nCALL PROCESS \" FROMLOC FRU FRV FRVolumes FS FSBROWSE FSEQN FSI \"\nCALL PROCESS \" FSINN FSM FSN FSP FSS FSSDEF FSSNAME FSTOP FTnnFxxx \"\nCALL PROCESS \" FTABLE FTABLES FTAM FTCLOSE FTDDDNNN FTDSSNNN \"\nCALL PROCESS \" FTERASE FTINCL FTOPEN FTP FTPAHC FTPCFO FTPRECV \"\nCALL PROCESS \" FTPSEND FTPSUB FV FWA FYI Gaitrie Galloway Galski \"\nCALL PROCESS \" Garamond Garczynski Gard Garde Garnett Geo George \"\nCALL PROCESS \" Georgia Gerard German Germany Gianneschi Giardina \"\nCALL PROCESS \" Gil Gilbert Gilday Gildea Girardy Gladstone \"\nCALL PROCESS \" Glenford Glenn Glenoaks Gloria Goforth Goldberg \"\nCALL PROCESS \" Gordon Govt Graeme Graf Grambor Greco Greek \"\nCALL PROCESS \" Greenwich Greer Gregorian Gregory Gribben Griffin \"\nCALL PROCESS \" Griswold Grp Gruenling Gwen Gwendolyn GA GAESDA \"\nCALL PROCESS \" GALI GALLARY GAM GB GBnn GBL GCR GCS GCSRECOV GDBS \"\nCALL PROCESS \" GDDM GDF GDG-ALL GDGs GDQF GDR GDS GE GE's GEISCO \"\nCALL PROCESS \" GEISCO's GENACCT GENCD GENCDX GENCYCLE GENER \"\nCALL PROCESS \" GENERATIONDATAGROUP GENJCL GENLIB GENLIBA GENTIME \"\nCALL PROCESS \" GETFILE GETJFCB GETMAIN GETMAINed GETMAINS GETMSG \"\nCALL PROCESS \" GETPARM GETPRM GETRC GFC GLBLZONE GLLOGFL GLREPT \"\nCALL PROCESS \" GLWTR GM GMCRAE GMLDOC GMT GNA GOBACK GONUMBER \"\nCALL PROCESS \" GOODBYE GOSTMT GOSUB GOTO GOVT GP GPAR GPARS GPG \"\nCALL PROCESS \" GPSS GRAF GREDATE GREER GROUPID GROUPNAME \"\nCALL PROCESS \" GRP GRS GSAM GSC GSL GTnn GTF \"\nCALL PROCESS \" GTFIVP GTFPARS GTFTSO GTFVTAM GTX GW-BASIC GWM H-R \"\nCALL PROCESS \" Hal Hank Hany Hardwarea Harmon Harold Harris \"\nCALL PROCESS \" Harrison Hartmann Hathaway Hayes Haynes Headley \"\nCALL PROCESS \" Headly Hebrew Heimsch Hel Helen Henderson Henry \"\nCALL PROCESS \" Herbein Herbel Hercules Hewlett Hewlett-Packard \"\n\nCALL PROCESS \" Hofer Hoffman Holland Holly Hollywood Hong Houghton \"\nCALL PROCESS \" Houston Howard Hreno Huber Hughes Huhn Hungary \"\nCALL PROCESS \" Huntsman Hz HANDBK HARDCPY HASP HASPnnn HASPxx \"\nCALL PROCESS \" HASPACE HASPCn HASPCKPT HASPPARM HASPPRPU HASPXEQ \"\n\n\nCALL PROCESS \" HCF HCLOGO HCPRIO HCPSYS HCPXA HCRC HCSM HD-RELOAD \"\nCALL PROCESS \" HD-UNLOAD HDA HDAM HDC HDDI HDLC HDREFID HDSSNNNX \"\nCALL PROCESS \" HELPPLI HEXIT HEXSHOW HF HFI HI-RISE HIDAM HIPO \"\nCALL PROCESS \" HISAM HISTORYX HJnnnn HLL HLP HMBLIST \"\n\nCALL PROCESS \" HOT-I HPC HPI HPO HPPLUS HPWORD HRAV HRDCOPY HRE \"\nCALL PROCESS \" HRJE HRP HRPI HRPI-Business HRPI-BUSINESS \"\nCALL PROCESS \" HRPI-Customer HRPI-CUSTOMER HRPI-President \"\nCALL PROCESS \" HRPI-Purchasing HRPI-PRESIDENT HRPI-PURCHASING \"\nCALL PROCESS \" HRPI-Training HRPI-TRAINING HS HSAM HSM HSS HST \"\nCALL PROCESS \" HUBMVS HUM HUNTMAN HUNTSMAN HVAC HY Ilch Illinois \"\nCALL PROCESS \" ImagePlus Inc Ind India Indianapolis Inds Infodata \"\nCALL PROCESS \" Init Innn Int'l Interceptor Intra Iran Iraq Ireland \"\nCALL PROCESS \" Irving Italy Ixx Ixxxxxxx IBB IBM IBM's IBMIN \"\nCALL PROCESS \" IBMMAIL IBMNET IBMPCYT IBMSUPP IC ICA ICAsnn ICCF \"\nCALL PROCESS \" ICD ICEF ICF ICFDEL ICFDIAG ICFDSS ICFEXP ICFLOC \"\nCALL PROCESS \" ICFLOCK ICFREST ICFRU ICFSMF ICFUNLK ICH ICHETEST \"\nCALL PROCESS \" ICKDSF ICOM ICOPY ICP ICQADMIN ICROFGIS ICU \"\nCALL PROCESS \" ICVARXNT IDAM IDATE IDBACKUP IDCAMS IDD IDDU \"\nCALL PROCESS \" IDFSTWPM IDIS IDRC IDRDATA IDSN IDSNXUPD IDTF IDU \"\nCALL PROCESS \" IEAxxx IEAIPSnn IEB IEBCOMPR IEBCOPY IEBDB IEBDG \"\nCALL PROCESS \" IEBEDIT IEBGENER IEBIMAGE IEBPTPCH IEBUPDTE IEC \"\nCALL PROCESS \" IECIEXPL IECUC IEFRDER IEFRDSN IEHDASDR IEHLIST \"\nCALL PROCESS \" IEHMOVE IEHPROGM IEHPROGRM IEIF IEUSERxx IEXEXT \"\nCALL PROCESS \" IEXEXTBL IEXEXTCD IEXFLAG IEXFLAGS IEXFUN IEXUCB \"\nCALL PROCESS \" IEXVIO IFs IFA IFBxxx IFILE IFIX IFPS IFPSSAVE IGES \"\nCALL PROCESS \" IGG IHALIST IHAUCB IIAS IIPS IISVTAM IJOB IJSYSRS \"\nCALL PROCESS \" IJZADOLT IKJ IKJEB IKJEBCY IKJEBMIN IKJEFTSR IL \"\nCALL PROCESS \" ILLINOIS IMAGELIB IMAGEPLUS IMD IMDS IMGDSN IMIMS \"\nCALL PROCESS \" IML IMLed IMMCLOSE IMMED IMS-PSBGEN IMSA IMSAC \"\nCALL PROCESS \" IMSACCUM IMSADF IMSAOMEG IMSBACK IMSBATCH IMSBKOUT \"\nCALL PROCESS \" IMSCOBOL IMSCTL IMSDLI IMSGENS IMSHDRLD IMSHDULD \"\nCALL PROCESS \" IMSHSRLD IMSHSULD IMSID IMSIMAGE IMSIMG IMSLOG \"\nCALL PROCESS \" IMSLOGRC IMSMON IMSPARC IMSPARS IMSPCB IMSPREOR \"\nCALL PROCESS \" IMSPRES IMSRnn IMSRECOV IMSRECV IMSRES IMSSYS IMST \"\nCALL PROCESS \" IMSTARC IMSTEST IMSTOMEG IMSVS IMSX IMSXXXVS INCM \"\nCALL PROCESS \" INCREMEN IND INDD INDEXC INDEXIF INDEXREC INDEXTEST \"\nCALL PROCESS \" INDEXTP INDX INFDS INFMJF INFOnnn INFOCOM \"\nCALL PROCESS \" INFOExpress INFOINDX INFOLIB INFOMVS INFOSCRP INIT \"\nCALL PROCESS \" INITDISK INITI INITIMG INMXPARM INNOV INP INPRIM \"\nCALL PROCESS \" INQ INR INT INT'L INV INVENTRY IO IOA IOCDS IOCDSM \"\nCALL PROCESS \" IOCHECK IOCMDF IOCP IOERR IOF IOFIOF IOFLIST IOFS \"\nCALL PROCESS \" IOFTEST IOGEN IOGENs IOGENOLD IOPCB IORECL IOV IOVX \"\nCALL PROCESS \" IOVXP IP IPA IPCS IPDT IPF IPL IPL'd IPLed IPLing \"\nCALL PROCESS \" IPLs IPLG IPLGVVE IPO IPOEIVP IPORES IPSTART IRA \"\nCALL PROCESS \" IRAxxxI IRB IRLMPROC IRLMPROD IRMA IRPT ISA ISAM \"\nCALL PROCESS \" ISASIZE ISBN ISC ISDN ISER ISG ISO ISP ISP@MSTR \"\nCALL PROCESS \" ISPCMDS ISPEXEC ISPF-EDIT ISPFs ISPFD ISPFILE \"\nCALL PROCESS \" ISPFINDX ISPFPDF ISPFT ISPLINK ISPLIST ISPLLIB \"\nCALL PROCESS \" ISPLOAD ISPLOG ISPPROF ISPRSI ISPSTART ISPTABL \"\nCALL PROCESS \" ISPTASK ISPTLIB ISPTSC ISPTUTOR ISPVM ISR ISRBRO \"\nCALL PROCESS \" ISRCLIB ISRCMDS ISREDIT ISREDRTS ISREORG ISRLCFIL \"\nCALL PROCESS \" ISRLFMPP ISRLOAD ISRLPCPY ISRTSP ISSCO ITR ITSRRC \"\nCALL PROCESS \" IUNIT IVL IVLxxx IVLR IVLRLEN IVLRMA IVLRNAME \"\nCALL PROCESS \" IVLRTG IVLSEND IVLSMMSG IVLSMPRM IVLSP IVLSPACE \"\nCALL PROCESS \" IVLSPALT IVLSPDEN IVLSPFLD IVLSPMA IVLSPNTB IVLSPP \"\nCALL PROCESS \" IVLSPVLN IVLSPVNO IVLSPVOL IVLSVARY IVP IXF IXMAINT \"\nCALL PROCESS \" IXUPDATE IXX Jacobs Jacobsen James Jan Jane Japan \"\nCALL PROCESS \" Japanese Jeff Jeffers Jeffrey Jepson Jernigan Jerry \"\nCALL PROCESS \" Jersey Jim Jo Joan Joaquim Joe John Johnson Jolla \"\nCALL PROCESS \" Jones Jordan Jose Joseph Jr Juan Juarez Judith Judy \"\nCALL PROCESS \" Jul Juliet Julius Jumba Jun Jus Jxxxx JA JACCT JBB \"\nCALL PROCESS \" JCLcontd JCLscan JCLACT JCLARC JCLARCH JCLCOM \"\nCALL PROCESS \" JCLCONTD JCLG JCLGVE JCLIN JCLLIB JCLLIST JCLONLY \"\nCALL PROCESS \" JCLSAFE JCS JCT JDS JDUTY JE JECL JECODE JENTRY JEP \"\nCALL PROCESS \" JESA JESANODE JESDS JESPARMS JFCB JFK JJ JK JMSG \"\nCALL PROCESS \" JNF JNM JNUM JOBDEF JOBLIB JOBLOG JOBN JOBNUM \"\nCALL PROCESS \" JOBPARM JOENUM JOHN JOHNSON JRn JSI JSIRPG JSIRPT \"\nCALL PROCESS \" JSISAVET JSISLCT JSTA JT JTn JTS JULADD JULDATE \"\nCALL PROCESS \" JULDIFF JULIANX JUNKDU JUNKESX JUNKPIC JWK JWKFILE \"\nCALL PROCESS \" Kaiser Kaminski Kanji Karen Karl Karpen Katakana \"\nCALL PROCESS \" Kathy Katie Kaushik Keebler Keich Kelly Kemeny Ken \"\nCALL PROCESS \" Kennedy Kerry Kevin Kilgore Kim Kirkland Kizer \"\nCALL PROCESS \" Kodak Kong Korea Korinna Kristin Krynski Kuper \"\nCALL PROCESS \" Kurtz Kuwait KxxxxxxL KA KARLIS KB KEEPDT KENNEDY \"\nCALL PROCESS \" KEYLEN KEYPLUS KEYPOINT KL KLM KN KNAPSACK KSDS KSL \"\nCALL PROCESS \" KWI KWIC KWJ KY KYBD La Lacko Lajolla Landes Larry \"\nCALL PROCESS \" Larsen Las Laurel Lavin Laye Lazerson LaJolla Lee \"\nCALL PROCESS \" Lees Legent Lehigh Leo Leominster Levine Lewis Liaw \"\nCALL PROCESS \" Lic Lilo Lima Linda Lindner Linehan Lisa Locational \"\nCALL PROCESS \" Lorraine Los Louisiana Lugenbeel Lyall Lynn \"\nCALL PROCESS \" LABELxxx LABELALL LABELPRB LABELPTB LABELSB LABELSX \"\nCALL PROCESS \" LABEXEC LABLIBF LABLPRTB LABNX LABSEQ LAN LANGLVL \"\nCALL PROCESS \" LASTPAGE LASTUSED LAUREL LBASIC LBKG LBRUPDT LBS \"\nCALL PROCESS \" LCAsnn LCFIX LCHTAB LCXsnn LCYAD LDA LDATE LDDSUUUU \"\nCALL PROCESS \" LDDUUUUU LDU LEDG LF LIBDEF LIBDEFs LIBRCIS LIBRCOB \"\nCALL PROCESS \" LIBRLIB LIBSYM LIEBOW LIFO LIM LINECNT LINECT \"\nCALL PROCESS \" LINEDATA LINENO LINKAG LINKLST LINKSTRT LINPUT \"\nCALL PROCESS \" LISTC LISTCRA LISTD LISTDRFM LISTDUMP LISTER \"\nCALL PROCESS \" LISTIDR LISTIO LISTMEM LISTPDS LISTRP LISTV \"\nCALL PROCESS \" LISTVTOC LJnnnn LKED LLA LLC LLL LLMAX LLSET LM \"\nCALL PROCESS \" LMIN LMOD LMODs LMSAD LMSG LMU LNGTH LOA LOADBUF \"\nCALL PROCESS \" LOADERn LOADGO LOADPARM LOCsnn LOCKCP LOCKLP LOCKRS \"\nCALL PROCESS \" LODn LOGDSN LOGFILE LOGICCHG LOGLIST LOGLST LOGMODE \"\nCALL PROCESS \" LOGOTEST LOGTERM LON LOSANGL LOSTLIST LOTSAVE LOTUS \"\nCALL PROCESS \" LPALIB LPAMOD LPAR LPARS LPDA LPO LPRAD LPREC LR \"\nCALL PROCESS \" LRDA LRDB LRDC LRDD LRUY LS LSA LSG LSG-Credit \"\nCALL PROCESS \" LSG-Group LSG-Law LSI LTERM LTEST LTM LTORG LTRAD \"\nCALL PROCESS \" LTWA LU LUs LV LVL M-B-C-H M-B-C-H-R M-LOBBY Mac \"\nCALL PROCESS \" Mack Mackiewicz Maine Maiorelli Maliszewski Maltby \"\nCALL PROCESS \" Manchester Manville Marcia Margaret Maria Marietta \"\nCALL PROCESS \" Marilyn Markners Markowitch Markowitz Martha Martin \"\nCALL PROCESS \" Martowicz Marwick Mary's Maryann Massey Matlock \"\nCALL PROCESS \" Mattes Matthew Maugham Maxwell McFadden McAuto \"\nCALL PROCESS \" McCall McCliment McCullagh McDonald McDonnell \"\nCALL PROCESS \" McGee McMillan McMurtrie McR McRae \"\nCALL PROCESS \" McRitchie Mech Meister Mekjian Merrills Merriman \"\nCALL PROCESS \" Meryl Metonic Metta Mex Mexico Meyers Mgr Michael \"\nCALL PROCESS \" Michelle Mickey Microvax MicroVax MicroVAX MicroVMS \"\nCALL PROCESS \" Midilist Mifflin Mike Milltown Mimi Mink Misc \"\nCALL PROCESS \" Misner Mitch Mitchell Mittel Mktg Mockingbird Modi \"\nCALL PROCESS \" Modrowsky Mohammed Molina Mon Monaco Montrose \"\nCALL PROCESS \" Morelli Morino Morris Morrison MoveCopy Mr Mulhearn \"\nCALL PROCESS \" Mullen Mundy Murphy MxxxxxxL MA MACH MACLIB MACLIST \"\nCALL PROCESS \" MACXXP MAE MAICMS MAILBIN MAILDOC MAILROOM MAINMENU \"\nCALL PROCESS \" MAINSIZE MAINTP MAJNODES MANDMS MANFG MANLAB MANMVS \"\nCALL PROCESS \" MANRLAB MANUAL@@ MANUALSP MANUALX MAPC MAPICS MAPP \"\nCALL PROCESS \" MARCO MARKETGP MARKSTR MAS MASDEF MASPC MASSCOPY \"\nCALL PROCESS \" MASTinit MASTpic MASTuuuu MASTxxxx MASTCAT MASTDMCR \"\nCALL PROCESS \" MASTDMS MASTGSB MASTIN MASTRCVY MATCADD MATCHLIM \"\nCALL PROCESS \" MATSRV MAXCC MAXFLDS MAXLENGTH MAXLITS MAXNAME \"\nCALL PROCESS \" MAXPART MAXRECS MAXUSER MBBCCHH MBR MBRSCS MBS MCAA \"\nCALL PROCESS \" MCAUTO MCRAE MCRITCHIE MCS MD MDS MDT MEH MEM \"\nCALL PROCESS \" MEMNAMES MEMOPREF MEMOPROF MEMSYM MER MERGECOPY \"\nCALL PROCESS \" MERRILL MES MESSAGEX MFG MFI MFM MFORM MFS MFT MHz \"\nCALL PROCESS \" MI MICF MICHIGAN MICR MICROFCH MICSnn MICSxx \"\nCALL PROCESS \" MICSDAIL MICSDS MICSSUB MIDI MIDIDSN MIDILAST \"\nCALL PROCESS \" MIDILIST MIDITL MIDLIST MIH MILIKEN MIPS MISC MKTG \"\nCALL PROCESS \" MKTVOL MLIM MLPA MMDDYYA MMDDYYMMDDYY MMG MMM \"\nCALL PROCESS \" MMXDDXYY MN MNGT MNNXX MNSW MODBLK MODBLKS MODELDCB \"\nCALL PROCESS \" MODELDSC MODELSMF MODEREG MODETAB MODETABI MODI \"\nCALL PROCESS \" MODYYR MON MONs MORGEN MOS MOSFET MOVEBCD MOVEDT \"\nCALL PROCESS \" MOVEFILE MOVEIOPT MOVEOPT MPO MPP MPRIVATL MPS MPSX \"\nCALL PROCESS \" MPX MR MRCS MRJE MRO MRP MRS MRTG MSA MSC MSDS MSE \"\nCALL PROCESS \" MSGA MSGCLASS MSGF MSGIEHnnn MSGLEVEL MSGPRINT \"\nCALL PROCESS \" MSGSS MSGV MSNF MSO MSRJE MSS MSSC MSSE MSSF \"\nCALL PROCESS \" MSTCONS MSTR MSVGP MSWP MTC MTDSSNNN MTHNNnnn \"\nCALL PROCESS \" MTHOLLY MTLOGOFF MTO MULTI-SYSTEM MVC MVI MVLIB \"\nCALL PROCESS \" MVNBCD MVS MVSCAT MVSDLB MVSPA MVSPRD MVSPRDBK \"\nCALL PROCESS \" MVSPRDT MVSPROD MVSREPLY MVSSOFT MVST MVSTxx MVSTA \"\nCALL PROCESS \" MVSTC MVSTCn MVSTCx MVSTL MVSTLx MVSTP MVSTPn \"\nCALL PROCESS \" MVSTPx MVSTPB MVSTPP MVSTST MVSTSTT MVSTVn MVSTVx \"\nCALL PROCESS \" MVSTXn MVSX MVSXnn MVZBCD MWF MXG MXIG MYAPPL \"\nCALL PROCESS \" MYDATA Nancy Natale NaSpa Nbr Neal Neil Ness Netman \"\nCALL PROCESS \" NetView Neubauer Newark Newstate NewJersey Ni-Cd \"\nCALL PROCESS \" Nichols Nijah Nixdorf NnRn NnRr Non-NETWORK Norfolk \"\nCALL PROCESS \" Norway Nov Novick NumLk NumLock NA NAMECOND NAP \"\nCALL PROCESS \" NARECORD NASPA NATLABS NBD NBUF NC NCAPXC NCAPXD \"\nCALL PROCESS \" NCAPXT NCAPXZ NCC NCCF NCCFs NCL NCLISTAH NCLISTB \"\nCALL PROCESS \" NCLTPLIB NCP NCP's NCPnnn NCPs NCPsnn NCPsxx NCPxxx \"\nCALL PROCESS \" NCPATT NCPC NCPCxx NCPH NCPS NCPU NCPUxx NCPUXX \"\nCALL PROCESS \" NCPV NCPVARY NCPXXX NCTE NCTNL NDA NDT NEC NETCHK \"\nCALL PROCESS \" NETCTLB NETCTLF NETCTLP NETCTLT NETDOWN NETF NETMAC \"\nCALL PROCESS \" NETMAN NETMOLD NETMOORE NETNAME NETNOTE NETOFF \"\nCALL PROCESS \" NETPARS NETSOL NETVIEW NETVSSI NETWARN \"\nCALL PROCESS \" NETWORK-related NEVERFIND NEWAPPL NEWARG NEWARK \"\nCALL PROCESS \" NEWCOPY NEWDD NEWGEN NEWLETTER NEWLETTERS NEWLOG \"\nCALL PROCESS \" NEWPDS NEWPOOL NEWTAP NEWVER NEWXMP NEWYORK NF NG \"\nCALL PROCESS \" NIC NIS NIXDORF NIXDORFNJ NJ NJAMG NJE NJEs NJEA \"\nCALL PROCESS \" NJEB NJEDEF NJEG NJEXB NL NLDM NMAX NME NMPF NNNNNK \"\nCALL PROCESS \" NOADV NOBYT NOC NOCAPS NOCATALOG NOCC NOCHECK \"\nCALL PROCESS \" NOCOMP NOCONLIST NODEID NODEIDS NODIRECT NODUMP \"\nCALL PROCESS \" NOEJECT NOEMPTY NOEQUALS NOERASE NOEXEC NOFEOV \"\nCALL PROCESS \" NOFLUSH NOFORCE NOFORCER NOFT NOFUNC NOHEX NOHOLD \"\nCALL PROCESS \" NOINDEX NOJCL NOKEY NOLEV NOLOGLST NOMARK NOMSG \"\nCALL PROCESS \" NON-STA NONDISPL NONLIN NONULL NOP NOPASS NOPAUSE \"\nCALL PROCESS \" NOPC NOPFLOW NOPREVIEW NOPROMPT NOREAL NOREC NOREPL \"\nCALL PROCESS \" NORESEQ NORUN NOS NOSAVE NOSCRATCH NOSPACES \"\nCALL PROCESS \" NOSPELLCHK NOSPIE NOSTAE NOSYMLIST NOTAUTH NOTCAT \"\nCALL PROCESS \" NOTEMAN NOTFND NOTRACE NOTRC NOTRK NOTUSED \"\nCALL PROCESS \" NOVALIDATE NOVERIFY NOWRITE NOXCO NOXCOUNT NOXREF \"\nCALL PROCESS \" NP NPA NPDA NPM NPRO NPSI NPT NRD NRDA NRDC NRE \"\nCALL PROCESS \" NRESTART NRZI NSCRIPT NSCRIPTA NSCRIPTS NSEXIT NSF \"\nCALL PROCESS \" NSL NSS NT NTM NTMRPT NTO NTSC NTXsnn NUC NUCID NUL \"\nCALL PROCESS \" NULLFILE NUMp NUMERAX NUMFDp NUMFDX NUMR NVSAM NXX \"\nCALL PROCESS \" NY NYC NYHG NYSE O'Donnell Oct Ohio Okidata \"\nCALL PROCESS \" Omegamon Onhand Onka Opachinski Orecchio Oscar Ott \"\nCALL PROCESS \" Ottawa Otto OAM OBJ OBJLIB OCx OCB OCCF OCCI \"\nCALL PROCESS \" OCCURED OCL OCR ODATE ODAY OEM OEMUCL \"\nCALL PROCESS \" OFF-------TOUR OFF-------TOUR OFFLOADn OFILE OFLOW \"\nCALL PROCESS \" OGddddAA OGL OGLCHAR OH OI OJ OJnnnn OJNNNN OKMVSTP \"\nCALL PROCESS \" OKNOTCAT OLCG OLDF OLDGEN OLDIDSNX OLDJPARM OLDLOG \"\nCALL PROCESS \" OLDRES OLDTEXT OLDVER OLDXUPD OLPXX OLSSNNN OLSXX \"\nCALL PROCESS \" OLTD OLTEP OM OMEGAMON OMONTH OMS OMSnnn ONs \"\nCALL PROCESS \" ONCEOVER ONLPARM ONLYLIST OODISSY OPddddAA OPC \"\nCALL PROCESS \" OPCOM OPENFILE OPERATNS OPERSEC OPLG OPN OPNDST \"\nCALL PROCESS \" OPRCTL OPS OPSYS OPTCD OPTCDJ OPTLIB ORD ORDBILL \"\nCALL PROCESS \" ORDERNET ORG ORIGLIB OS OSI OSJOB OSPCAT OTTAWA \"\nCALL PROCESS \" OUTDD OUTIN OUTLIM OUTPUTCM OUTPUTX OV OVRCT \"\nCALL PROCESS \" OWNNODE OX OYEAR OZSSDNN Pacific Pacifica Packard \"\nCALL PROCESS \" Paiz Palatino Pampa Panasonic Pansophic Papa \"\nCALL PROCESS \" Paraform Parkinson's Parslow Parti Pasadena \"\nCALL PROCESS \" Pasadenta Pascal Patricia Patrick Paul Payee Payne \"\nCALL PROCESS \" Pbi Pecora Pender Pennsylvania Percival Perra Perry \"\nCALL PROCESS \" Peru Pescatore Peterson Petrolino Petruzzellis \"\nCALL PROCESS \" Petzinger PgDn PgUp Phares Phenoxyn Phil \"\nCALL PROCESS \" Philadelphia Philbrick Philip Philippines Phillips \"\nCALL PROCESS \" Phoenix Pierce Pietrusza Pillsbury Pittsburg \"\nCALL PROCESS \" Pittsburgh Pittson Plainfield Plexiglas Pointe \"\nCALL PROCESS \" Poland Polybenzimidazole Polyethylene Pook \"\nCALL PROCESS \" Portsmouth Portugal PostScript Pressley Prew \"\nCALL PROCESS \" Princeton Printlog PrintNet Procics Prodctl \"\nCALL PROCESS \" Protestant Protestants Puma Purina Pxxxx \"\nCALL PROCESS \" Pyrotronics PACKETY PAGEA PAGEADD PAGEBUILD PAGEDEF \"\nCALL PROCESS \" PAGEDEFs PAGEDEFS PAGENUC PAGEOF PAGERATE PAII PAK \"\nCALL PROCESS \" PAM PANDMS PANELID PANGEN PANVALET PAPERX PARMLIST \"\nCALL PROCESS \" PARMWORK PARMX PASSLIB PASSTRHU PASZ PATsnn PATP \"\nCALL PROCESS \" PAUSExx PAUSEBG PAYBL PAYMAST PBA PBADATA PBADEC \"\nCALL PROCESS \" PBAINT PBALEN PBI-ALL PBIS PBX PCs PCALC PCB PCC \"\nCALL PROCESS \" PCF PCI PCI'S PCINFO PCIRES PCMS PCODEPTR PCOND \"\nCALL PROCESS \" PCOX PCSINIT PCT PCTM PCTRANS PD PDDB PDDBs PDEFLIB \"\nCALL PROCESS \" PDEV PDFB PDLN PDLR PDLT PDLY PDM PDQ PDSs PDSBKCM \"\nCALL PROCESS \" PDSBKRS PDSCOPY PDSDIR PDSFILEL PDSFILEM PDSSNNN \"\nCALL PROCESS \" PDSWORK PDSWORKA PDSWORKS PDT PEMPDATA PEMPLYEE \"\nCALL PROCESS \" PERBS PERF PETROCHE PFT PGF PGJT PGLDDPT PGMINDX \"\nCALL PROCESS \" PGMNEW PGMPARM PGMX PGMXPRM PGMXREF PGP PHARM PHO \"\nCALL PROCESS \" PHOENIX PHR PHV PHVVSAM PID PIF PIGMNT PIMS PIMSG \"\nCALL PROCESS \" PIMSPOLYMER PINX PINXDOIT PIRTXT PIX PK PKED \"\nCALL PROCESS \" PLDDNNN PLI PLIBAT PLICHK PLICK PLICKCL PLICKCLG \"\nCALL PROCESS \" PLICMD PLIDEQ PLIDLI PLIDUMP PLIENQ PLIF PLIM \"\nCALL PROCESS \" PLIMAP PLINCL PLINK PLIREST PLIRETC PLISTRS PLIX \"\nCALL PROCESS \" PLIXC PLIXCG PLIXCL PLIXCLG PLIXCLGP PLIXCLP \"\nCALL PROCESS \" PLIXOPT PLIY PLIYCL PLIZ PLMS PLNE PLNES PLOAD PLPA \"\nCALL PROCESS \" PLQUEUE PLR PLU PMA PMD PMF PMM PMMVSTP PMONITOR \"\nCALL PROCESS \" PMRXXXX PMRXXXY PMS PMTSO PNET PNETNJEx PNETNJEG \"\nCALL PROCESS \" PNUM PO PO# POAQUINO POBJLIB POC POLYESTER POOLDEFS \"\nCALL PROCESS \" POOLIST POOLLIST POOLNAME POOLSTAR POPERCENT \"\nCALL PROCESS \" PORTFOLO POSMAST POTHRES PPC PPD PPDSALES PPHELP \"\nCALL PROCESS \" PPMODE PPN PPOBJ PPOPTION PPPP PPT PQ PQUERY PR \"\nCALL PROCESS \" PR/SM PRn PRCTR PRDCLG PRDEST PRDMP PRDUCC PRDUCL \"\nCALL PROCESS \" PREF PREREORGANIZATION PRG PRGMRR PRIM \"\nCALL PROCESS \" PRIME------TOUR PRIME------TOUR PRINTDEV PRINTDS \"\nCALL PROCESS \" PRINTERn PRINTLOG PRINTRnn PRIOINC PRIOLIM PRIV \"\nCALL PROCESS \" PRLCL PRM PRMODE PRN PROCICS PROCINDX PRODCTL \"\nCALL PROCESS \" PRODDS PRODJCL PRODLIST PRODMVSS PRODVMSP PRODVMXA \"\nCALL PROCESS \" PRODVSE PROFAHC PROFILEV PROFILU PROFL PROJ PROJACS \"\nCALL PROCESS \" PRPQ PRPTEST PRTn PRTDMPed PRTDUMP PRTFMT PRTPDS \"\nCALL PROCESS \" PRTZO PS PSA PSAF PSAFOPTS PSB PSB's PSBgen PSBGEN \"\nCALL PROCESS \" PSDN PSEGLIB PSF PSFAG PSFBK PSFCMI PSFCR PSFGR \"\nCALL PROCESS \" PSFHV PSFKO PSFNCS PSFPL PSFSYM PSFZD PSOUT PSP PSR \"\nCALL PROCESS \" PST PSTHRES PSW PSWD PTF PTR PTRDS PTS PTXTA PTXTP \"\nCALL PROCESS \" PUs PUDEST PULCL PUNn PUNCHP PUR PURCH PURCHDT PUTD \"\nCALL PROCESS \" PUTFILE PVC PVM PVS PVT PW PWR PWRON PWRONRST \"\nCALL PROCESS \" PWRSTA PWRTAPE PWS PX PXS PXXXXXX PXXXXXXX PZDDDNN \"\nCALL PROCESS \" QtePh Quebec QuickRef Quietwriter Quinn QA QAR \"\nCALL PROCESS \" QARCOS QAT QBE QCINVEN QCOUNT QDSSNNN QEND QFY \"\nCALL PROCESS \" QHELP QID QISAM QIT QL QLL QLPU QLU QMF QMFBATCH \"\nCALL PROCESS \" QNAME QRPT QRTP QS QSAM QTAM QTY QUASAR QUE QUIK \"\nCALL PROCESS \" QUINN QW QY Racf Rae Ragno Railcar RailcarSyst \"\nCALL PROCESS \" Rajwant Ralf Ralph Ralston Ramos Rancho Rapifaxed \"\nCALL PROCESS \" Rd Realtime Recoverability Reinput Revisable Rhode \"\nCALL PROCESS \" Richard Richter Rick Rita Rnn Rnnn Rnnnn Roadmap \"\nCALL PROCESS \" Robert Robertson Roethke Roger Rogers Rolodex Romeo \"\nCALL PROCESS \" Ron Rooney Rosemary Rosenberg Roth Rouge Roussel Rt \"\nCALL PROCESS \" Rubics Russell Russian Rutgers Ruth Rutins Rxx \"\nCALL PROCESS \" RxxxxxxL RAC RACF RACFPROCN RACFREST RACFX RAILCAR \"\nCALL PROCESS \" RAS RB RBs RBA RBN RBS RCA RCS RCVBLS RD RDn RDBACK \"\nCALL PROCESS \" RDH RDI RDJFCB RDR RDRn RDRDUMP RDRLIST RDROPSL \"\nCALL PROCESS \" READB READDVAL REALVOLS RECATLG RECCT RECEIVEX \"\nCALL PROCESS \" RECSIZE RECV REFR RELOPER REM REMIT-TO REPEATNX \"\nCALL PROCESS \" REPL REPLID REQID RES-Q RES-Q's RESIGNAT RESLIB \"\nCALL PROCESS \" RESNUC RESP RESPRINT RESQ RESQTXT RESRETPD RESTCMDS \"\nCALL PROCESS \" RETBUFFER RETCODE RETENTAU RETENTPR RETENTPREF \"\nCALL PROCESS \" RETENTXM RETENTXMPT RETEXCLD RETLGTH RETREPTDnnnn \"\nCALL PROCESS \" RETRETPD RETVOLSP RETVOLSPEC REXAMINED REXX RFM RFT \"\nCALL PROCESS \" RFTDCA RGB RGN RHO RISC RISLAND RIW RJ RJE RJEF RKP \"\nCALL PROCESS \" RL RLSE RM RMnnn RMAS RMDS RMEX RMEXENT RMEXEVT \"\nCALL PROCESS \" RMEXT RMF RMFIVP RMFUPDT RMID RML RMLIST RMODE RMS \"\nCALL PROCESS \" RMTnnn RNAME RNAMES RND RNTOPT RNUM ROCF ROE ROFICS \"\nCALL PROCESS \" ROM ROS ROSCOE ROUGE ROUSSEL ROUTCD ROUTECDE \"\nCALL PROCESS \" ROWUSER RPAD RPG RPGLIB RPLIOPT RPLOPT RPQ RPS RPT \"\nCALL PROCESS \" RPTS RPW RRDS RS RSA RSCS RSCSDOWN RSF RSFCNF \"\nCALL PROCESS \" RSFLOG RSR RST RSTALM RSTCRIT RSTDCAT RSU RSVP RT \"\nCALL PROCESS \" RTAM RTG RTM RTME RTMSF RTN RTNxxxx RTRM RUTINS \"\nCALL PROCESS \" RVARY RVWS RX Sabol Saffioti Sagan Salegna \"\nCALL PROCESS \" Salisbury Sandifer Sandoz Sandra Sandusky Sanocki \"\nCALL PROCESS \" Santangelo Sara Sarah Scarano Scg Scharwath Sched \"\nCALL PROCESS \" Scheuerle Schiavino Schiller Schmieding Schoonover \"\nCALL PROCESS \" Scott Seabrook Seamon Seattle Sena Sept Shannon \"\nCALL PROCESS \" Sharon Shelby Shenandoah Shephard Shjarback Sholler \"\nCALL PROCESS \" Sierra Sills Simeon Singapore Singh Skydell \"\nCALL PROCESS \" Smartmodem Smith Softare Softcopy Softswitch \"\n\nCALL PROCESS \" Sou-tex Soutex Soviet Spain Spartanburg Spd \"\nCALL PROCESS \" Speciality Spg Spotts Sprague Spunbond Sr St \"\nCALL PROCESS \" Stachura Stacy Stanley Stauff Steiert Stephen Steve \"\nCALL PROCESS \" Steven Stevie Stewart Storeroom Storey Storrs \"\nCALL PROCESS \" Streep Strimple Strupczewski Stryker StttLsnn Stu \"\nCALL PROCESS \" Sunnyvale Superabsorbent Supp Swart Sweden \"\nCALL PROCESS \" Switzerland Sxxx Sxxxx Sykes Sym Sysmods Syst \"\nCALL PROCESS \" SysReq Szwarc SAnnnn SAA SAAxxxx SAALIB SAAMSGF \"\nCALL PROCESS \" SADMP SADUMP SAFETY-BSB SAFNFEP SAHCPROD SAM SAMON \"\nCALL PROCESS \" SAMPJCL SAMPNSS SANJOSE SANWET SAR SART SAS SASCOPY \"\nCALL PROCESS \" SASFSP SASGraph SASGRAPH SASMESS SASPROD SAST SASZ \"\nCALL PROCESS \" SAV SAVEAREA SAVELOC SAVESYS SB SBU SC SCnnnn SCCCC \"\nCALL PROCESS \" SCD SCG-VANGUARD SCGGL SCH SCHARWAT SCHDCTL \"\nCALL PROCESS \" SCHEDCHT SCHEDCTL SCHEDJT SCHEDOPC SCHEDQ SCIDS \"\nCALL PROCESS \" SCIEN SCOPY SCOPYNX SCORPIO SCP SCPMSG SCRDAT SCRDT \"\nCALL PROCESS \" SCRIPTFT SCRIPTM SCRIPTPG SCS SCSI SD SDA SDAID \"\nCALL PROCESS \" SDATA SDATE SDB SDF SDLC SDMA SDR'S SDSs SDSF \"\nCALL PROCESS \" SDSSNNN SECAM SECLVL SECP SECUDATA SEG SEGS SENDI \"\nCALL PROCESS \" SENDTEST SEP SEPDS SEQIN SEQLEN SEQTOPDS SEQTOSEQ \"\nCALL PROCESS \" SERIFS SERIN SEROUT SERV SERVOFF SESEAME SESS \"\nCALL PROCESS \" SETABND SETINIT SETLP SETVERB SETVTV SEU SFFFF SFFI \"\nCALL PROCESS \" SGML SGSP SH SHAREOPTIONS SHIFTNX SHOWDATE SHRG \"\nCALL PROCESS \" SHRW SIC SID SIDEA SIDEB SIE SIGENLED SIGP SIMON \"\nCALL PROCESS \" SIND SIO SIOT SIXMONTH SKEY SKIPA SKIPB SKIPREC SLA \"\nCALL PROCESS \" SLCxVS SLCTDSX SLCTLIB SLCTNAME SLCTPDS SLCTPRM \"\nCALL PROCESS \" SLCTTSO SLCTV SLCTVS SLCXV SLCXVS SLCXVSPN SLI SLNE \"\nCALL PROCESS \" SLNES SLR SLSS SLU SLWW SM SMALLINT SMCICS SMFnnALL \"\nCALL PROCESS \" SMFF SMFIN SMFOUT SMFSAMP SMFT SMFXWTR SMITH SMP \"\nCALL PROCESS \" SMPxxxn SMPCSI SMPE SMPECAT SMPEIVP SMPEOEM SMPPTS \"\nCALL PROCESS \" SMPQuery SMPSCDS SMPSTS SMS SMSG SMST SMU SNAsnn \"\nCALL PROCESS \" SNADS SNBU SNI SNODE SNOOPY SNOOPYR SNT SOCS SOFLOW \"\nCALL PROCESS \" SOP SOPA SOPINDX SOPMEMB SOPS SOR SORLIB \"\nCALL PROCESS \" SORT-MESSAGES SORTALT SORTCNTL SORTCODE SORTCR \"\nCALL PROCESS \" SORTEM SORTG SORTIN SORTLIB SORTMSG SORTOUT SORTSVC \"\nCALL PROCESS \" SORTWK SORTWKnn SORTWORK SOS SOURC SOUT SOUTEX \"\nCALL PROCESS \" SPnnnn SPARTANBURG SPC SPF SPFI SPFPC SPFTEST SPG \"\nCALL PROCESS \" SPGD SPGIS SPIE SPLEVEL SPLITJCL SPLITTER SPLITV \"\nCALL PROCESS \" SPM SPOOLn SPOOLDEF SPOOLNUM SPPMTEST SPREC SPTAPE \"\nCALL PROCESS \" SPUFI SPZAP SQ SQEESTR SQL SQLCA SQLCODE SQLERRMC \"\nCALL PROCESS \" SQLERROR SQR SQRT SR SRn SRC SRCHJCL SRCLIST SRL \"\nCALL PROCESS \" SRM SRTEALOC SRTECHGS SRTED SRTEPRES SRTERESV SRTES \"\nCALL PROCESS \" SRTESTAT SSCP SSCPs SSL SSLIB SSN SSP SSPROF SSTABI \"\nCALL PROCESS \" SSW SSWMVS SSWMVST SSWPD SSWRSCS SSX ST STn STnnnn \"\nCALL PROCESS \" STA STABLIZE STAE STAP STAPE STARTNEW STATEM STC \"\nCALL PROCESS \" STDHEAD STDHEADER STDHED STDHEDWS STDHEDX STEPnnn \"\nCALL PROCESS \" STEPCAT STEPLINES Steve STHEAD STHEADLN STHEADPLN \"\nCALL PROCESS \" STHPG STICKONS STO STOPAFT STOPQ STOR STRAPD STRAPE \"\nCALL PROCESS \" STRTAFT STXXX SUBA SUBINIT SUBMITIT SUBON SUBSCRPT \"\nCALL PROCESS \" SUL SUPC SUPD SUPERC SUPMAP SUPPRESSABLE SUPT SUPVR \"\nCALL PROCESS \" SURFANAL SVA SVARY SVCD SVCLIB SVCNODMS SVDICT SVS \"\nCALL PROCESS \" SWNsnn SWPRIM SWSEC SWT Sykes SYMLIST SYN SYSx \"\nCALL PROCESS \" SYSyyddd SYSABNCD SYSABNRC SYSABOUT SYSACT SYSAFF \"\nCALL PROCESS \" SYSAFT SYSBACK SYSBRD SYSBRO SYSCATLG SYSCHG SYSCIN \"\nCALL PROCESS \" SYSCMDRC SYSCOPY SYSCP SYSCTL SYSCTLG SYSDA SYSDATE \"\nCALL PROCESS \" SYSDAYOFM SYSDAYOFW SYSDBOUT SYSDEF SYSDLM SYSDSN \"\nCALL PROCESS \" SYSDVAL SYSENV SYSEVENT SYSEXEC SYSGNOLD SYSHO \"\nCALL PROCESS \" SYSHOUR SYSIBM SYSICMD SYSID SYSINDEX SYSIO SYSISPF \"\nCALL PROCESS \" SYSITEXT SYSJDATE SYSLIB SYSLIN SYSLMOD SYSLOGW \"\nCALL PROCESS \" SYSLST SYSLTERM SYSMAINT SYSMDUMP SYSMINUTE SYSMOD \"\nCALL PROCESS \" SYSMONTH SYSMSG SYSNEST SYSOUx SYSOUT-trapped \"\nCALL PROCESS \" SYSOUTLINEn SYSPARMS SYSPCH SYSPCMD SYSPDS SYSPOST \"\nCALL PROCESS \" SYSPREF SYSPRINT SYSPUNCH SYSRACF SYSRSB SYSSCAN \"\nCALL PROCESS \" SYSSCMD SYSSDATE SYSSECOND SYSSQ SYSSRV SYSSTIME \"\nCALL PROCESS \" SYST SYSTERM SYSTIME SYSTSIN SYSTSOUT SYSTSPRT \"\nCALL PROCESS \" SYSTST SYSUDUMP SYSUID SYSUSAGE SYSVARW SYSWKx \"\nCALL PROCESS \" SYSWKA SYSWKB SYSWKC SYSWKD SYSWKE SYSWKF SYSWKX \"\nCALL PROCESS \" SYSWTER SYSX SYSYEAR T-shirt Taiwan Taker's Talbot \"\nCALL PROCESS \" Tampa Tango Taylor Tbbb Tektronix Telagraf Telex \"\nCALL PROCESS \" Tennessee Teresa Terry Testa Texas Textpack \"\nCALL PROCESS \" Thailand Thhmmss Thomas Thompson Thur Thurlby Thurs \"\nCALL PROCESS \" Tigard Tim Timothy Tnnnn Token-Ring Tom Tomasheski \"\nCALL PROCESS \" Tonn Torrey Tracs Traveletter Troisi Trost Trum \"\nCALL PROCESS \" Tucker Tue Tues Tuyet Tx TABLENAME TACCT TAF TAGDT \"\nCALL PROCESS \" TAND TAPEDUMP TAPEIN TAPEIVP TAPELABEL TAPELIB \"\nCALL PROCESS \" TAPEPOOLN TAPESL TAPETYPE TARPS TAS TAXWK TAXWKXX \"\nCALL PROCESS \" TBADD TBADDs TBBOTTOM TBCLOSE TBCREATing TBCREATE \"\nCALL PROCESS \" TBCREATEd TBDELETE TBDISPL TBDISPL's TBEND TBERASE \"\nCALL PROCESS \" TBEXIST TBGET TBMOD TBOPEN TBOPENed TBOPENing TBPUT \"\nCALL PROCESS \" TBQUERY TBRG TBS TBSARG TBSAVE TBSCAN TBSKIP TBSORT \"\nCALL PROCESS \" TBSORTed TBSTATS TBTOP TBVCLEAR TBWRITE TC TCA TCAM \"\nCALL PROCESS \" TCAPCLA TCAS TCB TCBs TCM TCO TCOMMAND TCP TCS-ACF \"\nCALL PROCESS \" TCT TCTTUA TDA TDAGENERAL TDD TE TECHDS TECHDUM \"\nCALL PROCESS \" TECHPRIM TECHSUPP TECHT TECHV TEL TELEX TELMEM \"\nCALL PROCESS \" TEMPDATA TEMPLYEE TEMPORAR TEMPPO TEMPX TER TERMI \"\nCALL PROCESS \" TESTnn TESTnx TESTxx TESTARCH TESTAUTH TESTBATC \"\nCALL PROCESS \" TESTCn TESTCAT TESTDISKTESTPx TESTDU TESTIMS TESTIT \"\nCALL PROCESS \" TESTLIB TESTOL TESTP TESTPx TESTPROC TESTVMSP \"\nCALL PROCESS \" TESTVMXA TESTVSE TESTX TF TG THISQTR THO THR \"\nCALL PROCESS \" THROUGHT THU THV TIFCONV TIFF TIMETU TIOA TIOCNJOB \"\nCALL PROCESS \" TIOCSTEP TIODDPTR TIOED TIOENTRY TIOEQNAM TIOERLOC \"\nCALL PROCESS \" TIOES TIOPNSRT TIOPPOOL TIOPS TIOPSLOT TIOSJBLB \"\nCALL PROCESS \" TIOSLABL TIOSLTYP TIOSM TIOSV TIOSVERF TIOSVLSR \"\nCALL PROCESS \" TIOSVOLP TIS TJnnnn TJAUTH TLBL TLD TLGNn TLMS \"\nCALL PROCESS \" TLMSx TLMSBLKS TLMSCOMB TLMSCONE TLMSCTAB TLMSDSN \"\nCALL PROCESS \" TLMSII TLMSLIST TLMSRMF TLMSRPT TLMSRPTS TLMSTRKA \"\nCALL PROCESS \" TLMSTRS TLMSTSO TLMSUPDT TLMSUSER TLMSUSR TLMSVCVS \"\nCALL PROCESS \" TLMSX TLMSXOLD TLMSXUPD TLNEn TM TME TMONLINE TMP \"\nCALL PROCESS \" TMPs TMPRDERR TMS TNL TOADDR TOADDRESS TOD TODEV \"\nCALL PROCESS \" TODO TOJnnnn TOKEY TOL TOPROW TOSCnn TOV TOVolumes \"\nCALL PROCESS \" TOVOLUME TPAL TPCONFIG TPF TPHISTRY TPNS TPNSE \"\nCALL PROCESS \" TPRTn TPRTnn TPS TPSEQOP TPX TRA TRACEOFF TRANDESC \"\nCALL PROCESS \" TRANSM TRASNMIT TRDATA TRFR TRK TRKCALC TRMAP \"\nCALL PROCESS \" TRMTnnnn TRS TRTCH TSMCOM TSMDOPTS TSMJCL TSMLINK \"\nCALL PROCESS \" TSMPDFTB TSMPDM TSMPMD TSMSHOW TSMSTART TSMSTOP \"\nCALL PROCESS \" TSMUSRTB TSOs TSOASM TSOB TSOCLIST TSOCONV TSOD \"\nCALL PROCESS \" TSODn TSODnn TSODnx TSODxx TSODA TSOEXEC TSOEXET \"\nCALL PROCESS \" TSOF TSOHELP TSOLABEL TSOMODEL TSOMON TSONAME \"\nCALL PROCESS \" TSONCAT TSOOPT TSOPRO TSOPROC TSOPROF TSORUN \"\nCALL PROCESS \" TSOTSODnx TSOUSER TSOUTIL TSOX TSOXD TSOY TSP \"\nCALL PROCESS \" TSPLIT TSS TSTOCL TSTRCVER TSTUCL TSU TSVSPF TT TTL \"\nCALL PROCESS \" TTR TTTTNNN TTTTTTTMV TTY TUA TVTOCs TW TWA TWX TXT \"\nCALL PROCESS \" TXXXXXXX TY TYMNET TYMNET's TYP TYPEITAL TYPERUN \"\nCALL PROCESS \" TYPESIZE TYPEWGT TYPEWID TYPORG Uneeda Univar Unnn \"\nCALL PROCESS \" Util Uxxx UA UACC UADS UCB UCBID UCBSTND UCBUNTYP \"\nCALL PROCESS \" UCBVR UDMH UHL UHO UHV UID UIN UITILITY UNAL \"\nCALL PROCESS \" UNCATLG UNCOND UNDEFINEDFILE UNDR UNHEXIT \"\nCALL PROCESS \" UNITADDRESS UNITAFF UNIX UNKNWN UNLOCKLP UPC UPD \"\nCALL PROCESS \" UPDAT UPPR UPR UPSI UPV UR USA USASCII USASI USCORE \"\nCALL PROCESS \" USEDT USERCAT USERCATALOG USERCATALOGs USERCODT \"\nCALL PROCESS \" USEREXITS USERSDCF USERSET USP USS USSTABI UT \"\nCALL PROCESS \" UTILLIB UTL UTME UV UVOLID UXXX UXXXX UZxxxxxx Va \"\nCALL PROCESS \" Vanguard Vanness Vax Vectra Vermont Vern Vienna \"\nCALL PROCESS \" Vija Villano Villaruz Vin Vince Virginia Vnnn Vogt \"\nCALL PROCESS \" Vxxxxxx VAH VALPRODD VALTHODS VANGUARD VARYPHY VAX \"\nCALL PROCESS \" VBM VBS VC VCI VCNA VCODE VCTR VD VDATE VDEFINE \"\nCALL PROCESS \" VDELETE VDELETEd VDR VECTRA VEMP VF VGddddAA VGET \"\nCALL PROCESS \" VGETS VHS VI-A VIP VIP# VIPOCAT VIPS VIRT VM VMxxxx \"\nCALL PROCESS \" VMBACKUP VMBACUP VMBLIST VMC VMCDAILY VMF VMFHASM \"\nCALL PROCESS \" VMFLKED VMFVCVS VMGROUP VMMAP VMPPF VMPRF VMS \"\nCALL PROCESS \" VMSPCST VMSPROD VMUTIL VMVSCA VMVSCAT VMVSTST VMXA \"\nCALL PROCESS \" VMXAnn VNAS VNCA VOLCNT VOLDELETE VOLID VOLSEQ \"\nCALL PROCESS \" VOLSPEC VP VPddddAA VPIC VPS VPSPRINT VPSSEP \"\nCALL PROCESS \" VPSSSEPR VPUT VRN VRNs VRU VS-DB VSept VSAMnn \"\nCALL PROCESS \" VSAMxx VSAMxxVSPC VSAMBP VSAMDEF VSAMDLT VSAMTUNE \"\nCALL PROCESS \" VSBASIC VSE VSEPT VSERES VSETAPE VSN VSPC-to-TSO \"\nCALL PROCESS \" VSPCCOPY VSPCDATE VSPCINDX VSPCLIB VSPCLIST VSPCQF \"\nCALL PROCESS \" VSPCQFDT VSPCQFRD VSPCREAD VSPCSEQ VSPCSERI VSPCVn \"\nCALL PROCESS \" VSPCX VSSNE VST VSYSTST VSYSUNUM VTAM VTAM/E VTAMs \"\nCALL PROCESS \" VTAMxx VTAMA VTAMB VTAME VTAMF VTAMG VTAMI VTAMLST \"\nCALL PROCESS \" VTAMPARS VTAMS VTAMX VTELE VTMS VTOC VTOCs VTOCS \"\nCALL PROCESS \" VUT VV VVDS VVDSes VVVVVVVVV VWR VWR's VZERO Waaser \"\nCALL PROCESS \" Walker Walkthrough Walkthroughs Wally Walt Walter \"\nCALL PROCESS \" Washington Wasser Watson Weed-B-Gon Wesley Westlake \"\nCALL PROCESS \" Westwood Whisky Whitely Whse Wilczek Wilkins \"\nCALL PROCESS \" William Williams Wilmington Wilson WordPerfect \"\nCALL PROCESS \" Workflow Worley Worthen Wumpus Wylbur WADS WADSXX \"\nCALL PROCESS \" WARMSTART WATS WHERE-USED WHOGOT WHSE WITHINPAREN \"\nCALL PROCESS \" WORKnn WRAPALL WRD WRIGHT WRITELOG WRITENR WRONGVOL \"\nCALL PROCESS \" WSER WSF WSU WT WTM WTO WTOR X'FF XapfDingbats \"\nCALL PROCESS \" Xedit Xerox Xeroxed Xmas XnAxxxxx Xray XADLIB XAPFK \"\nCALL PROCESS \" XASRES XASTAT XAUTOLOG XCOM XCOUNT XCTL XDAYS XEDIT \"\nCALL PROCESS \" XEQc XF XIV-Lab XMITOBJ XMMAP XMT XRF XS XSANR XT \"\nCALL PROCESS \" XTIME XV-Lab XWTR XXssssss XXEEEEcc XXPCMDS XXRCMDS \"\nCALL PROCESS \" XXXXCYYY XXXXYY XXXYY XXZ Yale Yelton York YDD \"\nCALL PROCESS \" YEAR-TO-DATE YESTRDAY YN YYDDMM YYYYY YZXXXX Zapf \"\nCALL PROCESS \" Zinser Znnn Zulu Zxxx ZAAFREQ ZCMD ZCONT ZCTACT \"\nCALL PROCESS \" ZCTTRUNC ZCTVERB ZD ZDDSUUUU ZDDUUUUU ZDIV ZER ZETA \"\nCALL PROCESS \" ZF ZIn ZIND ZIPLUKUP ZIPST ZIPSTCD ZL ZN ZPLACE \"\n/*-- ,\n...xxx;.ct */\nCALL PROCESS \" ZPRIM ZPROFAPP ZSEL ZTDSELS ZTDTOP ZTEMPF ZUP ZUSER \"\nCALL PROCESS \" ZVARS ZVERB ZZBR ZZCH ZZCL ZZFO ZZINIT ZZLI ZZLO \"\nCALL PROCESS \" ZZNO ZZPO ZZPV ZZRECV ZZSEND ZZST ZZTERM \"\n/*********************************************************************/\n/* That's all -- now for the return and the PROCESS procedure        */\n/*********************************************************************/\n   report = \"PROPER changed \" owords \"occurrences of\" ,\n     cwords \"(builtin\" twords\")\"\n\"LINE_BEFORE .zf = NOTELINE \"\"\"||began||\"--\"||TIME('N') report \"\"\" \"\n         ZEDSMSG = \"COMPLETED\"\n         ZEDLMSG = BEGAN||\"--\"TIME('N') report\n         Address \"ISPEXEC\" \"SETMSG  MSG(ISRZ000)\"\nreturn 1\nPROCESS: procedure expose cwords owords twords;\nAddress \"ISREDIT\"\na. = \"\";\nPARSE ARG a.1 a.2 a.3 a.4 a.5 a.6 a.7 a.8 a.9 a.10 ,\n          a.11 a.12 a.13 a.14 a.15 a.16 a.17 a.18;\ndo i = 1 by 1 while a.I \\= \"\";\n   twords = twords + 1;\n   from = translate(a.i,'abcdefghijklmnopqrstuvwxyz', ,\n                        'ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n   \"change all word  c\"\"\"||from||\"\"\" \"\"\"||a.i||\"\"\" \"\n   if rc = 0 then cwords = cwords + 1\n   \"(OWORDSX) = CHANGE_COUNTS\"; owords = owords + owordsx\nend\n\"RESET CHANGE\"\nreturn\n/*********************************************************************/\n/* The following was tried using all words in one large string, but  */\n/* appeared to take the same amount of time -- so staying with old.  */\n/* DICT had to be built with concatenation, due to 500 clause limit. */\n/*********************************************************************/\n/* limit = words(dict)                                               */\n/* do i = 1 by 1  to limit;                                          */\n/*    to = word(dict,1);                                             */\n/*    dict = delword(dict,1,1);                                      */\n/*    from = translate(to,'abcdefghijklmnopqrstuvwxyz', ,            */\n/*                         'ABCDEFGHIJKLMNOPQRSTUVWXYZ')             */\n/*    \"change all word  c\"\"\"||from||\"\"\" \"\"\"||to||\"\"\" \"               */\n/* end                                                               */\n/*********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PU00L": {"ttr": 12545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01\\x85\\x01\\x85\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 389, "newlines": 389, "modlines": 0, "user": "MCRITCH"}, "text": "/*PU00L     Author: David McRitchie        (written  in REXX)        */\n/*                 \"The REXX Macros Toolbox\"                           */\n/*          Created 1993/10/15                                       */\n/*-------------------------------------------------------------------*/\n/*       Macro: PU00L                                                */\n/*       Purpose: Print content of member in EDIT to PU00L           */\n/*                as an AFP file for printing -- DEST(TECHPSF)       */\n/*-------------------------------------------------------------------*/\n/* Related clists: PU00L, TECHPS, @PRINTNX, SCRIPTPS,  @SCRIPT ....  */\n/*********************************************************************/\n    address \"ISREDIT\";\"MACRO (TOKEN)\"\n    otoken=token\n    address \"ISPEXEC\" \"CONTROL ERRORS RETURN\"\n    zedsmsg = \"**\";zedlmsg=\"**\"\n    token = \" \"translate(token)\" \"\n    \"(rowx,colx) = cursor\"\n    qcnt = 0\n    q.=\"\";\n    parse var token left \"CLASS(\" class \")\" right\n    if class = \"\" then class=\"A\"; else token = left right\n    parse var token left \"COPIES(\" copies \")\" right\n    if copies = \"\" then copies=\"1\"; else token = left right\n    i = pos(\" NX \", token)\n    if i \\= 0 then do; NXOPT=\"NX\";\n      token = substr(token,1,i) substr(token,i+4)\n    end; else NXOPT=\"\"\n    Address \"ISREDIT\" \"(CHG) = DATA_CHANGED\"\n    if CHG = \"YES\" then if NXOPT = \"\" then do\n         zedsmsg = \"Not Saved/Not Printed\"\n         ZEDLMSG = \"Data has not been saved, Save then reissue PU00L\"\n         call msg0\n         call note zedlmsg\n         call note \"  or invoke with NX option ===> PU00L NX\"\n         exit 1;\n    end\n    Parse var token left \" DEST(\" dest \")\" right;token = left right\n    If dest = \"\" then dest = \"TECHPSF\"\n     /* TECHPSF for APF output is same physical printer as PU00L */\n\n    SCALE =,\n      \"1...5...10...15...20...25...30...35...40...45...50...55...60\"||,\n      \"...65...70...75...80...85...90...95..100..105..110..115..120\"||,\n      \"..125..130..135..140..145..150..155..160..165..170..175..180\"\n    /* find long line 80=gt12, 105=gt15, 120=gt18, 132=gt20, 160=gt24*/\n    \"(var016) = data_width\"\n    data_width = var016\n    /* attempt to reduce apparent data_width */\n    call dwchk 133 118 121 106 80 65 72 57\n\n    if NXOPT = \"NX\" then do; data_width = data_width + 16\n        scale = left(\" \",15)scale;\n    end;\n\n    if data_width <= 73 then do;\n          scale = substr(scale,1,70);\n          font = \"GB10\"; signal ready;\n    end;\n    if data_width <= 80 then do;\n          scale = substr(scale,1,80);\n          font = \"GT12\"; signal ready;\n    end;\n    if data_width >= 133 then do\n       \"seek first 133\" data_width \"p'^'\"  NXOPT\n       if rc = 0 then do;\n          scale = substr(scale,1,160);\n          font = \"GT24\"; signal ready;\n       end;\n    end\n    if data_width >= 121 then do\n       \"seek first 121\" data_width \"p'^'\"  NXOPT\n       if rc = 0 then do;\n          scale=substr(scale,1,132);\n          font = \"GT20\"; signal ready;\n       end;\n    end\n    if data_width >= 106 then do\n       \"seek first 106\" data_width \"p'^'\"  NXOPT\n       if rc = 0 then do;\n          scale=substr(scale,1,120);\n          font = \"GT18\"; signal ready;\n       end;\n    end\n    if data_width >= 81  then do\n       \"seek first 81 \" data_width \"p'^'\"  NXOPT\n       if rc = 0 then do;\n          scale=substr(scale,1,105);\n          font = \"GT15\"; signal ready;\n       end;\n    end\n    scale = substr(scale,1,80)\n    font = \"GT12\";\n ready:\n    \"(say1,say2) = cursor\"\n    \"CURSOR =\" rowx colx\n    ZEDSMSG =\n    ZEDLMSG = \"** Process into Q. ---------- **\"\n    ADDRESS \"ISPEXEC\" \"CONTROL DISPLAY LOCK\"\n    call msg0\n\n    ADDRESS \"ISREDIT\" \"(DSN) = DATASET\"\n    ADDRESS \"ISREDIT\" \"(MEMBER) = MEMBER\"\n    SYSUID = SYSVAR(\"SYSUID\")\n    userid = SYSVAR(\"SYSUID\")\n    inputdsn = \"'\"sysuid\".SPELL.MACRO.TEXT'\"\n    if member = '' then dsname=\"'\"dsn\"'\"\n    else dsname =\"'\"dsn\"(\"strip(member)\")'\"\n    s9999 = \"'\"sysuid\".s9999.list'\"\n    PROFILE = \"DSMPROF4\"       /*DEFAULT*/\n    /* TSO dataset conventions for use w/o quotes */\n    /* Allocate DCF input dataset -- allow up to 200 bytes/rec*/\n    ADDRESS \"TSO\"\n    status = msg(\"off\")\n    Address \"TSO\"\n    \"free fi(ESPELL)\";\"free da(\"inputdsn\")\"\n    \"free da(\"s9999\")\"\n    if sysdsn(inputdsn) = \"OK\" then \"del\" inputdsn\n    if sysdsn(s9999)    = \"OK\" then \"del\" s9999\n    status = msg(\"on\")\n    \"ALLOC FI(ESPELL) NEW CAT SPACE(45 45) TRACKS UNIT(SYSDA)\" ,\n      \"LRECL(255) RECFM(V B M) BLKSIZE(3156)\" ,\n      \"DSN(\"inputdsn\") REUSE\"\n    /*  DCB attributes to the contrary will be reset by DCF */\n\n    /* Open file and SAY some SCRIPT commands to be sure */\n    /* data is formatted properly for parsing (later).     */\n\n    Address \"ISREDIT\"\n    qcnt=qcnt+1; q.qcnt =\".pm .9i\"\n    qcnt=qcnt+1; q.qcnt =\".rh on\"\n    qcnt=qcnt+1; q.qcnt =\".ll 6i\"\n    qcnt=qcnt+1; q.qcnt =\".bf @smalls =\"\n    qcnt=qcnt+1; q.qcnt =\".dc ps \u00a2\"\n/*********************************************************************/\n/*     qcnt=qcnt+1; q.qcnt =\".se TODAY  '&DAY(&SYSDAYOFW.).,\",       */\n/*          \"&MONTH(&SYSMONTH.). &SYSDAYOFM., 19&SYSYEAR.'\"          */\n/*********************************************************************/\n    qcnt=qcnt+1; q.qcnt =\".ri <Printed via PU00L> for\" dsname,\n          \" \"font \" on &DAY(&SYSDAYOFW.)\",\n          date(\"o\") \"at\" time(\"n\")\"           &rbl.\"\n    saveq = q.qcnt\n    qcnt=qcnt+1; q.qcnt =\".pf\"\n    qcnt=qcnt+1; q.qcnt =\".sp 1\"\n    qcnt=qcnt+1; q.qcnt =\".rh off\"\n    qcnt=qcnt+1; q.qcnt = \".rf odd  \"\n    qcnt=qcnt+1; q.qcnt = \".pm .6i  \"\n    qcnt=qcnt+1; q.qcnt = \".ll 7.2i \"\n    qcnt=qcnt+1; q.qcnt = \".sv off  \"\n    qcnt=qcnt+1; q.qcnt = \".fo right\"\n    qcnt=qcnt+1; q.qcnt = \".sp 2    \"\n    qcnt=qcnt+1; q.qcnt = \" &$PS    \"\n    qcnt=qcnt+1; q.qcnt = \".rf off  \"\n    qcnt=qcnt+1; q.qcnt = \".rf even \"\n    qcnt=qcnt+1; q.qcnt = \".sv off  \"\n    qcnt=qcnt+1; q.qcnt = \".fo left \"\n    qcnt=qcnt+1; q.qcnt = \".sp 2    \"\n    qcnt=qcnt+1; q.qcnt = \" &$PS.   \"\n    qcnt=qcnt+1; q.qcnt = \".rf off  \"\n    qcnt=qcnt+1; q.qcnt =\".sv off\"\n    qcnt=qcnt+1; q.qcnt =\".ll 7.5i\"\n    qcnt=qcnt+1; q.qcnt =\".if 1403 = &$PDEV. .llmax\"\n    call dirinfo; /* directory info extracted from @PRINTNX */\n    qcnt=qcnt+1; q.qcnt =\".dd file dsn \"dsname\n    qcnt=qcnt+1; q.qcnt =\".bf\" font \"gt15 =\"\n    qcnt=qcnt+1; q.qcnt =\".fo off fold\"\n    /******* bring in file currently in edit *********************/\n    /*******   .imfile is a special DCF macro for this purpose   */\n    if NXOPT = \"\" then do; qcnt=qcnt+1; q.qcnt =\".imfile file\";end;\n    else call modified_input    /* or use alternative for unsaved*/\n    /*************************************************************/\n    qcnt=qcnt+1; q.qcnt =\".pf\"\n    qcnt=qcnt+1; q.qcnt =\".sk 1\"\n    qcnt=qcnt+1; q.qcnt =\".ll 6i\"\n    qcnt=qcnt+1; q.qcnt =\".hr left right\" /* instead of  .$PARM */\n    qcnt=qcnt+1; q.qcnt =\".ll 7.5i\"\n    qcnt=qcnt+1; q.qcnt =\".bf\" font \"=\"\n    qcnt=qcnt+1; q.qcnt =scale\n    qcnt=qcnt+1; q.qcnt = \".if &$PASS = &$PSNO. .$FONT TY\"\n    qcnt=qcnt+1; q.qcnt =\".pf\"\n    qcnt=qcnt+1; q.qcnt =\".ll 6i\"\n    qcnt=qcnt+1; q.qcnt =\".bf\" font \"=\"\n    qcnt=qcnt+1; q.qcnt =\".se face '&$TYPESIZE. &$TYPEFACE.'\"\n    if pos(\"BROWSE\",token) \\= 0 then do\n      qcnt=qcnt+1; q.qcnt =\".$font ty\"\n    end\n    qcnt=qcnt+1; q.qcnt =\".pf\"\n    qcnt=qcnt+1; q.qcnt =\".bf @smalls =\"\n    qcnt=qcnt+1; q.qcnt =saveq \" with\" font \"(&face.)\"\n    qcnt=qcnt+1; q.qcnt =\".pf\"\n\n    extra_lines = qcnt  /* lines added in front of file */\n    Address \"TSO\" \"EXECIO * DISKW ESPELL (STEM Q. FINIS\"\n    /* Invoke SCRIPT/VS */\n    Address \"TSO\" \"SCRIPT\" inputdsn,\n        \" PRO('SCRIPT.R40.MACLIB(DSMPROF4)') LIB('SCRIPT.R40.MACLIB')\",\n        \" FO('SYS1.PROD.FONT300') index seg('sys1.seglib') DEV(PG4A)\",\n        \" CHARS(X0H21001) FP(2)SYS(X NO H NO D YES ) M(ID)\",\n        \" FILE(\"s9999\")\"\n    SCRIPT_RC = RC\n    status = msg(\"off\")\n    address \"TSO\" \"FREE DA(\"s9999\")\"\n    status = msg(\"on\")\n    i = pos(\"BROWSE\",token)\n    if i \\= 0 then do;  /* debugging check files created*/\n            SAY \"SCRIPT return code rc=\"script_rc  \"CLASS=\"class,\n               \"font\" font \"scale=\" length(scale),\n               \"one of longer lines\" say1 say2\n            address \"TSO\" \"$BROWSE\" dsname\n            address \"TSO\" \"$EDIT\"   inputdsn\n            address \"TSO\" \"$BROWSE\" s9999;\n            Address \"ISREDIT\" \"MEND\"\n            say zerrmsg zedsmsg zedlmsg zcmd\n            exit 1;\n            SAY \"THIS STATEMENT SHOULD NEVER APPEAR\"\n    end;\n    ZEDSMSG =\"\"\n    ZEDLMSG = \"** Completed----------------- ** -- FINAL PHASE\"\n    ADDRESS \"ISPEXEC\" \"CONTROL DISPLAY LOCK\"\n    call msg0\n\n    status = msg(\"off\")\n    Address \"TSO\"\n   \"FREE FI(ESPELL) DELETE\"\n   \"FREE OUTDES(NAME1) FI(SYSUT1 SYSUT2 SYSPRINT)\"\n    status = msg(\"on\")\n    OUTDES = \"CLASS(\"class\") DEST(\"dest\")\",\n        \"FORMDEF(A10111) LINECT(0) GROUPID(PU00L)\"\n   \"OUTDES NAME1\" OUTDES\n  /* class = A*/\n   \"ALLOC FI(SYSPRINT) DUMMY                 \"\n   \"ALLOC FI(SYSUT1) DA(\"s9999\") SHR\"\n   \"ALLOC FI(SYSUT2) SYSOUT(\"class\") OUTDES(NAME1) COPIES(\"copies\")\"\n   \"ALLOC FI(SYSIN) DUMMY REUSE              \"\n   \"CALL 'SYS1.LINKLIB(IEBGENER)'            \"\n   if rc = 0 then\n   ZEDSMSG = \"Printed\"\n   ZEDLMSG = time(\"n\"),\n      \"PU00L -Document has been Printed to CLASS(\"class\")\" font,\n      \"DEST(TECHPSF) copies(\"copies\")\"\n   call note zedlmsg\n   call msg0\n   address \"ISREDIT\" \"UP MAX\"\n   \"FREE FI(SYSUT1 SYSUT2) OUTDES(NAME1)     \"\n   \"ALLOC FI(SYSIN) DA(*) REUSE              \"\n   \"ALLOC FI(SYSPRINT) DA(*) REUSE           \"\n   Address \"ISREDIT\" \"UP MAX\"\n   Address \"ISREDIT\" \"MEND\"\n   exit 1;\n   say \"This statement--should never print\"\n dirinfo:\n /******** extracted from @PRINTNX *******************/\n  address \"ISREDIT\"\n  \" (VAR018) = DATAID\"\n  \" (VAR018A) = DATASET\"\n  \" (VAR043) = MEMBER\"\n  \" (DSNX)          = DATASET\"\n  \" (NUMX)          = NUMBER\"\n  x = LISTDSI(\"'\"DSNX\"'\") \"DIRECTORY\"\n  LMSG = \"DCB=(RECFM=\"SYSRECFM\",LRECL=\"SYSLRECL\",BLKSIZE=\"SYSBLKSIZE,\n        ||\",DSORG=\"SYSDSORG\")  NUMBER \"NUMX\n  IF VAR043 = \"\" THEN DO\n          xyz=\"\"  /* statistics not avail. for sequential file */\n          signal nostats;\n  END\n  Address \"ISPEXEC\" \"LMINIT DATAID(DDVAR) DATASET('\"VAR018A\"') ENQ(SHR)\"\n  if rc \\= 0 then say \"LMINIT RC=\"RC\n  Address \"ISPEXEC\" \"LMOPEN DATAID(\"ddvar\") OPTION(INPUT)\"\n  if rc \\= 0 then  say \"LMOPEN RC=\"RC\n  Address \"ISPEXEC\" \"LMMFIND DATAID(\"ddvar\") MEMBER(\"VAR043\")\",\n     \"STATS(YES)\"\n  if rc \\=0 then say \"LMFIND RC=\"RC\n  LRC = RC\n  IF LRC = 8 THEN  NOTFOUND = 1\n  ZEDLMSG = lmsg; call msg0\n  VAR043 = SUBSTR(VAR043,1,8)\n  /************************************************************/\n   XYZ = VAR043 ZLVERS\".\"ZLMOD ZLCDATE ZLMDATE\n   XYZ = XYZ ZLMTIME ZLCNORC ZLINORC ZLMNORC\n   XYZ = XYZ LEFT(ZLUSER,8)\n  nostats:\n   \" (VAR037) = LINENUM .ZLAST\"\n   IF ZLCNORC =\"\" THEN XYZ = VAR043,\n     \"                                  \"VAR037\"   *NO \",\n     \"STATISTICS*   \"\n   IF NOTFOUND = \"\" THEN XYZ = VAR043  ,\n       \"<<--------------- no prior statistics exist ---------->>\"\n   \"(VAR014A) = DATA_CHANGED\"\n   if VAR014A = \"NO\" then do\n      changed = \"-- Data Unchanged\"\n   end\n   else do\n      changed = \"-- Data Changed\"\n   end\n   if xyz \\= \"\" then do\n      call note \"=== MEMBER-- VV.MM CREATED- \",\n          \"---MODIFIED---  CURR  INIT   MOD LASTUSER ==\"\n      call note \"=== \"XYZ\" ==\"\"\"\n   end\n   IF VAR014A = \"YES\" THEN\n      call note \"=== PU00L\" otoken \"-- issued \"||,\n         \"(\"date('j')\")\" date('o') time('n') \"Data has been changed \"||,\n                                    \"===========\"\n   ELSE\n      call note \"=== PU00L\" otoken \"-- issued \"||,\n         \"(\"date('j')\")\" date('o') time('n') \"======================\"||,\n                                    \"===========\"\n   /* ------------------------------*/\n\n       qcnt=qcnt+1; q.qcnt= \".sk 1\"\n       qcnt=qcnt+1; q.qcnt= \".kp on\"\n       qcnt=qcnt+1; q.qcnt= \".bf gt20 gt15 =\"\n       qcnt=qcnt+1; q.qcnt= \".bx 0 6i\"\n       qcnt=qcnt+1; q.qcnt= \".in 2 \"\n       qcnt=qcnt+1; q.qcnt= \".ir 2\"\n        if xyz \\= \"\" then do\n          qcnt=qcnt+1; q.qcnt= \" MEMBER-- VV.MM \"||,\n           \"CREATED- ---MODIFIED---  CURR  INIT   MOD LASTUSER\"\n          qcnt=qcnt+1; q.qcnt= \" \"XYZ\n          qcnt=qcnt+1; q.qcnt= \".bx\"\n       end\n       qcnt=qcnt+1; q.qcnt= \" DSN=\"||left(SYSDSNAME,44),\n          \"Created\" SYSCREATE\n       qcnt=qcnt+1; q.qcnt= \" \"LMSG\n       qcnt=qcnt+1; q.qcnt= \".bx off\"\n       qcnt=qcnt+1; q.qcnt= \".kp off\"\n       qcnt=qcnt+1; q.qcnt= \".sk 1\"\n   /* ------------------------------*/\n /*IF ZLCNORC  /=\"\" THEN do*/\n     if xyz \\= \"\" then do\n      Address \"ISPEXEC\" \"LMCLOSE DATAID(\"ddvar\")\"\n      if rc \\=0 then say \"LMCLOSE RC=\"RC\n      Address \"ISPEXEC\" \"LMFREE DATAID(\"ddvar\")\"\n      if rc \\=0 then say \"LMFREE  RC=\"RC\n     end\n /*end*/\n /**** end extracted from @PRINTNX *******************/\n  return\n\n modified_input:\n unshown = 0\n /* TECHPS and PU00L contains coding similar to @PRINTNX */\n address \"ISREDIT\"\n \"(maxrec) = LINENUM .ZLAST\"\n qcnt=qcnt+1; q.qcnt =\".ti 5F 5F\"\n qcnt=qcnt+1; q.qcnt =\".ti\"\n qcnt=qcnt+1; q.qcnt =\".dc gml off\"\n qcnt=qcnt+1; q.qcnt =\".dc cw  off\"\n qcnt=qcnt+1; q.qcnt =\".li on\"\n do rec = 1 to maxrec\n    \"(XSTATUS) = XSTATUS\" REC\n    if XSTATUS = \"X\" then do\n       if unshown = 0 then qfrom = rec + 0\n       unshown = unshown + 1\n    end\n    else do\n       if unshown /= 0 then do\n          recm1 = rec - 1\n          qcnt=qcnt+1; q.qcnt = \"        - - - - - - - - -\",\n                unshown \"LINE(S), lines\" right(QFROM,6,'0')\"-\"||,\n                right(recm1,6,'0') \"Not Displayed\"\n          unshown = 0\n       end\n       \"(LINE) = LINE\" rec\n       \"(LABEL,NEST) = LABEL\" rec\n       qcnt=qcnt+1; q.qcnt = \" \"left(label,6) right(rec,6,'0') line\n       /* We could have provided more room when labels are not used, */\n       /* but chose to keep report uniform for NX listings regard-   */\n       /* less of whether labels are used or not.  <design choice>   */\n    end\nend\nqcnt=qcnt+1; q.qcnt = \".li off\"\nqcnt=qcnt+1; q.qcnt =\".dc gml : : e\"\nqcnt=qcnt+1; q.qcnt =\".dc cw 5E\"\nq.0 = qcnt;\nreturn\nNOTE: parse arg arg;\n      address \"ISREDIT\" \"line_before .zf = noteline (arg)\"; return\nMSG0: /* SPF/PC invokes SETMSG in incorrectly */\n      if v1 = \"REXXSAA\"\n         then /*Address*/ \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n         else Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\nreturn  0\ndwchk: arg dwchka\n  do j = 1 to words(dwchka)\n     n=word(dwchka,j); n=n+0; np1=n+1;\n     if data_width > n then do\n        \"seek first p'^' \" np1 data_width   NXOPT\n        if rc \\= 0 then data_width = n\n  end\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q": {"ttr": 12552, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01C\\x01C\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 323, "newlines": 323, "modlines": 0, "user": "MCRITCH"}, "text": "  PROC 1 Q PANEL() VGET() VPUT() SHARED() PROFILE() +\n   PARM() PGM() CMD() NEWAPPL() WHAT NESTING EDIT\n   /* PURPOSE: QUICK ENTRY INTO PANEL DISPLAY\n   /* INSTALLATION: <SPECIAL INSTRUCTIONS, IF ANY, FOR USER TO INSTALL\n   /* CONTRIBUTED:   F. David McRitchie             1986/07/14\n   /* USER CONTACT:  F. David McRitchie            xx\n   /* CODE MAINT.:   F. David McRitchie\n   /********8 added line\n /*********************************************************************\n /*\n /*    QQQQQQQQQQ           HH      HH  EEEEEEEEE  LL        PPPPPPPP\n /*   QQ        QQ          HH      HH  EE         LL        PP     PP\n /*   QQ        QQ  =====   HHHHHHHHHH  EEEEE      LL        PPPPPPPP\n /*   QQ     QQ QQ          HH      HH  EE         LL        PP\n /*    QQQQQQQQQQQ          HH      HH  EEEEEEEEE  LLLLLLLL  PP\n /*             QQQQQ\n /*  EXAMPLES:\n /*     ==> TSO Q *choose*\n /*\n /*  +-------------------------------------------------------------+.\n /*  | TSO Q option      (choose single choice option below)       |\n /*  +-------------------------------------------------------------+.\n /*  | ACTIVATOR   DATASET     LIBRARY     RESET       TERMINAL    |\n /*  | BATCH       DIALOG      LMU         SEARCH      TSO         |\n /*  |                                     SEARCH4                 |\n /*  | BROWSE      DMS         LOG         SOP         TUTORIAL    |\n /*  | CHANGES     DSLIST      NAMES       SUPERC      UTILITIES   |\n /*  | COMMAND     EDIT        OPT         SUPERCE     space       |\n /*  | COMPRESS    FOREGROUND  PSAF        TECHPRIM                |\n /*  | COPY        INFO        Q           TECHSUPP                |\n /*  |             INLOG                                           |\n /*  +-------------------------------------------------------------+.\n /*  EDIT option meaningful only to INLOG\n /*\n /*  +-------------------------------------------------------------+.\n /*  | WHAT       shows &ZAPPLID  and browse &DSNAME               |\n /*  +-------------------------------------------------------------+.\n /*\n /*     ==> TSO Q TLMS    /* quick entry to %TLMSUSR  */\n /*\n /*     ==> TSO Q SELECT PANEL(XXX) | PGM(XXXX) | CMD(XXX)   PARM(XXX)\n /*                  | NEWAPPL(XXX)\n /*\n /*     ==> TSO Q VPUT(PENCIL) SHARED(PEN2)    ==> TSO Q VGET(PENCIL)\n /*  Browse down to see more specific information\n /*  THIS IS THE ONLY COPY   OF  VGET   DISPLAY AVAILABLE\n /*   E.G.   COMMAND ===> TSO Q * VPUT(PEN2) SHARED(SHR-X) ...\n /*     ===> TSO Q * VPUT(PEN2) SHARED(SHR-X) PROFILE(PRO-X) VGET(*)\n /*********************************************************************\n  SET Q   = &STR(&SYSCAPS(&STR(&Q)))\n  SET Q   = &STR(&SYSCAPS(&STR(&Q)))\n  SET LP = &STR((\n  SET RP = )\n  IF &STR(&Q.) = HELP THEN DO\n     CLIST Q\n     EXIT CODE(1)\n  END\n  /********* EFFECTIVELY MAKES  ARGUMENT  \"Q\"  OPTIONAL  ************\n  IF &SUBSTR(1:5,&STR(&Q)           ) = &STR(VGET&STR(&LP))  THEN DO\n     SET VGET = &SUBSTR(6:&EVAL(&LENGTH(&STR(&Q))-1),&STR(&Q)                 )\n     SET Q = &STR(*)\n     GOTO NXT_TOK\n  END\n  IF &SUBSTR(1:5,&STR(&Q)           ) = &STR(VPUT&STR(&LP))  THEN DO\n     SET VPUT = &SUBSTR(6:&EVAL(&LENGTH(&STR(&Q))-1),&STR(&Q)                 )\n     SET Q = &STR(*)\n     GOTO NXT_TOK\n  END\n  IF &SUBSTR(1:6,&STR(&Q)           ) = &STR(PANEL&STR(&LP))  THEN DO\n     SET PANEL = &SUBSTR(7:&EVAL(&LENGTH(&STR(&Q))-1),&STR(&Q)                 )\n     SET Q = &STR(*)\n     GOTO NXT_TOK\n  END\n  IF &SUBSTR(1:7,&STR(&Q)           ) = &STR(SHARED&STR(&LP))  THEN DO\n     /******* following line may be incorrect-- changed from PANEL ??? */\n     SET SHARED = &SUBSTR(8:&EVAL(&LENGTH(&STR(&Q))-1),&STR(&Q)\n     SET Q = &STR(*)\n     GOTO NXT_TOK\n  END\n  IF &SUBSTR(1:8,&STR(&Q)           ) = &STR(PROFILE&STR(&LP))  THEN DO\n     SET PROFILE = &SUBSTR(9:&EVAL(&LENGTH(&STR(&Q))-1),&STR(&Q)\n     SET Q = &STR(*)\n     GOTO NXT_TOK\n  END\n  /******************************************************************\n  NXT_TOK: -\n   IF &STR(&Q) = &STR(TSOOS2) | &STR(&Q) = &STR(OS2) THEN DO\n      %TSOOS2\n      EXIT CODE(&LASTCC.)\n   END\n  IF &STR(&Q) ^= &STR(*) THEN DO\n     IF &STR(&Q) = TECHPRIM  THEN  SET PANEL = ISP@MSTR\n\n     IF &STR(&Q) = TERMINAL  THEN  ISPEXEC SELECT PGM(ISPOPT) PARM(ISPOPT1)\n\n     /*  use the   KEYS   command from any ispf panel .........\n\n\n\n/*   IF &STR(&Q) = PDF       THEN  SET PANEL = ISR@PRIM\n/*   IF &STR(&Q) = PDF       THEN  ISPEXEC SELECT PGM(ISR@PRIM)\n     IF &STR(&Q) = OPT       THEN  ISPEXEC SELECT PANEL(ISPOPTA)\n     IF &STR(&Q) = CHANGES   THEN  ISPEXEC SELECT PGM(ISPTUTOR) PARM(ISR00005)\n     IF &STR(&Q) = TUTORIAL  THEN  ISPEXEC SELECT PGM(ISPTUTOR) PARM(ISR00000)\n                   /* 6. PACKAGES  VUT@PRIM\n     IF &STR(&Q) = TECHSUPP  THEN  SET PANEL = VST@PRIM\n     IF &STR(&Q) = INFO      THEN ISPEXEC SELECT PANEL(ICQGCM00) NEWAPPL(ICQ)\n     IF &STR(&Q) = PSAF      THEN ISPEXEC SELECT CMD(AFPRINT ISPF(P))\n     IF &STR(&Q) = NAMES     THEN SET CMD      = &STR(%ICQCAC00)\n     IF &STR(&Q) = BROWSE    THEN  ISPEXEC SELECT PGM(ISRBRO) PARM(ISRBRO01)\n     IF &STR(&Q) = EDIT      THEN  ISPEXEC SELECT PGM(ISREDIT) PARM(P,ISREDM01)\n     IF &STR(&Q) = UTILITIES THEN  ISPEXEC SELECT PANEL(ISRUTIL)\n     IF &STR(&Q) = COMPRESS | &STR(&Q) = LIBRARY THEN -\n            ISPEXEC SELECT PGM(ISRUDA) PARM(ISRUDA1)\n     IF &STR(&Q) = DATASET   THEN ISPEXEC SELECT PGM(ISRUDA) PARM(ISRUDA2)\n     IF &STR(&Q) = COPY      THEN ISPEXEC SELECT PGM(ISRUMC)\n     IF &STR(&Q) = DSLIST    THEN ISPEXEC SELECT PGM(ISRUDL) PARM(ISRUDLP)\n     IF &STR(&Q) = RESET     THEN ISPEXEC SELECT PGM(ISRURS)\n     IF &STR(&Q) = WHAT  | &STR(&WHAT) = WHAT THEN DO\n           CLS\n           WRITE USERID=&SYSUID. AT &SYSSDATE. &SYSTIME.  +\n               PREFIX=&SYSPREF.  PROC=&SYSPROC. NEST=&SYSNEST.\n           ISPEXEC   VGET  DSNAME  SHARED\n           WRITE &DSNAME. <=== VALUE OF SHARED &&DSNAME.\n           ISPEXEC VGET VSTSRVTI SHARED\n           WRITE &VSTSRVTI. <=== VALUE OF SHARE &&VSTSRVTI.\n           ISPEXEC VGET ZAPPLID SHARED\n           WRITE &ZAPPLID. <=== VALUE OF SHARE &&ZAPPLID.\n     END\n\n\n\n\n\n     IF &STR(&Q) = SUPERC    THEN ISPEXEC SELECT PGM(ISRSSM)\n     IF &STR(&Q) = SUPERCE   THEN ISPEXEC SELECT PGM(ISRSEPRM) NOCHECK\n     IF &STR(&Q) = SEARCH    THEN DO\n                                  ISPEXEC SELECT PGM(ISRSFM)\n                             END\n     IF &STR(&Q) = SEARCH4   THEN DO\n                                  ISPEXEC SELECT PGM(ISRSFM)\n                                  SRCH400\n                             END\n     IF &STR(&Q) = FOREGROUND THEN  ISPEXEC SELECT PGM(ISRFPA)\n     IF &STR(&Q) = FORGROUND THEN  WRITE FORGROUND IS SPELLED FOREGROUND TRY AGA\n\n\n\n\n\n\n\n\n\n\n      IF &STR(&Q) = BATCH     THEN  ISPEXEC SELECT PGM(ISRJB1) PARM(ISRJPA) NOCH\n\n\n\n\n\n\n\n     IF &STR(&Q) = COMMAND   THEN  ISPEXEC SELECT PGM(ISRPTC)\n     IF &STR(&Q) = TSO       THEN  ISPEXEC SELECT PGM(ISRPTC)\n     IF &STR(&Q) = DIALOG    THEN  ISPEXEC SELECT PGM(ISPYXDR) NOCHECK PARM(ISR)\n     IF &STR(&Q) = PANELS    THEN  ISPEXEC SELECT PGM(ISPYXDR) NOCHECK PARM(ISR)\n     IF &STR(&Q) = VAR       THEN DO\n         ISPEXEC VGET ZAPPLID SHARED\n         IF &STR() = &STR(&PARM.) THEN SET PARM = ISR\n         IF &PARM. NE &ZAPPLID. OR &PARM. NE ISR THEN DO\n            WRITE CURRENT VALUE OF PARM(&ZAPPLID.)\n            WRITE CURRENT VALUE OF PARM(&ZAPPLID.)  WILL USE   PARM(&PARM.)\n         END\n                                   ISPEXEC SELECT PGM(ISPYXDR) NOCHECK PARM(&PAR\n     END\n     IF &STR(&Q) = LOG       THEN  ISPEXEC SELECT PGM(ISPYXDR) NOCHECK   /* SORR\n     IF &STR(&Q) = LMU       THEN  ISPEXEC SELECT PANEL(ISRLPRIM)\n\n     /* normally from edit use PDF  =4.9   (2.4.9)\n\n\n\n\n\n\n\n\n\n\n     IF &STR(&Q) = DMS       THEN -\n                   ISPEXEC SELECT CMD(%DMS) NEWAPPL(DMS)\n /*  IF &STR(&Q) = DMSLIST   THEN ISPEXEC SELECT PGM(DMS009E)\n\n\n\n\n\n\n\n\n\n\n     IF &STR(&Q) = SOP       THEN  ISPEXEC SELECT PANEL(VUTSOP) NEWAPPL(VSOP)\n\n\n\n\n\n\n\n\n\n\n     IF &STR(&Q) = SPACE  THEN -\n        ISPEXEC SELECT CMD(%ISMF) NEWAPPL(DGT) NOCHECK\n\n\n /*  use   ==> TSO SOP VIEW    instead\n /*  IF &STR(&Q) = TECHSOP   THEN  ISPEXEC SELECT PANEL(VSTSOP) NEWAPPL(VSOP)\n     IF &STR(&Q) = ACTIVATE | &STR(&Q) = ACTIVATOR THEN -\n        ISPEXEC SELECT CMD(%ACTIVATE) NEWAPPL(CACT)\n  END\n     IF &STR(&Q) = INLOG     THEN  DO\n        IF EDIT = &EDIT THEN $EDIT TECH.LIBR.PROJ(INLOG)\n        ELSE $BROWSE TECH.LIBR.PROJ(INLOG)\n        EXIT CODE(&LASTCC.)\n     END\n  IF &STR(&Q) = &STR(TLMS) THEN DO\n     WRITE Use \"END\" to TERMINATE your TLMS session\n     %TLMSUSR\n     EXIT CODE(0)\n  END\n  IF &STR(&VPUT) ^= &STR()     THEN DO    /* EXAMPLE   ==> TSO Q * VGET(ZPF13)\n                                          /*           ==> TSO Q * VPUT(PENCIL)\n                                          /*           ==> TSO Q * VPUT(PENCIL)\n       ALLOCATE FI(OUTFILE) DS(LIBR.CLIST(VPUT@1)) SHR REUSE\n       OPENFILE OUTFILE OUTPUT\n       SET OUTFILE = &STR( PROC 0)\n       PUTFILE OUTFILE\n       SET OUTFILE = &STR(/)&STR(*  THIS MEMBER --VPUT@1 -- WAS CREATED BY CLIST\n       PUTFILE OUTFILE\n       SET OUTFILE = &STR(/)&STR(*  &SYSICMD. *  VPUT(&VPUT.) SHARED(&STR(&SHARE\n       PUTFILE OUTFILE\n       IF &STR(&PROFILE) ^= &STR() THEN DO\n          SET OUTFILE = &STR(SET &STR(&VPUT) = &&STR(&PROFILE))\n          PUTFILE OUTFILE\n          SET OUTFILE = &STR(ISPEXEC VPUT (&STR(&VPUT)) PROFILE)\n          PUTFILE OUTFILE\n       END\n       IF &STR(&SHARED) ^= &STR() THEN DO\n          SET OUTFILE = &STR(SET &STR(&VPUT) = &&STR(&SHARED))\n          PUTFILE OUTFILE\n          SET OUTFILE = &STR(ISPEXEC VPUT (&STR(&VPUT)) SHARED)\n          PUTFILE OUTFILE\n       END\n       CLOSFILE OUTFILE\n       FREE FI(OUTFILE)\n       %VPUT@1\n       IF &STR(&VPUT) = THEN -\n       EXIT CODE(&LASTCC)\n  END\n  IF &STR(&VGET) ^= &STR()     THEN DO    /* EXAMPLE   ==> TSO Q * VGET(ZPF13)\n       IF &STR(&VGET) = &STR(*) THEN SET VGET = &STR(&VPUT)\n       ALLOCATE FI(OUTFILE) DS(LIBR.CLIST(VGET@1)) SHR REUSE\n       OPENFILE OUTFILE OUTPUT\n       SET OUTFILE = &STR( PROC 0)\n       PUTFILE OUTFILE\n       SET OUTFILE = &STR(/)&STR(*  THIS MEMBER --VGET@1 -- WAS CREATED BY CLIST\n       PUTFILE OUTFILE\n       SET OUTFILE = &STR(/)&STR(*  &SYSICMD. * VGET(&VGET.) VPUT(&VPUT.) SHARED\n       PUTFILE OUTFILE\n       SET OUTFILE = &STR(ISPEXEC VGET (&STR(&VGET)) SHARED)\n       PUTFILE OUTFILE\n       SET OUTFILE = &STR(SET SHARED1 = &&STR(&&&VGET.&RP.\n       PUTFILE OUTFILE\n       SET OUTFILE = &STR(WRITE  SHARED  VALUE &VGET = &&STR(&&&VGET.)\n       PUTFILE OUTFILE\n       SET OUTFILE = &STR(ISPEXEC VGET (&STR(&VGET)) PROFILE)\n       PUTFILE OUTFILE\n       SET OUTFILE = &STR(WRITE  PROFILE VALUE &VGET = &&STR(&&&VGET.)\n       PUTFILE OUTFILE\n       SET OUTFILE = &STR(IF &&STR(&&SHARED1) ^= &&STR() THEN DO\n       PUTFILE OUTFILE\n       SET OUTFILE = &STR(     SET &VGET = &&STR(&&SHARED1)\n       PUTFILE OUTFILE\n       SET OUTFILE = &STR(     ISPEXEC VPUT (&VGET) SHARED\n       PUTFILE OUTFILE\n       SET OUTFILE = &STR(     WRITE &VGET VALUE \"&STR(&&)SHARED1\" IN SHARED POO\n       PUTFILE OUTFILE\n       SET OUTFILE = &STR(     WRITE TO PREVENT LOSS WHICH WOULD OTHERWISE OCCUR\n       PUTFILE OUTFILE\n       SET OUTFILE = &STR(END)\n       PUTFILE OUTFILE\n       CLOSFILE OUTFILE\n       FREE FI(OUTFILE)\n       %VGET@1\n       EXIT CODE(&LASTCC)\n  END\n  IF &STR(&Q) = SELECT THEN DO\n     IF &STR(&PARM.)    ^= &STR() THEN SET PARM    = &STR(PARM&LP.&PARM.&RP.)\n     IF &STR(&PGM.)     ^= &STR() THEN SET PGM     = &STR(PGM&LP.&PGM.&RP.)\n     IF &STR(&CMD)      ^= &STR() THEN SET CMD     = &STR(CMD&LP.&CMD.&RP.)\n     IF &STR(&PANEL.)   ^= &STR() THEN SET PANEL   = &STR(PANEL&LP.&PANEL.&RP.)\n     IF &STR(&NEWAPPL.) ^= &STR() THEN SET NEWAPPL = &STR(NEWAPPL&LP.&NEWAPPL.&R\n     IF &STR(&NEWPOOL.) ^= &STR() THEN SET NEWPOOL = &STR(NEWPOOL&LP.&NEWPOOL.&R\n     WRITE  ISPEXEC SELECT &PANEL &CMD &PGM &PARM. &NEWAPPL. nesting\n     WRITE  IF ACCEPTABLE HIT ENTER\n     IF READ = &STR(Q.) THEN DO\n       READ XXX\n       IF &STR() ^= &STR(&XXX.) THEN EXIT CODE(12)\n     END\n     ISPEXEC SELECT &PANEL &CMD &PGM &PARM. &NEWAPPL. &NESTING\n     EXIT CODE(0)\n  END\n  IF &STR(&CMD) ^= &STR() THEN DO\n     ISPEXEC SELECT CMD(&CMD)\n     EXIT CODE(0)\n  END\n  IF &STR(&PANEL) ^= &STR() THEN DO\n     ISPEXEC SELECT PANEL(&PANEL)\n     EXIT CODE(0)\n  END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QHELP": {"ttr": 12804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x16\\x00\\x16\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "MCRITCH"}, "text": " /*REXX QHELP  */\n      /* PURPOSE: DEMONSTRATION OF MATERIAL MENTIONED IN  */\n  PARSE ARG  ARGS\n  IF LENGTH(ARGS) = 0 THEN ARGS = \"HELP\"\n  ELSE IF LENGTH(ARGS) <= 8 THEN ARGS = \"HELP \"||ARGS\n  IF OK = SYSDSN(\"'\"||SYSVAR(SYSUID)||\".QHELP.LIST'\") THEN ,\n  X=MSG(OFF)\n  \"DELETE  '\"||SYSVAR(SYSUID)||\".QHELP.LIST'\"\n  X=MSG(ON)\n  \"ALLOCATE DA('\"||SYSVAR(SYSUID)||\".QHELP.LIST')  TRACK\" ,\n      \"SPACE(2,10) RECFM(V B) LRECL(137) BLOCK(1374) REUSE\"\n   IF RC ^= 0 THEN EXIT RC\n   ADDRESS  ISPEXEC \"VGET (QHELP) SHARED\"\n   HQHELP = QHELP\n   QHELP = ARGS\n   DSNDESC = \"QHELP -- TSO HELP MATERIAL PLACED INTO EDIT\" ,\n      \"FOR EASIER VIEWING\"\n   ADDRESS ISPEXEC \"VPUT (QHELP DSNDESC) SHARED\"\n   \"$EDIT   '\"||SYSVAR(SYSUID)||\".QHELP.LIST' MACRO(QHELP@)\" ,\n      \"PANEL(SYSEDDE2)\"\n   QHELP = HQHELP\n   ADDRESS ISPEXEC \"VPUT (QHELP) SHARED\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QHELP@": {"ttr": 12806, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00/\\x00/\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "MCRITCH"}, "text": " /*REXX  QHELP@ SIMILAR TO @STRAPQQ CONVERTED TO REXX FROM @STRAPQ*/\n \"ISREDIT MACRO (COMMAND)              \"\n /*  TITLE:       QHELP@ -- TRAP CLIST INVOKED BY QHELP CLIST       */\n /*  USERS:       TSO ISPF EDIT USERS                               */\n /*  -- QHELP@ IS USED EXCLUSIVELY BY QHELP                         */\n /*  ENTRY:       USED AS AN EDIT CLIST WITHIN ISPF EDIT            */\n /*        ===> QHELP ALLOCATE    (WILL INVOKE QHELP@ EXECUTE       */\n /*  CONTRIBUTED: 1990/12/17 DAVID MCRITCHIE                        */\n /*               PROFS ID AT BBBBBBBBBBB   MCRITCHI               */\n /*  EXAMPLE:  ===> QHELP@ DDNAME ALL                               */\n \"ISREDIT CAPS OFF    \"\n \"ISREDIT BOUNDS      \"\n \"ISREDIT AUTOSAVE ON \"\n \"ISPEXEC VGET (QHELP) SHARED \"\n IF LENGTH(COMMAND) = 0 THEN COMMAND = QHELP\n IF LENGTH(COMMAND) = 0 THEN DO\n     SAY  ' PLEASE SUPPLY TSO COMMAND ENTRY FOR @STRAP MACRO CLIST'\n     SAY  '   USE SINGLE QUOTES OR PARENTHESIS IF            '\n     SAY  '          IF REPLY HAS SPACES OR COMMAS           '\n     SAY  '   TO CANCEL REQUEST HIT ENTER                    '\n     PULL COMMAND\n     SAY \"BY YOUR COMMAND ...\" COMMAND\n END\n IF LENGTH(COMMAND) = 0 THEN DO\n    SAY \"REQUEST TERMINATED DUE TO NULL COMMAND ENTRY\"\n    EXIT 0\n END\n \"ISREDIT CAPS OFF\"\n COMMANDX = TRANSLATE(COMMAND)\n IF SUBSTR(COMMANDX,1,5) = \"HELP \" THEN COMMANDX = SUBSTR(COMMAND,6)\n \"ISREDIT LINE_AFTER .ZLAST = '  '\"\n \"ISREDIT LINE_AFTER .ZLAST = 'COMMAND INVOKING QHELP@ EXECUTE,\n   MACRO ===> QHELP \"||COMMANDX||\"'\"\n \"ISREDIT LINE_AFTER .ZLAST = DATALINE \" ,\n    \"'EQUIVALENT TO TRAPPED OUTPUT ===> TSO \"||COMMAND||\"'\"\n \"ISREDIT  LINE_AFTER .ZLAST = '  '  \"\n RESULT = OUTTRAP(\"SAVE.\",'*')\n COMMAND\n RCMAX = RC\n RESULT = OUTTRAP(\"OFF\")\n DO I = 1 TO SAVE.TRAPPED BY 1;/*IF I > 400 THEN LEAVE I--P.REMOVED*/\n   XXXX   = TRANSLATE(SAVE.I,X2C('08'),'\"')\n   \"ISREDIT LINE_AFTER .ZLAST = DATALINE \"\"\"||XXXX||\"\"\"\"\n END\n \"ISREDIT CHANGE ALL '\"||X2C('08')||\"' '\"\"' \"\n \"ISREDIT LOC 0 \"\n EXIT RCMAX\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QUERYALL": {"ttr": 12808, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01\\xd3\\x01\\xd3\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 467, "newlines": 467, "modlines": 0, "user": "MCRITCH"}, "text": "/*        http://members.aol.com/dmcritchie/                  */\n          ISREDIT MACRO\n/* David McRitchie -- \"The REXX Macros Toolbox\" -- 1997/05/31 */\n /***  see results at http://members.aol.com/rexx01/txt/ncapxv.txt **/\n/*        NOT FOR DISTRIBUTION OR IS FOR PRIVATE TESTING.     */\n /*** D.McRitchie,  QUERYALL - query all ISPEXEC/ISREDIT variables **/\n /*** invoked from personal clist library or production copy of    **/\n /***  1990/03/27 Created for testing  D.McRitchie             */\n          CONTROL ASIS\nISREDIT CAPS OFF\n          CONTROL ASIS\nISREDIT LINE_AFTER .ZL = DATALINE \"    \"\nISREDIT LINE_AFTER .ZL = DATALINE \"    \"\nISREDIT LINE_AFTER .ZL = DATALINE \"    \"\nISREDIT LINE_AFTER .ZL = DATALINE \"    \"\nISREDIT LINE_AFTER .ZL = DATALINE \"    \"\nISREDIT LINE_AFTER .ZL = DATALINE \"    \"\nISREDIT LINE_AFTER .ZL = DATALINE \"    \"\nISREDIT LINE_AFTER .ZL = DATALINE \"    \"\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n /*             CONTROL CONLIST SYMLIST\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR001) = AUTOLIST\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR002) = AUTONUM\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR003,VAR004) = AUTOSAVE\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR005) = BLKSIZE\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR006,VAR007) = BOUNDS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR008) = CAPS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR009,VAR010) = CHANGE_COUNTS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR011,VAR012) = CTL_LIBRARY\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR013,VAR014) = CURSOR\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR014A) = DATA_CHANGED\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR016) = DATA_WIDTH\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR018) = DATAID\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR018A) = DATASET\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR019,VAR020) = DISPLAY_COLS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR021,VAR022) = DISPLAY_LINES\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR023E,VAR024E) = EXCLUDE_COUNTS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR023,VAR024) = FIND_COUNTS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR025,VAR026) = FLOW_COUNTS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR027,VAR028) = HEX\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR029) = IMACRO\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR031,VAR032) = LABEL .ZFIRST\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR033) = LEVEL\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR035) = LINE 8\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR037) = LINENUM .ZLAST\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR039) = MACRO_LEVEL\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR040) = LRECL\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR041) = MASKLINE\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR043) = MEMBER\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR045) = NOTE\n          ISREDIT (VAR045S) = NOTES\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR047,VAR048) = NULLS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR049,VAR050) = NUMBER\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR051) = PACK\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR053,VAR054) = PROFILE\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR055) = RANGE_CMD\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR057) = RECFM\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR059) = RECOVERY\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR061) = RMACRO\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR062) = SCAN\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR063,VAR064) = SEEK_COUNTS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR065) = STATS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR067A,VAR067B) = TABS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR069) = TABSLINE\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n   /*     ISREDIT (VAR071) = USER_STATE\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR073) = VERSION\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          ISREDIT (VAR075) = XSTATUS .ZFIRST\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR001) = AUTOLIST                                &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR002) = AUTONUM                                 &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR003,VAR004) = AUTOSAVE                         &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR005) = BLKSIZE                                 &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR006,VAR007) = BOUNDS                           &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR008) = CAPS                                    &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR009,VAR010) = CHANGE_COUNTS                    &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR011,VAR012) = CTL_LIBRARY                      &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR013,VAR014) = CURSOR                           &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR014A)       = DATA_CHANGED                     &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR016) = DATA_WIDTH                              &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR018) = DATAID                                  &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR018A) = DATASET                                 &VAR\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR019,VAR020) = DISPLAY_COLS                     &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR021,VAR022) = DISPLAY_LINES                    &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR023E,VAR024E) = EXCLUDE_COUNTS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR023,VAR024) = FIND_COUNTS                      &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR025,VAR026) = FLOW_COUNTS                      &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR027,VAR028) = HEX                              &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR029) = IMACRO                                  &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR031,VAR032) = LABEL .ZFIRST                    &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR033) = LEVEL                                   &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR035) = LINE 8                                  &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR037) = LINENUM .ZLAST                          &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR039) = MACRO_LEVEL                             &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR040) = LRECL                                   &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR041) = MASKLINE                                &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR043) = MEMBER                                  &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR045) = NOTE                                    &VAR0\n          WRITE ISREDIT (VAR045S) = NOTES                                    &VA\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR047,VAR048) = NULLS                            &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR049,VAR050) = NUMBER                           &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR051) = PACK                                    &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR053,VAR054) = PROFILE                          &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR055) = RANGE_CMD                               &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR057) = RECFM                                   &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR059) = RECOVERY                                &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR061) = RMACRO                                  &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR062) = SCAN                                    &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR063,VAR064) = SEEK_COUNTS                      &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR065) = STATS                                   &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR067A,VAR067B) = TABS                           &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          /* WRITE ISREDIT (VAR069) = TABSLINE                                &V\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR071) = USER_STATE                              <<wou\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR073) = VERSION                                 &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n          WRITE ISREDIT (VAR075) = XSTATUS .ZCSR                           &VAR0\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR001       ) = AUTOLIS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR002       ) = AUTONUM\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR003,VAR004) = AUTOSAV\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR005       ) = BLKSIZE\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR006,VAR007) = BOUNDS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR008       ) = CAPS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR009,VAR010) = CHANGE_\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR011,VAR012) = CTL_LIB\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR013,VAR014) = CURSOR\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR014A)       = DATA_CH\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR016       ) = DATA_WI\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR018       ) = DATAID\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR018A      ) = DATASET\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR019,VAR020) = DISPLAY\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR021,VAR022) = DISPLAY\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR023E,VAR024E) = EXCLU\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR023,VAR024) = FIND_CO\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR025,VAR026) = FLOW_CO\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR027,VAR028) = HEX\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR029       ) = IMACRO\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR031,VAR032) = LABEL .\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR033       ) = LEVEL\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR037       ) = LINENUM\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR039       ) = MACRO_L\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         /* ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR041       ) = MASK\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR043       ) = MEMBER\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR045       ) = NOTE\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR047,VAR048) = NULLS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR049,VAR050) = NUMBER\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR051       ) = PACK\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR053,VAR054) = PROFILE\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR055       ) = RANGE_C\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR057       ) = RECFM\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR059       ) = RECOVER\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR061       ) = RMACRO\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR063,VAR064) = SEEK_CO\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR065       ) = STATS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR067A,VAR06&B) = TABS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         /* ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR069       ) = TABS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n            ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR071       ) = USER\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n            ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT USER_STATE = (VAR071)\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR073       ) = VERSION\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR075       ) = XSTATUS\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         WRITE >>>>>&STR(&VAR035)<<<<<\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n         ISREDIT LINE_AFTER .ZLAST = DATALINE \"ISREDIT (VAR035       ) = LINE 8\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSUID    Current user s identific\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSPROC  LOGON procedure name\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSPREF  Data set name prefix\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" LASTCC   Most recent return code\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" MAXCC    Highest return code\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSICMD  Implicit execution member\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSSCAN  Symbolic substitution res\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSDLM   Terminal delimiter\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSDVAL  Terminal parameters\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSNEST  Nested procedure indicato\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSPCMD  Current primary command n\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSSCMD  Current subcommand name\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSTIME  Current time\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSDATE  Current date\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSENV   Foreground or background\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSCPU   CPU time (session) secs.h\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSHSM   Level of HSM available to\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSISPF  Whether ISPF management s\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSJDATE Julian date format  year.\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSLRACF Level of RACF available t\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSRACF  Indicate whether RACF ins\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSLTERM Contains number of lines\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSPROC  Name of logon procedure u\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSSDATE Date format year/month/da\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSSRV   Number of SRM serv. units\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSSTIME Date form  hours:minutes\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSTSOE  Level of TSO/E installed\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSWTERM Width of the screen\nIF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ----------------------------------\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \".ce panel  ISP@MSTR -- MASTER, and\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \".ce ISPF   Dialog Management Guide\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \"\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \".ce ISPEXEC VGET(........)  SHARED|\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET(........)\n       ISPEXEC VGET (ZUSER ZUSER ZPREFIX ZTIME ZTERM)\n       ISPEXEC VGET (ZDATE ZJDATE ZKEYS ZPFCTL ZLOGON VVER ZAPPLID ZCHARLM XENVI\n       ISPEXEC VGET (ZPF01 ZPF02 ZPF03 ZPF04 ZPF05 ZPF06 ZPF07 ZPF08)\n       ISPEXEC VGET (ZPF09 ZPF10 ZPF11 ZPF12 ZPF13 ZPF15 ZPF16 ZPF17)\n       ISPEXEC VGET (ZPF18 ZPF19 ZPF20 ZPF21 ZPF22 ZPF23 ZPF24)\n       ISPEXEC VGET (ZPL01 ZPL02 ZPL03 ZPL04 ZPL05 ZPL06 ZPL07 ZPL08)\n       ISPEXEC VGET (ZPL09 ZPL10 ZPL11 ZPL12 ZPL13 ZPL15 ZPL16 ZPL17)\n       ISPEXEC VGET (ZPL18 ZPL19 ZPL20 ZPL21 ZPL22 ZPL23 ZPL24 ZPFSHOW ZPFFMT)\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ----------------------------------\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZUSER )     Userid\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZUSER )     Userid\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZPREFIX)    Prefix\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZTIME )     Time\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZTERM )     Terminal\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZCHARLM)    Terminal\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZDATE )     Date\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZJDATE )    Date\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZKEYS )     PF Keys\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZPFCTL)     User Aut\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \"                           to use P\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \"                           USER|ON|\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZPFSHOW)    PFSHOW O\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZPFFMT)     Format o\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \"                           PRI (13-\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \"                           ALL (1-2\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZPF01 )     PF01\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZPF03 )     PF03\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZPF04 )     PF04\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZPF012)     PF012\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZPF024)     PF024\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZPL01 )     PF01   s\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZPL03 )     PF03   s\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZPL04 )     PF04   s\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZPL012)     PF012  s\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZPL024)     PF024  s\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZLOGON )    PROC\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (VVER  )     Version\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZAPPLID)    Applicat\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZENVIR )    Environm\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ----------------------------------\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" EDIT OUTPUT-ONLY variables-- ISPF\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ----------------------------------\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZCL    )  Left col o\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZCR    )  Right col\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZCSROFF)  CSR offset\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZCURSOR)  Named fiel\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZDADLN )  Length of\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZDADWD )  Width of d\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZDSN   )  Name of da\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZLEVEL )  Version an\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZLVLINE)  Last visib\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZMEMB  )  Name of me\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZTITLE )  title line\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZTITLE )   'DSN(MEMB\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ISPEXEC VGET (ZWIDTH )  Width of t\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ----------------------------------\n       SET DSN = '&VAR018A.(&VAR043.)'\n       IF &LASTCC ^= 0 THEN WRITE   LAST=&LASTCC    MAX=&MAXCC\n       SET DSN = '&VAR018A.'\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" set dsn = '&VAR018A.(&VAR043.)'\n       LISTDSI &DSN.  DIRECTORY\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSDSNAME Data set name\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSVOLUME  Volume Serial ID\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSDSORG   Data Set Organization\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSRECFM   Record Format\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSLRECL   Logical Record Length\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSBLKSIZE Block size\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSKEYLEN  Key Length\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \"\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSCREATE  Creation date\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSEXDATE  Expiration Date\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \"\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \"\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSREFDATE Last Referenced Date\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSUPDATED Change Indicator\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \"\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSUNIT    Device on which volume\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSUNITS   Space units\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSADIRBLK Directory Blocks Alloca\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSPRIMARY Primary Allocation in S\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSSECONDS Secondary Allocation in\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSUDIRBLK Directory Blocks used (\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSMEMBERS Number of Members (PDS\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \"\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSALLOC   Allocation in Space uni\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSUSED    Allocation used, in spa\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSBLKSTRK Directory blocks per tr\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSEXTENTS Number of Extents used\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSTRKSCYL Tracks per cylinder per\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \"\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSMSGLVL1 First Level Message (if\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSMSGLVL2 First Level Message (if\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSPASSWORD Password Indication\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSRACFA   RACF Indication\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" SYSREASON  LISTDSI reason Code\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \"\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \"ALLOCATE DA(x.&DSN.) NEW SPACE(&SYS\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \"   VOL(&SYSVOLUME.) UNIT(&SYSUNIT.)\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \"   &SYSUNITS DIR(&SYSADIRBLK.) +\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \"   RECFM(&SUBSTR(1:1,&SYSRECFM.\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \"         &SUBSTR(3:3,&SYSRECFM.\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \"   LRECL(&SYSLRECL.) BLKSIZE(&SYSBL\n /* to be added tacct jbxacct zpffmt  zfrml zfpked zbpked zfmt scrbr saf\n /* to be added zsf zpadc zdel zfmt zsced\n       ISPEXEC VGET (TACCT JBXACCT ZFRML ZFPKED ZBPKED ZFMT SCRBR SAF)\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \"  \"\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" TACCT\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" JBXACCT\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ZFRML\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ZBPKED\n       ISREDIT LINE_AFTER .ZLAST = DATALINE \" ZSCRBR\n           EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QW": {"ttr": 13059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\"\\x00\"\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "MCRITCH"}, "text": "PROC 0 PRM()\n/* THIS CLIST CAN BE USED TO INVOKE MVS/QUICKREF USING THE\n/* ISPF LIBDEF FACILITY. THIS CLIST SUPPORTS NESTED\n/* MVS/QUICKREF INVOCATIONS AND THE \"FAST-PATH\" INVOCATION\n/* METHOD.\n/*\n/* IF YOU MODIFY THE ISPF COMMANDS TABLE BY ADDING THE \"QW\"\n/* COMMAND, AND YOU WANT THE QW COMMAND TO INVOKE THIS\n/* CLIST, THEN THE ISPF COMMANDS TABLE ENTRY YOU ADD SHOULD\n/* LOOK LIKE THIS:\n/*\n/*   QW   0   SELECT CMD(%QW PRM('&ZPARM') NEWAPPL(QWRF))\n/*\nIF &SYSISPF ^= ACTIVE THEN DO\n  WRITE THIS CLIST MUST BE EXECUTED UNDER ISPF - TRY AGAIN\n  EXIT\n  END\nCONTROL MAIN NOMSG\nIF &LENGTH(&STR(&PRM)) < 3 THEN SET &PRM = ''\nISPEXEC LIBDEF ISPPLIB DATASET ID('TECH.QW.V40.PANELS')\nISPEXEC LIBDEF ISPMLIB DATASET ID('TECH.QW.V40.MESSAGES')\nISPEXEC LIBDEF ISPTLIB DATASET ID('TECH.QW.V40.TABLES')\nISPEXEC LIBDEF ISPLLIB DATASET ID('TECH.QW.V40.LINKLIB')\nALLOC F(QWREFDD) DA('TECH.QW.V40.DATABASE') SHR REUS\n/*   ALLOC F(QWREFDDU) DA('?????????') SHR REUS    */\n/*   ALLOC F(QWPARMS) DA(????????) SHR REUS  <OPTIONAL PARMS */\nISPEXEC SELECT PGM(QWIKREF1) PARM(&PRM)\nISPEXEC LIBDEF ISPPLIB\nISPEXEC LIBDEF ISPMLIB\nISPEXEC LIBDEF ISPTLIB\nISPEXEC LIBDEF ISPLLIB\nFREE F(QWREFDD)\nFREE F(QWREFDDU)\n/*   FREE F(QWPARMS)   */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "R": {"ttr": 13061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00.\\x00.\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "MCRITCH"}, "text": "ISREDIT MACRO (TCOMMAND)\n/*  DESCRIPTION: RETAIN / RECALL COMMAND\n/*       ==> R COMMAND     COMMAND WILL BE RETAINED FOR LATER USE\n/*       ==> R DISPLAY     WILL RECALL STORED COMMAND AND ONLY DISPLAY IT\n/*       ==> R             RETAINED COMMAND WILL BE RECALLED (AND EXECUTED)\n/*  PURPOSE:\n/*       ALLOW YOU TO DO OTHER EDIT FUNCTIONS SUCH AS MOVE LINES AROUND,\n/*       GO FORWARD/BACKWARD,  SAVE,   ETC.\n/*       YOU MUST BE WITHIN AN EDIT FOR THIS TO FUNCTION\n/*  WARNING:\n/*       CHECKING FOR INVALID COMMANDS IS LIMITED PREVENTING RECURSION\n/*       OF THE R MACRO ITSELF, WHICH WOULD OTHERWISE HAVE CAUSE A CONTINUOUS LO\n/*  PROGRAMMER:  F. DAVID MCRITCHIE BBBBBBBBBBBBBBB 1986/04/24\n/*******************************************************************************\n        IF DISPLAY = &TCOMMAND THEN DO\n           ISPEXEC VGET (TCOMMAND) SHARED\n           SET &ZEDSMSG = &STR(DISPLAY)\n           SET &ZEDLMSG = &STR(COMMAND R WOULD RETRIEVE \"ISREDIT &TCOMMAND\")\n           ISPEXEC     SETMSG MSG(ISRZ000)\n           IF &LENGTH(&STR(&TCOMMAND.)) > 60 THEN DO\n              WRITE ISREDIT &TCOMMAND\n           END\n           EXIT CODE(0)\n        END\n        IF &STR(&TCOMMAND) ^= &STR() THEN DO\n           ISPEXEC VPUT (TCOMMAND) SHARED\n           SET &ZEDSMSG = &STR(RETAINED)\n           SET &ZEDLMSG = &STR(COMMAND RETAINED, PERMITS YOU TO DO LINE MOVES, E\n           ISPEXEC     SETMSG MSG(ISRZ000)\n           ISREDIT &STR()\n           EXIT CODE(0)\n        END\n        ISPEXEC VGET (TCOMMAND) SHARED\n        SET &ZEDSMSG = &STR(RECALLED)\n        SET &ZEDLMSG = &STR(COMMAND \"&TCOMMAND\" WAS RECALLED AND EXECUTED)\n        ISPEXEC     SETMSG MSG(ISRZ000)\n        IF &STR(&TCOMMAND) ^= &STR() AND &STR(&TCOMMAND) ^= &STR(R) THEN DO\n           ISREDIT &TCOMMAND\n           IF &LASTCC ^= 0 THEN DO\n              SET &ZEDSMSG = &STR(*ERROR*)\n              SET &ZEDLMSG = &STR(STRING \"&TCOMMAND.\" WHICH WAS RECALLED IS INVA\n              ISPEXEC     SETMSG MSG(ISRZ000)\n              EXIT CODE(12)\n           END\n        END\n        EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REALLOC": {"ttr": 13063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x8b\\x00\\x8b\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 139, "newlines": 139, "modlines": 0, "user": "MCRITCH"}, "text": " PROC 1 DS FIRST LAST ADD REPLACE NOLIST LIST NOPROMPT PROMPT SHR OLD -\n        HELP DELETE DDNAME(SYSPROC) DISP(SHR) DEBUG NOERROR\n CONTROL NOFLUSH\n IF &DS = HELP OR &HELP = HELP THEN DO\n    HELP REALLOC\n    EXIT CODE(0)\n    END\n IF &OLD = OLD THEN SET DISP = OLD\n IF &PROMPT = PROMPT THEN DO\n    SET LIST = LIST\n    ISPEXEC CONTROL DISPLAY LINE\n    END\n IF &LIST = LIST THEN CONTROL LIST NOFLUSH\n SET SYSOUTTRAP = 1000\n LISTA ST\n SET SYSOUTTRAP = 0\n SET FOUND = NO\n SET DSFOUND = NO\n SET CONCAT = &STR()\n SET PREF = &SYSPREF..\n SET PREFL = &LENGTH(&STR(&PREF))\n IF &SUBSTR(1:1,&DS) = ' THEN SET DS1 = &DS\n ELSE IF &SYSPREF = THEN SET DS1 = '&DS'\n ELSE SET DS1 = '&SYSPREF..&DS'\n SET I = 1\n DO WHILE &STR(&FOUND) = NO AND &SYSOUTLINE >= &I\n    SET DDN = &&SYSOUTLINE&I..\n    IF &DEBUG. = DEBUG THEN WRITE DEBUG DDN IS &DDN.\n    IF &LENGTH(&STR(&DDN)) > 9 THEN -\n       IF &STR(&SUBSTR(2:10,&DDN)) = &STR( &DDNAME) THEN DO\n          SET FOUND = YES\n          SET I = &I - 1\n          SET DSN = &&SYSOUTLINE&I..\n          IF &DEBUG. = DEBUG THEN WRITE DEBUG DSN IS &DSN.\n          IF &LIST = LIST THEN WRITE &DDNAME ALLOCATION IS\n          IF &LIST = LIST THEN WRITE    '&DSN'\n          SET DS2 = '&DSN'\n          IF &LENGTH(&DSN) > &PREFL THEN -\n             IF &SUBSTR(1:&PREFL,&DSN) = &STR(&PREF) THEN DO\n                SET DSN = &SUBSTR(&EVAL(&PREFL+1):&LENGTH(&DSN),&DSN)\n                IF &DEBUG. = DEBUG THEN WRITE DEBUG DSN IS &DSN.\n                END\n             ELSE DO\n                SET DSN = '&DSN'\n                IF &DEBUG. = DEBUG THEN WRITE DEBUG DSN IS &DSN.\n                END\n          ELSE DO\n             SET DSN = '&DSN'\n             IF &DEBUG. = DEBUG THEN WRITE DEBUG DSN IS &DSN.\n             END\n          IF &REPLACE = AND &DS1 ^= &DS2 THEN SET CONCAT = &DSN\n          IF &DS1 = &DS2 THEN SET DSFOUND = YES\n          END\n       ELSE SET I = &I + 1\n    ELSE SET I = &I + 1\n    END\n IF &FOUND = YES THEN DO\n    DO WHILE &EVAL(&I+3) <= &SYSOUTLINE\n       SET I = &I + 3\n       SET DDN = &&SYSOUTLINE&I\n       IF &DEBUG. = DEBUG THEN WRITE DEBUG DDN IS &DDN.\n       IF &STR(&SUBSTR(1:3,&DDN)) = &STR() THEN DO\n          IF &REPLACE = REPLACE AND &LAST = LAST THEN -\n             SET CONCAT = &CONCAT&STR( ')&DSN'\n          SET I = &I - 1\n          SET DSN = &&SYSOUTLINE&I\n          IF &DEBUG. = DEBUG THEN WRITE DEBUG DSN IS &DSN.\n          IF &LIST = LIST THEN WRITE    '&DSN'\n          SET DS2 = '&DSN'\n          IF &LENGTH(&DSN) > &PREFL THEN -\n             IF &SUBSTR(1:&PREFL,&DSN) = &STR(&PREF) THEN DO\n                SET DSN = &SUBSTR(&EVAL(&PREFL+1):&LENGTH(&DSN),&DSN)\n                IF &DEBUG. = DEBUG THEN WRITE DEBUG DSN IS &DSN.\n                END\n             ELSE DO\n                SET DSN = '&DSN'\n                IF &DEBUG. = DEBUG THEN WRITE DEBUG DSN IS &DSN\n                END\n          ELSE DO\n             SET DSN = '&DSN'\n             IF &DEBUG. = DEBUG THEN WRITE DEBUG DSN IS &DSN\n             END\n          IF &REPLACE = OR &LAST = THEN -\n             IF &DS1 ^= &DS2 THEN SET CONCAT = &CONCAT &DSN\n          IF &DS1 = &DS2 THEN SET DSFOUND = YES\n          END\n       ELSE SET I = &SYSOUTLINE\n       END\n    END\n ELSE DO\n    IF &LIST = LIST THEN WRITE &DDNAME IS NOT ALLOCATED.\n    END\n IF &LIST = LIST THEN DO\n    IF &DELETE = DELETE THEN DO\n       IF &DSFOUND = YES THEN WRITE &DS WILL BE DELETED FROM THE LIST.\n       END\n    ELSE IF &REPLACE = REPLACE THEN DO\n  IF &LAST = LAST THEN WRITE THE LAST DATASET WILL BE REPLACED BY &DS..\n  ELSE WRITE THE FIRST DATASET WILL BE REPLACED BY &DS..\n  END\n    ELSE DO\n  IF &LAST = LAST THEN WRITE &DS WILL BE ADDED TO THE END OF THIS LIST.\n  ELSE WRITE &DS WILL BE ADDED TO THE TOP OF THIS LIST.\n  END\n    END\n IF &DELETE = DELETE THEN DO\n    IF &DSFOUND = NO THEN DO\n       IF &NOERROR ^= NOERROR THEN +\n          WRITE DATASET &DS1 WAS NOT FOUND IN &DDNAME ALLOCATION.\n       EXIT CODE(4)\n       END\n    SET CONCAT2 = &CONCAT\n    END\n ELSE IF &LAST = LAST THEN SET CONCAT2 = &CONCAT &DS\n ELSE SET CONCAT2 = &DS &CONCAT\n IF &PROMPT = PROMPT THEN DO\n    WRITE ALLOCATION WILL BE CHANGED WITH THE FOLLOWING COMMAND:\n    IF &CONCAT2 = THEN WRITE    FREE FI(&DDNAME)\n    ELSE WRITE    ALLOC FI(&DDNAME) DS(&CONCAT2) &DISP\n    WRITENR ENTER YES TO EXECUTE THIS COMMAND ===>\n    READ\n    IF &SYSDVAL ^= YES THEN EXIT CODE(0)\n    END\n IF &CONCAT2 = THEN FREE FI(&DDNAME)\n ELSE ALLOC FI(&DDNAME) DS(&CONCAT2) &DISP REUSE\n SET RC = &LASTCC\n IF &RC ^= 0 THEN DO\n    WRITE ALLOCATION FAILED, RETURN CODE &RC..\n    IF &PROMPT = PROMPT THEN DO\n       WRITE ALLOCATION WILL BE CHANGED WITH THE FOLLOWING COMMAND:\n       WRITE    ALLOC FI(&DDNAME) DS(&CONCAT) &DISP\n       WRITENR ENTER YES TO EXECUTE THIS COMMAND ===>\n       READ\n       IF &SYSDVAL ^= YES THEN EXIT CODE(0)\n       END\n    ALLOC FI(&DDNAME) DS(&CONCAT) &DISP REUSE\n    SET RC = &LASTCC\n    END\n EXIT CODE(&RC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REFORMAT": {"ttr": 13066, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01\\x02\\x01\\x02\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 258, "newlines": 258, "modlines": 0, "user": "MCRITCH"}, "text": "/* Reformat: rearrange columns and constant information  (REXX)*/\n/*********************************************************************\n MACRO:     Reformat lines of data\n PURPOSE:   Reformat data in edit\n EXAMPLES:\n   Reformat 1 10 '..' 20 30\n   reformat 'line ==>' 1  50 '<==='  .third .zl\n   reformat 0 10 '..' 20 30 ' columns 1-10 now blank'\n   reformat NX 50 70 1 40 .LABA .LABB\n   reformat test '>' x'414243' '<' 1 80   -- on OS2 with ascii\n   reformat test '>' x'c1c2c3' '<' 1 80   -- on TSO with ebcdic\n   ------- additional functions added 1993/12/29 ---\n   reformat hex 1 1 2 50    or  reformat  hex 1 1  2 L\n   reformat unhex 1 2 3 51\n   reformat \"find all word c'\" s 1 8 \"'\"    -- strip(name,'T')\n   ------- additional functions added 1994/10/07 --- using .MSK label\n   reformat m 1 23    1 8  '.spf'  m 40 63    1 8  s m 75 90 \" <==\"\n***********************************************************************\n\n  REFORMAT  Author: David McRitchie, created 1985/08/30 is03\n            at \"The REXX Macros Toolbox\", DMcRitchie@aol.com\n            Rewritten in REXX 1993/05/14 D.McRitchie IS03\n            Revised 1993/07/23 compatability with SPF/2 under OS/2\n            Revised 1993/12/29 HEX, UNHEX options added, L option fixed\n            -- TSO Stats -- created(1985/08/30) initsize(171)--\n  *******************************************************************\n  Title:   reformat the inclusive lines between two labels\n  Users:   TSO ISPF edit users, and OS2 users with SPF from CTC.\n  Entry:   used as an edit clist within ispf edit  ===> reformat\n  Contributed: 08/29/1985 David McRitchie \"The REXX Macros Toolbox\"\n     \"The REXX Macros Toolbox\"\n    \"The REXX Macros Toolbox\"\n  Example(s):\n     ===> reformat  .zfirst .zlast  10 30  200 01  31 40\n     ===> reformat  .refa   .refb   40 45  1 3  75 L\n        The second example reformats lines labeled .refa through\n        .refb such that the line begins with former contents of\n        pos. 40-45, followed by pos. 1-3 then 75 through the end\n        of the line\n     ===> reformat  e  'id(' 1 8 ') '  11 30\n  requirements:\n      constants enclosed in quotes and/or column pairs\n      The second of a column pair can be an L for end of line.\n  options:\n      NX        only do NX lines\n      TEST      use notelines instead of changing data\n      x'hhhh'   hex constant\n      test      use NOTELINE instead of actually changing data\n      HEX       will use C2X() to convert to hex,  cols in next pair\n      UNHEX     will use X2C() to convert to char, cols in next pair\n      S         will strip trailing blanks, cols in next pair\n                should generate noteline if left blank.\n      M         will use .MSK line to obtain \"STRING\"\n    * entire (compatibility) will be substituted by  \".zfirst .zlast \"\n    * init   (option dropped) will be used in an  initial macro\n    * labels required option has been dropped  1993/05/14*\n *****************************************************************/\n\n Address 'ISREDIT'\n 'MACRO (argx)';  /* NOPROCESS  if adding cc-range later */\n linex = substr(time('n'),1,5) 'REFORMAT' argx\n 'LINE_BEFORE .ZFIRST = NOTELINE (linex)'\n err='';labfirst='';lablast='';nx='';pair=0;string='';nulls='';\n prevtoken=0;newtoken=0; hexwork=0; unhexwork=0;stripwork=0;maskwork=0;\n mask=\"\";\n\n if argx = '' then do\n    dataline = 'NOTELINE'\n    argx = \"1 10 'Testing --' 11 72\"\n end\n argx = argx'   '   /* provide for terminating spaces during phase1 */\n\n /* ---- parse similar to  MACRO (a,b,c)  But creating an INTERPRET */\n /* ---- argument utilizing NUM/CHAR column pair determinations     */\n do forever;\n    i = verify(argx,' ')\n    if i =0 then signal endphase1\n    argx = substr(argx,i)\n    x = substr(argx,1,1)\n    if substr(argx,1,2) = \"x'\" then do\n       if pair = 1 then err = 'unpaired column before hex constant'\n       j=pos('''',substr(argx,3));\n       if j \\= 0 then do\n         token = 'X2C('||substr(argx,2,j)''')'\n         /* When in ascii ABC is x'414243'  */\n         string = string'||'token;\n         argx = substr(argx,3+j)\n         minor  = '' /*terminate any pair column started*/\n         pair = 0;\n         if argx = '' then signal endphase1\n       end\n       else exit\n    end;\n    else if x = '''' then do\n       if pair = 1 then err = 'unpaired column before literal'\n       j=pos('''',substr(argx,2));\n       if j \\= 0 then do\n         token = substr(argx,2,j-1);\n         string = string'||'''token'''';\n         argx = substr(argx,2+j)\n         minor  = '' /*terminate any pair column started*/\n         pair = 0;\n         if argx = '' then signal endphase1\n       end\n       else exit\n    end;\n    else if x = \"\"\"\" then do\n       if pair = 1 then err = \"unpaired column before literal\"\n       j=pos(\"\"\"\",substr(argx,2));\n       if j \\= 0 then do\n         token = substr(argx,2,j-1);\n         string = string\"||\"\"\"token\"\"\"\";\n         argx = substr(argx,2+j)\n         minor  = \"\" /*terminate any pair column started*/\n         pair = 0;\n         if argx = \"\" then signal endphase1\n       end\n       else exit\n    end;\n    else do;\n       j = pos(' ',argx)\n       token = substr(argx,1,j-1);\n       argx = substr(argx,j)\n\n       xx = translate(token)\n       if xx = 'HEX' then hexwork = 1\n       else if xx = 'UNHEX' then unhexwork = 1;\n       else if xx = 'NX' then NX='NX'  /* limit process to NX lines */\n       else if xx = 'TEST' | xx ='NOTELINE' then dataline='NOTELINE'\n       else if xx = 'S' then stripwork = 1\n       else if xx = 'M' then do; /*slightly redundant if multiple m */\n                '(LNOlabm) = LINENUM .MSK'\n                if LNOlabm = 0 then do\n                  ZEDSMSG = '.MSK missing'\n                  ZEDLMSG = 'M option requires MASK line at label .MSK'\n                  Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n                  return 1\n               end\n               '(MASK) = LINE .MSK'; maskwork = 1;\n            end;\n       else if xx = 'ENTIRE' then do\n          if labfirst \\= '' then err='...too many labels'\n          labfirst='.ZFIRST'; lablast='.ZLAST';\n       end\n       else if xx = 'INIT' then err='INIT option dropped 1993/05/14'\n       /* check for label before assuming a constant */\n       else if (substr(token,1,1)='.') & length(token) < 7 ,\n        & datatype(substr(token,2),'A') then do\n          if labfirst='' then labfirst=token\n          else if lablast='' then lablast=token\n          else err='.... too many labels .....'\n          '(TTT) = linenum' token\n          if ttt = 0 then err = 'Label' token 'is missing'\n       end\n       else do\n          if pair = 0 then do\n             CURRx = \"CURR\"; if maskwork = 1 then CURRx = \"MASK\";\n             if token = 0 then minor = '||substr(nulls,1';\n             else minor = '||substr('CURRx','token;\n             if stripwork = 1 then minor='||strip(substr('CURRx','token;\n             if hexwork   = 1 then minor='||C2X(substr('CURRx','token;\n             if unhexwork = 1 then minor='||X2C(substr('CURRx','token;\n             prevtoken = token;  /* will have to be subtracted*/\n             pair = 1;\n          end\n          else do    /* process second column in col-pair */\n             if xx \\= 'L' then do;\n                if prevtoken = 0 then newtoken = token /*nulls -- 0 5 */\n                else newtoken = token + 1 - prevtoken\n                string = string||minor||','||newtoken||')'\n                if stripwork = 1 then\n                   do; string = string||\",'T')\"; stripwork=0; end;\n             end;\n             else do\n                if unhexwork = 1 then\n                   err= \"Use of L with UNHEX not permitted\"\n                string = string||minor||')'\n             end\n             if hexwork = 1 then\n                 do; hexwork=0; string=string||')';end;\n             if unhexwork = 1 then do;\n                ttt = newtoken // 2\n                if ttt \\= 0 then err = \"The UNHEX column-pair did\",\n                     \"not address an even number of columns\"\n                unhexwork=0; string=string||')'\n             end;\n             pair = 0;\n             maskwork=0;\n          end\n       end;\n       if argx  = '' then signal endphase1\n    end\n end\n /* ---------------------------------------------------------*/\n endphase1: string = substr(string,3)\n\n if pair = 1 then do\n    \"line_before .zf = Noteline 'Unpaired pairs -- reenter with pairs'\"\n    ZEDSMSG = 'Pairs?'     /* this check added 1995/04/07 FDM */\n    ZEDLMSG = 'Unpaired column range(s) -- see noteline and REENTER'\n    Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    return 12\n end\n\n if labfirst = ' ' then do; labfirst='.ZFIRST'; lablast='.ZLAST';end;\n if lablast = '' then err = 'second label missing'\n else do\n   '(SNO) = linenum' labfirst\n   '(LNO) = linenum' lablast\n   if sno = 0 then sno = 1\n end\n if lno = 0 then err = \"One or more labels specified are missing\"\n if dataline = 'NOTELINE' then say 'string='string\n if err \\= '' then do\n    say err '<--- err'\n    \"(caps) = caps\"\n    \"caps off\"\n    'line_before .zfirst = noteline (err)'\n     ZEDSMSG = \"     \"\n     ZEDLMSG = \"See Noteline --\" err\n     ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n     \"caps\" caps\n     exit 12\n end\n\n do i = sno to lno;\n    doit = 1\n    if nx = 'NX' then do;  /* x  only is not available */\n       '(XSTATUS) = XSTATUS' i;\n       if XSTATUS \\= 'NX' then doit = 0\n    end\n    if doit = 1 then do\n       '(CURR) = line' i\n       line =''\n       /* \"LINE_BEFORE .zf  = INFOLINE \"\"\"string\"\"\"\" */\n       interpret 'LINE = ' string\n       if dataline = 'NOTELINE' then\n          'LINE_BEFORE' i '= INFOLINE (LINE)' /*(LINE) must be caps*/\n       else  do\n            /* SPF/PC will destroy labels -- ISPF would not */\n            '(lab1,lab2) = label' i\n            'LINE' i '= (LINE)'\n            if lab1 \\= \"\" then \"label\" i \"=\" lab1 lab2\n       end\n     end\n end;\n if warnstrip = 1 then  \"line_before .zf = noteline\",\n   \"\"\"REFORMAT use of Strip option(S) has resulted in some nulls\"\"\"\nexit\n/* A scale like the following in a different dataset ideal for testi\n    such scales can be created with the  COLS  macro\n1...5...10...15...20...25...30...35...40...45...50...55...60...65...70\n\n0000000001111111112222222222233333333334444444444555555555566666666667\n1234567890123456789012345678901234567890123456789012345678901234567890\n\nAAAAAAAAAaBBBBBBBBBbCCCCCCCCCcDDDDDDDDDdEEEEEEEEEeFFFFFFFFFfGGGGGGGGGg\n*********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REMBLANK": {"ttr": 13313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00b\\x00b\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 98, "newlines": 98, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- REMBLANK - Remove columns which are all blank in range */\n/*  \"The REXX Macros Toolbox\" SUPPORT -- \"The REXX Macros Toolbox\" -- DAVID MCRI\nAddress \"ISREDIT\"\n/*CONTROL NOFLUSH NOLIST NOMSG*/\n\n/*********************************************/\n/* DO NOT PROCESS ANY LINE COMMANDS UNTIL    */\n/* MACRO INITIALIZATION HAS BEEN COMPLETE.   */\n/*********************************************/\n\n  \"MACRO NOPROCESS (LABF LABL)\"\n\n  labf = translate(labf)\n  nopreserve = ''\n  if labl = '' then if labf = \"NOPRESERVE\"    then do\n     nopreserve = 'NOPRESERVE';labf = ''\n  end\n  If LABL \\= \"\" then do\n     \"(CHK1) = LINENUM \" LABF\n     \"(CHK2) = LINENUM \" LABL\n     If CHK1 \\= \"000000\"  then If CHK2 \\= \"000000\" then do\n        \"LABEL \" LABF \"= .LABF \"\n        If rc \\= 0 then return 16\n        \"LABEL \" LABL \"= .LABL \"\n        If rc \\= 0 then return 16\n     end\n     else do\n        ZEDSMSG = \"Labels\" LABF LABL\n        ZEDLMSG = \"Missing label \" labf \"or\" labl ,\n           \"or both labels missing\"\n        Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n        Return 12\n        Exit   12\n     end\n  END\n  else do\n/*********************************************************************/\n/*  TELL MACRO THAN WE WILL PROCESS ONLY C (COPY)    OPERATIONS      */\n/*********************************************************************/\n\n  \"PROCESS RANGE C M\"\n  CC = RC\n\n  \"(RANGE) = RANGE_CMD\"\n  If RANGE \\= \"C\" then do\n     ZEDSMSG = \"M range invalid\"\n     ZEDLMSG = \"C ranges are only ranges permited\"\n     Address \"ISPEXEC\" \"SETMSG MSG(ISRZ001)\"\n     exit 12\n  end\n\n  If CC =  4  THEN\n   DO\n     ZEDSMSG = \"ENTER ''C''       COMMANDS\"\n     ZEDLMSG = \"C FOR LINE RANGE TO REMOVE BLANKS\"\n     Address \"ISPEXEC\" \"SETMSG MSG(ISRZ001)\"\n\n/*********************************************/\n/*  SET A RETURN CODE OF 12 IN THE CLIST     */\n/*  EXIT COMMAND.  THE CURSOR IS PLACED ON   */\n/*  THE COMMAND LINE AND THE COMMAND IS LEFT */\n/*  DISPLAYED FOR USER CORRECTION.           */\n/*********************************************/\n\n     EXIT 12\n   END\n\n  If  CC >  0 THEN\n   DO\n     \"LINE_AFTER 0 = NOTELINE \"\"PROCESS \",\n       \"RANGE C   RETURN CODE IS &CC -- IN REMBLANK MACRO\"\"\"\n     ZEDSMSG = \"CONFLICTING RANGE\"\n     ZEDLMSG = \"CONFLICTING RANGE SPECIFIED RC=\"||RC\n     \"ISPEXEC SETMSG MSG(ISRZ001)\"\n     EXIT 12\n   END\n  \"LABEL .ZFRANGE = .LABF\"\n  \"LABEL .ZLRANGE = .LABL\"\n end\n /************ */\n  if nopreserve = ''\n  then \"line_before .labf = noteline \"\"Spaces will be preserved\",\n   \"at end of words unless NOPRESERVE is used\"\"\"\n  else \"line_before .labf = noteline \"\"Spaces will not be\",\n   \"preserved at end of words since NOPRESERVE option was invoked\"\"\"\n\n  \"(LRECL) = LRECL\"\n  do i=lrecl to 1 by -1\n    \"seek first p'^' .labf .labl \" I I\n    If RC =0 then do;\n       if i = lrecl | nopreserve = 'NOPRESERVE'\n       then \"change all .labf .labl\" i i \"' ' x'01'\"\n       else \"change all .labf .labl\" i value(i+1) \"' ' x'01'\"\n    end\n  end\n  \"change all .labf .labl ' ' x'05'\"\n  \"change all .labf .labl x'05' ''\"\n  \"change all .labf .labl x'01' ' '\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REMDUPS": {"ttr": 13316, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01\\x0c\\x01\\x0c\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 268, "newlines": 268, "modlines": 0, "user": "MCRITCH"}, "text": "/**rexx******* REMDUPS **********************************************\n     TITLE:       Remove duplicates (remove if same as previous line)\n     Users:       TSO ISPF EDIT users\n     Entry:       Used as an EDIT CLIST within ISPF EDIT\n                        ===> REMDUPS .label1 .label2\n     Contributed: 1985/09/16 David McRitchie\n       converted to REXX 1993/05/31 David McRitchie, DMcRitchie@aol.com\n     Requirements:\n      two labels\n      This macro can be used within a macro\n         for instance within DUADD it is invoked using\n            -------  ISREDIT  REMDUPS .DUADF .DUADL\n\n     EXAMPLE:     REMDUPS  .ZFIRST .ZLAST NX\n                  remdups  .zfirst .zlast nx  1 40\n\n     OPTIONS:\n         NX | X    (OPTIONAL)  PROCESS only NX or X lines\n         LPTR-RANGE | ENTIRE   (optional) LINE POINTER RANGE\n         NOTE      DELETED LINES WILL BE SHOWN WITHIN NOTELINES\n         SHOW      lines that would otherwise be deleted will\n                   show up as a noteline\n         ---FLAG---  BEST RESULTS IF  X ALL  FIRST THEN USE FLAG(0)\n         FLAG      Same as FLAG(0)\n         FLAG(0)   Only changes X-Status to NX-Status for duplicates.\n                   Both original of duplicate and duplicate become NX.\n                   Suggest use of NXDUP instead, unless you wish to\n                   retain NX status of lines already displayed.\n         FLAG(n)   Original line and lines that would otherwise be\n                   deleted are changed to nonexluded (NX) status.\n                   Original and duplicates are flagged in column n.\n         SEP       Insert separator when line changes\n                   e.g. REMDUPS sep 71 82\n         BLANK     Use blank line as separator when line changes.\n         '.string to use with sep--'   in quotes turns sep on\n         n1 n2     from and to columns -- warning may cause\n                   trouble if variable length\n         NXDUP     All lines in range are made X before starting.\n                   All duplicates and their originals become NX.\n      <<<Techniques ------->>>>\n           Keep only dups, remove all others\n                REMDUPS .a .b 1 8 NXDUP ; del .a .b x all\n           Keep only unique entries (delete all matched entries\n                REMDUPS .a .b 1 8 NXDUP ; del .a .b NX all ; reset\n\n       REQUIREMENTS:\n           none\n  ================================================================  **/\n/*********************************************************************/\n\n address 'ISREDIT'; 'MACRO (PARMS) NOPROCESS';\n after=0; Before=0; Change='';\n Labf=''; Labl=''; Remainder='';\n SEPSTR = \".* ========= REMDUPS SEP ====== \";\n blank=''; blankstr='';debug=''; entire=''; flag=''; help='';\n note=''; nx='';\n deleted=0; /*initialize*/  zedlmsg='xxx'; zedsmsg='sss';\n test=''; test=''; /* for continuous testing may be reset to TEST*/\n nxdup='';sep=''; show=''; x=''; fromcol='';tocol='';FORcol=100;done=0\n lastk = 0 /* line number of last k */\n /* Collect Parameters */\n if parms = '' Then signal NOPARMS\n parms = translate(parms)\n\n/* not suited for imbedded blanks but will see initial ending quotes*/\n do iii = 1 to 10;\n   token = word(parms,iii)\n   if token = '' Then leave\n   tokenx = translate(token);\n   if tokenx = \"DEBUG\" then do\n      TRACE Intermediate\n   end\n   j = pos(tokenx,' NX X NOTE SHOW FLAG SEP BLANK DEBUG NXDUP TEST ')\n   if j <> 0 then do;\n      string = token ' = '''token''''; interpret  string; iterate iii;\n   end;\n   if substr(token,1,6) = 'AFTER(' then do;\n      parse var token  'AFTER(' after ')' Right; iterate iii;\n   end\n   if 'FLAG(' = Substr(token,1,5)  then do;\n      parse var token  'FLAG(' flag ')' Right; iterate iii;\n   end\n   if substr(token,1,1) = '.' Then do\n      if labf = '' Then labf = token\n      else if labl = '' Then labl = token\n      else do\n            zedsmsg = '.LABEL RC=8'\n            zedlmsg = 'too many labels --' Labf labl token\n            Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n            exit 8\n      end\n      iterate iii\n   end\n\n   if substr(token,1,1) = \"'\" then do /* \"'\"*/\n      sepstr = substr(token,2,value(length(token)-2))\n      iterate iii\n   end\n   if datatype(token,\"NUM\") then do\n      if fromcol = '' then fromcol = value(token)\n      else if tocol = '' then do;\n          tocol = value(token);  FORcol=tocol + 1 - fromcol\n      end;\n      else do\n        zedsmsg = \"From/To Plus ??\"\n        zedlmsg = \"Can Handle only a Single From/To Pair of Columns\"\n        Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n        exit 12\n      end\n      iterate iii\n   end\n\n   say 'testing remainder --' token '<--'\n   remainder = remainder token\n end iii\n\n if remainder <> \"\" Then do\n    zedsmsg =  Remainder\n    zedlmsg =  remainder \"-- Parameters unknown to REMDUPS\"\n    Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    Exit 8\n end\n\n if nxdup = \"NXDUP\" then do\n    xyz = x||nx||sep||flag\n    if xyz \\= '' then do\n       zedsmsg =  \"NXDUP conflict\" xyz\n       zedlmsg =  \"NXDUP option conflicts with X NX SEP FLAG()\"\n       \"line_before .zfirst = NOTELINE \"\"NXDUP option conflicts\",\n            \"with X NX SEP FLAG()\"\"\"\n       Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n       Exit 8\n    end\n  end\n if fromcol \\= '' then if tocol = '' then do\n       zedsmsg =  \"From/To\"\n       zedlmsg =  \"From/To pair invalid, missing TO column\"\n       \"line_before .zfirst = NOTELINE\" \"From/To pair invalid,\",\n            \"missing TO column\"\n       Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n       Exit 8\n  end\n if entire = \"ENTIRE\" then\n    if labf = '' then do; labf=\".ZFIRST\"; labl=\".ZLAST\"; end\n    else do\n       zedsmsg =  \"ENTIRE\"\n       zedlmsg =  \"ENTIRE used and already specified\" labf labl\n       \"line_before .zfirst = NOTELINE\" zedlmsg\n       Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n       Exit 8\n    end\n\nNOPARMS: nop\n/* process additional LABEL / RANGE relationships */\nif labl = '' Then do\n   \"PROCESS RANGE C\"\n   if RC = 0 THEN DO\n      \"LABEL .zfrange = .labf 1\"\n      \"LABEL .zlrange = .labl 1\"\n      labf = \".labf\"\n      LABL = \".labl\"\n   end\nend\nif labl = '' Then do; labf='.ZFIRST'; labl='.ZLAST'; end;\n\"(LABFNO) = lineNUM\" LABF\n\"(LABLNO) = lineNUM\" LABL\n\"LINE_BEFORE\" labf \"= noteline \"\"===============begin range========\",\n    time('n') \"REMDUPS\" parms\"\"\"\"\n\"LINE_AFTER\"  labl \"= noteline \"\"=============== end  range========\",\n    time('n') \"REMDUPS\" parms\"\"\"\"\n\n if FLAG = \"FLAG\" then flag =  0\n if FLAG \\= \"\" then if flag \\= 0 then do\n    \"seek first p'^'\" labf labl  flag\n    if rc = 0 then do\n       zedsmsg =  \"FLAG(\"flag\") col\"\n       /* zedlmsg =  \"xxxxx flag() error\" */\n       zedlmsg =  \"FLAG(\"flag\") column not blank\" labf labl\n       \"line_before .zfirst = NOTELINE\" \"\"\"\"zedlmsg\"\"\"\"\n       Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n       Exit 8\n    end\n end\n\n/****** all parameters have been received and procesed relationships*/\n\nif nxdup = \"NXDUP\" then \"X ALL\" labf labl\n\"reset SPECIAL\" labf labl\nlineLST = \"..$..#..#..$$$..$$..99\" time('n')\nk = labfno\n/*=================================================================*/\nloop1:\n      \"(KL) = lineNUM\" LABL\n      IF K  >  KL THEN signal LOOP1E\n      IF K  >= KL THEN DONE = 1\n      IF \"\" \\= X||NX then do\n            \"(XSTATUS) = XSTATUS\" k\n             IF XSTATUS  \\= x||NX THEN signal LOOP2\n      END\n      \"(lineCUR) = LINE\" K\n      IF  tocol \\= \"\" THEN ,\n             lineCUR = substr(lineCUR,FROMcol,FORcol)\n      IF sep = \"SEP\"   | blank = \"BLANK\" then do\n             IF lineCUR    \\== lineLST    THEN DO\n               sepcur = sepstr||lineCUR\n               IF BLANK = \"BLANK\" THEN \"LINE_BEFORE\" k \"= (blankstr)\"\n               ELSE \"LINE_BEFORE\" K \"= dataline (sepcur)\"\n               K =  K + 1\n               lineLST = lineCUR\n             END\n             signal LOOP2\n      END\n      /* strictly equal  == include leading, imbeded blankstr*/\n      IF lineCUR   ==   lineLST THEN DO\n             IF NXDUP = \"NXDUP\"  THEN DO\n               \"reset x\" lastk lastk\n               \"reset x\" k k\n                signal LOOP2\n             END\n             IF NOTE = \"NOTE\" then\n               \" LINE_AFTER\" K \"= NOTELINE \"\"deleted\" k \"--\" ,\n                   lineCUR\"\"\"\"\n             IF flag   \\= \"\" THEN DO\n               \"reset x\" lastk lastk\n               \"reset x\" k k\n               if flag \\= 0 then do\n                  \"LABEL\" lastk \"=.FLAG 1\"\n                  \"C ALL .FLAG .FLAG\" FLAG  \"' ' '*' \"\n                  \"LABEL\" k \"= .FLAG 1\"\n                  \"C ALL .FLAG .FLAG\" FLAG  \"' ' '*' \"\n               end\n               signal LOOP2\n             END\n             IF SHOW = \"SHOW\" then do\n               \"(XSTATUS) = XSTATUS\" k\n                IF  XSTATUS  = \"X\" then do\n                  \"(lineSHW) = LINE\" k\n                  \"LINE_AFTER\" k \"= NOTELINE (lineSHW)\"\n                END\n                xyz = \"LINE\"  K \"would be deleted --\" lineCUR;\n                \"LINE_AFTER\" K \"= NOTELINE (xyz)\"\n                signal LOOP2\n             END\n             if TEST = \"TEST\" then do\n               \"LINE_AFTER\" k \"= MSGLINE \"\"TEST in effect;\",\n                  \"otherwise, the above line would be deleted --\",\n                  time('N')\"\"\"\"\n               \"reset\" k k\n             end\n             else do;  /* delete the line if not up 8 */\n                \"DELETE\" k\n                DELETED = DELETED  + 1\n                signal LOOP1\n             end\n      END\n      lineLST = lineCUR\n      lastk = k\nLOOP2:  IF DONE = 1 THEN signal LOOP1E\n      K = K + 1\n      signal LOOP1\n LOOP1E:\n      IF 0 \\= DELETED THEN DO\n             zedlmsg = DELETED \"lines deleted\"\n           \"LINE_BEFORE .ZF = NOTELINE\" ,\n               \"\"\"\"time('N') REMDUPS \"--\" DELETED \"lines deleted\"\"\"\n            address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      END\n      exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REPEATNX": {"ttr": 13321, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\"\\x00\"\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "MCRITCH"}, "text": "/* REPEAT NX LINES  -- BEFORE/AFTER original NX line  -- REXX*/\n/* The default is to repeat the line AFTER the original line */\n/* The INFOLINE will always be inserted between the orig. and newline*/\n/* created 1989/03/13 by David McRitchie, \"The REXX Macros Toolbox\" */\n/* converted to rexx 1994/03/09 F. David McRitchie, and add label range*/\naddress \"ISREDIT\";\"macro (mac)\"\nparse var mac beg1'.'range1'.'range2' 'beg2\nif range2 \\= \"\" then range = '.'range1 '.'range2\nelse range = '.zfirst .zlast'\nmac = translate(strip(beg1||beg2))\nIf mac = \"BEFORE\" then Do\n   last   = \"first\"\n   after  = \"before\"\n   before = \"after\"\n   prev   = \"next\"\nend\nElse Do\n   last   = \"LAST\"\n   after  = \"after\"\n   before = \"before\"\n   prev   = \"prev\"\nend\n\"seek\" last range \"nx 1 p'='\"\nIf rc \\= 0 then return 1\nDo forever\n   \"(ln1) = line .zcsr\"\n   commandx = \"\"\"line_\"after\" .zcsr = dataline (ln1)\"\"\"\n   interpret commandx\n   commandx = \"\"\"line_\"after\" .zcsr = infoline (ln1)\"\"\"\n   interpret commandx\n   \"x all .zcsr .zcsr\"\n   \"seek\" prev range \"nx 1 p'='\"\n   If rc \\= 0 then leave\nend\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXBOX": {"ttr": 13323, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00@\\x00@\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "MCRITCH"}, "text": "/***********************************************************REXX******/\n/*  DRAW A BOX AROUND CLIST LINES (COMMENT THEM OUT)                 */\n/*  MODIFIED FROM CBT TAPE #9102 -- FILE095 MEMBER CLISTBOX          */\n/* *******************************************************************/\n/*  USED CLIST WITH PENDING    ADD-LINES, WITH THE RESULT            */\n/*  THAT    ISPF SESSION ABENDED.   WAITING ON PENDING COMMANDS      */\n/*  IS A REQUIREMENT OF THIS CLIST -- APPEARS NOT TO RECUR           */\n/* *******************************************************************/\n/*  ADDED NOTELINES -- D.MCRITCHIE    1991/05/10, TO REXX 1993/06/11 */\n/* *******************************************************************/\n/*********************************************************************/\n   ADDRESS \"ISREDIT\";\"MACRO (HELP) NOPROCESS\"\n   IF HELP = \"?\" THEN DO\n      /*ADDRESS \"ISPEXEC DISPLAY PANEL(REXXBOX)\"*/\n      CLIST REXXBOX HELP\n      EXIT\n   END\n   STARS = SUBSTR('*',1,64,'*')\"/\"\n   \"PROCESS RANGE C\"\n   LCC = RC\n   \"(RCMD) = RANGE_CMD\"\n   IF RC = 4 | RCMD \\= \"C\" THEN DO\n      ZEDSMSG = \"NO RANGE SPECIFIED\"\n      ZEDLMSG = \"YOU MUST SPECIFY A RANGE OF LINES TO BE BOXED\",\n          \"USING A \"\"C<N>\"\" OR \"\"CC\"\"\"\n      ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ001)\"\n      EXIT 4\n   END\n   \"(FIRST) = LINENUM .ZFRANGE\"\n   \"(LAST) = LINENUM .ZLRANGE\"\n   \"(FR) = LINENUM .ZFRANGE\"\n   \"(LR) = LINENUM .ZLRANGE\"\n/*********************************************************************/\n/*    THIS IS A STARRY BOX CREATED BY THE REXXBOX CLIST              */\n/*********************************************************************/\n   \"LINE_BEFORE .ZFRANGE = NOTELINE \"\"\"TIME() \"START OF\",\n      \"REXXBOX -- LINES\" FR \"TO\" LR \"\"\"\"\n   \"LINE_AFTER         .ZLRANGE = NOTELINE \"\"\"TIME() \"-END OF-\",\n     \"REXXBOX -- LINES\" FR \"TO\" LR \"\"\"\"\n  \"(LBO,RBO) = BOUNDS\"\n  \"BOUNDS 1 72\"\n\n  DO C = FR TO LR\n    \"SHIFT )\" C \"3\"\n  END\n  \"MASKLINE = \"\"/\"||\"*****\"STARS\"\"\"\"\n  \"LINE_BEFORE\" FIRST \"= MASKLINE\"\n\n  DO I = FR TO LR\n    \"LABEL\" I \"= .LJ\"\n    \"SEEK P'^' .LJ .LJ\" LBO  RBO \"FIRST\"\n    \"SEEK P'^' .LJ .LJ\" LBO  RBO \"LAST\"\n    \"CHANGE P'===' '/\"||\"* ' 1\"\n    \"CHANGE P'==' '*\"||\"/' 70\"\n    IF  I =  FR THEN \"LABEL\" I \"= .LJX\"\n  END\n\n  \"SEEK P'=' .LJX .LJX FIRST\"\n  \"MASKLINE = \"\"/\"||\"*****\"STARS\"\"\"\"\n  LAST =  LAST + 1\n  \"LINE_AFTER\" LAST \"= MASKLINE\"\n  \"MASKLINE = ' '\"\n  \"BOUNDS         \" LBO\",\"RBO\n  EXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCLIST72": {"ttr": 13325, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00z\\x00z\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 122, "newlines": 122, "modlines": 0, "user": "MCRITCH"}, "text": " ISREDIT MACRO\n /* DAVID MCRITCHIE --                    1988/05/16 */\n /* SPLIT CLIST SO COL 72 AND BEYOND IS NOT USED\n /* *** */\n /* MORE ESTHETIC RESULTS MAY BE ACHIEVED BY MANUAL MANIPULATIONS\n /*   DO NOT FORGET TO INCLUDE \"+\" WHEN YOU SPLIT A LINE.\n /*   1.  SEE IF ALL LINES SHOULD BE MOVED LEFT (SHIFTNX LEFT N VALIDNX\n /*   2.  X ALL;F 72 124 P'^'\n /*   3.  SPLIT \"= NOTELINE\" AT THE \"=\" SO IT APPEARS ON NEXT LINE\n /*   4.  REMOVE SLASH-ASTERISK \"-*-/-\" COL 72 124\n ISREDIT FIND LAST P'^' 73 124\n IF &LASTCC ^= 0 THEN DO\n    ISREDIT LINE_BEFORE .ZF +\n       = NOTELINE \"&SYSTIME. NOTHING BEYOND COL 72 -- NO CHANGES\"\n    GOTO DONE\n END\n ISREDIT X ALL\n ISREDIT FIND ALL  P'^' 73 124\n SET NCOLS = &STR(1...5...10...15...+\n        20...25...30...35...40...45...50...55...60...65...70..)\n SET LAST13 = 9999999\n SET FLAG = 0\nREPEAT: -\n IF FLAG > 10 THEN DO\n   SET &ZEDSMSG = &STR(FLAG=&FLAG)\n   SET &ZEDLMSG = &STR(&ZEDSMSG. ERRORS)\n   ISREDIT     LINE_AFTER .ZCSR     = NOTELINE \"*ERROR** &XEDLMSG.\"\n   ISPEXEC     SETMSG MSG(ISRZ000)\n   EXIT CODE(4)\n END\n SET MSGX = &STR(, )\n ISREDIT FIND LAST P'^' 73 124\n IF &LASTCC ^= 0 THEN GOTO DONE\n ISREDIT (VAR013,VAR014) = CURSOR\n /* ------------------------------- */\n IF &EVAL(&VAR013.) < &EVAL(&LAST13.) THEN DO\n    SET LAST13 = &VAR013\n    ISREDIT LINE_BEFORE .ZCSR = MSGLINE \"&NCOLS.\"\n    ISREDIT FIND FIRST P'^' .ZCSR .ZCSR\n    ISREDIT (VAR013X,FFF014) = CURSOR\n    ISREDIT FIND NEXT .ZCSR .ZCSR X'615C'\n    /* CHECKED FOR SLASH-AST \"/*\" */\n    ISREDIT (VAR013X,AST014) = CURSOR\n    IF &AST014 ^= &FFF014 THEN DO\n       ISREDIT LINE_AFTER .ZCSR = LINE &VAR013.\n       ISREDIT TSPLIT &VAR013. &AST014.\n       /* DO NOT PLACE CONTINUATION CHARACTER ON LINE*/\n       ISREDIT DELETE &EVAL(&VAR013. + 2)\n       ISREDIT SHIFT ) &EVAL(&VAR013. + 1) 5\n       ISREDIT LABEL &EVAL(&VAR013 + 1) = .AST\n       ISREDIT C &FFF014. '  ' X'615C'\n   END\n END\n ISREDIT FIND LAST .ZCSR .ZCSR 73 124 P'^'\n IF &LASTCC ^= 0 THEN GOTO REPEAT\n ISREDIT FIND PREV .ZCSR .ZCSR 31 71 P' ^'\n SET RC = &LASTCC.\n IF &RC ^= 0 THEN DO\n    ISREDIT FIND LAST .ZCSR .ZCSR 1 72 P'^'\n    IF &LASTCC ^= 0 THEN DO\n       ISREDIT C ALL .ZCSR .ZCSR ' ' X'41'\n       ISREDIT C ALL 1 65 X'41' ''\n       ISREDIT C ALL .ZCSR .ZCSR X'41' ' '\n       SET FLAG = &FLAG + 1\n       GOTO REPEAT\n    END\n    ISREDIT FIND PREV .ZCSR .ZCSR 31 71 ','\n    SET RC = &LASTCC.\n    IF &RC. ^= 0 THEN ISREDIT FIND PREV 31 71 .ZCSR .ZCSR ' '\n    IF &RC = 0 THEN DO\n       ISREDIT FIND NEXT .ZCSR .ZCSR P'^' 1 72\n       IF &LASTCC = 0 THEN DO\n          ISREDIT (VAR013,VAR014) = CURSOR\n          SET VAR014 = &VAR014 - 1\n          GOTO USE\n       END\n    END\n    SET VAR014 = 70\n    SET MSGX = &STR(&MSGX, FORCED TO SPLIT AT 71)\n    GOTO USE\n END\n ISREDIT (VAR013,VAR014) = CURSOR\n IF VAR014 > 32 THEN DO\n    ISREDIT FIND 31 &VAR014. P'^ ' .ZCSR .ZCSR PREV\n    SET RC = &LASTCC.\n END\n IF &RC ^= 0 THEN DO\n    ISREDIT LINE_AFTER .ZCSR = NOTELINE \"******** &VAR013, &VAR014\"\n    ISREDIT FIND ',' LAST 1 70 .ZCSR .ZCSR\n    IF &LASTCC = 0 THEN DO\n       ISREDIT (VAR013,VAR014) = CURSOR\n       SET MSGX = &STR(&MSGX, SPLIT AFTER COMMA)\n       GOTO USE\n    END\n    ISREDIT FIND '^^' LAST 31 71 .ZCSR .ZCSR\n    IF &LASTCC ^= 0 THEN DO\n       SET MSGX = &STR(&MSGX, *SPLIT AT 71*)\n       SET VAR014 = 70\n       GOTO USE\n    END\n    ISREDIT (VAR013,VAR014) = CURSOR\n    SET MSGX = &STR(&MSGX, FORCED TO SPLIT MID-WORD)\n    GOTO USE\n END\nUSE: +\n ISREDIT LINE_AFTER .ZCSR = LINE &VAR013.\n ISREDIT TSPLIT &VAR013. &EVAL(&VAR014. + 1)\n ISREDIT C .ZCSR .ZCSR &EVAL(&VAR014. + 1) ' ' '+'\n ISREDIT DELETE &EVAL(&VAR013. + 2)\n ISREDIT SHIFT ) &EVAL(&VAR013. + 1) 2\n IF &STR(&MSGX.) ^= &STR(, ) THEN ISREDIT LINE_AFTER +\n    .ZCSR = MSGLINE \"&SUBSTR(3:&LENGTH(&STR(&MSGX.)),&STR(&MSGX.))\"\n GOTO REPEAT\nDONE8: -\n SET &ZEDSMSG = &STR(NO BLANK BEFORE 72)\n SET &ZEDLMSG = &STR(DID NOT WANT TO SPLIT THIS LINE DO IT +\n        MANUALLY -- THANK YOU)\n ISREDIT     LINE_AFTER .ZCSR     = NOTELINE \"*ERROR** &XEDLMSG.\"\n ISPEXEC     SETMSG MSG(ISRZ000)\n EXIT CODE(8)\nDONE: -\n EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCOPY": {"ttr": 13569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x008\\x008\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 56, "newlines": 56, "modlines": 0, "user": "MCRITCH"}, "text": "00010000   ISREDIT MACRO (DEBUG)\n00010100   IF DEBUG = &DEBUG THEN -\n00011000        CONTROL LIST CONLIST SYMLIST\n00020000   ISREDIT X ALL\n00030000   ISREDIT F ' EXEC COPY ' ALL\n00030100   ISREDIT (CNT11,CNT12) = FIND_COUNTS\n00031000   ISREDIT F ' EXEC COPY,' ALL\n00031100   ISREDIT (CNT21,CNT22) = FIND_COUNTS\n00032000   ISREDIT F ' EXEC COPY' NX ALL\n00032100   SET CC = &LASTCC\n00033000   ISREDIT (CNT31,CNT32) = FIND_COUNTS\n00040000   IF &CC ^= 0 THEN DO\n00041000      ISREDIT (VAR014A) = DATA_CHANGED\n00042000      IF &STR(&VAR014A) = NO THEN DO\n00042103         IF NOEXIT ^= &DEBUG THEN -\n00042203           ISREDIT CANCEL\n00042300         EXIT CODE(0)\n00042400      END\n00042500      ISREDIT LINE_AFTER 0 = NOTELINE \"DATA WAS CHANGED BEFORE SCOPY INV\n00043000      EXIT CODE(12)\n00044000   END\n00050000   ISREDIT F 'SYSUT1' ALL\n00051000   ISREDIT (CNT41,CNT42) = FIND_COUNTS\n00060000   ISREDIT F 'SYSUT2' ALL\n00061000   ISREDIT (CNT51,CNT52) = FIND_COUNTS\n00062000   IF &CNT31 = &CNT41 AND &CNT31 = &CNT51 THEN DO\n00063000      /********** THE FOLLOWING LINES ARE ALSO IN  SCOPYNX ******\n00063200      ISREDIT C ALL NX ' EXEC COPY,' ' EXEC SCOPY,'\n00063300      ISREDIT C ALL NX ' EXEC COPY ' ' EXEC SCOPY '\n00063400      ISREDIT C ALL NX 'SYSUT1' 'SORTIN'\n00063500      ISREDIT C ALL NX 'SYSUT2' 'SORTOUT'\n00063600      /**********************************************************\n00063700      ISREDIT LINE_AFTER 0 = NOTELINE \"SCOPYNX WAS INVOKED ON YOUR BEHAL\n00063800      ISREDIT F WORD 'COPY' ALL X\n00063902      ISREDIT FIND '.COPY)' FIRST\n00064001      IF &LASTCC = 0 THEN DO\n00064101        ISREDIT LINE_AFTER 0 = NOTELINE \"WARNING  '.COPY)' FOUND AS IN C\n00064201        ISREDIT LINE_AFTER 0 = NOTELINE \"WARNING  '.COPY)' FOUND AS IN C\n00064301        SET &ZEDSMSG = &STR(.. .COPY&RP.)\n00064401        SET &ZEDLMSG = &STR(CHANGE IS INCOMPLETE UNTIL  .COPY&RP.   IS (\n00064501        ISPEXEC     SETMSG MSG(ISRZ000)\n00064601      END\n00064702      ISREDIT FIND '.COPY.' FIRST\n00064801      IF &LASTCC = 0 THEN DO\n00064901        ISREDIT LINE_AFTER 0 = NOTELINE \"WARNING  '.COPY.' FOUND AS IN V\n00065001        ISREDIT LINE_AFTER 0 = NOTELINE \"WARNING  '.COPY.' FOUND AS IN V\n00065101        SET &ZEDSMSG = &STR(.. .COPY....)\n00065201        SET &ZEDLMSG = &STR(CHANGE IS INCOMPLETE UNTIL  .COPY.   IS (ARE\n00065301        ISPEXEC     SETMSG MSG(ISRZ000)\n00065401      END\n00065500      EXIT CODE(1)\n00066000   END\n00068000   SET &ZEDSMSG = &STR(NOT FINISHED)\n00069004   SET &ZEDLMSG = &STR(SCOPYNX NOT INVOKED -- UNMATCHED ' EXEC COPY'= &C\n00069100   ISPEXEC     SETMSG MSG(ISRZ000)\n00070000   ISREDIT F ' EXEC COPY' NX FIRST\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCRIPTPS": {"ttr": 13571, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01\\x9d\\x01\\x9d\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 413, "newlines": 413, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- Invoke SCRIPT with PostScript options                   */\n /*  Author: David McRitchie, \"The REXX Macros Toolbox\", 1991/09/05 */\n /*  Note PostScript codepages are not compatible with 3800-1 chars*/\n /*                                                                */\n /*  Unless a destination is coded, DEST() or GO, output will      */\n /*  remain only in the dataset.  userid.PUBLIC.membername         */\n /*                                                                */\n /* options :                                                      */\n /*  B,          BookMaster                                        */\n /*  DEST(---------)   required if file is to be sent              */\n /*  DEV(----------)                                               */\n /*    LEGAL,    Paper is legal size 8.5 x 11  DEVICE(PSL)         */\n /*  CLASS(-),  specify sysout class, default is G                 */\n /*  CHARS(matrix),  Specify Adobe Font Matrix                     */\n /*  CONT,           Continue after error(s) encountered           */\n /*  FORCE,          Attempt to print even though errors found     */\n /*  REPRINT,        Will not format, print old output at own risk */\n /*  CHARS(----------)   Initial FONTS .......   available TYPESIZE*/\n /*     HELVETICA            generates PSFHV...      3, 7, 8, 10 I  */\n /*     TIMES ROMAN          generates PSFTR...      7, 10   I      */\n /*     COURIER              generates PSFCR...      7, 10   I      */\n /*     PALATINO             generates PSFPL...      7, 10   I      */\n /*  the following are abbreviated to 1st significant word,         */\n /* ITC Avant Garde Gothic   generates PSFAG...      4, 6    I      */\n /* ITC Bookman              generates PSFBK...      3, 6    I      */\n /* ITC Garamond             generates PSFGR...      3, 7    I      */\n /* ITC Korinna              generates PSFKO...      7, 10   I      */\n /*  the following is abbreviated as  NCS                           */\n /* New Century Schoolbook   generates PSFNCS...     7, 10   I      */\n /*  pointsizes,     appended to   CHARS(PSF--xxx)                 */\n /*    3,7,8,10  Pointsize  generates L,B,BK,(null)                */\n /*================================================================*/\n /* store  Encapsulated PostScript (.EPS) in  SYS6.EPS.LOGOS(member)*/\n /*================================================================*/\nAddress \"ISREDIT\"\n\"MACRO (token)\"\n  tokenOrig = token\n \" (VAR014A) = DATA_CHANGED\"\n If VAR014A  = \"YES\" THEN do\n   address \"ISREDIT\"\n   \"SAVE\"\n   \"LINE_BEFORE .ZFIRST = NOTELINE \"\"\"TIME('N'),\n      \"SCRIPTPS  *Data had to be saved before invoking SCRIPT\"\"\"\n END\n\"(MEMBERX) = MEMBER \"\n\"(DSNX)    = DATASET\"\n Address \"TSO\" \"IEFBR14 -- SCRIPTPS\" token \"--\" dsnx\"(\"memberx\")\"\ndev=\"\";chars=\"\";dest=\"\";left=\"\";right=\"\";copies=\"1\";groupid=\"\";PSFILE=\"\"\nreprint=\"\";library=\"SCRIPT.R40.MACLIB\"\ntoken = TRANSLATE(' '||token||' ')  /* TRANSLATE TO UPPERCASE */\n\"(CARD1ST) = LINE .ZFIRST\"  /* FP(1) DUPLEX(NO) can be defaulted */\ncard1st = translate(card1st)\n\nREL = \"\"\ni = index(token,' R40 ');\nif i /=0 then do; REL = \"R40\"\n   parse var token left \" R40 \" right\n   token = left || ' ' || right\nend\nBOOK = \"\"\ni = index(token,' REPRINT ');\nif i /=0 then do; Useprev = \"USEPREV\"\n   parse var token left \" REPRINT \" right\n   token = \" \"left || ' ' || right\" \"\nend\ni = index(token,' B ');\nif i /=0 then do; Book = \"B\"\n   parse var token left \" B \" right\n   token = left || ' ' || right\n   library = \"SCRIPT.EDF.EDFMAC\"   /* SCRIPT.EDF.EDFMAC VERSION LATER*/\nend\ni = index(token,' R40 ');\nif i /=0 then do; REL = \"R40\"\n   parse var token left \" R40 \" right\n   token = left || ' ' || right\nend\n\n/******************/\nibmprof   = process('ibmprof')\nif ibmprof=\"IBMPROF\" then do\n    profiledsn= \"DCF.R40.MACLIB\"\n    library= \"tech.vmsubset.MACLIB\"  /* and dcf.r40.maclib */\nend\n/******************/\nuseprev  = process('USEPREV');\nnoprint = process('NOPRINT');\ncontinue=''\nCONTINUE = process('NOCO');\nif CONTINUE = '' then CONTINUE = process('CONTINUE')\nif CONTINUE = '' then CONTINUE =process('CONT')\nif CONTINUE = '' then CONTINUE =process('CO')\nif continue \\= '' then continue = \" CO \"\nif CONTINUE = 'NOCO' then CONTINUE = ''\nforce = process('FORCE')\nbrowse = process('BROWSE')\nif browse =\"\" then Browse=process('B')\nif browse \\= \"\" then Browse = \"BROWSE\"\n\ni = index(token,' CLASS(')\nif i/=0 then do;\n   parse var token left \" CLASS(\" class \")\" right\n   token = left || ' ' || right\nend\nelse class = \"G\"\nparse var token left \" FP(\" fp \") \" right\n   token = left || ' ' || right\n   if fp /='' then fp = ' FP('fp')';\n   if fp ='' then do\n      \"find 'FP(1)' .zfirst .zfirst\"\n      if rc = 0 then do ; fp = ' FP(1) ';say \"Found FP(1) \",\n         \"on first card will format one pass only\"\n      end\n      else fp=' FP(2)'\n   end\nx8=time('N');x6=substr(x8,1,2)substr(x8,4,2)substr(x8,7,2)\ni = index(token,' GROUPID(')\nif i/=0 then do;\n   parse var token left \" GROUPID(\" groupid \")\" right\n   token = left || ' ' || right\nend\nelse groupid = \"T\"x6\ni = index(token,' COPIES(')\nif i/=0 then do;\n   parse var token left \" COPIES(\" copies \")\" right\n   token = left || ' ' || right\nend\nelse copies = \"1\"\nsysvar = \"\"\n/* The following SYSVAR are in the Starter Set GML */\n/*    C,D,H,P,R,S,T,and W,  also find I,L,M, and X */\n/*    and the SCRIPTPS macro adds        Y, and Z  */\nif substr(sysvar(sysproc),5,4) = \"TEST\" then do\n    if rel = \"\" then do\n       rel = \"R40\"\n       say ' '\n       say 'use of a TEST logon proc has forced',\n         '-- using Release 4.0.0 macros ------'\n       say ' '\n       say 'use of a TEST logon proc has forced',\n         '-- using Release 4.0.0 macros ------'\n    end\nend\nif rel = \"\" then rel = \"R40\"\nif rel = \"R32\" then DSMPROF=\"DSMPROF4\"\nif rel = \"R40\" then DSMPROF=\"DSMPROF4\"\nif rel = \"\" then do;DSMPROF=\"DSMPROF4\";rel=\"R40\";end\n\n\nParse var token left \" DEV(\" DEV \")\" right\nIf dev /= '' then token = left right\n/* some special devices not checking for redundancy */\nI = index(token,\" L \"); If I /=0 then\n   do;DEV = \"PSA90\";token = substr(token,1,I)substr(token,I+3);end\nI = index(token,\" ACROSS \"); If I /=0 then\n   do;DEV = \"PSA90\";token = substr(token,1,I)substr(token,I+8);end\nI = index(token,\" LEGAL \"); If I/=0 then   /* change paper size*/\n   do; dev=\"PSL\"; token = substr(token,1,I)substr(token,I+7); end\nIf DEV = '' then DEV = \"PSA\"\n\nParse var token left \" DEST(\" dest \")\" right;token = left right\nIf dest = \"\" then do\n   I = index(token,\" GO \")\n   If I /= 0 then do;dest = \"P15NF\";  /* used to be P15NF, PROG1A3A */\n      token =substr(token,1,I)substr(token,I+3); end;\n   /* -- three tokens available for SYSTECH room LaserJet IV -MX-   */\n   if dest='' then dest=process(\"PU2ZD\",\"PU2ZD\")\n   if dest='' then dest=process(\"PU\",\"PU2ZD\")\n   if dest='' then dest=process(\"TECHPS\",\"P1CBX\")    /*TCP/IP*/\n   /* no-- if dest='' then dest=process(\"TECHPS\",\"TCPPRTST\")  */\n      /*  SYS6.VPS.CNTL for prod,   SYS6.VPS.R61.CNTL for test       */\n      /*        | member    =G         =A   |  =G         =A         */\n      /*        | dual      dest=    dest=  | single G    single A   */\n      /* TCP    |  no dual avail for TCP    | TCPPRTST    TCPPRTS1   */\n      /*        |                           | ======== or ========   */\n      /* VTAM   | PU2ZDALL PU2ZD    PU2ZD   |                        */\n      /*        | ======== <--active        |                        */\nend\nparse var token left \" FORMS(\" forms \") \" right\n   token = left || ' ' || right\nparse var token left \" DUPLEX(\" duplex \") \" right\n   token = left || ' ' || right\n   duplex = substr(duplex,1,1)\n   i = pos('DUPLEX(NO)',card1st);\n   if i \\=0 then do;\n     say \"Found DUPLEX(NO) \",\n        \"on first card will include SYSVAR(D N)\"\n     if duplex = '' then duplex = \"N\"\n   end   /* save duplex for sysvar later on */\nSTOP = process(\"STOP\")\ni=index(token,\" TECHPSF \");\nif i \\= 0 then do\n   ZEDSMSG = \"TECHPSF invalid\"\n   ZEDLMSG = \"TECHPSF is valid in @SCRIPT, but not in SCRIPTPS\"\n   ADDRESS 'ISPEXEC' 'SETMSG MSG(ISRZ000)'\n   EXIT 4\nend\n\nParse var token  left ' PAGE(' page ')' right;token= left right\nIf page /= '' then page = \" PAGE(\"page\")\"\n\nIf token = \" \" THEN CHARS = \"PSFHV\"  /* USE DEFAULT */\nParse var token  left ' CHARS(' CHARS ')' RIGHT;token = left right\nParse var token  left ' FILE(' PSFILE ')' Right;token = left right\nIf CHARS = '' THEN DO\n   If 0 /= INDEX(token,' HELVETICA ') THEN CHARS = \"PSFHV\"\n   ELSE If 0 /= INDEX(token,' TIMES ROMAN ') THEN do\n      CHARS = \"PSFTR\"; token = substr(token,1,I)||substr(token,I+12)\n      signal chdone\n   end\n   ELSE If 0 /= INDEX(token,' COURIER ')  THEN CHARS = \"PSFCR\"\n   ELSE If 0 /= INDEX(token,' AVANT ')    THEN CHARS = \"PSFAG\"\n   ELSE If 0 /= INDEX(token,' PALATINO ') THEN CHARS = \"PSFPL\"\n   ELSE If 0 /= INDEX(token,' BOOKMAN')   THEN CHARS = \"PSFBK\"\n   ELSE If 0 /= INDEX(token,' GARAMOND')  THEN CHARS = \"PSFGR\"\n   ELSE If 0 /= INDEX(token,' KORINNA')   THEN CHARS = \"PSFKO\"\n   ELSE If 0 /= INDEX(token,' NCS')       THEN CHARS = \"PSFNCS\"\n   ELSE If 0 /= INDEX(token,' KORINNA')   THEN CHARS = \"PSFKO\"\n   ELSE CHARS = 'PSFHV'\n   If I /= 0 then do; k = index(substr(token,I,),' ');\n      token = substr(token,1,I)||substr(token,I+k)\n   end; chdone:\nEND\nIf 0 /= INDEX(token,' 3 ') THEN CHARS = CHARS||'L';\nIf 0 /= INDEX(token,' 7 ') THEN CHARS = CHARS||'B';\nIf 0 /= INDEX(token,' 8 ') THEN CHARS = CHARS||'BK';\nIf 0 /= INDEX(token,' ITALIC ') | ,\n   0 /= INDEX(token,' I ') THEN DO\n     xx = substr(chars,4,2)\n     If 0 /= index('HV CR AG',substr(chars,4,2))\n     then chars = chars||'O'; else chars = Chars||'I';\nend\n\nIf token /= \"\" then do\n   say \"Possibility of unprocessed parameters\"\n   say \" --\" token\n   /*return*/\nend\n\nIf 0 /= INDEX(token,' E ') THEN PSOUT = 'E'; ELSE PSOUT = 'A'\nMEMBERD = MEMBERX\nIf MEMBERD = \"CNTL\" | MEMBERD = \"TEXT\" THEN MEMBERD = \"LIST\"\nIF substr(memberx,1,1) = \"S\" then\n   if dsnx = \"TECH.LIBR2.TEXT\" then memberx = 'A'||substr(memberx,2)\nif memberd = '' then memberd='GOGO'\nFILE = \"PUBLIC.\"||MEMBERD\nIf SUBSTR(FILE,1,13) = \"PUBLIC.ESHAJK\" THEN\n   FILE = \"PUBLIC.\"||SUBSTR(FILE,12)\nFILE = \"'\"||SYSVAR(SYSUID)||\".\"||FILE||\"'\"\nif PSFILE \\= '' then do\n   if substr(psfile,1,1) \\= \"'\" then psfile=\"'\"psfile\"'\"\n   say \"Override FILE\" file '..with..' psfile\n   file = psfile\nend\nAddress \"TSO\"\nX = SYSDSN(FILE)\nIf x = \"OK\" THEN DEL FILE\n\nX = SYSDSN('''SCRIPT.'rel'.FONTPS('||CHARS||')''')\nIf x /= \"OK\" then do\n  Address \"ISREDIT\"\n  \"LINE_BEFORE .ZFIRST = NOTELINE \"\"\"TIME('N'),\n   \"SCRIPTPS   ADOBE FONT Matrix (AFM) not found -- \"||chars||\"  RC=4\"\"\"\n  \"LINE_BEFORE .ZFIRST = NOTELINE \"\"          \",\n         \"using  SCRIPTPS\"||token||\"\"\"\"\n  \"UP MAX\"\n  \"LOC 0\"\n   ZEDSMSG = \"CHARS(??)\"\n   ZEDLMSG = \"Adobe Font Matrix (AFM) not found in SCRIPT.\"rel\".FONTPS\",\n      \"FOR CHAR(\"||chars||\")\"\n   ADDRESS 'ISPEXEC' 'SETMSG MSG(ISRZ000)'\n   EXIT 4\nend\n\"$TIME -- SCRIPTPS\"\n/* place our default SYSVAR in font of any supplied, except BookMaster*/\nif duplex = \"Y\" | duplex = \"YES\" | duplex = \"\" then duplex = \"Y\"\nsysvar = strip(sysvar) \"D\" duplex\npsdest = dest\nif psdest = \"\" then psdest = 'None'\nif book = \"B\" then do;\n   profiledsn = \"SYS1.EDF.EDFMAC1\"\n   profiledsn = \"SCRIPT.EDF.EDFMAC\"\n   dsmprof=\"EDFPRF40\"\n   sysvar = sysvar \"G INLINE Z\" psdest\nend;\nelse do;\n   profiledsn = \"SCRIPT.\"rel\".MACLIB\"\n   sysvar = \"X NO H NO Y\" sysvar(\"SYSUID\") \"Z\" psdest\" D \"duplex\n   /******************/\n   if ibmprof=\"IBMPROF\" then profiledsn= \"DCF.R40.MACLIB\"\n   /******************/\nend;\nif memberx /= '' then DCFcommand =,\n    \"SCRIPT '\"||DSNX||\"(\"||MEMBERX||\")'\"\nelse DCFcommand =  \"SCRIPT '\"||DSNX\"'\"\nif library \\= '' then  library = \" LIB('\"library\"')\"\nDCFcommand = DCFcommand \"INDEX B(1I)\"fp||continue,\n   \" SYS(\"sysvar\")\" library,\n   page\" DEV(\"||DEV||\") CHARS(\"||CHARS||\")\" ,\n   \"PSOUT(\"||PSOUT||\") FI(\"||FILE||\")\" ,\n   \"FO('SCRIPT.\"rel\".FONTPS') PRO('\"profiledsn\"(\"DSMPROF\")')\"\nsay '-------------'\nsay DCFcommand\nsay '-------------'\nif stop = \"STOP\" then do\n     Address \"ISREDIT\" \"LINE_BEFORE .ZFIRST = NOTELINE \"\"\"TIME('N'),\n        \"You choose to  STOP  before formatting\"\"\"\n     ZEDSMSG = \"STOP in effect\"\n     ZEDLMSG = \"You choose to  STOP  before formatting\"\n     ADDRESS 'ISPEXEC' 'SETMSG MSG(ISRZ000)'\n     return 1\nend\nif USEPREV = \"USEPREV\" then lastcc = 0\nelse DCFcommand\nlastcc = rc\n\nstatus = msg('off')\nADDRESS \"TSO\" \"FREE DA('SYS6.EPS.LOGOS')\"\nstatus = msg('on')\n\n\"$TIME -- SCRIPTPS\"\nScriptRC = lastcc\nif ScriptRC = 4 then\n   say 'Script/VS RC='ScriptRC' -- will try to use'\nif ScriptRC > 4  then do\n   if FORCE = \"FORCE\" then if continue \\= \"\" then leave\n   /* if you use force you may be asking for a heap of trouble */\n   if dest \\= \"\" then  say 'Script/VS RC='ScriptRC', print terminated'\n   else say 'Script/VS RC='ScriptRC', errors occurred do not print'\n   ZEDSMSG = \"Script/VS RC=\"ScriptRC\n   ZEDLMSG = \"SCRIPT invoked by\" SYSVAR(SYSICMD) ,\n        \"had errors,  Script/VS RC=\"ScriptRC\n   Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   return 1\nend\nif Browse = \"BROWSE\" then do;\"$BROWSE\" FILE;say DCFcommand;end\nif noprint = \"NOPRINT\" then do\n     Address \"ISREDIT\"\n     \"LINE_BEFORE .ZFIRST = NOTELINE \"\"\"TIME('N'),\n        \"You chose not to print, even though\",\n            \"you set dest=\"dest\", Script/VS RC=\"||ScriptRC\"\"\"\"\n     \"LINE_BEFORE .ZFIRST = NOTELINE \"\"\"TIME('N'),\n        \"You may reprint without reformatting by reinvoking\",\n            \"SCRIPTPS and including  REPRINT\"\"\"\n     ZEDSMSG = \"SCRIPTPS RC=\"||lastcc\n     ZEDLMSG = \"SCRIPTPS invoked SCRIPT and got\",\n             \"a return code of \"||lastcc\n     ADDRESS 'ISPEXEC' 'SETMSG MSG(ISRZ000)'\n   return 1\nend\nIf dest /= \"\" then do\n   Address \"TSO\"\n   status = msg('off')\n   \"FREE OUTDES(NAME1) FI(SYSUT1 SYSUT2 SYSPRINT)\"\n   status = msg('on')\n   groupid = \" GROUPID(\"groupid\")\"\n   outdes = \"DEST(\"dest\") COPIES(\"copies\")\" groupid\n   if forms \\= '' then outdes = outdes \"FORMS(\"strip(forms)\")\"\n   \"OUTDES NAME1\" OUTDES\n   rcc = rc\n   if rcc /= 0 then do\n     Address \"ISREDIT\"\n     \"LINE_BEFORE .ZFIRST = NOTELINE \"\"\"TIME('N'),\n        \"OUTDES NAME1\" OUTDES \" --- failed  RC=\"||rcc\"\"\"\"\n     Address \"TSO\"\n   end\n   If rcc /= 0 then leave\n   \"ALLOC FI(SYSPRINT) DUMMY                 \"\n   \"ALLOC FI(SYSUT1) DA(\"FILE\") SHR\"\n   \"ALLOC FI(SYSUT2) SYSOUT(\"class\") OUTDES(NAME1) \"\n   \"ALLOC FI(SYSIN) DUMMY REUSE              \"\n   \"CALL 'SYS1.LINKLIB(IEBGENER)'            \"\n   rcc=rc\n   If rcc = 0 then do\n     SAY \"PostScript Document has been Printed to CLASS(\"class\")\",\n         \"  DEST(\"dest\") COPIES(\"copies\"),  Script/VS RC=\"ScriptRC\n     Address \"ISREDIT\"\n     \"LINE_BEFORE .ZFIRST = INFOLINE \"\"\"TIME('N'),\n        \"SCRIPTPS   Printed CLASS(\"class\") DEST(\"dest\")  RC=\"||,\n        rcc\", ScriptRC=\"ScriptRC\" COPIES(\"copies\") --\" tokenOrig \"\"\"\"\n     Address \"TSO\"\n   end\n   else SAY \"#$#$#$# Failed PostScript Document to CLASS(\"class\") rc=\"rcc\n   \"FREE FI(SYSUT1 SYSUT2) OUTDES(NAME1)     \"\n   \"ALLOC FI(SYSIN) DA(*) REUSE              \"\n   \"ALLOC FI(SYSPRINT) DA(*) REUSE           \"\nend\nAddress \"ISREDIT\"\n\"LINE_BEFORE .ZFIRST = NOTELINE \"\"\"TIME('N'),\n   \"SCRIPTPS   Created \" FILE \"Chars(\"||chars||\")  RC=\"||lastcc\"\"\"\"\nZEDSMSG = \"SCRIPTPS RC=\"||lastcc\nZEDLMSG = \"SCRIPTPS invoked SCRIPT and got a return code of \"||lastcc\nADDRESS 'ISPEXEC' 'SETMSG MSG(ISRZ000)'\n\"up 3\"\n\"LOC 0\"\nif dest = \"\" then do\n  say \"You chose not to print, there was no destination. DEST(dest)\"\n  say \"You chose not to print, there was no destination. DEST(dest)\"\n  say  \"You may reprint without reformatting by reinvoking\",\n            \"SCRIPTPS and including\"\n  say  \"    REPRINT DEST(xxxx)\"\n  address \"ISREDIT\" \"LINE_BEFORE .ZFIRST = NOTELINE \"\"     You chose\",\n     \"not to print since you did not supply a destination\"\"\"\nend\nIf lastcc /= 0 then exit 4;else exit 1\nreturn\nProcess: procedure expose token\n arg subtoken, giveback  /* comma is important, must match*/\n if giveback = '' then giveback = subtoken\n i = index(token,' '||subtoken||' ')\n if i=0 then return ''\n tokenx = substr(token,1,I) || substr(token,I+2+length(subtoken))\n token = tokenx\n return giveback\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SEARCH4": {"ttr": 13578, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00.\\x00.\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX test of command for 2.3.14 SearchFor                  */\n/* CREATED by D.McRitchie, \"The REXX Macros Toolbox\", 1991/10/24 */\n/*    comparable   edit  macro is  @search4                   */\n/*    comparable tso rexx exec is  SEARCH4                    */\n/* multiple search arguments must be separated by commas      */\n/*  without intervening spaces unless part of search arg.     */\n/*    e.g.                                                    */\n/*  ===> TSO SEARCH full.dsname 1a 1b,c2 d2 e2,'3f 3g 3h 3i'  */\n/*   quotes are optional but dsname must be fully qualified   */\n/* ---------------------------------------------------------- */\n/*********************************************************************/\n/*  Manual for ISPF/PDF Guide and Ref. V3R3 MVS -- SC34-4258-01      */\n/*********************************************************************/\nParse arg token\ni= index(token,\" \")\nif i /= 0 then do;\n   dsn = substr(token,1,I-1)\n   dsn = strip(translate(dsn,' ',''''),'b')\n   token = substr(token,I+1)\nend\nelse do\n   dsn = token\n   token = ''\nend\nif dsn = '' then DSSFNDSN = ''; else DSSFNDSN = \"'\"dsn\"(*)'\"\n/* ---------------------------------------------------------- */\n\nif token = '' then ADDRESS \"ISPEXEC\" \"VPUT (DSSFNDSN)\"\nelse do   /* conditional update of VPUT arguments */\n   parse var token zssfs1 ',' zssfs2 ',' zssfs3 ',' zssfs4 ',' ,\n            zssfs5 ',' zssfs6 ',' zssfs7\n   /*  single imbedded quotes are invalid, even within double quotes*/\n   /*  -- will not be tested for here, left to SEARCHFOR to tell you*/\n   do i = 1 to 7 /*interpret executes expression*/\n      x = \"if zssfs\"i\" /= '' then if substr(zssfs\"i\",1,1) /= ''''\" ,\n      \" then do;j = index(zssfs\"i\",' ');if j/=0 then zssfs\"i ,\n          \" = \"\"'\"\"zssfs\"i\"\"\"'\"\";end\"  /* say x -- to debug*/\n      interpret x; /*change if any blank, unless begins with quote*/\n   end\n   if zssfs2 = '' then zssfmult = 'NO'; else zssfmult = 'YES'\n   Address \"ISPEXEC\" \"VPUT (DSSFNDSN ZSSFMULT ZSSFS1 ZSSFS2 \",\n            \"ZSSFS3 ZSSFS4 ZSSFS5 ZSSFS6 ZSSFS7)\"\nend\nAddress \"ISPEXEC\" \"SELECT PGM(ISRSFM)\"  /* OPT 2.3.14  Search*/\nDSSFNDSN = ''\nAddress \"ISPEXEC\" \"VPUT DSSFNDSN\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SELPANEL": {"ttr": 13580, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\r\\x00\\r\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "MCRITCH"}, "text": "    PROC 0 PANEL(ISR@PRIM)\n    CONTROL MAIN\n    LOOP: ISPEXEC DISPLAY PANEL(&PANEL)\n          SET RC = &LASTCC.\n          IF &RC = 8 THEN EXIT CODE(0)\n          IF &STR(&ZSEL.) = &STR() THEN GOTO LOOP\n          IF &STR(&ZSEL.) = &STR(EXIT) THEN EXIT CODE(0)\n          IF &STR(&ZSEL.) = &STR(?) THEN DO\n             ISPEXEC SETMSG MSG(ISPD241)\n             GOTO LOOP\n             END\n          ISPEXEC SELECT &ZSEL.\n          GOTO LOOP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHIFT": {"ttr": 13582, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xba\\x00\\xba\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 186, "newlines": 186, "modlines": 0, "user": "MCRITCH"}, "text": "/*  REXX: SHIFT   RIGHT|LEFT Cols                                    */\n/*  Title:   SHIFT   Cols                                            */\n/*  Users:   SCRIPT/VS users or other ISPF edit users                */\n/*  Entry:   Used as an edit macro within ISPF edit                  */\n/*  Contributed: 1986/04/21 David McRitchie                          */\n/*  conversion to REXX 1994/01/04 David McRitchie using SHIFTNX model */\n/*                                                                   */\n/*  examples:                                                        */\n/*           ===> SHIFT   left 8                                     */\n/*           ===> SHIFT   left 3 force                               */\n/*  options:                                                         */\n/*      lbl-range       (optional)  label range,                     */\n/*                                  defaults to .zfirst .zlast       */\n/*                           used to be required for SHIFT           */\n/*      X NX | NX | X   (optional)  restrict to  non-excluded,       */\n/*                                  or excluded lines -------------  */\n/*      RIGHT | LEFT    (required)  direction                        */\n/*      scnt            (required)  number of Columns to be shifted */\n/*      FORCE           (optional)  allows loss due to shifting      */\n/*      VALIDNX         (optional)  do but only for lines which      */\n/*                         would not need to be forced (FORCE).      */\n/*  Requirements:                                                    */\n/*   on a SHIFT   LEFT no data is to be lost, unless FORCE           */\n/*   on a SHIFT   RIGHT no data is to be lost, unless FORCE          */\n/*********************************************************************/\nAddress \"ISREDIT\";\"MACRO (TOKEN)\"\n\"LINE_BEFORE .ZFIRST = NOTELINE \"\"\",\n      ||TIME('N') SYSVAR(SYSICMD) TOKEN\"\"\"\"\nTOKEN = \" \"TRANSLATE(TOKEN)\" \"\ni=POS(' HELP ',token); if i/=0 then do ;\n    Address \"TSO\" \"pdsdd sysproc @SCRIPT\";RETURN; end ;\n\nx=''; nx=''; right=''; left=''; scnt=0; force=''\nlabf='';labl='';remain=\"\";validnx=\"\"\n do iii = 1 to 12;\n   subtoken = word(token,iii)\n   if subtoken = '' then leave\n   subtoken = translate(subtoken); subtokenx = ' '||subtoken||' '\n   j = pos(subtokenx,' X NX RIGHT LEFT FORCE VALIDNX')\n   if j \\= 0 then do;\n      string = subtoken ' = '''subtoken''''\n      interpret  string\n      iterate iii\n   end;\n   if substr(subtoken,1,1) = '.' then do\n      select\n         when labf = '' then labf = subtoken\n         when labl = '' then labl = subtoken\n         otherwise\n            zedsmsg = '.LABEL RC=8'\n            zedlmsg = 'too many labels --' labf labl subtoken\n            Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n            return 8\n      end /* select */\n      iterate iii\n   end\n   remain = remain subtoken\n end iii\n if datatype(remain,'n') then scnt = remain\n else do\n   zedsmsg = 'AMT'\n   zedlmsg = 'Missing number of columns to be shifted,  i.e. 10'\n   Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   return 8\n end\n fini0: nop\n\n if labf  = '' then do;\n    labf = '.zfirst'; labl='.zlast'\n end;\n if labl = '' then do\n   zedsmsg = 'labels'\n   zedlmsg = 'Exactly two labels can be specified (default -- .zf .zl)'\n   Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   return 1\n end\n\n/* Process collected parameters */\n '(LNOlabf) = LINENUM' labf\n '(LNOlabl) = LINENUM' labl\n if LNOlabf = 0 | LNOlabl = 0 then do\n   zedsmsg = 'labels invalid'\n   zedlmsg = 'labels supplied' labf labl 'are invalid'\n   Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   return 1\nend\nif datatype(scnt,'N') = 0 then do\n   zedsmsg = 'not numeric'\n   zedlmsg = token '-- Cols to shift right/left not numeric'\n   Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   return 1\n end\n/* End of processing collected parameters **************************/\nAddress \"ISREDIT\" \"(DWIDTH) = DATA_WIDTH\"\nAddress \"ISREDIT\" \"(LBOUND,RBOUND) = BOUNDS\"\nIF RBOUND = '' THEN  RBOUND = dwidth\n\n/* Begin Code for  SHIFT    macro *********************************/\n/*   Preliminary test for validity columns to be moved around *****/\nif validnx = \"VALIDNX\" then do\n  IF X = '' then if nx = '' then   NX = \"NX\"  /* only for validnx*/\nend\nIF X = \"X\" then if NX = \"NX\" then do; x = ''; nx=''; end;\nIF VALIDNX =  \"VALIDNX\" then if NX = ''      THEN DO\n    ZEDSMSG = 'X VALIDNX'\n    ZEDLMSG = 'VALIDNX requires \"NX\" ONLY NOT \"X\" -- ',\n             'VALIDNX will cause EXCLUDE'\n    Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n    RETURN 12\n END\n SLEFT =  LEFT||RIGHT\n IF SLEFT = \"\" |  sleft = \"LEFTRIGHT\" then do\n    ZEDSMSG = 'LEFT | RIGHT'\n    ZEDLMSG = 'Direction required, supply either \"LEFT\" or \"RIGHT\"'\n    Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n    RETURN 12\n END\n IF scnt = '' THEN DO\n    ZEDSMSG = 'Shift Amount'\n    ZEDLMSG = 'Must specify the number of columns to be shifted'\n    Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n    RETURN 12\n END\n /******** Begin processing having complete parameter processing */\ncol1r = rbound + 1 - scnt; col2r = rbound\ncol1l = lbound;  col2l = lbound + scnt - 1\nIF SLEFT = \"LEFT\" THEN DO\n   IF VALIDNX = \"VALIDNX\" THEN\n   Address \"ISREDIT\" \" EXCLUDE P'^'\" labf labl ALL  lbound col2l\n   Address \"ISREDIT\" \" SEEK P'^'\"    labf labl X NX lbound col2l\n   IF RC = 0 THEN       DO\n      ZEDSMSG = 'Can''t SHIFT left'\n      ZEDLMSG = LABF \"THRU\" labl x||nx \"Cols\" lbound\"-\",\n      ||col2l \"NOT BLANK -- VALIDNX NOT SPECIFIED\",\n        \"bounds(\"lbound rbound\")\"\n      Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n      IF FORCE = \"FORCE\" THEN DO\n         ZEDSMSG = 'Data forced out'\n         ZEDLMSG = LABF \"THRU\" labl x||nx \"Cols\" lbound\"-\",\n         ||SCNT \"NOT BLANK -- FORCE Requested\"\n      END\n      ELSE RETURN 12\n   END\nEND\nIF SLEFT = \"RIGHT\" THEN DO\n   IF VALIDNX = \"VALIDNX\" THEN\n      Address \"ISREDIT\" \"EXCLUDE P'^'\" labf labl ALL col1r rbound\n   Address \"ISREDIT\" \" SEEK P'^'\"   labf labl X NX col1r rbound\n   IF RC = 0 THEN       DO\n      ZEDSMSG = 'Can''t SHIFT right'\n      ZEDLMSG = 'Cols' col1r rbound 'NOT BLANK -- SHIFT RIGHT',\n               'NOT PERFORMED, bounds('lbound rbound\")\"\n      Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n      IF FORCE = \"FORCE\" THEN DO\n         ZEDSMSG = 'Data FORCEd out'\n         ZEDLMSG = 'Cols' col1r rbound 'NOT BLANK -- Force Requested'\n         Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n      END\n      ELSE RETURN 12\n   END\nEND\nIF LNOlabl < LNOlabf then do\n    ZEDSMSG = 'LABEL for .LABF/L'\n    ZEDLMSG = 'LABF MUST APPEAR EARLIER THAN labl'\n    Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n    RETURN 12\nEND\n/**************************************************/\nI =  LNOlabF\nDO i = LNOlabf to LNOlabL\n   Address \"ISREDIT\" \"(VAR075) = XSTATUS\" I\n   IF  VAR075 =  NX |   VAR075 =  X  | X||NX  = '' THEN DO\n     IF SLEFT = \"LEFT\" THEN\n        Address \"ISREDIT\" \"SHIFT (\" I scnt\n     IF SLEFT = \"RIGHT\" THEN\n        Address \"ISREDIT\" \"SHIFT )\" I scnt\n   END\nEND\nZEDSMSG = 'COMPLETED'\nZEDLMSG = 'Finished edit macro ===>' sysvar(sysicmd),\n         LABF LABL X NX SLEFT SCNT\nAddress \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\nAddress \"ISREDIT\" ,\n\"LINE_BEFORE .ZCSR = NOTELINE \"\"\"TIME('N') ,\n   \" ===> \" SYSVAR(SYSICMD)\" --completed RC=\"RC  Date('U')\"\"\"\"\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHIFTNX": {"ttr": 13828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xb7\\x00\\xb7\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 183, "newlines": 183, "modlines": 0, "user": "MCRITCH"}, "text": "/*  REXX: SHIFTNX RIGHT|LEFT Cols                                    */\n/*  Title:   SHIFTNX Cols                                            */\n/*  Users:   SCRIPT/VS users or other ISPF edit users                */\n/*  Entry:   Used as an edit macro within ISPF edit                  */\n/*  Contributed: 1986/04/21 David McRitchie                          */\n/*  conversion to REXX 1993/09/02 David McRitchie                    */\n/*                                                                   */\n/*  examples:                                                        */\n/*           ===> shiftnx left 8                                     */\n/*           ===> shiftnx left 3 force                               */\n/*  options:                                                         */\n/*      lbl-range       (optional)  label range,                     */\n/*                                  defaults to .zfirst .zlast       */\n/*      X NX | NX | X   (optional)  restrict to  non-excluded,       */\n/*                                  or excluded lines default is NX  */\n/*      RIGHT | LEFT    (required)  direction                        */\n/*      scnt            (required)  number of Columns to be shifted */\n/*      FORCE           (optional)  allows loss due to shifting      */\n/*      VALIDNX         (optional)  do but only for lines which      */\n/*                         would not need to be forced (FORCE).      */\n/*  Requirements:                                                    */\n/*   on a SHIFTNX LEFT no data is to be lost, unless FORCE           */\n/*   on a SHIFTNX RIGHT no data is to be lost, unless FORCE          */\n/*********************************************************************/\nAddress \"ISREDIT\";\"MACRO (TOKEN)\"\n\"LINE_BEFORE .ZFIRST = NOTELINE \"\"\",\n      ||TIME('N') SYSVAR(SYSICMD) TOKEN\"\"\"\"\nTOKEN = \" \"TRANSLATE(TOKEN)\" \"\ni=POS(' HELP ',token); if i/=0 then do ;\n    Address \"TSO\" \"pdsdd sysproc @SCRIPT\";RETURN; end ;\n\nx=''; nx=''; right=''; left=''; scnt=0; force=''\nlabf='';labl='';remain=\"\";validnx=\"\"\n do iii = 1 to 12;\n   subtoken = word(token,iii)\n   if subtoken = '' then leave\n   subtoken = translate(subtoken); subtokenx = ' '||subtoken||' '\n   j = pos(subtokenx,' X NX RIGHT LEFT FORCE VALIDNX')\n   if j \\= 0 then do;\n      string = subtoken ' = '''subtoken''''\n      interpret  string\n      iterate iii\n   end;\n   if substr(subtoken,1,1) = '.' then do\n      select\n         when labf = '' then labf = subtoken\n         when labl = '' then labl = subtoken\n         otherwise\n            zedsmsg = '.LABEL RC=8'\n            zedlmsg = 'too many labels --' labf labl subtoken\n            Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n            return 8\n      end /* select */\n      iterate iii\n   end\n   remain = remain subtoken\n end iii\n if datatype(remain,'n') then scnt = remain\n else do\n   zedsmsg = 'AMT'\n   zedlmsg = 'Missing number of columns to be shifted,  i.e. 10'\n   Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   return 8\n end\n fini0: nop\n\n if labf  = '' then do;\n    labf = '.zfirst'; labl='.zlast'\n end;\n if labl = '' then do\n   zedsmsg = 'labels'\n   zedlmsg = 'Exactly two labels can be specified (default -- .zf .zl)'\n   Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   return 1\n end\n\n/* Process collected parameters */\n '(LNOlabf) = LINENUM' labf\n '(LNOlabl) = LINENUM' labl\n if LNOlabf = 0 | LNOlabl = 0 then do\n   zedsmsg = 'labels invalid'\n   zedlmsg = 'labels supplied' labf labl 'are invalid'\n   Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   return 1\nend\nif datatype(scnt,'N') = 0 then do\n   zedsmsg = 'not numeric'\n   zedlmsg = token '-- Cols to shift right/left not numeric'\n   Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   return 1\n end\n/* End of processing collected parameters **************************/\nAddress \"ISREDIT\" \"(DWIDTH) = DATA_WIDTH\"\nAddress \"ISREDIT\" \"(LBOUND,RBOUND) = BOUNDS\"\nIF RBOUND = '' THEN  RBOUND = dwidth\n\n/* Begin Code for  SHIFTNX  macro *********************************/\n/*   Preliminary test for validity columns to be moved around *****/\nIF X = '' then if nx = '' then   NX = \"NX\"  /* DEFAULT */\nIF X = \"X\" then if NX = \"NX\" then do; x = ''; nx=''; end;\nIF VALIDNX =  \"VALIDNX\" then if NX = ''      THEN DO\n    ZEDSMSG = 'X VALIDNX'\n    ZEDLMSG = 'VALIDNX requires \"NX\" ONLY NOT \"X\" -- ',\n             'VALIDNX will cause EXCLUDE'\n    Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n    RETURN 12\n END\n SLEFT =  LEFT||RIGHT\n IF SLEFT = \"\" |  sleft = \"LEFTRIGHT\" then do\n    ZEDSMSG = 'LEFT | RIGHT'\n    ZEDLMSG = 'Direction required, supply either \"LEFT\" or \"RIGHT\"'\n    Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n    RETURN 12\n END\n IF scnt = '' THEN DO\n    ZEDSMSG = 'Shift Amount'\n    ZEDLMSG = 'Must specify the number of columns to be shifted'\n    Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n    RETURN 12\n END\n /******** Begin processing having complete parameter processing */\ncol1r = rbound + 1 - scnt; col2r = rbound\ncol1l = lbound;  col2l = lbound + scnt - 1\nIF SLEFT = \"LEFT\" THEN DO\n   IF VALIDNX = \"VALIDNX\" THEN\n   Address \"ISREDIT\" \" EXCLUDE P'^'\" labf labl ALL  lbound col2l\n   Address \"ISREDIT\" \" SEEK P'^'\"    labf labl X NX lbound col2l\n   IF RC = 0 THEN       DO\n      ZEDSMSG = 'Can''t SHIFT left'\n      ZEDLMSG = LABF \"THRU\" labl x||nx \"Cols\" lbound\"-\",\n      ||col2l \"NOT BLANK -- VALIDNX NOT SPECIFIED\",\n        \"bounds(\"lbound rbound\")\"\n      Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n      IF FORCE = \"FORCE\" THEN DO\n         ZEDSMSG = 'Data forced out'\n         ZEDLMSG = LABF \"THRU\" labl x||nx \"Cols\" lbound\"-\",\n         ||SCNT \"NOT BLANK -- FORCE Requested\"\n      END\n      ELSE RETURN 12\n   END\nEND\nIF SLEFT = \"RIGHT\" THEN DO\n   IF VALIDNX = \"VALIDNX\" THEN\n      Address \"ISREDIT\" \"EXCLUDE P'^'\" labf labl ALL col1r rbound\n   Address \"ISREDIT\" \" SEEK P'^'\"   labf labl X NX col1r rbound\n   IF RC = 0 THEN       DO\n      ZEDSMSG = 'Can''t SHIFT right'\n      ZEDLMSG = 'Cols' col1r rbound 'NOT BLANK -- SHIFT RIGHT',\n               'NOT PERFORMED, bounds('lbound rbound\")\"\n      Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n      IF FORCE = \"FORCE\" THEN DO\n         ZEDSMSG = 'Data FORCEd out'\n         ZEDLMSG = 'Cols' col1r rbound 'NOT BLANK -- Force Requested'\n         Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n      END\n      ELSE RETURN 12\n   END\nEND\nIF LNOlabl < LNOlabf then do\n    ZEDSMSG = 'LABEL for .LABF/L'\n    ZEDLMSG = 'LABF MUST APPEAR EARLIER THAN labl'\n    Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n    RETURN 12\nEND\n/**************************************************/\nI =  LNOlabF\nDO i = LNOlabf to LNOlabL\n   Address \"ISREDIT\" \"(VAR075) = XSTATUS\" I\n   IF  VAR075 =  NX |   VAR075 =  X  | X||NX  = '' THEN DO\n     IF SLEFT = \"LEFT\" THEN\n        Address \"ISREDIT\" \"SHIFT (\" I scnt\n     IF SLEFT = \"RIGHT\" THEN\n        Address \"ISREDIT\" \"SHIFT )\" I scnt\n   END\nEND\nZEDSMSG = 'COMPLETED'\nZEDLMSG = 'Finished edit macro ===>' sysvar(sysicmd),\n         LABF LABL X NX SLEFT SCNT\nAddress \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\nAddress \"ISREDIT\" ,\n\"LINE_BEFORE .ZCSR = NOTELINE \"\"\"TIME('N') ,\n   \" ===> \" SYSVAR(SYSICMD)\" --completed RC=\"RC  Date('U')\"\"\"\"\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOWDATE": {"ttr": 13832, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00~\\x00~\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 126, "newlines": 126, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX: SHOWDATE: SHOW DATES */\n/* AS SET UP EITHER CALLED BY @DATE -- OR SHOWDATE YYDDD WRITE */\n/*********************************************************************/\n/*  @SHOWDATE  1986/07/09 D.MCRITCHIE, THIS CODE HAS BEEN REWRITTEN  */\n/*    IN REXX FOR USE BY THE @DATE MACRO.                            */\n/*  DATES ARE ACCEPTED IN SEVERAL FORMS INCLUDING SAS OR DMS FORM    */\n/*    OF DDMMMYY.  WHEN INVOKED IN A NON NESTED FASHION WILL WRITE   */\n/*    LINES TO SCREEN.                                               */\n/*********************************************************************/\n\n/*********************************************************************/\n/*  DATE CONVERSION ROUTINE -- SYNTAX:                               */\n/*     %SHOWDATE YYDDD    -OR-      E.G.  86348                      */\n/*     %SHOWDATE YY/MM/DD           E.G.  1986/12/14                 */\n/*     %SHOWDATE DDMMMYY            E.G.  14DEC86      DMS AND SAS   */\n/*  SETS VARIABLES \"JDATE\" AND \"GDATE\" TO THE YYDDD AND YY/MM/DD     */\n/*  FORMS, RESPECTIVELY.                                             */\n/*********************************************************************/\n\n PDATE='';WRITE=''\n ARG PDATE WRITE\n PARSE VERSION V1 V2 V3 V4 V5  /* TO CHECK FOR TSO OR OS/2 */\n IF PDATE = \"\" | PDATE= \"*\" THEN  PDATE=DATE('O');\n RPTTIME=TIME()\n M.='';V.='';W.='';\n M.0=0; M.1=31; M.2=60; M.3=91; M.4=121; M.5=152; M.6=182; M.7=213;\n          M.8=244; M.9=274; M.10=305; M.11=335; M.12=99999999;\n V.1=\"JAN\"; V.2=\"FEB\"; V.3=\"MAR\"; V.4=\"APR\"; V.5=\"MAY\"; V.6=\"JUN\";\n          V.7=\"JUL\"; V.8=\"AUG\"; V.9=\"SEP\"; V.10=\"OCT\"; V.11=\"NOV\";\n          V.12=\"DEC\";\n W.1=\"SUN\"; W.2=\"MON\"; W.3=\"TUE\"; W.4=\"WED\"; W.5=\"THU\"; W.6=\"FRI\";\n          W.7=\"SAT\";\n\n\n   IF WRITE \\= \"NOWRITE\" THEN DO\n      PARSE VERSION V1 V2 V3 V4 V5\n      IF V1 /= \"REXX370\" THEN WRITE = \"WRITE\"  /* OS/2 NO SYSNEST*/\n      IF WRITE = \"\" THEN DO       /* WRITE(WRITE) WILL PRINT RESULTS*/\n         IF SYSVAR('SYSNEST') = \"NO\" THEN WRITE = \"WRITE\"\n         ELSE  WRITE = \"NOWRITE\"\n      END\n   END\n   IF PDATE = \"*\" THEN PDATE = DATE('O')\n   IF SUBSTR(PDATE,4,1) < \"0\" THEN DO\n      I = 1                /*  E.G.  14DEC86 CONVERTED TO 1986/12/14 */\n      DO WHILE I  <= 12\n         XXX = V.I\n         X3  = 100 +  I\n         IF SUBSTR(PDATE,3,3) = XXX THEN DO\n            PDATE = SUBSTR(PDATE,6,2)\"/\"SUBSTR(X3,2,2)\"/\"SUBSTR(PDATE,1,2)\n            SIGNAL REFORMED\n         END\n         I = I + 1\n      END\n   END\n REFORMED:\n   IF DATATYPE(PDATE) \\= \"NUM\" THEN SIGNAL TRY2\n   IF LENGTH(PDATE)  \\= 5      THEN SIGNAL TRY2\n   Y = SUBSTR(PDATE,1,2) + 0\n   D = SUBSTR(PDATE,3,3) + 0\n   Y1 = Y//4\n   IF Y1 \\= 0 THEN IF D > 59 THEN D = D + 1\n   IF  D > 366 THEN SIGNAL TRY2\n   I = 1\n   OLDM = 0\n   DO WHILE  I <= 12\n      NEWM = M.I\n      IF  D <=  NEWM THEN SIGNAL DCONS1\n      OLDM =  NEWM\n      I =  I + 1\n   END\n DCONS1:\n   X = V.I\n   DX0 = SUBSTR(PDATE,3,3)\n   DX1 = TRUNC((Y+3)/4) + 365 * Y + DX0 + 6\n   DX2 = TRUNC(DX1/7)\n   DX3 = (DX1 -  DX2) * 7 + 1\n   DX2 = (DX1)//7 + 1\n   WDATE =W.DX2\n   JDATE = PDATE\n   D = D -  OLDM\n   GDATE = RIGHT(Y,2,'0')'/'RIGHT(I,2,'0')'/'RIGHT(D,2,'0')\n   SDATE = RIGHT(D,2,'0')X||RIGHT(Y,2,'0')\n   SIGNAL GOODEXIT\n TRY2:\n   IF LENGTH(PDATE) \\= 8 THEN SIGNAL ERRORS\n   IF SUBSTR(PDATE,3,1) \\= \"/\" THEN SIGNAL ERRORS\n   IF SUBSTR(PDATE,6,1) \\= \"/\" THEN SIGNAL ERRORS\n   Y = LEFT(PDATE,2,'0')\n   I = SUBSTR(PDATE,4,2)\n   D = RIGHT(PDATE,2,'0')\n   IF DATATYPE(Y) \\= \"NUM\" THEN SIGNAL ERRORS\n   IF DATATYPE(I) \\= \"NUM\" THEN SIGNAL ERRORS\n   IF DATATYPE(D) \\= \"NUM\" THEN SIGNAL ERRORS\n   IF  D > 31 THEN SIGNAL ERRORS /* USED MM/DD/YY INSTEAD OF YY/MM/DD*/\n   IF  I > 12 THEN SIGNAL ERRORS\n   I = I - 1\n   I = M.I\n   D =  D +  I\n   IF  D > 366 THEN SIGNAL ERRORS\n   I =  TRUNC(Y / 4) * 4\n   IF  Y \\=  I  &   D > 59 THEN D =  D - 1\n   DX1 = TRUNC((Y+3)/4) + 365*Y  +  D + 6\n   DX2 = TRUNC(DX1 / 7)\n   DX3 =  DX1 -  DX2 * 7 + 1\n   WDATE = W.DX3\n   GDATE = PDATE\n   JDATE = RIGHT(Y,2,'0')RIGHT(D,3,'0')\n   I = SUBSTR(PDATE,4,2) + 0\n   SDATE = SUBSTR(PDATE,7,2)||V.I||RIGHT(Y,2,'0')\n GOODEXIT:\n   IF WRITE = \"WRITE\" THEN SAY JDATE GDATE SDATE   WDATE RPTTIME\n   IF V1 = \"REXX370\"        /* USING TSO,  OTHERWISE USING SPF/PC*/\n      THEN ADDRESS \"ISPEXEC\" \"VPUT (JDATE,GDATE,SDATE,WDATE)\"\n      ELSE DO;QUEUE JDATE; QUEUE GDATE; QUEUE SDATE; QUEUE WDATE;END;\n   EXIT 0\n\n ERRORS:\n   IF WRITE = \"WRITE\" THEN DO\n      SAY \"REQUESTED        SHOWDATE\" PDATE \" IS IN ERROR  RC=8\"\n      SAY \"IF REENTERED FOR CURRENT DATE AS ===> SHOWDATE *    \",\n          \"THE RESULTS WOULD BE...\"\n      ADDRESS \"TSO\" \"SHOWDATE * WRITE\"\n      SAY \"YOUR ORIGINAL REQUEST OF \"\"SHOWDATE\" PDATE\" WAS IN ERROR RC=8\"\n   END\n   EXIT 8\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SOPDUFIX": {"ttr": 13835, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\n\\x00\\n\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "MCRITCH"}, "text": "  ISREDIT MACRO\n        ISREDIT RCVYON\n        ISREDIT AUTOSAVE ON\n        ISREDIT (MEMBERX) = MEMBER\n        ISREDIT (DSNX)    = DATASET\n        ISREDIT @DIRSTAT\n        IF &DSNX ^= TECH.LIBR2.TEXT THEN EXIT CODE(0)\n        ISREDIT @SCRPTDU\n        ISREDIT @SCRPTD3\n        EXIT CODE(1)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SORTCR": {"ttr": 13837, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01\\x92\\x01\\x92\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 402, "newlines": 402, "modlines": 0, "user": "MCRITCH"}, "text": "/*rexx: */ Address \"ISREDIT\";\"MACRO (SORTF,SORTX,FLOW,COLL,SORT)\"\n/*  TITLE:      SORTCR --  Reformat and SORT names\n   Users:       SCRIPT users  or ISPF EDIT users\n   Entry:       Used as an EDIT CLIST within ISPF EDIT  ===> SORTCR\n   Contributed: 1985/11/25 David McRitchie\n           \"The REXX Macros Toolbox\",\n   Converted line by line from clist 1993/05/26 to REXX, some\n      function with label may have been lost.\n   Options:  FLOW option default is 70  e.g.  ===> SORTCR 70\n   Options:  length options  default 10 e.g.  ===> SORTCR 70 10\n   Requirements:\n    defined area must begin with at least one blank, each line\n        within area must begin the same number of blanks as the\n        first line of the area.\n    .SORTF    label required at beginning of a contiguous  word list\n        section\n\n    .SORTX    label immediately after end of the contiguous word\n        list section.  If label not supplied it will be created\n        based on a later line with data at an earlier starting column\n\n   The reason that .SORTX must be below the last line is to be able\n   to identify when there is only one line to be processed -- a\n   possible alternative might have been to pass names of the line\n   labels when invoking this edit macro, but I think the method used\n   is better than the alternative.  The CC-range would have worked\n   but cannot be redone.\n  *******************************************************************/\n   /*trace intermediate*/\n   \"LINE_BEFORE .ZF  = NOTELINE \"\"\"TIME('N') ,\n      \" ===> SORTCR\" sortf sortx flow coll sort\"\"\"\"\n   D = substr(SORTF,1,1)||substr(SORTX,1,1)\n   IF D \\= '..' then do\n      sort = flow;coll=sortx;flow=sortf;\n      SORTX = '.SORTX'\n      SORTF = '.SORTF'\n   END\n   else do\n      \"label\" sortf \"= .sortf 0\"\n      \"label\" sortx \"= .sortx 0\"\n      sortf = '.sortf'\n      sortx = '.sortx'\n   end\n   \"(SORTFNO) = LINENUM\" SORTF\n   IF rc > 0 THEN DO\n      zedsmsg =  SORTF \"MISSING\"\n      zedlmsg = \"A\" SORTF \"label (at the first '.du add ' line)\" ,\n                \"is not in the file\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      \"LABEL .ZFIRST = .SORTF\"    /* modified on pc-side*/\n      \"find P'^' 1\"\n      exit 12     /* could comment this out if testing */\n   END\n   \"(SORTXNO) = LINENUM\" SORTX\n   IF rc > 0 THEN DO\n      zedsmsg = SORTX \"missing\"\n      zedlmsg = \"A  .SORTX  label (at the line after the last\" ,\n                \"'.du add ' line) is not in the file\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n     /* EXIT 12*/\n     \"find first .sortf .sortf p' ^'\"  /* modified on pc-side */\n     \"(rowz,colz) = cursor\"\n     \"find next 1\" colz \"p'^'\"\n     if rc = 0 then \"label .zcsr = .sortx 0\"\n     else exit 12\n   END\n   IF FLOW  = '' THEN FLOW = 70\n   ELSE IF datatype(FLOW) \\= \"NUM\" then do\n      zedsmsg = \"Bad Parameter\"\n      zedlmsg = FLOW \"is an unknown parameter.  Use a column number.\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      exit 12\n   END\n   IF COLL \\= '' then\n   IF datatype(COLL) \\= NUM THEN DO\n      zedsmsg = \"Bad Parameter\"\n      zedlmsg = COLL \"2ND PARAMETER IS INVALID LENGTH\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      exit 12\n   END\n   \"(LBOUND,RBOUND) = BOUNDS\"\n   \"(DWIDTH) = DATA_WIDTH\"\n   IF FLOW = '' then nop\n   ELSE IF FLOW < 8  THEN DO\n      zedsmsg = \"Parameter too small\"\n      zedlmsg = \"The parameter must be at least 10.\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      exit 12\n   END\n   IF FLOW = '' then nop\n   ELSE IF flow  >  RBOUND  THEN DO\n      zedsmsg = \"Parameter too large\"\n      zedlmsg = \"The parameter must be smaller than or equal to\" ,\n                 RBOUND\", the right-bound.\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      exit 12\n   END\n   \"(SORTXNO) = LINENUM\" SORTX\n   SORTLNO = SORTXNO - 1\n   SORTXNO = SORTXNO + 0\n   IF value(SORTFNO) = value(SORTLNO) THEN DO\n      \"LINE_AFTER\" SORTF \"= DATALINE LINE\" SORTF   /* TO EFFECT A..*/\n      \"LINE_AFTER\" SORTF \"= DATALINE LINE\" SORTF   /* TO EFFECT A..*/\n      \"LINE_AFTER\" SORTF \"= DATALINE LINE\" SORTF   /* TO EFFECT A..*/\n      \"(SORTXNO) = LINENUM\" SORTX\n   END\n   \"LABEL\" value(SORTXNO - 1 ) \"= .SORTL 0\"\n   IF  RBOUND <  DWIDTH THEN DO\n      \"SEEK  .SORTF .SORTL  P'^'\" value(RBOUND+1) DWIDTH\n      IF rc = 0 THEN DO\n         zedsmsg = \"Data Outside Bounds\"\n         zedlmsg = \"Non-blank characters exist outside\" ,\n                    \"of the edit bounds\"\n         Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n         exit 12\n         /* Will not attempt to process, if there is data beyond the\n            right bound */\n      END\n   END\n   /* ************ ADDED D.MCR 1985/08/03 TO END ******/\n   IF value(SORTXNO) < value(SORTFNO) THEN DO\n      zedsmsg = \"LABEL ERR \"SORTF\"/X\"\n      zedlmsg = SORTF \"must appear earlier than\" SORTX\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      exit 12\n   END\n   \"SEEK\" .SORTF .SORTL \" 1 ';.' ALL\"\n   \"(SEEK1,SEEK2) = SEEK_COUNTS\"\n   IF value(SEEK2) \\= value(0) THEN DO\n      zedsmsg = \"One Command per line\"\n      zedlmsg = \"CAN ONLY HANDLE '.du add       ' COMMANDS AND \",\n                \"THEY MUST BEGIN IN COL 1\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      exit 12\n   END\n\n   \"SEEK  .SORTF  .SORTL P'^' FIRST\"\n   \"(SEEK1,SEEK2) = SEEK_COUNTS\"\n   IF value(SEEK2) = 0 then do\n      zedsmsg = \"No Data Found\"\n      zedlmsg =  \".SORTF .SORTL area appears to be blank\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      exit 12\n   END\n   \"(CUR1,COLB) = CURSOR\"\n   COLBM1      = value(COLB - 1)\n   \"SEEK .SORTF  .SORTL P'^' 1\" COLBM1\n   \"(SEEK1,SEEK2) = SEEK_COUNTS\"\n   IF value(SEEK2) \\= value(0) THEN DO\n      zedsmsg = \"NON-BLANK\" COLBM1\n      zedlmsg = SORTF .SORTL \"NOT CLEAR IN COLUMNS 1\" colbm1\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      exit 12\n   END\n   /********** ALL VERIFICATION HAS BEEN COMPLETED ABOVE\n               -- NOW SETTING UP TO CHANGE DATA*/\n   \"(SORTFNO) = LINENUM\" SORTF\n   \"LINE_AFTER .SORTL = DATALINE LINE\" .SORTL\n   \"(SORTXNO) = LINENUM\" SORTX\n   \"LABEL\" value(SORTXNO  - 1)\" = .sortv 0\"\n   \"LABEL\" SORTFNO \" = .SORTF  0\"\n      /*PROVIDED IN CASE SORTX was entered one line after SORTF */\n   \"(sortvNO) = LINENUM .sortv\"\n      /*RECALCULATED BECAUSE IT HAS MOVED ONE LINE DOWN*/\n   /********** START SPLITTING UP LINES FROM THE FIRST WORD*/\n   \" CURSOR =\" SORTFNO \"0\"\n   \" (sortvNO) = LINENUM .sortv\"\n\n\n   \"TFLOW .SORTF\" value(colb + 1)  /* first nonblank on .sortf + 1*/\n   /* now have a single column to be sorted, reworked */\n\n   \"(SORTXNO) = LINENUM \"SORTX\n   \"LABEL\" value(SORTXNO - 1) \"= .sortv 0\"\n   \"LABEL\" value(SORTXNO - 2) \"= .SORTL 0\"\n   \"DELETE .sortv .sortv\"\n   \"LINE_BEFORE\" SORTX \" = dataline '.* sortv -- STOPS FLOW'\"\n   \"LABEL\" value(SORTXNO - 2) \"= .SORTL 0\"\n   \"LABEL\" value(SORTXNO - 1) \"= .sortv 0\"\n      /* could make a do group to sort upper/lowercase same*/\n      /* could make line = substr(line,1,50)translate(line,1,20)) */\n      /* and then   SORT .sortf .sortv 51 70 1 50 */\n\n   /* letters precede numbers in EBCDIC on MVS -- ASCII is opposite*/\n   if x2c('41') = \"A\" then do;  /* Make ascii look like EBCDIC */\n    /* attempt to make sort look more ebcdic like */\n    \"change all x'30' x'f0' .sortf .sortv\"\n    \"change all x'31' x'f1' .sortf .sortv\"\n    \"change all x'32' x'f2' .sortf .sortv\"\n    \"change all x'33' x'f3' .sortf .sortv\"\n    \"change all x'34' x'f4' .sortf .sortv\"\n    \"change all x'35' x'f5' .sortf .sortv\"\n    \"change all x'36' x'f6' .sortf .sortv\"\n    \"change all x'37' x'f7' .sortf .sortv\"\n    \"change all x'38' x'f8' .sortf .sortv\"\n    \"change all x'39' x'f9' .sortf .sortv\"\n   end\n   \"SORT\" SORTF \".sortv\" sort\n   if x2c('41') = \"A\" then do;  /* Put Numbers back to ASCII */\n    /* restore normal ascii chars */\n    \"change all x'f0' x'30' .sortf .sortv\"\n    \"change all x'f1' x'31' .sortf .sortv\"\n    \"change all x'f2' x'32' .sortf .sortv\"\n    \"change all x'f3' x'33' .sortf .sortv\"\n    \"change all x'f4' x'34' .sortf .sortv\"\n    \"change all x'f5' x'35' .sortf .sortv\"\n    \"change all x'f6' x'36' .sortf .sortv\"\n    \"change all x'f7' x'37' .sortf .sortv\"\n    \"change all x'f8' x'38' .sortf .sortv\"\n    \"change all x'f9' x'39' .sortf .sortv\"\n   end\n\n   /* *********** remove any duplicates *****************/\n   /* *********** MAY RESULT IN LOSS OF .SORTL AND OTHER LINES*/\n   \"LOC\" SORTF\n   /* *********** remove any duplicates *****************/\n   /* sortf to .sortv  (sortv itself never a duplicate) */\n   \"(sortfn) = linenum .sortf\"\n   \"(sortvn) = linenum .sortx\"\n   prevline = \" \"\n   l=0\n   sortvv = sortvn - 2\n   do i = sortvv to sortfn by -1\n      /* could make line = substr(line,1,50)translate(line,1,20)) */\n      /* and sort 51 70 1 50 */\n      \"(line) = line\" i\n      line=strip(line,'T')\n      if line = prevline then \"delete\" i+1\n      else prevline = line\n      ll=length(line)\n      if ll > l then l = ll\n   end\n   /* use requested length (coll) if > required length (collx) */\n   if coll \\= \"\" then do\n      collx = l - colbm1\n      if coll < collx then do\n         zedsmsg = coll \"too small\"\n         zedlmsg = zedsmsg\", using entity width of\" collx\n         Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      end\n      if coll > collx  then l = coll + colbm1\n   end\n   else coll = l - colbm1\n\n   \"change all .sortf .sortv  ' ' '|'\" colb l\n   /*\"delete .sortv .sortv all\" */\n   /* ***************************************************/\n   /* BELOW COULD BE ADDED TO SORTCR                   **/\n   /*    MAKE ALL ROWnoS THE SAME                      **/\n   \"(SORTFNO) = LINENUM\" SORTF\n   \"(SORTXNO) = LINENUM\" SORTX\n   SORTLNO = SORTXNO - 2\n   \"LABEL\" SORTLNO \"= .SORTL 0\"  /* FIXUP */\n   IDIFF = SORTLNO + 1 - SORTFNO\n   \"LOC\" SORTF\n   \"FIND P'^' .SORTF .SORTF FIRST\"\n   \"(,CCC) = CURSOR\"\n   if coll \\= '' then do\n      protect = ccc + coll - 1;\n      \"CHANGE ALL .SORTF .SORTL\" ccc protect \"' ' '|'\"\n      /* guarantee minimum size, could still be larger*/\n   end\n   hightst = colb + 1\n   cole = colb\n   do forever;\n      if hightst > rbound then leave\n      \"SEEK\" \".SORTF .SORTL first p'^'\"  hightst rbound\n      if rc \\=0 then leave\n      \"(rowx,colx) = cursor\"\n      cole = colx\n      hightst = colx + 1\n   END\n   /*\"change all .sortf .sortv\" colb cole \"' ' '|'\"*/\n     \"change all .sortf .sortv\" colb cole \"'|' ' '\"\n   \"DELETE .sortv .sortv\"\n   cole = cole + 1    /* include blank after last character found*/\n   if coll = '' then do\n       coll = cole - colb  /*coll does not include sep. space*/\n   end\n   else do\n       if   value(cole - colb) \\=  value(coll)\n         then say value(cole - colb )   value(coll)\n       if value(cole - colb) >  value(coll) then do\n          collx = coll                /* as specified*/\n          coll = cole - colb          /* as s/b specified*/\n          \"line_before .ZF = Noteline \"\"SORTCR forced column\",\n             \"length of\" collx\", has been changed to the default\"\"\"\n          \"line_before .ZF = Noteline\",\n             \"\"\"       i.e. -- SORTCR\" flow coll\"\"\"\"\n       end\n   end\n   /* ************ calculate number of columns **********************/\n   collp1 = collp1\n   \"(T2) = LINENUM\" SORTF\n   \"(T3) = LINENUM\" SORTX\n\n   T4 = COLL + 1             /* longest column length + 1 space*/\n   T5 = flow - colb + 2      /* does need extra space at end*/\n   COLno = trunc(T5 / T4)    /* NUMBER OF COLUMNS PER LINE */\n\n   T10 = T3  - T2            /* NUMBER OF LINES INVOLVED */\n   T11 = T10 + COLno - 1\n   ROWno = trunc(T11 / COLno)    /* NUMBER OF ROWnoS REQUIRED */\n   T6  = trunc((t10 + ROWno - 1) / ROWno)  /* columns seen*/\n   /* -- Place single column into parallel columns.  The number of\n         Rows and Columns has bee previously calculated as has the\n         length of the columns.  All of the previous could be changed\n         to -->  SORTCR 70 1           *****************************/\n   \"(LNB) = LINENUM\" SORTF\n   \"(LNX) = LINENUM \"SORTX\n   \"LABEL\" value(LNX - 1) \"= .SORTL\"\n   \"CHANGE .SORTF .SORTL ALL\" COLB COLE \"' ' '\u00f8'\"\n   BLANK = substr(' ',1,70)\n   ROWno = ROWno + 0\n   COLno = COLno + 0\n   C = 0\n   LNA = LNB\n   LNS = LNX - LNB\n   LNST = 0           /* TEST NUMBER OF LINES SHOULD = LNS AT END */\n   R = 0\n   DO WHILE (R < ROWno)\n      R = R + 1\n      LNA = LNB + R - 1\n      \"(RLINE)   =  LINE\" LNA\n      RLINE = substr(rline,1,cole)\n      C = 1\n      LNST =  LNST + 1\n      DO WHILE ( C <  COLno)\n         C =  C + 1\n         LNA =  LNA + ROWno\n         IF  LNA <  LNX THEN DO\n            \"(NLINE) = LINE\" LNA\n            RLINE = RLINE||substr(nline,colb,value(cole+1-colb))\n            LNST = LNST + 1\n         END\n         ELSE RLINE = rline||substr(blank,colb,value(cole+1-colb))\n      END\n   RPL      = LNB + R - 1\n   IF value(FLOW) <= DWIDTH THEN \"LINE\" RPL \"=(rline)\"\n   ELSE \"LINE\" RPL \"=\" substr(rline,1,dwidth)\n   END\n   \"LABEL\"  value(LNX - 1) \"= .SORTL 0\"\n   /*   signal GYP*/\n   \"CHANGE .SORTF .SORTL 1\" value(DWIDTH) \"ALL '\u00f8' ' '\"\n   IF  LNST \\=  LNS THEN DO\n   GYP:\n      \"LINE_AFTER\" SORTX \"= NOTELINE \"\"UNMATCHED LINES IN=\"LNS\",\",\n              \" ENTRIES OUT=\"LNST\n      \"LINE_AFTER\" SORTX \"= \",\n      \"NOTELINE \"\"COLL=\"COLL \"FLOW=\"FLOW,\n          \" COLno=\"COLno \"(\"T5\"+\"T4\"-1)/\"T4 \"\"\"\"\n      \"LINE_AFTER\" SORTX \"= \",\n      \"NOTELINE \"ROWno=\"ROWno (\"T3\" - \"T2\" + \"colno\" - 1) / \"colno\"\"\"\"\n      zedsmsg = \"MISSING data \"\n      zedlmsg = \"SHOULD HAVE\" LNS \"ENTRIES, NOW HAVE\" LNST \"ENTRIES\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      exit 12\n   END\n   colb=colb+0;\n   IF T6 \\= COLno then do\n     t21 = trunc((flow - colb -t6) / t6)\n     t22 = ROWno * COLno\n     if t22 \\= T10  then\n       \"LINE_AFTER \"SORTX \"= \",\n        \"NOTELINE \"\"  Entries could be increased to\" t22,\n         \"and still fit within flow limit\"\"\"\n     if t21 \\= COLL then\n       \"LINE_AFTER \"SORTX \"= \",\n        \"NOTELINE \"\"  Length could be extended to\" t21,\n         \"and still fit within flow limit.\"\"\"\n     \"LINE_AFTER \"SORTX \"= \",\n         \"NOTELINE \"\"  with\" T10 \"entries into\" ROWno \"rows,\",\n         T6 \"cols out of the\" COLno \"will be used\"\"\"\n   end\n   \"LINE_AFTER \"SORTX \"= \",\n   \"NOTELINE \"\"SORTCR processed\" LNS \"entries into\",\n          COLno \"Columns X\" ROWno,\n         \"rows, F=\"flow \"L=\"coll \"b=\"colb \"e=\"cole\"\"\"\"\n   \"LINE_BEFORE .zf    = \",\n   \"NOTELINE \"\"SORTCR processed\" LNS \"entries into\",\n          COLno \"Columns X\" ROWno,\n         \"rows, F=\"flow \"L=\"coll \"b=\"colb \"e=\"cole\"\"\"\"\n   DLN1 = LNB + ROWno\n   DLN2 = LNX - 1\n   IF DLN1 <= DLN2 THEN ,\n   \"DELETE\" DLN1  DLN2 \"ALL\"\n   \"LABEL\" value(LNB) \"= .SORTF 0\"\n   \"RESET CHG    .SORTF .SORTF\"\n   \"LABEL\" value(LNB + ROWno) \"=\" SORTX \"0\"\n   \"LOC\" SORTF\n   \"UP 1\"\n   if value(COLno * (COLL + 1) + COLB - 2) > FLOW ,\n    | value(COLno * (COLL + 1) + COLB - 2 + COLL) < FLOW then\n      \"LINE_AFTER .SORTX = MSGLINE \"\"*** Check SORTCR usage\",\n      value(COLno * (COLL + 1) + COLB - 2)   FLOW ,\n      value(COLno * (COLL + 1) + COLB - 2 + COLL) \"where l=\"coll \"t5=\"t5\"\"\"\"\n   /**********************END OF PROGRAM ***********************/\n   zedsmsg = \"SORTCR finished OK\"\n   zedlmsg = \"SORTCR MACRO FINISHED OKAY --\",\n              \"CHANGED LINES INCLUDE\" SORTF \"-\"SORTX\n   Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SORTEM": {"ttr": 14086, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xef\\x00\\xef\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 239, "newlines": 239, "modlines": 0, "user": "MCRITCH"}, "text": "/*rexx*/ Address \"ISREDIT\";\n \"MACRO (SORTF,SORTX,FLOW,COLL,SORT)\"\n/* TITLE:       Reformat and SORT names\n   Users:       SCRIPT users  or ISPF EDIT users\n   Entry:       Used as an EDIT macro within ISPF EDIT  ===> SORTEM\n   Contributed: 1985/10/30 David McRitchie\n           \"The REXX Macros Toolbox\",\n   Converted to REXX based on a previously converted SORTCR macro, some\n      function with label may have been lost.   D.McRitchie\n   Options:  FLOW option default is 70  e.g.  ===> SORTEM 70\n   Options:  length options  default 10 e.g.  ===> SORTEM 70 10\n   Requirements:\n    defined area must begin with at least one blank, each line\n        within area must begin the same number of blanks as the\n        first line of the area.\n    .SORTF    label required at beginning of a contiguous  word list\n        section\n\n    .SORTX    label immediately after end of the contiguous word\n        list section.  If label not supplied it will be created\n        based on a later line with data at an earlier starting column\n\n   The reason that .SORTX must be below the last line is to be able\n   to identify when there is only one line to be processed -- a\n   possible alternative might have been to pass names of the line\n   labels when invoking this edit macro, but I think the method used\n   is better than the alternative.  The CC-range would have worked\n   but cannot be redone.\n\n   Internally:\n    .SORTV    Temporary label used, will be created/removed\n  *******************************************************************/\n   \"line_before .zf  = noteline \"\"\"time('n') ,\n      \" ===> SORTEM\" sortf sortx flow coll sort\"\"\"\"\n   D = substr(SORTF,1,1)||substr(SORTX,1,1)\n   IF D \\= '..' then do\n      sort = flow;coll=sortx;flow=sortf;\n      sortf = '.sortf'\n      sortx = '.sortx'\n   END\n   else do\n      \"label\" sortf \"= .sortf 0\"\n      \"label\" sortx \"= .sortx 0\"\n      sortf = '.sortf'\n      sortx = '.sortx'\n   end\n   sortf = translate(sortf)\n   \"(sortfno) = linenum\" sortf\n   if rc > 0 then do\n      zedsmsg =  SORTF \"MISSING\"\n      zedlmsg = \"A\" SORTF \"label to designate first involved line\",\n                \"is(/was) not in the file\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      \"LABEL .ZFIRST = .SORTF\"    /* modified on pc-side*/\n      \"find P'^' 1\"\n      exit 12     /* could comment this out if testing */\n   END\n   \"(SORTXNO) = LINENUM\" SORTX\n   IF rc > 0 THEN DO\n      zedsmsg = SORTX \"missing\"\n      zedlmsg = \"A  .SORTX  label (at the line after the last\" ,\n                \"'.du add ' line) is not in the file\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n     /* EXIT 12*/\n     \"find first .sortf .sortf p' ^'\"  /* modified on pc-side */\n     \"(rowz,colz) = cursor\"\n     \"find next 1\" colz \"p'^'\"\n     if rc = 0 then \"label .zcsr = .sortx 0\"\n     else exit 12\n   END\n   IF FLOW  = '' THEN FLOW = 70\n   ELSE IF datatype(FLOW) \\= \"NUM\" then do\n      zedsmsg = \"Bad Parameter\"\n      zedlmsg = FLOW \"is an unknown parameter.  Use a column number.\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      exit 12\n   END\n   IF COLL \\= '' then\n   IF datatype(COLL) \\= 'NUM' THEN DO\n      zedsmsg = \"Bad Parameter\"\n      zedlmsg = COLL \"2ND PARAMETER IS INVALID LENGTH\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      exit 12\n   END\n   \"(LBOUND,RBOUND) = BOUNDS\"\n   \"(DWIDTH) = DATA_WIDTH\"\n   IF FLOW = '' then nop\n   ELSE IF FLOW < 8  THEN DO\n      zedsmsg = \"Parameter too small\"\n      zedlmsg = \"The parameter must be at least 10.\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      exit 12\n   END\n   IF FLOW = '' then nop\n   ELSE IF flow  >  RBOUND  THEN DO\n      zedsmsg = \"Parameter too large\"\n      zedlmsg = \"The parameter must be smaller than or equal to\" ,\n                 RBOUND\", the right-bound.\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      exit 12\n   END\n   IF  RBOUND <  DWIDTH THEN DO\n      \"SEEK  .SORTF .SORTL  P'^'\" value(RBOUND+1) DWIDTH\n      IF rc = 0 THEN DO\n         zedsmsg = \"Data Outside Bounds\"\n         zedlmsg = \"Non-blank characters exist outside\" ,\n                    \"of the edit bounds\"\n         Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n         exit 12\n         /* Will not attempt to PROCESS, if there is data beyond the\n            right bound */\n      END\n   END\n   \"(SORTXNO) = LINENUM\" SORTX\n   SORTLNO = SORTXNO - 1\n   SORTXNO = SORTXNO + 0\n   IF value(SORTFNO) = value(SORTLNO) THEN DO\n      \"LINE_AFTER\" SORTF \"= DATALINE LINE\" SORTF   /* TO EFFECT A..*/\n      \"(SORTXNO) = LINENUM\" SORTX\n   END\n   \"LABEL\" value(SORTXNO - 1 ) \"= .SORTL 0\"\n   /* ************ ADDED D.MCR 1985/08/03 TO END ******/\n   IF value(SORTXNO) < value(SORTFNO) THEN DO\n      zedsmsg = \"LABEL ERR \"SORTF\"/X\"\n      zedlmsg = SORTF \"must appear earlier than\" SORTX\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      exit 12\n   END\n   \"SEEK\" .SORTF .SORTL \" 1 ';.' ALL\"\n   \"(SEEK1,SEEK2) = SEEK_COUNTS\"\n   IF value(SEEK2) \\= value(0) THEN DO\n      zedsmsg = \"One Command per line\"\n      zedlmsg = \"CAN ONLY HANDLE '.du add       ' COMMANDS AND \",\n                \"THEY MUST BEGIN IN COL 1\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      exit 12\n   END\n\n   \"SEEK  .SORTF  .SORTL P'^' FIRST\"\n   \"(SEEK1,SEEK2) = SEEK_COUNTS\"\n   IF value(SEEK2) = 0 then do\n      zedsmsg = \"No Data Found\"\n      zedlmsg =  \".SORTF .SORTL area appears to be blank\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      exit 12\n   END\n   \"(CUR1,COLB) = CURSOR\"\n   COLBM1      = value(COLB - 1)\n   \"SEEK .SORTF  .SORTL P'^' 1\" COLBM1\n   \"(SEEK1,SEEK2) = SEEK_COUNTS\"\n   IF value(SEEK2) \\= value(0) THEN DO\n      if colbm1 = 0 then colbm1 = 1 /* make message look okay*/\n      zedsmsg = \"NON-BLANK\" COLBM1\n      zedlmsg = sortf \"thru .SORTL NOT CLEAR IN COLUMNS 1-\"colbm1\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      exit 12\n   END\n   \"SEEK .SORTF  .SORTL  ' '\" COLB\n   if rc = 0 then do\n      zedsmsg = \"uneven\" colb\n      zedlmsg = SORTF .SORTL \"All Data in range must\",\n         \"begin at column\" colb\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      exit 12\n   END\n   /********** ALL VERIFICATION HAS BEEN COMPLETED ABOVE\n               -- NOW SETTING UP TO CHANGE DATA*/\n   \"(sortvn) = linenum .sortx\"\n   \"line_before .sortx = dataline \"\".*v\"\"\"\n   \"label\" sortvn \" = .sortv 0\"\n   \"find first p'^' .sortf .sortf\"\n   \"(row,col) = cursor\"\n   col = col + 1\n   \"TFLOW .sortf\" col\n   /* letters precede numbers in EBCDIC on MVS -- ASCII is opposite*/\n   if x2c('41') = \"A\" then do; /* ascii like EBCDIC*/\n    /* attempt to make sort look more ebcdic like */\n    \"change all x'30' x'f0' .sortf .sortv\"\n    \"change all x'31' x'f1' .sortf .sortv\"\n    \"change all x'32' x'f2' .sortf .sortv\"\n    \"change all x'33' x'f3' .sortf .sortv\"\n    \"change all x'34' x'f4' .sortf .sortv\"\n    \"change all x'35' x'f5' .sortf .sortv\"\n    \"change all x'36' x'f6' .sortf .sortv\"\n    \"change all x'37' x'f7' .sortf .sortv\"\n    \"change all x'38' x'f8' .sortf .sortv\"\n    \"change all x'39' x'f9' .sortf .sortv\"\n   end\n   \"SORT .sortf .sortv\" /*sort */\n   if x2c('41') = \"A\" then do; /* ascii like EBCDIC*/\n    /* restore normal ascii chars */\n    \"change all x'f0' x'30' .sortf .sortv\"\n    \"change all x'f1' x'31' .sortf .sortv\"\n    \"change all x'f2' x'32' .sortf .sortv\"\n    \"change all x'f3' x'33' .sortf .sortv\"\n    \"change all x'f4' x'34' .sortf .sortv\"\n    \"change all x'f5' x'35' .sortf .sortv\"\n    \"change all x'f6' x'36' .sortf .sortv\"\n    \"change all x'f7' x'37' .sortf .sortv\"\n    \"change all x'f8' x'38' .sortf .sortv\"\n    \"change all x'f9' x'39' .sortf .sortv\"\n   end\n\n   /* *********** remove any duplicates *****************/\n   /* sortf to .sortv  (sortv itself never a duplicate) */\n   \"(sortfn) = linenum .sortf\"\n   \"(sortvn) = linenum .sortv\"\n   prevline = \" \"\n   l=0\n   sortvv = sortvn - 2\n   do i = sortvv to sortfn by -1\n      /* could make line = substr(line,1,50)translate(line,1,20)) */\n      /* and sort 51 70 1 50 */\n      \"(line) = line\" i\n      line=strip(line,'T')\n      if line = prevline then \"delete\" i+1\n      else prevline = line\n      ll=length(line)\n      if ll > l then l = ll\n   end\n   /* use requested length (coll) if > required length (collx) */\n   if coll \\= \"\" then do\n      collx = l - colbm1\n      if coll < collx then do\n         zedsmsg = coll \"too small\"\n         zedlmsg = zedsmsg\", using entity width of\" collx\n         Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      end\n      if coll > collx  then l = coll + colbm1\n   end\n\n   \"change all .sortf .sortv  ' ' '|'\" colb l\n   \"TFLOW .SORTF\" flow  /* flow is optional*/\n   \"change all .sortf .sortv '|' ' '\"\n   \"reset change .sortf .sortv\"\n   \"delete .sortv\"\n   \"(linenum) = linenum .sortl\"\n   if rc = 0 then \"reset label .sortl .sortl\"  /*eliminate label*/\n   return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SORTG": {"ttr": 14091, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xfc\\x00\\xfc\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 252, "newlines": 252, "modlines": 0, "user": "MCRITCH"}, "text": "/*REXX: Title:   Sort grouping of  NX and X lines between labels   */\n/*  Users:       TSO ispf EDIT users   | Script users              */\n/*  Contributed: 1990/02/05 David McRitchie \"The REXX Macros Toolbox\" */\n/*    \"The REXX Macros Toolbox\"                                    */\n/*    Converted to REXX 1994/04/21 D.McRitchie                     */\n/*                                                                 */\n/*  Example:     SORTG    .a .b 7 9 4 5                            */\n/*                                                                 */\n/*  Options:                                                       */\n/*      lptr-range | entire   (required) line pointer range        */\n/*      column pairs for sorting                                   */\n/*         limited to ability to sort ascending only               */\n/*      LEAVE    -- leave in sorting criteria                      */\n/*   ----------- features added later -----------------------------*/\n/*      NOSORT   -- place column pair to last columns,             */\n/*                  leave option turn on, will not be sorted       */\n/*                  will not include sequence number               */\n/*  Requirements:                                                  */\n/*      display and non-displayed lines within label range         */\n/*  Additional clists or executes required:                        */\n/*      reformat                                                   */\n/*  Documented in  -- IS03.SHARE.TEXT(SORTG)                       */\n  Address \"ISREDIT\";\"MACRO (TOKENS)\"\n  addendum=\"*-*-*-*-*\"\n  debug=\"\"\n  fr = 0\n  help=\"\"\n  labi=0;pairsi=0;labels=\"\";pairs=\"\";remain=\"\"\n  leave=''\n  lower = 0\n  needcols=0\n  nosort=\"\"\n  xsubstr=\"\"\n  \"(autosave) = autosave\"\n  \"(row,col) = cursor\"\n  tokenso = tokens\n  tokens = translate(tokens)\n  \"(dwidth) = data_width\"\n  \"(MEMBER) = member\"\n  if tokens = \"DEBUG\" then tokens=\"DEBUG .a .b 1 5 11 15\"\n  call Dnote time('n') 'SORTG' tokens\n  do i = 1 to words(tokens)\n     token = word(tokens,i)\n     /****************** debug begin *********/\n     if token = \"?\" then do\n        Call Dnote \"<<<<<<<< Help was requested with ? >>>>>>>>>>>>>\"\n        address \"TSO\" \"CLIST SORTG HELP\"\n\n        return 4\n     end\n     if token = \"DEBUG\" then do\n        call Dnote \"DEBUG --- processing has begun\"\n        \"reset labels\"\n        \"c all 100 251 p'^' ' '\"\n        dwidth = 123\n        \"f first p' ######## ' 49\"\n        if rc \\= 0 then return 4\n        \"sort .zcsr .zl 49 60\"\n        \"f first p' ######## ' 49\"\n        \"label .zcsr = .a 0\"\n        \"f first .a .zl 49 ' 00000016'\"\n        if rc \\= 0 then return 4\n        \"label .zcsr = .b 0\"\n        \"x all 41 p'^' .a .b\"\n        iterate i\n        debug=\"DEBUG\"\n        call Dnote \"DEBUG --- processing has ended\"\n     end\n     /******************** debug end ************/\n     if substr(token,1,1) = '.'    then do\n        labi=labi+1\n        labels = labels token\n        iterate i\n     end\n     if datatype(token,\"n\") then do\n        if lower = 0 then do\n           lower = 1\n           bseg = token\n           iterate i\n        end\n        else do\n           lower = 0\n           lseg = token + 1 - bseg\n           if (token+0) < (bseg+0) then do\n              call Dnote 'Column PAIR order invalid for ' beseg token\n              return 4\n           end\n           xsubstr=xsubstr\"||substr(line,\"bseg\",\"lseg\")\"\n           needcols = needcols + lseg\n           pairs = pairs bseg token\n           iterate i\n         end\n      end\n      if token = \"HELP\" | token = \"DEBUG\" ,\n         | token = \"LEAVE\" ,\n         | token = \"NOSORT\" ,\n         then do\n           xxx = TOKEN \"= \"\"\"TOKEN\"\"\"\"\n           interpret xxx  /* execute the instruction */\n           iterate i\n         end\n      remain = remain token\n   end\n  /* end of tokens inputted */\n  if remain \\= \"\" then do\n     call Dnote remain \" -- Not provided for in SORTG\"\n     return 4\n  end\n  if substr(xsubstr,1,2)\\='||' then do\n     call Dnote \"No column pairs supplied\"\n     return 4\n  end\n  /* sort upper/lowercase as if uppercase  1994/04/25 */\n  xsubstr = 'addendum ='translate(substr(xsubstr,3))\n  line=' '; interpret xsubstr\n  if labels = '' then labels = \".ZFIRST .ZLAST\"\n  labels = translate(labels)\n  if words(labels) \\= 2 then do\n     call Dnote 'Label-range must be a single pair, found -->' labels\n     return 4\n  end\n\n  /************** end of label requirements *******************/\n  \"(lbound,rbound) = bounds\"\n  \"(var019,var020) = display_cols\"\n  /****************************/\n  \"(var057) = recfm\"\n  \"(var049,var050) = number\"\n  llbound = lbound\n  lladj = 0\n  if var057 = \"V\" and var049 = \"ON\" then do\n     lladj = 8\n     llbound = lbound + 8\n  end\n  /****************************/\n  if pairs = \"\"    then do\n      call Dnote 'No column pairs specified'\n      return 4\n  end\n  if lower = 1 then do\n      call Dnote \"Both start and end cols\",\n         \"must be present -- missing an end portion missing\"\n      return 4\n  end\n  seekcol = dwidth - needcols - 6 + 1 - 1\n  if nosort = \"NOSORT\" then seekcol = dwidth - needcols + 1 -1\n  if nosort = \"LEAVE\"  then seekcol = dwidth - needcols + 1 -1\n  \"seek first\" labels seekcol dwidth \"p'^'\"\n  if rc = 0 then do\n     call Dnote 'Columns' seekcol'-'dwidth 'must be blank for sort data'\n     return 4\n  end\n  \"seek first\" labels \"x p'='\"\n  if rc \\= 0 then do\n     call Dnote 'Undisplayed (X) lines missing'\n     return 4\n  end\n  \"(labf) = linenum\" word(labels,1)\n  \"(labl) = linenum\" word(labels,2)\n  do i = labf to labl\n     \"(line) = line\" i\n     \"(xstatus) = xstatus\" i\n     if xstatus = \"NX\" then do;interpret xsubstr;x=\"-\";end;\n     else x=\" \"\n     if leave = \"LEAVE\"\n       then line = substr(line,1,seekcol-1)x||addendum\n       else line = substr(line,1,seekcol-1)x||addendum||right(i,6,'0')\n     \"LINE\" i \"= (LINE)\"\n  end;\n  sortcol = seekcol + 1\n  \"(NUMLABF) = linenum\" word(labels,1)\n  \"(NUMLABL) = linenum\" word(labels,2)\n  \"(NUMLast) = linenum .zlast\"\n  if nosort = \"NOSORT\" then signal leaving\n  if x2c('41') = \"A\" then do;  /* Make ascii look like EBCDIC */\n    /* attempt to make sort look more ebcdic like */\n    \"change all x'30' x'f0'\" labels sortcol dwidth\n    \"change all x'31' x'f1'\" labels sortcol dwidth\n    \"change all x'32' x'f2'\" labels sortcol dwidth\n    \"change all x'33' x'f3'\" labels sortcol dwidth\n    \"change all x'34' x'f4'\" labels sortcol dwidth\n    \"change all x'35' x'f5'\" labels sortcol dwidth\n    \"change all x'36' x'f6'\" labels sortcol dwidth\n    \"change all x'37' x'f7'\" labels sortcol dwidth\n    \"change all x'38' x'f8'\" labels sortcol dwidth\n    \"change all x'39' x'f9'\" labels sortcol dwidth\n  end\n  \"sort\" labels sortcol dwidth\n  if x2c('41') = \"A\" then do;\n    /* restore normal ascii chars */\n    \"change all x'f0' x'30'\" labels sortcol dwidth\n    \"change all x'f1' x'31'\" labels sortcol dwidth\n    \"change all x'f2' x'32'\" labels sortcol dwidth\n    \"change all x'f3' x'33'\" labels sortcol dwidth\n    \"change all x'f4' x'34'\" labels sortcol dwidth\n    \"change all x'f5' x'35'\" labels sortcol dwidth\n    \"change all x'f6' x'36'\" labels sortcol dwidth\n    \"change all x'f7' x'37'\" labels sortcol dwidth\n    \"change all x'f8' x'38'\" labels sortcol dwidth\n    \"change all x'f9' x'39'\" labels sortcol dwidth\n  end\n  if leave = \"LEAVE\" then signal leaving\n  if numlabf \\= 1 then\n     \"label\" NUMlabf \"=\" word(labels,1) \"0\"\n  if numlabl \\= numlast then\n     \"label\" NUMlabl \"=\" word(labels,2) \"0\"\n  /* remove sorting information that was added */\n  \"change\" labels sortcol dwidth \" p'^' '' all\"\n  /* in spf/pc the above line must use an single space null */\n  \"seek\" sortcol dwidth \"P'#' first\"\n  if rc = 0 then do\n     call dnote \"found --- # -- aborting 1\"\n     call dnote \"change\" labels sortcol dwidth \" p'^' ' ' all\"\n     return 12\n  end\n  leaving:\n  \"X\" labels \"ALL\"\n  \"change all '-' ' '\" labels seekcol dwidth\n  \"reset chg\" labels /* spf/pc 3.07 does not like reset change*/\n  \"bounds\" lbound rbound\n  call Dnote time('n') 'SORTG --- completed' 'dwidth='dwidth\n  \"find first nx p'=' 1\"\n  \"cursor =\" row col\n  \"line_before\" numlabf \"= noteline \"\"begin SORTG\" tokens\"\"\"\"\n  \"line_after\" numlabl \"= noteline \"\"--end SORTG\" tokens labels\"\"\"\"\n  return 1\n\n Dnote: parse arg yyy; \"LINE_BEFORE .zf = NOTELINE (yyy)\"\n      zedsmsg = ''\n      zedlmsg = yyy\n      Address \"ISPEXEC\" \" SETMSG MSG(ISRZ000)\"\n    return;\n /* use (in another file) with option DEBUG for testing...\nzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx          00000001 NX\nyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx          00000002 NX\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx          00000003 NX\nwxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx x        00000004  X\nvxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx x        00000005  X\nuxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx x        00000006  X\ntxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx x        00000007  X\nsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx          00000008 NX\nrxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx          00000009 NX\nqxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx          00000010 NX\npxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx q        00000011  X\noxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx q        00000012  X\nnxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx q        00000013  X\nmxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx q        00000014  X\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx q        00000015  X\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx          00000016 NX\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx          00000017 NX\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx          00000018 NX\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx          00000019 end DEBUG*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPELL": {"ttr": 14341, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x010\\x010\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 304, "newlines": 304, "modlines": 0, "user": "MCRITCH"}, "text": "/*SPELL     Author: William R. Horton of        (now in REXX)        */\n/*                 Tennessee Eastman Company, Kingsport, TN.         */\n/*          Revisions made by David McRitchie                        */\n/*                 at \"The REXX Macros Toolbox\", DMcRitchie@aol.com    */\n/*          Updated 1991/04/08 -- 1991/12/24 11:40 IS03              */\n/*          Updated 1993/10/05 -- 1993/10/05 20:50 IS03 Convert to REXX */\n/*-------------------------------------------------------------------*/\n/*       Macro: SPELL                                                */\n/*       Purpose: Run SCRIPT against current data to check spelling  */\n/*-------------------------------------------------------------------*/\n/* Obtained from 'CBT' tape 103 -- TECH.CBT.FILE103.PDS(SPELL)       */\n/*  Created by William R. Horton of Tennessee Eastman Company of     */\n/*  Kingsport, TN,  this macro does not require member in edit to be */\n/*  saved, nor will it cause the member to be saved.   Changes have  */\n/*  been made since the original to provide support for SCRIPT       */\n/*  documents.  The use of PREFIX and NOPREFIX is supported for the  */\n/*  two datasets created for temporary usage.  Lines that have       */\n/*  spelling errors will be reset if  X ALL  was invoked before use. */\n/*  As an initial test this macro may be applied against itself.     */\n/*  Error words can be located with LOCATE SPECIAL.  Note lines will */\n/*  be created, which can be eliminated by  typing RESET or RESET    */\n/*  SPECIAL on the command line.                                     */\n/**********************************************************************/\n/*  PARM OPTIONS========                                              */\n/*    DEBUG         USUALLY TRACES SOME LINES                         */\n/*    DICT(DICT)    OVERRIDES DEFAULT DICTIONARY (SET IN PROFILE)     */\n/*    EAM           ENGLISH AMERICAN DICTIONARY SAME AS DICT(EAM)     */\n/*    PROFILE(PROFILE)  USE PROFILE OTHER THAN DEFAULT DSMPROF4       */\n/*    BROWSE        BROWSE SCRIPTED LISTING.  NORMALLY NOT SEEN.      */\n/*    EDIT          EDIT   SCRIPTED LISTING.  NORMALLY NOT SEEN.      */\n/*    NOCTL         Eliminate '.' and ':' in col 1 from spell test. . */\n/*                  Convert ':' anywhere in text to 9 to eliminate. . */\n/*                  Synonomous with MSDS text checking --macro MSPELL.*/\n/*    NX            SPELL CHECK ONLY NX LINES, OTHER LINES AS .*      */\n/*    X             WHEN SHOWING WORDS, TREAT AS IF ORIGINAL ALL X.   */\n/*                   WOULD BE USED ONLY IN COMBINATION WITH NX.       */\n/*    HELP          Invoke  ===> TSO CLIST SPELL HELP                 */\n/**********************************************************************/\n/*   NORMAL USAGE WITHOUT ANY PARAMETERS                              */\n/*      NO LINES DISPLAYED (X ALL), SPELL CHECK ALL LINES, LISTING    */\n/*         MISSPELLED WORDS BELOW ACTUAL LINE.  LINES IN ERROR RESET. */\n/*         USE OF (X ALL) BEFORE INVOKING SPELL IS MY PREFERENCE      */\n/*      AT LEAST SOME LINES SHOWN (NX ALL), SPELL WILL LIST LINES AND */\n/*         WORDS AT THE BEGINNING OF THE LIST.                        */\n/*-------------------------------------------------------------------*/\n    address \"ISREDIT\"\n    qcnt = 0\n    q.=\"\"\n    badline=0; xtralines=0\n    ADDRESS 'ISREDIT' 'MACRO (PARM)'\n    PARM = TRANSLATE(' 'PARM' ')\n    if  POS(' HELP ',PARM) \\=0 then do;\n        Address \"TSO\" \"%CLIST SPELL HELP\"; return 0;\n    end\n    PARMX = POS(' X ',PARM); IF PARMX \\= 0 THEN PARMX = 1\n    PARMNX = POS(' NX ',PARM); IF PARMNX \\= 0 THEN PARMNX = 1\n    DEBUG = POS(' DEBUG ',PARM); IF DEBUG \\= 0 THEN DEBUG = 1\n    NOCTL = POS(' NOCTL ',PARM); IF NOCTL \\= 0 THEN NOCTL = 1\n    /*******************************************************/\n    if noctl = 1 then do;\"x all\";xreset1=1;end\n    else do; \"ISREDIT\" \"SEEK FIRST P'=' 1 X\"\n             IF RC \\= 0 THEN \"x p'=' 1 all\"\n             ADDRESS \"ISREDIT\" \"SEEK FIRST P'=' 1 NX\"\n             IF RC = 0 THEN XRESET1 = 0\n             ELSE XRESET1 = 1\n    end\n    /*******************************************************/\n    ADDRESS 'ISREDIT' '(LAST) = LINENUM .ZLAST'\n    ADDRESS 'ISREDIT' '(WIDTH) = DATA_WIDTH'\n    ZEDSMSG =\n    ZEDLMSG = '** Spell checking in progress **'\n    ADDRESS 'ISPEXEC' 'CONTROL DISPLAY LOCK'\n    ADDRESS 'ISPEXEC' 'DISPLAY MSG(ISRZ000)'\n\n    ADDRESS 'ISREDIT' '(DSNX) = DATASET'\n    ADDRESS 'ISREDIT' '(MEMBERX) = MEMBER'\n    LP = '('\n    RP = ')'\n    DICT = ''          /* OR DEFAULT DICTIONARY HERE*/\n    I = POS(' DICT(',PARM)\n    IF  I \\= 0 THEN DO\n       PARSE VAR PARM LEFT 'DICT(' DICT ') ' RIGHT\n       PARM == LEFT RIGHT\n       SAY \"DICT=\"DICT\" FROM '\"PARM\"'\"\n    END\n    I = POS(' EAM ',PARM);  IF I \\= 0 THEN DICT = \"EAM\"\n\n    PROFILE = 'DSMPROF4'       /*DEFAULT*/\n    I = POS(' PROFILE(',PARM)\n    IF I \\= 0 THEN DO\n       PARSE VAR PARM LEFT ' PROFILE(' PROFILE ') ' RIGHT\n       PARM = LEFT RIGHT\n    END\n\n    /* TSO dataset conventions for use w/o quotes */\n    SYSUID = SYSVAR('SYSUID')\n    /* Allocate DCF input dataset -- allow up to 200 bytes/rec*/\n    ADDRESS 'TSO'\n    status = msg('off')\n    'free fi(ESPELL)'\n    'free fi(INFILE)'\n    spelldsn = \"'\"sysuid\".spell.macro'\"\n/*********************************************************************/\n/*     if sysdsn(spelldsn) = \"OK\" then \"del\" spelldsn                */\n/*********************************************************************/\n    status = msg('on')\n    'ALLOC FI(ESPELL) NEW CAT SPACE(45 45) TRACKS UNIT(SYSDA)' ,\n      'LRECL(255) RECFM(V B M) BLKSIZE(3156)' ,\n      \"DSN(\"spelldsn\") REUSE\"\n    /*  DCB attributes to the contrary will be reset by DCF */\n\n    /* Open file and SAY some SCRIPT commands to be sure */\n    /* data is formatted properly for parsing (later).     */\n\n    qcnt=qcnt+1; q.qcnt ='.PM 0 0'\n    qcnt=qcnt+1; q.qcnt ='.PW 133'\n    qcnt=qcnt+1; q.qcnt ='.LL 132'\n    qcnt=qcnt+1; q.qcnt ='.CL 132'\n    qcnt=qcnt+1; q.qcnt ='.FO OFF'\n    IF dict    \\= '' THEN DO\n       qcnt=qcnt+1; q.qcnt ='.DL' DICT\n       DICTX = '.DL' DICT\n    END\n\n    /* eliminate CCC last page count typed message */\n    qcnt=qcnt+1; q.qcnt ='.DM HCCEPIF ON'\n    qcnt=qcnt+1; q.qcnt ='.DM OFF'\n    qcnt=qcnt+1; q.qcnt ='.DM LASTPAGE ON'\n    qcnt=qcnt+1; q.qcnt ='.DM OFF'\n    qcnt=qcnt+1; q.qcnt ='.se pron ''0000'''\n    /* end \"The REXX Macros Toolbox\" considerations */\n\n    /*adding in words in this macro -- limit is 808 words */\n    dcfrec = '.DU ADD DCFINPUT dcfrec DCFMSG EASTMAN EAM ',\n               'dcfrec EDCTOUT ESPELL FI FSCR HORTON KINGSPORT' ,\n               'NGLOBAL NOPREFIX NRSTR Call TN DICTX regtm'\n          Call DCFINPUT\n\n    dcfrec = '.DC WORD 05 07 08 14 15 50 61 67 6A 7B 8C 8F ',\n               '9E 9F A1 AB AC AE BB BC BE BF B0 B1 B2 B3 B4 ',\n               'B5 B6 B7 B8 B9 CB CC C0 D0 EB EC E0 FA'\n         Call DCFINPUT\n    /*  by translating / to 9 eliminates JCL ddname   */\n    ADDRESS \"ISREDIT\" \"FIND .ZFIRST .ZFIRST 1 '//'\"\n    IF RC = 0 THEN DO; dcfrec = '.TI 61 F9'; Call DCFINPUT; end\n\n    /* WRITE EACH LINE OF THE DATA BEING EDITED */\n\n    xtrlines = qcnt     /* lines added in front of file */\n    I = 1\n    DO WHILE (I <= LAST)\n      IF 1 =  PARMNX THEN DO  /* SPECIAL IF NX OPTION IN USE*/\n         ADDRESS 'ISREDIT' '(XSTATUS) = XSTATUS' I\n         IF \"X\" =  XSTATUS THEN SPELLREC = '.*'\n         ELSE ADDRESS 'ISREDIT' '(SPELLREC) = LINE' I\n      END\n      ELSE ADDRESS 'ISREDIT' '(SPELLREC) = LINE' I\n      if noctl = 1 then do  /* for MSDS material w/o macros */\n          if substr(spellrec,1,4) = '.TOP',\n            | substr(spellrec,1,4) = '.BOT',\n            then spellrec = \" \";\n          if substr(spellrec,1,1) = '.' then\n             if substr(spellrec,1,4) \\= '.du ' then\n                spellrec='9'substr(spellrec,2)\n          if spellrec \\= \"\" then\n             spellrec = translate(spellrec,'9',':')\n      end\n      /* if msds then make first byte a \"9\" instead of \".\" */\n      qcnt=qcnt+1;  q.qcnt=SPELLREC\n      I =  I + 1\n    END\n    Address \"TSO\" \"EXECIO * DISKW ESPELL (STEM Q. FINIS\"\n    if pos(' BR',parm) \\= 0 then\n      ADDRESS 'ISPEXEC' 'BROWSE DATASET('spelldsn')'\n    /* Invoke SCRIPT/VS */\n\n    ZEDLMSG = '** SCRIPT/VS checking words **'\n    ADDRESS 'ISPEXEC' 'CONTROL DISPLAY LOCK'\n    ADDRESS 'ISPEXEC' 'DISPLAY MSG(ISRZ000)'\n  /*  ADDRESS 'ISPEXEC' 'SELECT MODE(FSCR) CMD(SCRIPT SPELL.MACRO SPELLCHK',*/\n  /*     FILE(&PREFIX.SPELL.MACRO.LIST) CO M(DELAY) Q B(0))*/\n    Address 'TSO' 'SCRIPT' spelldsn  'SPELLCHK' ,\n       'SEARCH('''DSNX''')',\n       'PRO(''SCRIPT.R40.MACLIB('PROFILE')'')',\n       'LIB(''SCRIPT.R40.MACLIB'')',\n       'SYS(X NO)',\n       'FILE('''SYSUID'.SPELL.MACRO.LIST'') CO M(DELAY) Q B(0)'\n    SCRIPT_RC = RC\n    if script_rc \\= 0 then\n      SAY 'rc='script_rc 'from ... SCRIPT spell.macro SPELLCHK' ,\n       'SEARCH('''DSNX''')',\n       'PRO(''SCRIPT.R40.MACLIB('PROFILE')'')',\n       'LIB(''SCRIPT.R40.MACLIB'')',\n       'SYS(X NO)',\n       'FILE('''SYSUID'.SPELL.MACRO.LIST'') CO M(DELAY) Q B(0)'\n    ZEDSMSG =\n    ZEDLMSG = '** SPELL CHECKING IN PROGRESS ** -- FINAL PHASE'\n    ADDRESS 'ISPEXEC' 'CONTROL DISPLAY LOCK'\n    ADDRESS 'ISPEXEC' 'DISPLAY MSG(ISRZ000)'\n\n    address 'TSO' 'FREE FI(ESPELL) DELETE'\n    EOF = 'NO'\n    MISSPELLED = 0\n    IF POS(' BR',PARM) \\= 0 THEN\n      ADDRESS 'ISPEXEC' 'BROWSE DATASET('''SYSUID'.SPELL.MACRO.LIST'')'\n    IF POS(' ED',PARM) \\= 0 THEN,\n      ADDRESS \"ISPEXEC\" \"EDIT DATASET('\"SYSUID\".SPELL.MACRO.LIST') MACRO(NULL)\"\n    \"ALLOC FI(infile) DSN('\"SYSUID\".SPELL.MACRO.LIST') OLD REUSE\"\n    q.=\"\"\n    ADDRESS \"TSO\" \"EXECIO * DISKR infile (STEM Q. FINIS\"\n\n    /*------------------------------------------------------*/\n    /* Read SCRIPT error messages and create MSG records to */\n    /* show user which card images have misspelled words.   */\n    /*------------------------------------------------------*/\n    /* aaaa aabb aaBB aacc aaCC aaff aagg aahh aaii aajj aakk*/\n\n    IF  PARMX = 1 THEN DO   /*IF PARM OPTION X TREAT AS IF MIXED*/\n       XRESET1 = 1\n       ADDRESS \"ISREDIT\" \"x 1 p'=' all\"\n    END\n    dcfrec=\"\"\n    call getrec\n    EOF = \"NO\"\n    DO WHILE (EOF = 'NO')\n       L =  LENGTH(dcfrec)\n       /* no need to check in rexx -- IF  L > 18 THEN D-o-*/\n       IF SUBSTR(dcfrec,2,15) = 'WORDS NOT FOUND' THEN DO\n          MISSPELLED =  MISSPELLED + 1\n          DCFMSG = SUBSTR(dcfrec,2)\n          DCFMSG2 = SUBSTR(dcfrec,17)\n          OKAY = 'NO'\n          call GETREC  /* get DCFREC from file*/\n          x7 = substr(dcfrec,2,7)\n          IF  x7 = '''MACRO''' THEN OKAY = 'YES'\n          DO WHILE OKAY||EOF = 'NONO'\n            DCFMSG = DCFMSG||SUBSTR(dcfrec,2)\n            call GETREC  /* get DCFREC from file*/\n            x7 = substr(dcfrec,2,7)\n            if x7 = '''MACRO''' then OKAY = 'YES'\n          END\n          parse var dcfrec '''MACRO'' LINE ' badline ':'\n          if datatype(badline,'N') then do\n           badline =   badline -   xtrlines\n           ADDRESS 'ISREDIT' 'LINE_AFTER' badline' = NOTELINE (DCFMSG)'\n           IF  XRESET1  = 1 THEN ,\n               ADDRESS 'ISREDIT' 'RESET X' badline   badline\n           ELSE do\n              IF  MISSPELLED < 11 THEN\n                  ADDRESS 'ISREDIT' 'LINE_BEFORE .ZFIRST = ',\n                     'NOTELINE' '(DCFMSG2)'\n           end\n        end\n       END\n\n       call getrec\n    END\n\n    /*\"FREE FI(infile) DELETE\"*/\n\n    IF  MISSPELLED > 0 THEN DO\n       ADDRESS 'ISREDIT' 'LINE_AFTER 0 = MSGLINE' ,\n         '''MISSPELLED WORDS WERE FOUND ON' MISSPELLED 'LINES' ,\n         '(SEE BELOW).'''\n       IF XRESET1 = 0 THEN ,\n          ADDRESS 'ISREDIT' 'LINE_BEFORE .ZF = MSGLINE ''-- UP TO 11 LINES',\n             'SHOWN ABOVE -- ALL MISSPELLINGS APPEAR BELOW --'''\n       ADDRESS 'ISREDIT' 'LOC 0'\n       ZEDSMSG =  MISSPELLED 'LINES HAD ERRORS'\n       ZEDLMSG =  MISSPELLED 'LINES HAD SPELLING ERRORS',\n           DICTX '-- SCRIPT RC='SCRIPT_RC\n       ADDRESS 'ISPEXEC' 'SETMSG MSG(ISRZ001)'\n    END\n\n    ELSE DO\n       ZEDSMSG = 'NO MISSPELLED WORDS!'\n       ZEDLMSG = 'ALL WORDS FOUND' DICTX,\n              '-- SCRIPT RC='SCRIPT_RC\n       ADDRESS 'ISPEXEC' 'SETMSG MSG(ISRZ000)'\n   END\n   if noctl = 1 then do\n      address \"ISREDIT\"\n      \"find 1 all '.msds0002'\"\n      \"find 1 all '.msds0040'\"\n      \"find 1 all '.msds0005'\"\n      \"find 1 all '.msds0006'\"\n      \"find 1 all '.msds0002'\"\n   end\n   return\nEND\nDCFINPUT: procedure ,\n   Expose dcfrec qcnt q.\n        qcnt=qcnt+1; q.qcnt  = dcfrec\n   Return\nGETREC: procedure Expose qcnt dcfrec EOF q.\n   qcnt = qcnt + 1\n   if qcnt <= q.0 then do\n      dcfrec = q.qcnt\n   end;\n   else do;\n      dcfrec=\">>EOF>>\"\n      EOF=\"YES\"\n   end;\n   Return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRCH401": {"ttr": 14347, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x009\\x009\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "MCRITCH"}, "text": "/*  REXX -- COMPANION TO SRCH400 DOC IN IS03.SHARE.TEXT(SRCH400) */\nADDRESS \"ISREDIT\";\"MACRO\"\n\"FIND FIRST '---------- STRING(S) FOUND ------------------'\"\nTIMEX = TIME()\nIF RC \\= 0 THEN DO\n   ZEDSMSG = \"-- STRINGS(S)\"\n   ZEDLMSG = \"INPUT NOT AS EXPECTED FOR  USERID.SRCHFOR.LIST\"\n   \"LINE_BEFORE .ZF = NOTELINE '\"TIME(),\n        \"SRCH401 DOES NOT HAVE THE INPUT EXPECTED'\"\n   \"LINE_BEFORE .ZF = NOTELINE\",\n       \"\"\" *ERROR*  MISSING  ---- STRINGS(S) FOUND ------\"\"\"\n   ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   RETURN 1\nEND\n\"X ALL\"\n\"FIND P'^' ALL\"\n\"DEL X ALL\"\n\"RESET\"\n\"X 'LINE-#  SOURCE SECTION' ALL\"\n\"X 'SUPERC - FILE/LINE/WORD/BYTE COMPARE PGM -' ALL\"\n\"X ' SUPERC - MVS/PDF FILE/LINE/WORD/BYTE/SFOR COMPARE UT' ALL\"\n\"DEL X ALL\"\n\"SHIFTNX RIGHT 10\"\n\"X ALL\"\n\"CHANGE ALL '----------- STRING(S) FOUND ------------------' ' '\"\n\"CHANGE ALL NX 12 ' ' '*'\"\n\"CHANGE ALL NX 2 P'==========' ''\"\n\"FIND LAST P'^' 3\"\nIF RC /= 0 THEN RETURN 4\n\"LABEL .ZLAST = .LSTSRCH\"\nCHGIT:\n\"(LINE) = LINE .ZCSR\"\n\"LABEL .ZCSR = .CURSRCH\"\nFROM =  SUBSTR(LINE,3,8)\n\"CHANGE ALL .CURSRCH .LSTSRCH 3 \"\"        \"\"  \"\"\"FROM\"\"\"\"\nIF RC \\= 0 THEN SIGNAL DONENOW\n\"X ALL .CURSRCH .LSTSRCH\"\n\"LABEL .CURSRCH = .LSTSRCH\"\n\"FIND LAST '*' 2 NX\"\nIF RC = 0 THEN SIGNAL CHGIT\n\"X ALL\"\n\"FIND 2 '*' ALL\"\n\"CHANGE ALL NX 3 11 P'^' ' '\"\n\"CHANGE ALL NX 3 11 P'^' ' '\"\n\"CHANGE ALL X          .ZF .ZL 11 ' ' '|'\"\n\"CHANGE ALL .ZF .ZL 2 ' ' '|'\"\n\"FIND 12 'LINES-FOUND' LAST\"\nIF RC = 0 THEN\n\"   CHANGE ALL .ZCSR .ZL P'=' 3 10 '*'\"\n\nZEDSMSG = \"COMPLETED\"\nZEDLMSG =  TIME() \"SRCH401 HAS COMPLETED SUCCESSFULLY\"\nADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n\"RESET\"\n\"LINE_BEFORE .ZF = NOTELINE '\"TIMEX\"-\"TIME(),\n        \"SRCH401 -- REFORMAT OF SUPERC LISTING COMPLETED'\"\nRETURN 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUBMITIT": {"ttr": 14349, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x07\\x00\\x07\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "MCRITCH"}, "text": "/*SUBMITIT  Author: David McRitchie, created 1987/03/13 IS03 -REXX */\n/*          \"The REXX Macros Toolbox\", DMcRitchie@aol.com    */\n/*   SUBMIT with CANCEL prevents making an unwanted save later*/\n Address \"ISREDIT\"  \"MACRO\"      /* converted to REXX 1994/05/19*/\n Address \"ISREDIT\"  \"SUBMIT\"\n Address \"ISREDIT\"  \"AUTOSAVE ON\"\n Address \"ISREDIT\"  \"CANCEL\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUPERC": {"ttr": 14593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01\\xd0\\x01\\xd0\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 464, "newlines": 464, "modlines": 0, "user": "MCRITCH"}, "text": "/*SUPERC    AUTHOR: IBM --- ISPF PDF OPTION 3.13 -- SAMPLIB         */\n/*          MODIFICATIONS HAVE BEEN MADE SEE NOTES BELOW, MODIFIED  */\n/*              \"THE REXX MACROS TOOLBOX\", DMCRITCHIE@AOL.COM    */\n/*          UPDATED 1991/06/13 10:53 IS03                           */\n/********************************************************************/\n        PROC 0 NEWFILE(DUMMY) OLDFILE(DUMMY) OUTDD(DUMMY)            +\n             DELDD(DUMMY) SYSIN(DUMMY) LISTING(DELTA) CTYPE(LINE)    +\n             MACRO()                                                 +\n             PROCESS() UID(&SYSPREF.) BROWSE EDIT DEBUG PLIB         +\n             LIB(SYS1.ISPFPDF.ISRLOAD(ISRSUPC))\n                 /* FOR PRIVATE LIB. OR OUTSIDE ISPF (INSTALLER MUST */\n                 /* MODIFY THE LIB PARAMETER.)                       */\n        /*************************************************************/\n        /*CLIST OBTAINED/MODIFIED FROM SYS1.SAMPLIB(ISRSCLST)        */\n        /*      BROWSE EDIT AND MACRO() OPTIONS ADDED                */\n        /*   COMPARISON MAY BE MADE TO THE ORIGINAL USING            */\n        /*  ==> @COMPARE SYS1.SAMPLIB(ISRSCLST)                      */\n        /*************************************************************/\n        /*  //*    AS A BATCH JOB\n        /*  //$NAME$  EXEC SUPERC,PROCESS='SEQ',LISTING=DELTA,SYSOUT=V\n        /*  //    OLDFILE='SYS6.SAS516.CNTL($NAME$)',TYPE=WORD,\n        /*  //    NEWFILE='SYS6.SAS518.CNTL($NAME$)\n        /*************************************************************/\n        /*                                                           */\n        /* CLIST NAME : ISRSCLST (SUPERC LINE COMMAND VERSION)       */\n        /*                                                           */\n        /* DESCRIPTION:                                              */\n        /*                                                           */\n        /*     ISRSCLST IS A SAMPLE \"LINE COMMAND\" CLIST THAT        */\n        /*     DEMONSTRATES MOST OF THE CAPABILITY OF SUPERC COMPARE */\n        /*     PROGRAM.  IT HAS LIMITED ERROR RECOVERY AND ERROR     */\n        /*     DIAGNOSTIC CAPABILITIES.  FURTHER, CERTAIN SUPERC     */\n        /*     FUNCTIONS ARE NOT SUPPORTED (E.G.  APNDLST AND        */\n        /*     APNDUPD).                                             */\n        /*                                                           */\n        /*     THIS CLIST HAS BEEN DEVELOPED FOR EXECUTION IN AN     */\n        /*     ISPF/PDF ENVIRONMENT.  HOWEVER, THERE IS SOME         */\n        /*     ADDITIONAL LOGIC (TSO/E  R2 DEPENDENT AND A \"PLIB\"    */\n        /*     PARAMETER) THAT WILL ALLOW THE USER TO EXECUTE THE    */\n        /*     CLIST OUTSIDE ISPF AND FROM A PRIVATE LIBRARY.        */\n        /*                                                           */\n        /*                                                           */\n        /*************************************************************/\n        CONTROL NOMSG NOLIST NOCONLIST NOFLUSH\n   /*      SET &DEBUG = DEBUG\n        IF &STR(&UID.) = &STR() THEN SET UID=&SYSUID.\n        IF &DEBUG = DEBUG THEN +\n          CONTROL MSG LIST CONLIST SYMLIST\n        SET &RETCC = 0\n        FREE FI(NEWDD,ISRS,SYSIN,OUTDD,DELDD)\n        IF &NEWFILE = DUMMY THEN +\n           SET &NEWFILE =\n        IF &OLDFILE = DUMMY THEN +\n           SET &OLDFILE =\n        /*************************************************************/\n        /* SET UP ERROR EXIT BEFORE FOR NEWFILE VERIFICATION.        */\n        /*************************************************************/\n        NEWDD1:ERROR +\n        DO\n          ERROR OFF\n          IF &NEWFILE ^=      THEN +\n             WRITE ** INVALID DATASET NAME/MEMBER OR BUSY: &NEWFILE\n          IF &FIRST =    THEN +\n          DO\n             SET &FIRST = DONE\n             IF &UID ^=     THEN +\n             DO\n                WRITE +\n         USE FULLY QUALIFIED DATASET NAME WITHOUT QUOTES OR \".\" +\n                                                 FOR USER PREFIX.\n                WRITE +\n        * EXAMPLE:   &UID..SUPERC.NEWIN   AND   .SUPERC.NEWIN    +\n                                                   ARE EQUIVALENT.\n             END\n             ELSE WRITE +\n        * USE FULLY QUALIFIED NAME WITHOUT QUOTES.\n          END\n          SET &NEWFILE =\n          WRITENR NEW FILE :&STR()\n          READ\n          SET &NEWFILE = &SYSDVAL\n          IF &STR('&NEWFILE') = 'EXIT' | &STR('&NEWFILE') =  '' THEN +\n            GOTO EXIT\n          ELSE GOTO NEWDD1\n        END\n        /*************************************************************/\n        /* VERIFY/ALLOCATE NEWFILE.                                  */\n        /*************************************************************/\n        IF &NEWFILE ^=    THEN +\n        DO\n          IF &SUBSTR(1:1,&NEWFILE) = . THEN +\n              SET &NEWFILE = &UID..&NEWFILE\n        END\n        CONTROL NOMSG\n        ALLOC FI(NEWDD) DA('&NEWFILE') SHR  REUSE\n        IF &SUBSTR(&LENGTH(&NEWFILE):&LENGTH(&NEWFILE),&NEWFILE) = ) +\n                                                                THEN +\n        DO\n\n          /***********************************************************/\n          /* INSURE NEWFILE IS SEQUENTIAL AND IF PO- MEMBER EXITS    */\n          /***********************************************************/\n          ALLOC FI(ISRS) DA('&NEWFILE') REUSE SHR\n          OPENFILE ISRS\n          CLOSFILE ISRS\n          FREE FI(ISRS)\n        END\n        /*************************************************************/\n        /* OLDFILE FULLY QUALIFIED?                                  */\n        /*************************************************************/\n        CONTROL NOMSG\n        /*************************************************************/\n        /*   ERROR EXIT FOR OLDFILE VERIFICATION.                    */\n        /*************************************************************/\n        OLDDD1:ERROR +\n        DO\n          ERROR OFF\n          IF &OLDFILE ^=  THEN +\n             WRITE ** INVALID DATASET NAME/MEMBER OR BUSY: &OLDFILE\n          IF &FIRST =    THEN +\n          DO\n             SET &FIRST = DONE\n             IF &UID ^= &STR() THEN +\n             DO\n                WRITE +\n         USE FULLY QUALIFIED DATASET NAME WITHOUT QUOTES OR \".\" +\n                                                 FOR USER PREFIX.\n                WRITE +\n        * EXAMPLE:   &UID..SUPERC.OLDIN   AND   .SUPERC.OLDIN    +\n                                                 ARE EQUIVALENT.\n             END\n             ELSE WRITE +\n        * USE FULLY QUALIFIED NAME WITHOUT QUOTES.\n          END\n          SET &OLDFILE =\n          WRITENR OLD FILE :&STR()\n          READ\n          SET &OLDFILE = &SYSDVAL\n          IF &STR('&OLDFILE') = 'EXIT' | &STR('&OLDFILE') = '' THEN +\n            GOTO EXIT\n          ELSE GOTO OLDDD1\n        END\n        /*************************************************************/\n        /* OLD FILE VERIFICATION CODE.                               */\n        /*************************************************************/\n        IF &CTYPE = SRCH THEN +\n        DO\n           IF &SYSIN = DUMMY THEN  +\n              SET &SYSIN = PROMPT\n        END\n        ELSE +\n        DO\n          IF &OLDFILE ^= &STR() THEN +\n          DO\n             IF &SUBSTR(1:1,&OLDFILE) = . THEN +\n                SET &OLDFILE = &STR(&UID.&OLDFILE)\n          END\n          ALLOC FI(OLDDD) DA('&OLDFILE') SHR REUSE\n          IF &SUBSTR(&LENGTH(&OLDFILE):&LENGTH(&OLDFILE),&OLDFILE)=) +\n                                                               THEN  +\n          DO\n             ALLOC FI(ISRS) DA('&OLDFILE') REUSE SHR\n             OPENFILE ISRS\n             CLOSFILE ISRS\n             FREE FI(ISRS)\n          END\n        END\n        ERROR OFF\n        /*************************************************************/\n        /* VERIFICATION/ALLOCATION OF LISTING DSN.                   */\n        /*************************************************************/\n        OUTDD1: +\n        IF &OUTDD = DUMMY THEN +\n        DO\n           SET OUTDD = &UID..SUPERC.LIST\n           IF &UID = &STR() THEN +\n              SET OUTDD = &SYSUID..SUPERC.LIST\n        END\n        ELSE IF &SUBSTR(1:1,&OUTDD) = . THEN +\n           SET &OUTDD = &STR(&UID..&OUTDD)\n        CONTROL NOMSG\n        FREE DA('&OUTDD')\n        ERROR +\n        DO\n          ERROR OFF\n          SET &PO = &SUBSTR(&LENGTH(&OUTDD)-1:&LENGTH(&OUTDD)-1,&OUTDD)\n          IF &PO = ) THEN +\n             SET &DIRM = &STR(DIR(5) DSORG(PO))\n          ELSE +\n             SET &DIRM = &STR(RELEASE DSORG(PS))\n          ALLOC FI(OUTDD) DA('&OUTDD') SPACE (50 100) BLKSIZE(3325) +\n                                                      REUSE NEW &DIRM\n          IF &LASTCC = 0 THEN +\n             GOTO SYSIN1\n          ELSE +\n          DO\n             WRITE    ** INVALID DATASET NAME/MEMBER OR BUSY: &OUTDD\n             IF &FIRST =   THEN +\n             DO\n                SET &FIRST = DONE\n                IF &UID ^= &STR() THEN +\n                DO\n                   WRITE +\n         USE FULLY QUALIFIED DATASET NAME WITHOUT QUOTES OR \".\" +\n                                                 FOR USER PREFIX.\n                   WRITE +\n        * EXAMPLE:   &UID..SUPERC.LIST    AND   .SUPERC.LIST     +\n                                                    ARE EQUIVALENT.\n                END\n                ELSE WRITE +\n        * USE FULLY QUALIFIED NAME WITHOUT QUOTES.\n             END\n             SET &OUTDD =\n             WRITENR LISTING FILE :&STR()\n             READ\n             SET &OUTDD = &SYSDVAL\n             IF &STR('&OUTDD') = 'EXIT' | &STR('&OUTDD') = '' THEN +\n               GOTO EXIT\n             ELSE +\n               GOTO OUTDD1\n          END\n        END\n        ALLOC FI(OUTDD) DA('&OUTDD') OLD  REUSE     /* ALLOC. AS OLD.*/\n        /*************************************************************/\n        /* STATEMENTS (SYSIN) DATA SET.                              */\n        /*************************************************************/\n        ERROR OFF\n        SYSIN1: +\n        IF &STR(&SYSIN) ^= DUMMY THEN +\n        DO\n          IF &STR(&SYSIN) ^= &STR(PROMPT) THEN +\n          DO\n            /*********************************************************/\n            /* SYSIN DSN ERROR RECOVERY.                             */\n            /*********************************************************/\n            ERROR +\n            DO\n              WRITE  ** INVALID DATASET NAME/MEMBER OR BUSY:  &SYSIN\n              IF &FIRST = THEN +\n              DO\n                 SET &FIRST = DONE\n                 IF &UID ^= &STR() THEN +\n                 DO\n                WRITE +\n         USE FULLY QUALIFIED DATASET NAME WITHOUT QUOTES OR \".\" +\n                                                 FOR USER PREFIX.\n                WRITE +\n        * EXAMPLE:   &UID..SUPERC.STMTS   AND   .SUPERC.STMTS    +\n                                                   ARE EQUIVALENT.\n                 END\n                 ELSE WRITE +\n        * USE FULLY QUALIFIED NAME WITHOUT QUOTES.\n              END\n              SET &SYSIN =\n              ERROR OFF\n              WRITENR SYSIN FILE :&STR()\n              READ\n              SET &SYSIN = &SYSDVAL\n              IF &STR('&SYSIN') = 'EXIT' | &STR('&SYSIN') = '' THEN +\n                GOTO EXIT\n              ELSE +\n              GOTO SYSIN1       /*  RECYCLE FOR ERROR CASE  */\n            END\n        CONT3: +\n            IF &SUBSTR(1:1,&SYSIN) = . THEN +\n              SET &SYSIN = &STR(&UID..&SYSIN)\n            CONTROL NOMSG\n            /*********************************************************/\n            /* VERIFICATION/ALLOCATION OF SYSIN DSN.                 */\n            /*********************************************************/\n            ALLOC FI(SYSIN) DA('&SYSIN') SHR  REUSE\n            ALLOC FI(ISRS)  DA('&SYSIN') SHR  REUSE\n            OPENFILE ISRS\n            CLOSFILE ISRS\n            FREE FI(ISRS)\n            ERROR OFF\n            CONTROL NOMSG\n          END\n          ELSE +\n          DO\n            /*********************************************************/\n            /* PROMPT FOR PROCESS STATEMENTS.                        */\n            /*********************************************************/\n            SET SYSIN = &UID..SUPERC.STMTS\n            IF &UID = &STR() THEN +\n               SET SYSIN = &SYSUID..SUPERC.STMTS\n            CONTROL NOMSG\n            DELETE '&SYSIN'\n            CONTROL MSG\n            ALLOC FI(SYSIN) DA('&SYSIN') SPACE (5 5) REUSE NEW +\n                                  RECFM(F,B) LRECL(80) BLKSIZE(1600)\n            CONTROL NOMSG\n            SET &TSYSIN  = &SYSIN\n            OPENFILE SYSIN OUTPUT\n            IF &CTYPE = SRCH THEN +\n            DO\n            WRITE  ENTER SRCHFOR AND ANY OTHER PROCESS STATEMENTS\n            WRITE  SRCHFOR STATEMENT FORMAT: SRCHFOR  +\n                                              SEARCH-PATTERN-IN-QUOTES\n            END\n            ELSE +\n            DO\n            WRITE +\n        PROCESS STATEMENT FORMAT:      (COMPARE TYPE)       EXAMPLES:\n            WRITE &STR( ) +\n         CMPCOLM  START-COLM:STOP-COLM ...  (L,W)     +\n                                                   CMPCOLM  1:60 75:90\n            WRITE &STR( ) +\n         LSTCOLM  START-COLM:STOP-COLM      (L  )     LSTCOLM  1:75\n            WRITE &STR( ) +\n         DPLINE   'STRING',START-POSITION   (L,W)     +\n                                                   DPLINE   'PAGE ',87\n            WRITE &STR(                 ) +\n                         OR, START-RANGE              +\n                                                DPLINE   'PAGE ',87:95\n            WRITE &STR(                 ) +\n                         OR  ENTIRE LINE              DPLINE   'PAGE '\n            WRITE &STR( ) +\n         SELECT   MEMBER, ...               (ALL)     +\n                                             SELECT   MEM1,NMEM2:OMEM2\n            WRITE &STR( ) +\n         LNCT     NNNNNN                    (ALL)     LNCT 999\n            WRITE &STR( ) +\n         OTHERS: NTITLE  (ALL)  OTITLE   (ALL)  CMPLINE  (L,W)  +\n                                                         CMPLNUM  (L,W)\n            WRITE &STR(         ) +\n                 CMPBOFS (B  )  CMPCOLMN (L,W)  CMPCOLMO (L,W)  +\n                                                         DPLINEC  (L,W)\n            WRITE &STR(         ) +\n                 NCHGT   (L,W)  OCHGT    (L,W)  SLIST    (ALL)  +\n                                                         * AND .* (ALL)\n            WRITE\n            WRITE  ENTER CONTROL STATEMENTS.\n            END\n            WRITENR &STR(   : )\n            SET &SYSDVAL =\n            READ\n            DO WHILE &STR(&SYSDVAL) ^= &STR() && +\n                                             &STR(&SYSDVAL) ^= &STR(/*)\n              SET &SYSIN = &STR(&SYSDVAL.   )\n              IF &STR('&SYSIN') = &STR('CANCEL') THEN +\n              DO\n                CLOSFILE SYSIN\n                GOTO EXIT\n              END\n              PUTFILE SYSIN\n              WRITENR &STR(   : )\n              READ\n            END\n            CLOSFILE SYSIN\n            SET &SYSINU = U                   /* INDICATE SYSIN USED */\n            SET &SYSIN = &TSYSIN             /*  RESTORE SYSIN NAME  */\n          END\n        END\n        ELSE +\n        DO\n          CONTROL NOMSG\n          FREE FILE(SYSIN)\n          CONTROL NOMSG\n        END\n        /*************************************************************/\n        /* UPDATE FILE SECTION.                                      */\n        /*************************************************************/\n        DELDD1: +\n        IF &DELDD = DUMMY THEN +\n        DO\n           SET DELDD = &UID..SUPERC.UPDATE\n           IF &UID = &STR() THEN +\n              SET DELDD = &SYSUID..SUPERC.UPDATE\n        END\n        ELSE IF &SUBSTR(1:1,&DELDD) = . THEN +\n           SET &DELDD = &STR(&UID.&DELDD)\n        CONTROL NOMSG\n        FREE DA('&DELDD')\n        ERROR +\n        DO\n          ERROR OFF\n          /* CHECK FOR PO DATASET SPECIFICATION\n          SET &PO=&SUBSTR(&LENGTH(&DELDD)-1:&LENGTH(&DELDD)-1,&DELDD)\n          IF &PO = ) THEN +\n             SET &DIRM = DIR(5)\n          ELSE +\n             SET &DIRM = &STR(RELEASE DSORG(PS))\n          ALLOC FI(DELDD) DA('&DELDD') SPACE (15 30) BLKSIZE(1600) +\n                                                      REUSE NEW &DIRM\n          IF &LASTCC = 0 THEN +\n             GOTO INVOKE1\n          ELSE +\n          DO\n             WRITE    ** INVALID DATASET NAME/MEMBER OR BUSY: &DELDD\n             IF &FIRST =   THEN +\n             DO\n                SET &FIRST = DONE\n                IF &UID ^= &STR() THEN +\n                DO\n                   WRITE +\n         USE FULLY QUALIFIED DATASET NAME WITHOUT QUOTES OR \".\" +\n                                                 FOR USER PREFIX.\n                   WRITE +\n        * EXAMPLE:   &UID..SUPERC.UPDATE  AND   .SUPERC.UPDATE   +\n                                                   ARE EQUIVALENT.\n                END\n                ELSE WRITE +\n        * USE FULLY QUALIFIED NAME WITHOUT QUOTES.\n             END\n             SET &DELDD =\n             WRITENR UPDATE FILE :&STR()\n             READ\n             SET &DELDD = &SYSDVAL\n             IF &STR('&DELDD') = 'EXIT' | &STR('&DELDD') = '' THEN +\n               GOTO EXIT\n             ELSE +\n               GOTO DELDD1\n          END\n        END\n        ALLOC FI(DELDD) DA('&DELDD') OLD  REUSE     /* ALLOC. OLD.   */\n        INVOKE1: +\n        ERROR OFF\n        /*************************************************************/\n        /* INVOKE SUPERC.                                            */\n        /*************************************************************/\n        WRITE  *** SUPERC INVOKED\n        IF &LISTING ^= OVSUM && &LISTING ^= DELTA && +\n                         &LISTING ^= LONG  && &LISTING ^= CHNG && +\n                                              &LISTING ^= NOLIST THEN +\n          SET LISTING = DELTA\n        IF &SYSISPF = ACTIVE && &PLIB =   THEN +\n        DO\n           /**********************************************************/\n           /* ASSUME ISPF IS ACTIVE AND USER DOESN'T HAVE SUPERC IN  */\n           /* A PRIVATE LIBRARY.                                     */\n           /**********************************************************/\n           ISPEXEC SELECT PGM(ISRSUPC) +\n                                  PARM(&LISTING.L,&CTYPE.CMP,&PROCESS.)\n           SET &RETCC = &LASTCC\n        END\n        ELSE +\n        DO\n           /**********************************************************/\n           /* OUTSIDE OF ISPF AND/OR PRIVATE SUPERC LOAD LIBRARY USE */\n           /* \"CALL\" INSTEAD OF \"ISPEXEC SELECT.\"                    */\n           /**********************************************************/\n           CALL '&LIB' '&LISTING.L,&CTYPE.CMP,&PROCESS.'\n           SET &RETCC = &LASTCC\n        END\n        WRITE  *** SUPERC RETURN CODE = &RETCC ***\n        CONTROL NOMSG\n        FREE DA('&OUTDD')\n        FREE FI(NEWDD OLDDD DELDD OUTDD ISRS)\n        /*************************************************************/\n        /* BROWSE LISTING (IF IN ISPF INVIRONMENT)                   */\n        /* ASSUMES TO E/ R2 OR BETTER SYSTEM.                        */\n        /*************************************************************/\n        IF &SYSISPF = ACTIVE THEN +\n        DO\n          IF &EDIT = EDIT | &STR(&MACRO.) ^= &STR() THEN +\n              ISPEXEC EDIT   DATASET('&OUTDD') MACRO(&MACRO)\n          ELSE DO\n             IF &BROWSE = BROWSE THEN +\n                 ISPEXEC BROWSE DATASET('&OUTDD')\n          END\n        END\n        EXIT: +\n        EXIT CODE(&RETCC)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYSDSN": {"ttr": 14601, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x88\\x00\\x88\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 136, "newlines": 136, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- SYSDSN -- Verify existance of dataset name at cursor      */\n/*  SYSDSN EDIT   -- edit the dataset after verifying existence      */\n/*  SYSDSN BROWSE -- browse the dataset after verifying existence    */\n/*  SYSDSN DSLIST -- DSLIST panel with datasetname (w/o member)      */\n /* SYSDSN    ** CREATED BY D.MCRITCHIE 1992/03/23 \"The REXX Macros Toolbox\" */\n /* **USAGE WOULD BE TO SET UP A PFKEY SUCH AS 19 ===> SYSDSN EDIT   */\n/*     place curson on the dataset name, and then hit PFK19          */\n/*********************************************************************/\n/* suggested PFKEYS currently used by D.McRitchie                    */\n/*    1-6   HELP,   SPLIT,   END,   :TS,     RFIND,    RCHANGE,      */\n/*    7-12  UP,     DOWN,    SWAP,  LEFT,    RIGHT,    CURSOR        */\n/*   13-18  PIR AT, PIR,     ***,   PIR S,   *,        SYSDSN        */\n/*   19-24  SYSDSN EDIT, EDITMEM, *, !EDCHEK, (*TEMP*), RETRIEVE     */\n/* PFK23 is frequently changed to  PRINT  or PRINT//print//          */\n/* PFK15 is left as *** to keep fingers off of this row for a PF3    */\n/* PFK17 is probably set at  SYSDSN BROWSE  but not necessarily      */\n/*********************************************************************/\n/* see June, 1992 CIS Newsletter, article by David McRitchie, page 15*/\nAddress \"ISREDIT\"\n\"MACRO (TOKEN)\"\nTOKEN = translate(TOKEN)\n\" (MEMBERX) = MEMBER \"\n\" (DSNX)    = DATASET\"\n\"(ROW,COL) = CURSOR\"\n IF COL = 0 THEN COL = 1\n\" (LINE) = line \" ROW\nline = translate(line)\nIF substr(line,col,4) = 'DSN=' then col = col + 4\n\"(LABEL) = LABEL .ZCSR\"\nif rc \\= 0 then \"LABEL .zcsr = .EDIT 0\"\nif ROW = 0 then do\n   ZEDSMSG = \"SYSDSN cursor\"\n   ZEDLMSG=\"SYSDSN -- no name found, since cursor has not been placed\"\n   address \"ISPEXEC\" \"SETMSG MSG(ISRZ001)\"\n   return 1\nend\nfrom = COL  /* in case cursor on a blank or something invalid */\ndo i = COL to 1 by -1;\n   L=verify(substr(line,i,1),'1234567890abcdefghijklmnopqrstuvwxyz'||,\n      '-ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$().')\n   if l \\= 0 then leave\n   from = i\nend\nline = substr(line,from)\nL=verify(line,'1234567890abcdefghijklmnopqrstuvwxyz'||,\n   '-ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$().*%')\nif l \\=1 then do\n    if substr(line,l-1,1) = '(' then do\n    i = pos(')',line)\n    if i \\= 0 then line = substr(line,1,i)\n    ZEDLMSG = \"Proceeding after dropping membername portion\" line\n    address \"ISPEXEC\"   \"SETMSG MSG(ISRZ001)\"\n    l = l - 1  /*dsname(&member.)*/\n      /* -\"-  allows for dsname(&member.)  and  \"dsn.name(\"member\")\"*/\n      /*            by using only the dsname portion                */\n    end\n    line=substr(line,1,l-1)\n    if substr(line,l-1,1) = '.' then line=substr(line,1,l-2)\nend\nelse do\n   ZEDSMSG = \"no name\"\n   ZEDLMSG = \"SYSDSN did not find a name at line\" ROW ', col ' COL\n   address \"ISPEXEC\"   \"SETMSG MSG(ISRZ001)\"\n   return 1\nend\ngotone:\n/******|provided for-------| *** |DSLIST limitations----|*************/\n/*     is03.share.text(cut)      is03.xyz.uuu(+1)       */\n/*     is03.share.text(editmem)  is03.share.text(art*)  */\n/*     is03.libr.clist(SYSDSN)   is03.*.text            */\n/* ()  is03.libr.clist(&mem.)    is03.*.text            */\n/*     is03.share.text sysdsn)  */\n/*********************************************************************/\nI = pos(\"DSLIST\",token)\nif i \\= 0 then do\n    address \"ISPEXEC\" \"VGET ZDLDSNLV PROFILE\"\n    olddsn = zdldsnlv\n    i = pos('(',line)\n    if i \\=0 then line = substr(line,1,i-1)\n    ZDLDSNLV = LINE\n    address \"ISPEXEC\" \"VPUT ZDLDSNLV PROFILE\"\n             /* ACCORDING TO Q417856 QUALIFIED DATASET*/\n             /* SHOULD HAVE USED LMMDISP. */\n             /* METHOD USED HAS PANEL OPTIONS AVAILABLE*/\n    address \"ISPEXEC\" \"SELECT PGM(ISRUDL) PARM(ISRUDLP)\"\n    ZDLDSNLV = OLDDSN\n    address \"ISPEXEC\" \"VPUT ZDLDSNLV PROFILE\"\n    EXIT 0\nend\nx = SYSDSN(\"'\"||line||\"'\")\nif x \\= \"OK\" then do\n   /* even though ISREDIT EDIT would work -- make this fail*/\n   ZEDSMSG = x\n   ZEDLMSG = \"SYSDSN('\"line\"') failed  --\" x\n   \"LINE_AFTER .ZCSR = NOTELINE \"\"SYSDSN('\"line\"') failed -- \" X\"\"\"\"\n   address \"ISPEXEC\"   \"SETMSG MSG(ISRZ001)\"\n   return 1\nend\nEDorBR = \"BROWSE\"\nI =pos(\"BROWSE\",token)\nif i \\= 0 then \"LABEL .zcsr = .BROWS 0\"\nIF i = 0 then Do\n     I =pos(\"EDIT\",token)\n     if i \\= 0 then EDorBR = \"EDIT\"\nend\nIF i \\= 0 THEN DO\n   Address \"ISPEXEC\" \"CONTROL ERRORS RETURN\"\n   address \"ISPEXEC\" EDorBR \"DATASET('\"line\"')\"\n   lastcc = rc\n   Address \"ISPEXEC\" \"CONTROL ERRORS CANCEL\"\n   if lastcc >= 12  then do\n       ZEDSMSG = zerrsm\n       ZEDLMSG = zerrmsg zerrlm \"RC=\"lastcc\n       address \"ISPEXEC\"   \"SETMSG MSG(ISRZ001)\"\n       \"LINE_AFTER .ZCSR = NOTELINE \"\"RC=\"lastcc zerrmsg zerrlm\"\"\"\"\n       IF lastcc = 20 then if EDorBR = \"EDIT\" then do\n       \"LINE_AFTER .ZCSR = NOTELINE \"\"EDIT failed will try BROWSE\"\"\"\n           address \"ISPEXEC\" BROWSE \"DATASET('\"line\"')\"\n           ZEDSMSG = zerrsm\n           ZEDLMSG = zerrmsg zerrlm \"RC=\"lastcc\n       end\n       return 1\n   end\n   ZEDSMSG = \"COMPLETED\"\n   ZEDLMSG = EDorBR \"completed via SYSDSN\" EDorBR \"for - \" line\n   address \"ISPEXEC\"   \"SETMSG MSG(ISRZ001)\"\n   \"CURSOR =\" ROW COL\nEND\nELSE DO\n   ZEDSMSG = x\n   ZEDLMSG = \"SYSDSN('\"line\"') --\" x\n   address \"ISPEXEC\"   \"SETMSG MSG(ISRZ001)\"\n   \"CURSOR =\" ROW COL\n   return 0\nEND\nreturn 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYSIN": {"ttr": 14604, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x08\\x00\\x08\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "MCRITCH"}, "text": "ISREDIT MACRO\nISREDIT FIND FIRST '//' 1 .ZCSR .ZCSR\nIF &LASTCC. NE 0 THEN ISREDIT FIND PREV 1 '//'\nISREDIT FIND       '//' 1 FIRST .ZCSR .ZCSR\nIF &LASTCC. EQ 0 THEN DO\n   ISREDIT LINE_AFTER .ZCSR = DATALINE \"//SYSIN    DD  *  (GENERATED DD FOR !EDC\n   ISREDIT FIND '(GENERA' NEXT\nEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TAGX": {"ttr": 14849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xa2\\x00\\xa2\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 162, "newlines": 162, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- converted to REXX on 1994/06/03 */\nADDRESS \"ISREDIT\"\n /*  TITLE:       TAGX     THE INCLUSIVE LINES BETWEEN TWO LABELS   */\n /*                                           *GENERALIZED TAGX    * */\n /*  USERS:       TSO ISPF EDIT USERS   | SCRIPT USERS              */\n /*  CONTRIBUTED: 1990/10/23 DAVID MCRITCHIE                        */\n /*                                                                 */\n /*  EXAMPLE:     TAGX     .ZFIRST .ZLAST NX                        */\n /*                                                                 */\n /*  OPTIONS:                                                       */\n /*      NX|X     DEFAULT IS NX                                     */\n /*        NX     PLACES %B% BEFORE NX LINE GROUPS AND %A% AFTER    */\n /*         X     PLACES %B% BEFORE  X LINE GROUPS AND %A% AFTER    */\n /*     <TAG1>    REPLACEMENT FOR DEFAULT %B%                       */\n /*     <TAG2>    REPLACEMENT FOR DEFAULT %A%                       */\n /*                                                                 */\n /*  REQUIREMENTS:                                                  */\n /*    NONE IN WHICH CASE WILL PROCESS ENTIRE MEMBER SAME AS IF     */\n /*        ===> %TAGX .ZF .ZL NX %B% %A%                            */\n \"MACRO (TOKENS)\"\n        I = 0\n        L = 0\n        /*********                                                  */\n        help=\"\"; debug=\"\"; s=\"\"; AT=\"\"; entire=\"\"; remain=\"\"\n        nx=\"\"; x=\"\"; tag1=\"\";tag2=\"\"; labf=\"\"; labl=\"\"\n        notvalid = \" ALL NEXT FIRST LAST PREV LEFT RIGHT \"\n    DO i = 1 to words(tokens)\n        TOKEN = word(tokens,i)\n        TOKEN = translate(TOKEN)\n        IF TOKEN = \"\" THEN  iterate i /* should not happen*/\n        IF pos(\" \"token\" \", notvalid) > 0 then do\n           zedsmsg = token \"invalid\"\n           zedlmsg = token \"not provided for, nor are\" novalid\n           call note \"PIR\" time(\"n\") zedlmsg\n           Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n           Exit 12\n        END\n        IF TOKEN = \"DEBUG\" then do; debug=\"DEBUG\"; iterate i; end\n        IF TOKEN = \"NX\" then do; NX=\"NX\"; iterate i; end\n        IF TOKEN = \"X\" then do; X=\"X\"; iterate i; end\n        IF TOKEN = \"ENTIRE\" then do; ENTIRE=\"ENTIRE\"; iterate i; end\n        IF SUBSTR(token,1) = \".\" THEN  DO\n           IF LABF = \"\" THEN  DO\n              LABF = TOKEN\n              iterate i\n           END\n           IF LABL = \"\" THEN  DO\n              LABL = TOKEN\n              iterate i\n           END\n          ZEDSMSG = \"LABEL\" TOKEN\n          ZEDLMSG = \"EXACTLY TWO LABELS ARE REQUIRED \",\n            \"FOUND\" LABF\", \"LABL\" AND  \"TOKEN\n          Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n          Exit 12\n        END\n        IF TOKEN = \")\" THEN  DO\n           ZEDSMSG = \"LOST PARENTHESIS\"\n           zedlmsg = \"\"\"blanks\"\"  separate all operands;\",\n              \"therefore invalid in from() to() col() begin()\"\n           Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n           Exit 12\n        END\n        IF TAG1  = \"\" THEN  DO\n           TAG1 = token\n           iterate i\n        END\n        IF TAG2  = \"\" THEN  DO\n           TAG2 = token\n           iterate i\n        END\n        REMAIN = REMAIN TOKEN\n    END i\n    IF REMAIN  \\= \"\" THEN  do\n           zedsmsg = remain \"invalid\"\n           zedlmsg = remain \"not provided for in TAGX macro\"\n           call note \"TAGX\" time(\"n\") zedlmsg\n           call note \" first two non control words are\",\n               \"accepted as TAGS --\" tag1 tag2\n           Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n           Exit 12\n    end\n   /******************************************************************/\n   /******************************************************************/\n    IF \"ENTIRE\" = ENTIRE THEN  DO     /*** LABELS ARE REQUIRED *****/\n       IF LABF = \"\" THEN  DO\n          LABF = \".ZFIRST\"\n          LABL = \".ZLAST\"\n       END\n       ELSE DO\n          ZEDSMSG = \"LABEL CONFLICT\"\n          ZEDLMSG = \"\"\"ENTIRE\"\" implies .ZFIRST .ZLAST \"\n              \"conflicts with\" LABF \"and\" LABL\n          Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n          Exit 12\n       END\n    END\n    IF LABF = \"\" THEN  DO\n          LABF = \".ZFIRST\"\n          LABL = \".ZLAST\"\n    END\n    IF LABL = \"\" THEN  DO\n          ZEDSMSG = \"MISSING\"  LABEL(S)\n          ZEDLMSG = ZEDSMSG \"-- A PAIR OF LABELS OR\",\n            \"\"\"ENTIRE\"\" IS REQUIRED\"\n          Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n          Exit 12\n    END\n    /************** END OF LABEL REQUIREMENTS *******************/\n    /******************** CODE FOR  TAGX     COMMANDS ************/\n    /******************** CODE FOR  TAGX     COMMANDS ************/\n    /******************** CODE FOR  TAGX     COMMANDS ************/\n    IF TAG1  = \"\" THEN  TAG1 = \"%B%\"\n    IF TAG2  = \"\" THEN  TAG2 = \"%A%\"\n    SITE = X||NX   /* could be one or the other */\n    IF SITE  = \"\" THEN  SITE = \"NX\"\n    IF \"NX\" = SITE THEN  OPPOSITE = \"X\"\n    ELSE OPPOSITE = \"NX\"\n    \"SEEK X P'=' 1 FIRST\" LABF   LABL\n    IF RC \\= 0 THEN call badx  /* this will exit*/\n    \"SEEK X P'=' 1 FIRST\" LABF LABL\n    IF rc \\= 0 then call badx  /* this will exit */\n    \"CURSOR = 1 0\"\n    call note time(\"n\") \"TAGX\" tokens\n    call note tag1 \"will be inserted before\" site,\n        \" line groups within range\"\n    call note tag2 \"will be inserted after\" site,\n       \"line groups within range\"\n LOOP:\n    \"SEEK NEXT 1 P'='\" SITE   LABF   LABL\n    IF RC \\= \"0\" THEN  call done  /* exit */\n    \"LINE_BEFORE .ZCSR = DATALINE (TAG1)\"\n    \"SEEK NEXT 1 P'='\" OPPOSITE   LABF   LABL\n    IF RC \\= \"0\" THEN  call done  /* exit */\n    \"LINE_BEFORE .ZCSR = DATALINE (TAG2)\"\n    signal LOOP\n DONE:\n  \"(VAR075) = XSTATUS\" LABL\n  IF VAR075 = SITE THEN  DO\n     \"(VAR037) = LINENUM\" LABL\n     VAR037 = VAR037  + 1\n     \"LINE_AFTER\" LABL \"= DATALINE (tag2)\"\n     IF Substr(LABL,1,2) \\= \".Z\" THEN\n         \"LABEL\" VAR037 \"=\" LABL \"0\"\n  END\n  exit 0\n\n  BADX:\n    ZEDSMSG = \"SETUP ERROR\"\n    ZEDLMSG = ZEDSMSG. -- REQUIRES BOTH X AND NX LINES\n    call noteMSG \"*ERROR**\" ZEDLMSG\n    call notemsg \"Read documentation in IS03.SHARE.TEXT(TAGX)\"\n    call notemsg \"  or enter  COMMAND ===> TSO CLIST TAGX HELP\"\n    Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n    Exit 12\n\nnote:  parse arg arg\n    \"LINE_BEFORE .ZFIRST = NOTELINE (arg)\"\n  return\nnoteMSG:  parse arg arg\n    \"LINE_BEFORE .ZFIRST = MSGLINE (arg)\"\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TEAR": {"ttr": 14853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xb1\\x00\\xb1\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 177, "newlines": 177, "modlines": 0, "user": "MCRITCH"}, "text": "/* REXX -- Aid removal of MODIFY=TEAR in favor of OUTPUT statements*/\n/* David McRitchie, \"The REXX Macros Toolbox\", Nov. 14, 1991*/\n/*Do forever*/\nAddress \"ISREDIT\"\n\"MACRO (TOKEN)\"\nCAPS='ON'\n\"(CAPS)=CAPS\"  /*will restore at exit*/\n\"caps off\"  /*for msglines*/\ntoken=translate(token) /*capitals*/\nnull=; /*easier to read later*/\ntearcnt=0;copycnt=0\n\"reset SPE\"\nMSGBC=\"LINE_BEFORE .zcsr = msgline \"\nMSGB1=\"LINE_BEFORE 1 = msgline \"\n\"(VAR014A) = DATA_CHANGED\"\nIf VAR014A = \"YES\" then STRTWITH=\"S\";else STRTWITH=\"\"\n\"x 1 p'=' all\";\"f '//' 1 all\";\"x '//\"||\"*' 1 all\"\n\"find first nx ' EXEC '\"\n\"LABEL .zcsr = .top 0\"\n\"SEEK all 'COPIES=' NX\"\n\"(XX,COPYCNT)= SEEK_COUNTS\"\n\"x 1 p'=' all\";\"f 1 '//' all\"\n\"X all 1 '//\"||\"*'\"; \"find all word 'MODIFY=TEAR' nx\"\n\"(XX,TEARCNT)= FIND_COUNTS\"\ntearcnt=tearcnt+0;copycnt=copycnt+0;\nIf tearcnt <> copycnt then\n   \"line_before .zf = msgline \"\"MODIFY=TEAR appears on\",\n   tearcnt \" line(s), while COPIES= appears on\" copycnt||\"\"\"\"\nif TEARCNTS = 0 then do\n   \"find 'MODIFY=' all\"\n   \"find 'COPIES=' all\"\n   \"find ' OUTPUT ' all\"\n   \"find 'OUTPUT=' all\"\n   msgb1 \"'MODIFY=TEAR not found'\"\n   msgb1 \"' There may be COPIES= internal to PROCs'\"\n   return(1)\nend\n/********** find modify=tear and/or copies= on output statements***/\n\"x ' ' all .zf .top\";\"f '//' 1 all .zf .top\";\n\"x '//\"||\"*' 1 all .zf .top\"\n\"find word  'OUTPUT' 5 23 .zf .top all nx\"\n\"x all '//\"||\"*' 1 .zf .top\"\n\"nxnx after(1) .zf .top\"\n\"seek 'MODIFY=TEAR' all   nx .zf .top\"\n\"(XX,OUT1CNT)= SEEK_COUNTS\"\nif OUT1CNT > 0 then \"LINE_BEFORE .zf  = MSGLINE \"\"     \",\n   \"Warning \" out1cnt \"OUTPUT statment(s) contains MODIFY=TEAR\"\"\"\n\"seek all    'COPIES=' nx .zf .top\"\n\"(XX,OUT2CNT)= SEEK_COUNTS\"\nif OUT2CNT > 0 then \"LINE_BEFORE .zf  = MSGLINE \"\"     \",\n   \"Warning \" out2cnt \"OUTPUT statment(s) contains COPIES=\"\"\"\n/**************************************************/\n\"x ' ' all\";\"f '//' 1 all .top .zl\";\"x '//\"||\"*' 1 all\"\n\"x all 5 22 ' OUTPUT ' \"\nhighest = 0\nDO COPIES = 1 TO 255 /* ACTUAL MAXIMUM IN JCL IS 128*/\n      \"FIND   FIRST NX WORD 'COPIES=\"||COPIES||\"' \"\n      If rc = 0 then highest = copies\nend\n/************************************************/\n/* MAY WANT TO CHECK FOR MAX OF 10 COPIES HERE  */\nif highest > 30  then do\n   \"LINE_BEFORE .zf = MSGLINE \"\"Converion of COPIES=\",\n      ||highest||\", to OUTPUT=  subparameters\"\"\"\n   \"LINE_BEFORE .zf = MSGLINE \"\"  will exceed !EDCHEK\",\n      \"limit of 30 (actual JCL limit is 128)\"\nend\nelse if highest > 8  then do\n   \"LINE_BEFORE .zf  = MSGLINE \"\"COPIES=\"||,\n        highest \"-- messy warning above 8\"\"\"\nend\n/************************************************/\nif highest < 2 then do\n   /* use of modify=tear and copies irrelevant */\n   \"F FIRST 'COPIES=' NX\"\n   IF RC <> 0 THEN DO\n     \"F FIRST MODIFY=TEAR NX\"\n     IF RC <> 0 THEN DO\n       VAR014A = ''\n       \"(VAR014A) = DATA_CHANGED\"\n       IF VAR014A <> \"YES\" THEN DO\n         i = index(TOKEN,\"NOLEAVE\")\n         if i = 0 then \"CANCEL\"\n         RETURN(1)\n       end\n    END\n  END\n  \"LINE_AFTER .ZF = MSGLINE \"\"- USE OF MODIFY=TEAR\",\n       \"AND/OR COPIES= MAX OF \"HIGHEST\" IRRELEVANT\"\"\"\n   \"x ' ' all\"\n   call WRAPUP\n   return(1)\nend\n/************************************************/\n\"x ' ' all\";\"f '//' 1 all\";\"x '//\"||\"*' 1 all\"\nCOPIESX=(400)' ';\nCHR=(400)' ';\nDo COPIES = 1 to highest\n   rcx=0\n   fndx=0\n   MAX5=0\n   Find first ' '\n   Do LN89 = 1 to 200 while rcx=0\n      \"FIND   FIRST  NX 'COPIES=\"||COPIES||\"' WORD\"\n      rcx = rc\n      if rcx = 0 then do\n         CALL NOTECSR\n         \"CHANGE FIRST .ZCSR .ZCSR NX ',COPIES=\"||COPIES||\"'   ''\"\n         \"CHANGE FIRST .ZCSR .ZCSR NX WORD 'COPIES=\"||COPIES||\"'   ''\"\n         ADDCOMMA = \" \"\n         \"FIND FIRST .ZCSR .ZCSR ', '\"\n         IF RC = 0 THEN ADDCOMMA = \", \"\n         ELSE DO;\n            \"change first  17 72 '  ' ', ' .zcsr .zcsr\"\n            \"seek first ' ,' .zcsr .zcsr\"\n            if rc = 0 then \"LINE_AFTER .zcsr = MSGLINE \",\n               \"\"\"---- comma INCORRECTLY added above,\" ,\n                \"or parameters must be merged  ----\"\"\"\n            else \"LINE_AFTER .zcsr = NOTELINE \",\n                  \"'---- comma added above ----'\"\n         end\n         \"LINE_AFTER .zcsr = '//\"||\"*****junk'\"\n         \"(BEFORE) = linenum .zcsr\"\n         before = before + 1\n         \"LABEL\" before \"= .BEF\"\n         subcnt = 1;COPIESX='';prefix='OUTPUT=('\n         do II = 1 to copies\n            IF subcnt > 5 then do\n              \"LINE_BEFORE .BEF = DATALINE \"\"//             \" ,\n                  ||PREFIX||SUBSTR(COPIESX,2)||\",\"\"\"\n              subcnt = 0;prefix = '';COPIESX='';\n            end\n            subcnt = subcnt + 1\n            COPIESX=COPIESX||',*.COPY'||II\n         end\n         \"LINE_BEFORE .BEF = DATALINE \"\"//             \" ,\n             ||PREFIX||SUBSTR(COPIESX,2)||')'||ADDCOMMA||\"\"\"\"\n         \"DEL .BEF .BEF all\"\n      END\n      \"Change all nx .zcsr .zcsr 'MODIFY=TEAR,'   ''\"\n      \"Change all nx .zcsr .zcsr ',MODIFY=TEAR'   ''\"\n   end\nEnd\nDo copies = 1 to highest;if copies < 10 then dum=' ';else dum=''\n   \"LINE_BEFORE .top = dataline \"\"//COPY\"||COPIES||DUM,\n           ||\"   OUTPUT GROUPID=COPY\"||COPIES||\"\"\"\"\nEnd\nCall WRAPUP\nReturn(1)   /***** end of execute ***********/\n\nNOTECSR: procedure;\n   \"(ORIG) = LINE .zcsr\"\n   \"LINE_AFTER .zcsr = NOTELINE (ORIG)\"\nReturn\nWRAPUP:  procedure expose STRTWITH\n  \"find 'MODIFY=' all\"\n  \"find 'COPIES=' all\"\n  \"find ' OUTPUT ' all\"\n  \"find 'OUTPUT=' all\"\n  \"find 'MODIFY=' all\"\n  \"FIND FIRST ' '\"\n   \"(VAR014A) = DATA_CHANGED\"\n   If VAR014A = \"YES\" then Do\n     \"LINE_AFTER 0 = MSGLINE \",\n      \"\"\"=================== DATA-CHANGED=CHG \",\n        ||\"============================\"||  STRTWITH||\"\"\"\"\n     ZEDSMSG = \"data changed\"\n     ZEDLMSG = \"data changed -- save or cancel\"\n     Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   end\n   if highest > 8  then do\n      \"LINE_BEFORE .top = NOTELINE \"\"COPIES=\"||,\n           highest \"-- messy warning above 8\"\"\"\n   end\n   \"CAPS ON\"  /* WORKING WITH JCL SO CAPS EVEN IF NOT REALLY*/\n   \"LOC 0\"    /* UP MAX -- NOT ALLOWED IN AN INITIAL MACRO */\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TECHPS": {"ttr": 14857, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x01\\xff\\x01\\xff\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 511, "newlines": 511, "modlines": 0, "user": "MCRITCH"}, "text": "/*TECHPS    Author: David McRitchie        (written  in REXX)        */\n/*                 \"The REXX Macros Toolbox\"                           */\n/*          Created 1994/02/16 for PostScript (from PU00L 1993/10/15 */\n/*-------------------------------------------------------------------*/\n/*       Macro: TECHPS                                               */\n/*       Purpose: Print content of member in EDIT to PU2ZD in SysTech*/\n/*                prints nice two-sided copies on LaserJet IV   MX   */\n/*-------------------------------------------------------------------*/\n/* Related clists: PU00L, TECHPS, @PRINTNX, SCRIPTPS,  @SCRIPT ....  */\n/*********************************************************************/\n/***************  TECHPS options *************************************/\n/*  Options -- plus anything valid for SCRIPTPS macro                */\n/*     BROWSE          -- Browse input file to SCRIPT command        */\n/*     CHARS(xxx)      -- override calculated default                */\n/*     CLASS(class)    -- override CLASS(G) default                  */\n/*     COPIES(copies)  -- override default of 1                      */\n/*     DEST(dest) or GO TECHPS PU                                    */\n/*     NOLABEL         -- do not show labels, only meaningful if NX  */\n/*     NX              -- include only NX lines, also                */\n/*                         show labels unless NOLABEL option invoked */\n/*     STOP            -- testing, BROWSE script input, stop, noprint*/\n/*\n    Font       in.  GT24 GT20  GT18 GT15 GT12 GT10\"\n    Portrait   7.6   182  152   136  114   91   76\"\n               7.5              129                corrected PSA90\n    Landscape 10.1   242  202   181  151  121  101\"\n *********************************************************************/\n    address \"ISREDIT\";\"MACRO (TOKEN)\"\n    terminate = 0\n    dev=\"PSA\"\n    otoken=token\n    address \"ISPEXEC\" \"CONTROL ERRORS RETURN\"\n    zedsmsg = \"**\";zedlmsg=\"**\"\n    token = \" \"translate(token)\" \"\n    \"(rowx,colx) = cursor\"\n    qcnt = 0\n    addon = 0\n    q.=\"\"\n    font=\"\";chars=\"\";pagex=\"\"\n    parse var token left \"CHARS(\" chars \")\" right\n    if CHARS \\= \"\" then token =  left right\n    i = pos(' NOLABEL ',token)\n    if i=0 then nolabel=0; else do; nolabel=1;\n         token = substr(token,1, i)||substr(token,i+9); end;\n    parse var token left \" CLASS(\" class \") \" right\n    if class = \"\" then class=G   /* for PostScript*/\n    else token = \" \"left right\" \"\n    parse var token left \"COPIES(\" copies \")\" right\n    if copies = \"\" then copies=\"1\"; else token = left right\n    parse var token left \" PAGE(\" pagex  \")\" right\n    if pagex  \\= \"\" then do;pagex=\" Page(\"pagex\")\"; token = left right;end;\n    i = pos(' STOP ',token)\n    if i=0 then STOP=0; else do; STOP=1;\n         token = substr(token,1, i)||substr(token,i+6); end;\n    i = pos(\" NX \", token)\n    if i \\= 0 then do; NXOPT=\"NX\";\n      token = substr(token,1,i)||substr(token,i+4)\n    end; else NXOPT=\"\"\n    if NXOPT = \"NX\" then if NOLABEL = 0  then do\n       \"LOC FIRST LABEL\"\n       if rc \\= 0 then NOLABEL = 1\n    end\n    Address \"ISREDIT\" \"(CHG) = DATA_CHANGED\"\n    if CHG = \"YES\" then if NXOPT = \"\" then do\n         zedsmsg = \"Not Saved/Not Printed\"\n         ZEDLMSG = \"Data has not been saved, Save then reissue TECHPS\"\n         call msg0\n         call note zedlmsg\n         call note \"  or invoke with NX option ===> TECHPS NX\"\n         exit 1;\n    end\nParse var token left \" DEV(\" DEV \")\" right\nIf dev /= '' then token = left right;\n/* some special devices not checking for redundancy */\nI = index(token,\" L \"); If I /=0 then\n   do;DEV = \"PSA90\";token = substr(token,1,I)substr(token,I+3);end\nI = index(token,\" ACROSS \"); If I /=0 then\n   do;DEV = \"PSA90\";token = substr(token,1,I)substr(token,I+8);end\nI = index(token,\" LEGAL \"); If I/=0 then   /* change paper size*/\n   do; dev=\"PSL\"; token = substr(token,1,I)substr(token,I+7); end\nIf DEV = '' then DEV = \"PSA\"\nParse var token left \" DEST(\" dest \")\" right;token = left right\nIf dest = \"\" then do    /* this portion matches  clist SCRIPTPS */\n   I = index(token,\" GO \")\n   If I /= 0 then do;dest = \"P15NF\";  /* used to be P15NF, PROG1A3A */\n      token =substr(token,1,I)substr(token,I+4); end;\n   I = index(token,\" TECHPS \")\n   If I /= 0 then do;dest = \"PU2ZD\";  /* used to use TCPPRTST */\n      token =substr(token,1,I)substr(token,I+8); end;\n   I = index(token,\" PU \")\n   If I /= 0 then do;dest = \"PU2ZD\";  /* used to use TCPPRTST */\n      token =substr(token,1,I)substr(token,I+4); end;\n      /*  SYSx.VPS.CNTL for prod,   SYSx.VPS.R61.CNTL for test       */\n      /*        | member    =G         =A   |  =G         =A         */\n      /*        | dual      dest=    dest=  | single G    single A   */\n      /* TCP    |  no dual avail for TCP    | TCPPRTST    TCPPRTS1   */\n      /*        |                           | ======== or ========   */\n      /* VTAM   | PU2ZDALL PU2ZD    PU2ZD   |                        */\n      /*        | ======== <--active        |                        */\nend\nif dest='' then dest=\"PU2ZD\"  /* default for TECHPS will be used*/\n\n    SCALE =,\n      \"1...5...10...15...20...25...30...35...40...45...50...55...60\"||,\n      \"...65...70...75...80...85...90...95..100..105..110..115..120\"||,\n      \"..125..130..135..140..145..150..155..160..165..170..175..180\"||,\n      \"..185..190..195..200..205..210..215..220..225\"\n    addon = 0\n    if NXOPT = \"NX\" then do;\n      if nolabel=0 then addon = 15; else addon=7\n      scale = left(\" \",addon)scale;\n    end\n    else do;\n      addon = 0 /* even if label unless NX won't show*/\n      scale = left(\" \",addon)scale;\n    end;\n    \"(var016) = data_width\"\n    data_width = dwchk()\n    font = chars\n    /* attempt to reduce apparent data_width */\n    a1=data_width\n    a2=a1 + addon\n    if dev \\= \"PSA90\" then do\n       if      a2 > 152 then do; font = gt24; mpl=182; end;\n       else if a2 > 129 then do; font = gt20; mpl=152; end;\n       else if a2 > 114 then do; font = \"GT18\"; mpl=129; end;\n       else if a2 >  91 then do; font = \"GT15\"; mpl=114; end;\n       else if a2 >  76 then do; font = \"GT12\"; mpl=91; end;\n       else do; font = \"GT10\"; mpl=76; end;\n    end\n    else do;\n       if      a2 > 202 then do; font = gt24; mpl=242; end;\n       else if a2 > 181 then do; font = gt20; mpl=202; end;\n       else if a2 > 151 then do; font = \"GT18\"; mpl=181; end;\n       else if a2 > 121 then do; font = \"GT15\"; mpl=151; end;\n       else if a2 > 101 then do; font = \"GT12\"; mpl=121; end;\n       else do; font = \"GT10\"; mpl=101; end;\n    end\n    if chars \\= \"\" then font = chars\n    qcnt=qcnt+1;q.qcnt = \".* \" data_width\" chars in longest line,\",\n      || \" treated as\" a2 \"with addon of\" addon\n    qcnt=qcnt+1;q.qcnt = \".* font=\"font\" accomodates\" mpl\" chars/line\",\n         \", override=\"chars\n    qcnt=qcnt+1;q.qcnt=\".* Font  in.  GT24 GT20  GT18 GT15 GT12 GT10\"\n    qcnt=qcnt+1;q.qcnt=\".* Port  7.6   182  152   136  114   91   76\"\n    qcnt=qcnt+1;q.qcnt=\".* Land 10.1   242  202   181  151  121  101\"\n    notex = A1||\"(+\"addon||\") line lengths accomodated up to\",\n        mpl \"bytes by\" font \"dev(\"dev\")\"\n    call info(notex)\n    scale = substr(scale,1,data_width)\n    if token \\= \"\" then do\n           ZEDSMSG = \"Bad Parm\"\n           ZEDLMSG = 'Unknow options \"'token'\"'\n           ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n           exit 4\n    end\n    scale = substr(scale,1,data_width)\n\n    address \"ISREDIT\"\n    \"(say1,say2) = cursor\"\n    \"CURSOR =\" rowx colx\n    ZEDSMSG =\n    ZEDLMSG = \"** Process into Q. ---------- **\"\n    ADDRESS \"ISPEXEC\" \"CONTROL DISPLAY LOCK\"\n    call msg0\n\n    ADDRESS \"ISREDIT\" \"(DSN) = DATASET\"\n    ADDRESS \"ISREDIT\" \"(MEMBER) = MEMBER\"\n    SYSUID = SYSVAR(\"SYSUID\")\n    userid = SYSVAR(\"SYSUID\")\n    inputdsn = \"'\"sysuid\".SPELL.MACRO.TEXT'\"\n    if member = '' then dsname=\"'\"dsn\"'\"\n    else dsname =\"'\"dsn\"(\"strip(member)\")'\"\n    s9999 = \"'\"sysuid\".s9999ps.list'\"\n    PROFILE = \"DSMPROF4\"       /*DEFAULT*/\n    /* TSO dataset conventions for use w/o quotes */\n    /* Allocate DCF input dataset -- allow up to 200 bytes/rec*/\n    ADDRESS \"TSO\"\n    status = msg(\"off\")\n    \"free fi(ESPELL)\";\"free da(\"inputdsn\")\"\n    \"free da(\"s9999\")\"\n    if sysdsn(inputdsn) = \"OK\" then \"del\" inputdsn\n    if sysdsn(s9999)    = \"OK\" then \"del\" s9999\n    status = msg(\"on\")\n    \"ALLOC FI(ESPELL) NEW CAT SPACE(45 45) TRACKS UNIT(SYSDA)\" ,\n      \"LRECL(255) RECFM(V B M) BLKSIZE(3156)\" ,\n      \"DSN(\"inputdsn\") REUSE\"\n    /*  DCB attributes to the contrary will be reset by DCF */\n\n    /* Open file and SAY some SCRIPT commands to be sure */\n    /* data is formatted properly for parsing (later).     */\n\n    qcnt=qcnt+1; q.qcnt =\".pm .8i\"\n    qcnt=qcnt+1; q.qcnt =\".rh on\"\n    qcnt=qcnt+1;\n    if dev = \"PSA90\" then q.qcnt=\".ll 8.5i\"; else q.qcnt=\".ll 6i\"\n    qcnt=qcnt+1; q.qcnt =\".bf @smalls =\"\n    qcnt=qcnt+1; q.qcnt =\".dc ps \u00a2\"\n/*********************************************************************/\n/*     qcnt=qcnt+1; q.qcnt =\".se TODAY  '&DAY(&SYSDAYOFW.).,\",     *'*/\n/*          \"&MONTH(&SYSMONTH.). &SYSDAYOFM., 19&SYSYEAR.'\"        *'*/\n/*********************************************************************/\n    qcnt=qcnt+1; q.qcnt =\".ri on\"\n    qcnt=qcnt+1; q.qcnt =\"<Printed via TECHPS>  &$CONT.\"\n    qcnt=qcnt+1; q.qcnt =\".bf fontp2 =\"\n    qcnt=qcnt+1; q.qcnt =\".bf hi2  =\"\n    parse var dsname \"'\"dsnamex\"'\"\n    qcnt=qcnt+1; q.qcnt =dsnamex\n    qcnt=qcnt+1; q.qcnt =\".pf \"\n    qcnt=qcnt+1; q.qcnt =\".pf\"\n    qcnt=qcnt+1; q.qcnt =\".ct   \"font \" on &DAY(&SYSDAYOFW.)\",\n          date(\"o\") \"at\" time(\"n\")\" for\" userid\n    qcnt=qcnt+1; q.qcnt =\".ri off\"\n    saveq = q.qcnt\n    qcnt=qcnt+1; q.qcnt =\".pf\"\n    qcnt=qcnt+1; q.qcnt =\".sp 1\"\n    qcnt=qcnt+1; q.qcnt =\".rh off\"\n    qcnt=qcnt+1; q.qcnt = \".rf odd  \"\n    qcnt=qcnt+1; q.qcnt = \".pm .8i\"\n    qcnt=qcnt+1;\n    if dev = \"PSA90\" then q.qcnt=\".ll 9.7i\"; else q.qcnt=\".ll 7.2i\"\n    qcnt=qcnt+1; q.qcnt = \".sv off  \"\n    qcnt=qcnt+1; q.qcnt = \".fo right\"\n    qcnt=qcnt+1; q.qcnt = \".sp 2    \"\n    qcnt=qcnt+1; q.qcnt = \" &$PS    \"\n    qcnt=qcnt+1; q.qcnt = \".rf off  \"\n    qcnt=qcnt+1; q.qcnt = \".rf even \"\n    qcnt=qcnt+1; q.qcnt =\".pm .8i\"\n    qcnt=qcnt+1; q.qcnt = \".sv off  \"\n    qcnt=qcnt+1; q.qcnt = \".fo left \"\n    qcnt=qcnt+1; q.qcnt = \".sp 2    \"\n    qcnt=qcnt+1; q.qcnt = \" &$PS.   \"\n    qcnt=qcnt+1; q.qcnt = \".rf off  \"\n    qcnt=qcnt+1; q.qcnt =\".sv off\"\n    qcnt=qcnt+1;\n    if dev = \"PSA90\" then q.qcnt=\".ll 10.1i\"; else q.qcnt=\".ll 7.6i\"\n    qcnt=qcnt+1; q.qcnt =\".if 1403 = &$PDEV. .llmax\"\n    call dirinfo; /* directory info extracted from @PRINTNX */\n    qcnt=qcnt+1; q.qcnt =\".dd file dsn \"dsname\n    qcnt=qcnt+1; q.qcnt =\".bf\" font \"GT15 =\"\n    qcnt=qcnt+1; q.qcnt =\".fo off fold\"\n    /******* bring in file currently in edit *********************/\n    /*******   .imfile is a special DCF macro for this purpose   */\n    if NXOPT = \"\" then do; qcnt=qcnt+1; q.qcnt =\".imfile file\";end;\n    else call modified_input    /* or use alternative for unsaved*/\n    /*************************************************************/\n    qcnt=qcnt+1; q.qcnt =\".pf\"\n    qcnt=qcnt+1; q.qcnt =\".sk 1\"\n    qcnt=qcnt+1;\n    if dev = \"PSA90\" then q.qcnt=\".ll 8.5i\"; else q.qcnt=\".ll 6.0i\"\n    qcnt=qcnt+1; q.qcnt =\".hr left right\" /* instead of  .$PARM */\n    qcnt=qcnt+1;\n    if dev = \"PSA90\" then q.qcnt=\".ll 10.1i\"; else q.qcnt=\".ll 7.6i\"\n    qcnt=qcnt+1; q.qcnt =\".bf\" font \"GT15 =\"\n    qcnt=qcnt+1; q.qcnt =scale\n    qcnt=qcnt+1; q.qcnt = \".if &$PASS = &$PSNO. .$FONT TY\"\n    qcnt=qcnt+1; q.qcnt =\".pf\"\n    qcnt=qcnt+1;\n    if dev = \"PSA90\" then q.qcnt=\".ll 8.5i\"; else q.qcnt=\".ll 6.0i\"\n    qcnt=qcnt+1; q.qcnt =\".bf\" font \"GT15 =\"\n    qcnt=qcnt+1; q.qcnt =\".se face '&$TYPESIZE. &$TYPEFACE.'\"\n    if pos(\"BROWSE\",token) \\= 0 then do\n      qcnt=qcnt+1; q.qcnt =\".$font ty\"\n    end\n    qcnt=qcnt+1; q.qcnt =\".pf\"\n    qcnt=qcnt+1; q.qcnt =\".bf @smalls =\"\n    qcnt=qcnt+1; q.qcnt =saveq \" with\" font \"(&face.)\"\n    qcnt=qcnt+1; q.qcnt =\".pf\"\n    qcnt=qcnt+1; q.qcnt =\".if &$LST = 1 .sk 0\"\n    qcnt=qcnt+1; q.qcnt =\".se *lcdv1 = '&$PN with &$LC.\"\n    qcnt=qcnt+1; q.qcnt =\".se *lcdv2 = '&*lcdv1. lines remaining\"\n    qcnt=qcnt+1; q.qcnt =\".se *lcdv  = '&*lcdv2. (&DV'&$LC.dv/&DV'1\"\n    qcnt=qcnt+1; q.qcnt =\".if &$PASS. = &$PSNO.\"\n    qcnt=qcnt+1; q.qcnt =\".th .ty LASTPAGE is &*lcdv.dv)\"\n    qcnt=qcnt+1; q.qcnt =\".rh on\"\n    qcnt=qcnt+1; q.qcnt =\".sp 5i\"\n    qcnt=qcnt+1; q.qcnt =\".ce (Last Page left intentionally Blank)\"\n    qcnt=qcnt+1; q.qcnt =\".rh off\"\n    qcnt=qcnt+1; q.qcnt =\".cp\"\n    qcnt=qcnt+1; q.qcnt =\".if &SYSVARD = yes\"\n    qcnt=qcnt+1; q.qcnt =\".an SYSPAGE = EVEN\"\n    qcnt=qcnt+1; q.qcnt =\".th .pa odd\"\n    qcnt=qcnt+1; q.qcnt =\".th .rh sup\"\n    qcnt=qcnt+1; q.qcnt =\".th .rf sup\"\n\n    Address \"TSO\" \"EXECIO * DISKW ESPELL (STEM Q. FINIS\"\n    /* Invoke SCRIPT/VS */\n    if stop = 1 then do\n       address \"TSO\" \"$BROWSE\" inputdsn\n       Say \"SCRIPT command if issued would have looked like...\"\n       say        \"SCRIPT\" inputdsn,\n        \" PRO('SCRIPT.R40.MACLIB(DSMPROF4)') LIB('SCRIPT.R40.MACLIB')\",\n        \" FO('SCRIPT.R40.FONTPS') index DEV(\"dev\")\",\n        \" CHARS(PSFHV) FP(2)SYS(X NO H NO D YES ) M(ID)\",\n        \" FILE(\"s9999\")\"pagex\n       exit\n    end\n    address \"ISPEXEC\" \"CONTROL ERRORS EXIT\"\n    Address \"TSO\" \"SCRIPT\" inputdsn,\n        \" PRO('SCRIPT.R40.MACLIB(DSMPROF4)') LIB('SCRIPT.R40.MACLIB')\",\n        \" FO('SCRIPT.R40.FONTPS') index DEV(\"dev\")\",\n        \" CHARS(PSFHV) FP(2)SYS(X NO H NO D YES ) M(ID)\",\n        \" FILE(\"s9999\")\"pagex\n    SCRIPT_RC = RC\n    status = msg(\"off\")\n    address \"TSO\" \"FREE DA(\"s9999\")\"\n    terminate = terminate + 1\n    if terminate \\= 1 then exit 16\n    status = msg(\"on\")\n    i = pos(\"BROWSE\",token)\n    if i \\= 0 then do;  /* debugging check files created*/\n            SAY \"SCRIPT return code rc=\"script_rc  \"CLASS=\"class,\n               \"font\" font \"scale=\" length(scale),\n               \"one of longer lines\" say1 say2\n            address \"TSO\" \"$BROWSE\" dsname\n            address \"TSO\" \"$EDIT\"   inputdsn\n            address \"TSO\" \"$BROWSE\" s9999;\n            Address \"ISREDIT\" \"MEND\"\n            say zerrmsg zedsmsg zedlmsg zcmd\n            exit 1;\n            SAY \"THIS STATEMENT SHOULD NEVER APPEAR\"\n    end;\n    ZEDSMSG =\"\"\n    ZEDLMSG = \"** Completed----------------- ** -- FINAL PHASE\"\n    ADDRESS \"ISPEXEC\" \"CONTROL DISPLAY LOCK\"\n    call msg0\n\n    status = msg(\"off\")\n    Address \"TSO\"\n   \"FREE FI(ESPELL) DELETE\"\n   \"FREE OUTDES(NAME1) FI(SYSUT1 SYSUT2 SYSPRINT)\"\n    status = msg(\"on\")\n    OUTDES = \"CLASS(\"class\") DEST(\"dest\")\",\n        \"FORMDEF(A10111) LINECT(0) GROUPID(TECHPS)\"\n   \"OUTDES NAME1\" OUTDES\n  /* class = A*/\n   \"ALLOC FI(SYSPRINT) DUMMY                 \"\n   \"ALLOC FI(SYSUT1) DA(\"s9999\") SHR\"\n   \"ALLOC FI(SYSUT2) SYSOUT(\"class\") OUTDES(NAME1) COPIES(\"copies\")\"\n   \"ALLOC FI(SYSIN) DUMMY REUSE              \"\n   \"CALL 'SYS1.LINKLIB(IEBGENER)'            \"\n   if rc = 0 then\n   ZEDSMSG = \"Printed\"\n   ZEDLMSG = time(\"n\"),\n      \"TECHPS -Document has been Printed to CLASS(\"class\")\" font,\n      \"DEST(\"dest\") copies(\"copies\")\"\n   call note zedlmsg\n   if NXOPT = \"\" then call note \" Option NX would include\",\n      \"sequence numbers and labels on printed listing\"\n   call msg0\n   address \"ISREDIT\" \"UP MAX\"\n   \"FREE FI(SYSUT1 SYSUT2) OUTDES(NAME1)     \"\n   \"ALLOC FI(SYSIN) DA(*) REUSE              \"\n   \"ALLOC FI(SYSPRINT) DA(*) REUSE           \"\n   Address \"ISREDIT\" \"MEND\"\n   exit 1;\n   say \"This statement--should never print\"\n dirinfo:\n /******** extracted from @PRINTNX *******************/\n  address \"ISREDIT\"\n  \" (VAR018) = DATAID\"\n  \" (VAR018A) = DATASET\"\n  \" (VAR043) = MEMBER\"\n  \" (DSNX)          = DATASET\"\n  \" (NUMX)          = NUMBER\"\n  x = LISTDSI(\"'\"DSNX\"'\") \"DIRECTORY\"\n  LMSG = \"DCB=(RECFM=\"SYSRECFM\",LRECL=\"SYSLRECL\",BLKSIZE=\"SYSBLKSIZE,\n        ||\",DSORG=\"SYSDSORG\")  NUMBER \"NUMX\n  IF VAR043 = \"\" THEN DO\n          xyz=\"\"  /* statistics not avail. for sequential file */\n          signal nostats;\n  END\n  Address \"ISPEXEC\" \"LMINIT DATAID(DDVAR) DATASET('\"VAR018A\"') ENQ(SHR)\"\n  if rc \\= 0 then say \"LMINIT RC=\"RC\n  Address \"ISPEXEC\" \"LMOPEN DATAID(\"ddvar\") OPTION(INPUT)\"\n  if rc \\= 0 then  say \"LMOPEN RC=\"RC\n  Address \"ISPEXEC\" \"LMMFIND DATAID(\"ddvar\") MEMBER(\"VAR043\")\",\n     \"STATS(YES)\"\n  if rc \\=0 then say \"LMFIND RC=\"RC\n  LRC = RC\n  IF LRC = 8 THEN  NOTFOUND = 1\n  ZEDLMSG = lmsg; call msg0\n  VAR043 = SUBSTR(VAR043,1,8)\n  /************************************************************/\n   XYZ = VAR043 ZLVERS\".\"ZLMOD ZLCDATE ZLMDATE\n   XYZ = XYZ ZLMTIME ZLCNORC ZLINORC ZLMNORC\n   XYZ = XYZ LEFT(ZLUSER,8)\n  nostats:\n   \" (VAR037) = LINENUM .ZLAST\"\n   IF ZLCNORC =\"\" THEN XYZ = VAR043,\n     \"                                  \"VAR037\"   *NO \",\n     \"STATISTICS*   \"\n   IF NOTFOUND = \"\" THEN XYZ = VAR043  ,\n       \"<<--------------- no prior statistics exist ---------->>\"\n   \"(VAR014A) = DATA_CHANGED\"\n   if VAR014A = \"NO\" then do\n      changed = \"-- Data Unchanged\"\n   end\n   else do\n      changed = \"-- Data Changed\"\n   end\n   IF VAR014A = \"YES\" THEN\n      \" LINE_AFTER 0 = NOTELINE \"\"=== TECHPS\" otoken \"-- issued \"||,\n         \"(\"date('j')\")\" date('o') time('n') \"Data has been changed \"||,\n                                    \"===========\"\"\"\n ELSE\n      \" LINE_AFTER 0 = NOTELINE \"\"=== TECHPS\" otoken \"-- issued \"||,\n         \"(\"date('j')\")\" date('o') time('n') \"======================\"||,\n                                    \"===========\"\"\"\n   if xyz \\= \"\" then do\n   \" LINE_AFTER 0 = NOTELINE \"\"=== \"XYZ\" ==\"\"\"\n   \" LINE_AFTER 0 = NOTELINE \"\"=== MEMBER-- VV.MM CREATED- \",\n     \"---MODIFIED---  CURR  INIT   MOD LASTUSER ==\"\"\"\n   end\n\n   /* ------------------------------*/\n\n       qcnt=qcnt+1; q.qcnt= \".sk 1\"\n       qcnt=qcnt+1; q.qcnt= \".kp on\"\n       qcnt=qcnt+1; q.qcnt= \".bf gt20 GT15 =\"\n       qcnt=qcnt+1; q.qcnt= \".bx 0 6i\"\n       qcnt=qcnt+1; q.qcnt= \".in 2 \"\n       qcnt=qcnt+1; q.qcnt= \".ir 2\"\n        if xyz \\= \"\" then do\n          qcnt=qcnt+1; q.qcnt= \" MEMBER-- VV.MM \"||,\n           \"CREATED- ---MODIFIED---  CURR  INIT   MOD LASTUSER\"\n          qcnt=qcnt+1; q.qcnt= \" \"XYZ\n          qcnt=qcnt+1; q.qcnt= \".bx\"\n       end\n       qcnt=qcnt+1; q.qcnt= \" DSN=\"||left(SYSDSNAME,44),\n          \"Created\" SYSCREATE\n       qcnt=qcnt+1; q.qcnt= \" \"LMSG\n       qcnt=qcnt+1; q.qcnt= \".bx off\"\n       qcnt=qcnt+1; q.qcnt= \".kp off\"\n       qcnt=qcnt+1; q.qcnt= \".sk 1\"\n   /* ------------------------------*/\n /*IF ZLCNORC  /=\"\" THEN do*/\n     if xyz \\= \"\" then do\n      Address \"ISPEXEC\" \"LMCLOSE DATAID(\"ddvar\")\"\n      if rc \\=0 then say \"LMCLOSE RC=\"RC\n      Address \"ISPEXEC\" \"LMFREE DATAID(\"ddvar\")\"\n      if rc \\=0 then say \"LMFREE  RC=\"RC\n     end\n /*end*/\n /**** end extracted from @PRINTNX *******************/\n  return\n\n modified_input:\n unshown = 0\n /* TECHPS and PU00L contains coding similar to @PRINTNX */\n address \"ISREDIT\"\n \"(maxrec) = LINENUM .ZLAST\"\n qcnt=qcnt+1; q.qcnt =\".ti 5F 5F\"\n qcnt=qcnt+1; q.qcnt =\".ti\"\n qcnt=qcnt+1; q.qcnt =\".su off\"\n qcnt=qcnt+1; q.qcnt =\".dc gml off\"\n qcnt=qcnt+1; q.qcnt =\".dc cw  off\"\n qcnt=qcnt+1; q.qcnt =\".li on\"\n do rec = 1 to maxrec\n    \"(XSTATUS) = XSTATUS\" REC\n    if XSTATUS = \"X\" then do\n       if unshown = 0 then qfrom = rec + 0\n       unshown = unshown + 1\n    end\n    else do\n       if unshown /= 0 then do\n          recm1 = rec - 1\n          qcnt=qcnt+1; q.qcnt = \"        - - - - - - - - -\",\n                unshown \"LINE(S), lines\" right(QFROM,6,'0')\"-\"||,\n                right(recm1,6,'0') \"Not Displayed\"\n          unshown = 0\n       end\n       \"(LINE) = LINE\" rec\n       \"(LABEL,NEST) = LABEL\" rec\n       line=strip(line,'t')\n       qcnt=qcnt+1;\n       if nolabel = 1\n          then q.qcnt = right(rec,6,'0') line\n          else q.qcnt = \" \"left(label,6) right(rec,6,'0') line\n       /* We could have provided more room when labels are not used, */\n       /* but chose to keep report uniform for NX listings regard-   */\n       /* less of whether labels are used or not.  <design choice>   */\n    end\nend\nqcnt=qcnt+1; q.qcnt = \".li off\"\nqcnt=qcnt+1; q.qcnt =\".dc gml : : e\"\nqcnt=qcnt+1; q.qcnt =\".dc cw 5E\"\nqcnt=qcnt+1; q.qcnt =\".su on\"\nq.0 = qcnt;\nreturn\nINFO: parse arg arg;\n      address \"ISREDIT\" \"line_before .zf = infoline (arg)\"; return\nNOTE: parse arg arg;\n      address \"ISREDIT\" \"line_before .zf = noteline (arg)\"; return\nMSG0: /* SPF/PC invokes SETMSG in incorrectly */\n      if v1 = \"REXXSAA\"\n         then /*Address*/ \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n         else Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\nreturn  0\ndwchk:\n   tmax = var016; if tmax > 250 then tmax = 250;\n   ttmax = tmax;\n   do jj = ttmax to 70 by -10;\n      address \"ISREDIT\" \"seek first p'^'\" jj tmax\n      if rc \\= 0 then tmax = jj;\n   end;\n   do j = tmax to 70   by -1\n      address \"ISREDIT\" \"seek first p'^'\" j tmax\n      if rc = 0 then return j;\n   end;\n   return 70\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TLMSUSER": {"ttr": 15111, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x03\\x00\\x03\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 3, "newlines": 3, "modlines": 0, "user": "MCRITCH"}, "text": "PROC 0\nWRITE %TLMSUSR IS EQUIVALENT TO %TLMSUSER AND IS BEING INVOKED\n%TLMSUSR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TLOG": {"ttr": 15113, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00>\\x00>\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 62, "newlines": 62, "modlines": 0, "user": "MCRITCH"}, "text": " PROC 0 SMGR LOGON EDIT\n CONTROL MAIN ASIS\n /*     CONTROL LIST CONLIST SYMLIST\n IF &LOGON = THEN ISPEXEC CONTROL DISPLAY LINE\n PROFILE MSGID INTERCOM WTPMSG\n /************************************/\n SET CNTL = &SUBSTR(1:4,&SYSUID.    )\n SET CNTL = &CNTL.\n SET CNTL = &CNTL..TLOG.LOG\n /************************************/\n SET U = &SUBSTR(1:4,&SYSUID.     )\n SET U = &SUBSTR(1:8,&U.TLOG       )\n SET U = &U\n SET SYSOUTTRAP = 1000\n STATUS &U\n /* SYSOUTLINE CONTAINS NUMBER OF LINES,    */\n /* SETTING FROM &&SYSOUTLINE&I.. GIVES A PARTICULAR LINE. */\n SET SYSOUTTRAP = 0\n SET I = 1\n SET N = &SYSOUTLINE\n SET COUNT = 0\n DO WHILE &I <= &N\n    SET &L&I = &&SYSOUTLINE&I..\n    SET L = &&L&I..\n    SET &L&I = &L\n    IF &LENGTH(&STR(&L)) >= 32 THEN -\n       IF &SUBSTR(1:9,&L) = IKJ56192I THEN  DO\n          SET JOBSTAT = &SUBSTR(15:32,&L)\n          /***********************************************************\n          /* ---------------  CHECK DATASET  -------------------------------- */\n          IF &SYSDSN('&CNTL') ^= OK THEN DO\n             ALLOC DS('&CNTL') NEW CATALOG TRACK SPACE(60,1) DIR(30) LRECL(132)\n             FREE DS('&CNTL')\n             END\n          /* ---------------  FIND NEXT MEMBER  ---------------------------- */\n          SET C = 1\n          SET SOUP = &STR(ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$)\n          DO WHILE &C <= &LENGTH(&SOUP)\n             SET D = L&SUBSTR(7:8,&SYSDATE)&SUBSTR(1:2,&SYSDATE)&SUBSTR(4:5,&SYS\n             IF &C > &LENGTH(&SOUP) THEN GOTO END1\n             IF &SYSDSN('&CNTL(&D)') ^= OK THEN GOTO END2\n             SET C = &C + 1\n             END\n          END1: WRITE &CNTL(&D) &SYSDSN('&CNTL(&D)')\n                EXIT CODE(8)\n          END2: WRITE OUT  &JOBSTAT CLASS(V)  HOLD KEEP PRINT('&CNTL(&D)')\n            /*  OUT &JOBSTAT CLASS(V) HOLD KEEP /* PRINT(*)\n            /*  IF &LASTCC = 0 THEN DO\n                   OUT &JOBSTAT CLASS(V) HOLD KEEP PRINT('&CNTL(&D)')\n                   IF &LASTCC = 0 THEN OUT &JOBSTAT  DELETE\n                   ISPEXEC EDIT DATASET('&CNTL(&D)') MACRO(TLOGEDIT)\n                   CONTROL NOMSG\n                   FREE DATASET('&CNTL')\n                   CONTROL MSG\n            /*  END\n          /***********************************************************\n          SET COUNT = &COUNT + 1\n       END\n    SET I = &I + 1\n END\n IF EDIT = &EDIT. THEN $EDIT &CNTL\n EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TOD": {"ttr": 15115, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00B\\x00B\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "MCRITCH"}, "text": " /*REXX*/\n /* INTERPRET TOD TIME STAMP SUCH AS FOUND IN LISTCAT FOR VSAM  */\n /* DAVID MCRITCHIE, \"THE REXX MACROS TOOLBOX\", 1993/09/28 WITH J.KENNEDY */\n /* *********************************************************** ****/\n /*       9852F19918A85000                                         */\n /*       9854F19918A85000      GMT STAMP: 1984.336 04:28:49.321   */\n /*       A827D9A2A9082B12      GMT STAMP: 1993.271 17:22:16.110   */\n /*       A827D9A2A9100000                 1993.271 17:22:16.110   */\n /*       A827D9A2A9000000                 1993.271 17:22:16.110   */\n /*       A827D9A2A8900000                 1993.271 17:22:16.108   */\n /*       AF00000000000000      GMT STAMP: 1997.204 07:42:37.77280 */\n /******************************************************************/\n \"CLS\"; D=' ----- '\n NUMERIC DIGITS 35\n ARG TOD\n SAY \"TOD -- TRANSLATE THE GMT TIMESTAMP AS FOUND IN OUTPUT FROM\"\n SAY \"  IDCAMS OR LISTCAT FOR CLUSTERS.  IN BATCH USE PROC=AMSCLUST\"\n SAY \"  INSTEAD OF PROC=AMS.\"\n TOD = TRANSLATE(TOD)\n I=VERIFY(TOD,'0123456789ABCDEF')\n IF I /= 0 THEN DO\n    SAY 'INCORRENT VALUE ===> TOD' TOD\n    SAY 'WILL BE TREATED AS NO VALUE SUPPLIED'\n    TOD=''\n END\n IF TOD = '' THEN DO\n     X2 = SUBSTR('U',1,2)\n     /* GUESS WHETHER DAYLIGHT SAVINGS TIME OR STATNDARD TIME */\n     IF X2 < 04 | X2 > '10' THEN GMTADJ = 5 ELSE GMTADJ = 6\n     SS = SUBSTR(TIME('L'),9) + TIME('S') + 0.18 /*ADD .18 SEC*/\n     A = (((DATE('C') - 1 ) * 24 + GMTADJ)* 60 * 60 + SS) * 4096E6\n     TOD = D2X(A)  /* PREV TESTED WITH  'A827D9A2A9082B12'*/\n     SAY 'NO ARGUMENT SUPPLIED -- CREATED A VALUE FROM LOCAL TIME'\n     SAY ' AS IF ENTERED AS      COMMAND ===> TSO TOD' TOD\n END\n ELSE SAY D\"TOD (TIME OF DAY) CALCULATION BASED ON YOUR ENTRY\"D\n L = LENGTH(TOD)\n IF L /= 16 THEN DO\n    SAY 'YOU SUPPLIED' L 'DIGITS, 16 ARE REQUIRED -- CORRECTED ENTRY'\n    TOD=SUBSTR(TOD||'00000000000000000',1,16)\n END\n WORK_SEC = X2D(TOD) / 4096E6;\n /* THE REMAINDER OF CODE IS SAME AS IN IS02.UTILITY.PLI(GMT) */\n /* WHICH WAS ALSO USED IN PGM=IZ2048 USED IN PROC=AMSCLUST   */\n WORK_MIN = WORK_SEC % 60    /* TRUNC(WORK_SEC / 60) */\n SEC   = WORK_SEC - 60 * WORK_MIN\n WORK_HR  = WORK_MIN % 60\n MIN   = TRUNC(WORK_MIN - 60 * WORK_HR)\n WORK_DAY = WORK_HR % 24\n HR    = TRUNC(WORK_HR - 24 * WORK_DAY)\n WORK_DAY = WORK_DAY + 1 /* AS IF 1900 WERE A LEAP YEAR*/\n Y4    = WORK_DAY % 1461  /* 4YEARS = 3*365 + 366 */\n D4    = WORK_DAY - 1461 * Y4\n Y1    = MAX(D4 -1,0)%365\n YEAR  = TRUNC(4*Y4 + Y1)\n DAY   = D4 - 365 * Y1 - SIGN(Y1)  + 1\n DAY   = RIGHT(DAY,3,'0')\n HR    = RIGHT(HR,2,'0')\n MIN   = RIGHT(MIN,2,'0')\n SEC   = RIGHT(TRUNC(SEC,5),8,'0') /* MAKE LOOK GOOD */\n YEAR = YEAR + 1900\n SAY 'GMT STAMP:' YEAR'.'DAY  HR':'MIN':'SEC',  FROM TIMESTAMP:' TOD\n SAY ' '\n SAY '---- COMPARE THE ABOVE TO THE CURRENT INFORMATION BELOW ---'\n SAY '----   FIRST LINE HAS GMT,  SECOND LINE HAS LOCAL TIME  ---'\n ADDRESS TSO \"TIMES\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOOS2": {"ttr": 15117, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00;\\x00;\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 59, "newlines": 59, "modlines": 0, "user": "MCRITCH"}, "text": "/*TSOOS2:  File Transfer Set Up between OS/2             (REXX)   */\n/*       created by David McRitchie, \"The REXX Macros Toolbox\" 1993/05/20 */\n/*       <<for use on TSO only>> copy made available to PC users  */\n/*       SCRSIZEP and SCRSIZEA created by John Kennedy            */\n/*-----------------------------------------------------------------\n   To be used during file transfers between TSO and OS/2 either way.\n   Will set the SCReen SIZE to \"Primary\" for the duration.  When PF3\n   is entered the duration ends  SCRSIZEA, \"Alt\", is invoked, and\n   INTERCOM which accepts messages from other users is turned back on\n.-----------------------------------------------------------------*/\n if sysvar(\"SYSISPF\") /= \"ACTIVE\" then exit 0\n trap = 0\n\n tryagain:,\n ADDRESS \"ISPEXEC\" \"VGET (ZSCREEND ZSCREENW ZSPLIT) SHARED\"\n if zsplit = \"YES\" then do;\n    cls /*clear screen*/\n    say \"------------- SPLIT SCREEN Warning ---------------\"\n    say \"Split screen is NOT compatible with transfers, causes \"\n    say \"asterisks to appear on screen delaying or causing \"\n    say \"failure in file transfer\"\n    if zscreend = 27 then do; say ' ';\n    say \"-----  Also Please reset screen size to STD ------\"\n    end\n    say \"---------------------------------------------------\"\n end\n if zscreend = 27 then do\n    /* do not bother checking for ISPF, screen has no msgarea*/\n    say \"Think you need to set  terminal screen to  STD\"\n end\n if zscreend = 27 | zsplit = \"YES\" then\n    address \"ISPEXEC\" \"SELECT PGM(ISPOPT) PARM(ISPOPT1)\"\n \"TERMINAL NOBREAK\"\n ADDRESS \"ISPEXEC\" \"VGET (ZSCREEND ZSCREENW ZSPLIT) SHARED\"\n if zsplit = \"YES\" | zscreend = 27 then do;\n      say '****************************************'\n      say '*   WAKE UP,  changes required to your *'\n      say '*   your session before going into     *'\n      say '*   COMMAND MODE to process transmit   *'\n      say '****************************************'\n      trap = trap + 1\n      if trap > 0 then return 12\n      signal tryagain;\n end;\n \"PROFILE NOINTERCOM\";\"SCRSIZEP\";\"Q TSO\"\n \"PROFILE INTERCOM\";\"SCRSIZEA\"\n if zscreend = 27 | sysvar('SYSUID') = \"IS03\" then do\n    ADDRESS \"ISPEXEC\" \"VGET (ZSCREEND) SHARED\"\n    if zscreend  = 24 then do\n       say \"You may set TERMINAL back to DATA or MAX now, if you like   \"\n       address \"ISPEXEC\" \"SELECT PGM(ISPOPT) PARM(ISPOPT1)\"\n    end\n end\n if sysvar(\"SYSISPF\") = \"ACTIVE\" then do\n    ZEDSMSG = \"\"\n    ZEDLMSG = \"    >>>>>> %TSOOS2 DONE -- PROFILE INTERCOM <<<<<<<\"\n    ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n end\n else do;%CLS; SAY \"----- %TSOOS2 DONE -- PROFILE INTERCOM\";end;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOTRAP": {"ttr": 15119, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00=\\x00=\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 61, "newlines": 61, "modlines": 0, "user": "MCRITCH"}, "text": "  /* ---------------------  rexx procedure  ---------------------- */\n  /* Name:      TSOTRAP                                            */\n  /*                                                               */\n  /* Function:  This Rexx procedure will accept any TSO command    */\n  /*            (including clists and other Rexx procedures)       */\n  /*            that output to the terminal and trap the output    */\n  /*            and then display the results using ISPF Browse.    */\n  /*                                                               */\n  /* Syntax:    %TSOTRAP tso-command options                       */\n  /*                                                               */\n  /* Author:    Lionel B. Dyck                                     */\n  /*            Rockwell International                             */\n  /*            P.O. Box 2515                                      */\n  /*            Seal Beach, California 90740                       */\n  /*            (310) 797-1125                                     */\n  /*            IBMLINK:  ROK2027                                  */\n  /*                                                               */\n  /*   Similar to edit macros  @STRAP  etc. by D.McR               */\n  /*   The TSOTRAP procedure should prove useful to CUT lines out  */\n  /*   and to paste elsewhere later.                               */\n  /*                                                               */\n  /* History:   1990/07/23 - Rexx procedure created.               */\n  /*            1990/10/04 - update to larger lrecl for trap d/s   */\n  /*            1992/01/19 - D.McR use EDIT, exit if TRAP.0=0      */\n  /*            1992/01/20 - D.McR .LIST in dsname for profile     */\n  /*            1994/06/30 - D.McR Provide for NOPREFIX users      */\n  /*                                                               */\n  /* ------------------------------------------------------------- */\n\n  arg command\n  sysuid = SYSVAR('SYSUID')  /* to provide for NOPREFIX users */\n\n  if length(command) = 0 then do\n     say \"Error:  Use of TSOTRAP requires the specification of\"\n     say \"        a TSO command whose results will be captured\"\n     say \"        and displayed using ISPF Browse/Edit.\"\n     say \"        (e.g.  %TSOTRAP LISTC)\"\n     exit 12\n     end\n\n  x = outtrap(\"trap.\",\"*\")\n\n  command\n\n  x= outtrap(\"off\")\n\n  if trap.0 = 0 then do;\n     say ' ';x = '***** Unable to Trap command ******';say x||x\n     exit 12\n  end\n\n  dd = \"TP\"random()\n\n  \"ALLOC F(\"dd\") DS('\"sysuid\".TSOTRAP.\"dd\".LIST') NEW SPACE(10,30)\",\n        \"TRACKS LRECL(130) RECFM(F B) BLKSIZE(0)\"\n\n  \"EXECIO * DISKW\" dd \"(FINIS STEM trap.\"\n\n  /*Address ISPEXEC \"BROWSE DATASET(TSOTRAP.\"dd\")\" */\n  Address ISPEXEC \"EDIT DATASET('\"sysuid\".TSOTRAP.\"dd\".LIST')\"\n  \"FREE F(\"dd\") DELETE\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNGML": {"ttr": 15361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00*\\x00*\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "MCRITCH"}, "text": " /*REXX TITLE:    UNGML  -- take gml statements and regmls them      */\n /*                      so then can be printed to show gml control  */\n /*  USERS:            SCRIPT USERS                                  */\n /*  CONTRIBUTED: 1988/04/09 DAVID MCRITCHIE                         */\n /*                        \"The REXX Macros Toolbox\",                */\n /*  EXAMPLE: ===>  ungml                                            */\n Address \"ISREDIT\"\n \"MACRO NOPROCESS (REVERSE)\"\n/*ddress \"ISPEXEC\" \"CONTROL ASIS\"*/\n \"PROCESS RANGE C\"\n IF RC = 0 THEN do\n    LABF = \".ZFRANGE\"\n    LABL = \".ZLRANGE\"\n    \"LABEL .zfrange = .A 0\"\n    \"LABEL .zlrange = .B 0\"\n END\n ELSE do            /* default range is label .a and .b */\n    LABF = \" .A \"\n    LABL = \" .B \"\n END\n IF \"REVERSE\" \\= translate(REVERSE) THEN do\n \"C ALL \" labf labl \"    '&&&&'           '&&&&amp.'\"\n \"C ALL \" labf labl \"    ':'              '?#?'\"\n \"C ALL \" labf labl \"    '-         '     '-&&&&rbl.         '\"\n \"C ALL \" labf labl \"    '^'              '&&&&not.'\"\n \"C ALL \" labf labl \"1   '.'              '&&&&period.'\"\n \"C ALL \" labf labl \"    ';.'             ';&&&&period.'\"\n \"C ALL \" labf labl \"    '?#?'            '&&&&gml.'\"\n \"C ALL \" labf labl \"    ';'              '&&&&semi.'\"\n end\n else do\n \"C ALL \" labf labl \"    '&&&&semi.'       ';'\"\n \"C ALL \" labf labl \"    '&&&&gml.'        '?#?'\"\n \"C ALL \" labf labl \"    ';.&&&&period.'   ';.'\"\n \"C ALL \" labf labl \" 1  '&&&&period.'     '.'\"\n \"C ALL \" labf labl \"    '&&&&period.'     '.'\"\n \"C ALL \" labf labl \"    '-&&&&rbl.   '    '-    '\"\n \"C ALL \" labf labl \"    '&&&&not.'        '^'\"\n \"C ALL \" labf labl \"    '?#?'            ':'\"\n \"C ALL \" labf labl \"    '&&&&amp.'        '&&&&'\"\n end\n return 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WHEREIS": {"ttr": 15363, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00z\\x00z\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 122, "newlines": 122, "modlines": 0, "user": "MCRITCH"}, "text": "/* Language  -- REXX                                                 */\n/* Name      -- WHEREIS                                              */\n/* Purpose   -- Search for a given member in library concat.         */\n/* Author    -- John McCarthy, Optimum Data Systems, Inc.            */\n/*              \"Locating ISPF Library Members\" in \"TSO Times\"       */\n/*              Summer 1993 issue from  Chicago-Soft, Ltd            */\n/* modifications by David McRitchie -- \"The REXX Macros Toolbox\" 1993/10/04 */\n/*   default to exact match, unless new option ANY invoked           */\n/*   preference for SYSDSN to LISTD, uses 4 secs instead of 30       */\n/*   include DDNAME in display when found                            */\n/*   original had 70 lines, this equates to 112 (remaining + 3)      */\n/*********************************************************************/\n  trace o\n  parse upper arg fmember op.1 op.2\n  if fmember = ' ' then do\n           ZEDSMSG = \"member?\"\n           ZEDLMSG = 'Member was not specified'\n           ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n           exit(12)\n  END\n  any = \"\"\n  address \"TSO\" \"CLS\"\n  do i = 1 to 2\n     if op.i = \"ANY\" then ANY = \"ANY\"\n     if datatype(op.i,'n') = 0 then max = op.i\n  end\n  timestart = time('N')\n  say \"Time started \" timestart \"-- TSO WHEREIS\" fmember max,\n      \"allow at least 30 seconds\"\n  if ANY = \"ANY\" then say \"    ANY, specified will search for\",\n         fmember \"as part of membernames\"\n  else say \"    ANY, not specified therefore membername must\",\n         \"match exactly with\" fmember\n  say \"    nnn, possible termination after nnn hits within dataset\"\n  say \"--alternative \"The REXX Macros Toolbox\" clists: \",\n        \"clist, panels, loadmod, proc, pdsdd\"\n  if max = '' then max = 999\n  else do\n     if max = \"=\" then do; max=999; exact=1; end;\n     else if datatype(max,'n') = 0 then do\n           ZEDSMSG = \"max\"\n           ZEDLMSG = 'Second parameter indicates number',\n             \"of hits acceptable -- must be numeric, or '='\"\n           ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n           exit(12)\n     END\n  END\n  total = 0\n\n  /* get concatenation */\n  x = outtrap(\"alc.\")\n  \"listalc status\"\n  x = outtrap(\"off\")\n\n  /* search libraries */\n  do line = 2 to alc.0\n     linep1 = line+1\n     if substr(alc.linep1,1,2)='  ' then\n        if substr(alc.linep1,3,1)\\='' then\n           ddname=substr(alc.linep1,3,8)\n     if substr(alc.line,1,1) \\= ' ' then do\n        i = pos('(',alc.line)\n        if i=0 then i=pos('?',alc.line)\n        if i = 0 then\n           if substr(alc.line,1,9) \\= 'TERMFILE ' then\n           if substr(alc.line,1,9) \\= 'NULLFILE ' then\n           if ANY = \"\" then call quick_scan;\n           else call scan_members\n     end\n  end\n  if total = 0 then do\n           ZEDSMSG = \"not found\"\n           ZEDLMSG = 'Member' fmember 'was not found'\n           ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n           say fmember '-- not found, try one of the other clists'\n  end\n  say \"WHEREIS began\" timestart \"completed\" time('N'),\n       \"-- TSO WHEREIS\" fmember op.1 op.2\n\n  /* that's all folks   -'- */\n  exit\n\n  /* sub-routines  */\nquick_scan:          /* added by D.McRitchie for speed and usage */\n  x = sysdsn(\"'\"strip(substr(alc.line,1,44))\"(\"fmember\")'\")\n  if x = \"OK\" then do\n     total=total + 1\n     say ddname 'member('fmember') in' alc.line\n  end\n  return\n\nscan_members:      /*original code, find string anywhere in members*/\n  x = outtrap(\"members.\")\n  \"listd '\"alc.line\"' MEM\"\n  x = outtrap(\"off\")\n  if members.0 < 7 then return\n  flag1 = 0; count=max;\n  do num = 7 to members.0\n    /* if fmember = substr(members.num,3,8)  then do*/\n    find = 0\n    if ANY = \"ANY\" then find = POS(fmember,strip(members.num))\n    else if fmember = substr(members.num,3,8) then find=1\n    if find \\= 0 then do\n        total = total + 1\n        if flag1 = 0 then do\n           say left(ddname,8) '-- Dataset --' alc.line,\n               'members('members.0')'\n       /*  say '-- Members --'*/\n           flag1 = 1\n        end\n        say '       'members.num\n        count = count - 1\n        if count < 1 then do\n           say ' '\n           say 'Continue?  (Y/N)'\n           pull ans; ans=translate(ans)\n           if ans \\= 'Y' then exit(2)\n           count = max\n        end\n     end\n  end\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WHICH": {"ttr": 15366, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00W\\x00W\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 87, "newlines": 87, "modlines": 0, "user": "MCRITCH"}, "text": "00010011PROC 0 DEBUG SYMLIST TSO WHICH CPU UCB IPL HELP DS() VOLUME() UNIT() -\n00011011   SYSTEM\n00012011IF &SYSNEST = NO THEN CONTROL MAIN\n00013011ELSE CONTROL NOFLUSH\n00014011IF &DEBUG = DEBUG THEN CONTROL LIST CONLIST\n00015011SET ERRTXT =\n00016011ERROR GOTO ERROR\n00017011PROFILE INTERCOM WTPMSG\n00018011SET WHAT = &CPU.&UCB.&HELP.&IPL.&SYSTEM\n00019011IF &WHAT = CPU THEN IVLCPU\n00020011ELSE IF &WHAT = UCB THEN DO\n00030011   CONTROL NOMSG\n00040011   ERROR OFF\n00050011   FREE FI(INFILE)\n00060011   ERROR GOTO ERROR\n00070011   CONTROL MSG\n00080011   IF &DS.&VOLUME.&UNIT. = THEN DO\n00090011      WRITENR ENTER DS('FULLY.QUALIFIED.DSN'), VOLUME(VOLSER), OR UNIT(X\n00100011      READ\n00110011      %WHICH UCB &SYSDVAL\n00120011      EXIT CODE(&LASTCC)\n00130011      END\n00140011   IF &UNIT ^= THEN SET UNIT1 = UNIT(&UNIT)\n00150011   ELSE IF &DS = OR &VOLUME ^= THEN SET UNIT1 = UNIT(SYSALLDA)\n00160011   ELSE SET UNIT1 =\n00170011   IF &DS = THEN SET DS1 = NEW DELETE BLOCK(80) SPA(0) RECFM(F) -\n00180011      BLKSIZE(80)\n00190011   ELSE SET DS1 = DS('&DS') SHR\n00200011   IF &VOLUME ^= THEN SET VOLUME1 = VOLUME(&VOLUME)\n00210011   ELSE SET VOLUME1 =\n00220011   SET ERRTXT = FAILING COMMAND: ALLOCATE FI(INFILE) &DS1 &VOLUME1 &UNIT\n00230011   ALLOCATE FI(INFILE) &DS1 &VOLUME1 &UNIT1 TRACK\n00240011   SET ERRTXT =\n00250011   IVLUCB1\n00260011   FREE FI(INFILE)\n00270011   END\n00280011ELSE IF &WHAT. = IPL THEN DO\n00290011   WRITENR PRODUCTION 3090 IPL VOLUME:\n00300011   ALLOCATE FI(INFILE) DS('SYS1.MVSPRD') SHR REUSE\n00310011   IVLUCB1\n00320011   $EDIT 'TECH.LIBR.CNTL(WHICHIPL)' MACRO(WHICHIPL)\n00330011   IF &LASTCC ^= 0 THEN DO\n00340011      WRITENR NOT ALL VOLUMES ARE AVAILABLE AT THIS TIME -- TERMINATING\n00341011   END\n00342011   WRITENR &RBL.      TEST 3090 IPL VOLUME:\n00342111   ALLOCATE FI(INFILE) DS('SYS1.MVSTST') SHR REUSE\n00342211   IF &LASTCC = 0 THEN DO\n00342311         IVLUCB1\n00342411         FREE FI(INFILE)\n00342511      END\n00342611   END\n00342711ELSE IF &WHAT. = SYSTEM THEN DO\n00342811   WRITE THIS IS NODE AHCENTER.\n00342911   END\n00343011ELSE GOTO SYNTAX\n00344011EXIT CODE(0)\n00345011ERROR: -\n00346011   ERROR\n00347011   WRITE THE COMMAND CONTAINS AN ERROR.  REVIEW THE SYNTAX, AND CORRECT\n00348011   IF &ERRTXT ^= THEN WRITE &ERRTXT\n00349011   SET ERRTXT =\n00350011   WRITE\n00360011   SET WHAT = &WHAT\n00370011   IF &DS ^= THEN SET WHAT = &WHAT DS('&DS')\n00380011   IF &VOLUME ^= THEN SET WHAT = &WHAT VOLUME(&VOLUME)\n00390011   IF &UNIT ^= THEN SET WHAT = &WHAT UNIT(&UNIT)\n00400011   SET WHAT = &SUBSTR(1:45,&WHAT\n00410011   SET ENTER = CORRECT\n00420011   GOTO SYNTAX2\n00430011SYNTAX: -\n00440011   CLRSCRN\n00450011   WRITENR ***\n00460011   READ\n00470011   SET WHAT =\n00480011   SET ENTER = ENTER\n00490011SYNTAX2: -\n00500011   WRITE SYNTAX:\n00510011   WRITE    TSO WHICH CPU   . . . . . . . . . . . . . . . . WHICH CPU OR\n00520011   WRITE    TSO WHICH UCB DS('FULLY.QUALIFIED.DSN')   . . . WHAT IS THE\n00530011   WRITE    TSO WHICH UCB VOLUME(VOLSER)  . . . . . . . . . WHAT IS THE\n00540011   WRITE    TSO WHICH UCB UNIT(UNIT)  . . . . . . . . . . . WHAT IS A VO\n00550011   WRITE              (NOTE: DS, VOLUME, AND UNIT PARAMETERS MAY BE COMB\n00560011   WRITE    TSO WHICH IPL . . . . . . . . . . . . . . . . . WHICH IPL VO\n00570011   WRITE\n00580011   EXIT CODE(&LASTCC)\n00590011   END\n00600011EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WHO": {"ttr": 15369, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "MCRITCH"}, "text": "  /*REXX*/\n  sysuid = sysvar(\"sysuid\")\n  syspref = sysvar(\"syspref\")\n  sysproc = sysvar(\"sysproc\")\n  if syspref = \"\" then syspref=\"**NOPREFIX**\"\n  say  \"  userid=\"sysuid\", syspref=\"syspref\", proc=\"sysproc\n  terminal = gettrid()\n  say  \"                  VTAM Terminal ID=\"terminal\n\n  /* LOCATION -- TELLS USER WHERE LOGGEDON ON                */\n  /* SYSUID  -- USER'S IDENTIFICATION                        */\n  /* SYSPREF -- DATA SET NAME PREFIX WHICH THE USER SETS     */\n  /*            USING THE PROFILE COMMAND                    */\n  /* SYSPROC -- LOGON PROCEDURE NAME                         */\n  /* TERMINAL-- VTAM TERMINAL ID  AS FOUND BY GETTRID        */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WORDS": {"ttr": 15371, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00'\\x00'\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "MCRITCH"}, "text": "/*  REXX -- Count number of words in text                      */\n/*  no provision for tags,  if script use  @SCRIPT Q  first    */\n/*  author: David McRitchie, \"The REXX Macros Toolbox\" 1993/11/09 */\nAddress \"ISREDIT\"\n\"MACRO (TOKEN)\"\n\"seek prefix p'@' all\"\n\"(cnt1aw,cnt2aw) = seek_counts\"\n\"seek word p'@' all\"\n\"(cnt1as,cnt2as) = seek_counts\"\n\"seek prefix p'#' all\"\n\"(cnt1nw,cnt2nw) = seek_counts\"\n\"seek word p'#' all\"\n\"(cnt1ns,cnt2ns) = seek_counts\"\n\"seek prefix p'$' all\"\n\"(cnt1sw,cnt2sw) = seek_counts\"\n\"seek word p'$' all\"\n\"(cnt1ss,cnt2ss) = seek_counts\"\n\"seek p' ^^' all\"\n\"(cnt1pw,cnt2pw) = seek_counts\"\n\"seek p' ^ ' all\"\n\"(cnt1ps,cnt2ps) = seek_counts\"\n\"seek p'^' 1 all\"\n\"(cnt1p1,cnt2p1) = seek_counts\"\nwords  = cnt1aw + cnt1nw + cnt1as + cnt1ns\nbreaks = cnt1pw + cnt1ps + cnt1p1\ncnt1aw = 0 + cnt1aw; cnt1as= 0 + cnt1as;\ncnt1nw = 0 + cnt1nw; cnt1ns= 0 + cnt1ns;\ncnt1sw = 0 + cnt1sw; cnt1ss= 0 + cnt1ss;\ncnt1pw = 0 + cnt1pw; cnt1ps= 0 + cnt1ps;\ncnt1p1 = 0 + cnt1p1;\nmoreinf = words \"words, begin letter(\"cnt1aw \"+\" cnt1as\")\",\n   \"+ numeric(\"cnt1nw \"+\" cnt1ns\") -- special(\"cnt1sw \"+\" cnt1ss\")\"\n\"LINE_BEFORE .zfirst = NOTELINE (moreinf)\"\n ZEDSMSG = breaks \"words\"\n zedlmsg = breaks \"words=\" cnt1pw\"(p' ^^') +\" cnt1ps\"(p' ^ ') +\" cnt1p1\"(1 p'^')\n\"LINE_BEFORE .zfirst = NOTELINE (zedlmsg)\"\n ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n \"up max\"\n RETURN 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XEVERY": {"ttr": 15373, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00\\xa7\\x00\\xa7\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 167, "newlines": 167, "modlines": 0, "user": "MCRITCH"}, "text": " /*  TITLE:       XEVERY  -- EXCLUDE LINES CONTAINING EVERY  SPECIFIED STRING\n /*  USERS:       SCRIPT USERS\n /*  ENTRY:       USED AS AN EDIT CLIST WITHIN ISPF EDIT  ===> XEVERY 'A' 'B' C\n /*  CONTRIBUTED: 1986/04/28 DAVID MCRITCHIE\n /*\n /*  EXAMPLE:     XEVERY .ZFIRST .ZLAST  'STRING1' \"STRING2\" STRING3 STRING4 'ST\n /*  OPTIONS:\n /*      LBL-RANGE    (OPTIONAL)  LABEL RANGE\n /*      NX | X       (INVALID )  LIMIT TO NON-EXCLUDED, OR EXCLUDED LINES\n /*      <LIST>       (REQUIRED)  STRING OPERAND SUITABLE FOR AN EXCLUDE COMMAND\n /*\nISREDIT     MACRO (TOK1,TOK2,TOK3,TOK4,TOK5,TOK6,TOK7,TOK8,TOK9,TOK10,TOK11,TOK1\n          TOK14,TOK15,TOK16,TOK17,TOK18,TOK19,TOK20,TOK21,TOK22,TOK23,TOK24,TOK2\n          TOK27,TOK28,TOK29,TOK30,TOK31,TOK32,TOK33,TOK34,TOK35,TOK36,TOK37,TOK3\n          TOK40,TOK41,TOK42,TOK43,TOK44,TOK45,TOK46,TOK47,TOK48)\n        ISREDIT (IMAC) = IMACRO\n        SET R  = 0\n        SET XCNT = 0\n        SET I = 0\n        /*********\n        SET I = 1\n       DO WHILE &I <= 48\n        SET TOKEN = &&TOK&I\n        SET TOKEN = &STR(&SYSCAPS(&TOKEN))\n        IF &STR(&TOKEN) = &STR() THEN GOTO END_TOK\n        IF X   = &STR(&TOKEN) | NX   = &STR(&TOKEN) | ENTIRE = &STR(&TOKEN) -\n        | ALL = &STR(&TOKEN) | NEXT = &STR(&TOKEN) | FIRST = &STR(&TOKEN) | LAST\n          SET &ZEDSMSG = &STR(&TOKEN INVALID)\n          SET &ZEDLMSG = &STR(\"&TOKEN\" NOT PROVIDED FOR NOR ARE NEXT ALL FIRST L\n          ISPEXEC   SETMSG MSG(ISRZ000)\n          EXIT CODE(12)\n        END\n        IF &SUBSTR(1:6,&STR(&TOKEN)       ) = &STR(BEGIN&STR(&LP))  THEN DO\n           SET BEGIN = &SUBSTR(7:&EVAL(&LENGTH(&STR(&TOKEN))-1),&STR(&TOKEN)\n           GOTO NXT_TOK\n        END\n        IF &STR(&TOKEN) = WORD | &STR(&TOKEN) = CHAR | &STR(&TOKEN) = CHARS -\n        | &STR(&TOKEN) = PREFIX | &STR(&TOKEN) = SUFFIX THEN DO\n           IF &STR(&WORD) ^= &STR() THEN DO\n              SET &ZEDSMSG = &STR(INCONSISTENT PARAMETERS)\n              SET &ZEDLMSG = &STR('&WORD' AND '&TOKEN' CANNOT BOTH BE SPECIFIED\n              ISPEXEC     SETMSG MSG(ISRZ000)\n           END\n           SET WORD = &TOKEN\n           GOTO NXT_TOK\n        END\n        IF &STR(&TOKEN) = LEFT THEN DO /* LEFT | RIGHT */\n           SET LEFT = LEFT\n           GOTO NXT_TOK\n        END\n        IF &STR(&TOKEN) = RIGHT THEN DO\n           SET RIGHT = RIGHT\n           GOTO NXT_TOK\n        END\n        IF &SUBSTR(1,&TOKEN) = &STR(.) THEN DO\n           IF &LABF = &STR() THEN DO\n              SET LABF = &STR(&TOKEN)\n              GOTO NXT_TOK\n           END\n           IF &STR(&LABL) = &STR() THEN DO\n              SET LABL = &STR(&TOKEN)\n              GOTO NXT_TOK\n           END\n          SET &ZEDSMSG = &STR(LABEL &STR(&TOKEN))\n          SET &ZEDLMSG = &STR(EXACTLY TWO LABELS ARE REQUIRED FOUND   \"&LABF\", \"\n          ISPEXEC   SETMSG MSG(ISRZ000)\n          EXIT CODE(12)\n        END\n        IF &STR(&TOKEN) = &STR()) THEN DO\n           SET &ZEDSMSG = &STR(LOST PARENTHESIS)\n           SET &ZEDLMSG = BLANKS SEPARATE ALL OPERANDS; THEREFORE INVALID IN FRO\n           ISPEXEC SETMSG MSG(ISRZ000)\n           EXIT CODE(12)\n        END\n        SET REMAIN = &STR(&REMAIN &STR(&TOKEN))\n        SET R = &R + 1\n        SET FIND&R = &STR(&TOKEN)\n NXT_TOK: -\n        SET I = &I + 1\n      END\n END_TOK: SET I = &I\n      /*****************************************************************\n        /*****************************************************************\n        SET RMAX = &R\n        IF &STR(&FIND1) = &STR() THEN DO\n                   SET &ZEDSMSG = &STR(EXCLUDE STRINGS)\n                   SET &ZEDLMSG = &STR(&ZEDSMSG ARE MISSING)\n                   ISPEXEC     SETMSG MSG(ISRZ000)\n                   EXIT CODE(12)\n        END\n        IF &LABL = &STR() AND &LABF ^= &STR() THEN DO\n           SET &ZEDSMSG = &STR(LABEL MISSING)\n           SET &ZEDLMSG = &STR(TWO LABELS MUST BE INDICATED FOR A RANGE)\n           ISPEXEC     SETMSG MSG(ISRZ000)\n        END\n        IF &LABF = &STR() THEN SET LABF = &STR(.ZFIRST)\n        IF &LABL = &STR() THEN SET LABL = &STR(.ZLAST)\n        ISREDIT (#LABF) = LINENUM &LABF\n        IF &LASTCC ^= 0 THEN DO\n                   SET &ZEDSMSG = &STR(&LABF. LABEL)\n                   SET &ZEDLMSG = &STR(&ZEDSMSG DOES NOT EXIST)\n                   ISPEXEC     SETMSG MSG(ISRZ000)\n                   EXIT CODE(12)\n        END\n        ISREDIT (#LABL) = LINENUM &LABL\n        IF &LASTCC ^= 0 THEN DO\n                   SET &ZEDSMSG = &STR(&LABL. LABEL)\n                   SET &ZEDLMSG = &STR(&ZEDSMSG DOES NOT EXIST)\n                   ISPEXEC     SETMSG MSG(ISRZ000)\n                   EXIT CODE(12)\n        END\n        /********************************** END OF LABEL REQUIREMENTS **********\n        ISREDIT (DWIDTH) = DATA_WIDTH\n        SET DWIDTH2 = &DWIDTH + &DWIDTH     /* CAN BE USED TO FORCE AN ERROR */\n        ISREDIT (LBOUND,RBOUND) = BOUNDS\n        ISREDIT (VAR019,VAR020) = DISPLAY_COLS\n        /****************************/\n        ISREDIT (VAR057) = RECFM\n        ISREDIT (VAR049,VAR050) = NUMBER\n        SET LLBOUND = &LBOUND\n        SET LLADJ = 0\n        IF &VAR057 = V AND &VAR049 = ON THEN DO\n           SET LLADJ = 8\n           SET LLBOUND = &LBOUND + 8\n        END\n        /****************************/\n        /* WRITE    LBOUND=&LBOUND + &LLADJ = &LLBOUND   RBOUND=&RBOUND  DWIDTH=\n        /************************************** CODE FOR  XEVERY COMMANDS ******\n        /************************************** CODE FOR  XEVERY COMMANDS ******\n        /************************************** CODE FOR  XEVERY COMMANDS ******\n          IF &EVAL(&#LABL.) < &EVAL(&#LABF.) THEN DO\n              SET &ZEDSMSG = &STR(LABEL ERR .LABF/L)\n              SET &ZEDLMSG = &STR(&LABF MUST APPEAR EARLIER THAN &LABL)\n    ISPEXEC   SETMSG MSG(ISRZ000)\n              EXIT CODE(12)\n          END\n    /* **************************************************\n          ISREDIT SEEK &LABF. &LABL. NX FIRST &FIND1\n          IF &LASTCC ^= 0 THEN GOTO NONE\n          SET I = &#LABF\n          DO WHILE &I <= &#LABL\n             ISREDIT (VAR075) = XSTATUS &I\n             IF &VAR075 = NX THEN DO\n                SET R = 1\n                DO WHILE &R <= &RMAX\n                   ISREDIT LABEL &I = .POINT\n                   SET TOKEN = &STR(&&FIND&R)\n                   SET TOKEN = &STR(&TOKEN)\n                   ISREDIT SEEK .POINT .POINT &TOKEN. &WORD. ALL\n                   IF &LASTCC > 0 THEN GOTO NFOUND\n                   SET R = &R + 1\n                END\n                ISREDIT XSTATUS .POINT = X\n                SET XCNT = 0&XCNT + 1\n                GOTO NXTT_I\n               NFOUND: -\n                SET K = &K   /* NO CHANGE */\n             END\n   NXTT_I: -\n             SET I = &I. + 1\n          END\n          ISREDIT F FIRST NX &LABF &LABL ' '\n          IF &STR(&IMAC) = NONE THEN ISREDIT UP 1\n    NONE: -\n          SET &ZEDSMSG = &STR(&EVAL(&XCNT.) EXCLUDED)\n          SET &ZEDLMSG = &STR(&EVAL(&XCNT.) LINE EXCLUDED BY MACRO ===> XEVERY &\n          ISPEXEC     SETMSG MSG(ISRZ000)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "X0289S": {"ttr": 15377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993_\\x00\\x993_\\x12\\x00\\x00C\\x00C\\x00\\x00\\xd4\\xc3\\xd9\\xc9\\xe3\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-01T00:00:00", "modifydate": "1999-12-01T12:00:00", "lines": 67, "newlines": 67, "modlines": 0, "user": "MCRITCH"}, "text": "ISREDIT MACRO\n        ISREDIT (MEMBERX) = MEMBER\n        ISREDIT (DSNX)    = DATASET\n /*===== SYSTECH PERSONNEL CHANGED FORM 0267 TO 0289 ONLY  ========*/\n /* PURPOSE OF X0289S AND X0289 CLISTS -- SYSTECH CHANGED          */\n /*   CHANGE THE FIRST CARD COST CENTER FROM 0267 TO 0289          */\n /*   CHANGE THE AREA CODE TO 908 ON '(201) 555-' CARDS            */\n /* DIRECTIONS TO USE THE X0289S CLIST AND IT'S COMPANION X0289    */\n /* 1. GET INTO EDIT ON MEMBER ZZ IN THE LIBRARY TO BE CHANGED     */\n /* 2. ON THE COMMAND LINE ENTER   ===> X0289S                     */\n /* 3. CHECK THE SRCHFOR PANEL THAT YOU HAVE                       */\n /*    A. THE CORRECT DSNAME INCLUDING AN (*) FOR MEMBERNAME       */\n /*    B. THAT YOU ARE SEARCHING ON STRINGS                        */\n /*       \"0267,\"   AND \"(201) 555-\"                               */\n /* 4. HIT ENTER TO INVOKE THE SEARCH                              */\n /* 5. HIT PFK-3 TO GET OUT OF BROWSE.                             */\n /* 6. CHANGES WILL COMMENCE, BY INVOKING 2ND CLIST                */\n /*      ISREDIT X0289                                             */\n /* 7. IF THE CLIST STOPS BEFORE COMPLETION ON AN SB37 OR          */\n /*    SOMETHING SIMILAR.  COMPRESS YOUR LIBRARY WITHOUT           */\n /*    LEAVING EDIT.  THEN HIT PFK-3 TO EXIT AND CONTINUE.         */\n /* 8. CHECK NUMBER OF MEMBERS PROCESSED AGAINST NUMBER OF         */\n /*    MEMBERS IN THE ZZ MEMBER.                                   */\n /*================================================================*/\nISREDIT F FIRST '='P\nIF &LASTCC = 0 THEN DO\n   SET &ZEDSMSG = &STR(NOT EMPTY)\n   SET &ZEDLMSG = &STR(&ZEDSMSG. IS A REQUIREMENT, SHOULD BE MEMBER ZZ)\n   ISREDIT LINE_BEFORE .ZF   =  MSGLINE \"&SYSTIME. *ERROR** &ZEDLMSG.\"\n   ISREDIT LINE_BEFORE .ZCSR = NOTELINE \"&SYSTIME. *ERROR** &ZEDLMSG.\"\n   ISPEXEC     SETMSG MSG(ISRZ000)\n   EXIT CODE(1)\nEND\nSET RP = &STR())\nSET LP = &STR())\nSET &ZSSFS1 = &STR('0267,')\nSET &ZSSFS2 = &STR('(201) 555-')\nSET &ZSSFS3 = &STR(   )\nSET &ZSSFNDSN = &STR('&DSNX.(*&RP.'\nSET &ZSSFMULT = &STR(YES)\nISPEXEC VPUT (ZSSFS1,ZSSFS2,ZSSFS3,ZSSFNDSN,ZSSFMULT) SHARED\nISPEXEC SELECT PGM(ISRSFM)\nCOPY SRCHFOR.LIST '&DSNX.(ZZX0289)' NONUM\nISREDIT COPY ZZX0289 AFTER 0\nISREDIT KILL ZZX0289\nISREDIT X 'ZZX0289' ALL\nIF &STR(&SYSUID..ISPF.PROFILE) = &STR(&DSNX.) THEN DO\n   /* CAN NOT DO YOUR OWN PROFILE  */\n   ISREDIT CHANGE  ALL WORD ISRPROF  2 '******* ISPPROF '\n   ISREDIT CHANGE  ALL WORD ISRPROF  2 '******* ISPSPROF '\n   ISREDIT CHANGE  ALL WORD ISRPROF  2 '******* ISRPROF '\nEND\nISREDIT DEL  X ALL\nISREDIT X ALL\nISREDIT F '-----' ALL\nIF &LASTCC. ^= 0 THEN DO\n   SET &ZEDSMSG = &STR(NO STRINGS FOUND)\n   SET &ZEDLMSG = &STR(&ZEDSMSG. -- TERMINATING CLIST)\n   ISREDIT LINE_BEFORE .ZCSR = NOTELINE \"&SYSTIME. *ERROR** &ZEDLMSG.\"\n   ISPEXEC     SETMSG MSG(ISRZ000)\n   EXIT CODE(1)\nEND\nSET I = &SYSINDEX(&STR(ISPF.PROFILE),&STR(&DSNX.            ))\nIF &I = 0 THEN  ISREDIT @DIR STET $NDU IMAC MACRO(X0289) FIND(2)\n          ELSE  ISREDIT @DIR SUPPRESS IMAC MACRO(X0289P) FIND(2)\nSET &ZSSFNDSN = &STR()\nISPEXEC VPUT (ZSSFNDSN) SHARED\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT380/FILE380.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT380", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}