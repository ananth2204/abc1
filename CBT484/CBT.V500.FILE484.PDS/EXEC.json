{"INMR01": {"INMLRECL": 80, "INMFNODE": "CCCMVS2", "INMFUID": "CEB40", "INMTNODE": "COMPLEX2", "INMTUID": "CEB40", "INMFTIME": "20001019221410000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 411502, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 6160, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CEB40.V24.ACU.EXEC", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CEB40.V24.ACU.EXEC": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 6160, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3339, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 0, "DS1REFD": "000000", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x00\\x00\\x00\\x00'", "DS1LSTAR": "b'\\x00\\x00\\x00'", "DS1TRBAL": "b''"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xfd\\xa8\\x08\\xa8\\x8f\\xec\\x04,\\x04\\xa5\\xc2\\x18'", "extents": ["b'\\x01\\x00\\x00\\x00\\xfd\\xa8\\x08\\xa8\\x8f\\xec\\x04,\\x04\\xa5\\xc2\\x18'", "b'X\\xf2\\x07\\x80\\x00\\x00\\x00;\\x00\\x07\\x00;\\x00\\r\\x00\\x07'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"CACHEDUP": {"ttr": 16, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x005\\x00\\x95\\x04\\x1f\\x00\\x95 _\\x105\\x00\\xd9\\x00\\xd8\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "1995-02-10T00:00:00", "modifydate": "1995-07-24T10:35:35", "lines": 217, "newlines": 216, "modlines": 0, "user": "CEB40"}, "text": "/*  rexx exec called by Amdahl Cache Utility to handle duplex logic  */\n/*  (C) COPYRIGHT AMDAHL CORPORATION  1995. All Rights Reserved      */\n/*  written:  January 1994                                           */\n/*  author :  Chuck Baumann                                          */\n/*  Panels :  CSHMAN4                                                */\n/*  Help   :  CSHHMAN4                                               */\n/*  Externs:  DEVTYPE          (assembler modules)                   */\n/*  Message:  CSHM01                                                 */\n/*  Changes:  V1.0 -- Initial functions                              */\n/*  94/02/11  V1.1 -- Error messages for file tailoring added        */\n/*-------------------------------------------------------------------*/\narg volser devt addr cachlog cachcnf\n\n/*-------------------------------------------------------------------*/\n/*  Use outtrap to get output from LISTDATA commands                 */\n/*-------------------------------------------------------------------*/\ndummy = outtrap('oline.','*','NOCONCAT')\n\n/*-------------------------------------------------------------------*/\n/* Display the panel                                                 */\n/*-------------------------------------------------------------------*/\ncc = 0\n\naddress 'ISPEXEC' 'DISPLAY PANEL(CSHMAN4) CURSOR(CSHMODE)'\nif rc > 8\nthen do\n       say 'Panel CSHMAN4    could not be found.'\n       exit\n     end\nelse\nif rc = 8 | substr(zcmd,1,3) = 'CAN'\nthen return(4)\n/*-------------------------------------------------------------------*/\n/* get values and bld a command or create a batch job                */\n/*-------------------------------------------------------------------*/\noption = ''\nif CSHCOPY \u00ac= ''\nthen option = 'COPY'\nif CSHPACE  \u00ac= ''\nthen option = option 'PACE('cshpace')'\nif CSHNCOPY \u00ac= ''\nthen option = 'NOCOPY'\n\nselect\n  when CSHSSC \u00ac= ''\n  then do\n         cmdline = 'SSEC('sadr')' option\n       end\n  when CSHSUSPR \u00ac= ''\n  then do\n         cmdline = 'SUSPRI'\n       end\n  when CSHSUSSE \u00ac= ''\n  then do\n         cmdline = 'SUSSEC'\n       end\n  when CSHRSTOD \u00ac= ''\n  then do\n         cmdline = 'RESETDUP' option\n       end\n  when CSHRESTD \u00ac= ''\n  then do\n         cmdline = 'REEST('radr')' option\n       end\n  when CSHRSTOS \u00ac= ''\n  then do\n         cmdline = 'RESETSIM'\n       end\n  otherwise nop\nend\ncmd = 'SETCACHE' cmdline 'VOL('volser') UNIT('devt')'\nif CSHMODE = 'F'  /* foreground execution */\nthen do\n       cc = 0\n       if CACHCNF = 'YES'\n       then do\n              zwinttl = cmd\n              address 'ISPEXEC' 'ADDPOP ROW(9)'\n              address 'ISPEXEC' 'DISPLAY PANEL(CSHSETC) CURSOR(ZCMD)'\n              cc = rc\n              address 'ISPEXEC' 'REMPOP'\n            end\n       if cc = 0\n       then do\n              address 'TSO' cmd\n              cc = rc\n              if rc > 0\n              then   call Rc8_Display rc cmd\n              call WriteLog cc cmd\n            end\n     end\nelse do\n       address 'ISPEXEC' 'CONTROL DISPLAY SAVE'\n       address 'ISPEXEC' 'DISPLAY PANEL(CSHJCL) CURSOR(CACHOPT)'\n       cc = rc\n       address 'ISPEXEC' 'CONTROL DISPLAY RESTORE'\n       if cc = 8   /* End key was pressed - submit the job */\n       then do\n              address 'ISPEXEC' 'FTOPEN TEMP'\n              address 'ISPEXEC' 'FTINCL CSHSKEL1'\n              if rc > 0\n              then call Fail_Ftincl rc\n              address 'ISPEXEC' 'FTCLOSE'\n              if rc > 0\n              then call Fail_Ftclose rc\n              address 'ISPEXEC' 'VGET (ZTEMPF)'\n              address 'TSO' 'SUBMIT '''ztempf''''\n              cc = 0\n            end\n       else\n       if CACHOPT = 'SAVE'  /* save this JCL in a dataset  */\n       then do\n              address 'ISPEXEC' 'CONTROL DISPLAY SAVE'\n              address 'ISPEXEC' 'DISPLAY PANEL(CSHJCL01)'\n              cc = rc\n              address 'ISPEXEC' 'CONTROL DISPLAY RESTORE'\n              if cc = 0   /* Enter key pressed - save the JCL */\n              then do\n                     adsn = \"'\"adsn\"'\"\n                     address 'TSO' 'FREE  F(ISPFILE)'\n                     address 'TSO' 'ALLOC F(ISPFILE) DSN('ADSN') SHR'\n                     if rc = 12\n                     then address 'ISPEXEC' 'SETMSG MSG(CSHM016)'\n                     else do\n                            address 'ISPEXEC' 'FTOPEN'\n                            address 'ISPEXEC' 'FTINCL CSHSKEL1'\n                            if rc > 0\n                            then call Fail_Ftincl rc\n                          address 'ISPEXEC' 'FTCLOSE LIBRARY(ISPFILE) ,\n                                        NAME('CACHMBR')'\n                            if rc > 0\n                            then call Fail_Ftclose rc\n                           else address 'ISPEXEC' 'SETMSG MSG(CSHM019)'\n                            cc = 0\n                          end\n                   end\n            end\n       else cc = 4    /* I should never get here */\n     end\nreturn(cc)\n/*-------------------------------------------------------------------*/\n/*     Rc8_Display    starts here                                    */\n/*-------------------------------------------------------------------*/\nRc8_Display:\n/* Use a PopUp window to display the error messages from the IDCAMS  */\n/* functions.                                                        */\nprocedure expose oline.\narg Lretcode Ltitle\n\n   cc = lretcode\n   address 'ISPEXEC' 'TBCREATE ERRTB NAMES(XLINE) NOWRITE REPLACE'\n   do i = 1 to oline.0\n      xline = oline.i\n     address 'ISPEXEC' 'TBADD ERRTB'\n   end\n   address 'ISPEXEC' 'ADDPOP ROW(9)'\n   zwinttl = Ltitle\n   address 'ISPEXEC' 'TBTOP ERRTB'\n   address 'ISPEXEC' 'TBDISPL ERRTB PANEL(CSHERRP) CURSOR(ZCMD)'\n   address 'ISPEXEC' 'REMPOP'\n   address 'ISPEXEC' 'TBCLOSE ERRTB'\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     WriteLog       starts here                                    */\n/*-------------------------------------------------------------------*/\nWriteLog:\nprocedure expose cachlog oline.\narg Lretcode Lcmdline\n\n if CACHLOG = 'YES'\n then do\n        queue date('U') time() 'RC='right(Lretcode,2)  Lcmdline\n        address 'TSO' 'EXECIO 1 DISKW CACHLG'\n      end\n\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Fail_Ftincl    starts here                                    */\n/*-------------------------------------------------------------------*/\nFail_Ftincl:\narg Lretcode\n\nselect\n  when Lretcode = 8\n  then say 'Skeleton CSHSKEL1 does not exist'\n  when Lretcode = 12\n  then say 'Skeleton in use; ENQ failed'\n  when Lretcode = 16\n  then say 'Data trunc occurred or Skel lib or output lib not alloctd'\n  when Lretcode = 20\n  then say 'Severe error'\n  otherwise say 'RC ' Lretcode ' is not documented'\nend\n/*-------------------------------------------------------------------*/\n/*     Fail_Ftclose   starts here                                    */\n/*-------------------------------------------------------------------*/\nFail_Ftclose:\narg Lretcode\n\nselect\n  when Lretcode = 4\n  then say 'Member already exists in output lib and NOREPL specified'\n  when Lretcode = 8\n  then say 'File not open. FTOPEN was not used prior to FTCLOSE'\n  when Lretcode = 12\n  then say 'Output file in use; ENQ failed'\n  when Lretcode = 16\n  then say 'Skel lib or output lib not allocated'\n  when Lretcode = 20\n  then say 'Severe error'\n  otherwise say 'RC ' Lretcode ' is not documented'\nend\n\nreturn\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CACHEGRP": {"ttr": 261, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\r\\x005\\x00\\x95\\x04\\x1f\\x00\\x98\\x01/#\\x17\\x01 \\x00\\xd4\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "02.13", "flags": 0, "createdate": "1995-02-10T00:00:00", "modifydate": "1998-01-12T23:17:35", "lines": 288, "newlines": 212, "modlines": 0, "user": "CEB40"}, "text": "/*  rexx exec called by Amdahl Cache Utility to create select group  */\n/*  (C) COPYRIGHT AMDAHL CORPORATION  1995. All Rights Reserved      */\n/*  written:  February 1995                                          */\n/*  author :  Chuck Baumann                                          */\n/*  Panels :  CSHMAN8, CSHMAN9                                       */\n/*  Help   :  CSHHMAN8                                               */\n/*  Changes:  V1.0 -- Initial functions                              */\n/*  95/02/02  V2.3 -- Create a selection group                       */\n/*-------------------------------------------------------------------*/\narg odsn        /* name of table data set */\n\naddress 'ISPEXEC' 'TBQUERY MEMBTAB ROWNUM(ROWS) POSITION(CROW)'\nif rc = 12                    /* table not open              */\nthen call Modify_Old_Member   /* so display a list of members*/\nelse\n  do\n    address 'ISPEXEC' 'TBTOP MEMBTAB'\n    address 'ISPEXEC' 'TBDISPL MEMBTAB PANEL(CSHMAN8) CURSOR(MEMNAME)'\n    cc = rc\n\n    if memapp = 'Y'\n    then call Update_Existing_Member\n    else call Create_New_Member\n  end\nreturn\n\n/*------------------------------------------------------------------*/\n/*  Append to a  member in the table library for selection process. */\n/*  The existing member is copied to the new member and the selected*/\n/*  controllers are added to the old member.                        */\n/*------------------------------------------------------------------*/\nUpdate_Existing_Member:\n\ndo while cc < 8\n  newname = 'G' || memname   /* to identify groups in table lib */\n\n  sel = 'Y'\n  do while sel = 'Y'       /* ZTDSELS is the system variable which */\n    if ZTDSELS \u00ac= 0        /* contains a count of the number of    */\n    then                   /* lines that were modified in the table*/\n      do\n        user_comment = tcm             /* get new value from panel */\n        user_ssid    = tbssid\n        user_tbmdl   = tbmdl\n        user_address = tbu\n        address 'ISPEXEC' 'TBGET MEMBTAB'\n        tbssid = user_ssid\n        tbmdl  = user_tbmdl\n        tcm = user_comment\n        tbu = right(user_address,4,0)\n        taddr = x2d(tbu)\n        address 'ISPEXEC' 'TBPUT MEMBTAB'   /* update table */\n\n        if ZTDSELS = 1     /* processed last line with action */\n        then address 'ISPEXEC' 'SETMSG MSG(CSHM030) COND'\n\n        address 'ISPEXEC' 'TBDISPL MEMBTAB CURSOR(TCM)'\n        cc = rc\n      end\n    else sel = 'N'\n  end\n  if substr(ZCMD,1,3) = 'CAN' | cc = 8  /* CANCEL or PF3 */\n  then cc = 8                     /* just get out */\n  else do\n         address 'ISPEXEC' 'TBOPEN' newname 'WRITE'\n         if rc = 12\n         then say 'Enqueue failed for table' newname\n         else do\n                do rows\n                  address 'ISPEXEC' 'TBSKIP MEMBTAB'\n                  address 'ISPEXEC' 'TBGET MEMBTAB'\n                  address 'ISPEXEC' 'TBADD' newname\n                end\n                address 'ISPEXEC' 'TBCLOSE' newname\n                if rc = 0\n                then do\n                       address 'ISPEXEC' 'SETMSG MSG(CSHM031) COND'\n                       cc = 8       /* set so we can exit panel */\n                     end\n                else do\n                       address 'ISPEXEC' 'SETMSG MSG(CSHM037) COND'\n                       cc = 8       /* set so we can exit panel */\n                     end\n              end\n       end\nend\nreturn\n/*------------------------------------------------------------------*/\n/*  Create a new member in the table library for selection process. */\n/*  The user can add comments to each selected controller to help   */\n/*  identify why it is part of this selection member.               */\n/*------------------------------------------------------------------*/\nCreate_New_Member:\naddress 'ISPEXEC' 'TBTOP MEMBTAB'\ncc = 0\n\ndo while cc < 8\n/*\n  address 'ISPEXEC' 'TBDISPL MEMBTAB PANEL(CSHMAN8) CURSOR(MEMNAME)'\n  cc = rc\n*/\n  if memrep = 'Y'          /* replace duplicates */\n  then replace = 'REPLACE'\n  else replace = ''\n  newname = 'G' || memname   /* to identify groups in table lib */\n\n  sel = 'Y'\n  do while sel = 'Y'       /* ZTDSELS is the system variable which */\n    if ZTDSELS \u00ac= 0        /* contains a count of the number of    */\n    then                   /* lines that were modified in the table*/\n      do\n        user_comment = tcm             /* get new value from panel */\n        user_ssid    = tbssid\n        user_tbmdl   = tbmdl\n        user_address = tbu\n        address 'ISPEXEC' 'TBGET MEMBTAB'\n        tbssid = user_ssid\n        tbmdl  = user_tbmdl\n        tcm = user_comment\n        tbu = right(user_address,4,0)\n        taddr = x2d(tbu)\n        address 'ISPEXEC' 'TBPUT MEMBTAB'   /* update table */\n\n        if ZTDSELS = 1     /* processed last line with action */\n        then address 'ISPEXEC' 'SETMSG MSG(CSHM030) COND'\n\n        address 'ISPEXEC' 'TBDISPL MEMBTAB CURSOR(TCM)'\n        cc = rc\n      end\n    else sel = 'N'\n  end\n  if substr(ZCMD,1,3) = 'CAN' | cc = 8  /* CANCEL or PF3 */\n  then cc = 8                     /* just get out */\n  else do\n         address 'ISPEXEC' 'TBCREATE' newname ,\n                  'NAMES(TBMDL,TBSSID,TBU,TADDR,TCM) WRITE' replace\n         if rc = 8               /* table already exists-no replace */\n         then address 'ISPEXEC' 'SETMSG MSG(CSHM029) COND'\n         else\n         if rc = 12\n         then say 'Enqueue failed for table' newname\n         else do\n                do rows\n                  address 'ISPEXEC' 'TBSKIP MEMBTAB'\n                  address 'ISPEXEC' 'TBGET MEMBTAB'\n                  address 'ISPEXEC' 'TBADD' newname\n                end\n                address 'ISPEXEC' 'TBCLOSE' newname\n                if rc = 0\n                then do\n                       address 'ISPEXEC' 'SETMSG MSG(CSHM028) COND'\n                       cc = 8       /* set so we can exit panel */\n                     end\n              end\n       end\nend\nreturn\n/*------------------------------------------------------------------*/\n/*  User did not select any controllers for inclusion in a selection*/\n/*  member.  So show them a panel with a list of previously defined */\n/*  groups.                                                         */\n/*------------------------------------------------------------------*/\nModify_Old_Member:\ncmd = 'ENTER'\naddress 'ISPEXEC' 'DISPLAY PANEL(CSHMAN8) CURSOR(MEMNAME) COMMAND(CMD)'\naddress 'ISPEXEC' 'TBCREATE GRPTAB NAMES(ACT,MEMBR) NOWRITE REPLACE'\n/*------------------------------------------------------------------*/\n/*  Use outtrap to get output from LISTD xxx MEM command             */\n/*  This will add existing ctlrs to the new table                    */\n/*------------------------------------------------------------------*/\n  dummy = outtrap('gline.','*')\n\n  address 'TSO' 'LISTD' odsn 'MEM'\n  act = ''\n\n  do i = 7 to gline.0             /* first 6 lines are data set info */\n    mname = strip(gline.i,'B',' ')\n    if substr(mname,1,1) = 'G'\n    then do\n           membr = substr(mname,2,length(mname)-1)\n           address 'ISPEXEC' 'TBADD GRPTAB'\n         end\n  end\n  address 'ISPEXEC' 'ADDPOP ROW(6)'\n  zwinttl = 'Existing Selection Group Members'\n  address 'ISPEXEC' 'TBTOP GRPTAB'\n  selmem = ''\n\n  do while rc < 8\n    address 'ISPEXEC' 'TBDISPL GRPTAB PANEL(CSHGRPL) CURSOR(ACT)'\n    sel = 'Y'\n    do while sel = 'Y'\n      if ZTDSELS \u00ac= 0\n      then do\n             selmem = membr\n             address 'ISPEXEC' 'TBDISPL GRPTAB'\n           end\n      else sel = 'N'\n    end\n    if ZCMD = 'L'\n    then do\n           membr = LOCATE||'*'\n           address 'ISPEXEC' 'TBSCAN GRPTAB ARGLIST(MEMBR)' ,\n                   'CONDLIST(GE) ROWID(LOCROW)'\n           if rc = 0\n           then do\n                  address 'ISPEXEC' 'TBTOP GRPTAB'\n                  address 'ISPEXEC' 'TBSKIP GRPTAB ROW('locrow')'\n                end\n           else\n           if rc = 8\n           then do\n                  address 'ISPEXEC' 'TBBOTTOM GRPTAB'\n                  rc = 0\n                end\n         end\n  end\n\n  address 'ISPEXEC' 'REMPOP'\n  address 'ISPEXEC' 'TBCLOSE GRPTAB'\n\n  if selmem \u00ac= ''\n  then do\n         realmem = 'G' || selmem\n         memname = selmem\n         address 'ISPEXEC' 'TBOPEN' realmem\n         if rc = 12\n         then do\n                address 'ISPEXEC' 'TBCLOSE' realmem\n                address 'ISPEXEC' 'TBOPEN' realmem\n              end\n         address 'ISPEXEC' 'TBSORT' realmem 'FIELDS(TADDR,N,A)'\n         address 'ISPEXEC' 'TBTOP' realmem\n         call Process_Members\n         address 'ISPEXEC' 'TBCLOSE' realmem\n       end\nreturn\n\nProcess_Members:\n  do while rc < 8\n    address 'ISPEXEC' 'TBDISPL' realmem 'PANEL(CSHMAN9) CURSOR(TCM)'\n    sel = 'Y'\n    do while sel = 'Y'\n      if ZTDSELS \u00ac= 0\n      then do\n             if ACT = ' '\n             then do\n                    user_ssid    = tbssid\n                    user_tbmdl   = tbmdl\n                    user_address = tbu\n                    user_comment = tcm\n                    address 'ISPEXEC' 'TBGET' realmem\n                    tbssid = user_ssid\n                    tbmdl  = user_tbmdl\n                    tcm = user_comment\n                    tbu = right(user_address,4,0)\n                    taddr = x2d(tbu)\n                    address 'ISPEXEC' 'TBPUT' realmem\n                    if rc = 0\n                    then address 'ISPEXEC' 'SETMSG MSG(CSHM031) COND'\n                    else address 'ISPEXEC' 'SETMSG MSG(CSHM032) COND'\n                  end\n             else\n             if ACT = 'I' | ACT = 'A'\n             then do\n                    tcm = ''\n                    tbu = right(tbu,4,0)\n                    tbmdl = '3990'\n                    tbssid = ''\n                    taddr = 0\n                    address 'ISPEXEC' 'TBADD' realmem\n                    if rc = 0\n                    then address 'ISPEXEC' 'SETMSG MSG(CSHM031) COND'\n                    else address 'ISPEXEC' 'SETMSG MSG(CSHM032) COND'\n                  end\n             if ACT = 'D'\n             then do\n                    address 'ISPEXEC' 'TBDELETE' realmem\n                    if rc = 0\n                    then address 'ISPEXEC' 'SETMSG MSG(CSHM031) COND'\n                    else address 'ISPEXEC' 'SETMSG MSG(CSHM032) COND'\n                  end\n             address 'ISPEXEC' 'TBDISPL' realmem 'CURSOR(ACT)'\n           end\n      else sel = 'N'\n    end\n  end\nreturn\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CACHEMAN": {"ttr": 20, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x04\\x00V\\x00\\x95\\x04\\x1f\\x00\\x95 _\\x105\\x00\\x1e\\x00\\x17\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "02.04", "flags": 0, "createdate": "1995-02-10T00:00:00", "modifydate": "1995-07-24T10:35:56", "lines": 30, "newlines": 23, "modlines": 0, "user": "CEB40"}, "text": "/*  rexx exec to drive Cacheman Cache  Dialog -----------------------*/\n/*  (C) COPYRIGHT AMDAHL CORPORATION  1995. All Rights Reserved      */\n/*  written:  January 1994                                           */\n/*  author :  Chuck Baumann                                          */\n/*  Panels :  CSHMAN1 CSHMAN2 CSHMAN3 CSHOPT                         */\n/*  Help   :  CSHHMAN1 CSHHMN11 CSHHMN12 CSHHMAN2 CSHHMAN3 CSHHOPT   */\n/*  Externs:  CASHMAN, DEVTYPE, SLEEP (assembler modules)            */\n/*  Message:  CSHM00, CSHM01, CSHM02                                 */\n/*  Changes:                                                         */\n/*-------------------------------------------------------------------*/\n/*-------------------------------------------------------------------*/\n/*  If invoked from TSO use ISPSTART to set up necessary environment.*/\n/*  NEWAPPL keeps profle variables from this application separate.   */\n/*  As of 02/1995 the only valid parm is RESET.  It will override    */\n/*  the test for split screen active and CACHEMAN active.  The       */\n/*  variable used to indicate that Cacheman is active is left on if  */\n/*  Cacheman abnormally terminates.  If the user then tries to invoke*/\n/*  it again while split screen is active they will get the message  */\n/*  NOT ALLOWED.  The only previous recourse was to exit one of the  */\n/*  split screen sessions prior to invoking Cacheman. Now you can    */\n/*  just invoke it by entering  'CACHEMAN RESET'.     This does NOT  */\n/*  mean that CACHEMAN will work in two different logical sessions.  */\n/*-------------------------------------------------------------------*/\narg parm\n\nif sysvar('SYSISPF') \u00ac= 'ACTIVE'\nthen   'ISPSTART CMD(%CACHEMN0' parm') NEWAPPL(CACH)'\nelse   address 'ISPEXEC' 'SELECT CMD(%CACHEMN0' parm') NEWAPPL(CACH)'\n\nexit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CACHEMN0": {"ttr": 22, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x04\\x00\\x05\\x00\\x95\\x04\\x1f\\x00\\x95 _\\x106\\x00\\x1b\\x00\\x1a\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "02.04", "flags": 0, "createdate": "1995-02-10T00:00:00", "modifydate": "1995-07-24T10:36:05", "lines": 27, "newlines": 26, "modlines": 0, "user": "CEB40"}, "text": "/*  rexx exec to call Cachemn1 exec ---------------------------------*/\n/*  (C) COPYRIGHT AMDAHL CORPORATION  1995. All Rights Reserved      */\n/*  written:  January 1995                                           */\n/*  author :  Chuck Baumann                                          */\n/*  Descr  :  Load modules invoked via ISPEXEC SELECT PGM or ISPEXEC */\n/*            SELECT CMD must issue VDEFINEs for variables that are  */\n/*            manipulated.  Since Rexx cannot issue VDEFINEs it must */\n/*            be invoked via a call statement.                       */\n/*            This was done to make it possible to compile the execs.*/\n/*-------------------------------------------------------------------*/\narg parm\n/*-------------------------------------------------------------------*/\n/* Change the dataset names in the next 4 lines to point to the name */\n/* of the restored datasets.                                         */\n/*-------------------------------------------------------------------*/\naddress 'ISPEXEC' \"LIBDEF ISPPLIB DATASET ID('CEB40.V24.ACU.ISPPLIB')\"\naddress 'ISPEXEC' \"LIBDEF ISPMLIB DATASET ID('CEB40.V24.ACU.ISPMLIB')\"\naddress 'ISPEXEC' \"LIBDEF ISPSLIB DATASET ID('CEB40.V24.ACU.ISPSLIB')\"\naddress 'ISPEXEC' \"LIBDEF ISPLLIB DATASET ID('CEB40.V24.ACU.ISPLLIB')\"\n\ncall Cachemn1 parm\n\naddress 'ISPEXEC' 'LIBDEF ISPPLIB'\naddress 'ISPEXEC' 'LIBDEF ISPMLIB'\naddress 'ISPEXEC' 'LIBDEF ISPSLIB'\naddress 'ISPEXEC' 'LIBDEF ISPLLIB'\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CACHEMN1": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x03\\x00\\x97\\x08?\\x00\\x991o\\t\\x04\\x08\\xde\\x08\\xb5\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1997-03-24T00:00:00", "modifydate": "1999-11-12T09:04:03", "lines": 2270, "newlines": 2229, "modlines": 0, "user": "CEB40"}, "text": "/*  rexx exec to drive Amdahl Cache Utility   -----------------------*/\n/*  (C) COPYRIGHT AMDAHL CORPORATION  1995. All Rights Reserved      */\n/*  written:  January 1994                                           */\n/*  author :  Chuck Baumann                                          */\n/*  Panels :  CSHMAN1 CSHMAN2 CSHMAN3 CSHMAN4 CSHMAN5 CSHMAN6 CSHOPT */\n/*  Panels :  CSHPERF                                                */\n/*  Help   :  CSHHMAN1 CSHHMN11 CSHHMN12 CSHHMAN2 CSHHMAN3 CSHHOPT   */\n/*  Externs:  CASHMAN, DEVTYPE, SLEEP (assembler modules)            */\n/*  Message:  CSHM00, CSHM01, CSHM02                                 */\n/*  Changes:  V1.0 -- Initial functions                              */\n/*  94/02/02  V1.1 -- Libdef support added, SaveJCL bug fixed        */\n/*  94/02/09          Retain table position, NVS help, NVS status    */\n/*  94/02/09          Err msg to indicate blank volser for online dev*/\n/*  94/02/10          Add Status to device panel to brws subsys stat */\n/*  94/02/10          Correct = to continue if stat is already set   */\n/*  94/02/10          Code to prevent split screen multiple sessions.*/\n/*  94/06/07  V1.2 -- Code added to include model number on dev panl.*/\n/*  94/06/07          Bug corrected for controller CFW status.       */\n/*  94/06/08          Code modified to parse 3880 report correctly.  */\n/*  94/06/08          Code added to reset tables following abend.    */\n/*  94/06/16  V1.2a - Typo corrected on TBCREATE SMSTAB              */\n/*  94/06/16          LIBDEF statements moved to beginning of EXEC   */\n/*  94/06/16          LIBDEF added for ISPTLIB and ISPTABL           */\n/*  94/06/16          Duplex logic corrected(dual copy)              */\n/*-------------------------------------------------------------------*/\n/*                    3880 corrections                               */\n/*  94/06/27          Parse logic changed for 3880 controllers       */\n/*  94/07/05          3880 device recognition logic updated          */\n/*  94/07/05          3880 device refresh     logic updated          */\n/*-------------------------------------------------------------------*/\n/*  94/07/21  V1.3  - Enhanced logic to handle blank volsers         */\n/*  94/07/21          Improved error messages for table failures     */\n/*  94/07/25          Changed to allocate (libdef) unique table dsn  */\n/*  94/07/25          Call to clean_up added prior to any exit       */\n/*  94/08/13          Chng to pin data detection due to IBM omission.*/\n/*  94/09/07          Moved model lookup from DEVTYPE to CACHEMN1    */\n/*                    (user can add new models to Lookup_Model)      */\n/*                    (or change how model is displayed)             */\n/*  94/10/19          Added common procedure to execute commands     */\n/*-------------------------------------------------------------------*/\n/*  94/10/22  V2.0  - Added logic/screens to display cache performnce*/\n/*                    statistics. (delta of stop - start)            */\n/*                    Can display stats in foreground or background. */\n/*  94/11/08          Correct sorting order for 3990 devices.        */\n/*  94/11/29  V2.1  - Correct errors in Cache Write algorithms.      */\n/*                    Modify panel field edits for cache perf window.*/\n/*                    Modify Options logic to recognize new values.  */\n/*  94/12/01          Modify logic to correct missing controller due */\n/*                    to Rexx exponential interpretation.            */\n/*  94/12/07  V2.2  - Return error codes from DEVTYPE and display msg*/\n/*  95/01/03          Correct logic for HITS option not recognized   */\n/*  95/01/03          HAPPY BIRTHDAY CACHEMAN ( 1 year old)          */\n/*  95/01/14          Correct logic for initializing VERDEV & VERCTL */\n/*-------------------------------------------------------------------*/\n/*  95/01/20  V2.3  - Add Hits logic to Device panel                 */\n/*  95/01/20          Add logging of calls to DEVTYPE                */\n/*  95/01/20          Add undocumented commands to query usage detail*/\n/*  95/01/20          SMF IEFU84 will be bundled (optional)          */\n/*  95/01/22          DCACHE command added                           */\n/*  95/01/22          Moved code to check ZCMD to common procedure   */\n/*  95/01/22          Wrote new exec Cachemn0/compiled Rexx loadmods */\n/*  95/01/22          Moved main LIBDEFS to CACHEMN0                 */\n/*  95/01/25          Changed duplex pair to report CCA & not DDC    */\n/*  95/02/01          Modify REFRESH logic to update device panel    */\n/*  95/02/02          EXCEPT command added (exceptional conditions)  */\n/*  95/02/02          Add logic to invoke CACHEMAN RESET (split scr) */\n/*  95/02/02          Add logic to invoke WHAT's NEW panel           */\n/*  95/02/03          Modify some 3880 logic for condition codes.    */\n/*  95/02/04          Expose options values so they are updated.     */\n/*  95/02/09          Add selection by Group (user defined groups).  */\n/*  95/02/09          Created CACHEGRP exec for selection groups.    */\n/*  95/03/14          Correct bug with testing of tbchan for selctn. */\n/*-------------------------------------------------------------------*/\n/*  95/04/03  V2.4  - Add logic to disable logging when log file full*/\n/*  95/05/01          Made hilevel_qual a global var for alloc dsns. */\n/*  95/05/30          Added SORT primary command for Ctlr panel.     */\n/*  95/06/26          Changed Lookup_Model to use MDR devtype code   */\n/*                    from DCE of UCB (don't need to alloc volume)   */\n/*  95/07/10          Correct bug for display of Configured Cach stg */\n/*-------------------------------------------------------------------*/\n/*  95/09/07  V2.41 - Add logic to report SS stg and NVS stg correct */\n/*                    from 3990-6 enhanced mode controller           */\n/*  96/02/15          Expand field for NVS storage to 4 bytes        */\n/*-------------------------------------------------------------------*/\n/*  97/03/24  V2.42 - Expand field for NVS storage to 5 bytes (9999M)*/\n/*-------------------------------------------------------------------*/\n/*  97/08/06  V2.43 - Configured storage reported in bytesK          */\n/*                    convert to bytes and then do normal processing */\n/*-------------------------------------------------------------------*/\n/*  98/01/12  V2.44 - Corrected logic for storage in bytesK          */\n/*                    convert to bytes and then do normal processing */\n/*                    Add logic to allow append to existing groups   */\n/*                    (for members containing controllers on more    */\n/*                     than one screen)                              */\n/*-------------------------------------------------------------------*/\narg parm\n\nhold_msg = msg('OFF')      /* turn off messages while exec is running*/\nsorted = 'N'\n/*-------------------------------------------------------------------*/\n/* Version of exec    (displayed in title of panels)                 */\n/*        Change to identify which version is being used             */\n/*-------------------------------------------------------------------*/\naddress 'ISPEXEC' 'VGET (VERS) PROFILE'\nprior_version = vers       /* Will test to see if first time new rlse*/\nvers  = 'V2.44'            /* Ver of Cacheman(displayed on panels)   */\nvdate = '99/11/12'         /* Date of last update */\naddress 'ISPEXEC' 'VPUT (VERS) PROFILE'\n\nsignal on HALT             /* Trap PA1/ATTN keys */\n\n/*-------------------------------------------------------------------*/\n/*  allocate a unique table dataset for each Cacheman user           */\n/*  This prevents an enqueue failure if two users are using Cacheman */\n/*  at the same time.  The table dataset is used to save data that   */\n/*  will be displayed on the screen.                                 */\n/*-------------------------------------------------------------------*/\n\nuserid = sysvar(sysuid)         /* used in Query_Info panel */\nhilevel_qual = userid\n\ntdsn  = \"'\"hilevel_qual\".CACHEMAN.ISPTABL'\"\ntbl_exists = sysdsn(tdsn)\nif tbl_exists = 'DATASET NOT FOUND'\nthen do\n       address 'TSO' 'FREE FI(CACHTMP)'\n       address 'TSO' 'ALLOC FI(CACHTMP) DA('tdsn') ,\n       NEW CATALOG TRACKS SPACE(3,1) DIR(5) RECFM(F,B) LRECL(80) ,\n       BLKSIZE(6160)'\n       if rc > 0\n       then do\n              say 'Allocation of a table dataset failed.'\n              say 'DSN= 'tdsn\n              say 'Correct problem or manually allocate ' tdsn\n              say 'and then re-invoke the exec'\n              call Clean_up\n              return\n            end\n       address 'TSO' 'FREE FI(CACHTMP)'\n     end\naddress 'ISPEXEC' \"LIBDEF ISPTLIB DATASET ID(\"tdsn\")\"\naddress 'ISPEXEC' \"LIBDEF ISPTABL DATASET ID(\"tdsn\")\"\n\n/*-------------------------------------------------------------------*/\n/* Check variable in profile pool to tst if this application is      */\n/* already active on another logical screen.                         */\n/* If YES and split screen is active, then disallow second invocation*/\n/*-------------------------------------------------------------------*/\naddress 'ISPEXEC' 'VGET (ZSPLIT) SHARED'\naddress 'ISPEXEC' 'VGET (CACHACT,CACHUSE) PROFILE'\nif cachact = 'YES' & zsplit = 'YES' & parm \u00ac= 'RESET'\nthen do\n       address 'ISPEXEC' 'SETMSG MSG(CSHM018) COND'\n       return\n     end\nelse do\n       if datatype(cachuse) = 'NUM'\n       then cachuse = cachuse + 1\n       else cachuse = 1\n       cachact = 'YES'\n       address 'ISPEXEC' 'VPUT (CACHACT,CACHUSE) PROFILE'\n     end\n/*-------------------------------------------------------------------*/\n/* if user's profile version is different from value in this exec it */\n/* must be the first time the user is using this new release. Tell   */\n/* them what is new in this release. (will also be true if users     */\n/* profile is somehow deleted)                                       */\n/*-------------------------------------------------------------------*/\nif prior_version \u00ac= vers\nthen do\n       address 'ISPEXEC' 'DISPLAY PANEL(CSHWNEW) CURSOR(ZCMD)'\n     end\n\n/*-------------------------------------------------------------------*/\n/* Return ERRORs to the dialog for handling                          */\n/* Close all tables (even if not open) in case of previous abend     */\n/*-------------------------------------------------------------------*/\naddress 'ISPEXEC' 'CONTROL ERRORS RETURN'\naddress 'ISPEXEC' 'TBCLOSE EXCEPT'\naddress 'ISPEXEC' 'TBCLOSE MEMBTAB'\naddress 'ISPEXEC' 'TBCLOSE VOLTABLE'\naddress 'ISPEXEC' 'TBCLOSE SSGTAB'\naddress 'ISPEXEC' 'TBCLOSE CHTTAB'\naddress 'ISPEXEC' 'TBCLOSE CSTTABLE'\naddress 'ISPEXEC' 'TBCLOSE DEVTAB'\naddress 'ISPEXEC' 'TBCLOSE SMSTAB'\n/*-------------------------------------------------------------------*/\n/* Get option variables from the profile pool.  If they don't already*/\n/* exist display the option panel so user can set (CSHOPT)           */\n/*-------------------------------------------------------------------*/\n\naddress 'ISPEXEC' 'VGET (CACHVW CACHLOG CACHREF CACHST CACHSCNT ,\n       CACHSPIN CACHSRAT CACHMB CACHSDV CACHDSTG CACHDCNT CACHDPIN ,\n       CACHDSUB CACHDDUP ATCACH ATCFW ATNVS CACHCNF CACHXCP) PROFILE'\nif rc \u00ac= 0\nthen call Set_Options\nelse call Set_Verifies\n\n/*-------------------------------------------------------------------*/\n/* Was logging requested in options? If yes then allocate a new or   */\n/* existing log file of format sysuid.CACHE.LOG.                     */\n/*-------------------------------------------------------------------*/\n\nif CACHLOG = 'YES'\nthen do\n       ldsn  = \"'\"hilevel_qual\".CACHE.LOG'\"\n       log_exists = sysdsn(ldsn)\n       if log_exists = 'OK'\n       then do\n              address 'TSO' 'ALLOC FI(CACHLG) DA('ldsn') MOD KEEP'\n              if rc > 0\n              then do\n                     CACHLOG = 'NO'\n                     emsg = 'CSHM005' /* logfile alloc fail */\n                   end\n            end\n       else do\n              cmd = 'ALLOC FI(CACHLG) DA(' || ldsn || ') NEW '\n              cmd = cmd 'CATALOG TRACKS SPACE(3,3) RECFM(F,B) '\n              cmd = cmd 'BLKSIZE(6160)'\n              address 'TSO' cmd\n              if rc > 0\n              then do\n                     CACHLOG = 'NO'\n                     emsg = 'CSHM005' /* logfile alloc fail */\n                   end\n            end\n       queue date('U') time() '********* New Session **********'\n       address 'TSO' 'EXECIO 1 DISKW CACHLG'\n     end\n\n\n/*-------------------------------------------------------------------*/\n/* Save the value of the PFKEY selected for refreshing the screen    */\n/* so it can be restored to the original value on exit.              */\n/* Terminals with 12 PFKEYS still use the variables 13-24 to handle  */\n/* the settings.                                                     */\n/*-------------------------------------------------------------------*/\naddress 'ISPEXEC' 'VGET (CACHREF,ZKEYS) PROFILE'\n\npfk_num = cachref\nif pfk_num < 13 & zkeys = 12\nthen pfk_num = cachref + 12\n\npfkey = 'ZPF'||right(pfk_num,2,'0')\n\naddress 'ISPEXEC' 'VGET ('pfkey') PROFILE'\nsaved_pfk = value(pfkey)\ninterpret pfkey '= ''REF'''\naddress 'ISPEXEC' 'VPUT ('pfkey') PROFILE'\n\n/*-------------------------------------------------------------------*/\n/*  Use outtrap to get output from LISTDATA commands                 */\n/*-------------------------------------------------------------------*/\n  dummy = outtrap('rline.','*','NOCONCAT')\n\n  grplist = '\u00a2'                   /* initialize with attrib char   */\n  vergrp  = ''\n\n  address 'TSO' 'LISTD' tdsn 'MEM'\n\n  do i = 7 to rline.0             /* first 6 lines are data set info */\n    member = strip(rline.i,'B',' ')\n    if substr(member,1,1) = 'G'\n    then do\n           name = substr(member,2,length(member)-1)\n           vergrp = vergrp || ',' || name\n           grplist = grplist left(name,9)\n         end\n  end\n  vergrp = strip(vergrp,'L',',')        /* get rid of the leading , */\n  address 'ISPEXEC' 'VPUT (GRPLIST,VERGRP) SHARED'\n/*-------------------------------------------------------------------*/\n/* Create table of every req online dasd. This will be used to issue */\n/* the LISTDATA cmds to build a table w/status of each unique subsys */\n/* Cashman is an assembler routine that displays a panel to allow    */\n/* selected volsers or unit addresses to be included in the table it */\n/* constructs (VOLTAB).  This table will be used to select contrlrs  */\n/* to be displayed on main panel.                                    */\n/*-------------------------------------------------------------------*/\ndo forever     /* this loop is exited when PF3 is entered in CASHMAN */\n  saved_ssid = 0            /*--Initialized variables--*/\n  new_tbssst = ''           /*--Initialized variables--*/\n  new_tbsdst = ''           /*--Initialized variables--*/\n  new_tbnvst = ''           /*--Initialized variables--*/\n  emsg       = ''           /*--Initialized variables--*/\n  grpname    = ''\n\n  address 'ISPEXEC' 'SELECT PGM(CASHMAN)'\n  if rc = 8             /* PF3 was pressed on selection panel */\n  then do\n         call Clean_up\n         return\n       end\n\n  address 'ISPEXEC' 'VGET (GRPNAME) SHARED'\n  if grpname \u00ac= ''\n  then do\n         member = 'G' || grpname\n         address 'ISPEXEC' 'TBOPEN' member\n         if rc \u00ac= 0\n         then do\n                grpname = ''\n                ctlr.0 = 0\n                address 'ISPEXEC' 'SETMSG MSG(CSHM033) COND'\n              end\n         else do\n                rows = 0\n                address 'ISPEXEC' 'TBSORT' member 'FIELDS(TADDR,N,A)'\n                address 'ISPEXEC' 'TBQUERY' member 'ROWNUM(ROWS)'\n                if rows = 0\n                then grpname = ''\n                else ctlr.0 = rows\n                do i = 1 to rows\n                  address 'ISPEXEC' 'TBSKIP' member\n                  address 'ISPEXEC' 'TBGET' member\n                  ctlr.i = tbu\n                end\n                address 'ISPEXEC' 'TBCLOSE' member\n              end\n       end\n\n/*-------------------------------------------------------------------*/\n/*  Subsystem Storage Table will contain all information shown on    */\n/*  Controller panel.                                                */\n/*-------------------------------------------------------------------*/\n  address 'ISPEXEC' 'TBCREATE SSGTAB ,\n  NAMES(TBMDL,TBSSID,TBSSSTG,TBSSAVL,TBNVSAVL,TBNVSSTG,TBSSST,TBSDST, ,\n       TBNVST,TBV,TBU,TBDTYP,TBPIN,TBOFF,TBUD,TBSSIDD) NOWRITE REPLACE'\n  if rc > 4\n  then do\n         say 'Creation of subsystem table SSGTAB failed - rc = ' rc\n         call Clean_up\n         return\n       end\n\n/*-------------------------------------------------------------------*/\n/*  Issue the LISTDATA commands for each unique entry in the VOLTABLE*/\n/*-------------------------------------------------------------------*/\n  address 'ISPEXEC' 'TBOPEN VOLTABLE NOWRITE SHARE'\n  if rc \u00ac= 0\n  then do\n         say 'Open of volser table VOLTABLE failed - rc = ' rc\n         call Clean_up\n         return\n       end\n  address 'ISPEXEC' 'TBQUERY VOLTABLE ROWNUM(ROWS)'\n\n  old_addr = 0\n  i = 1\n  do rows\n     address 'ISPEXEC' 'TBSKIP VOLTABLE'  /* position to next line   */\n     address 'ISPEXEC' 'TBGET  VOLTABLE'  /* read row from table     */\n     addr = substr(tbchan,1,3)            /* compare first 3 digits  */\n     d_addr = x2d(addr)                   /* because 0Ex is exponent */\n     if grpname \u00ac= ''\n     then if x2d(substr(ctlr.i,1,3)) \u00ac= d_addr\n          then iterate\n          else if i < ctlr.0\n               then i = i + 1\n\n     if d_addr \u00ac= old_addr                /* probably new controller */\n     then do\n            old_addr = d_addr\n            call List_Stat TBVOL TBDEVT 'TBADD' TBCHAN\n          end\n  end\n\n  address 'ISPEXEC' 'TBCLOSE VOLTABLE'\n\n  if rows = 0             /* if voltable had no entries */\n  then do\n         address 'ISPEXEC' 'SETMSG MSG(CSHM010) COND'\n         rc = 8           /* this will exit gracefully w/no panel */\n       end\n  if CACHXCP = 'YES'      /* CACHXCP set on OPTions panel         */\n  then call Cachxcpt      /* can also use EXCEPT command to see   */\n\n  select_group = 0\n\n/*-------------------------------------------------------------------*/\n/*  Display PANEL until PF3 or END command issued                    */\n/*-------------------------------------------------------------------*/\n  do while rc < 8\n    if datatype(ZTDTOP) = 'NUM' & sorted = 'N'\n    then do\n           address 'ISPEXEC' 'TBTOP SSGTAB'\n           address 'ISPEXEC' 'TBSKIP SSGTAB ROW('ZTDTOP')'\n         end\n    sorted = 'N'\n    pan  = 'CSHMAN1'\n\n    if emsg = ''\n    then address 'ISPEXEC' 'TBDISPL SSGTAB PANEL('pan') CURSOR(ACT)'\n    else address 'ISPEXEC' 'TBDISPL SSGTAB PANEL('pan') CURSOR(ACT) ,\n         MSG('emsg')'\n    if rc > 8\n    then do\n           say 'Table display failed - panel or message was not found'\n           say 'Panel = ' pan   'Emsg = ' emsg\n           call Clean_up\n           return\n         end\n\n    emsg = ''\n    sel = 'Y'\n\n    first_member = 1\n    do while sel = 'Y'       /* ZTDSELS is the system variable which */\n      if ZTDSELS \u00ac= 0        /* contains a count of the number of    */\n      then                   /* lines that were modified in the table*/\n        do\n          select\n\n            when ACT = CACHST\n            then do\n                   cmdl = 'LISTDATA STATUS VOL('TBV') UNIT('TBDTYP')'\n                   call Execute_Cmd 4\n                   if result < 5\n                   then call Browse_Tmp\n                 end\n\n            when ACT = CACHSCNT\n            then do\n                   cmdl = 'LISTDATA COUNTS VOL('TBV')'\n                   cmdl = cmdl || ' UNIT('TBDTYP') SUBSYSTEM'\n                   call Execute_Cmd 4\n                   if result < 5\n                   then call Browse_Tmp\n                 end\n\n            when ACT = CACHMB     /* add to a select group */\n            then do\n                   select_group = 1\n                   taddr = x2d(tbu)\n                   if first_member\n                   then do\n                          first_member = 0\n                          address 'ISPEXEC' 'TBCREATE MEMBTAB ,\n                            NAMES(TBMDL,TBSSID,TBU,TADDR,TCM) ,\n                            NOWRITE REPLACE'\n                          address 'ISPEXEC' 'TBADD MEMBTAB'\n                        end\n                   else do\n                          address 'ISPEXEC' 'TBADD MEMBTAB'\n                        end\n                 end\n\n            when ACT = CACHSRAT\n            then do\n                   if tbmdl = '3880'\n                   then emsg = 'CSHM020' /* not valid cmd 3880 */\n                   else do\n                          call Confirm_CachPerf\n                          if result = 0\n                          then\n                            do\n                              rtype = 'SUBSYSTEM'\n                              address 'ISPEXEC' 'VGET (CMODE) PROFILE'\n                      address 'ISPEXEC' 'VGET (SAMPTIME,NUMINT) SHARED'\n                              if cmode = 'F'  /* do it foreground */\n                              then\n                                do\n                                  cmdl = 'LISTDATA COUNTS VOL('TBV')'\n                             cmdl = cmdl || ' UNIT('TBDTYP') SUBSYSTEM'\n                                  call Execute_Cmd 0\n                                  if result = 0\n                                  then call Get_Cache_Rates ,\n                                            rtype tbv tbdtyp\n                                end\n                              else\n                              if cmode = 'B'  /* do it in batch   */\n                              then call Batch_CachPerf\n                            end\n                        end\n                 end\n\n            when ACT = CACHSDV\n            then do\n                   call Get_Dev_Info TBV TBDTYP\n                   call Dev_Process\n                   address 'ISPEXEC' 'TBCLOSE DEVTAB'\n                 end\n/*---------------------------------------------------------------*/\n/* if ACT is blank, the user modified some field to change the   */\n/* status of cache or NVS.  Save the three input fields and 'get'*/\n/* the original row.  Compare the values to see which changed    */\n/* and then issue the correct SETCACHE command.                  */\n/*---------------------------------------------------------------*/\n            when ACT = ' '\n            then do\n                   new_tbssst = tbssst\n                   new_tbsdst = tbsdst\n                   new_tbnvst = tbnvst\n                   call Bld_Setcache_Cmd\n                 end\n/*---------------------------------------------------------------*/\n/* if ACT is '=', the user wants to make the same changes to the */\n/* status of cache or NVS for another controller. Check to see   */\n/* if a valid change was made first.  Then apply the same changes*/\n/* to the new controller.                                        */\n/*---------------------------------------------------------------*/\n            when ACT = '='\n            then do\n                   if new_tbssst \u00ac= '' ,\n                    | new_tbsdst \u00ac= '' ,\n                    | new_tbnvst \u00ac= ''\n                   then call Bld_Setcache_Cmd\n                   else emsg = 'CSHM004'   /* no change to repeat */\n                 end\n\n            when ACT = CACHSPIN\n            then do\n                   if tbmdl = '3880'\n                   then emsg = 'CSHM020' /* not valid cmd 3880 */\n                   else do\n                          rline.0 = 0  /* problem w/outtrap*/\n                          cmdl = 'LISTDATA PINNED VOL('TBV')'\n                          cmdl = cmdl || ' UNIT('TBDTYP') SUBSYSTEM'\n                          call Execute_Cmd 4\n                          if result = 4 & rline.0 = 0\n                          then emsg = 'CSHM012'\n                          else call Browse_Tmp\n                        end\n                 end\n\n            when ACT = CACHDSTG\n            then do\n                   if tbmdl = '3880'\n                   then emsg = 'CSHM020' /* not valid cmd 3880 */\n                   else do\n                          call Confirm_Destage\n                          if result \u00ac= 0\n                          then nop\n                          else do\n                                 setc_cmd = 'DESTAGE'\n                                 call Exec_Setcache tbv setc_cmd\n                               end\n                        end\n                 end\n\n            otherwise nop\n          end\n          if ZTDSELS = 1     /* processed last line with action */\n          then if select_group  /* user has selected controllers */\n               then do          /* to create a selection group   */\n                      address 'ISPEXEC' 'CONTROL DISPLAY SAVE'\n\n                      call 'CACHEGRP' tdsn\n\n                      address 'ISPEXEC' 'CONTROL DISPLAY RESTORE'\n                      address 'ISPEXEC' 'TBCLOSE MEMBTAB'\n                      select_group = 0\n                      first_member = 1\n                    end\n/*---------------------------------------------------------------*/\n/* A TBDISPL with no panel parameter will decrement the value    */\n/* of ZTDSELS (selected/modified lines) by one and position the  */\n/* table to the next corresponding record.                       */\n/*---------------------------------------------------------------*/\n          if emsg = ''\n          then address 'ISPEXEC' 'TBDISPL SSGTAB CURSOR(ACT)'\n          else address 'ISPEXEC' 'TBDISPL SSGTAB CURSOR(ACT) ,\n               MSG('emsg')'\n          emsg = ''\n        end\n      else sel = 'N'\n    end\n\n    call Process_ZCMD 'CTL'\n  end\n\n  address 'ISPEXEC' 'TBCLOSE SSGTAB'\nend\n\ncall Clean_up\nreturn\n\n/*-------------------------------------------------------------------*/\n/*-------------------------------------------------------------------*/\n/*     SUBROUTINES start here                                        */\n/*-------------------------------------------------------------------*/\n/*-------------------------------------------------------------------*/\n/*     Execute_Cmd    starts here                                    */\n/*     Common logic to issue the actual LISTDATA cmd and test retcd. */\n/*-------------------------------------------------------------------*/\nExecute_Cmd:\narg expected_rc\n\n  address 'TSO' cmdl\n  cc = rc\n  if rc > expected_rc\n  then do\n         call Rc8_Display rc cmdl\n         rc = 0\n       end\n  call WriteLog cc cmdl\nreturn(cc)\n/*-------------------------------------------------------------------*/\n/*     Dev_Process    starts here                                    */\n/*     Logic to handle mods to devices on device panel               */\n/*-------------------------------------------------------------------*/\nDev_Process:\nprocedure expose tbmdl tbssst tbsdst tbnvst cachlog cachst cachsdv ,\n   cachspin cachscnt cachdstg cachdcnt cachdpin cachddup cachdsub ,\n   cachsrat new_thcach new_thdfw emsg rline. cachcnf act_3880. ,\n   cachmb vdate verdev verctl tdsn hilevel_qual userid\n\naddress 'ISPEXEC' 'CONTROL DISPLAY SAVE'\naddress 'ISPEXEC' 'TBSORT  DEVTAB FIELDS(TDECAD)'\n\nemsg    = ''\n\ndo while rc < 8\n  if datatype(ZTDTOP) = 'NUM'\n  then do\n         address 'ISPEXEC' 'TBTOP DEVTAB'\n         address 'ISPEXEC' 'TBSKIP DEVTAB ROW('ZTDTOP')'\n       end\n  if emsg = ''\n  then address 'ISPEXEC' 'TBDISPL DEVTAB PANEL(CSHMAN3) CURSOR(LOP)'\n  else address 'ISPEXEC' 'TBDISPL DEVTAB PANEL(CSHMAN3) CURSOR(LOP) ,\n                 MSG('emsg')'\n  if rc > 8\n  then do\n         say 'Table display failed - panel or message was not found'\n         say 'Panel = CSHMAN3  Emsg = ' emsg\n         call Clean_up\n         exit\n       end\n  emsg = ''\n  sel = 'Y'\n  do while sel = 'Y'\n    if ZTDSELS \u00ac= 0\n    then do\n           call Devtype TVOLSR\n           dev_result = result\n           cc = c2d(substr(dev_result,9,1))\n           if cc \u00ac= 0\n           then call Process_Devtype_Err result\n           cmdl = 'call Devtype' TVOLSR\n           call WriteLog cc cmdl\n\n           devcyl = substr(dev_result,6,2)\n           tmod = Lookup_model(substr(dev_result,3,1) devcyl)\n           devt = substr(tmod,1,4)\n          select\n           when LOP = CACHDSUB\n           then do\n                  cmdl = 'LISTDATA STATUS VOL('TVOLSR') UNIT('devt')'\n                  call Execute_Cmd 4\n                  if result < 5\n                  then call Browse_Tmp\n                end\n           when LOP = CACHDPIN\n           then do\n                  if tbmdl = '3880'\n                  then emsg = 'CSHM020' /* not valid cmd 3880 */\n                  else do\n                         cmdl = 'LISTDATA PINNED VOL('TVOLSR')'\n                         cmdl = cmdl 'UNIT('devt') DEVICE'\n                         call Execute_Cmd 4\n                         if result = 4\n                         then emsg = 'CSHM012'   /* no pinned data */\n                         else call Browse_Tmp\n                       end\n                end\n           when LOP = CACHDCNT\n           then do\n             cmdl = 'LISTDATA COUNTS VOL('TVOLSR') UNIT('devt') DEVICE'\n                  address 'TSO' cmdl\n                  call Execute_Cmd 4\n                  if result < 5\n                  then call Browse_Tmp\n              end\n           when LOP = CACHDDUP\n           then do\n                  if tbmdl = '3880'\n                  then emsg = 'CSHM020' /* not valid cmd 3880 */\n                  else do\n                         address 'ISPEXEC' 'CONTROL DISPLAY SAVE'\n                         call 'CACHEDUP' tvolsr devt tad cachlog cachcnf\n                         address 'ISPEXEC' 'CONTROL DISPLAY RESTORE'\n                       end\n              end\n           when LOP = CACHSRAT\n           then do\n                  if tbmdl = '3880'\n                  then emsg = 'CSHM020' /* not valid cmd 3880 */\n                  else do\n                         call Confirm_CachPerf\n                         if result = 0\n                         then\n                           do\n                             rtype = 'DEVICE'\n                             address 'ISPEXEC' 'VGET (CMODE) PROFILE'\n                     address 'ISPEXEC' 'VGET (SAMPTIME,NUMINT) SHARED'\n                             if cmode = 'F'  /* do it foreground */\n                             then\n                               do\n                                 cmdl = 'LISTDATA COUNTS VOL('TVOLSR')'\n                                 cmdl = cmdl 'UNIT('devt') DEVICE'\n                                 call Execute_Cmd 0\n                                 if result = 0\n                                 then call Get_Cache_Rates ,\n                                           rtype tvolsr devt\n                               end\n                             else\n                             if cmode = 'B'  /* do it in batch   */\n                             then call Batch_CachPerf\n                           end\n                       end\n                end\n/*---------------------------------------------------------------*/\n/* if LOP is blank, the user modified some field to change the   */\n/* status of cache or DFW.  Save the two   input fields and 'get'*/\n/* the original row.  Compare the values to see which changed    */\n/* and then issue the correct SETCACHE command.                  */\n/*---------------------------------------------------------------*/\n           when LOP = ' '\n           then do\n                  new_thcach = thcach\n                  new_thdfw   = thdfw\n                  call Bld_Setc_Dev_Cmd\n                end\n/*---------------------------------------------------------------*/\n/* if LOP is '=', the user wants to make the same changes to the */\n/* status of cache or DFW for another device.     Check to see   */\n/* if a valid change was made first.  Then apply the same changes*/\n/* to the new device.                                            */\n/*---------------------------------------------------------------*/\n             when LOP = '='\n             then do\n                    if new_thcach \u00ac= '' ,\n                     | new_thdfw \u00ac= ''\n                    then call Bld_Setc_Dev_Cmd\n                    else emsg = 'CSHM004'   /* no change to repeat */\n                  end\n             otherwise nop\n           end\n           if emsg = ''\n           then address 'ISPEXEC' 'TBDISPL DEVTAB CURSOR(LOP)'\n           else address 'ISPEXEC' 'TBDISPL DEVTAB CURSOR(LOP) ,\n                MSG('emsg')'\n           emsg = ''\n         end\n    else sel = 'N'\n  end\n  call Process_ZCMD 'DEV'\nend\n\naddress 'ISPEXEC' 'CONTROL DISPLAY RESTORE'\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Merge_3880_Info starts here                                   */\n/*-------------------------------------------------------------------*/\nMerge_3880_Info:\nprocedure expose tad tvolsr thcach thdfw thdup thpin thpri thsec ,\n                 tscach tsdfw tscfw tdecad rline. act_3880.\narg Ltable Lssst\n\nthdfw = 'N/A'\nthpri = ''\nthsec = ''\nthdup = 'N/A'\nthpin = 'N/A'\ntsdfw = 'N/A'\ntscfw = 'N/A'\nthcach = '???'\nindx   = 0\n\ndo i = 2 to rline.0\n  parse var rline.i word1 word2 .\n  if word1 = 'VOLUME'\n  then do\n         call Devtype word2\n         dev_result = result\n         cc = c2d(substr(dev_result,9,1))\n         if cc \u00ac= 0\n         then call Process_Devtype_Err result\n         cmdl = 'call Devtype' word2\n         call WriteLog cc cmdl\n\n         tvolsr = word2\n         devcyl = substr(dev_result,6,2)\n         tmod = Lookup_model(substr(dev_result,3,1) devcyl)\n         tad = right(c2x(substr(dev_result,1,2)),4,'0')\n         tmp = substr(tad,3,1)\n         tmp = x2d(tmp)\n         if tmp // 2 = 0\n         then offset = 0\n         else offset = 16\n         ix = indx + offset\n\n         tdecad = right(x2d(tad),5,'0')\n         thcach = act_3880.ix\n         indx = indx + 1\n\n         call Actual_Status thcach thdfw Lssst 'N/A' 'N/A'\n         parse var result tscach .\n         address 'ISPEXEC' 'TBADD DEVTAB'\n         i = i + 16      /* skip other report output lines  */\n       end\nend\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Merge_Hdwr_Info starts here                                   */\n/*-------------------------------------------------------------------*/\nMerge_Hdwr_Info:\nprocedure expose tad tvolsr thcach thdfw thdup thpin thpri thsec ,\n                 tscach tsdfw tscfw tdecad rline.\narg Ltable Lssst Lsdst Lnvst\n\n\nthpin  = ' NO'\naddress 'ISPEXEC' 'TBOPEN SMSTAB'\ndo i = 3 to rline.0\n  parse var rline.i word1 word2 .\n  if word1 = 'VOLUME'\n  then do\n         call Get_SMS_Info word2    /* word2 is the volser */\n         parse var result  tad tvolsr tsdup tspin tsdupst tsddc tscca\n         tdecad = right(x2d(tad),5,'0')\n\n         call Devtype tvolsr\n         dev_result = result\n         cc = c2d(substr(dev_result,9,1))\n         if cc \u00ac= 0\n         then call Process_Devtype_Err result\n         cmdl = 'call Devtype' tvolsr\n         call WriteLog cc cmdl\n\n         devcyl = substr(dev_result,6,2)\n         tmod = Lookup_model(substr(dev_result,3,1) devcyl)\n         thpin = tspin   /* get info from SMS ctl blks until */\n                         /* Listdata Counts report is fixed  */\n         i = i + 16      /* skip other report output lines  */\n       end\n\n  select\n    when word1 = 'DEVICE'\n    then do\n           parse var rline.i . 'CACHING:' cach .\n           if cach = 'ACTIVE'\n           then thcach = 'ON'\n           else thcach = 'OFF'\n         end\n    when word1 = 'DASD'\n    then do\n           parse var rline.i . 'WRITE:' dfw .\n           if dfw = 'ACTIVE'\n           then thdfw = 'ON'\n           else thdfw = 'OFF'\n         end\n    when word1 = 'DUPLEX'\n    then do\n           thpri = ''\n           thsec = ''\n           parse var rline.i . 'PAIR:' dup .\n           if dup = 'NOT'\n           then thdup = ' NO'\n           else\n           if substr(dup,1,3) = 'PRI'\n           then do\n                  thpri = 'YES'\n                  thdup = substr(tsdupst,1,3)\n                  thsec = right(tscca,3)\n                end\n           else\n           if substr(dup,1,3) = 'SEC'\n           then do\n                  thsec = 'YES'\n                  thdup = substr(tsdupst,1,3)\n                  thpri = right(tscca,3)\n                end\n           else thdup = substr(dup,1,3)\n         end\n    when word1 = 'PINNED'\n    then thpin = 'YES'\n    when word2 = 'STORAGE'\n    then do\n           call Actual_Status thcach thdfw Lssst Lsdst Lnvst\n           parse var result tscach tsdfw tscfw\n           address 'ISPEXEC' 'TBADD DEVTAB'\n           thpin = ' NO'\n           i = i + 1\n         end\n    otherwise nop\n  end\nend\ncall Actual_Status thcach thdfw Lssst Lsdst Lnvst\nparse var result tscach tsdfw tscfw\naddress 'ISPEXEC' 'TBADD DEVTAB'     /* write last record into table */\naddress 'ISPEXEC' 'TBCLOSE SMSTAB'\nreturn\n\n/*-------------------------------------------------------------------*/\n/*  This procedure will check both device and controller status to   */\n/*  determine the actual/overall caching status of this device.      */\n/*-------------------------------------------------------------------*/\nActual_Status:\nprocedure expose rline.\narg Lhcach Lhdfw Lssst Lsdst Lnvst\n\ncache = 'OFF'\nnvs   = 'OFF'\ncfw   = 'OFF'\nif Lhcach = 'ON' & Lssst = 'ON'\nthen do\n       cache = 'ON'\n       if Lhdfw = 'ON' & Lnvst = 'ON'\n       then do\n              nvs = 'ON'\n              if Lsdst = 'ON'\n              then cfw = 'ON'\n            end\n     end\nline = cache nvs cfw\nreturn(line)\n\n/*-------------------------------------------------------------------*/\n/*     Bld_3880_Dev_Info starts here                                 */\n/* Creates a table which contains caching status of dasd devices     */\n/* connected to this 3880 controller.                                */\n/*-------------------------------------------------------------------*/\nBld_3880_Dev_Info:\nprocedure expose rline. act_3880.\n\ndo i = 1 to rline.0\n  parse var rline.i word1 word2 .\n  if word1 = 'FOR' & word2 = 'DEVICES'\n  then do\n         parse var rline.i . 'DEVICES' act_ln1\n         do j = 0 to 31\n            act_3880.j = 'OFF'\n         end\n         do j = 1 to words(act_ln1)\n            indx =  word(act_ln1, j)\n            indx = x2d(indx)\n            act_3880.indx = 'ON '\n         end\n         i = i + 1\n         act_ln2 = rline.i\n         do j = 1 to words(act_ln2)\n            indx =  word(act_ln2, j)\n            indx = x2d(indx)\n            act_3880.indx = 'ON '\n         end\n         i = rline.0      /* skip rest of output lines */\n       end\nend\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Bld_SMS_Info starts here                                      */\n/* Creates a table in ascending order by volser that will be matched */\n/* with the hardware information for the corresponding volser.       */\n/*-------------------------------------------------------------------*/\nBld_SMS_Info:\nprocedure expose rline.\n\naddress 'ISPEXEC' 'TBCREATE SMSTAB KEYS(TVOLSR) ,\n         NAMES(TAD,TSDUP,TSDUPST,TSCCA,TSDDC,TSPIN) WRITE REPLACE'\n\ndo i = 1 to rline.0\n  parse var rline.i word1 .\n  if word1 = 'DEV'\n  then do\n         do j = i + 1 to rline.0\n           parse var rline.j tad tvolsr . . tscach ,\n                     tsdfw tsdup\n           if word(tsdup,1) = 'NO'\n           then parse var tsdup tsdup tspin tsnvs\n           else\n           if word(tsdup,1) = 'PRI' | word(tsdup,1) = 'SEC'\n           then parse var tsdup tsdup tsdupst tspin tsnvs . tscca tsddc\n           if tad = '3990' | tad = 'DEVICE' | tad = 'SUBSYSTEM' ,\n              | substr(tad,1,3) = '...' | tad = 'DEV'\n           then nop                /* skip the page break headings */\n           else address 'ISPEXEC' 'TBADD SMSTAB'\n         end\n         i = rline.0\n       end\nend\naddress 'ISPEXEC' 'TBSORT  SMSTAB FIELDS(TVOLSR)'\naddress 'ISPEXEC' 'TBCLOSE SMSTAB'\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Bld_Status_Info starts here                                   */\n/* Creates a table in ascending order by string that will be show    */\n/* status of all devices in string for Cache, DFW, and duplex.       */\n/* Funky logic because of the way I chose to list strings. One       */\n/* controller may have multiple strings so keep track of duplicate   */\n/* DSTATUS reports and exclude from the table.                       */\n/*-------------------------------------------------------------------*/\nBld_Status_Info:\nprocedure expose rline. chan dv0 dv1 dv2 dv3 dv4 dv5 dv6 dv7 dv8 dv9 ,\n                 dva dvb dvc dvd dve dvf last_unit_address\n\ndv0 = '...'\ndv1 = '...'\ndv2 = '...'\ndv3 = '...'\ndv4 = '...'\ndv5 = '...'\ndv6 = '...'\ndv7 = '...'\ndv8 = '...'\ndv9 = '...'\ndva = '...'\ndvb = '...'\ndvc = '...'\ndvd = '...'\ndve = '...'\ndvf = '...'\nwrite = 'N'\nsave_chan = 0\ndo i = 1 to rline.0\n  parse var rline.i word1 .\n  if word1 = 'DEV'\n  then\n    do\n      do j = i + 1 to rline.0\n        if substr(rline.j,8,1) \u00ac= ' '  /* volser might be blank */\n        then parse var rline.j uadr . . . cach dfw duplex\n        else parse var rline.j uadr . . cach dfw duplex\n\n        if uadr = '3990' | uadr = 'DEVICE' | uadr = 'SUBSYSTEM' ,\n           | substr(uadr,1,3) = '...' | uadr = 'DEV'\n        then iterate            /* skip the page break headings */\n\n        if x2d(uadr) < last_unit_address\n        then leave           /* don't waste time on duplicates */\n        else last_unit_address = x2d(uadr)\n\n        next_chn = substr(uadr,1,length(uadr)-1)\n        next_chn = next_chn || 0\n        d_chan = x2d(next_chn)        /* remember 0E0 is exponent */\n        if save_chan \u00ac= d_chan & save_chan > 0\n        then do\n               pline = chan dv0 dv1 dv2 dv3 dv4 dv5 dv6 dv7 dv8\n               pline = pline dv9 dva dvb dvc dvd dve dvf\n               queue pline\n               address 'TSO' 'EXECIO' queued() 'DISKW CSHDCST (FINIS'\n               address 'ISPEXEC' 'TBADD STATTAB'\n               write = 'N'\n               dv0 = '...'\n               dv1 = '...'\n               dv2 = '...'\n               dv3 = '...'\n               dv4 = '...'\n               dv5 = '...'\n               dv6 = '...'\n               dv7 = '...'\n               dv8 = '...'\n               dv9 = '...'\n               dva = '...'\n               dvb = '...'\n               dvc = '...'\n               dvd = '...'\n               dve = '...'\n               dvf = '...'\n             end\n\n        chan = substr(uadr,1,length(uadr)-1)\n        chan = chan || 0\n        save_chan = d_chan\n        pos_in_string = substr(uadr,length(uadr),1)\n        vardev = 'DV' || pos_in_string\n        if word(duplex,1) = 'NO'\n        then parse var duplex duplex pin nvs\n        else\n        if word(duplex,1) = 'PRI' | word(duplex,1) = 'SEC'\n        then parse var duplex duplex . pin nvs .\n        val = substr(cach,1,1)||substr(dfw,1,1)||substr(duplex,1,1)\n        interpret vardev '= val'\n        write = 'Y'\n      end\n      i = rline.0\n      if write = 'Y'\n      then do\n             pline = chan dv0 dv1 dv2 dv3 dv4 dv5 dv6 dv7 dv8\n             pline = pline dv9 dva dvb dvc dvd dve dvf\n             queue pline\n             address 'TSO' 'EXECIO' queued() 'DISKW CSHDCST (FINIS'\n             address 'ISPEXEC' 'TBADD STATTAB'\n             write = 'N'\n           end\n    end\nend\n\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Bld_Setcache_Cmd starts here                                  */\n/*-------------------------------------------------------------------*/\nBld_Setcache_Cmd:\nprocedure expose new_tbssst new_tbsdst new_tbnvst emsg ,\n                 tbssst tbsdst tbnvst cachlog rline. cachcnf\n\n/* Get the original value from the table and compare to the new value*/\n/* If the new value is different AND NOT null, this field was changed*/\n/* Null signifies that the field was not changed (used by = logic)   */\n\naddress 'ISPEXEC' 'TBGET SSGTAB'\nif tbssst \u00ac= new_tbssst & new_tbssst \u00ac= ''\nthen do\n       if new_tbssst = 'YES' | new_tbssst = 'ON' ,\n        | new_tbssst = 'ONF' | new_tbssst = 'YFF'\n       then do\n              setc_cmd = 'SUBSYSTEM ON'\n              new_tbssst = 'ON'\n            end\n       else\n       if new_tbssst = 'OFF' | new_tbssst = 'NO' ,\n        | new_tbssst = 'OF'  | new_tbssst = 'NN'\n       then do\n              setc_cmd = 'SUBSYSTEM OFF'\n              new_tbssst = 'OFF'\n            end\n       else emsg = 'CSHM001'\n       if emsg = ''\n       then do\n              call Exec_Setcache tbv setc_cmd\n              if result = 0\n              then do\n                     tbssst = new_tbssst\n                     address 'ISPEXEC' 'TBPUT SSGTAB ORDER'\n                   end\n            end\n     end\nelse nop             /* new_tbssst = ''    nothing changed */\nif tbsdst \u00ac= new_tbsdst & new_tbsdst \u00ac= ''\nthen do\n       if tbmdl = '3880'\n       then emsg = 'CSHM020'    /* not valid command for 3880s */\n       else\n       if new_tbsdst = 'YES' | new_tbsdst = 'ON' ,\n        | new_tbsdst = 'ONF' | new_tbsdst = 'YFF'\n       then do\n              setc_cmd = 'CACHEFW ON'\n              new_tbsdst = 'ON'\n            end\n       else\n       if new_tbsdst = 'NO' | new_tbsdst = 'OFF' ,\n        | new_tbsdst = 'OF' | new_tbsdst = 'NN'\n       then do\n              setc_cmd = 'CACHEFW OFF'\n              new_tbsdst = 'OFF'\n            end\n       else emsg = 'CSHM002'\n       if emsg = ''\n       then do\n              call Exec_Setcache tbv setc_cmd\n              if result = 0\n              then do\n                     tbsdst = new_tbsdst\n                     address 'ISPEXEC' 'TBPUT SSGTAB ORDER'\n                   end\n            end\n     end\nelse nop            /* new_tbsdst = ''  nothing changed */\nif tbnvst \u00ac= new_tbnvst & new_tbnvst \u00ac= ''\nthen do\n       if tbmdl = '3880'\n       then emsg = 'CSHM020'    /* not valid command for 3880s */\n       else\n       if new_tbnvst = 'YES' | new_tbnvst = 'ON' ,\n        | new_tbnvst = 'ONF' | new_tbnvst = 'YFF'\n       then do\n              setc_cmd = 'NVS ON'\n              new_tbnvst = 'ON'\n            end\n       else\n       if new_tbnvst = 'NO' | new_tbnvst = 'OFF' ,\n        | new_tbnvst = 'OF' | new_tbnvst = 'NN'\n       then do\n              setc_cmd = 'NVS OFF'\n              new_tbnvst = 'OFF'\n            end\n       else emsg = 'CSHM001'\n       if emsg = ''\n       then do\n              call Exec_Setcache tbv setc_cmd\n              if result = 0\n              then do\n                     tbnvst = new_tbnvst\n                     address 'ISPEXEC' 'TBPUT SSGTAB ORDER'\n                   end\n            end\n     end\nelse nop            /* new_tbnvst = '' nothing changed */\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Bld_Setc_Dev_Cmd starts here                                  */\n/*-------------------------------------------------------------------*/\nBld_Setc_Dev_Cmd:\nprocedure expose new_thcach new_thdfw emsg thcach thdfw cachlog ,\n                 tbssst tbsdst tbnvst rline. cachcnf\n\n/* Get the original value from the table and compare to the new value*/\n/* If the new value is different AND NOT null, this field was changed*/\n/* Null signifies that the field was not changed (used by = logic)   */\n\naddress 'ISPEXEC' 'TBGET DEVTAB'\ntbv = tvolsr\nif thcach \u00ac= new_thcach & new_thcach \u00ac= ''\nthen do\n       if new_thcach = 'YES' | new_thcach = 'ON' ,\n        | new_thcach = 'ONF' | new_thcach = 'YFF'\n       then do\n              setc_cmd = 'DEVICE ON'\n              new_thcach = 'ON'\n            end\n       else\n       if new_thcach = 'NO' | new_thcach = 'OFF' | new_thcach = 'OF' ,\n        | new_thcach = 'OF' | new_thcach = 'NN'\n       then do\n              setc_cmd = 'DEVICE OFF'\n              new_thcach = 'OFF'\n            end\n       else emsg = 'CSHM001'\n       if emsg = ''\n       then do\n              call Exec_Setcache tbv setc_cmd\n              if result = 0\n              then do\n                     thcach = new_thcach\n                     call Actual_Status thcach thdfw tbssst tbsdst ,\n                          tbnvst\n                     parse var result tscach tsdfw tscfw\n                     address 'ISPEXEC' 'TBPUT DEVTAB'\n                   end\n            end\n     end\nelse nop           /* new_thcach = '' nothing changed */\nif thdfw \u00ac= new_thdfw & new_thdfw \u00ac= ''\nthen do\n       if new_thdfw = 'ON'  | new_thdfw = 'YES' ,\n        | new_thdfw = 'ONF' | new_thdfw = 'YFF'\n       then do\n              setc_cmd = 'DASDFW ON'\n              new_thdfw = 'ON'\n            end\n       else\n       if new_thdfw = 'OFF' | new_thdfw = 'NO' ,\n        | new_thdfw = 'OF'  | new_thdfw = 'NN'\n       then do\n              setc_cmd = 'DASDFW OFF'\n              new_thdfw = 'OFF'\n            end\n       else emsg = 'CSHM001'\n       if emsg = ''\n       then do\n              call Exec_Setcache tbv setc_cmd\n              if result = 0\n              then do\n                     thdfw = new_thdfw\n                     call Actual_Status thcach thdfw tbssst tbsdst ,\n                          tbnvst\n                     parse var result tscach tsdfw tscfw\n                     address 'ISPEXEC' 'TBPUT DEVTAB'\n                   end\n            end\n     end\nelse nop            /* new_thdfw = '' nothing changed */\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Exec_Setcache starts here                                     */\n/*-------------------------------------------------------------------*/\nExec_Setcache:\nprocedure expose rline. cachlog cachcnf\narg Lvolsr Lcmd\n\n/* Devtype is a user written external REXX function (assembler) that */\n/* will return the devicetype (3380 or 3390 or 33??) and model in    */\n/* RESULT.  DEVICETYPE is the first 4 chars of result.               */\n\n  cc = 0\n  call Devtype Lvolsr\n  dev_result = result\n  cc = c2d(substr(dev_result,9,1))\n\n  if cc \u00ac= 0\n  then call Process_Devtype_Err result\n  cmdl = 'call Devtype' Lvolsr\n  call WriteLog cc cmdl\n\n  devcyl = substr(dev_result,6,2)\n  tmod = Lookup_model(substr(dev_result,3,1) devcyl)\n  devt = substr(tmod,1,4)\n  if CACHCNF = 'YES'\n  then do\n         zwinttl = 'SETCACHE' Lcmd 'VOL('Lvolsr') UNIT('devt')'\n         address 'ISPEXEC' 'ADDPOP ROW(9)'\n         address 'ISPEXEC' 'DISPLAY PANEL(CSHSETC) CURSOR(ZCMD)'\n         cc = rc\n         address 'ISPEXEC' 'REMPOP'\n       end\n  if cc = 0\n  then do\n         cmdl = 'SETCACHE' Lcmd 'VOL('Lvolsr') UNIT('devt')'\n         call Execute_Cmd 0\n         cc = result\n       end\n\nreturn(cc)\n\n/*-------------------------------------------------------------------*/\n/*     Display_Cache_Stat starts here                                */\n/* Creates table of all devices CACHE, DFW, DUPlex status and        */\n/* displays it in a grid format.                                     */\n/*-------------------------------------------------------------------*/\nDisplay_Cache_Stat:\nprocedure expose rline. emsg hilevel_qual\n\naddress 'ISPEXEC' 'TBCREATE STATTAB ,\n         NAMES(CHAN,DV0,DV1,DV2,DV3,DV4,DV5,DV6,DV7,DV8,DV9,DVA,DVB, ,\n               DVC,DVD,DVE,DVF) NOWRITE REPLACE'\ntimex = time()\nparse var timex hh ':' mm ':' ss\ndyntm = 'T'hh||mm||ss\noname = \"'\"hilevel_qual\".CACHEST.\"dyntm\"'\"\naddress 'TSO' 'ALLOC FI(CSHDCST) DA('oname') MOD CATALOG TRACKS ,\n       SPACE(1,1) RECFM(F,B) LRECL(80) BLKSIZE(6160)'\nif rc \u00ac= 0\nthen do\n       title = 'Output File Allocate Failed'\n       call Rc8_Display rc title\n     end\nelse do\n       pline = 'STR  0   1   2   3   4   5   6   7   8   9   A   B   C'\n       pline = pline '  D   E   F'\n       queue pline\n     end\n\n/*-------------------------------------------------------------------*/\n/*  Issue the LISTDATA DSTATUS  for each unique entry in the CSTTABLE*/\n/*-------------------------------------------------------------------*/\n  address 'ISPEXEC' 'TBOPEN CSTTABLE NOWRITE SHARE'\n  if rc \u00ac= 0\n  then do\n         say 'Open of volser table CSTTABLE failed - rc = ' rc\n         call Clean_up\n         exit\n       end\n  address 'ISPEXEC' 'TBQUERY CSTTABLE ROWNUM(ROWS)'\n\n  do rows\n     address 'ISPEXEC' 'TBSKIP CSTTABLE'  /* position to next line   */\n     address 'ISPEXEC' 'TBGET  CSTTABLE'  /* read row from table     */\n     cmdl = 'LISTDATA DSTATUS VOL('tvol') UNIT('tdevice') SUBSYSTEM'\n     call Execute_Cmd 12\n     call Bld_Status_Info\n  end\n\n  emsg = 'CSHM027'\n  address 'TSO' 'FREE FI(CSHDCST)'\n  address 'ISPEXEC' 'TBCLOSE CSTTABLE'\n  address 'ISPEXEC' 'TBTOP STATTAB'\n  pan  = 'CSHMAN6'\n  address 'ISPEXEC' 'CONTROL DISPLAY SAVE'\n  do while rc \u00ac= 8\n    if emsg = ''\n    then address 'ISPEXEC' 'TBDISPL STATTAB PANEL('pan')'\n    else address 'ISPEXEC' 'TBDISPL STATTAB PANEL('pan') MSG('emsg')'\n  end\n  address 'ISPEXEC' 'CONTROL DISPLAY RESTORE'\n  address 'ISPEXEC' 'TBCLOSE STATTAB'\n\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Get_Dev_Info starts here                                      */\n/* Creates DEVTAB and extracts data from LISTDATA commands.          */\n/*-------------------------------------------------------------------*/\nGet_Dev_Info:\nprocedure expose rline. act_3880. tbmdl tbssst tbsdst tbnvst tdecad ,\n          cachlog\narg Ltbv Ltbdtyp\n\ntable = 'DEVTAB'\n\nif substr(tbmdl,1,4) = '3990'\nthen do\n       cmdl = 'LISTDATA DSTATUS VOL('Ltbv') UNIT('Ltbdtyp') SUBSYSTEM'\n       call Execute_Cmd 0\n       call Bld_SMS_Info\n     end\nelse do  /* for 3880 */\n       cmdl = 'LISTDATA STATUS VOL('Ltbv') UNIT('Ltbdtyp')'\n       call Execute_Cmd 4\n       call Bld_3880_Dev_Info\n     end\n\ncmdl = 'LISTDATA COUNTS VOL('Ltbv') UNIT('Ltbdtyp') SUBSYSTEM'\ncall Execute_Cmd 4\n\naddress 'ISPEXEC' 'TBCLOSE DEVTAB'\naddress 'ISPEXEC' 'TBCREATE DEVTAB ,\n         NAMES(TAD,TVOLSR,THCACH,THDFW,THDUP,THPIN,THPRI, ,\n         THSEC,TSCACH,TSDFW,TSCFW,TDECAD,TMOD) WRITE REPLACE'\nif rc > 4\nthen do\n       if rc = 8\n       then say 'DEVTAB table already exists.'\n       else\n       if rc = 12\n       then say 'Table in use by another user. Enqueue failed'\n       else\n       if rc = 16\n       then say 'Write mode specified & table input lib not allocated'\n       else say 'Severe error'\n\n       say 'Creation of DEVTAB failed - rc = ' rc\n       call Clean_up\n       exit\n     end\nif substr(tbmdl,1,4) = '3990'\nthen call Merge_Hdwr_Info table tbssst tbsdst tbnvst\nelse call Merge_3880_Info table tbssst\n\naddress 'ISPEXEC' 'TBSORT  DEVTAB FIELDS(TDECAD)'\n\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Get_SMS_Info starts here                                      */\n/* Returns SMS info from the SMS table.                              */\n/*-------------------------------------------------------------------*/\nGet_SMS_Info:\nprocedure expose rline. tdecad\narg Lvolser\n\ntvolsr = Lvolser\naddress 'ISPEXEC' 'TBGET SMSTAB'\nif rc > 0\nthen do\n       address 'ISPEXEC' 'SETMSG MSG(CSHM021)'\n       tdecad = tdecad + 1\n       tad = d2x(tdecad)\n       tvolsr = '      '\n       tsdup  = ''\n       tsdupst = ''\n       tsddc   = ''\n       tscca   = ''\n       tspin   = ''\n     end\ntline = tad tvolsr tsdup tspin tsdupst tsddc tscca\n\nreturn(tline)\n\n/*-------------------------------------------------------------------*/\n/*     Browse_Tmp     starts here                                    */\n/*     Logic to handle mods to devices on device panel               */\n/*-------------------------------------------------------------------*/\nBrowse_Tmp:\nprocedure expose rline. hilevel_qual\n\ndo i = 1 to rline.0\n  queue rline.i\nend\ntimex = time()\nparse var timex hh ':' mm ':' ss\ndyntm = 'T'hh||mm||ss\noname = \"'\"hilevel_qual\".STATUS.\"dyntm\"'\"\naddress 'TSO' 'ALLOC FI(CSHSTAT) DA('oname') NEW CATALOG TRACKS ,\n  SPACE(2,1) RECFM(F,B) LRECL(80) BLKSIZE(6160)'\nif rc = 0\nthen do\n       address 'TSO' 'EXECIO' queued() 'DISKW CSHSTAT'\n       address 'TSO' 'EXECIO 0 DISKW CSHSTAT (FINIS'\n       call Browse_Dsn oname\n       address 'TSO' 'FREE FI(CSHSTAT)'\n       address 'TSO' 'DELETE' oname\n     end\nelse do\n       title = 'Output File Allocate Failed'\n       call Rc8_Display rc title\n     end\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     BrwsDataSet    starts here                                    */\n/*-------------------------------------------------------------------*/\nBrowse_Dsn:\nprocedure expose rline.\narg Lname\n\n  address 'ISPEXEC' 'CONTROL DISPLAY SAVE'\n  address 'ISPEXEC' 'BROWSE DATASET('Lname')'\n  if rc >= 12\n  then address 'ISPEXEC' 'SETMSG MSG(CSHM006)'\n  address 'ISPEXEC' 'CONTROL DISPLAY RESTORE'\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Parse_Listd   starts here                                     */\n/*-------------------------------------------------------------------*/\nParseListd:\nprocedure expose rline. saved_ssid act_3880. cachlog\narg Ltable Luaddr Ldevtyp Lfunc Lvolser\n\ntbpin = ' NO'    /* initialize because PINNED is not in 3880-23 rpt*/\ntbsdst = 'N/A'   /* initialize because CFW is n/a   for 3880s      */\ntbnvst = 'N/A'   /* initialize because NVS is n/a   for 3880s      */\ndo i = 1 to rline.0\n  parse var rline.i tok1 tok2 tok3 tok4 .\n  select\n     when tok1 = '3990'\n     then do\n            model = ''\n            parse var rline.i . 'MODEL' model\n            model = strip(model,'B',' ')\n            tbmdl = tok1 || '-' || model\n          end\n     when tok1 = '3380' | tok1 = '3350'\n     then do\n            tbmdl = '3880   '\n            tbv   = Lvolser\n            /* the type of 3880 controller is not in report output */\n          end\n     when tok1 = 'VOLUME'\n     then do\n            tbv = tok2\n          end\n     when tok2 = 'ID'\n     then do\n            parse var rline.i . 'X' ssid .\n            ssid = strip(ssid,'B',\"'\")\n/* convert to hex to avoid xxEx being interpreted as exponential num */\n            if saved_ssid = x2d(ssid)\n            then return          /* don't bother to process anythng*/\n            else do\n                   tbssid = right(ssid,4,0)\n                   tbssidd = x2d(tbssid)\n                 end\n          end\n\n/* if subsytem storage < 32M then this is a 3990-6 enhanced mode ctlr*/\n/* and the value returned is in kilobytes. Convert it to bytes */\n/* version 2.43 since 3990-6 enhanced mode  now reports amounts in K */\n\n     when tok1 = 'CONFIGURED'\n     then do\n            parse var rline.i . ssstg nvsstg .\n            if pos('K',ssstg) > 0\n            then do\n                   ssstg = strip(ssstg,'T','K')\n                   ssstg = ssstg * 1024\n                 end\n            if pos('K',nvsstg) > 0\n            then do\n                   nvsstg = strip(nvsstg,'T','K')\n                   nvsstg = nvsstg * 1024\n                 end\n\n            if ssstg < (32 * 1048576)\n            then do\n                   ssstg = ssstg * 1024\n                   enhanced_ss = 1\n                 end\n            else enhanced_ss = 0\n\n            tbssstg = ssstg / 1048576\n            tbssstg = format(tbssstg,4,0) ||'M'\n            tbssstg = right(tbssstg,5)\n            if substr(tbmdl,1,4) = '3990'\n            then do\n/* if nonvoltl storage < 4M then this is a 3990-6 enhanced mode ctlr*/\n/* and the value returned is in kilobytes. Convert it to bytes */\n                   if nvsstg < (4 * 1048576)\n                   then do\n                           enhanced_nvs = 1\n                           nvsstg = nvsstg * 1024\n                        end\n                   else enhanced_nvs = 0\n                   tbnvsstg = nvsstg / 1048576\n                   tbnvsstg = format(tbnvsstg,4,0) ||'M'\n                   tbnvsstg = right(tbnvsstg,5)\n                 end\n            else tbnvsstg = 'N/A'\n          end\n     when tok1 = 'AVAILABLE'\n     then do\n            parse var rline.i . ssavl nvsavl .\n            if enhanced_ss\n            then ssavl = ssavl * 1024\n\n            if pos('K',ssavl) > 0\n            then do\n                   ssavl = strip(ssavl,'T','K')\n                   ssavl = ssavl * 1024\n                 end\n\n            if pos('K',nvsavl) > 0        /* ie   596k    */\n            then do\n                   nvsavl = strip(nvsavl,'T','K')\n                   nvsavl = nvsavl * 1024\n                 end\n\n            if ssavl > 1048576\n            then do\n                   ssavl = ssavl / 1048576\n                   tbssavl = format(ssavl,4,0)||'M'\n                 end\n            else\n            if ssavl > 1024\n            then do\n                   ssavl = ssavl / 1024\n                   tbssavl = format(ssavl,4,0)||'K'\n                 end\n            else tbssavl = right(ssavl,4)\n            if substr(tbmdl,1,4) = '3990'\n            then do\n                   if datatype(nvsavl) = 'NUM' & nvsavl > 1048576\n                   then do\n                          nvsavl = nvsavl / 1048576\n                          tbnvsavl = format(nvsavl,4,0)||'M'\n                        end\n                   else\n                   if datatype(nvsavl) = 'NUM' & nvsavl > 1024\n                   then do\n                          nvsavl = nvsavl / 1024\n                          tbnvsavl = format(nvsavl,4,0)||'K'\n                        end\n                   else tbnvsavl = 'N/A'\n                 end\n            else tbnvsavl = 'N/A'\n          end\n     when tok1 = 'PINNED'\n     then do\n            parse var rline.i . sspin nvspin .\n            tbsspin = right(sspin,10)\n            tbnvspin = right(nvspin,10)\n            if tbsspin > 0\n            then tbpin = 'YES'\n            else tbpin = ' NO'\n          end\n     when tok1 = 'OFFLINE'\n     then do\n            parse var rline.i . ssoff nvsoff .\n            tbssoff = right(ssoff,10)\n            if tbssoff > 0\n            then tboff = 'YES'\n            else tboff = ' NO'\n            if substr(tbmdl,1,4) = '3990'\n            then tbnvsoff = right(nvsoff,10)\n            else tbnvsoff = right('N/A',10)\n          end\n     when tok1 = 'SUBSYSTEM' & tok2 = 'CACHING'\n     then do\n            parse var rline.i . 'STATUS:' ssst ssst2 ssst3 .\n            if ssst = 'ACTIVE'\n            then ssst = 'ON'\n            else\n            if substr(ssst,1,2) = 'DE' & ssst2 = 'ERROR'\n            then ssst = 'ERR'\n            else\n            if substr(ssst,1,2) = 'DE' & ssst2 = 'FAILED'\n            then ssst = 'DFL'         /* deactivation failed */\n            else ssst = ' OFF'\n            tbssst = strip(ssst,'B',' ')\n          end\n     when tok1 = 'OVERALL' & tok2 = 'CACHING'\n     then do\n            parse var rline.i . 'STATUS' ssst .\n            if ssst = 'ACTIVE'\n            then ssst = 'ON'\n            else ssst = ' OFF'\n            tbssst = strip(ssst,'B',' ')\n          end\n     when tok1 = 'SD'\n     then do\n            parse var rline.i . 'CONDITIONS:' sdst\n            parse var sdst t1 t2 t3 t4 t5\n            if t1 = 'CACHE' & t2 = 'FAST' & t3 = 'WRITE'\n            then do\n                   if t4 = 'ACTIVE'\n                   then sdst = 'ON'\n                   else\n                   if t4 = 'DISABLED'\n                   then sdst = 'OFF'\n                 end\n            else\n            if t1 = 'SUBSYSTEM' & t2 = 'DISABLED'\n            then sdst = 'DIS'\n            else sdst = 'OFF'\n            tbsdst = strip(sdst,'B',' ')\n          end\n     when tok1 = 'NVS' | tok1 = 'NON-VOLATILE'\n     then do\n            parse var rline.i . 'STATUS:' nvst nvst2 nvst3\n            if nvst = 'ACTIVE'\n            then nvst = 'ON'\n            else\n            if nvst2 = 'ERROR'\n            then nvst = 'ERR'\n            else\n            if nvst2 = 'FAILED'\n            then nvst = 'DFL'\n            else\n            if nvst = 'DISABLED'\n            then nvst = 'DIS'\n            else nvst = 'OFF'\n            tbnvst = strip(nvst,'B',' ')\n            i = rline.0      /* skip rest of output lines */\n          end\n     otherwise nop\n  end\n  tbu = Luaddr\n  tbud = x2d(tbu)         /* for sort key purposes */\n  tbdtyp = Ldevtyp\nend\n\n/* convert to hex to avoid xxEx being interpreted as exponential num */\nsaved_ssid = x2d(tbssid)\naddress 'ISPEXEC' Lfunc 'SSGTAB ORDER'\n\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Get_Cache_Rates starts here                                   */\n/*-------------------------------------------------------------------*/\nGet_Cache_Rates:\nprocedure expose rline. tbv tbdtyp interval samptime cachlog\narg ctlr_or_dev vol dtype\nix = 1\ntimex = time()\nparse var timex hh ':' mm ':' ss\nint_time.ix = hh * 3600 + mm * 60 + ss\ncall Parse_Counts ix\ncc = 0\n  do while cc < 8\n    address 'ISPEXEC' 'TBCREATE CHTTAB ,\n           NAMES(VOLSER,IO,CACHABLE,TOTHIT,DFWPCT,RW,RHIT,DFWHIT, ,\n         CFWHIT,STAGE,DFWRETRY,BYPASS,INHIBIT,ADDR) NOWRITE REPLACE'\n    if rc > 4\n    then\n      do\n        say 'Creation of cache hit table CHTTAB failed - rc = ' rc\n        call Clean_up\n        exit\n      end\n    timex = time()\n    parse var timex hh ':' mm ':' ss\n    timex = hh * 3600 + mm * 60 + ss\n\n    if int_time.ix + samptime > timex\n    then this_interval = int_time.ix + samptime - timex\n    else this_interval = 0\n    if this_interval > 0\n    then call Sleep this_interval\n\n    ix = ix + 1\n    timex = time()\n    parse var timex hh ':' mm ':' ss\n    int_time.ix = hh * 3600 + mm * 60 + ss\n    cmdl = 'LISTDATA COUNTS VOL('vol') UNIT('dtype')' ctlr_or_dev\n    call Execute_Cmd 0\n    call Parse_Counts ix\n    ctlr_bzer = 0\n    ctlr_ezer = 0\n    ctlr_aone = 0\n    ctlr_bone = 0\n    ctlr_cone = 0\n    ctlr_done = 0\n    ctlr_eone = 0\n    ctlr_ftwo = 0\n    ctlr_fthr = 0\n    ctlr_ffive = 0\n    iy = ix - 1\n    interval = int_time.ix - int_time.iy\n    do j = 1 to v\n      bzer = b0.ix.j - b0.iy.j\n      ctlr_bzer = ctlr_bzer + bzer\n\n      czer = c0.ix.j - c0.iy.j       /* CFW total */\n\n      ezer = e0.ix.j - e0.iy.j\n      ctlr_ezer = ctlr_ezer + ezer\n\n      aone = a1.ix.j - a1.iy.j\n      ctlr_aone = ctlr_aone + aone\n      bone = b1.ix.j - b1.iy.j\n      ctlr_bone = ctlr_bone + bone\n      cone = c1.ix.j - c1.iy.j\n      ctlr_cone = ctlr_cone + cone\n\n      done = d1.ix.j - d1.iy.j\n      done = done + czer            /* following CRR report */\n      ctlr_done = ctlr_done + done\n\n      eone = e1.ix.j - e1.iy.j\n      ctlr_eone = ctlr_eone + eone\n\n      ftwo = f2.ix.j - f2.iy.j\n      ctlr_ftwo = ctlr_ftwo + ftwo\n      fthr = f3.ix.j - f3.iy.j\n      ctlr_fthr = ctlr_fthr + fthr\n      ffive = f5.ix.j - f5.iy.j\n      ctlr_ffive = ctlr_ffive + ffive\n      volser = vol.ix.j\n      addr   = adr.ix.j\n      io  = format((aone + cone + ftwo + fthr) / interval,,1)\n\n      if (aone + done) > 0\n      then cachable = format(((bone + eone) / (aone + done)) * 100,,1)\n      else cachable = 0\n\n      if (aone + cone + ftwo + fthr) > 0\n      then tothit = format((bone + eone)/ ,\n                    (aone + cone + ftwo + fthr) * 100,,1)\n      else tothit = 0\n\n      if done > 0\n      then dfwpct = format((eone / done) * 100,,1)\n      else dfwpct = 0\n\n      dfwhit = format(done / interval,,1)\n      cfwhit = format((bzer + ezer) / interval,,1)\n      stage  = format((aone - bone + done - eone)/ interval,,1)\n\n      if cone > 0\n      then rw = format(aone / cone,,2)\n      else rw = 0\n      rhit   = format(bone / interval,,1)\n\n      dfwretry = format(ffive / interval,,1)\n      bypass = format(fthr / interval,,1)\n      inhibit = format(ftwo / interval,,1)\n      address 'ISPEXEC' 'TBADD CHTTAB'\n    end\n    volser = ' TOTAL'\n    addr   = 00\n    io  = format((ctlr_aone + ctlr_cone + ctlr_ftwo + ctlr_fthr) ,\n          / interval,,1)\n\n    if (ctlr_aone + ctlr_done) > 0\n    then cachable = format(((ctlr_bone + ctlr_eone) / ,\n                    (ctlr_aone + ctlr_done)) * 100,,1)\n    else cachable = 0\n    if (ctlr_aone + ctlr_cone + ctlr_ftwo + ctlr_fthr) > 0\n    then tothit = format((ctlr_bone + ctlr_eone) / ,\n           (ctlr_aone + ctlr_cone + ctlr_ftwo + ctlr_fthr) ,\n             * 100,,1)\n    else tothit = 0\n    if ctlr_done > 0\n    then dfwpct = format((ctlr_eone / ctlr_done) * 100,,1)\n    else dfwpct = 0\n    dfwhit = format(ctlr_done / interval,,1)\n    cfwhit = format((ctlr_bzer + ctlr_ezer) / interval,,1)\n    stage  = format((ctlr_aone - ctlr_bone + ,\n             ctlr_done - ctlr_eone) / interval,,1)\n\n    if ctlr_cone > 0\n    then rw = format(ctlr_aone / ctlr_cone,,2)\n    else rw = 0\n    rhit   = format(ctlr_bone / interval,,1)\n    dfwretry = format(ctlr_ffive / interval,,1)\n    bypass = format(ctlr_fthr / interval,,1)\n    inhibit = format(ctlr_ftwo / interval,,1)\n    address 'ISPEXEC' 'TBADD CHTTAB'\n\n    address 'ISPEXEC' 'TBSORT CHTTAB FIELDS(ADDR,N,A)'\n    address 'ISPEXEC' 'CONTROL DISPLAY SAVE'\n    address 'ISPEXEC' 'TBDISPL CHTTAB PANEL(CSHMAN5)'\n    cc = rc\n    address 'ISPEXEC' 'CONTROL DISPLAY RESTORE'\n    address 'ISPEXEC' 'TBCLOSE CHTTAB'\n  end\nreturn\n\nParse_Counts:\nv = 0\nwrite1 = ''\ndo i = 1 to rline.0\n  parse var rline.i tok1 .\n  select\n     when tok1 = 'VOLUME'\n     then do\n            v = v + 1\n            parse var rline.i . vol.ix.v . . xaddr\n            xaddr = substr(xaddr,2,length(xaddr)-1)\n            xaddr = strip(xaddr,'B',\"'\")\n            adr.ix.v = x2d(xaddr)\n            i = i + 7\n          end\n     when tok1 = 'CACHE'\n     then do\n            parse var rline.i . 'WRITE' . b0.ix.v c0.ix.v . e0.ix.v .\n            if datatype(e0.ix.v) \u00ac= 'NUM' then e0.ix.v = 0\n          end\n\n     when tok1 = 'TOTALS'\n     then do\n            parse var rline.i . a1.ix.v b1.ix.v c1.ix.v ,\n                                d1.ix.v e1.ix.v .\n            i = i + 1\n          end\n     when tok1 = 'INHIBIT'\n     then do\n            parse var rline.i 'LOADING' f2.ix.v .\n          end\n     when tok1 = 'BYPASS'\n     then do\n            parse var rline.i 'CACHE' f3.ix.v .\n            i = i + 2\n          end\n     when tok1 = 'DASD'\n     then do\n            parse var rline.i 'RETRIES' f5.ix.v .\n            i = i + 4\n          end\n     otherwise nop\n  end\nend\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Lookup_Model   starts here                                    */\n/*     MDR device type codes                                         */\n/*     Hex      (Dec)                                                */\n/*     x'11'      17            3350                                 */\n/*     x'14'      20            3380-A                               */\n/*     x'1B'      27            3380-E                               */\n/*     x'1C'      28            3380-D                               */\n/*     x'21'      33            3380-J                               */\n/*     x'23'      35            3380-K                               */\n/*     x'24'      36            3390-3                               */\n/*     x'26'      38            3390-1                               */\n/*     x'27'      39            3390-2                               */\n/*     x'32'      50            3390-9   w/2724'x data & alt cyls    */\n/*     x'32'      50            6395-5   w/13D4'x data & alt cyls    */\n/*                                                                   */\n/*-------------------------------------------------------------------*/\nLookup_Model:\narg MDR_code cyls_in_hex\n\nselect\n  when MDR_code = '11'x    then type = '3350  '\n  when MDR_code = '14'x    then type = '3380-A'\n  when MDR_code = '1B'x    then type = '3380-E'\n  when MDR_code = '1C'x    then type = '3380-D'\n  when MDR_code = '21'x    then type = '3380-J'\n  when MDR_code = '23'x    then type = '3380-K'\n  when MDR_code = '24'x    then type = '3390-3'\n  when MDR_code = '26'x    then type = '3390-1'\n  when MDR_code = '27'x    then type = '3390-2'\n  when MDR_code = '32'x\n       then if cyls_in_hex = '13D4'x\n            then type = '3390-5'\n            else\n            if cyls_in_hex = '2724'x\n            then type = '3390-9'\n            else type = '3390-x'\n  otherwise do\n              type = '?'\n              mdrmsg = c2x(MDR_code)\n              address 'ISPEXEC' 'SETMSG MSG(CSHM022) COND'\n            end\nend\nreturn(type)\n\n/*-------------------------------------------------------------------*/\n/*     List_Stat      starts here                                    */\n/*-------------------------------------------------------------------*/\nList_Stat:\nprocedure expose act saved_ssid cachlog rline.\narg Lvolser Ldevt Lfunc Laddr\n\ncmdl = 'LISTDATA STATUS VOL('Lvolser') UNIT('Ldevt')'\ncall Execute_Cmd 12\nif result < 5                /* 3880s return 4 for SD offline */\nthen do\n       act   = ''\n       table = 'SSGTAB'\n       call ParseListd table Laddr Ldevt Lfunc Lvolser\n     end\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Confirm_Destage starts here                                   */\n/*-------------------------------------------------------------------*/\nConfirm_Destage:\nprocedure expose rline.\n/* Use a PopUp window to prompt for confirmation before DESTAGE      */\n\n   address 'ISPEXEC' 'ADDPOP ROW(10)'\n   zwinttl = 'Destage Confirmation'\n   address 'ISPEXEC' 'DISPLAY PANEL(CSHDSTG) CURSOR(ZCMD)'\n   cc = rc\n   address 'ISPEXEC' 'REMPOP'\nreturn(cc)\n\n/*-------------------------------------------------------------------*/\n/*     Confirm_CachPerf starts here                                  */\n/*-------------------------------------------------------------------*/\nConfirm_CachPerf:\nprocedure expose rline.\n/* Use a PopUp window to prompt for foreground or background Cache   */\n/* Performance statistics                                            */\n\n   address 'ISPEXEC' 'ADDPOP ROW(10)'\n   zwinttl = 'Cache Performance Stats'\n   address 'ISPEXEC' 'DISPLAY PANEL(CSHPERF) CURSOR(ZCMD)'\n   cc = rc\n   address 'ISPEXEC' 'REMPOP'\nreturn(cc)\n\n/*-------------------------------------------------------------------*/\n/*     Batch_CachPerf starts here                                    */\n/*-------------------------------------------------------------------*/\nBatch_CachPerf:\n  address 'ISPEXEC' 'FTOPEN TEMP'\n  address 'ISPEXEC' 'FTINCL CSHSKEL2'\n  if rc = 0\n  then\n    do\n      address 'ISPEXEC' 'FTCLOSE'\n      address 'ISPEXEC' 'VGET (ZTEMPF)'\n      address 'TSO' 'SUBMIT '''ztempf''''\n      cc = 0\n    end\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Process_Devtype_Err starts here                               */\n/*-------------------------------------------------------------------*/\nProcess_Devtype_Err:\nprocedure expose cc\narg Lresult\n\n  if cc = 2                 /* invalid device type  */\n  then\n    do\n      newdev = c2x(substr(Lresult,10,1))\n      address 'ISPEXEC' 'SETMSG MSG(CSHM023) COND'\n    end\n  else\n  if cc = 4                 /* DEVTYPE macro failed */\n  then\n    do\n      address 'ISPEXEC' 'SETMSG MSG(CSHM024) COND'\n    end\n  else\n  if cc = 8                 /* allocation or deallocation failed */\n  then\n    do\n      address 'ISPEXEC' 'SETMSG MSG(CSHM025) COND'\n    end\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Set_Options  starts here                                      */\n/*     display screen to prompt for new values                       */\n/*     panel does the VPUT to add these to the profile               */\n/*-------------------------------------------------------------------*/\nSet_Options:\n   address 'ISPEXEC' 'DISPLAY PANEL(CSHOPT)'\n   rc = 0\n\n   address 'ISPEXEC' 'VGET (CACHVW CACHLOG CACHREF CACHST CACHSCNT ,\n       CACHSPIN CACHSRAT CACHMB CACHSDV CACHDSTG CACHDCNT CACHDPIN ,\n       CACHDSUB CACHDDUP ATCACH ATCFW ATNVS CACHCNF CACHXCP) ASIS'\n   call Set_Verifies\nreturn\n\nSet_Verifies:\n/*-------------------------------------------------------------------*/\n/* verctl and verdev are used for VER strings in the )PROC sections  */\n/* of panels CSHMAN1 and CSHMAN3                                     */\n/*-------------------------------------------------------------------*/\n verctl = CACHST||','||CACHSCNT||','||CACHSDV||','||CACHSPIN||','\n verctl = verctl||CACHSRAT||','||CACHDSTG||','||CACHMB||','' '',''='''\n\n verdev = CACHDCNT||','||CACHDPIN||','||CACHDSUB||','||CACHDDUP\n verdev = verdev||','||CACHSRAT||','' '',''='''\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Rc8_Display    starts here                                    */\n/* Use a PopUp window to display the error messages from the IDCAMS  */\n/* functions.                                                        */\n/*-------------------------------------------------------------------*/\nRc8_Display:\nprocedure expose rline.\narg Lretcode Ltitle\n\n   cc = lretcode\n   address 'ISPEXEC' 'TBCREATE ERRTB NAMES(XLINE) NOWRITE REPLACE'\n   do i = 1 to rline.0\n      xline = rline.i\n     address 'ISPEXEC' 'TBADD ERRTB'\n   end\n   address 'ISPEXEC' 'ADDPOP ROW(9)'\n   zwinttl = Ltitle\n   address 'ISPEXEC' 'TBTOP ERRTB'\n   address 'ISPEXEC' 'TBDISPL ERRTB PANEL(CSHERRP) CURSOR(ZCMD)'\n   address 'ISPEXEC' 'REMPOP'\n   address 'ISPEXEC' 'TBCLOSE ERRTB'\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Process_ZCMD   starts here                                    */\n/*-------------------------------------------------------------------*/\nProcess_ZCMD:\nprocedure expose rline. act_3880. tbmdl tbssst tbsdst tbnvst tdecad ,\n         tbu cachlog zcmd saved_ssid emsg vdate verdev verctl cachvw ,\n         cachlog cachref cachst cachscnt cachspin cachsrat cachsdv ,\n         cachdstg cachdcnt cachdpin cachdsub cachddup atcach atcfw ,\n         atnvs cachcnf cachxcp tdsn ldsn hilevel_qual sorted userid\narg Lsection\n\n   if substr(ZCMD,1,3) = 'REF'     /* refresh controller status */\n   then do\n          if Lsection = 'DEV'\n          then do\n                 address 'ISPEXEC' 'TBGET  SSGTAB'\n                 call Get_Dev_Info TBV TBDTYP\n               end\n\n          if Lsection = 'CTL'\n          then saved_ssid = 0\n          address 'ISPEXEC' 'TBQUERY SSGTAB ROWNUM(ROWS) ,\n                             POSITION(CROW)'\n          address 'ISPEXEC' 'TBTOP SSGTAB'\n          do rows\n            address 'ISPEXEC' 'TBSKIP SSGTAB'\n            address 'ISPEXEC' 'TBGET  SSGTAB'\n            call List_Stat TBV TBDTYP 'TBPUT' TBU\n          end\n          address 'ISPEXEC' 'TBTOP SSGTAB'\n          address 'ISPEXEC' 'TBSKIP SSGTAB ROW('CROW')'\n        end\n   else\n   if substr(ZCMD,1,3) = 'NEW'     /* check for What's new request */\n   then do\n          address 'ISPEXEC' 'DISPLAY PANEL(CSHWNEW) CURSOR(ZCMD)'\n        end\n   else\n   if substr(ZCMD,1,3) = 'EXC'     /* check for exceptional status */\n   then do\n          call 'CACHXCPT'\n        end\n   else\n   if substr(ZCMD,1,3) = 'MEM'     /* invoke member selection proc */\n   then do\n          call 'CACHEGRP' tdsn\n        end\n   else\n   if ZCMD = 'OPT'\n   then do\n          /* restore value to previous used PFKEY */\n          interpret pfkey '= saved_pfk'\n          address 'ISPEXEC' 'VPUT ('pfkey') PROFILE'\n\n          call Set_Options\n\n          address 'ISPEXEC' 'VGET (CACHREF,ZKEYS) PROFILE'\n          pfk_num = cachref\n          if pfk_num < 13 & zkeys = 12\n          then pfk_num = cachref + 12\n          pfkey = 'ZPF'||right(pfk_num,2,'0')\n          address 'ISPEXEC' 'VGET ('pfkey') PROFILE'\n          saved_pfk = value(pfkey)\n          interpret pfkey '= ''REF'''\n          address 'ISPEXEC' 'VPUT ('pfkey') PROFILE'\n          rc = 0\n        end\n   else\n   if substr(ZCMD,1,3) = 'VDA'     /* query version date */\n   then call Query_Info\n   else\n   if substr(ZCMD,1,3) = 'SOR' & Lsection = 'CTL'  /* display order */\n   then do\n          sorted = 'Y'\n          address 'ISPEXEC' 'VGET (OBJECT,VALUE) SHARED'\n          if object = 'SSID'\n          then if value= 'D'\n              then address 'ISPEXEC' 'TBSORT SSGTAB FIELDS(TBSSIDD,N,D)'\n              else address 'ISPEXEC' 'TBSORT SSGTAB FIELDS(TBSSIDD,N,A)'\n          else\n          if object = 'CACHE' | object = 'MEM'\n          then if value= 'D'\n               then address 'ISPEXEC' 'TBSORT SSGTAB ,\n                             FIELDS(TBSSSTG,C,D,TBUD,N,A)'\n               else address 'ISPEXEC' 'TBSORT SSGTAB ,\n                             FIELDS(TBSSSTG,C,A,TBUD,N,A)'\n          else\n          if object = 'NVS'\n          then if value= 'D'\n               then address 'ISPEXEC' 'TBSORT SSGTAB ,\n                             FIELDS(TBNVSSTG,C,D,TBUD,N,A)'\n               else address 'ISPEXEC' 'TBSORT SSGTAB ,\n                             FIELDS(TBNVSSTG,C,A,TBUD,N,A)'\n          else address 'ISPEXEC' 'TBSORT SSGTAB FIELDS(TBUD,N,A)'\n        end\n   else\n   if substr(ZCMD,1,3) = 'DCA'     /* display cache status of all */\n   then do\n          address 'ISPEXEC' 'SELECT PGM(CACHSTAT)'\n          call Display_Cache_Stat\n        end\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     WriteLog       starts here                                    */\n/*-------------------------------------------------------------------*/\nWriteLog:\nprocedure expose cachlog rline.\narg Lretcode Lcmdline\n\n if CACHLOG = 'YES'\n then do\n        queue date('U') time() 'RC='right(Lretcode,2)  Lcmdline\n        address 'TSO' 'EXECIO 1 DISKW CACHLG (FINIS'\n        if rc > 0\n        then do\n               CACHLOG = 'NO'\n               address 'ISPEXEC' 'SETMSG MSG(CSHM036) COND'\n             end\n      end\n\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Query_Info     starts here                                    */\n/*-------------------------------------------------------------------*/\nQuery_Info:\n  zwinttl = 'Cacheman Information'\n  address 'ISPEXEC' 'ADDPOP ROW(4)'\n  address 'ISPEXEC' 'DISPLAY PANEL(CSHINFO)'\n  address 'ISPEXEC' 'REMPOP'\nreturn\n\n/*-------------------------------------------------------------------*/\n/*     Cleanup        starts here                                    */\n/*-------------------------------------------------------------------*/\nClean_up:\n\nif CACHLOG = 'YES'\nthen do\n       address 'TSO' 'EXECIO 0 DISKW CACHLG (FINIS'\n       address 'TSO' 'FREE FI(CACHLG)'\n     end\ninterpret pfkey '= saved_pfk'\naddress 'ISPEXEC' 'VPUT ('pfkey') PROFILE'\ndummy = msg(hold_msg)\naddress 'ISPEXEC' 'LIBDEF ISPTLIB'\naddress 'ISPEXEC' 'LIBDEF ISPTABL'\ncachact = 'NO'\naddress 'ISPEXEC' 'VPUT (CACHACT) PROFILE'\nreturn\n\nHALT:\naddress 'ISPEXEC' 'TBCLOSE' table\naddress 'ISPEXEC' 'TBCLOSE SSGTAB'\ncall Clean_up\nexit\n\nSYNTAX:\nsay 'Syntax  on line' sigl\nsay 'RC =' rc\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CACHPERF": {"ttr": 257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x00\\x96\\x15_\\x00\\x96\\x15_\\x15D\\x00\\xdb\\x00\\xdb\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-06-03T00:00:00", "modifydate": "1996-06-03T15:44:20", "lines": 219, "newlines": 219, "modlines": 0, "user": "CEB40"}, "text": "/*  rexx exec to create Batch Cache Performance Report --------------*/\n/*  (C) COPYRIGHT AMDAHL CORPORATION  1995. All Rights Reserved      */\n/*  written:  October 1994                                           */\n/*  author :  Chuck Baumann                                          */\n/*-------------------------------------------------------------------*/\narg samptime num_of_intervals volume devtype rtype\n\n/*-------------------------------------------------------------------*/\n/*  Use outtrap to get output from LISTDATA commands                 */\n/*-------------------------------------------------------------------*/\n  dummy = outtrap('rline.','*','NOCONCAT')\n\n  cmdl = 'LISTDATA COUNTS VOL('volume') UNIT('devtype')' rtype\n  address 'TSO' cmdl\n  if rc = 0\n  then call Get_Cache_Rates\n\n  address 'TSO' 'EXECIO 0 DISKW SYSTSPRT (FINIS'\nexit\n\n/*-------------------------------------------------------------------*/\n/*     SUBROUTINES start here                                        */\n/*-------------------------------------------------------------------*/\n/*-------------------------------------------------------------------*/\n/*     Get_Cache_Rates starts here                                   */\n/*-------------------------------------------------------------------*/\nGet_Cache_Rates:\n\nix = 1\ntimex = time()\nparse var timex hh ':' mm ':' ss\nint_time.ix = hh * 3600 + mm * 60 + ss\ncall Parse_Counts ix\ncc = 0\n  do while ix < num_of_intervals + 1\n    timex = time()\n    parse var timex hh ':' mm ':' ss\n    timex = hh * 3600 + mm * 60 + ss\n\n    if int_time.ix + samptime > timex\n    then this_interval = int_time.ix + samptime - timex\n    else this_interval = 0\n\n    if this_interval > 0\n    then call 'SLEEP' this_interval\n\n    ix = ix + 1\n    timex = time()\n    parse var timex hh ':' mm ':' ss\n\n    int_time.ix = hh * 3600 + mm * 60 + ss\n    cmdl = 'LISTDATA COUNTS VOL('volume') UNIT('devtype')' rtype\n    address 'TSO' cmdl\n\n    call Parse_Counts ix\n    ctlr_bzer = 0\n    ctlr_ezer = 0\n    ctlr_aone = 0\n    ctlr_bone = 0\n    ctlr_cone = 0\n    ctlr_done = 0\n    ctlr_eone = 0\n    ctlr_ftwo = 0\n    ctlr_fthr = 0\n    ctlr_ffive = 0\n    iy = ix - 1\n    interval = int_time.ix - int_time.iy\n\n    queue '1'date('U') time() '********* New Interval *********'\n    line = '           I/O   CaHit TotHit DFWHit Bypass  Inhib   R/W'\n    line2 = '  RHit  DFWHit CFWHit  Stage DFWRetry'\n    queue line line2\n    line = ' Volser   Rate    Pct    Pct    Pct   Rate    Rate  Rate'\n    line2 = ' Rate   Rate    Rate    Rate  Rate'\n    queue line line2\n\n    do j = 1 to v\n      bzer = b0.ix.j - b0.iy.j\n      ctlr_bzer = ctlr_bzer + bzer\n\n      czer = c0.ix.j - c0.iy.j       /* CFW total */\n\n      ezer = e0.ix.j - e0.iy.j\n      ctlr_ezer = ctlr_ezer + ezer\n\n      aone = a1.ix.j - a1.iy.j\n      ctlr_aone = ctlr_aone + aone\n      bone = b1.ix.j - b1.iy.j\n      ctlr_bone = ctlr_bone + bone\n      cone = c1.ix.j - c1.iy.j\n      ctlr_cone = ctlr_cone + cone\n      done = d1.ix.j - d1.iy.j\n      done = done + czer            /* following CRR report */\n      ctlr_done = ctlr_done + done\n      eone = e1.ix.j - e1.iy.j\n      ctlr_eone = ctlr_eone + eone\n      ftwo = f2.ix.j - f2.iy.j\n      ctlr_ftwo = ctlr_ftwo + ftwo\n      fthr = f3.ix.j - f3.iy.j\n      ctlr_fthr = ctlr_fthr + fthr\n      ffive = f5.ix.j - f5.iy.j\n      ctlr_ffive = ctlr_ffive + ffive\n      volser = vol.ix.j\n      io  = format((aone + cone + ftwo + fthr) / interval,,1)\n\n      if (aone + done) > 0\n      then cachable = format(((bone + eone) / (aone + done)) ,\n                      * 100,,1)\n      else cachable = 0\n\n      if (aone + cone + ftwo + fthr) > 0\n      then tothit = format((bone + eone)/ ,\n                    (aone + cone + ftwo + fthr) * 100,,1)\n      else tothit = 0\n\n      if done > 0\n      then dfwpct = format((eone / done) * 100,,1)\n      else dfwpct = 0\n\n      dfwhit = format(done / interval,,1)\n      cfwhit = format((bzer + ezer) / interval,,1)\n      stage  = format((aone - bone + done - eone)/ interval,,1)\n\n      if cone > 0\n      then rw = format(aone / cone,,2)\n      else rw = 0\n      rhit   = format(bone / interval,,1)\n      dfwretry = format(ffive / interval,,1)\n      bypass = format(fthr / interval,,1)\n      inhibit = format(ftwo / interval,,1)\n      line1 = left(volser,6) right(io,6) right(cachable,6)\n      line2 = right(tothit,6) right(dfwpct,6) right(bypass,6)\n      line3 = right(inhibit,6) right(rw,6) right(rhit,6)\n      line4 = right(dfwhit,6) right(cfwhit,6) right(stage,6)\n      line5 = right(dfwretry,6)\n      line = ' 'line1 line2 line3 line4 line5\n      queue line\n    end\n    volser = ' TOTAL'\n    io  = format((ctlr_aone + ctlr_cone + ctlr_ftwo + ctlr_fthr) ,\n          / interval,,1)\n    if (ctlr_aone + ctlr_done) > 0\n    then cachable = format(((ctlr_bone + ctlr_eone) / ,\n                    (ctlr_aone + ctlr_done)) * 100,,1)\n    else cachable = 0\n    if (ctlr_aone + ctlr_cone + ctlr_ftwo + ctlr_fthr) > 0\n    then tothit = format((ctlr_bone + ctlr_eone) / ,\n           (ctlr_aone + ctlr_cone + ctlr_ftwo + ctlr_fthr) ,\n             * 100,,1)\n    else tothit = 0\n    if ctlr_done > 0\n    then dfwpct = format((ctlr_eone / ctlr_done) * 100,,1)\n    else dfwpct = 0\n    dfwhit = format(ctlr_done / interval,,1)\n    cfwhit = format((ctlr_bzer + ctlr_ezer) / interval,,1)\n    stage  = format((ctlr_aone - ctlr_bone + ,\n             ctlr_done - ctlr_eone) / interval,,1)\n\n    if ctlr_cone > 0\n    then rw = format(ctlr_aone / ctlr_cone,,2)\n    else rw = 0\n    rhit   = format(ctlr_bone / interval,,1)\n    dfwretry = format(ctlr_ffive / interval,,1)\n    bypass = format(ctlr_fthr / interval,,1)\n    inhibit = format(ctlr_ftwo / interval,,1)\n    line1 = left(volser,6) right(io,6) right(cachable,6)\n    line2 = right(tothit,6) right(dfwpct,6) right(bypass,6)\n    line3 = right(inhibit,6) right(rw,6) right(rhit,6)\n    line4 = right(dfwhit,6) right(cfwhit,6) right(stage,6)\n    line5 = right(dfwretry,6)\n    line = ' 'line1 line2 line3 line4 line5\n    queue line\n    address 'TSO' 'EXECIO' queued() 'DISKW SYSTSPRT'\n\n    cc = rc\n  end\nreturn\n\nParse_Counts:\nv = 0\ndo i = 1 to rline.0\n  parse var rline.i tok1 .\n  select\n     when tok1 = 'VOLUME'\n     then do\n            v = v + 1\n            parse var rline.i . vol.ix.v .\n            i = i + 7\n          end\n\n     when tok1 = 'CACHE'\n     then do\n            parse var rline.i . 'WRITE' . b0.ix.v c0.ix.v . e0.ix.v .\n            if datatype(e0.ix.v) \u00ac= 'NUM' then e0.ix.v = 0\n          end\n     when tok1 = 'TOTALS'\n     then do\n            parse var rline.i . a1.ix.v b1.ix.v c1.ix.v ,\n                                d1.ix.v e1.ix.v .\n            i = i + 1\n          end\n     when tok1 = 'INHIBIT'\n     then do\n            parse var rline.i 'LOADING' f2.ix.v .\n          end\n     when tok1 = 'BYPASS'\n     then do\n            parse var rline.i 'CACHE' f3.ix.v .\n            i = i + 2\n          end\n     when tok1 = 'DASD'\n     then do\n            parse var rline.i 'RETRIES' f5.ix.v .\n            i = i + 4\n          end\n     otherwise nop\n  end\nend\nreturn\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CACHXCPT": {"ttr": 24, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00)\\x00\\x95\\x04\\x1f\\x00\\x95 _\\x106\\x00<\\x00;\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "1995-02-10T00:00:00", "modifydate": "1995-07-24T10:36:29", "lines": 60, "newlines": 59, "modlines": 0, "user": "CEB40"}, "text": "/*  rexx exec called by Amdahl Cache Utility to check for exceptions */\n/*  (C) COPYRIGHT AMDAHL CORPORATION  1995. All Rights Reserved      */\n/*  written:  February 1995                                          */\n/*  author :  Chuck Baumann                                          */\n/*  Panels :  CSHMAN7                                                */\n/*  Help   :  CSHHMAN7                                               */\n/*  Changes:  V1.0 -- Initial functions                              */\n/*  95/02/02  V2.3 -- Check for exceptional conditions               */\n/*-------------------------------------------------------------------*/\naddress 'ISPEXEC' 'TBCREATE EXCEPT ,\n  NAMES(TBMDL,TBSSID,TBSSSTG,TBSSAVL,TBNVSAVL,TBNVSSTG,TBU,TBREASON) ,\n   NOWRITE REPLACE'\n\naddress 'ISPEXEC' 'TBQUERY SSGTAB ROWNUM(ROWS) POSITION(CROW)'\naddress 'ISPEXEC' 'TBTOP SSGTAB'\ndo rows\n  x = 'N'                    /* x = flag to indicate exception */\n  address 'ISPEXEC' 'TBSKIP SSGTAB'\n  address 'ISPEXEC' 'TBGET  SSGTAB'\n  if TBOFF \u00ac= 'NO'           /* some cache memory is offline */\n  then do\n         x = 'Y'\n         tbreason = 'Cache or NVS memory is offline'\n       end\n  if TBSSST \u00ac= 'ON'          /* subsystem cache is not on */\n  then do\n         x = 'Y'\n         tbreason = 'Subsystem Cache is not on'\n       end\n  if substr(TBNVST,1,1) \u00ac= 'O' ,  /* NVS in error condition */\n  &  tbmdl \u00ac= '3880'\n  then do\n         x = 'Y'\n         tbreason = 'NVS is in an error state'\n       end\n  if TBPIN  \u00ac= 'NO' ,        /* pinned data exists       */\n  then do\n         x = 'Y'\n         tbreason = 'Pinned data exists'\n       end\n  if x = 'Y'\n  then do\n         address 'ISPEXEC' 'TBADD EXCEPT'\n       end\nend\n\naddress 'ISPEXEC' 'TBQUERY EXCEPT ROWNUM(ROWS)'\nif rows > 0\nthen do\n       address 'ISPEXEC' 'TBTOP EXCEPT'\n       do while rc < 8\n         address 'ISPEXEC' 'TBDISPL EXCEPT PANEL(CSHMAN7)'\n       end\n     end\nelse address 'ISPEXEC' 'SETMSG MSG(CSHM035) COND'\n\naddress 'ISPEXEC' 'TBCLOSE EXCEPT'\naddress 'ISPEXEC' 'TBTOP SSGTAB'\naddress 'ISPEXEC' 'TBSKIP SSGTAB ROW('CROW')'\nreturn\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COMPILE": {"ttr": 12, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x00\\x95\\x15\\x0f\\x00\\x95\\x15\\x0f\\x15\\x19\\x00B\\x00B\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-05-30T00:00:00", "modifydate": "1995-05-30T15:19:24", "lines": 66, "newlines": 66, "modlines": 0, "user": "CEB40"}, "text": "//CEB40C   JOB (4052CEB,503),'BATCH COMPILE',MSGCLASS=Y,                JOB11170\n//             MSGLEVEL=(1,1),NOTIFY=CEB40\n//*\n//*********************************************************************\n//* Invoke REXX compiler for CEB40.V24.ACU.EXEC(CACHEMN1)\n//* Load Library will be CEB40.V24.ACU.ISPLLIB\n//* The Load library should be the same as the one in the LIBDEF\n//*     ISPLLIB statement in the CACHEMN0 exec.\n//* WARNING: **********************************************************\n//* Do NOT compile CACHEMAN or CACHEMN0. Invocation will fail.\n//*********************************************************************\n//CMN1    EXEC PGM=IKJEFT01,REGION=6M,TIME=2,DYNAMNBR=200\n//SYSPROC  DD  DSN=SYS1.SISPEXEC,DISP=SHR  REXX Compiler exec lib\n//SYSLIB   DD  DSN=CEB40.V24.ACU.EXEC,DISP=SHR\n//SYSTSPRT DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=(Y)\n//SYSTSIN  DD  *\n  PROFILE PREFIX(CEB40) MSGID\n  REXXC 'CEB40.V24.ACU.EXEC(CACHEMN1)' +\n  PRINT(**) +\n  OBJ(,EFPL,V24.ACU.ISPLLIB),NOCEXEC\n/*\n//CDUP    EXEC PGM=IKJEFT01,REGION=6M,TIME=2,DYNAMNBR=200\n//SYSPROC  DD  DSN=SYS1.SISPEXEC,DISP=SHR  REXX Compiler exec lib\n//SYSLIB   DD  DSN=CEB40.V24.ACU.EXEC,DISP=SHR\n//SYSTSPRT DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=(Y)\n//SYSTSIN  DD  *\n  PROFILE PREFIX(CEB40) MSGID\n  REXXC 'CEB40.V24.ACU.EXEC(CACHEDUP)' +\n  PRINT(**) +\n  OBJ(,EFPL,V24.ACU.ISPLLIB),NOCEXEC\n/*\n//CPERF   EXEC PGM=IKJEFT01,REGION=6M,TIME=2,DYNAMNBR=200\n//SYSPROC  DD  DSN=SYS1.SISPEXEC,DISP=SHR  REXX Compiler exec lib\n//SYSLIB   DD  DSN=CEB40.V24.ACU.EXEC,DISP=SHR\n//SYSTSPRT DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=(Y)\n//SYSTSIN  DD  *\n  PROFILE PREFIX(CEB40) MSGID\n  REXXC 'CEB40.V24.ACU.EXEC(CACHPERF)' +\n  PRINT(**) +\n  OBJ(,EFPL,V24.ACU.ISPLLIB),NOCEXEC\n/*\n//CXCPT   EXEC PGM=IKJEFT01,REGION=6M,TIME=2,DYNAMNBR=200\n//SYSPROC  DD  DSN=SYS1.SISPEXEC,DISP=SHR  REXX Compiler exec lib\n//SYSLIB   DD  DSN=CEB40.V24.ACU.EXEC,DISP=SHR\n//SYSTSPRT DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=(Y)\n//SYSTSIN  DD  *\n  PROFILE PREFIX(CEB40) MSGID\n  REXXC 'CEB40.V24.ACU.EXEC(CACHXCPT)' +\n  PRINT(**) +\n  OBJ(,EFPL,V24.ACU.ISPLLIB),NOCEXEC\n/*\n//CGRP    EXEC PGM=IKJEFT01,REGION=6M,TIME=2,DYNAMNBR=200\n//SYSPROC  DD  DSN=SYS1.SISPEXEC,DISP=SHR  REXX Compiler exec lib\n//SYSLIB   DD  DSN=CEB40.V24.ACU.EXEC,DISP=SHR\n//SYSTSPRT DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=(Y)\n//SYSTSIN  DD  *\n  PROFILE PREFIX(CEB40) MSGID\n  REXXC 'CEB40.V24.ACU.EXEC(CACHEGRP)' +\n  PRINT(**) +\n  OBJ(,EFPL,V24.ACU.ISPLLIB),NOCEXEC\n/*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COMPMN1": {"ttr": 14, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00I\\x00\\x95\\x15\\x0f\\x00\\x95\\x15\\x0f\\x15#\\x00\\r\\x00\\x16\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-05-30T00:00:00", "modifydate": "1995-05-30T15:23:49", "lines": 13, "newlines": 22, "modlines": 0, "user": "CEB40"}, "text": "//CEB40C   JOB (4052CEB,503),'BATCH COMPILE',MSGCLASS=Y,                JOB11170\n//             MSGLEVEL=(1,1),NOTIFY=CEB40\n//CMN1    EXEC PGM=IKJEFT01,REGION=6M,TIME=2,DYNAMNBR=200\n//SYSPROC  DD  DSN=SYS1.SISPEXEC,DISP=SHR  REXX Compiler exec lib\n//SYSLIB   DD  DSN=CEB40.V24.ACU.EXEC,DISP=SHR\n//SYSTSPRT DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=(Y)\n//SYSTSIN  DD  *\n  PROFILE PREFIX(CEB40) MSGID\n  REXXC 'CEB40.V24.ACU.EXEC(CACHEMN1)' +\n  PRINT(**) +\n  OBJ(,EFPL,V23.ACU.ISPLLIB),NOCEXEC\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IEFU84": {"ttr": 266, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x00\\x98\\x01?\\x00\\x98\\x01?\\x08\\x13\\x022\\x022\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-01-13T00:00:00", "modifydate": "1998-01-13T08:13:34", "lines": 562, "newlines": 562, "modlines": 0, "user": "CEB40"}, "text": "//CEB40U84 JOB (X),'CHUCK.B',MSGCLASS=Y,CLASS=A\n//ASM   EXEC ASMHCL,PARM.C='RENT',\n//            PARM.L='LIST,MAP,LET,RENT,REFR'\n//C.SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR\n//          DD DSN=SYS1.MODGEN,DISP=SHR\n//C.SYSIN DD *\n         TITLE 'IEFU84 BRANCH ENTERED SMF EXIT'\nIEFU84   CSECT\nIEFU84  AMODE 31\nIEFU84  RMODE ANY\n*--------------------------------------------------------------------\n*  (C) COPYRIGHT AMDAHL CORPORATION  1995. All Rights Reserved\n*    This SMF exit routine only handles type 22(8) records\n*    and issues a WTO (branch entered) describing 3990 state changes.\n*    All other record types are ignored.\n* Entry Points -\n*         IEFU84\n* Locks -\n*  Local lock (enabled for I/O and EXT interrupts)\n* Input\n*    Register 1 contains the address of a fullword that points to\n*    the record that SMF is going to write.\n*\n* Output\n*    Register 15 must contain one of the following return codes:\n*    0 - Write the SMF record (keep)\n*    4 - Don't write the SMF record (delete)\n*\n* Installation\n*    Assemble and link into SYS1.LPALIB.  Re-IPL with CLPA option.\n*    Edit the SYS1.PARMLIB(SMFPRMxx) member and add IEFU84 to the\n*    EXITS for SYS and make sure SMF type 22 is being recorded.\n* Written by:  Chuck Baumann,   Amdahl   January 1995\n*              optional part of Cacheman utility\n*--------------------------------------------------------------------\n         EJECT\n         YREGS\nTYPE22   EQU   X'16'               SMF type 22 record\nS3990CHG EQU   X'08'               3990 state change indicator\nCACHSTAT EQU   B'11100000'         cache status changes\nDEVSTAT  EQU   B'11000000'         device cache status bits\nPINSTAT  EQU   B'11000000'         pinned data status bits\nDFWSTAT  EQU   B'00110000'         DFW cache status bits\nDUPSTAT  EQU   B'00000011'         Duplex cache status bits\nACTIVE   EQU   B'00000000'         active\nPENDACT  EQU   B'00100000'         pending active\nDEACTSUB EQU   B'01000000'         deactivated subsystem\nDEACTHST EQU   B'10000000'         deactivated host\nPENDING  EQU   B'11000000'         pending\nPENDFAIL EQU   B'11100000'         pending off failed\nSSDISABL EQU   B'00010000'         subsystem storage disabled maint\nIMLDEV   EQU   B'00000010'         IML device is not available\nCFWDISAB EQU   B'00000001'         Cache Fast Write is disabled\nDEV00    EQU   B'00000000'         active\nDEV40    EQU   B'01000000'         not used\nDEV80    EQU   B'10000000'         deactivation pending\nDEVC0    EQU   B'11000000'         deactivated\nDUP00    EQU   B'00000000'         available\nDUP01    EQU   B'00000001'         pending\nDUP02    EQU   B'00000010'         failed duplex,\nDUP03    EQU   B'00000011'         failed duplex,\nDUP04    EQU   B'00000100'         secondary of duplex pair\nDUP08    EQU   B'00001000'         primary of duplex pair\nDFW00    EQU   B'00000000'         active\nDFW10    EQU   B'00010000'         not used\nDFW20    EQU   B'00100000'         deactivation pending\nDFW30    EQU   B'00110000'         deactivated\nPIN00    EQU   B'00000000'         no pinned data exists\nPIN40    EQU   B'01000000'         pinned data exists for suspended\nPIN80    EQU   B'10000000'         reserved bit\nPINC0    EQU   B'11000000'         pinned data exists for suspended\nNVS00    EQU   B'00000000'         NVS is active\nNVS40    EQU   B'01000000'         NVS deactivated subsystem\nNVS80    EQU   B'10000000'         NVS deactivated host\nNVSC0    EQU   B'11000000'         NVS is pending\nNVSSTAT  EQU   B'11000000'         NVS status changes\nNVSDISMT EQU   B'00010000'         NVS disabled for Maintenance\nNVSPEND  EQU   B'00001000'         NVS pending due to error\nCCAMASK  EQU   B'11000000'         N mask for CCA reconstruction\n*\n         EJECT\n         USING *,R15               Temporary base for\n         B     HERE                branching around\n         DC    CL8'IEFU84  '       module name\n         DC    CL8'&SYSDATE'\n         DC    CL8' @ &SYSTIME'\nHERE     STM   R14,R12,12(R13)     save regs\n         DROP  R15                 drop temp base\n         USING IEFU84,R12          base\n         LR    R12,R15\n         LR    R11,R1              save ptr to parms\n         LR    R10,R13             save temporary until getmain is done\n         L     R2,0(R11)           get smf record address\n         CLI   5(R2),TYPE22        is it type 22?\n         BNE   QUIKEXIT            if not then go to exit\n         CLI   19(R2),S3990CHG     was it created by 3990 state chg?\n         BNE   QUIKEXIT            if not then go to exit\n*\n*  Obtain the Local lock unconditionally\n*\nGETLOCK  EQU   *\n         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=USE\nSAVERC   LR    R9,R15              save return code from setlock\n*\n         L     R5,CVTPTR           R5 = addr of cvt\n         USING CVT,R5\n         L     R6,CVTTCBP          R6 = ptr to addr of cur tcb\n         L     R7,12(R6)           R7 = addr of current ascb\n         DROP  R5\n         SR    R0,R0               clear reg 0  (mem really is SP252\n*                                  because we are key 0 supervisor st)\n         SR    R4,R4               indicate current TCB\n         LA    R0,WORKLEN          set length for getmain from sp 0\n*                                  R4 and R7 are used by branch GETMAIN\n         GETMAIN R,LV=(R0),BRANCH=YES     unconditional request\n*                                  will abend this task if not rc=0\n         LR    R13,R10             restore so we can chain saves\n         ST    R1,8(R13)           chain\n         ST    R13,4(R1)           save\n         LR    R13,R1              areas\n         USING WORK,R13            base\n         MVC   WTOMSG(WTOLEN),WTO  move message to gotten\n*\n         L     R2,0(R11)           get smf record address\n         USING SMFRCD22,R2         map symbolic names to type 22 rec\n*\n         CLC   SMF22SCS,SMF22PCS   compare current to previous\n         BE    CHKNVS              no change.  go check for nvs change\n         MVC   RESULTXC,SMF22SCS   prepare for XC\n         XC    RESULTXC,SMF22PCS   resultxc tells which flds chgd\n         SR    R3,R3\n         IC    R3,SMF22SCS         move one byte to register\n         EJECT\n         TM    RESULTXC,CACHSTAT   test for changes with prev field\n         BZ    CHKDISAB\n         LA    R6,MSGTAB           point to first entry in table\n         LA    R7,NMSGS            r7 = number of entries in table\n         LR    R1,R3\n         SRL   R1,5                shift off bits 3-7\nCHECKMSG EQU   *\n         CLM   R1,1,0(R6)          do the bit patterns match?\n         BE    MSGFND              yes   go build wto message\n         LA    R6,LENMSG(R6)       no    point to next entry in table\n         BCT   R7,CHECKMSG         try until match or end of table\n         LA    R6,NOMSG            debug message\n         BAL   R10,WTORTN          go issue WTO\n         B     ENDCHK              not good. this should not happen.\nMSGFND   EQU   *\n         BAL   R10,WTORTN          go issue WTO\nCHKDISAB EQU   *\n         TM    RESULTXC,SSDISABL   did subsys storage dis maint chg?\n         BNO   CHKIML              not on.   go chk next flag bit\n         TM    SMF22SCS,SSDISABL   is subsys storage dis maint new?\n         BNO   LSTGENA             not on.   go chk next flag bit\n         LA    R6,STGDIS           r6 = address of message to issue\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKIML\nLSTGENA  EQU   *                   now on.   go chk next flag bit\n         LA    R6,STGENA           r6 = address of message to issue\n         BAL   R10,WTORTN          go issue WTO\nCHKIML   EQU   *\n         TM    RESULTXC,IMLDEV     is IML device unavailable new?\n         BNO   CHKCFW              not on.   go chk next flag bit\n         TM    SMF22SCS,IMLDEV     is IML device unavailable new?\n         BNO   LIMLENA             now on.   go chk next flag bit\n         LA    R6,IMLDIS           r6 = address of message to issue\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKCFW\nLIMLENA  EQU   *                   now on.   go chk next flag bit\n         LA    R6,IMLENA           r6 = address of message to issue\n         BAL   R10,WTORTN          go issue WTO\nCHKCFW   EQU   *\n         TM    RESULTXC,CFWDISAB   is cache fast write disabled new?\n         BNO   ENDCHK              not on.  all flags have been tested\n         TM    SMF22SCS,CFWDISAB   is cache fast write disabled new?\n         BNO   LCFWENA             not on.  all flags have been tested\n         LA    R6,CFWDIS           r6 = address of message to issue\n         BAL   R10,WTORTN          go issue WTO\n         B     ENDCHK\nLCFWENA  EQU   *                   now on.  all flags have been tested\n         LA    R6,CFWENA           r6 = address of message to issue\n         BAL   R10,WTORTN          go issue WTO\n         B     ENDCHK\n*\n         EJECT\nCHKNVS   EQU   *                   SMF22SNV compared to SMF22PNV\n         CLC   SMF22SNV,SMF22PNV   compare current to previous\n         BE    CHKDEV              no change.  go check for device chg\n         MVC   RESULTXC,SMF22SNV   prepare for exclusive or character\n         XC    RESULTXC,SMF22PNV   resultxc indicates which flds chgd\n         TM    RESULTXC,NVSSTAT    test for changes with prev field\n         BZ    CHKNVSDM            no  NVS status bits did not change\nCHKNC0   TM    SMF22SNV,NVSC0      was NVS changed to active or pendin?\n         BZ    LNVSACT             both bits are off so NVS is active\n         BNO   CHKN10              both bits are not on. check next ptn\n         LA    R6,NVSPND           both bits are on.  NVS is pending\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKNVSDM            go check next flag.\nLNVSACT  LA    R6,NVSACT           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKNVSDM            go check next flag.\nCHKN10   EQU   *\n         TM    SMF22SNV,NVS80      was NVS changed deactivated host?\n         BNO   CHKN01              no change.  go check next pattern\n         LA    R6,NVSDHS           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKNVSDM            go check next flag.\nCHKN01   EQU   *\n         TM    SMF22SNV,NVS40      was NVS changed deactivated subsys?\n         BNO   CHKNVSDM            no change.  go check next pattern\n         LA    R6,NVSDSS           get address of message\n         BAL   R10,WTORTN          go issue WTO\nCHKNVSDM EQU   *\n         TM    RESULTXC,NVSDISMT   test for changes with prev field\n         BZ    CHKNPND             no  NVS status bits did not change\n         TM    SMF22SNV,NVSDISMT   did NVS disabled maint status chg?\n         BNO   LNVSENA             not on.   go chk next flag bit\n         LA    R6,NVSDIM           r6 = address of message to issue\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKNPND\nLNVSENA  EQU   *                   now on.   go chk next flag bit\n         LA    R6,NVSENA           r6 = address of message to issue\n         BAL   R10,WTORTN          go issue WTO\nCHKNPND  EQU   *\n         TM    SMF22SNV,NVSPEND    did NVS pending due err stat  chg?\n         BNO   ENDCHK              not on.   all checks are complete\n         LA    R6,NVSPER           r6 = address of message to issue\n         BAL   R10,WTORTN          go issue WTO\n         B     ENDCHK\n         EJECT\nCHKDEV   EQU   *\n         CLC   SMF22SDS,SMF22PDS   compare current to previous\n         BE    ENDCHK              no changes.\n         MVC   RESULTXC,SMF22SDS   prepare for XC\n         XC    RESULTXC,SMF22PDS   resultxc says which flds chgd\n         TM    RESULTXC,DEVSTAT    test for changes with prev field\n         BZ    CHKDFWST            no  device cache status didnt change\nCHKDEVC0 EQU   *\n         TM    SMF22SDS,DEVC0      was device cache chgd to deactivate?\n         BZ    LDEVACT             both bits are off so dev cache act\n         BNO   CHKDEV80            both bits are not on.\n         LA    R6,DEVDEA           both bits are on.  dev cache deact\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDFWST            go check next flag.\nLDEVACT  EQU   *\n         LA    R6,DEVACT           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDFWST            go check next flag.\nCHKDEV80 EQU   *\n         TM    SMF22SDS,DEV80      was device cache chgd to deact pend?\n         BNO   CHKDEV40            no change.  go check next pattern\n         LA    R6,DEVDPN           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDFWST            go check next flag.\nCHKDEV40 EQU   *\n         TM    SMF22SDS,DEV40      was device cache chgd to deact pend?\n         BNO   CHKDFWST            no change.  go check next pattern\n         LA    R6,BADDEV           get address of message\n         BAL   R10,WTORTN          go issue WTO\nCHKDFWST EQU   *\n         TM    RESULTXC,DFWSTAT    test for changes with prev field\n         BZ    CHKDUPST            no  DFW status bits did not change\nCHKDFW30 EQU   *\n         TM    SMF22SDS,DFW30      was device cache chgd to deact pend?\n         BZ    LDFWACT             both bits are off. dfw status active\n         BNO   CHKDFW20            both bits are not on.\n         LA    R6,DFWDEA           both bits are on.  dfw is deactivatd\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDUPST            go check next flag.\nLDFWACT  EQU   *\n         LA    R6,DFWACT           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDUPST            go check next flag.\nCHKDFW20 EQU   *\n         TM    SMF22SDS,DFW20      was device cache chgd to deact pend?\n         BNO   CHKDFW10            no change.  go check next pattern\n         LA    R6,DFWDPN           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDUPST            go check next flag.\nCHKDFW10 EQU   *\n         TM    SMF22SDS,DFW10      was device cache chgd to deact pend?\n         BNO   CHKDUPST            no change.  go check next pattern\n         LA    R6,BADDFW           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         EJECT\nCHKDUPST EQU   *\n         TM    RESULTXC,DUPSTAT    test for changes with prev field\n         BZ    CHKDUPPR            no  duplex       status didnt change\n         MVC   CCAORIG,SMF22CCA    get CCA of originating device\n         NI    CCAORIG,CCAMASK     save only bits 0-1\n         MVC   CCAWORK,SMF22SDS+1  get other cca in duplex\n         NI    CCAWORK,X'3F'       only low order 6 bits are used\n         OC    CCAWORK(1),CCAORIG  restore bits 0-1 to get full CCA\n         UNPK  CCA(3),CCAWORK(2)    prepare for translate instr\n         TR    CCA(2),HEXTABLE-240  translate to displayable\n         MVI   CCA+2,C' '          eliminate extra char from unpack\nCHKDUP03 EQU   *\n         TM    SMF22SDS,DUP03      was duplex changed to failed?\n         BZ    LDUPAVL             both bits are off. duplex available\n         BNO   CHKDUP02            both bits are not on.\n         LA    R6,DUPFLB           both bits are on.\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDUPPR            go check next flag.\nLDUPAVL  EQU   *\n         TM    SMF22SDS,DUP08      is the primary of duplex bit on?\n         BZ    DAVAIL              no so issue the available message\n         LA    R6,DUPEST           yes so issue the duplex est msg\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDUPPR            go check next flag.\nDAVAIL   LA    R6,DUPAVL           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDUPPR            go check next flag.\nCHKDUP02 EQU   *\n         TM    SMF22SDS,DUP02      was duplex changed to failed?\n         BNO   CHKDUP01            no change.  go check next pattern\n         LA    R6,DUPFLA           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDUPPR            go check next flag.\nCHKDUP01 EQU   *\n         TM    SMF22SDS,DUP01      was duplex changed to pending?\n         BNO   CHKDUPPR            no change.  go check next pattern\n         LA    R6,DUPPEN           get address of message\n         BAL   R10,WTORTN          go issue WTO\nCHKDUPPR EQU   *\n         TM    RESULTXC,DUP08      was primary of duplex changed?\n         BNO   CHKDUPSE            no change.  go check next pattern\n         MVC   CCAORIG,SMF22CCA    get CCA of originating device\n         NI    CCAORIG,CCAMASK     save only bits 0-1\n         MVC   CCAWORK,SMF22SDS+1  get other cca in duplex\n         NI    CCAWORK,X'3F'       only low order 6 bits are used\n         OC    CCAWORK(1),CCAORIG  restore bits 0-1 to get full CCA\n         UNPK  CCA(3),CCAWORK(2)    prepare for translate instr\n         TR    CCA(2),HEXTABLE-240  translate to displayable\n         MVI   CCA+2,C' '          eliminate extra char from unpack\n         TM    SMF22SDS,DUP08      was primary of duplex changed?\n         BNO   LDUPSIM             changed to off. back to simplex\n         LA    R6,DUPPRI           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         TM    SMF22SDS,DUP01      is duplex pending flag on? SLOPPY\n         BO    CHKDUPSE            no so skip duplex est message\n         LA    R6,DUPEST           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDUPSE\nLDUPSIM  EQU   *\n         MVC   CCA,=C'   '\n         LA    R6,DUPSIM\n         BAL   R10,WTORTN          go issue WTO\nCHKDUPSE EQU   *\n         TM    SMF22SDS,DUP04      is  secondary of duplex on?\n         BNO   CHKPINST            no change.  go check next pattern\n         MVC   CCAORIG,SMF22CCA    get CCA of originating device\n         NI    CCAORIG,CCAMASK     save only bits 0-1\n         MVC   CCAWORK,SMF22SDS+1  get other cca in duplex\n         NI    CCAWORK,X'3F'       only low order 6 bits are used\n         OC    CCAWORK(1),CCAORIG  restore bits 0-1 to get full CCA\n         UNPK  CCA(3),CCAWORK(2)    prepare for translate instr\n         TR    CCA(2),HEXTABLE-240  translate to displayable\n         MVI   CCA+2,C' '          eliminate extra char from unpack\n         LA    R6,DUPSEC           get address of message\n         BAL   R10,WTORTN          go issue WTO\nCHKPINST EQU   *\n         MVC   RESULTXC,SMF22SDS+1 prepare for XC\n         XC    RESULTXC,SMF22PDS+1 resultxc says which flds chgd\n         TM    RESULTXC,PINSTAT    test for changes with prev field\n         BZ    ENDCHK              no changes so its miller time.\nCHKPINC0 TM    SMF22SDS+1,PINC0    no pinned exists?\n         BZ    LPINNOX             both bits are off. pinned no exist\n         BNO   CHKPIN80            both bits are not on.\n         LA    R6,PINEXS           both bits are on. pinned exists\n         BAL   R10,WTORTN          go issue WTO\n         B     ENDCHK\nLPINNOX  LA    R6,PINNOX           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     ENDCHK\nCHKPIN80 TM    SMF22SDS+1,PIN80    unused bit. if on issue bad msg\n         BNO   CHKPIN40            no change.  go check next pattern\n         LA    R6,BADPIN           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     ENDCHK\nCHKPIN40 TM    SMF22SDS+1,PIN40    no pinned exists?\n         BNO   ENDCHK              no change.  go check next pattern\n         LA    R6,PINEXI           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     ENDCHK\n         EJECT\n*--------------------------------------------------------------------*\n*   Construct the message to be issued. Move message text, descriptor*\n*   code and the volser of device in SMF22VOL.  Exec the WTO & return*\n*--------------------------------------------------------------------*\nWTORTN   EQU   *\n         SR    R0,R0               clear reg 0\n         LA    R4,WTOMSG           point to beginning of parm list\n         AH    R4,0(R4)            add length of text\n         MVC   0(2,R4),1(R6)       move descriptor code to parm list\n         MVC   SSSTAT,3(R6)        move message text to parm list\n         UNPK  DEVID(5),SMF22CUA(3)   prepare for translate instr\n         TR    DEVID(4),HEXTABLE-240  translate to displayable\n         MVI   DEVID+4,C','        eliminate extra char from unpack\n         WTO   MF=(E,WTOMSG),LINKAGE=BRANCH\n         BR    R10                 go back to work\n*\nENDCHK   EQU   *\n         SR    R0,R0               clear reg 0\n         LA    R0,WORKLEN          free gotten area\n         L     R5,CVTPTR           R5 = addr of cvt\n         USING CVT,R5\n         L     R6,CVTTCBP          R6 = ptr to addr of cur tcb\n         DROP  R5\n         L     R7,12(R6)           R7 = addr of current ascb\n         SR    R4,R4               indicate current TCB\n         LR    R1,R13              address of getmained area\n         L     R13,4(R13)          get to callers save area\n         FREEMAIN R,LV=(R0),A=(R1),BRANCH=YES\n         LTR   R9,R9               test return code from Setlock OBTAIN\n         BNZ   HADLOCK             rc for obtain = 4 (caller had lock)\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=USE\nHADLOCK  EQU   *\nQUIKEXIT LM    R14,R12,12(R13)     restore regs\n         SR    R15,R15             set rc = 0\n*        BSM   0,14                return\n         BR    R14                 return\nWTO  WTO 'PCC10I XXXX,MESSAGE TEXT OF CONDITION************   ',       X\n               ROUTCDE=(1),DESC=(2),MCSFLAG=(BRDCST),LINKAGE=,MF=L\nWTOLEN   EQU   *-WTO\n         EJECT\n*   Descriptor Code\n*    1   System Failure\n*    2   Immediate Action required\n*    3   Eventual Action required\n*    4   System Status\n*    5   Immediate Command response\n*    6   Job status\n*    7   Retain action message for life of task\n*    8   Out-of-line message\n*    9   Operator request\n*   10   Dynamic status displays\n*   11   Critical eventual action requested\n*   12   Important information messages\n*   13   Message previously automated\n*\nMSGTAB   DS    0H\n*               SMF    descriptor flags\n*              flag    1234567890123456       message text\n         DC    X'00',B'0010000000000000'\n         DC    CL40'SUBSYSTEM CACHE NOW ACTIVE'\nLENMSG   EQU   *-MSGTAB\n         DC    X'01',B'0010000000000000'\n         DC    CL40'SUBSYSTEM CACHE IS PENDING ACTIVE'\n         DC    X'02',B'0010000000000000'\n         DC    CL40'SUBSYSTEM CACHE DEACTIVATED'\n         DC    X'04',B'0010000000000000'\n         DC    CL40'SUBSYSTEM CACHE DEACTIVATED BY HOST'\n         DC    X'06',B'0010000000000000'\n         DC    CL40'SUBSYSTEM CACHE PENDING OFF'\n         DC    X'07',B'0100000000000000'\n         DC    CL40'SUBSYSTEM CACHE PENDING OFF FAILED'\nNMSGS    EQU   (*-MSGTAB)/LENMSG\n*                 descriptor flags\n*                 1234567890123456       message text\nDEVACT   DC    X'00',B'0010000000000000'\n         DC    CL40'DEVICE CACHE IS ACTIVE'\nBADDEV   DC    X'00',B'0100000000000000'\n         DC    CL40'INVALID DEVICE CACHE STATUS'\nDEVDPN   DC    X'00',B'0010000000000000'\n         DC    CL40'DEVICE CACHE DEACTIVATE PENDING'\nDEVDEA   DC    X'00',B'0010000000000000'\n         DC    CL40'DEVICE CACHE HAS BEEN DEACTIVATED'\n*\nDFWACT   DC    X'00',B'0010000000000000'\n         DC    CL40'DEVICE DFW IS ACTIVE'\nBADDFW   DC    X'00',B'0100000000000000'\n         DC    CL40'INVALID DEVICE DFW STATUS'\nDFWDPN   DC    X'00',B'0010000000000000'\n         DC    CL40'DEVICE DFW DEACTIVATION PENDING'\nDFWDEA   DC    X'00',B'0010000000000000'\n         DC    CL40'DEVICE DFW HAS BEEN DEACTIVATED'\n*\nDUPEST   DC    X'00',B'0010000000000000'\n         DC    CL40'DUPLEX IS ESTABLISHED      OTHER CCA='\nDUPAVL   DC    X'00',B'0010000000000000'\n         DC    CL40'DUPLEX IS AVAILABLE        OTHER CCA='\nDUPSIM   DC    X'00',B'0010000000000000'\n         DC    CL40'DUPLEX PAIR RESET TO SIMPLEX         '\nDUPPEN   DC    X'00',B'0010000000000000'\n         DC    CL40'PENDING DUPLEX             OTHER CCA='\nDUPFLA   DC    X'00',B'0010000000000000'\n         DC    CL40'SECONDARY DEV SUSPENDED    OTHER CCA='\nDUPFLB   DC    X'00',B'0010000000000000'\n         DC    CL40'PRIMARY DEVICE SUSPENDED   OTHER CCA='\nDUPPRI   DC    X'00',B'0010000000000000'\n         DC    CL40'PRIMARY OF DUPLEX PAIR     OTHER CCA='\nDUPSEC   DC    X'00',B'0010000000000000'\n         DC    CL40'SECONDRY OF DUPLEX PAIR    OTHER CCA='\n*\nNVSACT   DC    X'00',B'0010000000000000'\n         DC    CL40'SUBSYSTEM NVS IS ACTIVE'                (X'00')\nNVSDSS   DC    X'00',B'0100000000000000'\n         DC    CL40'SUBSYSTEM NVS FAILED'                   (X'01')\nNVSDHS   DC    X'00',B'0010000000000000'\n         DC    CL40'SUBSYSTEM NVS HAS BEEN DEACTIVATED'     (X'02')\nNVSPND   DC    X'00',B'0010000000000000'\n         DC    CL40'SUBSYSTEM NVS IS PENDING OFF'           (X'04')\n*\nNVSDIM   DC    X'00',B'0010000000000000'\n         DC    CL40'SUBSYSTEM NVS DISABLED FOR MAINTENANCE'\nNVSENA   DC    X'00',B'0010000000000000'\n         DC    CL40'SUBSYSTEM NVS ENABLED FROM MAINTENANCE'\nNVSPER   DC    X'00',B'0100000000000000'\n         DC    CL40'SUBSYSTEM NVS PENDING OFF DUE TO ERROR'\n*\nPINNOX   DC    X'00',B'0010000000000000'\n         DC    CL40'NO PINNED DATA EXISTS FOR DEVICE'           (X'00')\nPINEXI   DC    X'00',B'0100000000000000'\n         DC    CL40'DEVICE HAS PINNED DATA, DFW ACTIVE'         (X'01')\nPINEXS   DC    X'00',B'0100000000000000'\n         DC    CL40'DEVICE HAS PINNED DATA, DFW SUSPENDED'      (X'03')\nBADPIN   DC    X'00',B'0100000000000000'\n         DC    CL40'INVALID PINNED DATA STATUS'                 (X'04')\n*\nSTGDIS   DC    X'00',B'0100000000000000'\n         DC    CL40'SUBSYSTEM STORAGE DISABLED MAINT'\nSTGENA   DC    X'00',B'0010000000000000'\n         DC    CL40'SUBSYSTEM STORAGE NOW ENABLED'\nIMLDIS   DC    X'00',B'0100000000000000'\n         DC    CL40'IML DEVICE UNAVAILABLE'\nCFWDIS   DC    X'00',B'0010000000000000'\n         DC    CL40'CACHE FASTWRITE IS DISABLED'\nIMLENA   DC    X'00',B'0100000000000000'\n         DC    CL40'IML DEVICE IS NOW AVAILABLE'\nCFWENA   DC    X'00',B'0010000000000000'\n         DC    CL40'CACHE FASTWRITE IS ACTIVE'\nNOMSG    DC    X'00',B'0100000000000000'\n         DC    CL40'INVALID SUBSYSTEM CACHING STATUS'\n*\nHEXTABLE DC    C'0123456789ABCDEF' used by translate instruction\n         LTORG\nWORK     DSECT\nSAVEAREA DS    18F\nRESULTXC DS    CL1\nCCAORIG  DS    CL1                 CCA of originating device\nCCAWORK  DS    CL2                 CCA of other device in pair (2-7)\n         DS    0F\nWTOMSG   DS    256X                work\n         ORG   WTOMSG+4\n         DS    CL7    'PCC10I '\nDEVID    DS    CL4    'XXXX'\n         DS    CL1    ','\nSSSTAT   DS    CL38   'MESSAGE TEXT'\nCCA      DS    CL3\n         ORG\nWORKLEN  EQU   *-WORK\n         EJECT\n         IFASMFR 22                mapping macro for type 22 record\n         IHAPSA\n         CVT   DSECT=YES\n         END\n//L.SYSLMOD DD DSN=SYS1.LPALIB,DISP=SHR,\n//      UNIT=SYSDA,VOL=SER=SM51D0\n//SYSIN  DD *\n ENTRY IEFU84\n NAME IEFU84(R)\n/*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT484/CBT.V500.FILE484.PDS/EXEC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT484/CBT.V500.FILE484.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}