{"INMR01": {"INMLRECL": 80, "INMFNODE": "CCCMVS2", "INMFUID": "CEB40", "INMTNODE": "COMPLEX2", "INMTUID": "CEB40", "INMFTIME": "20001019221411000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 6160, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CEB40.V24.ACU.ASM", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CEB40.V24.ACU.ASM": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 6160, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3339, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 0, "DS1REFD": "000000", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x00\\x00\\x00\\x00'", "DS1LSTAR": "b'\\x00\\x00\\x00'", "DS1TRBAL": "b''"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xfd\\xa8\\x08\\xa8\\x8f\\xec\\x04,\\x04\\xa5\\xc2\\x18'", "extents": ["b'\\x01\\x00\\x00\\x00\\xfd\\xa8\\x08\\xa8\\x8f\\xec\\x04,\\x04\\xa5\\xc2\\x18'", "b'X\\xf1\\xe6\\x90\\x00\\x00\\x00\\x1c\\x00\\x04\\x00\\x1c\\x00\\x06\\x00\\x03'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$INDEX": {"ttr": 267, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x00\\x95$\\x0f\\x00\\x95$\\x0f\\x15 \\x00\\n\\x00\\n\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-08-28T00:00:00", "modifydate": "1995-08-28T15:20:03", "lines": 10, "newlines": 10, "modlines": 0, "user": "CEB40"}, "text": "ASMCASH          JCL TO ASSEMBLE CASHMAN SOURCE\nASMDEV           JCL TO ASSEMBLE DEVTYPE SOURCE\nASMSLEEP         JCL TO ASSEMBLE SLEEP   SOURCE\nASMSTAT          JCL TO ASSEMBLE CACHSTAT SOURCE\nCACHSTAT         SOURCE TO SCAN UCBS AND CREATE TABLE OF STATUS BY DEV\nCASHMAN          SOURCE TO SCAN UCBS FOR SELECTION OF SPECIFIED CTRLRS\nDEVTYPE          SOURCE TO SCAN UCBS TO DETERMINE DEVICE TYPE\nDEVTYPEO         EXTRA CODE FOR SYSTEMS THAT DON'T SUPPORT UCBSCAN MACR\nIEFU84           SOURCE FOR SMF EXIT IEFU84 (3990 STATE CHANGE WTO'S)\nSLEEP            SOURCE TO ROUTINE FOR STIMER WAIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMCASH": {"ttr": 12, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00Y\\x00\\x94\\x00O\\x00\\x95\\x18o\\x132\\x00\\t\\x00\\n\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1994-01-04T00:00:00", "modifydate": "1995-07-05T13:32:59", "lines": 9, "newlines": 10, "modlines": 0, "user": "CEB40"}, "text": "//CEB40DS JOB (*),'*',TIME=(0,10),MSGCLASS=Y,\n//        NOTIFY=$\n//ASM   EXEC ASMHCL, ARM.C='OBJECT,NODECK',\n//            PARM.LKED='LIST,MAP,LET'\n//ASM.SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR\n//          DD DSN=SYS1.MODGEN,DISP=SHR\n//          DD DSN=CEB40.NEW.MACLIB,DISP=SHR\n//ASM.SYSIN DD DSN=CEB40.V24.ACU.ASM(CASHMAN),DISP=SHR\n//LKED.SYSLMOD DD DSN=CEB40.V24.ACU.ISPLLIB(CASHMAN),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMDEV": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x08\\x00\\x95\\x17\\x8f\\x01\\x00)?\\x14Q\\x00\\x08\\x00\\x08\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1995-06-27T00:00:00", "modifydate": "2000-10-19T14:51:08", "lines": 8, "newlines": 8, "modlines": 0, "user": "CEB40"}, "text": "//CEB40DS JOB (*),'*',TIME=(0,10),MSGCLASS=Y,\n//        NOTIFY=$\n//ASM   EXEC ASMHCL, ARM.ASM='OBJECT,NODECK',\n//            PARM.LKED='LIST,MAP,LET'\n//ASM.SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//             DD DSN=SYS1.MODGEN,DISP=SHR\n//ASM.SYSIN    DD DSN=CEB40.V24.ACU.ASM(DEVTYPE),DISP=SHR\n//LKED.SYSLMOD DD DSN=CEB40.V24.ACU.ISPLLIB(DEVTYPE),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMSLEEP": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x003\\x00\\x94)O\\x01\\x00)?\\x14Q\\x00\\x08\\x00\\x08\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-10-21T00:00:00", "modifydate": "2000-10-19T14:51:33", "lines": 8, "newlines": 8, "modlines": 0, "user": "CEB40"}, "text": "//CEB40DS JOB (*),'*',TIME=(0,10),MSGCLASS=Y,\n//        NOTIFY=$\n//ASM   EXEC ASMHCL, ARM.ASM='OBJECT,NODECK',\n//            PARM.LKED='LIST,MAP,LET'\n//ASM.SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//             DD DSN=SYS1.MODGEN,DISP=SHR\n//ASM.SYSIN    DD DSN=CEB40.V22.ACU.ASM(SLEEP),DISP=SHR\n//LKED.SYSLMOD DD DSN=CEB40.V22.ACU.ISPLLIB(SLEEP),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMSTAT": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00E\\x00\\x95\\x02\\x1f\\x01\\x00)?\\x14Q\\x00\\t\\x00\\t\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1995-01-21T00:00:00", "modifydate": "2000-10-19T14:51:45", "lines": 9, "newlines": 9, "modlines": 0, "user": "CEB40"}, "text": "//CEB40DS JOB (*),'*',TIME=(0,10),MSGCLASS=Y,\n//        NOTIFY=$\n//ASM   EXEC ASMHCL, ARM.C='OBJECT,NODECK',\n//            PARM.LKED='LIST,MAP,LET'\n//ASM.SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=SYS1.MODGEN,DISP=SHR\n//           DD DSN=CEB40.NEW.MACLIB,DISP=SHR\n//ASM.SYSIN  DD DSN=CEB40.V24.ACU.ASM(CACHSTAT),DISP=SHR\n//LKED.SYSLMOD DD DSN=CEB40.V24.ACU.ISPLLIB(CACHSTAT),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CACHSTAT": {"ttr": 16, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x07\\x00\\x95\\x02\\x1f\\x00\\x95 _\\x102\\x00\\xaa\\x00\\xd5\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1995-01-21T00:00:00", "modifydate": "1995-07-24T10:32:07", "lines": 170, "newlines": 213, "modlines": 0, "user": "CEB40"}, "text": "           TITLE 'CACHEMAN DASD SCAN MODULE'\nCACHSTAT CSECT *\n*---------------------------------------------------------------------\n* This program will scan online ucbs to construct a table that is\n* used in the CACHEMN1 exec.\n* REQUIREMENTS:\n*   Macros -  all dialog services macros from my macro library\n* (C) COPYRIGHT AMDAHL CORPORATION  1995. All Rights Reserved\n*---------------------------------------------------------------------\n         YREGS\n         SAVE  (14,12)                 STANDARD LINKAGE\n         LR    R11,R15\n         LA    R12,4095(R11)\n         LA    R12,1(R12)\n         USING CACHSTAT,R11,R12\n         ST    R13,SAVE+4\n         LA    R14,SAVE\n         ST    R14,8(R13)\n         LR    R13,R14\n*---------------------------------------------------------------------\n* Load a copy of ISPLINK for use by the Dialog Manager macros\n*---------------------------------------------------------------------\n         LOAD    EP=ISPLINK\n         ST      R0,SAVEISP\n*\n*-- Test which version of MVS is running. If prior to MVS 4 then\n*-- use the older techniqe to access UCB scan services\n*\n         L     R2,CVTPTR               address of CVT\n         USING CVTMAP,R2\n         LR    R3,R2\n         LA    R4,CVTMAP-CVTFIX        address of CVT prefix area\n         SR    R3,R4\n         USING CVTFIX,R3               addressability for prefix area\nPRODN    MVC   MVSVERS(1),CVTPRODN+2   save version of prod number\n         DROP  R3\n*---------------------------------------------------------------------\n* VDEFINE the storage areas so ISPF can associate variables with them\n* all areas with same size and type can be done with one vdefine\n*---------------------------------------------------------------------\n         VDEFINE (TCHAN),HEX,2\n         VDEFINE (TVOL),CHAR,6\n         VDEFINE (TDEVICE),CHAR,4\n*\n* Create the table to hold the CACHSTAT entries\n*\nCRTTAB   TBCREATE CSTTABLE,,(TCHAN,TVOL,TDEVICE),WR,REPLACE\nUCBCNT   SR    R9,R9                   CLEAR R9 FOR UCB COUNTER\n         MVI   DEV,X'20'               set device class to DASD\n         LA    R1,WORKX                work area for old format scan\n         ST    R1,P1                   save address of work area\n         LA    R1,DEV\n         ST    R1,P2                   save address of device class\n         LA    R1,UCBA\n         ST    R1,P3                   save address of ucb area\n         XC    UCB48,UCB48\n         XC    WORKX,WORKX\n*\nUCBSCAN  EQU   *\n         CLI   MVSVERS,C'4'            is product MVS SP4 ESA 4 or >\n         BL    PRESP4                  no;  go to pre-SP4 logic\n*\n* -- This section of code invokes the extended UCB scan services via\n* -- the UCBSCAN macro.  This handles dynamic UCBs and 4 digit addr.\n* -- This macro was new with MVS 4.1? (really a DFP version macro)\n*\n         UCBSCAN COPY,WORKAREA=WORKX,UCBAREA=UCB48,                    X\n               DEVCLASS=DASD,DYNAMIC=YES,RANGE=ALL\n         LTR   R15,R15                 WAS A DASD UCB FOUND\n         BNZ   EXIT                    NO DASD UCB FOUND FOR VOL\n         LA    R8,UCB48                ELSE GET ADDRESS PASSED BACK\n         B     UCBRETND                branch around code for old svcs\n*\n* -- This section of code is to invoke the UCB scan services for\n* -- MVS systems prior to Version 4.  The UCBSCAN macro was new with\n* -- DFP 3.?  and will abend with a 0D6 abend if executed on pre 3.2?\n*\nPRESP4   L     R14,CVTPTR              ADDR OF CVT\n         L     R15,CVTUCBSC-CVTMAP(,R14) address of ucb scan services\n         LA    R1,P1                   LOAD ADDRESS OF PARMLIST\n         OI    P3,X'80'                SET END OF PARMLIST\n         BALR  R14,R15                 CALL UCB LOOKUP ROUTINE\n         LTR   R15,R15                 WAS A DASD UCB FOUND\n         BNZ   EXIT                    NO DASD UCB FOUND FOR VOL\n         L     R8,UCBA                 ELSE GET ADDRESS PASSED BACK\nUCBRETND EQU   *\n         USING UCBOB,R8                DSECT\n         TM    UCBSTAT,UCBONLI         DEVICE ONLINE???\n         BNO   UCBSCAN                 TRY AGAIN\n         TM    UCBSTAT,UCBCHGS         DEVICE GOING OFFLINE???\n         BO    UCBSCAN                 TRY TRY AGAIN\nGOTONE   EQU   *\n         SR    R2,R2\n         LH    R2,UCBCHAN\n         SRL   R2,4                    shift off last nibble\n         SR    R3,R3\n         LH    R3,TCHAN\n         SRL   R3,4                    shift off last nibble\n         CR    R2,R3                   is address from same range?\n         BE    UCBSCAN                 yes - don't add it to the table\n         MVC   TCHAN,UCBCHAN           move to table variable\n         MVC   TVOL,UCBVOLI            volser in ucb\n         SR    R1,R1\n         IC    R1,UCBUNTYP         LOAD UNIT TYPE DEVICE CODE FIELD\n         SLL   R1,2                MULTIPLY BY 4 FOR TABLE ENTRIES\n         LA    R3,DEVNM            GET START OF DEVICE NAME TABLE\n         AR    R1,R3               AND ADD TO CORRECT OFFSET\n         MVC   TDEVICE(4),0(R1)    LOAD DEVICE TYPE FROM TABLE\n         TBADD CSTTABLE                ADD A ROW TO SPACE TABLE\n         B     UCBSCAN                 LOOP UNTIL ALL UCB'S FOUND\n         CNOP  0,4\nTBCLPRM  DC    A(TBCLOSE)\n         DC    A(CSTTABLE+X'80000000')\nEXIT     EQU   *\n         LA    R1,TBCLPRM\n         L     R15,SAVEISP\n         BALR  R14,R15\nQWIKEXIT EQU   *\n         L     R13,SAVE+4\n         RETURN (14,12),RC=(15)\n         EJECT\n         COPY  DMFUNCT\nWORKADR  DC    PL3'0'\nFROMX    DS    XL2\nTOX      DS    XL2\n*\nDEVNM    DC    CL4'....'               00 (00) - UNASSIGNED\n         DC    CL4'2311'               01 (01) - 2311 DISK\n         DC    CL4'2301'               02 (02) - 2301 DRUM\n         DC    CL4'2303'               03 (03) - 2303 DRUM\n         DC    CL4'2302'               04 (04) - 2302 DISK FILE\n         DC    CL4'2321'               05 (05) - 2321 DATA CELL\n         DC    CL4'2305'               06 (06) - 2305-1\n         DC    CL4'2305'               07 (07) - 2305-2\n         DC    CL4'2314'               08 (08) - 2314 DISK\n         DC    CL4'3330'               09 (09) - 3330 DISK\n         DC    CL4'3340'               10 (0A) - 3340\n         DC    CL4'3350'               11 (0B) - 3350 DISK\n         DC    CL4'3375'               12 (0C) - 3375\n         DC    CL4'3330'               13 (0D) - 3330-11 DISK\n         DC    CL4'3380'               14 (0E) - 3380\n         DC    CL4'3390'               15 (0F) - 3390\n         SPACE 2\n*------------------------------------------------------------------\n*-- The following work areas are used by the UCBSCAN macro.\n*\n         DS    0F\nWORKX    DC    100X'00'\nUCB48    DS    CL48\n*------------------------------------------------------------------\n*-- The following work areas are used by the 'old' style invocation\n*-- of the UCB scan service routines.\n*\n         DS    0F\nUCBA     DS    A\nDEV      DS    XL1\n         DS    0F\nP1       DS    A\nP2       DS    A\nP3       DS    A\n*------------------------------------------------------------------\nMVSVERS  DC    C'0'\n*\nSAVE     DC    18F'0'\nZERO     DC    H'0'\n         LTORG\n         DSECT\n         IEFUCBOB DEVCLAS=DA\n         CVT   DSECT=YES,PREFIX=YES\n         END   CACHSTAT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CASHMAN": {"ttr": 20, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00@\\x00\\x95\\x18o\\x00\\x95 _\\x102\\x01\\x03\\x00\\xe4\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1995-07-05T00:00:00", "modifydate": "1995-07-24T10:32:40", "lines": 259, "newlines": 228, "modlines": 0, "user": "CEB40"}, "text": "           TITLE 'CACHEMAN DASD SCAN MODULE'\nCASHMAN CSECT *\n*---------------------------------------------------------------------\n* (C) COPYRIGHT AMDAHL CORPORATION  1995. All Rights Reserved\n* THIS PROGRAM WILL SCAN ONLINE UCBS TO CONSTRUCT A TABLE THAT IS\n* USED IN THE CACHEMN1 EXEC.\n* REQUIREMENTS:\n*   PANEL  -  CSHMAN1\n*   MACROS -  ALL DIALOG SERVICES MACROS FROM MY MACRO LIBRARY\n*   MACROS -  ISPLINK will be called dynamically\n*   FUTURE MODS:\n*   Tables -  VOLTABLE\n*    fields      TBVOL    = Volser of DASD\n*                TBDEVT   = Device type of DASD (3380 or 3390)\n*                TBCHAN   = UCB channel address\n*---------------------------------------------------------------------\n         YREGS\n         SAVE  (14,12)                 STANDARD LINKAGE\n         LR    R11,R15\n         LA    R12,4095(R11)\n         LA    R12,1(R12)\n         USING CASHMAN,R11,R12\n         ST    R13,SAVE+4\n         LA    R14,SAVE\n         ST    R14,8(R13)\n         LR    R13,R14\n*---------------------------------------------------------------------\n* Load a copy of ISPLINK for use by the Dialog Manager macros\n*---------------------------------------------------------------------\n         LOAD    EP=ISPLINK\n         ST      R0,SAVEISP\n*\n*-- Test which version of MVS is running. If prior to MVS 4 then\n*-- use the older techniqe to access UCB scan services\n*\n         L     R2,CVTPTR               address of CVT\n         USING CVTMAP,R2\n         LR    R3,R2\n         LA    R4,CVTMAP-CVTFIX        address of CVT prefix area\n         SR    R3,R4\n         USING CVTFIX,R3               addressability for prefix area\nPRODN    MVC   MVSVERS(1),CVTPRODN+2   save version of prod number\n         DROP  R3\n*---------------------------------------------------------------------\n* VDEFINE THE STORAGE AREAS SO ISPF CAN ASSOCIATE VARIABLES WITH THEM\n* ALL AREAS WITH SAME SIZE AND TYPE CAN BE DONE WITH ONE VDEFINE\n*---------------------------------------------------------------------\n         VDEFINE (PANEL),CHAR,8\n         VDEFINE (TBVOL,VOLUME),CHAR,6\n         VDEFINE (GRPNAME),CHAR,7\n         VDEFINE (TBDEVT,FUA,TUA),CHAR,4\n         VDEFINE (TBCHAN),HEX,2\n         VDEFINE (ACT),CHAR,1\n         B     DISPPAN\nDISPPRM  DC    A(DISPLAY)\n         DC    A(CSHPANL+X'80000000')\nDISPPAN  LA    R1,DISPPRM\n         L     R15,SAVEISP\n         BALR  R14,R15\n         CH    R15,=H'8'               PF3 KEY HIT SO EXIT\n         BE    QWIKEXIT\n         B     CRTTAB\nCSHPANL  DC    C'CSHMAN2 '\n*\n* Create the table to hold the CASHMAN entries\n*\nCRTTAB   TBCREATE VOLTABLE,,(TBVOL,TBDEVT,TBCHAN),WR,REPLACE\nUCBCNT   SR    R9,R9                   CLEAR R9 FOR UCB COUNTER\n         MVI   DEV,X'20'               set device class to DASD\n         LA    R1,WORKX                work area for old format scan\n         ST    R1,P1                   save address of work area\n         LA    R1,DEV\n         ST    R1,P2                   save address of device class\n         LA    R1,UCBA\n         ST    R1,P3                   save address of ucb area\n         XC    UCB48,UCB48\n         XC    WORKX,WORKX\n         MVC   FROMX,=X'0000'          DEFAULT FROM ADDRESS\n         MVC   TOX,=X'FFFF'            DEFAULT TO   ADDRESS\n         VCOPY VOLUME,6,,MOVE,LABEL=LENVOL\n         VCOPY GRPNAME,7,,MOVE,LABEL=LENGRP\n         VPUT  GRPNAME,SHARED          stuff into shared variable pool\nVOL      L     R1,LENVOL               GET LENGTH OF ARGUMENT\n         CH    R1,ZERO                 WAS VOLUME ENTERED\n         BNE   UCBSCAN                 yes so skip other checks\nGRP      L     R1,LENGRP               GET LENGTH OF ARGUMENT\n         CH    R1,ZERO                 WAS GROUPNAME ENTERED\n         BNE   GETGRP                  YES SO SKIP UNIT ADDR RANGE\n         VCOPY FUA,4,,MOVE,LABEL=FLEN  ELSE GET FROM UNIT ADDRESS\n         VCOPY TUA,4,,MOVE,LABEL=TLEN  AND TO   UNIT ADDRESS\n         MVC   WORK,=C'0000'           init work field\n         CLC   FLEN,=F'4'              was full field entered?\n         BE    PRTUA\nFLENG3   CLC   FLEN,=F'3'              were 3 chars entered?\n         BNE   FLENG2\n         MVC   WORK+1(3),FUA           move the 3 chars\n         MVC   FUA,WORK\n         B     PRTUA\nFLENG2   CLC   FLEN,=F'2'              were 2 chars entered?\n         BNE   FLENG1\n         MVC   WORK+2(2),FUA           move the 2 chars\n         MVC   FUA,WORK\n         B     PRTUA\nFLENG1   MVC   WORK+3(1),FUA           move the 2 chars\n         MVC   FUA,WORK\nPRTUA    MVC   WORK,=C'0000'           init work field\n         CLC   TLEN,=F'4'              was full field entered?\n         BE    PREPIT\nTLENG3   CLC   TLEN,=F'3'              were 3 chars entered?\n         BNE   TLENG2\n         MVC   WORK+1(3),TUA           move the 3 chars\n         MVC   TUA,WORK\n         B     PREPIT\nTLENG2   CLC   TLEN,=F'2'              were 2 chars entered?\n         BNE   TLENG1\n         MVC   WORK+2(2),TUA           move the 2 chars\n         MVC   TUA,WORK\n         B     PREPIT\nTLENG1   MVC   WORK+3(1),TUA           move the 2 chars\n         MVC   TUA,WORK\nPREPIT   MVC   FROMX,=X'0000'          PREP for mvo\n         MVC   TOX,=X'0000'            prep for mvo\n         TR    FUA(4),TRANTBL          CONVERT SO PACK WILL WORK\n         PACK  WORKADR(3),FUA(4)       PACK AND CONVERT TO HEX\n         MVO   FROMX(2),WORKADR(2)\n         TR    TUA(4),TRANTBL          CONVERT SO PACK WILL WORK\n         PACK  WORKADR(3),TUA(4)       PACK AND CONVERT TO HEX\n         MVO   TOX(2),WORKADR(2)\n         B     UCBSCAN\nGETGRP   EQU   *\n         MVI   VOLUME,C'*'             get all controllers\n*                                      filtering is done in CACHEMN1\nUCBSCAN  EQU   *\n         CLI   MVSVERS,C'4'            is product MVS SP4 ESA 4 or >\n         BL    PRESP4                  no;  go to pre-SP4 logic\n*\n* -- This section of code invokes the extended UCB scan services via\n* -- the UCBSCAN macro.  This handles dynamic UCBs and 4 digit addr.\n* -- This macro was new with MVS 4.1.\n*\n         UCBSCAN COPY,WORKAREA=WORKX,UCBAREA=UCB48,                    X\n               DEVCLASS=DASD,DYNAMIC=YES,RANGE=ALL\n         LTR   R15,R15                 WAS A DASD UCB FOUND\n         BNZ   EXIT                    NO DASD UCB FOUND FOR VOL\n         LA    R8,UCB48                ELSE GET ADDRESS PASSED BACK\n         B     UCBRETND                branch around code for old svcs\n*\n* -- This section of code is to invoke the UCB scan services for\n* -- MVS systems prior to Version 4.  The UCBSCAN macro was new with\n* -- DFP 3.?  and will abend with a 0D6 abend if executed on pre 3.2?\n*\nPRESP4   L     R14,CVTPTR              ADDR OF CVT\n         L     R15,CVTUCBSC-CVTMAP(,R14) address of ucb scan services\n         LA    R1,P1                   LOAD ADDRESS OF PARMLIST\n         OI    P3,X'80'                SET END OF PARMLIST\n         BALR  R14,R15                 CALL UCB LOOKUP ROUTINE\n         LTR   R15,R15                 WAS A DASD UCB FOUND\n         BNZ   EXIT                    NO DASD UCB FOUND FOR VOL\n         L     R8,UCBA                 ELSE GET ADDRESS PASSED BACK\nUCBRETND EQU   *\n         USING UCBOB,R8                DSECT\n         TM    UCBSTAT,UCBONLI         DEVICE ONLINE???\n         BNO   UCBSCAN                 TRY AGAIN\n         TM    UCBSTAT,UCBCHGS         DEVICE GOING OFFLINE???\n         BO    UCBSCAN                 TRY TRY AGAIN\nGOTONE   EQU   *\n         MVC   TBCHAN,UCBCHAN          UNIT ADDRESS\n         CLC   UCBCHAN,TOX         IF UCBCHAN > TOX  IT IS OUT OF RANGE\n         BH    UCBSCAN\n         CLC   UCBCHAN,FROMX       IF UCBCHAN < FROMX    OUT OF RANGE\n         BL    UCBSCAN\nCKVOLSER EQU   *\n         L     R1,LENVOL               GET LENGTH OF ARGUMENT\n         CH    R1,ZERO                 WAS VOLUME ENTERED\n         BE    NOVOLCHK                NO   BYPASS THE VOLSER COMPARE\n         CLI   VOLUME,C'*'             INCLUDE ALL VOLUMES???\n         BE    NOVOLCHK                YES SO BYPASS COMPARISON\n         L     R1,LENVOL               GET LENGTH OF ARGUMENT\n         BCTR  R1,0                    DECREMENT LEN BY 1\n         EX    R1,CLCVOL               EXECUTE THE COMPARE OF VOLUMES\n         BNE   UCBSCAN                 IF NO MATCH TRY ANOTHER UCB\n         B     NOVOLCHK                TRY AGAIN\nCLCVOL   CLC   UCBVOLI(0),VOLUME       CHECK AGAINST PANEL VALUE\nNOVOLCHK MVC   TBVOL,UCBVOLI           VOLSER IN UCB\n         LA    R1,UCBVOLI              VOLSER IN UCB\n         SR    R1,R1\n         IC    R1,UCBUNTYP         LOAD UNIT TYPE DEVICE CODE FIELD\n         SLL   R1,2                MULTIPLY BY 4 FOR TABLE ENTRIES\n         LA    R3,DEVNM            GET START OF DEVICE NAME TABLE\n         AR    R1,R3               AND ADD TO CORRECT OFFSET\n         MVC   TBDEVT(4),0(R1)     LOAD DEVICE TYPE FROM TABLE\n         TBADD VOLTABLE                ADD A ROW TO SPACE TABLE\n         B     UCBSCAN                 LOOP UNTIL ALL UCB'S FOUND\n         CNOP  0,4\nTBCLPRM  DC    A(TBCLOSE)\n         DC    A(VOLTABLE+X'80000000')\nEXIT     EQU   *\n         LA    R1,TBCLPRM\n         L     R15,SAVEISP\n         BALR  R14,R15\nQWIKEXIT EQU   *\n         L     R13,SAVE+4\n         RETURN (14,12),RC=(15)\n         EJECT\n         COPY  DMFUNCT\nWORKADR  DC    PL3'0'\nWORK     DC    CL4'0000'\nFROMX    DS    XL2\nTOX      DS    XL2\n*------------------------------------------------------------------\n*-- The following work areas are used by the UCBSCAN macro.\n*\n         DS    0F\nWORKX    DC    100X'00'\nUCB48    DS    CL48\n*------------------------------------------------------------------\n*-- The following work areas are used by the 'old' style invocation\n*-- of the UCB scan service routines.\n*\n         DS    0F\nUCBA     DS    A\nDEV      DS    XL1\n         DS    0F\nP1       DS    A\nP2       DS    A\nP3       DS    A\n*------------------------------------------------------------------\nMVSVERS  DC    C'0'\n*\nDEVNM    DC    CL4'....'               00 (00) - UNASSIGNED\n         DC    CL4'2311'               01 (01) - 2311 DISK\n         DC    CL4'2301'               02 (02) - 2301 DRUM\n         DC    CL4'2303'               03 (03) - 2303 DRUM\n         DC    CL4'2302'               04 (04) - 2302 DISK FILE\n         DC    CL4'2321'               05 (05) - 2321 DATA CELL\n         DC    CL4'2305'               06 (06) - 2305-1\n         DC    CL4'2305'               07 (07) - 2305-2\n         DC    CL4'2314'               08 (08) - 2314 DISK\n         DC    CL4'3330'               09 (09) - 3330 DISK\n         DC    CL4'3340'               10 (0A) - 3340\n         DC    CL4'3350'               11 (0B) - 3350 DISK\n         DC    CL4'3375'               12 (0C) - 3375\n         DC    CL4'3330'               13 (0D) - 3330-11 DISK\n         DC    CL4'3380'               14 (0E) - 3380\n         DC    CL4'3390'               15 (0F) - 3390\n         SPACE 2\n         ORG   *-193\nTRANTBL  DS    CL193\n         DC    X'0A0B0C0D0E0F'\n         ORG   TRANTBL+240\n         DC    X'F0F1F2F3F4F5F6F7F8F9'\n         ORG   TRANTBL+256\nSAVE     DC    18F'0'\nZERO     DC    H'0'\n         LTORG\n         DSECT\n         IEFUCBOB DEVCLAS=DA\n         CVT   DSECT=YES,PREFIX=YES\n         END   CASHMAN\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DEVTYPE": {"ttr": 257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x95\\x17\\x8f\\x00\\x95 _\\x103\\x00\\x86\\x00\\x92\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1995-06-27T00:00:00", "modifydate": "1995-07-24T10:33:00", "lines": 134, "newlines": 146, "modlines": 0, "user": "CEB40"}, "text": "DEVTYPE CSECT                         *\nDEVTYPE AMODE 31\nDEVTYPE RMODE ANY\n*---------------------------------------------------------------------\n* (C) COPYRIGHT AMDAHL CORPORATION  1995. All Rights Reserved\n* Written by:  Chuck Baumann ------------------July 1992    ----------\n* Version:     2.2\n*\n*      An external rexx function model.  Scans ucb chain until volser\n*      matches passed argument.   Returns the device type 3380 or 3390\n*      and number of cylinders of device and an internal return code.\n*\n* Register usage: (on entry)\n*   R0     -  address of environment block\n*   R1     -  address of the external function parameter list\n*   R2-12  -  unpredictable\n*   R13    -  register save area\n*   R14    -  return address\n*   R15    -  entry point address\n* Register usage:\n*   R2     -  address of argument\n*   R3     -  length  of argument\n*   R7     -  addressability for DCE mapping of UCB\n*   R8     -  addressability for UCB\n*   R9     -  addressability for evalblock\n*   R10    -  addressability for the parsed argument list\n*   R11    -  addressability for efpl mapping macro (irxefpl)\n*   R12    -  base\n*---------------------------------------------------------------------\n         YREGS\n         SAVE  (14,12)                 Standard Linkage\n         LR    R12,R15\n         USING DEVTYPE,R12\n         ST    R13,SAVE+4\n         LA    R14,SAVE\n         ST    R14,8(R13)\n         LR    R13,R14\n*----------------------------------------------------------------------\n*     The format of the parsed argument list this function receives   *\n*     is address/length pairs until terminated by a doubleword of     *\n*     high values.                                                    *\n*     DS   A      address of arg n                                    *\n*     DS   F      length  of arg n                                    *\n*     DC   X'FFFFFFFFFFFFFFFF'                                        *\n*----------------------------------------------------------------------\n         TITLE '  REXX EXTENSION -- RETURN DEVICE TYPE OF DASD VOLSER'\n         USING EFPL,R1\n         L     R10,EFPLARG             address of parsed argument list\n         L     R9,EFPLEVAL             address of fullword ptr\n         L     R9,0(,R9)               address of the evalblock\n         L     R2,0(,R10)              address of arg 1\n         ST    R2,SAVEARG1             save so i can reuse r2\n         L     R3,4(,R10)              length  of arg 1\n         ST    R3,SAVER3\n*  If length of input data is greater than 125 you can call the IRXRLT\n*  routine to obtain a larger evaluation block.\n         CH    R3,=H'125'              is arg 1 length > 125?\n         BH    ERREXIT                 yes  too big for this function\n         XC    WORKX(100),WORKX        init to zeros prior to scan\n*\nUCBSCAN  EQU   *\n*\n* -- This section of code invokes the extended UCB scan services via\n* -- the UCBSCAN macro.  This handles dynamic UCBs and 4 digit addr.\n*\n         L     R3,SAVEARG1             restore addr of passed arg 1\n         LA    R8,48                   length of DCE area\n         UCBSCAN COPY,WORKAREA=WORKX,UCBAREA=UCB48,VOLSER=(R3),        X\n               DCEAREA=DCE,DCELEN=DCELENG,DEVCLASS=DASD,               X\n               DYNAMIC=YES,RANGE=ALL\n         LTR   R15,R15                 test if dasd ucb was returned\n         BNZ   RESULT                  no ucb returned; go to result\n*\n         LA    R8,UCB48                get address of ucb\n         USING UCBOB,R8                addressability for ucb\n         MVC   OUTAREA(2),UCBCHAN      move unit address to output\n         DROP  R8\nGETMODEL EQU   *\n         LA    R7,DCE                  addressability for dasd cl ext\n         USING DCEMAP,R7\n         MVC   OUTMODEL,DCEMDRDT       move MDR device type code\n         MVC   OUTCUMOD,DCECUID        move control unit id\n         MVC   OACTFEA,DCEACTFE        move active features byte\n         MVC   ODEVCYL,DCEUDCYL        data + alt cylinders\n*\n*  Fill in required info in the EVALBLOCK before returning.\n*\nRESULT   EQU   *\n         MVC   16(L'OUTAREA,R9),OUTAREA move result to EVDATA\n         LA    R1,L'OUTAREA            get length of returned output\n         ST    R1,8(,R9)               move length to  EVLEN\n         SR    R15,R15                 set return code to 0\nEXIT     EQU   *\n         L     R13,SAVE+4\n         RETURN (14,12),RC=(15)\nERRTYPE  EQU   *\n         MVI   OUTAREA+8,X'02'         move internal rc to output\n         B     RESULT\nERREXIT  EQU   *\n         MVI   OUTAREA+8,X'08'         argument too long\n         B     RESULT\n         EJECT\nSAVE     DC    18F'0'\nSAVER3   DS    F\nSAVEARG1 DS    F\n*\nOUTAREA  DS    0CL16\nODEVADR  DC    XL2'0'\nOUTMODEL DC    XL1'0'\nOUTCUMOD DC    XL1'0'\nOACTFEA  DC    XL1'0'\nODEVCYL  DC    XL2'FFFF'\n         DC    XL9'0'\n         SPACE 3\nWORKX    DC    100X'00'\nDCE      DS    CL48\nDCELENG  DC    H'48'\nUCB48    DS    CL48\n         DS    0F\nUCBA     DS    A\nDEV      DS    XL1\n         DS    0F\nP1       DS    A\nP2       DS    A\nP3       DS    A\n         LTORG\n*\n********************************************************************\n         IRXEFPL\n         DSECT\n         IEFUCBOB DEVCLAS=DA\nDCEMAP   IECDDCE\n         CVT   DSECT=YES,PREFIX=YES\n         END   DEVTYPE\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DEVTYPEO": {"ttr": 260, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00!\\x00\\x944\\x1f\\x00\\x95 _\\x103\\x00\\xd4\\x00\\xcf\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1994-12-07T00:00:00", "modifydate": "1995-07-24T10:33:21", "lines": 212, "newlines": 207, "modlines": 0, "user": "CEB40"}, "text": "DEVTYPE CSECT                         *\nDEVTYPE AMODE 31\nDEVTYPE RMODE ANY\n*---------------------------------------------------------------------\n* (C) COPYRIGHT AMDAHL CORPORATION  1995. All Rights Reserved\n* Written by:  Chuck Baumann ------------------July 1992    ----------\n* Version:     2.2\n*\n*      An external rexx function model.  Scans ucb chain until volser\n*      matches passed argument.   Returns the device type 3380 or 3390\n*      and number of cylinders of device and an internal return code.\n*\n* Register usage: (on entry)\n*   R0     -  address of environment block\n*   R1     -  address of the external function parameter list\n*   R2-12  -  unpredictable\n*   R13    -  register save area\n*   R14    -  return address\n*   R15    -  entry point address\n* Register usage:\n*   R2     -  address of argument\n*   R3     -  length  of argument\n*   R9     -  addressability for evalblock\n*   R10    -  addressability for the parsed argument list\n*   R11    -  addressability for efpl mapping macro (irxefpl)\n*   R12    -  base\n*---------------------------------------------------------------------\n         YREGS\n         SAVE  (14,12)                 Standard Linkage\n         LR    R12,R15\n         USING DEVTYPE,R12\n         ST    R13,SAVE+4\n         LA    R14,SAVE\n         ST    R14,8(R13)\n         LR    R13,R14\n*----------------------------------------------------------------------\n*     The format of the parsed argument list this function receives   *\n*     is address/length pairs until terminated by a doubleword of     *\n*     high values.                                                    *\n*     DS   A      address of arg n                                    *\n*     DS   F      length  of arg n                                    *\n*     DC   X'FFFFFFFFFFFFFFFF'                                        *\n*----------------------------------------------------------------------\n         TITLE '  REXX EXTENSION -- RETURN DEVICE TYPE OF DASD VOLSER'\n         USING EFPL,R1\n         L     R10,EFPLARG             address of parsed argument list\n         L     R9,EFPLEVAL             address of fullword ptr\n         L     R9,0(,R9)               address of the evalblock\n         L     R2,0(,R10)              address of arg 1\n         L     R3,4(,R10)              length  of arg 1\n         ST    R3,SAVER3\n*  If length of input data is greater than 125 you can call the IRXRLT\n*  routine to obtain a larger evaluation block.\n         CH    R3,=H'125'              is arg 1 length > 125?\n         BH    ERREXIT                 yes  too big for this function\n         XC    WORKX(100),WORKX        init to zeros prior to scan\nUCBSCAN  EQU   *\n         UCBSCAN COPY,WORKAREA=WORKX,UCBAREA=UCB48,VOLSER=(R2),        X\n               DEVCLASS=DASD,DYNAMIC=YES,RANGE=ALL\n         LTR   R15,R15                 test if dasd ucb was returned\n         BNZ   RESULT                  no ucb returned; go to result\n         LA    R8,UCB48                get address of ucb\n         USING UCBOB,R8                addressability for ucb\n         MVC   OUTAREA+6(2),UCBCHAN    move unit address to output\n         MVC   OUTAREA+9(1),UCBUNTYP   for debugging purposes\n         MVC   UNITVOL(6),UCBVOLI      move volser to output\n         CLI   UCBUNTYP,X'0E'          test if  3380 device type\n         BNE   CHK90                   not a 3380; go to chk90\n         MVC   UNITDEV,=C'3380'        move 3380 to text unit(dynalloc)\n         MVC   OUTAREA(4),=C'3380'     move to output\n         B     GETMODEL\nCHK90    EQU   *\n         CLI   UCBUNTYP,X'0F'          test if  3390 device type\n         BNE   ERRTYPE                 not a 3390;  go to invalid\n         MVC   UNITDEV,=C'3390'        move 3390 to text unit(dynalloc)\n         MVC   OUTAREA(4),=C'3390'     move to output\n         B     GETMODEL\n         DROP  R8\nGETMODEL EQU   *\n         BAL   R2,ALLOCATE             dynamically allocate volume\n         LTR   R15,R15                 test if dynamic allocation OK\n         BNZ   ERREXIT                 not OK;  go to errexit\n         DEVTYPE DDNAME,DEVTOUT,DEVTAB\n         LTR   R15,R15                 test DEVTYPE macro success\n         BNZ   ERRDEVT                 not OK;  go to errdevt\n         BAL   R2,DEALLOC              deallocate the volume\n         LTR   R15,R15                 test if deallocation OK\n         BNZ   ERREXIT                 not OK;  go to errexit\n         MVC   OUTAREA+4(2),DEVTOUT+8  move #cyls (hex) to output\n*\n*  Fill in required info in the EVALBLOCK before returning.\n*\nRESULT   EQU   *\n         MVC   16(L'OUTAREA,R9),OUTAREA move result to EVDATA\n         LA    R1,L'OUTAREA            get length of returned output\n         ST    R1,8(,R9)               move length to  EVLEN\n         SR    R15,R15                 set return code to 0\nEXIT     EQU   *\n         L     R13,SAVE+4\n         RETURN (14,12),RC=(15)\nERRTYPE  EQU   *\n         MVI   OUTAREA+8,X'02'         move internal rc to output\n         B     RESULT\nERRDEVT  EQU   *\n         MVI   OUTAREA+8,X'04'         DEVTYPE macro failed\n         B     RESULT\nERREXIT  EQU   *\n         MVI   OUTAREA+8,X'08'         dynamic alloc/dealloc failed\n         B     RESULT\n*---------------------------------------------------------------------\n* THE ALLOCATE AND DEALLOCATE ROUTINES ARE BAL'D.                   --\n* REGISTERS USED:  R4, R5, R6, R8,  R2 = RETURN                     --\n*---------------------------------------------------------------------\nALLOCATE EQU   *                                                        P24DYNAL\n         LA    R8,DYNWORK              ADDRESS OF DYN ALLOC BLOCKS\n         USING S99RBP,R8               FOR S99RBP DSECT\n         LA    R4,S99RBPTR+4           POINT AT REQUEST BLOCK\n         USING S99RB,R4                FOR S99RB  DSECT\n         ST    R4,S99RBPTR\n         OI    S99RBPTR,S99RBPND       TURN ON HI ORDER BIT IN S99RBPTR\n         XC    S99RB(RBLEN),S99RB      SET REQUEST BLOCK TO ZEROS\n         MVI   S99RBLN,RBLEN           PUT REQ BLK LEN IN ITS LEN FLD\n         MVI   S99VERB,S99VRBAL        SET VERB TO ALLOCATION\n         MVI   S99FLAG1,S99NOCNV       DO NOT USE AN EXISTING ALLOC\n         LA    R5,S99RB+RBLEN          POINT TO START OF TUP LIST\n         USING S99TUPL,R5\n         ST    R5,S99TXTPP             STORE ADDR OF TUP LIST IN RB\n         LA    R6,STATUSTU             DISPOSITION=SHR\n         ST    R6,S99TUPTR             STORE IN TUP LIST\n         LA    R5,S99TUPL+4            ADDR OF NEXT TUPL ENTRY\n         LA    R6,DDNTU                DDNAME\n         ST    R6,S99TUPTR             STORE IN TUP LIST\n         LA    R5,S99TUPL+4            ADDR OF NEXT TUPL ENTRY\n         LA    R6,UNITTU               UNIT ADDRESS\n         ST    R6,S99TUPTR             STORE IN TUP LIST\n         LA    R5,S99TUPL+4            ADDR OF NEXT TUPL ENTRY\n         LA    R6,VOLTU                VOLSER\n         ST    R6,S99TUPTR             STORE IN TUP LIST\n         OI    S99TUPTR,S99TUPLN       TURN ON HI ORDER BIT\n         LR    R1,R8\n         DYNALLOC\n         BR    R2\nDEALLOC EQU    *                                                        P25DYNUN\n         LA    R8,DYNWORK              ADDRESS OF DYN ALLOC BLOCKS\n         USING S99RBP,R8               FOR S99RBP DSECT\n         LA    R4,S99RBPTR+4           POINT AT REQUEST BLOCK\n         USING S99RB,R4                FOR S99RB  DSECT\n         ST    R4,S99RBPTR\n         OI    S99RBPTR,S99RBPND       TURN ON HI ORDER BIT IN S99RBPTR\n         XC    S99RB(RBLEN),S99RB      SET REQUEST BLOCK TO ZEROS\n         MVI   S99RBLN,RBLEN           PUT REQ BLK LEN IN ITS LEN FLD\n         MVI   S99VERB,S99VRBUN        SET VERB TO DEALLOCATION\n         LA    R5,S99RB+RBLEN          POINT TO START OF TUP LIST\n         USING S99TUPL,R5\n         ST    R5,S99TXTPP             STORE ADDR OF TUP LIST IN RB\n         LA    R6,DDNTU                DDNAME\n         ST    R6,S99TUPTR             STORE IN TUP LIST\n         OI    S99TUPTR,S99TUPLN       TURN ON HI ORDER BIT\n         LR    R1,R8\n         DYNALLOC\n         BR    R2\n         EJECT\nDD       DC    CL8' '             WORK AREA FOR DDNAME TO OPEN\n*   SVC 99 (DYNAMIC ALLOCATION TEXT UNITS) ***\nDYNWORK  DS    CL50                    DYNAMIC ALLOCATION WORK AREA     DYNWORK\nRBLEN    EQU   (S99RBEND-S99RB)                                         RBLEN\n         DS    0F\nSTATUSTU DC    AL2(DALSTATS)           KEY FOR DSN DISPOSTION           STATUSTU\n         DC    X'0001'\n         DC    X'0001'                 LEN OF PARM\n         DC    X'08'                   DISP=SHR\n*\n         DS    0F\nDDNTU    DC    AL2(DALDDNAM)           KEY FOR DDNAME ALLOCATION        DDNTU\n         DC    X'0001'\nDDNLEN   DC    X'0008'                 LEN OF DDNAME                    DDNLEN\nDDNAME   DC    C'CACHEDEV'             DDNAME FOR DEVTYPE MACRO         DDNAME\n*\n         DS    0F\nUNITTU   DC    AL2(DALUNIT)            KEY FOR UNIT   ALLOCATION        DDNTU\n         DC    X'0001'\n         DC    X'0004'                 LEN OF UNIT ADDR                 DDNLEN\nUNITDEV  DC    C'XXXX'                 DEVICE TYPE FOR UNIT ADDRESS     DDNAME\n*\n         DS    0F\nVOLTU    DC    AL2(DALVLSER)           KEY FOR VOLSER ALLOCATION        DDNTU\n         DC    X'0001'\n         DC    X'0006'                 LEN OF VOLSER                    DDNLEN\nUNITVOL  DC    C'XXXXXX'               VOLSER                           DDNAME\n         EJECT\nSAVE     DC    18F'0'\nSAVER3   DS    F\n*\nOUTAREA  DS    0CL10\n         DC    CL8' '\n         DC    XL2'0000'\nDEVTOUT  DS    5F                      output area for  DEVTYPE macro\n         SPACE 3\nWORKX    DC    100X'00'\nUCB48    DS    CL48\n         DS    0F\nUCBA     DS    A\n         LTORG\n*\n         IEFZB4D0\n         IEFZB4D2\n********************************************************************\n         IRXEFPL\n         DSECT\n         IEFUCBOB DEVCLAS=DA\n         CVT   DSECT=YES\n         END   DEVTYPE\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IEFU84": {"ttr": 269, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00U\\x00\\x95$\\x0f\\x00\\x95$\\x0f\\x15 \\x022\\x022\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-08-28T00:00:00", "modifydate": "1995-08-28T15:20:55", "lines": 562, "newlines": 562, "modlines": 0, "user": "CEB40"}, "text": "//CEB40U84 JOB (X),'CHUCK.B',MSGCLASS=Y,CLASS=A\n//ASM   EXEC ASMHCL,PARM.C='RENT',\n//            PARM.L='LIST,MAP,LET,RENT,REFR'\n//C.SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR\n//          DD DSN=SYS1.MODGEN,DISP=SHR\n//C.SYSIN DD *\n         TITLE 'IEFU84 BRANCH ENTERED SMF EXIT'\nIEFU84   CSECT\nIEFU84  AMODE 31\nIEFU84  RMODE ANY\n*--------------------------------------------------------------------\n*  (C) COPYRIGHT AMDAHL CORPORATION  1995. All Rights Reserved\n*    This SMF exit routine only handles type 22(8) records\n*    and issues a WTO (branch entered) describing 3990 state changes.\n*    All other record types are ignored.\n* Entry Points -\n*         IEFU84\n* Locks -\n*  Local lock (enabled for I/O and EXT interrupts)\n* Input\n*    Register 1 contains the address of a fullword that points to\n*    the record that SMF is going to write.\n*\n* Output\n*    Register 15 must contain one of the following return codes:\n*    0 - Write the SMF record (keep)\n*    4 - Don't write the SMF record (delete)\n*\n* Installation\n*    Assemble and link into SYS1.LPALIB.  Re-IPL with CLPA option.\n*    Edit the SYS1.PARMLIB(SMFPRMxx) member and add IEFU84 to the\n*    EXITS for SYS and make sure SMF type 22 is being recorded.\n* Written by:  Chuck Baumann,   Amdahl   January 1995\n*              optional part of Cacheman utility\n*--------------------------------------------------------------------\n         EJECT\n         YREGS\nTYPE22   EQU   X'16'               SMF type 22 record\nS3990CHG EQU   X'08'               3990 state change indicator\nCACHSTAT EQU   B'11100000'         cache status changes\nDEVSTAT  EQU   B'11000000'         device cache status bits\nPINSTAT  EQU   B'11000000'         pinned data status bits\nDFWSTAT  EQU   B'00110000'         DFW cache status bits\nDUPSTAT  EQU   B'00000011'         Duplex cache status bits\nACTIVE   EQU   B'00000000'         active\nPENDACT  EQU   B'00100000'         pending active\nDEACTSUB EQU   B'01000000'         deactivated subsystem\nDEACTHST EQU   B'10000000'         deactivated host\nPENDING  EQU   B'11000000'         pending\nPENDFAIL EQU   B'11100000'         pending off failed\nSSDISABL EQU   B'00010000'         subsystem storage disabled maint\nIMLDEV   EQU   B'00000010'         IML device is not available\nCFWDISAB EQU   B'00000001'         Cache Fast Write is disabled\nDEV00    EQU   B'00000000'         active\nDEV40    EQU   B'01000000'         not used\nDEV80    EQU   B'10000000'         deactivation pending\nDEVC0    EQU   B'11000000'         deactivated\nDUP00    EQU   B'00000000'         available\nDUP01    EQU   B'00000001'         pending\nDUP02    EQU   B'00000010'         failed duplex,\nDUP03    EQU   B'00000011'         failed duplex,\nDUP04    EQU   B'00000100'         secondary of duplex pair\nDUP08    EQU   B'00001000'         primary of duplex pair\nDFW00    EQU   B'00000000'         active\nDFW10    EQU   B'00010000'         not used\nDFW20    EQU   B'00100000'         deactivation pending\nDFW30    EQU   B'00110000'         deactivated\nPIN00    EQU   B'00000000'         no pinned data exists\nPIN40    EQU   B'01000000'         pinned data exists for suspended\nPIN80    EQU   B'10000000'         reserved bit\nPINC0    EQU   B'11000000'         pinned data exists for suspended\nNVS00    EQU   B'00000000'         NVS is active\nNVS40    EQU   B'01000000'         NVS deactivated subsystem\nNVS80    EQU   B'10000000'         NVS deactivated host\nNVSC0    EQU   B'11000000'         NVS is pending\nNVSSTAT  EQU   B'11000000'         NVS status changes\nNVSDISMT EQU   B'00010000'         NVS disabled for Maintenance\nNVSPEND  EQU   B'00001000'         NVS pending due to error\nCCAMASK  EQU   B'11000000'         N mask for CCA reconstruction\n*\n         EJECT\n         USING *,R15               Temporary base for\n         B     HERE                branching around\n         DC    CL8'IEFU84  '       module name\n         DC    CL8'&SYSDATE'\n         DC    CL8' @ &SYSTIME'\nHERE     STM   R14,R12,12(R13)     save regs\n         DROP  R15                 drop temp base\n         USING IEFU84,R12          base\n         LR    R12,R15\n         LR    R11,R1              save ptr to parms\n         LR    R10,R13             save temporary until getmain is done\n         L     R2,0(R11)           get smf record address\n         CLI   5(R2),TYPE22        is it type 22?\n         BNE   QUIKEXIT            if not then go to exit\n         CLI   19(R2),S3990CHG     was it created by 3990 state chg?\n         BNE   QUIKEXIT            if not then go to exit\n*\n*  Obtain the Local lock unconditionally\n*\nGETLOCK  EQU   *\n         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=USE\nSAVERC   LR    R9,R15              save return code from setlock\n*\n         L     R5,CVTPTR           R5 = addr of cvt\n         USING CVT,R5\n         L     R6,CVTTCBP          R6 = ptr to addr of cur tcb\n         L     R7,12(R6)           R7 = addr of current ascb\n         DROP  R5\n         SR    R0,R0               clear reg 0  (mem really is SP252\n*                                  because we are key 0 supervisor st)\n         SR    R4,R4               indicate current TCB\n         LA    R0,WORKLEN          set length for getmain from sp 0\n*                                  R4 and R7 are used by branch GETMAIN\n         GETMAIN R,LV=(R0),BRANCH=YES     unconditional request\n*                                  will abend this task if not rc=0\n         LR    R13,R10             restore so we can chain saves\n         ST    R1,8(R13)           chain\n         ST    R13,4(R1)           save\n         LR    R13,R1              areas\n         USING WORK,R13            base\n         MVC   WTOMSG(WTOLEN),WTO  move message to gotten\n*\n         L     R2,0(R11)           get smf record address\n         USING SMFRCD22,R2         map symbolic names to type 22 rec\n*\n         CLC   SMF22SCS,SMF22PCS   compare current to previous\n         BE    CHKNVS              no change.  go check for nvs change\n         MVC   RESULTXC,SMF22SCS   prepare for XC\n         XC    RESULTXC,SMF22PCS   resultxc tells which flds chgd\n         SR    R3,R3\n         IC    R3,SMF22SCS         move one byte to register\n         EJECT\n         TM    RESULTXC,CACHSTAT   test for changes with prev field\n         BZ    CHKDISAB\n         LA    R6,MSGTAB           point to first entry in table\n         LA    R7,NMSGS            r7 = number of entries in table\n         LR    R1,R3\n         SRL   R1,5                shift off bits 3-7\nCHECKMSG EQU   *\n         CLM   R1,1,0(R6)          do the bit patterns match?\n         BE    MSGFND              yes   go build wto message\n         LA    R6,LENMSG(R6)       no    point to next entry in table\n         BCT   R7,CHECKMSG         try until match or end of table\n         LA    R6,NOMSG            debug message\n         BAL   R10,WTORTN          go issue WTO\n         B     ENDCHK              not good. this should not happen.\nMSGFND   EQU   *\n         BAL   R10,WTORTN          go issue WTO\nCHKDISAB EQU   *\n         TM    RESULTXC,SSDISABL   did subsys storage dis maint chg?\n         BNO   CHKIML              not on.   go chk next flag bit\n         TM    SMF22SCS,SSDISABL   is subsys storage dis maint new?\n         BNO   LSTGENA             not on.   go chk next flag bit\n         LA    R6,STGDIS           r6 = address of message to issue\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKIML\nLSTGENA  EQU   *                   now on.   go chk next flag bit\n         LA    R6,STGENA           r6 = address of message to issue\n         BAL   R10,WTORTN          go issue WTO\nCHKIML   EQU   *\n         TM    RESULTXC,IMLDEV     is IML device unavailable new?\n         BNO   CHKCFW              not on.   go chk next flag bit\n         TM    SMF22SCS,IMLDEV     is IML device unavailable new?\n         BNO   LIMLENA             now on.   go chk next flag bit\n         LA    R6,IMLDIS           r6 = address of message to issue\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKCFW\nLIMLENA  EQU   *                   now on.   go chk next flag bit\n         LA    R6,IMLENA           r6 = address of message to issue\n         BAL   R10,WTORTN          go issue WTO\nCHKCFW   EQU   *\n         TM    RESULTXC,CFWDISAB   is cache fast write disabled new?\n         BNO   ENDCHK              not on.  all flags have been tested\n         TM    SMF22SCS,CFWDISAB   is cache fast write disabled new?\n         BNO   LCFWENA             not on.  all flags have been tested\n         LA    R6,CFWDIS           r6 = address of message to issue\n         BAL   R10,WTORTN          go issue WTO\n         B     ENDCHK\nLCFWENA  EQU   *                   now on.  all flags have been tested\n         LA    R6,CFWENA           r6 = address of message to issue\n         BAL   R10,WTORTN          go issue WTO\n         B     ENDCHK\n*\n         EJECT\nCHKNVS   EQU   *                   SMF22SNV compared to SMF22PNV\n         CLC   SMF22SNV,SMF22PNV   compare current to previous\n         BE    CHKDEV              no change.  go check for device chg\n         MVC   RESULTXC,SMF22SNV   prepare for exclusive or character\n         XC    RESULTXC,SMF22PNV   resultxc indicates which flds chgd\n         TM    RESULTXC,NVSSTAT    test for changes with prev field\n         BZ    CHKNVSDM            no  NVS status bits did not change\nCHKNC0   TM    SMF22SNV,NVSC0      was NVS changed to active or pendin?\n         BZ    LNVSACT             both bits are off so NVS is active\n         BNO   CHKN10              both bits are not on. check next ptn\n         LA    R6,NVSPND           both bits are on.  NVS is pending\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKNVSDM            go check next flag.\nLNVSACT  LA    R6,NVSACT           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKNVSDM            go check next flag.\nCHKN10   EQU   *\n         TM    SMF22SNV,NVS80      was NVS changed deactivated host?\n         BNO   CHKN01              no change.  go check next pattern\n         LA    R6,NVSDHS           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKNVSDM            go check next flag.\nCHKN01   EQU   *\n         TM    SMF22SNV,NVS40      was NVS changed deactivated subsys?\n         BNO   CHKNVSDM            no change.  go check next pattern\n         LA    R6,NVSDSS           get address of message\n         BAL   R10,WTORTN          go issue WTO\nCHKNVSDM EQU   *\n         TM    RESULTXC,NVSDISMT   test for changes with prev field\n         BZ    CHKNPND             no  NVS status bits did not change\n         TM    SMF22SNV,NVSDISMT   did NVS disabled maint status chg?\n         BNO   LNVSENA             not on.   go chk next flag bit\n         LA    R6,NVSDIM           r6 = address of message to issue\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKNPND\nLNVSENA  EQU   *                   now on.   go chk next flag bit\n         LA    R6,NVSENA           r6 = address of message to issue\n         BAL   R10,WTORTN          go issue WTO\nCHKNPND  EQU   *\n         TM    SMF22SNV,NVSPEND    did NVS pending due err stat  chg?\n         BNO   ENDCHK              not on.   all checks are complete\n         LA    R6,NVSPER           r6 = address of message to issue\n         BAL   R10,WTORTN          go issue WTO\n         B     ENDCHK\n         EJECT\nCHKDEV   EQU   *\n         CLC   SMF22SDS,SMF22PDS   compare current to previous\n         BE    ENDCHK              no changes.\n         MVC   RESULTXC,SMF22SDS   prepare for XC\n         XC    RESULTXC,SMF22PDS   resultxc says which flds chgd\n         TM    RESULTXC,DEVSTAT    test for changes with prev field\n         BZ    CHKDFWST            no  device cache status didnt change\nCHKDEVC0 EQU   *\n         TM    SMF22SDS,DEVC0      was device cache chgd to deactivate?\n         BZ    LDEVACT             both bits are off so dev cache act\n         BNO   CHKDEV80            both bits are not on.\n         LA    R6,DEVDEA           both bits are on.  dev cache deact\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDFWST            go check next flag.\nLDEVACT  EQU   *\n         LA    R6,DEVACT           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDFWST            go check next flag.\nCHKDEV80 EQU   *\n         TM    SMF22SDS,DEV80      was device cache chgd to deact pend?\n         BNO   CHKDEV40            no change.  go check next pattern\n         LA    R6,DEVDPN           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDFWST            go check next flag.\nCHKDEV40 EQU   *\n         TM    SMF22SDS,DEV40      was device cache chgd to deact pend?\n         BNO   CHKDFWST            no change.  go check next pattern\n         LA    R6,BADDEV           get address of message\n         BAL   R10,WTORTN          go issue WTO\nCHKDFWST EQU   *\n         TM    RESULTXC,DFWSTAT    test for changes with prev field\n         BZ    CHKDUPST            no  DFW status bits did not change\nCHKDFW30 EQU   *\n         TM    SMF22SDS,DFW30      was device cache chgd to deact pend?\n         BZ    LDFWACT             both bits are off. dfw status active\n         BNO   CHKDFW20            both bits are not on.\n         LA    R6,DFWDEA           both bits are on.  dfw is deactivatd\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDUPST            go check next flag.\nLDFWACT  EQU   *\n         LA    R6,DFWACT           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDUPST            go check next flag.\nCHKDFW20 EQU   *\n         TM    SMF22SDS,DFW20      was device cache chgd to deact pend?\n         BNO   CHKDFW10            no change.  go check next pattern\n         LA    R6,DFWDPN           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDUPST            go check next flag.\nCHKDFW10 EQU   *\n         TM    SMF22SDS,DFW10      was device cache chgd to deact pend?\n         BNO   CHKDUPST            no change.  go check next pattern\n         LA    R6,BADDFW           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         EJECT\nCHKDUPST EQU   *\n         TM    RESULTXC,DUPSTAT    test for changes with prev field\n         BZ    CHKDUPPR            no  duplex       status didnt change\n         MVC   CCAORIG,SMF22CCA    get CCA of originating device\n         NI    CCAORIG,CCAMASK     save only bits 0-1\n         MVC   CCAWORK,SMF22SDS+1  get other cca in duplex\n         NI    CCAWORK,X'3F'       only low order 6 bits are used\n         OC    CCAWORK(1),CCAORIG  restore bits 0-1 to get full CCA\n         UNPK  CCA(3),CCAWORK(2)    prepare for translate instr\n         TR    CCA(2),HEXTABLE-240  translate to displayable\n         MVI   CCA+2,C' '          eliminate extra char from unpack\nCHKDUP03 EQU   *\n         TM    SMF22SDS,DUP03      was duplex changed to failed?\n         BZ    LDUPAVL             both bits are off. duplex available\n         BNO   CHKDUP02            both bits are not on.\n         LA    R6,DUPFLB           both bits are on.\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDUPPR            go check next flag.\nLDUPAVL  EQU   *\n         TM    SMF22SDS,DUP08      is the primary of duplex bit on?\n         BZ    DAVAIL              no so issue the available message\n         LA    R6,DUPEST           yes so issue the duplex est msg\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDUPPR            go check next flag.\nDAVAIL   LA    R6,DUPAVL           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDUPPR            go check next flag.\nCHKDUP02 EQU   *\n         TM    SMF22SDS,DUP02      was duplex changed to failed?\n         BNO   CHKDUP01            no change.  go check next pattern\n         LA    R6,DUPFLA           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDUPPR            go check next flag.\nCHKDUP01 EQU   *\n         TM    SMF22SDS,DUP01      was duplex changed to pending?\n         BNO   CHKDUPPR            no change.  go check next pattern\n         LA    R6,DUPPEN           get address of message\n         BAL   R10,WTORTN          go issue WTO\nCHKDUPPR EQU   *\n         TM    RESULTXC,DUP08      was primary of duplex changed?\n         BNO   CHKDUPSE            no change.  go check next pattern\n         MVC   CCAORIG,SMF22CCA    get CCA of originating device\n         NI    CCAORIG,CCAMASK     save only bits 0-1\n         MVC   CCAWORK,SMF22SDS+1  get other cca in duplex\n         NI    CCAWORK,X'3F'       only low order 6 bits are used\n         OC    CCAWORK(1),CCAORIG  restore bits 0-1 to get full CCA\n         UNPK  CCA(3),CCAWORK(2)    prepare for translate instr\n         TR    CCA(2),HEXTABLE-240  translate to displayable\n         MVI   CCA+2,C' '          eliminate extra char from unpack\n         TM    SMF22SDS,DUP08      was primary of duplex changed?\n         BNO   LDUPSIM             changed to off. back to simplex\n         LA    R6,DUPPRI           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         TM    SMF22SDS,DUP01      is duplex pending flag on? SLOPPY\n         BO    CHKDUPSE            no so skip duplex est message\n         LA    R6,DUPEST           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     CHKDUPSE\nLDUPSIM  EQU   *\n         MVC   CCA,=C'   '\n         LA    R6,DUPSIM\n         BAL   R10,WTORTN          go issue WTO\nCHKDUPSE EQU   *\n         TM    SMF22SDS,DUP04      is  secondary of duplex on?\n         BNO   CHKPINST            no change.  go check next pattern\n         MVC   CCAORIG,SMF22CCA    get CCA of originating device\n         NI    CCAORIG,CCAMASK     save only bits 0-1\n         MVC   CCAWORK,SMF22SDS+1  get other cca in duplex\n         NI    CCAWORK,X'3F'       only low order 6 bits are used\n         OC    CCAWORK(1),CCAORIG  restore bits 0-1 to get full CCA\n         UNPK  CCA(3),CCAWORK(2)    prepare for translate instr\n         TR    CCA(2),HEXTABLE-240  translate to displayable\n         MVI   CCA+2,C' '          eliminate extra char from unpack\n         LA    R6,DUPSEC           get address of message\n         BAL   R10,WTORTN          go issue WTO\nCHKPINST EQU   *\n         MVC   RESULTXC,SMF22SDS+1 prepare for XC\n         XC    RESULTXC,SMF22PDS+1 resultxc says which flds chgd\n         TM    RESULTXC,PINSTAT    test for changes with prev field\n         BZ    ENDCHK              no changes so its miller time.\nCHKPINC0 TM    SMF22SDS+1,PINC0    no pinned exists?\n         BZ    LPINNOX             both bits are off. pinned no exist\n         BNO   CHKPIN80            both bits are not on.\n         LA    R6,PINEXS           both bits are on. pinned exists\n         BAL   R10,WTORTN          go issue WTO\n         B     ENDCHK\nLPINNOX  LA    R6,PINNOX           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     ENDCHK\nCHKPIN80 TM    SMF22SDS+1,PIN80    unused bit. if on issue bad msg\n         BNO   CHKPIN40            no change.  go check next pattern\n         LA    R6,BADPIN           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     ENDCHK\nCHKPIN40 TM    SMF22SDS+1,PIN40    no pinned exists?\n         BNO   ENDCHK              no change.  go check next pattern\n         LA    R6,PINEXI           get address of message\n         BAL   R10,WTORTN          go issue WTO\n         B     ENDCHK\n         EJECT\n*--------------------------------------------------------------------*\n*   Construct the message to be issued. Move message text, descriptor*\n*   code and the volser of device in SMF22VOL.  Exec the WTO & return*\n*--------------------------------------------------------------------*\nWTORTN   EQU   *\n         SR    R0,R0               clear reg 0\n         LA    R4,WTOMSG           point to beginning of parm list\n         AH    R4,0(R4)            add length of text\n         MVC   0(2,R4),1(R6)       move descriptor code to parm list\n         MVC   SSSTAT,3(R6)        move message text to parm list\n         UNPK  DEVID(5),SMF22CUA(3)   prepare for translate instr\n         TR    DEVID(4),HEXTABLE-240  translate to displayable\n         MVI   DEVID+4,C','        eliminate extra char from unpack\n         WTO   MF=(E,WTOMSG),LINKAGE=BRANCH\n         BR    R10                 go back to work\n*\nENDCHK   EQU   *\n         SR    R0,R0               clear reg 0\n         LA    R0,WORKLEN          free gotten area\n         L     R5,CVTPTR           R5 = addr of cvt\n         USING CVT,R5\n         L     R6,CVTTCBP          R6 = ptr to addr of cur tcb\n         DROP  R5\n         L     R7,12(R6)           R7 = addr of current ascb\n         SR    R4,R4               indicate current TCB\n         LR    R1,R13              address of getmained area\n         L     R13,4(R13)          get to callers save area\n         FREEMAIN R,LV=(R0),A=(R1),BRANCH=YES\n         LTR   R9,R9               test return code from Setlock OBTAIN\n         BNZ   HADLOCK             rc for obtain = 4 (caller had lock)\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=USE\nHADLOCK  EQU   *\nQUIKEXIT LM    R14,R12,12(R13)     restore regs\n         SR    R15,R15             set rc = 0\n*        BSM   0,14                return\n         BR    R14                 return\nWTO  WTO 'PCC10I XXXX,MESSAGE TEXT OF CONDITION************   ',       X\n               ROUTCDE=(1),DESC=(2),MCSFLAG=(BRDCST),LINKAGE=,MF=L\nWTOLEN   EQU   *-WTO\n         EJECT\n*   Descriptor Code\n*    1   System Failure\n*    2   Immediate Action required\n*    3   Eventual Action required\n*    4   System Status\n*    5   Immediate Command response\n*    6   Job status\n*    7   Retain action message for life of task\n*    8   Out-of-line message\n*    9   Operator request\n*   10   Dynamic status displays\n*   11   Critical eventual action requested\n*   12   Important information messages\n*   13   Message previously automated\n*\nMSGTAB   DS    0H\n*               SMF    descriptor flags\n*              flag    1234567890123456       message text\n         DC    X'00',B'0010000000000000'\n         DC    CL40'SUBSYSTEM CACHE NOW ACTIVE'\nLENMSG   EQU   *-MSGTAB\n         DC    X'01',B'0010000000000000'\n         DC    CL40'SUBSYSTEM CACHE IS PENDING ACTIVE'\n         DC    X'02',B'0010000000000000'\n         DC    CL40'SUBSYSTEM CACHE DEACTIVATED'\n         DC    X'04',B'0010000000000000'\n         DC    CL40'SUBSYSTEM CACHE DEACTIVATED BY HOST'\n         DC    X'06',B'0010000000000000'\n         DC    CL40'SUBSYSTEM CACHE PENDING OFF'\n         DC    X'07',B'0100000000000000'\n         DC    CL40'SUBSYSTEM CACHE PENDING OFF FAILED'\nNMSGS    EQU   (*-MSGTAB)/LENMSG\n*                 descriptor flags\n*                 1234567890123456       message text\nDEVACT   DC    X'00',B'0010000000000000'\n         DC    CL40'DEVICE CACHE IS ACTIVE'\nBADDEV   DC    X'00',B'0100000000000000'\n         DC    CL40'INVALID DEVICE CACHE STATUS'\nDEVDPN   DC    X'00',B'0010000000000000'\n         DC    CL40'DEVICE CACHE DEACTIVATE PENDING'\nDEVDEA   DC    X'00',B'0010000000000000'\n         DC    CL40'DEVICE CACHE HAS BEEN DEACTIVATED'\n*\nDFWACT   DC    X'00',B'0010000000000000'\n         DC    CL40'DEVICE DFW IS ACTIVE'\nBADDFW   DC    X'00',B'0100000000000000'\n         DC    CL40'INVALID DEVICE DFW STATUS'\nDFWDPN   DC    X'00',B'0010000000000000'\n         DC    CL40'DEVICE DFW DEACTIVATION PENDING'\nDFWDEA   DC    X'00',B'0010000000000000'\n         DC    CL40'DEVICE DFW HAS BEEN DEACTIVATED'\n*\nDUPEST   DC    X'00',B'0010000000000000'\n         DC    CL40'DUPLEX IS ESTABLISHED      OTHER CCA='\nDUPAVL   DC    X'00',B'0010000000000000'\n         DC    CL40'DUPLEX IS AVAILABLE        OTHER CCA='\nDUPSIM   DC    X'00',B'0010000000000000'\n         DC    CL40'DUPLEX PAIR RESET TO SIMPLEX         '\nDUPPEN   DC    X'00',B'0010000000000000'\n         DC    CL40'PENDING DUPLEX             OTHER CCA='\nDUPFLA   DC    X'00',B'0010000000000000'\n         DC    CL40'SECONDARY DEV SUSPENDED    OTHER CCA='\nDUPFLB   DC    X'00',B'0010000000000000'\n         DC    CL40'PRIMARY DEVICE SUSPENDED   OTHER CCA='\nDUPPRI   DC    X'00',B'0010000000000000'\n         DC    CL40'PRIMARY OF DUPLEX PAIR     OTHER CCA='\nDUPSEC   DC    X'00',B'0010000000000000'\n         DC    CL40'SECONDRY OF DUPLEX PAIR    OTHER CCA='\n*\nNVSACT   DC    X'00',B'0010000000000000'\n         DC    CL40'SUBSYSTEM NVS IS ACTIVE'                (X'00')\nNVSDSS   DC    X'00',B'0100000000000000'\n         DC    CL40'SUBSYSTEM NVS FAILED'                   (X'01')\nNVSDHS   DC    X'00',B'0010000000000000'\n         DC    CL40'SUBSYSTEM NVS HAS BEEN DEACTIVATED'     (X'02')\nNVSPND   DC    X'00',B'0010000000000000'\n         DC    CL40'SUBSYSTEM NVS IS PENDING OFF'           (X'04')\n*\nNVSDIM   DC    X'00',B'0010000000000000'\n         DC    CL40'SUBSYSTEM NVS DISABLED FOR MAINTENANCE'\nNVSENA   DC    X'00',B'0010000000000000'\n         DC    CL40'SUBSYSTEM NVS ENABLED FROM MAINTENANCE'\nNVSPER   DC    X'00',B'0100000000000000'\n         DC    CL40'SUBSYSTEM NVS PENDING OFF DUE TO ERROR'\n*\nPINNOX   DC    X'00',B'0010000000000000'\n         DC    CL40'NO PINNED DATA EXISTS FOR DEVICE'           (X'00')\nPINEXI   DC    X'00',B'0100000000000000'\n         DC    CL40'DEVICE HAS PINNED DATA, DFW ACTIVE'         (X'01')\nPINEXS   DC    X'00',B'0100000000000000'\n         DC    CL40'DEVICE HAS PINNED DATA, DFW SUSPENDED'      (X'03')\nBADPIN   DC    X'00',B'0100000000000000'\n         DC    CL40'INVALID PINNED DATA STATUS'                 (X'04')\n*\nSTGDIS   DC    X'00',B'0100000000000000'\n         DC    CL40'SUBSYSTEM STORAGE DISABLED MAINT'\nSTGENA   DC    X'00',B'0010000000000000'\n         DC    CL40'SUBSYSTEM STORAGE NOW ENABLED'\nIMLDIS   DC    X'00',B'0100000000000000'\n         DC    CL40'IML DEVICE UNAVAILABLE'\nCFWDIS   DC    X'00',B'0010000000000000'\n         DC    CL40'CACHE FASTWRITE IS DISABLED'\nIMLENA   DC    X'00',B'0100000000000000'\n         DC    CL40'IML DEVICE IS NOW AVAILABLE'\nCFWENA   DC    X'00',B'0010000000000000'\n         DC    CL40'CACHE FASTWRITE IS ACTIVE'\nNOMSG    DC    X'00',B'0100000000000000'\n         DC    CL40'INVALID SUBSYSTEM CACHING STATUS'\n*\nHEXTABLE DC    C'0123456789ABCDEF' used by translate instruction\n         LTORG\nWORK     DSECT\nSAVEAREA DS    18F\nRESULTXC DS    CL1\nCCAORIG  DS    CL1                 CCA of originating device\nCCAWORK  DS    CL2                 CCA of other device in pair (2-7)\n         DS    0F\nWTOMSG   DS    256X                work\n         ORG   WTOMSG+4\n         DS    CL7    'PCC10I '\nDEVID    DS    CL4    'XXXX'\n         DS    CL1    ','\nSSSTAT   DS    CL38   'MESSAGE TEXT'\nCCA      DS    CL3\n         ORG\nWORKLEN  EQU   *-WORK\n         EJECT\n         IFASMFR 22                mapping macro for type 22 record\n         IHAPSA\n         CVT   DSECT=YES\n         END\n//L.SYSLMOD DD DSN=SYS1.LPALIB,DISP=SHR,\n//      UNIT=SYSDA,VOL=SER=SM51D0\n//SYSIN  DD *\n ENTRY IEFU84\n NAME IEFU84(R)\n/*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SLEEP": {"ttr": 264, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00Q\\x00\\x94)O\\x00\\x95 _\\x103\\x00[\\x00d\\x00\\x00\\xc3\\xc5\\xc2\\xf4\\xf0@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-10-21T00:00:00", "modifydate": "1995-07-24T10:33:51", "lines": 91, "newlines": 100, "modlines": 0, "user": "CEB40"}, "text": "         TITLE '  REXX EXTENSION -- ISSUE STIMER WAIT'\nSLEEP   CSECT                         *\nSLEEP   AMODE 31\nSLEEP   RMODE ANY\n*---------------------------------------------------------------------\n* (C) COPYRIGHT AMDAHL CORPORATION  1995. ALL RIGHTS RESERVED\n* WRITTEN BY:  CHUCK BAUMANN ------------------MAY 1993     ----------\n*\n*      AN EXTERNAL REXX SUBROUTINE       THIS CODE WILL ISSUE AN MVS\n*      STIMER MACRO USING THE ARGUMENT AS THE INTERVAL (IN SECONDS) TO\n*      WAIT. THIS SIMULATES THE VM SLEEP COMMAND.\n*\n* INVOKED:    CALL SLEEP XXXX      (XXXX = NUMBER OF SECONDS TO SLEEP)\n* REFERNC:    TSO EXTENSIONS VERSION 2\n*             PROCEDURES LANGUAGE MVS/REXX REFERENCE  SC28-1883\n*\n* REGISTER USAGE: (ON ENTRY)\n*   R0     -  ADDRESS OF ENVIRONMENT BLOCK\n*   R1     -  ADDRESS OF THE EXTERNAL FUNCTION PARAMETER LIST\n*   R2-12  -  UNPREDICTABLE\n*   R13    -  REGISTER SAVE AREA\n*   R14    -  RETURN ADDRESS\n*   R15    -  ENTRY POINT ADDRESS\n* REGISTER USAGE:\n*   R2     -  ADDRESS OF ARGUMENT\n*   R3     -  LENGTH  OF ARGUMENT\n*   R11    -  ADDRESSABILITY FOR EFPL MAPPING MACRO (IRXEFPL)\n*   R12    -  BASE\n*---------------------------------------------------------------------\n         YREGS\n         SAVE  (14,12)                 STANDARD LINKAGE\n         LR    R12,R15\n         USING SLEEP,R12\n         ST    R13,SAVE+4\n         LA    R14,SAVE\n         ST    R14,8(R13)\n         LR    R13,R14\n         EJECT\n*----------------------------------------------------------------------\n*     THE FORMAT OF THE PARSED ARGUMENT LIST THIS FUNCTION RECEIVES   *\n*     IS ADDRESS/LENGTH PAIRS UNTIL TERMINATED BY A DOUBLEWORD OF     *\n*     HIGH VALUES.                                                    *\n*     DS   A      ADDRESS OF ARG N                                    *\n*     DS   F      LENGTH  OF ARG N                                    *\n*     DC   X'FFFFFFFFFFFFFFFF'                                        *\n*----------------------------------------------------------------------\n         LR    R11,R1                  ADDRESS OF EXT FUNCT PLIST\n         USING EFPL,R11\n         L     R10,EFPLARG             ADDRESS OF PARSED ARG LIST\n         L     R9,EFPLEVAL             ADDRESS OF FULLWORD PTR\n         L     R9,0(,R9)               ADDRESS OF EVALBLOCK\n         L     R2,0(,R10)              ADDRESS OF ARG(1)\n         L     R3,4(,R10)              LENGTH  OF ARG(1)\n         LA    R4,5                    MAX LENGTH OF ARGUMENT 99999      00002A\n         SR    R4,R3                   OFFSET AT WHICH TO MOVE ARG       00002E\n         LA    R5,INTERVAL             ADDRESS OF WORK AREA              000030\n         AR    R5,R4                   OFFSET IN INTERVAL FOR MOVE       000034\n         MVC   INTERVAL,=C'00000'      INIT WORKAREA                     000036\n         BCTR  R3,R0                   DECREMENT LENGTH BY 1             00003C\n         EX    R3,MOVEIT               MOVE ARGUMENT TO WORKAREA         00003E\n         ZAP   PACKAREA,=P'0'          INIT THE DECIMAL WORKAREA         000042\n         PACK  PACKAREA+5(3),INTERVAL(5)   PACK THE ARGUMENT             000048\n         SRP   PACKAREA,2,0            * 100 CONVERT TO 100THS OF SEC    00004E\n         CVB   R4,PACKAREA             CONVERT TO BINARY FOR STIMER      000054\n         N     R4,UNSIGN               REMOVE SIGN                       000058\n         ST    R4,BINSLP               SAVE TIME TO SLEEP                00005C\n         STIMER WAIT,BINTVL=BINSLP     START WAIT                        000060\n*----------------------------------------------------------------------\n*  FILL IN REQUIRED INFO IN THE EVALBLOCK BEFORE RETURNING\n*  IF LENGTH OF INPUT DATA IS GREATER THAN 125 YOU CAN CALL THE IRXRLT\n*  ROUTINE TO OBTAIN A LARGER EVALUATION BLOCK.\n*----------------------------------------------------------------------\n         L     R3,NORESULT             FIX UP RETURN PARAMETERS          000070\n         ST    R3,8(,R9)               SAVE IN EVALLEN                   000074\n         SR    R15,R15                 SET RETURN CODE = 0\nEXIT     EQU   *\n         L     R13,SAVE+4\n         RETURN (14,12),RC=(15)\nMOVEIT   MVC   0(0,R5),0(R2)           MOVE ARG TO WORKAREA              00008C\n         EJECT\nSAVE     DC    18F'0'\nNORESULT DC    X'80000000'             INDICATES NO RESULT RETURNED\nUNSIGN   DC    X'EFFFFFFF'             MASK TO TURN OFF BIT\nINTERVAL DS    CL5\nPACKAREA DS    D\nBINSLP   DS    F\n*\n         EJECT\n         LTORG\n         IRXEFPL\n         END   SLEEP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT484/CBT.V500.FILE484.PDS/ASM.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT484/CBT.V500.FILE484.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}