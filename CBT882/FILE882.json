{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013211000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE882.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE882.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x04\\t'", "DS1TRBAL": "b'.Z'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x07\\xab\\x00\\x0e\\x07\\xac\\x00\\x03\\x00\\x05'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00\\x13\\x01 \\x07/\\x01 \\x07/\\x18\\x07\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-03-12T00:00:00", "modifydate": "2020-03-12T18:07:13", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-499"}, "text": "REGULAR CBT TAPE - VERSION 499    FILE:  882\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT499.FILE882\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 8 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,553 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   03/12/20    18:07:13    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE882": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00\\x07\\x01 \\x07/\\x01 \\x07/\\x18\\x07\\x00\\x10\\x00\\x10\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-03-12T00:00:00", "modifydate": "2020-03-12T18:07:07", "lines": 16, "newlines": 16, "modlines": 0, "user": "CBT-499"}, "text": "//***FILE 882 is from Tony Thigpen and Dana Mitchell, and contains  *   FILE 882\n//*           a few programs to automate the execution of console   *   FILE 882\n//*           commands (automated shutdown, etc.).                  *   FILE 882\n//*                                                                 *   FILE 882\n//*       JOBZDOIT - A console automation program - source code     *   FILE 882\n//*                                                                 *   FILE 882\n//*       JOBZDOJ1 - Sample control cards to do a complete          *   FILE 882\n//*                  system shutdown                                *   FILE 882\n//*                                                                 *   FILE 882\n//*       MPF2REXX - MPF Installation exit to process WTO           *   FILE 882\n//*                  messages using SYSTEM REXX execs               *   FILE 882\n//*                                                                 *   FILE 882\n//*          email:  Tony Thigpen <tony@vse2pdf.com>                *   FILE 882\n//*                                                                 *   FILE 882\n//*          email:  Mitchell, Dana <mitchdana@gmail.com>           *   FILE 882\n//*                                                                 *   FILE 882\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JOBZDJC1": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00&\\x01 \\x07\\x1f\\x01 \\x07/\\x15X\\x00\\t\\x00\\x03\\x00\\x00\\xd9\\xe4\\xd5\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2020-03-11T00:00:00", "modifydate": "2020-03-12T15:58:26", "lines": 9, "newlines": 3, "modlines": 0, "user": "RUNJCL"}, "text": "//SBGOLOBJ JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*     AUTOMATE SYSTEM SHUTDOWN (THIS IS A MODEL)\n//*     THIS ILLUSTRATES THE CAPABILITY OF JOBZDOIT.\n//*\n//RUNJOBZ EXEC PGM=JOBZDOIT\n//STEPLIB DD DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//CARDS   DD DISP=SHR,DSN=SBGOLOB.CBT499.FILE882(JOBZDOJ1)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JOBZDJC2": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x14\\x01 \\x07\\x1f\\x01 \\x07/\\x15W\\x00\\r\\x00\\x03\\x00\\x00\\xd9\\xe4\\xd5\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2020-03-11T00:00:00", "modifydate": "2020-03-12T15:57:14", "lines": 13, "newlines": 3, "modlines": 0, "user": "RUNJCL"}, "text": "//SBGOLOBJ JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*   SMALL JOB TO ILLUSTRATE FUNCTIONALITY\n//*\n//RUNJOBZ EXEC PGM=JOBZDOIT\n//STEPLIB DD DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//CARDS   DD *\nASK      YES REPLY 'YES' IF YOU WANT TO RECYCLE TSSO.\nPAUSE    003\nOPCMD    C TSSO\nOPCMD    S TSSO,SUB=JES2\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JOBZDOI$": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x17\\x01\\x07\"_\\x01 \\x07/\\x15X\\x00\\x1c\\x00\\x0e\\x00\\x00\\xc1\\xe2\\xd4\\xd3\\xd1\\xc3\\xd3@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2007-08-13T00:00:00", "modifydate": "2020-03-12T15:58:17", "lines": 28, "newlines": 14, "modlines": 0, "user": "ASMLJCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT499.FILE882(JOBZDOIT)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'      (NOT RE-ENTRANT)\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   JOBZDOIT\n SETSSI  CB499882\n SETCODE AC(1)\n ENTRY   JOBZDOIT\n NAME    JOBZDOIT(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JOBZDOIT": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x08\\x01 \\x07\\x1f\\x01 \\x07\\x1f\\x018\\x02\\x07\\x02\\x07\\x00\\x00\\xe2\\xd6\\xe4\\xd9\\xc3\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-03-11T00:00:00", "modifydate": "2020-03-11T01:38:08", "lines": 519, "newlines": 519, "modlines": 0, "user": "SOURCE"}, "text": "         TITLE 'JOBZDOIT - PROCESS A PARMLIB SCRIPT'\n*\n* AUTHOR: TONY THIGPEN\n*         THIPGEN ENTERPRISES, INC.\n*         WINTER HAVEN, FL\n*         407-474-0770\n*         TONY@THIGPENS.COM\n*\n* DATE:   03/18/2018\n*\n* COPYRIGHT 2018-2020 TONY THIGPEN. ALL RIGHTS RESERVED.\n*\n* PERMISSION TO USE, COPY, MODIFY, AND DISTRIBUTE THIS SOFTWARE\n* AND ITS DOCUMENTATION FOR EDUCATIONAL, RESEARCH, AND NOT-FOR-PROFIT\n* PURPOSES, WITHOUT FEE AND WITHOUT A SIGNED LICENSING AGREEMENT,\n* IS HEREBY GRANTED, PROVIDED THAT THE ABOVE COPYRIGHT NOTICE, THIS\n* PARAGRAPH AND THE FOLLOWING TWO PARAGRAPHS APPEAR IN ALL COPIES,\n* MODIFICATIONS, AND DISTRIBUTIONS.\n*\n* IN NO EVENT SHALL TONY THIGPEN BE LIABLE TO ANY PARTY FOR DIRECT,\n* NDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING\n* LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE, AND IT'S\n* DOCUMENTATION, EVEN IF TONY THIGPEN HAS BEEN ADVISED OF THE\n* POSSIBILITY OF SUCH DAMAGE.\n*\n* TONY THIGPEN SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n* BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n* AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE AND\n* ACCOMPANYING DOCUMENTATION, IF ANY, IS PROVIDED \"AS IS\". TONY\n* THIGPEN HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,\n* ENHANCEMENTS, OR MODIFICATIONS.\n*\n* USAGE:\n*  CARD INPUT CONTAINS:\n*     1-8   ACTION:\n*             'ASK     ' PROMPT THE OPERATOR WITH THE MESSAGE IN 12-19.\n*                        IF THE ANSWER EXACTLY MATCHES 9-11, THE THE\n*                        PROGRAM WILL CONTINUE PROCESSING. ANY MIS-\n*                        MATCH OF THE ANWSER WILL CASE THE PROGRAM TO\n*                        DISCONTINUE PROCESSING OF COMMANDS.\n*             'EXIT    ' DISCONTINUE PROCESSING OF COMMANDS. USED FOR\n*                        TESTING.\n*             'OPCMD   ' ISSUE CONSOLE COMMAND IN 9-71.\n*             'OPCMD0  ' ISSUE CONSOLE COMMAND IN 9-71 FROM CONSID=0.\n*             'PAUSE   ' WAIT SECONDS SPECIFIED IN 9-11.\n*             'WAITDOWN' WAIT FOR JOB IN 12-19 TO SHUT DOWN. CHECK\n*                        ONCE EVERY N SECONDS SPECIFIED IN 9-11.\n*             'WAITUP  ' WAIT FOR JOB IN 12-19 TO BE STARTED. CHECK\n*                        ONCE EVERY N SECONDS SPECIFIED IN 9-11.\n*             'WAITVTAM' WAIT UNTIL A CONNECTION TO THE APPLID\n*                        SPECIFICED IN 12-19 CAN BE ESTABLISHED. THE\n*                        DEFAULT OF 'VTAMISUP' WILL BE USED IF SPACES.\n*                        CHECK ONCE EVER N SECONDS SPECIFIED IN 9-11.\n*    9-71  PARMS, AS DESCRIBED ABOVE.\n*\n* USAGE NOTES:\n*   ALL USE OF SECONDS IN 9-11 REQUIRE THREE NUMERICAL DIGITS. NO\n*     EDITING IS PERFORMED. INVALID DATA MAY CAUSE PROGRAM EXCEPTIONS.\n*   COMMENTS CARDS ARE ANY CARD WITH '*' IN THE FIRST POSITION.\n*\n* EXAMPLES (SHIFTED RIGHT 3 POSITIONS):\n*   THE FOLLOWING IS A PARTIAL SHUTDOWN SCRIPT\n*  ASK      YES REPLY 'YES' IF YOU WANT TO CONTINUE SHUTDOWN\n*  OPCMD    P RMM\n*  WAITDOWN 010 RMM\n*  OPCMD    Z NET,QUICK\n*  WAITDOWN 010 NET\n*  OPCMD    $T U,ALL\n*  OPCMD    $P JES2\n*  PAUSE    010\n*  OPCMD    $P JES2,QUICK\n*  PAUSE    010\n*  WAITDOWN 010 JES2\n*\n*   THE FOLLOIWNG IS A PARTIAL STARTUP SCRIPT\n*  OPCMD    S DLF,SUB=MSTR\n*  PAUSE    020 ALLOW JES2 TIME TO COME UP\n*  OPCMD    S RMM\n*  OPCMD    S DFSMSHSM\n*  PAUSE    010\n*  * THE FOLLOWING VERIFIES THAT JES2 IS UP\n*  WAITUP   010 RMM\n*  OPCMD    S NET,,,(LIST=00)\n*  PAUSE    010\n*  WAITUP   010 NET\n*  WAITVTAM 010\n*  OPCMD    S RMF.RMF,,,MEMBER(00)\n*  OPCMD    S SDSF\n*  PAUSE    010\n*  OPCMD    S TSO\n*  PAUSE    010\n*  OPCMD    S TCPIP\n*  OPCMD    S TN3270E\n*  PAUSE    020\n*  ASK      YES REPLY 'YES' TO START DATABASES\n*  OPCMD    S ADAPROD\n*  PAUSE    020\n*  OPCMD    S ADATEST\n*  PAUSE    020\n*  ASK      YES REPLY 'YES' TO START CICS'S\n*  OPCMD    S CICSP\n*  PAUSE    020\n*  OPCMD    S CICSD\n*  WAITUP   010 CICSP\n*  WAITUP   010 CICSD\n*\n*   THE FOLLOWING ARE EXAMPLE PROCS:\n*     'SYS1.PROCLIB(SHUTDOWN)'\n*  //SHUTHKYP PROC MEM='JOBZIPLD'\n*  //COMAND00 EXEC PGM=JOBZDOIT,REGION=3000K,TIME=50\n*  //CARDS    DD   DSN=SYS1.PARMLIB(&MEM),DISP=SHR\n*  //\n*\n*   TO SHUTDOWN USING THE ABOVE SCRIPT, THE OPERATOR ISSUES:\n*\n*  S SHUTDOWN,SUB=MSTR\n*\n*     'SYS1.PROCLIB(STARTUP)'\n*  //STRTHKYP PROC MEM='JOBZIPLU'\n*  //COMAND00 EXEC PGM=JOBZDOIT,REGION=3000K,TIME=50\n*  //CARDS    DD   DSN=SYS1.PARMLIB(&MEM),DISP=SHR\n*  //\n*\n*   TO SHUTDOWN USING THE ABOVE SCRIPT, PLACE IN COMMMD00:\n*  COM='START STRTHKYP,SUB=MSTR'\n*\n*   JOBZDOIT CAN ALSO BE USED IN NORMAL JOBS:\n*  //COMAND00 EXEC PGM=JOBZDOIT,REGION=3000K,TIME=50\n*  //CARDS    DD   *\n*  OPCMD0   V 084,CONSOLE\n*  //\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nJOBZDOIT CSECT\nJOBZDOIT AMODE 24\nJOBZDOIT RMODE 24\n         STM   R14,R12,12(R13)    SAVE REGISTERS\n         LR    R12,R15            LOAD MY BASE REGISTER\n         USING JOBZDOIT,R12\n         L     R0,=A(WORKLL)      LENGTH OF WORK AREA\n         GETMAIN RU,LV=(0),LOC=BELOW\n         ST    R13,4(R1)          SAVE BACK CHAIN\n         ST    R1,8(R13)          SAVE FORWARD CHAIN\n         L     R1,24(R13)         RESTORE REG1\n         L     R13,8(R13)         POINT TO MY SAVE AREA\n         USING WORKAREA,R13\nGETMYNAME DS   0H\n         L     R10,X'021C'         CURRENT TCB\n         L     R10,12(,R10)         POINT TO TIOT\n         MVC   MYJOB,0(R10)        POPULATE JOB-NUMBER\n         OPEN  (CARD,INPUT)\nREADIT   DS    0H\n         GET   CARD,INCARD\n         CLI   ACTION,C'*'\n         BE    READIT\n         CLC   ACTION,=CL8'ASK     '\n         BE    ASK_\n         MVC   WS_WTOAREA,CMD_WTO\n         MVC   WS_WTOAREA+4(8),MYJOB\n         MVC   WS_WTOAREA+17(L'INCARD),INCARD\n         WTO   MF=(E,WS_WTOAREA)\n         CLC   ACTION,=CL8'OPCMD   '\n         BE    OPCMD_\n         CLC   ACTION,=CL8'OPCMD0  '\n         BE    OPCMD0_\n         CLC   ACTION,=CL8'PAUSE   '\n         BE    PAUSE_\n         CLC   ACTION,=CL8'WAITDOWN'\n         BE    WAITDOWN_\n         CLC   ACTION,=CL8'WAITUP  '\n         BE    WAITUP_\n         CLC   ACTION,=CL8'WAITVTAM'\n         BE    WAITVTAM_\n         CLC   ACTION,=CL8'EXIT    '\n         BE    EXIT_\n         MVC   WS_WTOAREA,CMD_BAD\n         MVC   WS_WTOAREA+4(8),MYJOB\n         WTO   MF=(E,WS_WTOAREA)\n         B     READIT\n\nOPCMD_   DS    0H\n         MVC   CONCMD,COMMAND\n         LA    R1,L'CONCMD\n         STH   R1,CONCMDL\n         LA    R1,0\n         STH   R1,CONCMDL0\n         MVC   CONCMDL0,CONCMDL\n         LA    R2,CONCMDL0\n         MODESET MODE=SUP,KEY=ZERO\n         LA    R1,CONCMDS\n         SR    R0,R0              CLEAR FOR SVC 34\n         SVC   34                 ISSUE THE COMMAND\n         MODESET MODE=PROB,KEY=NZERO\nOC_EXIT  DS    0H\n         B     READIT\n\nOPCMD0_  DS    0H\n         MVC   CONCMD,COMMAND\n         LA    R1,L'CONCMD\n         STH   R1,CONCMDL\n         LA    R1,0\n         STH   R1,CONCMDL0\n         MVC   CONCMDL0,CONCMDL\n         LA    R2,CONCMDL0\n         MVC   WS_MGAREA,C0_MGCRE\n         MODESET MODE=SUP,KEY=ZERO\n         MGCRE MF=(E,WS_MGAREA),TEXT=(R2),CONSID=ZERO\n         MODESET MODE=PROB,KEY=NZERO\nOC0_EXIT DS    0H\n         B     READIT\n\nPAUSE_   DS    0H\n         CLC   SECONDS,SPACES\n         BNE   PA_WAIT\n         MVC   SECONDS,=C'010'\nPA_WAIT  DS    0H\n         MVC   SECS_Z,=C'000XXX00' ALSO ADDS SUBSECS AS ZEROS\n         MVC   SECS_Z+3(3),SECONDS\n         PACK  SECS_P,SECS_Z\n         CVB   R1,SECS_P\n         ST    R1,SECS_B\n         STIMER WAIT,BINTVL=SECS_B\nPA_EXIT  DS    0H\n         B     READIT\n\n\nWAITDOWN_ DS   0H\n         CLC   SECONDS,SPACES\n         BNE   WD_SCAN\n         MVC   SECONDS,=C'010'\nWD_SCAN  DS    0H\n*******************************************************************\n* POINT TO ASVT\n*******************************************************************\n         L     R2,CVTPTR          POINT TO CVT  - X'10'\n         USING CVT,R2             MAP CVT\n         L     R2,CVTASVT         POINT TO ASVT\n         DROP  R2                 TELL ASMBLR TO STOP USING R2 FOR CVT\n         USING ASVT,R2            MAP ASVT\n         LA    R4,ASVTENTY        POINT TO FIRST ENTRY IN TABLE\n         L     R3,ASVTMAXU        LOAD MAX NUMBER OF ENTRIES\n*******************************************************************\n* THIS ROUTINE CHECKS EACH ASVT ENTRY.\n* IF THE HIGH ORDER BIT IS ON, THE ENTRY IS THE ADDRESS OF THE\n* NEXT AVAILABLE ASID (OR THE LAST ENTRY IF ZEROS).\n* IF THE HIGH ORDER BIT IS NOT ON, THE ENTRY IS THE ADDRESS\n* OF THE ASCB FOR THAT ENTRY.\n*******************************************************************\nWD_LOOP  TM    0(R4),ASVTAVAL     IS THIS AN ASCB ADDRESS ?\n         BO    WD_NEXT\n*******************************************************************\n* WE HAVE A VALID ASCB ADDRESS - CHECK IT\n*******************************************************************\nWD_ASCB  DS    0H\n         L     R10,0(R4)          POINT TO ASCB\n         USING ASCB,R10           MAP IT\n         L     R5,ASCBJBNI        POINT TO JOBNAME\n         CL    R5,=F'0'           WAS THIS A START/MOUNT/LOGON ?\n         BE    WD_STC             YES, BRANCH\n         CLC   JOBNAME,0(R5)      IS IT THE ASCB OF JOB ON THE PARM?\n         BE    WD_UP              YES, BRANCH\n         B     WD_NEXT\nWD_STC   DS    0H\n         L     R5,ASCBJBNS        POINT TO START/MOUNT/LOGON NAME\n         CLC   JOBNAME,0(R5)      IS IT THE ASCB OF JOB ON THE PARM?\n         BE    WD_UP              YES, BRANCH\nWD_NEXT  DS    0H\n         LA    R4,4(,R4)          NO, POINT TO NEXT ENTRY IN ASVT\n         BCT   R3,WD_LOOP         GO CHECK NEXT ASVT ENTRY\n         DROP  R10\nWD_DOWN  DS    0H\n         MVC   WS_WTOAREA,WD_WTO1\n         MVC   WS_WTOAREA+4(8),MYJOB\n         MVC   WS_WTOAREA+17(8),JOBNAME\n         WTO   MF=(E,WS_WTOAREA)\n         B     WD_EXIT\nWD_UP    DS    0H\n         MVC   WS_WTOAREA,WD_WTO2\n         MVC   WS_WTOAREA+4(8),MYJOB\n         MVC   WS_WTOAREA+25(8),JOBNAME\n         WTO   MF=(E,WS_WTOAREA)\n         MVC   SECS_Z,=C'000XXX00' ALSO ADDS SUBSECS AS ZEROS\n         MVC   SECS_Z+3(3),SECONDS\n         PACK  SECS_P,SECS_Z\n         CVB   R1,SECS_P\n         ST    R1,SECS_B\n         STIMER WAIT,BINTVL=SECS_B\n         B     WD_SCAN\nWD_EXIT  DS    0H\n         B     READIT\n\n\nWAITUP_  DS    0H\n         CLC   SECONDS,SPACES\n         BNE   WU_SCAN\n         MVC   SECONDS,=C'010'\nWU_SCAN  DS    0H\n*******************************************************************\n* POINT TO ASVT\n*******************************************************************\n         L     R2,CVTPTR          POINT TO CVT  - X'10'\n         USING CVT,R2             MAP CVT\n         L     R2,CVTASVT         POINT TO ASVT\n         DROP  R2                 TELL ASMBLR TO STOP USING R2 FOR CVT\n         USING ASVT,R2            MAP ASVT\n         LA    R4,ASVTENTY        POINT TO FIRST ENTRY IN TABLE\n         L     R3,ASVTMAXU        LOAD MAX NUMBER OF ENTRIES\n*******************************************************************\n* THIS ROUTINE CHECKS EACH ASVT ENTRY.\n* IF THE HIGH ORDER BIT IS ON, THE ENTRY IS THE ADDRESS OF THE\n* NEXT AVAILABLE ASID (OR THE LAST ENTRY IF ZEROS).\n* IF THE HIGH ORDER BIT IS NOT ON, THE ENTRY IS THE ADDRESS\n* OF THE ASCB FOR THAT ENTRY.\n*******************************************************************\nWU_LOOP  TM    0(R4),ASVTAVAL     IS THIS AN ASCB ADDRESS ?\n         BO    WU_NEXT\n*******************************************************************\n* WE HAVE A VALID ASCB ADDRESS - CHECK IT\n*******************************************************************\nWU_ASCB  DS    0H\n         L     R10,0(R4)          POINT TO ASCB\n         USING ASCB,R10           MAP IT\n         L     R5,ASCBJBNI        POINT TO JOBNAME\n         CL    R5,=F'0'           WAS THIS A START/MOUNT/LOGON ?\n         BE    WU_STC             YES, BRANCH\n         CLC   JOBNAME,0(R5)      IS IT THE ASCB OF JOB ON THE PARM?\n         BE    WU_UP              YES, BRANCH\n         B     WU_NEXT\nWU_STC   DS    0H\n         L     R5,ASCBJBNS        POINT TO START/MOUNT/LOGON NAME\n         CLC   JOBNAME,0(R5)      IS IT THE ASCB OF JOB ON THE PARM?\n         BE    WU_UP              YES, BRANCH\nWU_NEXT  DS    0H\n         LA    R4,4(,R4)          NO, POINT TO NEXT ENTRY IN ASVT\n         BCT   R3,WU_LOOP         GO CHECK NEXT ASVT ENTRY\n         DROP  R10\nWU_DOWN  DS    0H\n         MVC   WS_WTOAREA,WU_WTO2\n         MVC   WS_WTOAREA+4(8),MYJOB\n         MVC   WS_WTOAREA+25(8),JOBNAME\n         WTO   MF=(E,WS_WTOAREA)\n         MVC   SECS_Z,=C'000XXX00' ALSO ADDS SUBSECS AS ZEROS\n         MVC   SECS_Z+3(3),SECONDS\n         PACK  SECS_P,SECS_Z\n         CVB   R1,SECS_P\n         ST    R1,SECS_B\n         STIMER WAIT,BINTVL=SECS_B\n         B     WU_SCAN\nWU_UP    DS    0H\n         MVC   WS_WTOAREA,WU_WTO1\n         MVC   WS_WTOAREA+4(8),MYJOB\n         MVC   WS_WTOAREA+17(8),JOBNAME\n         WTO   MF=(E,WS_WTOAREA)\n         B     WU_EXIT\nWU_EXIT  DS    0H\n         B     READIT\n\n\nWAITVTAM_ DS   0H\n         CLC   SECONDS,SPACES\n         BNE   WV_ACBNAME\n         MVC   SECONDS,=C'010'\nWV_ACBNAME DS  0H\n         MVI   ACBLANE_L,X'08'         ACBNAME LENGTH\n         MVC   ACBNAME(8),=CL8'VTAMISUP'\n         CLI   JOBNAME,C' '\n         BE    WV_GENCB\n         MVC   ACBNAME(8),JOBNAME      ALLOW OVERRIDE ACBNAME\nWV_GENCB DS    0H\n         LA    R2,VTAMACB\n         LA    R3,APPLID\n         GENCB BLK=ACB,AM=VTAM,APPLID=((R3)),MACRF=NLOGON,             X\n               WAREA=((R2)),LENGTH=VTAMACB_L\n         LTR   15,15\n         BZ    WV_SCAN\n         ABEND 001,DUMP\nWV_SCAN  DS    0H\n         LA    R2,VTAMACB\n         OPEN  ((2))\n         LTR   R15,R15\n         BZ    WV_UP\n         B     WV_DOWN\nWV_UP    DS    0H\n         LA    R2,VTAMACB\n         CLOSE ((2))\n         MVC   WS_WTOAREA,WU_WTO3\n         MVC   WS_WTOAREA+4(8),MYJOB\n         WTO   MF=(E,WS_WTOAREA)\n         B     WV_EXIT\nWV_DOWN  DS    0H\n         MVC   WS_WTOAREA,WD_WTO3\n         MVC   WS_WTOAREA+4(8),MYJOB\n         WTO   MF=(E,WS_WTOAREA)\n         MVC   SECS_Z,=C'000XXX00' ALSO ADDS SUBSECS AS ZEROS\n         MVC   SECS_Z+3(3),SECONDS\n         PACK  SECS_P,SECS_Z\n         CVB   R1,SECS_P\n         ST    R1,SECS_B\n         STIMER WAIT,BINTVL=SECS_B\n         B     WV_SCAN\nWV_EXIT  DS    0H\n         B     READIT\n\n\nASK_     DS    0H\n         MVC   WS_WTOAREA,ASK_WTOR\n         MVC   WS_WTOAREA+12(8),MYJOB\n         MVC   WS_WTOAREA+21(L'PROMPT),PROMPT\n         XC    ASK_ECB,ASK_ECB\n         LA    R2,ASK_RPLY\n         LA    R3,ASK_ECB\n         WTOR  ,(R2),,(R3),MF=(E,WS_WTOAREA)\n         WAIT  ECB=(R3)\n         OC    ASK_RPLY,SPACES\n         CLC   ANSWER,ASK_RPLY\n         BNE   EXIT_\nASK_EXIT DS    0H\n         B     READIT\n\nEXIT_    DS    0H\n\nEODINPUT DS    0H\n         CLOSE CARD\n         L     R13,4(R13)         RESTORE REG13 (CALLER'S AREA)\n         L     R1,8(R13)          MY SAVE AREA\n         L     R0,=A(WORKLL)      SET LENGTH\n         FREEMAIN RU,LV=(0),A=(1)\n         LM    R14,R12,12(R13)    RESTORE CALLER'S REGS\n         LA    R15,0\n         BR    R14                RETURN TO CALLER\n         DS    0F\nCARD     DCB   DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=32000,DDNAME=CARDS,  X\n               MACRF=(GM),EODAD=EODINPUT\n\nZERO     DC    A(0)\nSPACES   DC    CL80' '\nCMD_WTO  WTO   'JOBZDOIT CMD=                                        ',X\n               MF=L\nCMD_BAD  WTO   'JOBZDOIT INVALID REQUEST                             ',X\n               MF=L\nWD_WTO1  WTO   'JOBZDOIT JOB XXXXXXXX IS DOWN                        ',X\n               MF=L\nWD_WTO2  WTO   'JOBZDOIT WAITING FOR XXXXXXXX TO SHUTDOWN            ',X\n               MF=L\nWD_WTO3  WTO   'JOBZDOIT WAITING FOR VTAM TO START UP                ',X\n               MF=L\nWU_WTO1  WTO   'JOBZDOIT JOB XXXXXXXX IS UP                          ',X\n               MF=L\nWU_WTO2  WTO   'JOBZDOIT WAITING FOR XXXXXXXX TO START UP            ',X\n               MF=L\nWU_WTO3  WTO   'JOBZDOIT VTAM IS UP                                  ',X\n               MF=L\nASK_WTOR WTOR  'JOBZDOIT                                               X\n                           ',                                          X\n               0,3,0,ROUTCDE=(2),MF=L\nC0_MGCRE MGCRE MF=L\n         LTORG\n\nWORKAREA DSECT\nSAVEAREA DS    CL72\n\nMYJOB    DS    CL8\n*\nINCARDL  DC    Y(80)\nINCARD   DS    CL80\n         ORG   INCARD\nACTION   DS    CL8\n         DS    CL1\nCOMMAND  DS    0CL(72-(*-INCARD))\nANSWER   DS    0CL3\nSECONDS  DS    CL3\n         DS    CL1\nPROMPT   DS    0CL(72-(*-INCARD))\nJOBNAME  DS    CL8\n         ORG\nBLOCKER  DS    C' '\n         DS    0F\nCONCMDS  DS    0F\nCONCMDL  DS    H\nCONCMDL0 DS    H\nCONCMD   DS    CL(L'COMMAND)\n         DS    0F\nSECS_Z   DS    CL8\nSECS_P   DS    CL8\nSECS_B   DS    CL4\n\nAPPLID   DS    0XL9\nACBLANE_L DC   XL1'08'\nACBNAME  DC    CL8'VTAMISUP'    VTAM ACB NAME\nVTAMACB  ACB   AM=VTAM,APPLID=APPLID,MACRF=NLOGON\nVTAMACB_L EQU  *-VTAMACB\n\nASK_ECB  DC    F'0'\nASK_RPLY DS    CL3\n         DS    0F\nWS_WTOAREA DS  CL200\n         DS    0F\nWS_MGAREA DS   CL200\n*\nWORKLL   EQU   *-WORKAREA\n         CVT DSECT=YES\n         IHAASVT\n         IHAASCB\n         END   JOBZDOIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JOBZDOJ1": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01 \\x07\\x1f\\x01 \\x07\\x1f\\x01%\\x00m\\x00m\\x00\\x00\\xc3\\xe3\\xd3\\xc3\\xd9\\xc4\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-03-11T00:00:00", "modifydate": "2020-03-11T01:25:09", "lines": 109, "newlines": 109, "modlines": 0, "user": "CTLCRDS"}, "text": "ASK      YES REPLY 'YES' IF YOU WANT TO CONTINUE SHUTDOWN\n* ? IS PREFIX FOR TSSO\nOPCMD    ?.RELOAD HUP1DN\nPAUSE    010\nOPCMD    F JQP,STATS\nOPCMD    P FFST\nOPCMD    VARY NET,INACT,ID=VDR,FORCE\nOPCMD    MODIFY DLF,MODE=QUIESCE\nOPCMD    P ENF\nOPCMD    $PI\nPAUSE    010\nOPCMD    D OMVS,A=ALL\nOPCMD    D OMVS,U=OMVSKERN\nPAUSE    010\nOPCMD    F OMVS,PPFS=ZFS\nOPCMD    $PLOGON1\nPAUSE    010\nOPCMD    F BPXOINIT,SHUTDOWN=FORKS\nPAUSE    010\nOPCMD    F BPXOINIT,SHUTDOWN=FORKINIT\nPAUSE    010\nOPCMD0   F CICSPTE2,CESN USERID=OPERACS,PS=XXXXXXXX\nOPCMD0   F CICSPTE2,CEMT P SHUT\nWAITDOWN 030 CICSPTE2\nOPCMD    P CNDLINIT\nOPCMD    /DBR DB ALL\nOPCMD    #DBR DB ALL\nPAUSE    015\n* / IS PREFIX FOR IMS PROD\nOPCMD    /CHE FREEZE\n* # IS PREFIX FOR IMS DEVP\nOPCMD    #CHE FREEZE\nWAITDOWN 010 DBCPDBRC\nWAITDOWN 010 DBCPDLI\nWAITDOWN 010 DBCPBC\nWAITDOWN 010 DBCTDBRC\nWAITDOWN 010 DBCTDLI\nWAITDOWN 010 DBCTBC\nOPCMD    P RMM\nOPCMD    P DFSMSHSM\nOPCMD    P DSSUMON\nOPCMD    P JCLARCHP\nPAUSE    010\nOPCMD    P JCLARCH\nOPCMD    MODIFY JQP,SHUT\nOPCMD    P LLA\nOPCMD    %P\nOPCMD    MODIFY RMF,P III\nOPCMD    P SDSF\nPAUSE    010\nOPCMD    P LPSERVE\nOPCMD    P FTPD\nOPCMD    F ESF,PNET\nOPCMD    F ESF,SHUTDOWN\nOPCMD    P TSO\nOPCMD    P DLF\nOPCMD    P VLF\nOPCMD    P RMF\nPAUSE    010\nOPCMD    $P I\nOPCMD    $P LINE(1-10)\nOPCMD    C APPC\nPAUSE    010\nOPCMD    C LPSERVE\nOPCMD    C FTPD\nPAUSE    010\nOPCMD    %STOP\nPAUSE    010\nOPCMD    $E LINE(1-10)\nWAITDOWN 010 APPC\nWAITDOWN 010 CNDLINIT\nWAITDOWN 010 DBCPDBC\nWAITDOWN 010 DBCPDBRC\nWAITDOWN 010 DBCPDLI\nWAITDOWN 010 DBCTDBC\nWAITDOWN 010 DBCTDBRC\nWAITDOWN 010 DBCTDLI\nWAITDOWN 010 DFSMSHSM\nWAITDOWN 010 DLF\nWAITDOWN 010 DSSUMON\nWAITDOWN 010 ENF\nWAITDOWN 010 EPWFFST\nWAITDOWN 010 ESF\nWAITDOWN 010 FTPD\nWAITDOWN 010 JCLARCH\nWAITDOWN 010 JCLARCHP\nWAITDOWN 010 LLA\nWAITDOWN 010 LPSERVE\nWAITDOWN 010 RACF\nWAITDOWN 010 RMF\nWAITDOWN 010 RMFGAT\nWAITDOWN 010 RMM\nWAITDOWN 010 SDSF\nWAITDOWN 010 TCPIP\nWAITDOWN 010 TSO\nWAITDOWN 010 VDR\nWAITDOWN 010 VLF\nOPCMD    D A,L\n* ? IS PREFIX FOR TSSO\nOPCMD    ?.P\nOPCMD    Z NET,QUICK\nWAITDOWN 010 TSSO\nWAITDOWN 010 NET\nOPCMD    $T U,ALL\nOPCMD    $P JES2\nPAUSE    010\nOPCMD    $P JES2,QUICK\nPAUSE    010\nWAITDOWN 010 JES2\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MPF2REXX": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x007\\x01 \\x07/\\x01 \\x07/\\x16!\\x03O\\x03O\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2020-03-12T00:00:00", "modifydate": "2020-03-12T16:21:37", "lines": 847, "newlines": 847, "modlines": 0, "user": "SBGOLOB"}, "text": "//MPF2REXX JOB (JOB,JOB),'XXXXXXXXXXXXXXXXXX',CLASS=Z,COND=(8,LT),\n//         MSGCLASS=M,REGION=3M\n//ASM      EXEC PGM=ASMA90,PARM='XREF,NODECK,OBJECT'\n//* SLIB   DD DSN=THRD.MVSPUB.FILE332.PDS,DISP=SHR\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=SYSSQ,SPACE=(1700,(600,100))\n//SYSUT2   DD DSN=&&SYSUT2,UNIT=SYSSQ,SPACE=(1700,(300,50))\n//SYSUT3   DD DSN=&&SYSUT3,UNIT=SYSSQ,SPACE=(1700,(300,50))\n//SYSPRINT DD SYSOUT=*\n//*YSPRINT DD SYSOUT=(P,,1PN),FCB=1PW,COPIES=1,\n//*      DCB=(RECFM=FM),FREE=CLOSE\n//SYSLIN   DD DSN=&&OBJLIB(MPF2REXX),DISP=(MOD,PASS),\n//            UNIT=SYSSQ,SPACE=(400,(800,400,10),,,ROUND),\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=880,DSORG=PO)\n//SYSIN    DD *\nMPF2REXX TITLE '- MPF exit to call SYSTEM REXX'\n         PRINT GEN\n***********************************************************************\n*                                                                     *\n* Name: MPF2REXX                                                      *\n*                                                                     *\n*      Author: Dana Mitchell      email:  mitchdana@gmail.com         *\n*                                                                     *\n* Description: MPF Installation exit to process WTO                   *\n*              messages using SYSTEM REXX execs                       *\n*                                                                     *\n*   Operation: Call a SYSTEM REXX EXEC when the specfied message      *\n*              is issued.  The default name of the SYSREXX to be      *\n*              called is the message identifier.  If an alternate     *\n*              REXX is to be called, specify AUTO(rexxname) on the    *\n*              MPFLSTxx statement.                                    *\n*                                                                     *\n*              Sample MPFLSTxx statements:                            *\n*                                                                     *\n*              msgid,USEREXIT(MPF2REXX)                               *\n*                                                                     *\n*                    When <msgid> message is issued,  call a System   *\n*                    Rexx with the name of <msgid>.                   *\n*                                                                     *\n*              msgid,USEREXIT(MPF2REXX),AUTO(altrexx)                 *\n*                                                                     *\n*                    When <msgid> message is issued,  call a System   *\n*                    Rexx with the name of <altrexx>.                 *\n*                                                                     *\n*       Input: R1->  Address of CTXT                                  *\n*              R13-> Standard save area                               *\n*              R14-> Return address                                   *\n*              R15-> Entry point                                      *\n*                                                                     *\n*   Regs used: R2 R6 and R7 work                                      *\n*              R3  Ptr to WORKDS   workarea                           *\n*              R4  Ptr to CTXTATTR                                    *\n*              R5  Ptr to CTXT                                        *\n*              R12 Base                                               *\n*              R13 Register save area                                 *\n*              R14 Return address                                     *\n*                                                                     *\n* Fields passed to REXX exec:                                         *\n*                                                                     *\n*              MPF2REXXJOB     Job name of issuer                     *\n*              MPF2REXXJID     Job ID of issuer            @DM11032010*\n*              MPF2REXXSYS     System name where message originated   *\n*              MPF2REXXMSG.0   Number of lines returned               *\n*              MPF2REXXMSG.x   Where x= 1-20 lines of WTO text        *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n* Change Log                                                          *\n* ------------------------------------------------------------------- *\n* Mitchell  9/22/2010 Initial coding                                  *\n*                                                                     *\n* Mitchell 10/22/2010 Insert test for valid System Rexx environment.  *\n*  AXREXX macro fails w/RC 0000000C  RSN 041E0C0F if the AS issuing   *\n*  the message is not valid for creation of a dependant enclave.      *\n*  Check for  OUCBIac>0                                               *\n*                                                                     *\n* Mitchell @DM11032010 Add CTXTOJBID field passed to REXX             *\n* Mitchell @DM11112010 Set actual length of MPF2REXXJOB and 'SYS      *\n*                      fields.                                        *\n* TONY THIGPEN - FIXED 'MESSAGE' LESS THAN 7 CHARACTERS               *\n*                                                                     *\n***********************************************************************\nMPF2REXX CSECT\nMPF2REXX AMODE 31                      31-BIT ADDRESSING MODE\nMPF2REXX RMODE ANY                     31-BIT RESIDENCE\n\n* Registers\n\nR0       EQU   0\nR1       EQU   1             TRT\nR2       EQU   2             TRT\nR3       EQU   3             Work area (dynamic storage)\nR4       EQU   4             CTXTATTR\nR5       EQU   5             CTXT\nR6       EQU   6             Work\nR7       EQU   7             Work\nR8       EQU   8             Work for REXX areas\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12            BASE\nR13      EQU   13            Save area\nR14      EQU   14\nR15      EQU   15\n\n* Setup Entry Linkage\n\n         USING *,R12                    Tell assembler\n         BAKR  R14,0                    Save regs\n         LAE   R12,0(,R15)              Load base\n         B     Begin                    Branch around eyecatchers\n         DC    C'MPF2REXX '\n         DC    C'&SYSDATE &SYSTIME '\nBegin    DS    0H\n         L     R5,0(R1)                 Get poitner to CTXT\n         USING CTXT,R5                  use R5\n\n         TM    CTXTSFB4,CTXTCIDA        Is this termination call?\n         BO    Return                   Yes-> return\n\n* Determine type of call\n\n         L     R4,CTXTTXPN              Load pointer to minor line\n         LTR   R4,R4                    Is there a minor line?\n         BNZ   MinorLine                Yes-> Go process minor line\n\n* Check for valid environment                               @DM10222010\n\n         B     EnvOK          **** Don't check Environment ****\n\n         USING PSA,R0              Point to PSA             @DM10222010\n         L     R6,PSAAOLD          Point to Current ASCB    @DM10222010\n         USING ASCB,R6             Use pointer to ASCB      @DM10222010\n         L     R6,ASCBOUCB         Point to OUCB            @DM10222010\n         Drop  R6                  Reg is now pointing to OU@DM10222010\n         USING OUCB,R6             Tell assembler           @DM10222010\n         CLI   OUCBIAC,x'00'       Is OUCBIAC>0?            @DM10222010\n         BH    EnvOK               Yes-> Continue           @DM10222010\n         WTO   'MPF2REXX Invalid environment for System REXX'\n         B     Return                                       @DM10222010\n         Drop  R6                                           @DM10222010\n\n* Getmain workarea\n\nEnvOK    DS    0H                                           @DM10222010\n         GETMAIN RU,LV=WORKLEN,SP=230,LOC=(BELOW,ANY)\n         LTR   R15,R15             Getmain OK?\n         BZ    GM1OK               Yes-> continue\n         WTO   'MPF2REXX Getmain Error'\n         B     Return              Bye\n\nGM1OK    DS    0H\n         LR    R3,R1               Get address of storage\n         USING WORKDS,R3           Tell assembler\n         LA    R13,SAVEAREA        Point to save area\n         MVC   SAVEAREA+4,=C'F1SA' Mark stack in use\n\n* Save various fixed fields from the message header\n\n         MVC   NumMin,=F'1'        Set beginning number of lines\n         L     R4,CTXTTXPJ         Load address of ptr to text\n         USING CTXTATTR,R4         Use this for the base\n         MVC   VARTMSG,CTXTTMSG    Move in message text\n         MVC   VARTLEN,CTXTTLEN    Get Length of message text\n         MVC   VARJBNM,CTXTJBNM    Move in JOB name\n         MVC   VARJBID,CTXTOJBID   Move in JOB ID           @DM11032010\n         MVC   VARSYSN,CTXTSYSN    Move in system name\n\n* Get name of exec\n\n         MVC   EXECNAME(8),CTXTTMSG  Move in first 8 chars of text\n         MVI   EXECEOF,C' '          SET STOPPER BYTE         TT 021518\n         LA    R1,EXECNAME-1         CLEAN NAME BECAUSE IT    TT 120817\nCLEANIT  DS    0H                      . MAY BE SHORT AND     TT 120817\n         LA    R1,1(,R1)               . ANOTHER PARM STARTS  TT 120817\n         CLI   0(R1),C' '              . WITHIN THE 8 CHARS   TT 120817\n         BNE   CLEANIT                 .                      TT 120817\n         MVC   0(8,R1),=CL8'        '  .                      TT 120817\n         CLC   CTXTAUTT,=CL8' '      Is any token specified?\n         BNH   Defname               No-> use name from message text\n         MVC   EXECNAME,CTXTAUTT     Move in name from auto token\nDefname  DS    0H\n\n* Determine type of line\n\n         TM    CTXTTFB1,CTXTTFMJ   Is this a MLWTO?\n         BZ    BuildRexx           No-> go build SYSREXX call\n         TM    CTXTTFB1,CTXTTFME   Is this the last line?\n         BO    BuildRexx           Yes-> go build SYSREXX call\n\n* Chain workarea\n\n         MVC   Seqno,CTXTSEQN      Save sequence number of this MSG\n         L     R15,CTXTIWKP        Point to exit work area\n\nAddWork  DS    0h\n\n         XR    R1,R1               Clear work reg\n         CS    R1,R3,0(R15)        Add pointer to chain OK?\n         BE    ReqMinors           Yes-> go get more minors\n         LR    R15,R1              No-> point to next minor block\n         B     AddWork             Go try adding the next block\n\nReqMinors DS   0H\n\n         OI    CTXTRFB1,CTXTRPML   Request more minors if available\n         B     Return              Go back\n\n* Process Minor Line\n\nMinorLine DS    0H\n\n         NI    CTXTRFB1,255-CTXTRPML Turn off request bit\n         L     R3,CTXTIWKP          Get pointer to exit work area\n\nTryNext  DS    0H\n\n         L     R3,0(R3)             Get pointer to first/next work area\n         LTR   R3,R3                Is there a work area exist?\n         BNZ   WorkOK               Yes-> See if its the right one\n         WTO   'MPF2REXX No workarea found for minor'\n         B     Return               Go Back\n\nWorkOK   Ds    0H\n\n         CLC   Seqno,CTXTSEQN       Is this the right one?\n         Bne   TryNext              No-> try the next one\n\n* Store message line in work area\n\n         LA    R6,VARTMSG           Point to line array\n         L     R8,NumMin            Get number of minor lines\n         CH    R8,=H'20'            Max minor lines reached?\n         BNL   MinFull              Yes-> Dont add to buffer\n         MH    R8,=AL2(L'CTXTTMSG)  Find index into table\n         AR    R6,R8                Point to next entry\n         MVC   0(L'CTXTTMSG,R6),CTXTTMSG  Move in message text\n         L     R8,NumMin            Get number of minor lines\n         SLA   R8,1                 Multiply by 2\n         LA    R6,VARTLEN(R8)       Point to length entry\n         MVC   0(2,R6),CTXTTLEN     Save length of message\n         L     R8,NumMin            Get number of minor lines\n         LA    R8,1(,R8)            Increment number of minors\n         ST    R8,NumMin            Store number of minors\n\n         TM    CTXTTFB1,CTXTTFME    Is this the END line?\n         BZ    ReqMinors            No-> Go get more\n\nMinFull  DS    0H\n* Remove workarea from chain\n\n         L     R1,CTXTIWKP          Point to exit workarea\n\nRemWork  DS    0H\n\n         LR    R15,R3               Point to our workarea\n         L     R14,NextWrk          Load pointer to next one\n         CS    R15,R14,0(R1)        Try Removing chain\n         BE    BuildRexx            Yes-> Go build REXX request\n         LR    R1,R15               No-> Point to next one\n         B     RemWork              Go try to remove it\n\n* Begin building SYSTEM REXX call areas\n\nBuildRexx DS   0H\n\n         XC    RxVarLst,RxVarLst    Clear the VarLst header\n         LA    R8,RxVarLst\n\n* Build headers\n\n         USING AxrArgLst,R8\n         MVC   AxrArgLstId,=A(AxrVarLstAcro) Set it to varible type\n         MVC   AxrArgLstVer,=A(AxrArgLstCurVer) Set it to version\n         L     R6,NumMin           Get number of wto lines\n         LA    R6,ExtraFields(,R6) Add more fields to count\n         STH   R6,AxrArgLstNumber  Store the number of variables\n         DROP  R8\n\n* Prepare variable entries\n\n        LA     R8,RxVarEnt          Point to first entry\n        USING  AxrArgEntry,R8\n\n* Job name\n\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R6,jbnmName          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'jbnmName\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n         LA    R6,L'VARJBNM         Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n         LA    R6,VARJBNM           Get address of Job name\n         ST    R6,AXRARGADDRLOW     Store address in arglist\n         TRT   VARJBNM,TRTTAB       Find length of JOB name @DM11112010\n         BZ    DefJOB               Job name is default leng@DM11112010\n         SR    R1,R6                Calculate length        @DM11112010\n         ST    R1,AxrArgLength      Store length            @DM11112010\nDefJOB   DS    0H                                           @DM11112010\n\n* Job ID\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R6,VARJBID           Get address of Job ID\n         ST    R6,AXRARGADDRLOW     Store address in arglist\n         LA    R6,jbidName          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'jbidName\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n         LA    R6,L'VARJBID         Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* System name\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R6,sysnName          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'sysnName store length of name\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n         LA    R6,L'VARSYSN         Plug in default length\n         ST    R6,AxrArgLength      Store length in var entry\n         LA    R6,VARSYSN           Get address of System name\n         ST    R6,AXRARGADDRLOW     Store address in arglist\n         TRT   VARSYSN,TRTTAB       Find length of System na@DM11112010\n         BZ    DefSYS               Default length          @DM11112010\n         SR    R1,R6                Calculate length        @DM11112010\n         ST    R1,AxrArgLength      Store length            @DM11112010\nDefSYS   DS    0H                                           @DM11112010\n\n* Message text .0\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8)  Clear entry\n         LA    R6,NumMin            Get address of varable\n         ST    R6,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNam0          get address of variable name\n         ST    R6,AXRARGNameADDRLOW Store address of name\n         MVI   AxrArgNameLength,L'tmsgNam0\n         OI    AXRARGINPUTFLGS1,AXRARGInput   input varible\n         MVI   AxrArgType,AXRARGTYPEUNSIGNED  type is unsigned binary\n         LA    R6,L'NumMin          Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .1\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,VARTMSG           Get address of message text line\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNam1          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgNam1\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+0         Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .2\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,L'CTXTTMSG(,R7) Point to next line of message text\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNam2          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgNam2\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+2         Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .3\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,L'CTXTTMSG(,R7) Point to next line of message text\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNam3          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgNam3\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+4         Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .4\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,L'CTXTTMSG(,R7) Point to next line of message text\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNam4          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgNam4\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+6         Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .5\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,L'CTXTTMSG(,R7) Point to next line of message text\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNam5          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgNam5\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+8         Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .6\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,L'CTXTTMSG(,R7) Point to next line of message text\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNam6          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgNam6\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+10        Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .7\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,L'CTXTTMSG(,R7) Point to next line of message text\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNam7          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgNam7\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+12        Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .8\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,L'CTXTTMSG(,R7) Point to next line of message text\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNam8          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgNam8\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+14        Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .9\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,L'CTXTTMSG(,R7) Point to next line of message text\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNam9          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgNam9\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+16        Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .10\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,L'CTXTTMSG(,R7) Point to next line of message text\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNamA          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgNamA\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+18        Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .11\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,L'CTXTTMSG(,R7) Point to next line of message text\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNamb          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgNamb\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+20        Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .12\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,L'CTXTTMSG(,R7) Point to next line of message text\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNamc          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgNamc\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+22        Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .13\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,L'CTXTTMSG(,R7) Point to next line of message text\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNamd          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgNamd\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+24        Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .14\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,L'CTXTTMSG(,R7) Point to next line of message text\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgName          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgName\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+26        Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .15\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,L'CTXTTMSG(,R7) Point to next line of message text\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNamf          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgNamf\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+28        Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .16\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,L'CTXTTMSG(,R7) Point to next line of message text\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNamg          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgNamg\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+30        Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .17\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,L'CTXTTMSG(,R7) Point to next line of message text\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNamh          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgNamh\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+32        Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .18\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,L'CTXTTMSG(,R7) Point to next line of message text\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNami          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgNami\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+34        Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .19\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,L'CTXTTMSG(,R7) Point to next line of message text\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNamj          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgNamj\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+36        Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n* Message text .20\n\n         LA    R8,AXRARGENTRY_LEN(,R8)     Point to next entry\n         XC    0(AXRARGENTRY_LEN,R8),0(R8) Clear entry\n         LA    R7,L'CTXTTMSG(,R7) Point to next line of message text\n         ST    R7,AXRARGADDRLOW     Store address in arglist\n         LA    R6,tmsgNamk          Get address of name\n         ST    R6,AXRARGNameADDRLOW Store address of name of varible\n         MVI   AxrArgNameLength,L'tmsgNamk\n         OI    AXRARGINPUTFLGS1,AXRARGInput  Input variable\n         MVI   AxrArgType,AxrArgTypeChar        Indicate char string\n*        LA    R6,L'CTXTTMSG        Obtain length (in bytes)\n         LH    R6,VARTLEN+38        Obtain length (in bytes)\n         ST    R6,AxrArgLength      Store length in var entry\n\n         DROP  R8\n         WTO   'MPF2REXX INVOKED',MCSFLAG=(HRDCPY)\n\n* Call system rexx\n\n         AXREXX REQUEST=EXECUTE,   Execute a rexx                      X\n               SECURITY=BYAXRUSER, Run under ID in AXRUSER of AXRxx    X\n               NAME=EXECNAME,      Name is stored in execname          X\n               SYNC=NO,            Asyncrounous call                   X\n               TSO=NO,             TSO environment                     X\n               REXXVARS=RxVarLst,  Point to variable list              X\n               REXXDIAG=RxAxrDiag, Diagnosis area                      X\n               PLISTVER=MAX,       Largest possible AXREXX plist size  X\n               RETCODE=OutRC,      Store return code                   X\n               RSNCODE=OutRsn,     Store reason code                   X\n               MF=(E,RXPLIST,COMPLETE)\n\n         LTR   R15,R15\n         BNZ   FailLabel\n         USING AxrDiag,R9\n         LA    R9,RxAxrDiag\n         TM    AxrDiagFlgs1,AxrDiagNoExecRetCode\n         BNZ   FailLabel\n         L     R15,AxrDiagExecRetCode\n         LTR   R15,R15\n         BNZ   FailLabel\n\n* Cleanup\n\n         LA    R1,WORKLEN\n         FREEMAIN R,LV=(R1),A=(R3),SP=230\n         LTR   R15,R15             Free OK?\n         BZ    RETURN              Yes-> Return\n         WTO   'MPF2REXX FREEMAIN FAILED'\n\n* Exit\n\nReturn   DS    0h\n         PR                             Restore callers regs\n\n* Perform error checking\n\nFailLabel DS   0H\n\n         MVC   WTOPLIST(WTOLISTL),WTOLIST Move in WTO plist\n\n         UNPK  WTOPLIST+29(9),OutRC(5)  Unpack RC\n         MVI   WTOPLIST+37,C' '         Clear old sign\n         TR    WTOPLIST+29(8),TRTABLE   Convert to printable hex chars\n\n         UNPK  WTOPLIST+43(9),OutRsn(5) Unpack RSN code\n         MVI   WTOPLIST+51,C' '         Clear old sign\n         TR    WTOPLIST+43(8),TRTABLE   Convert to printable hex chars\n         WTO   MF=(E,WTOPLIST)\n         AGO   .SKIP\n*\n* OUTPUT AXRDIAG CODES AS WELL - MCKOWN\n         MVC   WTOPLIST(WTOLISTL2),WTOLIST2\n         UNPK  WTOPLIST+19(9),AXRDIAG1(5)\n         TR    WTOPLIST+19(8),TRTABLE\n         MVI   WTOPLIST+27,C' '\n         UNPK  WTOPLIST+34(9),AXRDIAG2(5)\n         TR    WTOPLIST+34(8),TRTABLE\n         MVI   WTOPLIST+42,C' '\n         UNPK  WTOPLIST+49(9),AXRDIAG3(5)\n         TR    WTOPLIST+49(8),TRTABLE\n         MVI   WTOPLIST+57,C' '\n         UNPK  WTOPLIST+64(9),AXRDIAG4(5)\n         TR    WTOPLIST+64(8),TRTABLE\n         MVI   WTOPLIST+72,C' '\n         WTO   MF=(E,WTOPLIST)\n.SKIP    ANOP\n*\n\n         PR\n\n* Local storage\n\nNumVars  EQU   24                Total number of variables  @DM11032010\nExtraFields EQU 4                Extra fields beyond wto lin@DM11032010\ntmsgNam0 DC    C'MPF2REXXMSG.0'\ntmsgNam1 DC    C'MPF2REXXMSG.1'\ntmsgNam2 DC    C'MPF2REXXMSG.2'\ntmsgNam3 DC    C'MPF2REXXMSG.3'\ntmsgNam4 DC    C'MPF2REXXMSG.4'\ntmsgNam5 DC    C'MPF2REXXMSG.5'\ntmsgNam6 DC    C'MPF2REXXMSG.6'\ntmsgNam7 DC    C'MPF2REXXMSG.7'\ntmsgNam8 DC    C'MPF2REXXMSG.8'\ntmsgNam9 DC    C'MPF2REXXMSG.9'\ntmsgNamA DC    C'MPF2REXXMSG.10'\ntmsgNamb DC    C'MPF2REXXMSG.11'\ntmsgNamc DC    C'MPF2REXXMSG.12'\ntmsgNamd DC    C'MPF2REXXMSG.13'\ntmsgName DC    C'MPF2REXXMSG.14'\ntmsgNamf DC    C'MPF2REXXMSG.15'\ntmsgNamg DC    C'MPF2REXXMSG.16'\ntmsgNamh DC    C'MPF2REXXMSG.17'\ntmsgNami DC    C'MPF2REXXMSG.18'\ntmsgNamj DC    C'MPF2REXXMSG.19'\ntmsgNamk DC    C'MPF2REXXMSG.20'\njbnmName DC    C'MPF2REXXJOB'\njbidName DC    C'MPF2REXXJID'                               @DM11032010\nsysnName DC    C'MPF2REXXSYS'\nWTOLIST  WTO   'MPF2REXX AXREXX ERROR RC XXXXXXXX  RSN XXXXXXXX',      X\n               MF=L\nWTOLISTL EQU   *-WTOLIST\n         AGO   .SKIP2\nWTOLIST2 WTO   'MPF2REXX DIAG1 XXXXXXXX DIAG2 XXXXXXXX DIAG3 XXXXXXXX DI\n               IAG4 XXXXXXXX',                                         X\n               MF=L\nWTOLISTL2 EQU  *-WTOLIST2\n.SKIP2   ANOP\n* TR table for decoding hex values\n         ORG   *-240\nTRTABLE  EQU   *\n         DS    CL240\n         DC    C'0123456789ABCDEF'\n         ORG   ,\n* TRT table for finding length of fields\nTRTTAB   DC    256X'FF'           All values invalid\n         ORG   TRTTAB+C'#'\n         DC    1X'00'             #\n         ORG   TRTTAB+C'$'\n         DC    1X'00'             $\n         ORG   TRTTAB+C'@'\n         DC    1X'00'             @\n         ORG   TRTTAB+C'A'\n         DC    9X'00'             ABCDEFGHI\n         ORG   TRTTAB+C'J'\n         DC    9X'00'             JKLMNOPQR\n         ORG   TRTTAB+C'S'\n         DC    8X'00'             STUVWXYZ\n         ORG   TRTTAB+C'0'\n         DC    10X'00'            0123456789\n         ORG   ,\n\n* Work area DSECT\n\nWORKDS   DSECT\nNextwrk  DS    F                        Ptr to next work area\nSeqno    DS    F                        Sequence number\nSAVEAREA DS    18F                      Reg save area\nDWORD    DS    D                        Doubleword\nNumMin   DS    F                        Number of Minor lines\nNumMinC  DS    C\nExecName DS    CL8                      Exec Name\nExecEOF  DS    CL8          **REQ**     MUST BE AFTER NAME    TT 120817\nRxVarLst DS    CL(AXRARGLST_LEN)        Variable List\nRxVarEnt DS    24CL(AXRARGENTRY_LEN)    Varible entries\n*xVarEnt DS    CL(AXRARGENTRY_LEN*NumVars)    Varible entries\nRxAxrDiag DS   CL(AXRDIAG_LEN)          Diagnostic area\nVARTMSG  DS    CL(L'CTXTTMSG)           message text\nMinLines DS    19CL(L'CTXTTMSG)         19 more minor lines\nVARTLEN  DS    H                        Length of Line\nMinLens  DS    19H                      19 more lengths\nVARJBNM  DS    CL(L'CTXTJBNM)           job issuing message\nVARSYSN  DS    CL(L'CTXTSYSN)           System issuing message\nVARJBID  DS    CL(L'CTXTOJBID)          Job ID              @DM11032010\nOutRC    DS    F                        Return code from axrexx\n         DS    C                        Pad char\nOutRsn   DS    F                        Reason code\n         DS    C                        Pad char\n         AXREXX PLISTVER=MAX,MF=(L,RXPLIST)\nWTOPLIST WTO   'MPF2REXX AXREXX ERROR RC XXXXXXXX  RSN XXXXXXXX ',     X\n               MF=L\n         AGO   .SKIP3\nWTOPLIST WTO   'MPF2REXX DIAG1 XXXXXXXX DIAG2 XXXXXXXX DIAG3 XXXXXXXX DI\n               IAG4 XXXXXXXX',                                         X\n               MF=L\n.SKIP3   ANOP\nWORKLEN  EQU   *-WORKDS\n\n* Other DSECTS\n\n         EJECT\n         IEZVX100                       CTXT\n         AXRZARG DSECT=YES,AXRARGLST=YES,AXRARGENTRY=YES,AXRDIAG=YES\n         IHAASCB DSECT=YES\n         IRAOUCB DSECT=YES\n         IHAPSA  DSECT=YES\n         EJECT\n         END   MPF2REXX\n/*\n//LKED   EXEC PGM=IEWL,\n//   PARM='XREF,LIST,REUS,AC=1,RENT,AMODE=31,RMODE=ANY'\n//SYSLMOD  DD  DSN=SYS1.LINKLIB(MPF2REXX),DISP=SHR\n//SYSUT1   DD  UNIT=SYSSQ,SPACE=(CYL,(2,1))\n//SYSPRINT DD SYSOUT=*\n//*YSPRINT DD SYSOUT=(P,,1PN),FCB=1PW,COPIES=1,\n//*      DCB=(RECFM=FM),FREE=CLOSE\n//SYSLIB   DD  DSN=&&OBJLIB,DISP=(OLD,PASS),UNIT=SYSSQ\n//SYSLIN   DD  *\n INCLUDE SYSLIB(MPF2REXX)\n NAME MPF2REXX(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT882/FILE882.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT882", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}