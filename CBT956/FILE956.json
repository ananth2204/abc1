{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013559000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 293930, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE956.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE956.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x06\\t'", "DS1TRBAL": "b'Q\\xf2'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\t\\xee\\x00\\t\\t\\xef\\x00\\x00\\x00\\x07'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04_\\x00C\\x01\\x17\\x10\\x9f\\x01\\x17\\x10\\x9f\\t5\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf5@@@'", "ispf": {"version": "04.95", "flags": 0, "createdate": "2017-04-19T00:00:00", "modifydate": "2017-04-19T09:35:43", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-495"}, "text": "REGULAR CBT TAPE - VERSION 495    FILE:  956\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT495.FILE956\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    27920   PO\n\n   PDS117I 8 MEMBERS COUNTED; CUMULATIVE SIZE IS 2,718 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/19/17    09:35:42    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x14\\x01\\x17\\x10\\x7f\\x01\\x17\\x10\\x9f\\t5\\x00>\\x00\\x1f\\x00\\x00\\xd4\\xe5\\xe2\\xd7\\xd9\\xd6\\xc7@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2017-04-17T00:00:00", "modifydate": "2017-04-19T09:35:14", "lines": 62, "newlines": 31, "modlines": 0, "user": "MVSPROG"}, "text": "DSREF from Steve Myers (mvsprog@yahoo.com)\n\nDSREF produces three reports:\n\n - Data set to userid\n\n   data set name\n    user user ... user\n\n - User to data set\n\n   user\n    data set  data set ... data set\n\n - Optional list of jobs in the data\n\nMember  Purpose\nDSREF    The main program\nQSORTS   An in storage sort program loosely modeled on the C standard\n         library qsort function\nMINIFMT  A message format program\nINSTALL  JCL to assemble and link DSREF and its dependent modules\n\nInstallation -\n - Method 1 - Use the TSO RECEIVE command to transform the LOADMOD\n              member in this data set to build a load module form\n              of the DSREF program.\n\n              RECEIVE INDATASET(this-data-set(LOADMOD))\n\n - Method 2 - Customize the INSTALL member in this data set to\n              assemble and link the DSREF program and its 2 dependent\n              modules to build a load module form of the DSREF\n              program.\n\nRun time JCL -\n\n //        EXEC PGM=DSREF,PARM='option,option,...'\n //SYSPRINT DD  SYSOUT=*\n //SMF      DD  -- SMF data --\n\n The SMF data must contain SMF type 14, 15 and 30 records.  The SMF 30\n records link a userid (from SMF30RUD) to job information (from the\n SMF 14 and 15 records).\n\n The options are documented in the DSREF module.\n\nA few notes about the program\n\nAt one time the program listed the users it found as a separate report.\nThe code is still there, but it has effectively been disabled; it was\nsuperflous after the data sets accessed by a user was added.  The\nUSERLIST and NOUSERLIST options are still in the option table, but\nas comments.\n\nDSREF and MINIFMT are effectively in the public domain.  However, they\nare copyrighted.  DO NOT ALTER OR REMOVE THE COPYRIGHT DECLARATION.\nAny additions should be declared separately.  The QSORTS module is\nnot copyrighted because it is based on code from the copyrighted\n\"The C Programming Language.\"  Appropriate attribution is in the\nmodule source.  The QSORTL function in the module is entirely original.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE956": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04_\\x007\\x01\\x17\\x10\\x9f\\x01\\x17\\x10\\x9f\\t5\\x00\\x18\\x00\\x18\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf5@@@'", "ispf": {"version": "04.95", "flags": 0, "createdate": "2017-04-19T00:00:00", "modifydate": "2017-04-19T09:35:37", "lines": 24, "newlines": 24, "modlines": 0, "user": "CBT-495"}, "text": "//***FILE 956 is from Steve Myers, and contains programs to         *   FILE 956\n//*           show dataset access by userid from SMF data.          *   FILE 956\n//*                                                                 *   FILE 956\n//*       The DSREF program produces reports showing dataset        *   FILE 956\n//*       access by userid, using SMF 14, 15 and 30 records.        *   FILE 956\n//*                                                                 *   FILE 956\n//*           email:  mvsprog@yahoo.com                             *   FILE 956\n//*                                                                 *   FILE 956\n//*       DSREF produces three reports:                             *   FILE 956\n//*                                                                 *   FILE 956\n//*        - Data set to userid                                     *   FILE 956\n//*                                                                 *   FILE 956\n//*          data set name                                          *   FILE 956\n//*           user user ... user                                    *   FILE 956\n//*                                                                 *   FILE 956\n//*        - User to data set                                       *   FILE 956\n//*                                                                 *   FILE 956\n//*          user                                                   *   FILE 956\n//*           data set  data set ... data set                       *   FILE 956\n//*                                                                 *   FILE 956\n//*        - Optional list of jobs in the data                      *   FILE 956\n//*                                                                 *   FILE 956\n//*       For additional information, see member $DOC.              *   FILE 956\n//*                                                                 *   FILE 956\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DSREF": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x17\\x10\\x7f\\x01\\x17\\x10\\x7f\\x14\\x18\\x04\\xc9\\x04\\xc9\\x00\\x00\\xd4\\xe5\\xe2\\xd7\\xd9\\xd6\\xc7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-04-17T00:00:00", "modifydate": "2017-04-17T14:18:33", "lines": 1225, "newlines": 1225, "modlines": 0, "user": "MVSPROG"}, "text": "DSREF    TITLE '                             D A T A   S E T   U S A G >\n               E   B Y   U S E R'\n***********************************************************************\n*                                                                     *\n* Title - DSREF                                                       *\n*                                                                     *\n* Function / Operation - DSREF uses data from the IBM SMF facility to *\n*   produce a report showing the users that access data sets.  A data *\n*   set report looks like -                                           *\n*                                                                     *\n*   dsn   nnn                                                         *\n*    user user ... user                                               *\n*                                                                     *\n*   The list of users report extends over as many lines as are        *\n*   required for the data set.  The nnn on the data set line is the   *\n*   number of references for the data set, not the number of users    *\n*   that referenced the data set.  The user entries in the user       *\n*   are in 10 byte cells.  A user with a * before the userid          *\n*   indicates the user updated the data set.                          *\n*                                                                     *\n*   The second report is a list of users followed by the data sets    *\n*   the user accessed.  The report looks like this -                  *\n*                                                                     *\n*   userid                                                            *\n*    dsn dsn ... dsn                                                  *\n*                                                                     *\n*   The dataset list extends over as many lines as are required.      *\n*                                                                     *\n*   The third report is optional.  It is a list of jobs DSREF         *\n*   encountered.  If possible, it displays the userid of the user     *\n*   that submitted the job in this report.                            *\n*                                                                     *\n* JCL -                                                               *\n*   //        EXEC PGM=DSREF,PARM=option,option,...'                  *\n*   //SYSPRINT DD  -- Data set to receive the report --               *\n*   //SMF      DD  -- Data set containing SMF data --                 *\n*                                                                     *\n*   These options can be specified.                                   *\n*    JOBLIST - List the jobs in the input.                            *\n*    NOJOBLIST - Do not list the jobs,                                *\n*    WIDELINE - Use a 120 byte wide line to list the users for data   *\n*     sets.                                                           *\n*    NOWIDELINE - Use an 80 byte wide line to list the users for data *\n*     sets.                                                           *\n*    SORTREFCOUNT - Sort the data set report by the reference count   *\n*     for the data set.                                               *\n*    SORTDSN - Sort the data set report by data set name.             *\n*                                                                     *\n*    The default is SORTREFCOUNT,NOWIDELINE,NOJOBLIST                 *\n*                                                                     *\n* Messages -                                                          *\n*    THERE ARE NO VALID RECORDS IN THE SMF DATA SET                   *\n*     Reason: DSREF determined there are no valid SMF records in the  *\n*      data set specified by the DD statement with DD name SMF.       *\n*     Action: DSREF terminates.                                       *\n*     Response: Specify a data set containing SMF data and rerun      *\n*      DSREF.                                                         *\n*    SMF DATA FROM yyyy/mm/dd hh:mm:ss TO yyyy/mm/dd hh:mm:ss         *\n*     Reason: Duh                                                     *\n*     Action: DSREF produces the report.                              *\n*     Response: Review the report.                                    *\n*    jjjjjjjj yyyy/mm/dd hh:mm:ss uuuuuuuu                            *\n*     Reason: the input data included jobs (or TSO sessions) that     *\n*      were submitted at yyyy/mm/dd hh:mm:ss and were run by a user   *\n*      with userid uuuuuuuu.  Userid ???????? indicates DSREF was     *\n*      unable to determine the userid.  This report appears when      *\n*      option JOBLIST is specifieds in the EXEC statement PARM.       *\n*     Action: DSREF lists the next job.                               *\n*     Response: Review the report.                                    *\n*    nnnK BYTES OF STORAAGE ALLOCATED                                 *\n*     Reason: DSREF allocated the indicated amount of storage to      *\n*      prepare its reports.  Some additional storage for data areas   *\n*      for I/O buffers and possible temporary store are also required *\n*      and are not included in this value.                            *\n*     Action: DSREF terminates.                                       *\n*     Response: None required.  This storage is requested             *\n*      unconditionally and can result in SB78 ABENDs.                 *\n*    OPTIONS: option,...,option                                       *\n*     Reason: DSREF lists the option it is using.  The option strings *\n*      in the message are the same option strings that can be         *\n*      specified in the PARM=ccc parameter in the JCL EXEC statement  *\n*      used to run DSREF.                                             *\n*     Action: DSREF terminates.                                       *\n*     Response: Review the options.  If necessary, correct the        *\n*      and rerun DSREF.                                               *\n*     Comment: The code in DSREF that analyzes the options ignores    *\n*      invalid options without writing an error message.              *\n*                                                                     *\n* Notes -                                                             *\n*   DSREF attempts to reduce \"noise\" in the output report by not      *\n*   reporting access to temporary data sets and to ISPF backup data   *\n*   sets.  ISPF backup data sets have data set name                   *\n*   userid.ISRnnnn.BACKUP, where nnnn is a 4 digit numeric.           *\n*                                                                     *\n*   Userid ???? is used by DSREF when it is unable to determine the   *\n*   userid of a user accessing a data set.  The only known source     *\n*   of a userid in SMF data is the SMF30RUD data srea in the ID       *\n*   segment of most SMF type 30 records.  A patient analyst can often *\n*   guess a userid by examining the JOBLIST report looking for job    *\n*   or TSO sessions with userid ????.  This should be very rare in    *\n*   systems that write \"interval\" SMF type 30 records.                *\n*                                                                     *\n***********************************************************************\n         EJECT\nDSREF    RSECT\nDSREF    AMODE 31\n         USING DSREFD,11\n         USING *,12\n         SAVE  (14,12),,'DSREF &SYSDATE &SYSTIME Copyright (C) 2017 J. >\n               Stephen Myers'\n         LR    12,15               Prepare\n         BAS   14,*+L'*+4           the\n         DC    AL4(DSREFD)           base\n         L     11,0(,14)              registers\n         LA    15,SAVEAREA             and\n         ST    13,4(,15)                the\n         ST    15,8(,13)                 first\n         LR    13,15                      save area\n         L     2,0(,1)             Load the address of the PARM text\n         BAS   14,INITHDR          Add the run date & time to the     ->\n                                    page header\n         OPEN  MF=(E,OPARM01)      Open the data sets\n         LTR   15,15               All data sets open?\n         BNZ   EXIT                No\n         BAS   14,PARMSCAN         Scan the PARM text\n         USING SMFREC,3\nGET0100  GET   SMF                 Retrieve an SMF record\n         LR    3,1                 Record woth processing?\n         LH    0,0(,3)\n         CHI   0,MINSIZE\n         BL    GET0100             No\n         TP    SMFRDTE             Date packed decimal?\n         BNZ   GET0100             No\n         ICM   0,B'1111',SMFRTME   Tinme of day valid?\n         BM    GET0100\n         C     0,=A(100*24*60*60)\n         BNL   GET0100\n         CLI   SMFRTYP,2           Type 2 record?\n         BE    GET0100             Yes\n         CLI   SMFRTYP,3           Type 3 record?\n         BE    GET0100             Yes\n         LA    15,1                Update the\n         A     15,RCOUNT            record count\n         ST    15,RCOUNT\n         CP    SMFRDTE,LOWTIME+4(4)  Lowest date/time for the data set?\n         BL    GET0200\n         BNE   GET0300\n         C     0,LOWTIME\n         BNL   GET0300\nGET0200  MVC   LOWTIME,SMFRTME     Save lowest date & time\nGET0300  CP    SMFRDTE,HIGHTIME+4(4)  Higehest date/time for data set?\n         BH    GET0400\n         BNE   GET0500\n         C     0,HIGHTIME\n         BNH   GET0500\nGET0400  MVC   HIGHTIME,SMFRTME    Save highest data/time\nGET0500  CLI   SMFRTYP,30          Type 30 record?\n         BE    GET1300             Yes\n         CLI   SMFRTYP,14          Type 14\n         BL    GET0100              or\n         CLI   SMFRTYP,15            type 15 record?\n         BH    GET0100\n         LA    1,SMF14JBN          Locate a JOB element\n         BAS   14,GETJOB\n         LR    10,1                Copy the JOB address to reg 10\n         TM    SMF14RIN,SMF14TDS   TEMPORARY DATA SET?\n         BO    GET0100             YES\n         CLC   =C'SYS',(JFCBDSNM-JFCB)+SMFJFCB1  Test if temporary\n         BNE   GET0600                            data set name\n         CLI   ((JFCBDSNM-JFCB)+SMFJFCB1)+8,C'.'\n         BNE   GET0600\n         CLI   ((JFCBDSNM-JFCB)+SMFJFCB1)+16,C'.'\n         BNE   GET0600\n         TRT   (JFCBDSNM-JFCB)+SMFJFCB1+3(5),TESTNUM\n         BNZ   GET0600\n         TRT   (JFCBDSNM-JFCB)+SMFJFCB1+10(6),TESTNUM\n         BZ    GET0100\nGET0600  LA    15,(JFCBDSNM-JFCB)+SMFJFCB1  Test\n         LA    0,10                          if\nGET0700  CLI   0(15),C'.'                     ISPF\n         BE    GET0800                         backup\n         LA    15,1(,15)                        data set\n         BCT   0,GET0700\n         B     GET0900\nGET0800  CLC   =C'.ISR',0(15)\n         BNE   GET0900\n         TRT   4(4,15),TESTNUM\n         BNZ   GET0900\n         CLC   =C'.BACKUP',8(15)\n         BE    GET0100\nGET0900  LA    1,(JFCBDSNM-JFCB)+SMFJFCB1  Get a DS\n         BAS   14,GETDS\n         LR    9,1\n         LA    0,1                 Update the\n         A     0,DSRCOUNT-DS(,9)    refrence\n         ST    0,DSRCOUNT-DS(,9)     count\n* Determine if this job has already referenced the data set\n         LA    1,(DSREFLST-DS)-(REFNEXT-REF)(,9)\nGET1000  ICM   1,B'1111',REFNEXT-REF(1)  LOAD ADDRESS OF THE NEXT     ->\n                                            REFERENCE\n         BZ    GET1100             THIS DATA SET HAS NOT BEEN         ->\n                                    REFERENCED BY THIS JOB\n         C     10,REFJOB-REF(,1)    HAS THIS JOB ALREADY REFERENCED   ->\n                                     THIS DATA SET?\n         BE    GET1200             YES\nGET1100  LA    0,REFSIZE           ALLOCATE A NEW REFERENCE\n         BAS   14,GETMAIN\n         XC    0(REFSIZE,1),0(1)   CLEAR IT\n         MVC   REFNEXT-REF(,1),DSREFLST-DS(9)  ADD THE REFERENCE TO\n         ST    1,DSREFLST-DS(,9)                THE DATA SET\n         ST    10,REFJOB-REF(,1)\nGET1200  CLI   SMFRTYP,15          Type 16 record?\n         BNE   GET0100             No\n         OI    REFFLAG-REF(1),REFOUTPUT  Show output reference\n         B     GET0100\n         USING SMFRCD30,3\nGET1300  ICM   4,B'1111',SMF30IOF  Load offset of the ID area\n         BZ    GET0100             No ID area\n         AR    4,3                 Compute address of the ID area\n         USING SMF30ID,4\n* Build a job ID in FMTWORK\n         MVC   FMTWORK(L'SMF30JBN),SMF30JBN\n         MVC   FMTWORK+L'SMF30JBN(L'SMF30RST),SMF30RST\n         MVC   FMTWORK+L'SMF30JBN+L'SMF30RST(L'SMF30RSD),SMF30RSD\n         LA    1,FMTWORK           Allocate or find a JOB\n         BAS   14,GETJOB\n         LR    10,1\n         MVC   AJUSER-AJOB(,10),SMF30RUD  Copy the userid to the JOB\n         LA    1,SMF30RUD          Get a USER data area\n         BAS   14,GETUSER\n         B     GET0100\n         DROP  3,4\n         EJECT\nEOF      DC    0H'0'\n         ICM   0,B'1111',RCOUNT    Any SMF records?\n         BNZ   EOF0100\n         LA    1,FMT02\n         BAS   14,FMTLINE\n         B     EXIT\n* Convert the SMF binary time of day to the decimal time of day\n* used by MINIFMT\nEOF0100  LA    0,LOWTIME\n         BAS   14,DECTIME\n         LA    0,HIGHTIME\n         BAS   14,DECTIME\n         LA    1,FMT03             Write the date and time range\n         BAS   14,FMTLINE\n         LA    0,HDSNO             Build a single linked data set list\n         LA    2,HASHDS             from the data set hash table\nEOF0200  ICM   1,B'1111',0(2)\n         BZ    EOF0300\n         MVC   0(4,2),DSNEXT-DS(1)\n         MVC   DSNEXT-DS(,1),DSLIST\n         ST    1,DSLIST\n         B     EOF0200\nEOF0300  LA    2,4(,2)\n         BCT   0,EOF0200\n         LA    2,DSLIST-(DSNEXT-DS)\nEOF0400  ICM   2,B'1111',DSNEXT-DS(2)\n         BZ    EOF0800\n         LA    3,(DSREFLST-DS)-(REFNEXT-REF)(,2)\nEOF0500  ICM   3,B'1111',REFNEXT-REF(3)\n         BZ    EOF0400\n         ICM   4,B'1111',REFJOB-REF(3)\n         BZ    EOF0500\n         LA    1,AJUSER-AJOB(,4)\n         BAS   14,FINDUSER\n         LTR   15,15\n         BNZ   EOF0500\n         LR    4,1\n         LA    5,(AUREFLST-AUSER)-(URNEXT-UREF)(,4)\nEOF0600  ICM   5,B'1111',URNEXT-UREF(5)\n         BZ    EOF0700\n         C     2,URDS-UREF(5)\n         BNE   EOF0600\n         B     EOF0500\nEOF0700  LA    0,URSIZE\n         BAS   14,GETMAIN\n         XC    0(URSIZE,1),0(1)\n         MVC   URNEXT-UREF(,1),AUREFLST-AUSER(4)\n         ST    1,AUREFLST-AUSER(,4)\n         ST    2,URDS-UREF(,1)\n         B     EOF0500\nEOF0800  L     15,=V(QSORTL)       Sort the data set list\n         TM    OPTION,SORTRCNT\n         BO    SORTR\n         CALL  (15),(,,SORTCMP4),MF=(E,SORTPARM)\n         B     RPT0100\nSORTR    CALL  (15),MF=(E,SORTPARM)\n* Write the data set report\nRPT0100  LA    2,DSLIST-(DSNEXT-DS)\n         USING DS,2\nRPT0200  ICM   2,B'1111',DSNEXT\n         BZ    RPT0800\n         CLC   DSDSN,=44X'04'      VTOC data set?\n         BNE   RPT0300             No\n         MVC   DSDSN,=CL44'**VTOC' Change the name for the report\nRPT0300  LA    1,FMT04\n         BAS   14,FMTLINE\n         ICM   0,B'1111',DSREFLST  Any references?\n         BZ    RPT0200             No\n         XC    LASTUSER,LASTUSER   Reset the last user\n         L     15,=V(QSORTL)       Sort the references\n         CALL  (15),(DSREFLST,,SORTCMP2),MF=(E,SORTPARM)\n         LA    3,DSREFLST-(REFNEXT-REF)\n         LA    5,FMTWORK+4+81      Compute the address\n         TM    OPTION,WIDELINE      of the\n         BZ    RPT0400               end of the line\n         LH    5,(DCBLRECL-IHADCB)+PRINT\n         LA    5,FMTWORK(5)\nRPT0400  LA    14,FMTWORK+5        Compute address of the start of    ->\n                                    the line\n         MVI   FMTWORK+4,C' '\nRPT0500  ICM   3,B'1111',REFNEXT-REF(3)\n         BZ    RPT0700\n         L     15,REFJOB-REF(,3)\n         CLC   AJUSER-AJOB(,15),LASTUSER  Multiple references for     ->\n                                           same user?\n         BE    RPT0500             Yes\n         MVC   LASTUSER,AJUSER-AJOB(15)\n         LA    0,10(,14)           Compute end of the user cell\n         CR    0,5                 Will cell fit on the line?\n         BNH   RPT0600             Yes\n         BCTR  14,0                Find the actual end of line\n         TM    0(14),255-C' '\n         BZ    *-6\n         LA    1,FMTWORK           Compute the line length\n         SR    14,1\n         LA    14,1(,14)\n         SLL   14,16               Convert the length to an RDW\n         ST    14,FMTWORK\n         BAS   14,OUTEDIT          Write the completed line\n         LA    14,FMTWORK+5        Start a new line\nRPT0600  MVC   0(2,14),=CL2' '     Build a user cell\n         MVC   2(8,14),LASTUSER\n         TM    REFFLAG-REF(3),REFOUTPUT  Output?\n         BZ    *+L'*+4             No\n         MVI   1(14),C'*'          Flag cell as output\n         LA    14,10(,14)          Compute address of the next cell\n         B     RPT0500\n* All references identified, print the last line\nRPT0700  BCTR  14,0\n         TM    0(14),255-C' '\n         BZ    RPT0700\n         LA    1,FMTWORK\n         SR    14,1\n         LA    14,1(,14)\n         CHI   14,5\n         BNL   *+L'*+4\n         LA    14,5\n         SLL   14,16\n         ST    14,FMTWORK\n         BAS   14,OUTEDIT\n         B     RPT0200\n         DROP  2\nRPT0800  NOPR  0\n* Build a single user list from the hash table\n         LA    0,HUSERNO           Load number of entries\n         LA    2,HASHUSER          Load address of the hash table\nRPT0900  ICM   1,B'1111',0(2)      Load address of an AUSER\n         BZ    RPT1000             No more left\n         MVC   0(4,2),AUNEXT-AUSER(1)  Remove the AUSER from the table\n         MVC   AUNEXT-AUSER(,1),USERLIST  Add the AUSER to\n         ST    1,USERLIST                  the user list\n         B     RPT0900             Do it again\nRPT1000  LA    2,4(,2)             Compute address of the next entry\n         BCT   0,RPT0900           Do it again\n         L     15,=V(QSORTL)       Sort the user list\n         CALL  (15),(USERLIST,,SORTCMP5),MF=(E,SORTPARM)\n         MVI   CC,C'-'\n         LA    2,USERLIST-(AUNEXT-AUSER)\nRPT1100  ICM   2,B'1111',AUNEXT-AUSER(2)  Load addr of the next AUSER\n         BZ    RPT2800             Done\n         ICM   0,B'1111',AUREFLST-AUSER(2)  Any references?\n         BZ    RPT1100                      No\n         LA    1,FMT07             Print the userid\n         BAS   14,FMTLINE\n         MVI   CC,C' '\n         L     15,=V(QSORTL)\n         CALL  (15),(AUREFLST-AUSER(,2),,SORTCMP6),MF=(E,SORTPARM)\n         LA    6,FMTWORK+4+81          Prepare the address of the\n         TM    OPTION,WIDELINE          end of the line\n         BZ    RPT1200\n         LH    6,(DCBLRECL-IHADCB)+PRINT\n         LA    6,FMTWORK(6)\nRPT1200  LA    5,FMTWORK+5         Load address of the first data     ->\n                                    set cell\n         LA    3,(AUREFLST-AUSER)-(URNEXT-UREF)(,2)\nRPT1300  ICM   3,B'1111',URNEXT-UREF(3) Load address of the next ref\n         BZ    RPT1700             End of references\n         L     4,URDS-UREF(,3)     Load address of the DS\nRPT1400  LA    15,DSDSN+L'DSDSN-DS(,4)  Compute bytes in the name\n         BCTR  15,0\n         TM    0(15),255-C' '\n         BZ    *-6\n         LA    0,DSDSN-DS(,4)\n         SR    15,0\n         BNM   *+L'*+2\n         DC    H'0'                Length <= 0!?\n         LA    0,2(15,5)           Compute address of the end of the  ->\n                                    data set cell\n         CR    0,6                 Will data set fit on the line?\n         BNH   RPT1600             Yes, add data set to the line\n         LA    1,FMTWORK           Print the line\n         LR    0,5\n         SR    0,1\n         SLL   0,16\n         ST    0,FMTWORK\n         BAS   14,OUTEDIT\n         LA    5,FMTWORK+5         Start the next line\n         B     RPT1400\nRPT1500  MVC   1(*-*,5),DSDSN-DS(4) ** EX only **\nRPT1600  MVI   0(5),C' '           Insert the separatot\n         EX    15,RPT1500          Copy the data set\n         LA    5,2(15,5)           Compute address of the next cell\n         B     RPT1300\nRPT1700  LA    1,FMTWORK           Print the last line for the ds\n         LR    0,5\n         SR    0,1\n         SLL   0,16\n         ST    0,FMTWORK\n         BAS   14,OUTEDIT\n         B     RPT1100\nRPT2800  TM    OPTION,JLIST        JOBLIST?\n         BZ    RPT3200             No\n* Build a single job list from the job hash table\n         LA    0,HJOBNO\n         LA    2,HASHJOB\nRPT2900  ICM   1,B'1111',0(2)\n         BZ    RPT3000\n         MVC   0(4,2),AJNEXT-AJOB(1)\n         MVC   AJNEXT-AJOB(,1),JOBLIST\n         ST    1,JOBLIST\n         B     RPT2900\nRPT3000  LA    2,4(,2)\n         BCT   0,RPT2900\n* Sort the job list\n         L     15,=V(QSORTL)\n         CALL  (15),(JOBLIST,,SORTCMP3),MF=(E,SORTPARM)\n* Print the JOBLIST report\n         LA    2,JOBLIST-(AJNEXT-AJOB)\n         MVI   CC,C'-'\nRPT3100  ICM   2,B'1111',AJNEXT-AJOB(2)\n         BZ    RPT3200\n         LA    0,AJRTIME-AJOB(,2)\n         BAS   14,DECTIME\n         LA    1,FMT05\n         BAS   14,FMTLINE\n         MVI   CC,C' '\n         B     RPT3100\nRPT3200  TM    OPTION,ULIST\n         BZ    RPT4000\n*        L     15,=V(QSORTL)\n*        CALL  (15),(USERLIST,,SORTCMP5),MF=(E,SORTPARM)\n         ICM   0,B'1111',USERLIST\n         BZ    RPT4000\n         LA    3,FMTWORK+4\n         LA    4,FMTWORK+4+81\n         LA    2,USERLIST-(AUNEXT-AUSER)\n         MVI   CC,C'-'\nRPT3500  ICM   2,B'1111',AUNEXT-AUSER(2)\n         BZ    RPT3900\nRPT3600  LA    15,AUUSER-AUSER+L'AUUSER(,2)\n         BCTR  15,0\n         TM    0(15),255-C' '\n         BZ    *-6\n         LA    0,AUUSER-AUSER(,2)\n         SR    15,0\n         BNM   *+L'*+2\n         DC    H'0'\n         LA    0,2(15,3)\n         CR    0,4\n         BNH   RPT3800\n         LA    1,FMTWORK\n         LR    0,3\n         SR    0,1\n         SLL   0,16\n         ST    0,FMTWORK\n         MVC   FMTWORK+4(1),CC\n         MVI   CC,C' '\n         BAS   14,OUTEDIT\n         LA    3,FMTWORK+4\n         B     RPT3600\nRPT3700  MVC   1(*-*,3),AUUSER-AUSER(2)\nRPT3800  NOPR  0\n         CHI   15,7\n         BNH   *+L'*+2\n         DC    H'0'\n         MVI   0(3),C' '\n         EX    15,RPT3700\n         LA    3,2(15,3)\n         B     RPT3500\nRPT3900  LA    1,FMTWORK\n         LR    0,3\n         SR    0,1\n         SLL   0,16\n         ST    0,FMTWORK\n         MVC   FMTWORK+4(1),CC\n         MVI   CC,C' '\n         BAS   14,OUTEDIT\n* Compute storage allocated by the GETMAIN function\nRPT4000  SR    2,2\n         LA    1,CPLIST-(CPNEXT-CPOOL)\nRPT4100  ICM   1,B'1111',CPNEXT-CPOOL(1)\n         BZ    RPT4200\n         A     2,CPSIZE-CPOOL(1)\n         B     RPT4100\nRPT4200  SRL   2,10                Comvert storage to K units\n         LA    1,FMT06\n         BAS   14,FMTLINE\n* PREPARE THE OPTIONS IN EFFECT LIST\n*                               ----+----\n         MVC   FMTWORK+4(10),=C'-OPTIONS:'\n         LA    3,FMTWORK+4+9       Compute start of options text\n         LA    4,PSTAB             Load address of the option table\nRPT4300  CLI   0(4),X'FF'          End of option table?\n         BE    RPT4600             Yes\n         SR    15,15\n         IC    15,0(,4)            Load length og option string\n         MVC   12(1,13),OPTION     Copy options to a work area\n         NC    12(1,13),3(4)       Isolate option bitT\n         CLC   12(1,13),4(4)       Option in effect?\n         BNE   RPT4400             No\n         MVI   0(3),C','           Add a ,\n         EX    15,RPT4500          Copy option text to message\n         LA    3,2(15,3)           Advance output pointer\nRPT4400  LA    4,6(15,4)           Compute address of next option\n         B     RPT4300             Do it again\nRPT4500  MVC   1(*-*,3),5(4)       ** EX only **\nRPT4600  MVI   FMTWORK+4+9,C' '    Replace ,\n         LA    1,FMTWORK           Load address of the message\n         SR    3,1                 Compute message length\n         SLL   3,16                Convert length to an RDW\n         ST    3,0(,1)             Store the RDW in the message\n         BAS   14,OUTEDIT          Write the message\nEXIT     LA    1,CPARM01           Close the data sets\n         BAS   14,CLOSELST\n         BAS   14,FREEALL          Free storage allocated by GETMAIN\n         L     13,4(,13)           Exit\n         RETURN (14,12),RC=0\n         EJECT\n         CNOP  0,8\nPARMSCAN BASR  15,0\n         SAVE  (14,12),,PARMSCAN   Save registers\n         LH    5,0(,2)             Load the length of the parm text\n         LTR   5,5                 Any text?\n         BZ    PS0900              No, exit\n         LA    3,2(,2)             Compute address of the first byte\n         LA    4,1\n         LA    5,1(5,2)            Compute address of last text byte\nPS0100   LR    6,3                 Save address of start of string\nPS0200   CLI   0(3),C','           End of string?\n         BE    PS0300              Yes\n         BXLE  3,4,PS0200          Advance the pointer\nPS0300   LR    7,3                 Copy end of string addr to reg 7\n         SR    7,6                 Compute length of string\n         BNP   PS0800              Skip if <= 0\n         BCTR  7,0                 Reduce the length\n         LA    1,PSTAB             Compute address of the option table\nPS0400   CLI   0(1),X'FF'          End of table?\n         BE    PS0800              Yes\n         CLM   7,B'0001',0(1)      Option string length = keyword len?\n         BNE   PS0700              No\n         EX    7,PS0500            String match option?\n         BNE   PS0700              No\n         NC    OPTION,2(1)         Turn off bits\n         OC    OPTION,1(1)         Turn on bits\n         B     PS0700\nPS0500   CLC   0(*-*,6),5(1)       ** EX ONLY **\nPS0700   SR    15,15               Reg 15 = 0\n         IC    15,0(,1)            Load string length\n         LA    1,6(15,1)           COMPUTE ADDR OF NEXT TABLE ENTRY\n         B     PS0400\nPS0800   BXLE  3,4,PS0100          Advance string pointer\nPS0900   RETURN (14,12)            Restore registers & return\n         EJECT\n* CONVERT BINARY TIME OF DAY TO DECIMAL TIME OF DAY\n         CNOP  0,8\nDECTIME  BASR  15,0\n         SAVE  (14,2),,DECTIME\n         LA    15,72(,13)\n         ST    13,4(,15)\n         ST    15,8(,13)\n         LR    13,15\n         LR    2,0\n         L     0,0(,2)\n         L     15,=V(CNVTBIN)\n         CALL  (15)\n         ST    0,0(,2)\n         L     13,4(,13)\n         RETURN (14,2)\n         EJECT\n         CNOP  0,8\nGETDS    BASR  15,0\n         SAVE  (14,3),,GETDS\n         LA    15,72(,13)\n         ST    13,4(,15)\n         ST    15,8(,13)\n         LR    13,15\n         L     15,=CL4' '\n         LR    3,1\n         L     1,0(,1)\n         C     15,4(3)\n         BE    GETD0100\n         AL    1,4(,3)\n         C     15,8(,3)\n         BE    GETD0100\n         AL    1,8(,3)\n         C     15,12(,3)\n         BE    GETD0100\n         AL    1,12(,3)\n         C     15,16(,3)\n         BE    GETD0100\n         AL    1,16(,3)\n         C     15,20(,3)\n         BE    GETD0100\n         AL    1,20(,3)\n         C     15,24(,3)\n         BE    GETD0100\n         AL    1,24(,3)\n         C     15,28(,3)\n         BE    GETD0100\n         AL    1,28(,3)\n         C     15,32(,3)\n         BE    GETD0100\n         AL    1,32(,3)\n         C     15,36(,3)\n         BE    GETD0100\n         AL    1,36(,3)\n         C     15,40(,3)\n         BE    GETD0100\n         AL    1,40(,3)\nGETD0100 SR    0,0\n         D     0,=A(HDSNO)\n         LR    2,0\n         SLL   2,2\n         LA    2,HASHDS(2)\n         LR    1,2\nGETD0200 ICM   1,B'1111',0(1)\n         BZ    GETD0300\n         CLC   DSDSN-DS(,1),0(3)\n         BNE   GETD0200\n         B     GETD0400\nGETD0300 LA    0,DSSIZE\n         BAS   14,GETMAIN\n         XC    0(DSSIZE,1),0(1)\n         MVC   DSDSN-DS(,1),0(3)\n         MVC   DSNEXT-DS(,1),0(2)\n         ST    1,0(,2)\nGETD0400 L     13,4(,13)\n         ST    1,24(,13)\n         RETURN (14,3)\n         EJECT\n         CNOP  0,8\nGETJOB   BASR  15,0\n         SAVE  (14,3),,GETJOB\n         LA    15,72(,13)\n         ST    13,4(,15)\n         ST    15,8(,13)\n         LR    13,15\n         LR    3,1\n         SR    0,0\n         PACK  64(5,13),0(9,3)\n         L     1,64(,13)\n         AL    1,8(,3)\n         AL    1,12(,3)\n         SR    0,0\n         D     0,=A(HJOBNO)\n         LR    2,0\n         SLL   2,2\n         LA    2,HASHJOB(2)\n         LR    1,2\nGETJ0100 ICM   1,B'1111',0(1)\n         BZ    GETJ0200\n         CLC   AJKEY-AJOB(,1),0(3)\n         BNE   GETJ0100\n         B     GETJ0300\nGETJ0200 LA    0,AJSIZE\n         BAS   14,GETMAIN\n         XC    0(AJSIZE,1),0(1)\n         MVC   AJKEY-AJOB(,1),0(3)\n         MVC   AJUSER-AJOB(,1),=8C'?'\n         MVC   AJNEXT-AJOB(,1),0(2)\n         ST    1,0(,2)\nGETJ0300 L     13,4(,13)\n         ST    1,24(,13)\n         RETURN (14,3)\n         EJECT\n         CNOP  0,8\nGETUSER  BASR  15,0\n         SAVE  (14,3),,GETUSER     Save registers\n         LA    15,72(,13)          Prepare a\n         ST    13,4(,15)            new\n         ST    15,8(,13)             save\n         LR    13,15                  area\n         LR    3,1                 Copy the key address to reg 3\n         SR    0,0                 Set reg 0 = 0\n         PACK  64(5,13),0(9,3)     Compact the key\n         L     1,64(,13)           Load the compacted key\n         D     0,=A(HUSERNO)       Divide the key by the number of    ->\n                                    words in the hash table\n         LR    2,0                 Copy the remainder to reg 2\n         SLL   2,2                 Multiply the remainder by 4\n         LA    2,HASHUSER(2)       Compute the address of the hash    ->\n                                    alias entry in USERHASH\n         LR    1,2                 Copy the address to reg 1\nGETU0100 ICM   1,B'1111',0(1)      Load the address of the next AUSER\n         BZ    GETU0200            Br if no AUSERs match the key\n         CLC   AUUSER-AUSER(,1),0(3)  Does this AUSER MATCH?\n         BNE   GETU0100            No, go try thenext AUSER\n         B     GETU0300            Got it, exit\nGETU0200 LA    0,AUSIZE            Allocate storage for the new AUSER\n         BAS   14,GETMAIN\n         XC    0(AUSIZE,1),0(1)      Initialize the\n         MVC   AUUSER-AUSER(,1),0(3)  new AUSER\n         MVC   AUNEXT-AUSER(,1),0(2) Add the new AUSER to\n         ST    1,0(,2)                 USERHASH\nGETU0300 L     13,4(,13)           Load address of the higher save area\n         ST    1,24(,13)           Replace the caller's reg 1 with    ->\n                                    address of the AUSER\n         RETURN (14,3)             Restore registers & return\n         EJECT\n         CNOP  0,8\nFINDUSER BASR  15,0\n         SAVE  (14,0),,FINDUSER    Save registers\n         SR    14,14               Set reg 14 = 0\n         PACK  64(5,13),0(9,1)     Compact the userid\n         L     15,64(,13)          Load the compacted userid\n         D     14,=A(HUSERNO)      Divide userid by hash table size\n         SLL   14,2                Multiply the remainder by 4\n         LA    14,HASHUSER(14)     Compute the address of the hash    ->\n                                    table entry for the userid\nFU0100   ICM   14,B'1111',AUNEXT-AUSER(14)  Load addr of the next AUSER\n         BZ    FU0200              Nothing\n         CLC   AUUSER-AUSER(,14),0(1)  Correct AUSER?\n         BNE   FU0100              No, try the next AUSER\n         LR    1,14                Copy the AUSER address to reg 1\n         RETURN (14,0),RC=0        Restore registers & return\nFU0200   RETURN (14,0),RC=4        Not found, restore regs & return\n         EJECT\n* Insert run date & time into the page header\n         CNOP  0,8\nINITHDR  BASR  15,0                Store current address in reg 15\n         SAVE  (14,0),,INITHDR     Save registers\n         LA    15,72(,13)          Compute addr of the next save area\n         ST    13,4(,15)           Add new save area to the\n         ST    15,8(,13)            save area chain\n         LR    13,15               Establish new save area pointer\n         LA    0,FMTWORK           Load addr of the MINIFMT work area\n         LA    1,FMT01             Load addr of the format\n         L     15,=V(MINIFMT)      Load addr of the format program\n         CALL  (15)                Format the system date & time\n         LA    0,4(,1)             Compute addr of the date & time text\n         LH    15,0(,1)            Load length of the message\n         AHI   15,-4               Compute length of the next\n         LA    14,PAGEHDR+97       Compute addr of date & time in hdr\n         LR    1,15                Copy length to reg 1\n         MVCL  14,0                Copy date & time to the page hdr\n         L     13,4(,13)           Load addr of the higher save area\n         RETURN (14,0),T           Restore registers & return\n         EJECT\n* Test if a DD statement is allocated\n         CNOP  0,8\nTESTDD   BASR  15,0                Store current addr in reg 16\n         SAVE  (14,3),,TESTDD      Save registers\n         LR    2,1                 Copy OPEN parm list addr to reg 2\n         SR    3,3                 Set the return code\nTDD0100  L     1,0(,2)             Load a DCB address\n         N     1,=A(X'FFFFFF')     Isolate the 24-bit DCB address\n         DEVTYPE DCBDDNAM-IHADCB(,1),64(,13)  Test if DD present\n         LTR   15,15               Test DEVTYPE return code\n         JZ    TDD0200             Br if RC = 0\n         LHI   3,4                 Reset my return code\nTDD0200  TM    0(2),X'80'          Test if end of the OPEN parm list\n         LA    2,4(,2)             Compute addr of the next DCB pointer\n         JZ    TDD0100             Br if not end of the OPEN parm list\n         LR    15,3                Copy my return code to reg 15\n         RETURN (14,3),T,RC=(15)   Restore regs & return\n         EJECT\n* Open one or more DCBs\n         CNOP  0,8\nOPENLIST BASR  15,0                Store current address in reg 15\n         SAVE  (14,2),,OPENLIST    Save registers\n         LR    2,1                 Copy parm list addr to reg 2\n         OPEN  MF=(E,(2))          Open the DCBs\n         SR    15,15               Set preliminary return code\nOL0100   L     1,0(,2)             Load a DCB address\n         N     1,=A(X'FFFFFF')     Isolate the 24-bit DCB address\n         TM    DCBOFLGS-IHADCB(1),DCBOFOPN  Test if the DCB is open\n         JO    *+8                 Br if so\n         LHI   15,4                Reset the return code\n         TM    0(2),X'80'          Test if end of the parm list\n         LA    2,4(,2)             Compute addr of the next DCB pointer\n         JZ    OL0100              Br if not end of the parm list\n         RETURN (14,2),T,RC=(15)   Restore regs & return\n         EJECT\n* Close one or more DCBs and free their buffer pools\n         CNOP  0,8\nCLOSELST BASR  15,0                Store current address in reg 15\n         SAVE  (14,2),,CLOSELST    Save registers\n         LR    2,1                 Copy parm list address to reg 2\n         CLOSE MF=(E,(1))          Close the DCBs\nCL0100   L     1,0(,2)             Load a DCB addr from the parm list\n         N     1,=A(X'FFFFFF')     Isolate the 24-bit DCB address\n         TM    DCBOFLGS-IHADCB(1),DCBOFOPN  Test if the DCB is open\n         JO    CL0200              Br if so\n         TM    (DCBBUFCB-IHADCB)+3(1),1  Test if there is a buffer pool\n         JO    CL0200              Br if not\n         FREEPOOL (1)              Free the buffer pool\nCL0200   TM    0(2),X'80'          Test if end of the parm list\n         LA    2,4(,2)             Compute addr of the next DCB pointer\n         JZ    CL0100              Br if not end of the parm list\n         RETURN (14,2),T           Restore registers & return\n         EJECT\n* Prepare an output line using MINIFMT and then \"print\" the line\n         CNOP  0,8\nFMTLINE  BASR  15,0                Store current address in reg 15\n         SAVE  14,,FMTLINE         Save reg 14\n         LA    15,72(,13)          Compute addr of the next save area\n         ST    15,8(,13)           Add new save area to the\n         ST    13,4(,15)            save area chain\n         LR    13,15               Establish new save area pointer\n         LA    0,FMTWORK           Load addr of the MINIFMT work area\n         L     15,=V(MINIFMT)      Load addr of MINIFMT\n         CALL  (15)                Format the line\n*        BRAS  14,OUTEDIT          Write the formatted line\n         L     13,4(,13)           Load addr of the higher save area\n         L     14,12(,13)          Reload reg 15\n         J     OUTEDIT             Go write the completed line\n*        L     13,4(,13)           Load addr of the higher save area\n*        RETURN 14,T               Restore reg 14 & return\n         EJECT\n* \"Print\" a line, after inserting a page header if required.\n         CNOP  0,8\nOUTEDIT  BASR  15,0                Store current address in reg 15\n         SAVE  (14,4),,OUTEDIT     Save registers\n         LR    2,1                 Copy line address to reg 2\n         SR    3,3                 Set reg 3 = 0\n         SR    4,4                 Set reg 4 = 0\n         LA    15,72(,13)          Compute addr of the next save area\n         ST    15,8(,13)           Add new save area to the\n         ST    13,4(,15)            save area chain\n         LR    13,15               Establish new save area pointer\n*        LH    0,0(,2)             Load the line length\n*        CH    0,(DCBLRECL-IHADCB)+PRINT  Test the length\n*        JNH   *+L'*+6             Br if length <= lrecl\n*        MVC   0(2,2),(DCBLRECL-IHADCB)+PRINT  Reset the length\n         IC    3,4(,1)             Load the carriage control character\n         IC    4,OELINES(3)        Load lines this line will print\n         AH    4,LINECT            Add current page position\n         CHI   4,60                Compare new page position with     ->\n                                    max lines on a page\n         JNH   OE0100              Br if new line will fit on the     ->\n                                    current page\n         AP    PAGENUM,=P'1'       Add 1 to the page number\n         MVC   PAGE#,=X'402020202120'  Convert page number to digits\n         ED    PAGE#,PAGENUM\n         PUT   PRINT,PAGEHDR       Write the page header\n         MVI   4(2),C'0'           Replace the carriage control\n         LHI   4,3                 Set new page position\nOE0100   PUT   PRINT,(2)           Write the line\n         STH   4,LINECT            Update the page position\n         STC   3,4(,2)             Restore original carriage control\n         L     13,4(,13)           Load addr of the higher save area\n         RETURN (14,4),T           Restore registers & return\n         EJECT\n* Allocate a small amount of storage\n         DC    0D'0'\nCPAMT    EQU   4*1024              BYTES IN A SINGLE CELL POOL\nGETMAIN  BASR  15,0                STORE CURRENT ADDRESS IN REG 15\n*        USING *,12                ESTABLISH ADDRESSABILITY\n         USING CPOOL,10\n         SAVE  (14,12),,GETMAIN    SAVE REGISTERS\n*        LR    12,15               COPY ENTRY POINT ADDRESS TO REG 12\n         LR    2,0                 COPY AMOUNT OF STORAGE TO REG 2\n         AHI   2,7                 ROUND REQUEST UP TO AN 8 BYTE\n         N     2,ROUND8             MULTIPLE\nGM0100   LA    10,CPLIST-(CPNEXT-CPOOL)  LOAD ADDR OF A DUMMY CPOOL\nGM0200   ICM   10,B'1111',CPNEXT   LOAD ADDR OF THE NEXT CPOOL\n         JZ    GM0300              BR IF END OF LIST\n         C     2,CPLEFT            COMPARE REQUESTED AMOUNT WITH      ->\n                                    FREE STORAGE IN THIS CPOOL\n         JH    GM0200              BR IF NOT ENOUGH STORAGE IN THIS   ->\n                                    CPOOL\n         MVC   24(4,13),CPNEXTA    REPLACE CALLER'S REG 1 W/ CURRENT  ->\n                                    FREE SPACE ADDRESS IN THIS CPOOL\n         L     0,CPLEFT            LOAD FREE BYTES IN THIS CPOOL\n         SR    0,2                 SUBTRACT AMOUNT OF STORAGE WE      ->\n                                    JUST ALLOCATED\n         ST    0,CPLEFT            UPDATE FREE SPACE AMOUNT\n         A     2,CPNEXTA           ADD ADDRESS OF STORAGE WE JUST     ->\n                                    ALLOCATED TO AMOUNT OF STORAGE    ->\n                                     WE JUST ALLOCATED\n         ST    2,CPNEXTA           UPDATE ADDRESS OF FREE STORAGE\n         J     GM0800              AND EXIT\nGM0300   LHI   0,CPAMT-(CPSTART-CPOOL)  SET REG 0 = FREE STORAGE IN A ->\n                                         SINGLE CPOOL\nGM0400   CR    0,2                 COMPARE W/ AMOUNT WE NEED\n         JNL   GM0500              BR IF ENOUGH\n         AHI   0,CPAMT             ADD CPAMT TO REG 0\n         J     GM0400              CONTINUE\nGM0500   AHI   0,CPSTART-CPOOL     SET REG 0 TO A K MULTIPLE\n         LR    3,0                 COPY AMOUNT OF STORAGE TO REG 3\n         TAM   ,                   TEST ADDRESSING MODE\n         JNZ   GM0600              BR IF NOT AMODE 24\n         GETMAIN RU,LV=(0)         ALLOCATE STORAGE\n         J     GM0700\nGM0600   GETMAIN RU,LV=(0),LOC=(31,ANY)  ALLOCATE STORAGE\nGM0700   LR    10,1                COPY ADDRESS TO REG 11\n*        XC    0(CPSTART-CPOOL,11),0(11)  CLEAR THE HEADER\n         ST    3,CPSIZE            STORE THE SIZE\n         LA    0,CPSTART\n         ST    0,CPNEXTA\n         AHI   3,-(CPSTART-CPOOL)  SUBTRACT HEADER SIZE FROM          ->\n                                    ALLOCATED STORAGE\n         ST    3,CPLEFT            STORE FREE SPACE SIZE\n         MVC   CPNEXT,CPLIST       ADD THE NEW SUBPOOL TO THE\n         ST    10,CPLIST            SUBPOOL CHAIN\n         J     GM0100              AND RESTART ALLOCATION\nGM0800   RETURN (14,12),T          RESTORE REGS & RETURN\n         SPACE 5\n         CNOP  0,8\nFREEALL  BASR  15,0                STORE CURRENT ADDRESS IN REG 15\n*        USING *,12                ESTABLISH ADDRESSABILITY\n         SAVE  (14,12),,FREEALL    SAVE REGISTERS\n*        LR    12,15               COPY THE ENTRY POINT ADDR TO REG 12\nFR0100   ICM   10,B'1111',CPLIST   LOAD ADDR OF THE NEXT CPOOL\n         JZ    FR0200              EXIT IF DONE\n         MVC   CPLIST,CPNEXT       REMOVE CURRENT CPOOL FROM THE CHAIN\n         L     0,CPSIZE            LOAD SIZE\n         FREEMAIN RU,LV=(0),A=(10) FREE THE CPOOL\n         J     FR0100              GO FREE THE NEXT CPOOL\nFR0200   RETURN (14,12),T          RESTORE REGS & RETURN\n         SPACE 1\nROUND8   DC    F'-8'\n         DROP  10\n         SPACE 5\n         CNOP  0,8\n*        PUSH  USING\n*        DROP  ,\nL        USING DS,14\nR        USING DS,1\nSORTCMP1 SAVE  14\n         LM    14,15,0(1)\n         L     14,0(,14)\n         L     1,0(,15)\n         LA    15,1\n         L     0,R.DSRCOUNT\n         C     0,L.DSRCOUNT\n         JL    SC0200\n         JH    SC0300\n         CLC   L.DSDSN,R.DSDSN\n         JL    SC0200\n         JH    SC0300\n         J     SC0100\n         SPACE 5\nL        USING REF,14\nR        USING REF,1\nSORTCMP2 SAVE  14\n         LM    14,15,0(1)\n         L     14,0(,14)\n         L     1,0(,15)\n         LA    15,1\n         CLC   R.REFFLAG,L.REFFLAG\n         JL    SC0200\n         JH    SC0300\n         L     14,L.REFJOB\n         L     1,R.REFJOB\nL        USING AJOB,14\nR        USING AJOB,1\n         CLC   L.AJUSER,R.AJUSER\n         JL    SC0200\n         JH    SC0300\n         J     SC0100\n         SPACE 3\n         CNOP  0,8\nL        USING AJOB,14\nR        USING AJOB,1\nSORTCMP3 SAVE  14\n         LM    14,15,0(1)\n         L     14,0(,14)\n         L     1,0(,15)\n         LA    15,1\n*        CP    L.AJRDATE,R.AJRDATE\n*        JL    SC0200\n*        JH    SC0300\n*        L     0,L.AJRTIME\n*        C     0,R.AJRTIME\n*        JL    SC0200\n*        JH    SC0300\n         CLC   L.AJOBNAME,R.AJOBNAME\n         JL    SC0200\n         JH    SC0300\n         CP    L.AJRDATE,R.AJRDATE\n         JL    SC0200\n         JH    SC0300\n         L     0,L.AJRTIME\n         C     0,R.AJRTIME\n         JL    SC0200\n         JH    SC0300\n         J     SC0100\n         SPACE 5\n         CNOP  0,8\nL        USING DS,14\nR        USING DS,1\nSORTCMP4 SAVE  14\n         LM    14,15,0(1)\n         L     14,0(,14)\n         L     1,0(,15)\n         LA    15,1\n         CLC   L.DSDSN,R.DSDSN\n         JL    SC0200\n         JH    SC0300\n         J     SC0100\n         SPACE 5\nL        USING AUSER,14\nR        USING AUSER,1\n         CNOP  0,8\nSORTCMP5 SAVE  14\n         LM    14,15,0(1)\n         L     14,0(,14)\n         L     1,0(,15)\n         LA    15,1\n         CLC   L.AUUSER,R.AUUSER\n         JL    SC0200\n         JH    SC0300\n         J     SC0100\n         SPACE 5\n         CNOP  0,8\nL        USING UREF,14\nR        USING UREF,1\nSORTCMP6 SAVE  14\n         LM    14,15,0(1)\n         L     14,0(,14)\n         L     1,0(,15)\n         LA    15,1\n         L     14,L.URDS\n         L     1,R.URDS\nL        USING DS,14\nR        USING DS,1\n         CLC   L.DSDSN,R.DSDSN\n         JL    SC0200\n         JH    SC0300\n*        J     SC0100\nSC0100   SR    15,15\n         J     SC0300\nSC0200   LNR   15,15\nSC0300   RETURN 14,RC=(15)\n         DROP  L,R\n         DC    0D'0'\n         EJECT\nDSREFD   CSECT\nOELINES  DC    0XL256'0'\n* These statements depend on the EBCDIC collating sequence\n         DC    (C' ')X'FF',AL1(1) Blank < + < - < 0              1 OF 5\n         DC    (C'+'-(*-OELINES))X'FF',AL1(0)                    2 OF 5\n         DC    (C'-'-(*-OELINES))X'FF',AL1(3)                    3 OF 5\n         DC    (C'0'-(*-OELINES))X'FF',AL1(2)                    4 OF 5\n         DC    (256-(*-OELINES))X'FF'                            5 OF 5\nTESTNUM  DC    0XL256'0',(C'0')X'04',10X'00',(256-(*-TESTNUM))X'04'\nSAVEAREA DC    (5*9)D'0'           5 72 byte OS/360 save areas\nFMTWORK  DC    XL200'0'            MINIFMT work area\nLASTUSER DC    CL8' '\nLOWTIME  DC    0XL8'0',X'7FFFFFFF',PL4'999365'\nHIGHTIME DC    0XL8'0',F'0',PL4'1'\nRCOUNT   DC    F'0'\nDSLIST   DC    A(*-*)\nJOBLIST  DC    A(*-*)\nUSERLIST  DC   A(*-*)\nSORTPARM CALL  ,(DSLIST,SORTOFF,SORTCMP1),MF=L\nSORTOFF  DC    A(*-*)\nCPLIST   DC    A(*-*)              ADDRESS OF FIRST SUBPOOL\nLINECT   DC    H'255',0F'0'        Initial page position\n         PUSH  PRINT\n         PRINT NOGEN\nOPARM01  OPEN  (PRINT,OUTPUT,SMF,INPUT),MF=L\nCPARM01  CLOSE (PRINT,,SMF),MF=L\nPRINT    DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=VBA,LRECL=125\nSMF      DCB   DSORG=PS,MACRF=GL,DDNAME=SMF,BFTEK=A,EODAD=EOF\n         POP   PRINT\n         DC    0D'0'\n         LTORG ,\nPSTAB    DC    AL1(6,JLIST,X'FF',JLIST,JLIST),C'JOBLIST'\n         DC    AL1(8,0,255-JLIST,JLIST,0),C'NOJOBLIST'\n         DC    AL1(7,WIDELINE,X'FF',WIDELINE,WIDELINE),C'WIDELINE'\n         DC    AL1(9,0,255-WIDELINE,WIDELINE,0),C'NOWIDELINE'\n*                                       ----+----1--\n         DC    AL1(11,SORTRCNT,X'FF',SORTRCNT,SORTRCNT),C'SORTREFCOUNT'\n*                                      ----+--\n         DC    AL1(6,0,255-SORTRCNT,SORTRCNT,0),C'SORTDSN'\n*        DC    AL1(7,ULIST,X'FF',ULIST,ULIST),C'USERLIST'  OPTIONS\n*        DC    AL1(9,0,255-ULIST,ULIST,0),C'NOUSERLIST'     DELETED\n         DC    X'FF'\nOPTION   DC    AL1(SORTRCNT)\nJLIST    EQU   X'80'\nWIDELINE EQU   X'40'\nSORTRCNT EQU   X'20'\nULIST    EQU   X'08'\nLEFT     EQU   ((120-L'HDR)/2)+1\nRIGHT    EQU   111-LEFT-L'HDR\nPAGEHDR  DC    AL2(PAGEHDRL,0),CL(LEFT)'1(DSREF &SYSDATE &SYSTIME)'\nHDR      DC    C'D A T A   S E T   U S A G E    B Y   U S E R'\n         DC    CL(RIGHT)' '\n         DC    C'PAGE'\nPAGE#    DC    C' NNNNN'\nPAGEHDRL EQU   *-PAGEHDR\nPAGENUM  DC    P'00000'\n         SPACE 1\nC0       EQU   X'C0'\nFMT01    DC    AL.2(2),AL.6(4),AL1(1,1),X'FF' Format system date & time\n         SPACE 1\nFMT02    DC    AL1(L'FMT02A)\nFMT02A   DC    C' THERE ARE NO VALID RECORDS IN THE SMF DATA SET',X'FF'\n         SPACE 1\nFMT03    DC    AL1(L'FMT03A)\nFMT03A   DC    C' SMF DATA FROM '\n         DC    AL1(C0+5,1,3),SL2(LOWTIME)\n         DC    AL1(4),CL4' TO '\n         DC    AL1(C0+5,1,3),SL2(HIGHTIME),X'FF'\n         SPACE 1\n         USING DS,2\nFMT04    DC    AL1(1),C' '\n         DC    AL1(C0+0,L'DSDSN,L'DSDSN),SL2(DSDSN)\n         DC    AL1(C0+1,L'DSRCOUNT,6),SL2(DSRCOUNT),X'FF'\n         DROP  2\n         SPACE 1\n         USING AJOB,2\nFMT05    DC    AL1(X'80'+0,L'CC,L'CC),AL4(CC)\n         DC    AL1(C0+0,L'AJOBNAME,L'AJOBNAME+1),SL2(AJOBNAME)\n         DC    AL1(C0+5,1,3),SL2(AJRTIME)\n         DC    AL1(1),C' '\n         DC    AL1(C0+0,L'AJUSER,0),SL2(AJUSER),X'FF'\n         DROP  2\n         SPACE 1\nFMT06    DC    AL1(1),C'-'\n         DC    AL1(C0+10,4,0),SL2(28(13))\n         DC    AL1(L'FMT06B)\nFMT06B   DC    C'K BYTES OF STORAGE ALLOCATED',X'FF'\n         SPACE 1\n         USING AUSER,2\nFMT07    DC    AL1(X'80'+0,L'CC,L'CC),AL4(CC)\n         DC    AL1(C0+0,L'AUUSER,0),SL2(AUUSER),X'FF'\n         DROP  2\n         SPACE 1\nCC       DC    C' '\n         SPACE 1\nHASHJOB  DC    31A(*-*)\nHJOBNO   EQU   (*-HASHJOB)/L'HASHJOB\n         SPACE 1\nHASHUSER DC    31A(*-*)\nHUSERNO  EQU   (*-HASHUSER)/L'HASHUSER\n         SPACE 1\nHASHDS   DC    31A(*-*)\nHDSNO    EQU   (*-HASHDS)/L'HASHDS\n         SPACE 1\n         DC    0D'0'\nDSREF    RSECT\n         SPACE 2\n         PUSH  PRINT\n         PRINT NOGEN\n         DCBD  DSORG=QS,DEVD=DA\n         SPACE 2\nCPOOL    DSECT                     CELL POOL CONTAINER\nCPNEXT   DS    A                   ADDRESS OF THE NEXT CONTAINER\nCPSIZE   DS    F                   BYTES ALLOCATED FOR THIS SUBPOOL\nCPLEFT   DS    F                   FREE BYTES LEFT IN THIS CONTAINER\nCPNEXTA  DS    A,0D                ADDRESS OF FIRST FREE BYTE\nCPSTART  EQU   *\n         SPACE 2\nSMFREC   DSECT\nSMFRDW   DS    2AL2,AL1\nSMFRTYP  DS    AL1\nSMFRTME  DS    FL4\nSMFRDTE  DS    PL4\nMINSIZE  EQU   *-SMFREC\n         ORG   SMFREC\n         IFASMFR 14\n         ORG   SMFREC\n         IFASMFR 30\n         EJECT\nDS       DSECT\nDSNEXT   DS    A\nDSDSN    DS    CL44\nDSREFLST DS    A\nDSRCOUNT DS    F\n         DS    0D\nDSSIZE   EQU   *-DS\n         SPACE 2\nREF      DSECT\nREFNEXT  DS    A\nREFTIME  DS    F\nREFDATE  DS    PL4\nREFJOB   DS    A\nREFFLAG  DS    AL1\nREFOUTPUT EQU  X'80'\n         DS    0D\nREFSIZE  EQU   *-REF\n         SPACE 2\nAJOB     DSECT\nAJNEXT   DS    A\nAJOBNAME DS    CL8\nAJRTIME  DS    F\nAJRDATE  DS    PL4\nAJKEY    EQU   AJOBNAME,*-AJOBNAME\nAJUSER   DS    CL8\n         DS    0D\nAJSIZE   EQU   *-AJOB\n         SPACE 2\nAUSER    DSECT\nAUNEXT   DS    A\nAUUSER   DS    CL8\nAUREFLST DS    A\n         DS    0D\nAUSIZE   EQU   *-AUSER\n         SPACE 2\nUREF     DSECT\nURNEXT   DS    A\nURDS     DS    A\n         DS    0D\nURSIZE   EQU   *-UREF\n         SPACE 2\nJFCB     DSECT\n         IEFJFCBN ,\n         POP   PRINT\n         END   DSREF\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTALL": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00U\\x01\\x17\\x10\\x7f\\x01\\x17\\x10\\x7f\\x14V\\x00\\x1d\\x00\\x1d\\x00\\x00\\xd4\\xe5\\xe2\\xd7\\xd9\\xd6\\xc7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-04-17T00:00:00", "modifydate": "2017-04-17T14:56:55", "lines": 29, "newlines": 29, "modlines": 0, "user": "MVSPROG"}, "text": "//ASMAC   PROC M='?'\n//C       EXEC PGM=ASMA90,PARM='OBJECK,NODECK,XREF(SHORT)'\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(SHR,PASS),DSN=SYS1.MACLIB\n//SYSLIN   DD  DISP=OLD,DSN=&SYSUID..DSREF.CBT.OBJ(&M)\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSIN    DD  DISP=(SHR,PASS),DSN=&SYSUID..DSREF.CBT.PDS(&M)\n//        PEND\n//A       EXEC PGM=IEFBR14\n//LOAD     DD  DISP=(MOD,DELETE),UNIT=SYSALLDA,SPACE=(TRK,0),\n//             DSN=&SYSUID..DSREF.CBT.LOAD\n//OBJ      DD  DISP=(MOD,DELETE),UNIT=SYSALLDA,SPACE=(TRK,0),\n//             DSN=&SYSUID..DSREF.CBT.OBJ\n//B       EXEC PGM=IEFBR14\n//LOAD     DD  DISP=(,CATLG),UNIT=SYSDA,SPACE=(TRK,(3,1,1)),\n//             DSN=*.A.LOAD\n//OBJ      DD  DISP=(,CATLG),UNIT=SYSDA,SPACE=(TRK,(3,1,1)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),DSN=*.A.OBJ\n//DSREF   EXEC ASMAC,M=DSREF\n//QSORTS  EXEC ASMAC,M=QSORTS\n//MINIFMT EXEC ASMAC,M=MINIFMT\n//LINK    EXEC PGM=IEWL,PARM='MAP,LIST'\n//SYSPRINT DD  SYSOUT=*\n//SYSLMOD  DD  DISP=OLD,DSN=*.A.LOAD\n//OBJ      DD  DISP=OLD,DSN=*.A.OBJ\n//SYSLIN   DD  *\n       INCLUDE OBJ(DSREF,MINIFMT,QSORTS)\n         ENTRY DSREF\n          NAME DSREF(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOADMOD": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x009\\x01\\x17\\x10\\x8f\\x01\\x17\\x10\\x8f\\x101\\x00\\x8c\\x00\\x8c\\x00\\x00\\xd4\\xe5\\xe2\\xd7\\xd9\\xd6\\xc7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-04-18T00:00:00", "modifydate": "2017-04-18T10:31:39", "lines": 140, "newlines": 140, "modlines": 0, "user": "MVSPROG"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "MINIFMT": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00I\\x01\\x17\\x10\\x7f\\x01\\x17\\x10\\x7f\\x14 \\x03\\xa9\\x03\\xa9\\x00\\x00\\xd4\\xe5\\xe2\\xd7\\xd9\\xd6\\xc7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-04-17T00:00:00", "modifydate": "2017-04-17T14:20:49", "lines": 937, "newlines": 937, "modlines": 0, "user": "MVSPROG"}, "text": "MINIFMT  TITLE '                                  MINIFMT - A Message G>\n               enerator'\n***********************************************************************\n*                                                                     *\n* Title -- MINIFMT                                                    *\n*                                                                     *\n* Function / Operation -- MINIFMT is a message generator program.  It *\n*   is a proper superset of MICROFMT; all valid MICROFMT formats will *\n*   produce the same results as MICROFMT.  Additional formatting      *\n*   includes date and time formats, formats to translate the record   *\n*   formats included with the DCB and Format 1 DSCBs, the DSORG in    *\n*   the DCB and Format 1 DSCBs, and tabs and multiple space inserts.  *\n*                                                                     *\n* Status / Change Level --                                            *\n*   V1L5 -- September 2016                                            *\n*    - CNVTBIN rewritten to improve performance and reduce storage    *\n*      foot print                                                     *\n*      - Fewer registers saved / restored                             *\n*      - One divide / multiply pair eliminated                        *\n*      - Last multiply of hours by 1,000,000 changed to               *\n*        two MHI reg,1000 to eliminate a SR and the storage for       *\n*        F'1000000'.                                                  *\n*      - Method to strip the packed decimal sign from the result      *\n*        simplified.                                                  *\n*    - Copyright added to SAVE macro                                  *\n*   V1L4 -- January 2015                                              *\n*    - Added LJUSTX external function to left justify the contents    *\n*      of a text data srea.                                           *\n*   V1L3 -- November 2014                                             *\n*    - Add formst 10, a binary to decimal conversion that inserts ,   *\n*      characters between every 3 digits, e.g., 1,035 rather than     *\n*      1035, to make large numbers easier to read.                    *\n*   V1L2 -- June 2010                                                 *\n*    - Hex conversion for fields containing more than 7 bytes not     *\n*      being done correctly                                           *\n*   V1L1 -- June 2010                                                 *\n*    - Blank not being inserted between the date and time for format  *\n*      codes 4 and 5 if both a date code and time code are specified  *\n*    - Tab problem                                                    *\n*   V1L0 -- April 2010                                                *\n*                                                                     *\n* Calling sequence --                                                 *\n*            LA    0,FMTWORK                                          *\n*            LA    1,FORMAT                                           *\n*            L     15,=V(MINIFMT)      MINIFMT CAN ALSO BE CALLED     *\n*            BALR  14,15               USING BRAS OR BRASL            *\n*            ...                                                      *\n*   FMTWORK  DC    XL200'0'                                           *\n*   FORMAT   DC    -- Format Specifications --                        *\n*                                                                     *\n*   Returns -- Address of generated output line in register 1.        *\n*     All other registers are returned unchanged                      *\n*                                                                     *\n* Format Specification --                                             *\n*   A format consists of two or more field specifications.  There are *\n*   three types of field specifications --                            *\n*   - End of format -- X'FF' or X'00'                                 *\n*   - In line text -- AL1(length),C'in line text'                     *\n*     Length can be 1 to 127                                          *\n*   - Data conversion -- These data conversions are provided.         *\n*     . Character, for data areas from 1 to 255 bytes.                *\n*     . Binary to decimal, of unsigned 1, 2 and 3 byte fields, and    *\n*       signed 4 byte fields                                          *\n*     . Binary to hexadecimal, of data areas from 1 to 255 bytes. Two *\n*       output bytes for each input byte                              *\n*     . Insert blanks.                                                *\n*     . Format system date and time                                   *\n*     . Format date and time using a TIME DEC formatted date and      *\n*       time.                                                         *\n*     . Provide a tabbing capability                                  *\n*     Each data conversion is specified as a multiple byte format --  *\n*     Offset  Bit  Value Purpose                                      *\n*        0     0     1 -- Indicates data conversion                   *\n*        0     1     0 -- Address specified as an in-line 4 byte      *\n*                         address constant                            *\n*        0     1     1 -- Address specified as a 2 byte S type        *\n*                         address                                     *\n*                         The S-con base register can be registers 2  *\n*                         through 13.  Since registers 14, 15, 0 and  *\n*                         are used as link registers, their use in    *\n*                         an S-con is limited.                        *\n*        0    2-7    0 -- Copy text string to output line             *\n*                    1 -- Translate 1 to 4 byte binary to decimal     *\n*                    2 -- Translate 1 to 255 byte binary to           *\n*                         hexadecimal digits                          *\n*                    3 -- Provide input length for an undefined       *\n*                         text or  hexadecimal conversion             *\n*                    4 -- Format the system date and time.  The       *\n*                         input length byte specifies the date        *\n*                         format, the output length byte specifies    *\n*                         the time format.  MINIFMT obtains the       *\n*                         system date the first time this format is   *\n*                         encountered.                                *\n*                    5 -- Format the date and time in a TIME DEC      *\n*                         storage area                                *\n*                    6 -- Insert blanks                               *\n*                    7 -- Tab.  A tab to a position higher than the   *\n*                         current end of line inserts blanks.  The    *\n*                         position is relative to the first byte in   *\n*                         the line.                                   *\n*                    8 -- Translate DCBRECFM/DS1RECFM                 *\n*                    9 -- Translate DCBDSORG/DS1DSORG                 *\n*                   10 -- Tranalate 1 to 4 byte binary to decimal     *\n*                         using an alternate format, nnn,nnn rather   *\n*                         than nnnnnn                                 *\n*        1    0-7    Input length.                                    *\n*                    For codes 4 and 5, this byte contains a date     *\n*                    format code --                                   *\n*                     1 -- yyyy/mm/dd                                 *\n*                     2 -- yy/mm/dd                                   *\n*                     3 -- mm/dd/yyyy                                 *\n*                     4 -- mm/dd/yy                                   *\n*                     5 -- yyyy month dd                              *\n*                     6 -- yy month dd                                *\n*                     7 -- month dd, yyyy                             *\n*                     8 -- yyyy                                       *\n*                     9 -- yy                                         *\n*                    10 -- mm    (Month as a two digit number)        *\n*                    11 -- mmm   (Abbreviated month name)             *\n*                    12 -- month (Full month name)                    *\n*                    13 -- dd    (Day of month)                       *\n*                    14 -- ddd   (Day of year)                        *\n*                                                                     *\n*                    Date codes that insert a 2 digit year makes      *\n*                    your program Y2K conpatible if it is Y2K         *\n*                    compliant in all other aspects                   *\n*                                                                     *\n*        2    0-7    Output length.  Not used for hex conversion.  If *\n*                    0 is specified, for binary to decimal conversion *\n*                    the output length is the length of the converted *\n*                    number, for character conversion the output      *\n*                    length is the input length with trailing blanks  *\n*                    removed                                          *\n*                                                                     *\n*                    For codes 4 and 5, this byte contains a time     *\n*                    format code --                                   *\n*                     1 -- hh:mm       (24 hour clock)                *\n*                     2 -- hh:mm xM    (xM is AM or PM)               *\n*                     3 -- hh:mm:ss    (24 hour clock)                *\n*                     4 -- hh:mm:ss xM (xM is AM or PM)               *\n*                                                                     *\n*                    If a date code and a time code are both          *\n*                    present, a blank appears between the date and    *\n*                    time.                                            *\n*                                                                     *\n*        3           Data address, as either a 2-bye S type address   *\n*                    or a 4 byte address constant.                    *\n*                                                                     *\n* Attributes -- MINIFMT is reenterable, refreshable and reusable.  It *\n*   operates in any key, problem or supervisor state.  It is  not     *\n*   intended to operate in AR mode or the 64-bit addressing mode.  It *\n*   will operate in the 24-bit addressing mode if the format, work    *\n*   area, and any data referenced in the format is in the 24-bit      *\n*   residence area.                                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 5\nMINIFMT  RSECT\nMINIFMT  AMODE ANY\nMINIFMT  RMODE ANY\n         PUSH  PRINT\n         PRINT NOGEN\n         DCBD  DSORG=QS,DEVD=DA    DEFINE DCB SYMBOLS\n         POP   PRINT\nMFMTWORK DSECT\nMFMTWWRK DS    D                   DOUBLE WORD ALIGNED 8 BYTE WORK AREA\nMFMTWDT  DS    2F                  SYSTEM DATE AND TIME\nMFMTWEWK DS    0C' 999999999999999'\nMFMTWLNG DS    C' 999,999,999,999,999'\nMFMTWLEN DS    AL1                 LENGTH FROM FORMAT 3\nMFMTWFLG DS    AL1                 NON-ZERO IF SYSTEM DATE AND TIME   ->\n                                    STORED IN MFMFWDT\nMFMTSAVE DS    AL1,0F\nMFMTWLNE DS    2AL2                GENERATED OUTPUT LINE\nMINIFMT  RSECT\n         BASR  15,0                STORE CURRENT ADDRESS IN REG 15\n         USING *,12                ESTABLISH PROGRAM BASE REGISTER\n         USING MFMTWORK,11         ESTABLISH WORK AREA ADDRESSABILITY\n*        SAVE  (14,12),,MINIFMT-V1L4-&SYSDATE-&SYSTIME  SAVE REGISTERS\n         SAVE  (14,12),,'MINIFMT V1L5 &SYSDATE &SYSTIME  Copyright (c) >\n               2010, 2014-2016 J. Stephen Myers'\n         LR    12,15               COPY ENTRY POINT ADDRESS TO REG 12\n         LR    11,0                COPY WORK AREA ADDRESS TO REG 11\n         MVI   MFMTWFLG,0          INDICATE SYSTEM DATE AND TIME NOT  ->\n                                    IN WORKAREA\n         LR    3,1                 COPY ADDRESS OF FORMAT TO REG 3\n         LA    14,MFMTWLNE+4       LOAD START OF TEXT OUTPUT\nMFMT0100 CLI   0(3),X'FF'          TEST IF END OF FORMAT\n         JE    MFMT7600\n         CLI   0(3),0\n         JE    MFMT7600\n         TM    0(3),X'80'          TEST IF DATA CONVERSION\n         JO    MFMT0200            BR IF SO\n         SR    15,15               SET REG 15 = 0\n         IC    15,0(,3)            LOAD LENGTH OF IN-LINE CHARACTER   ->\n                                    STRING\n         LA    0,1(,3)             LOAD START OF IN-LINE CHARACTER    ->\n                                    STRING\n         LR    1,15                COPY LENGTH TO REG 1\n         MVCL  14,0                COPY IN-LINE CHARACTER STRING TO   ->\n                                    NEW LINE\n         LR    3,0                 COPY START OF NEXT FORMAT TO REG 3\n         J     MFMT0100            GO CHECK THE NEXT FORMAT\nMFMT0200 IC    15,0(,3)            LOAD FORMAT TYPE\n         N     15,=A(X'3F')        ISOLATE TYPE\n         CHI   15,10               COMPARE WITH MAX\n         JH    MFMT7500            BR TO FORMAT ERROR\n         SLL   15,2                MULTIPLY TYPE BY 4\n         B     *+4(15)             BR TO JUMP TABLE ENTRY\n         J     MFMT0400            TYPE 0 - CHARACTER\n         J     MFMT0800            TYPE 1 - BINARY TO DECIMAL\n         J     MFMT1200            TYPE 2 -BINARY TO HEXADECIMAL DIGITS\n         J     MFMT0300            TYPE 3 - SAVE LENGTH FOR TYPES 0 & 2\n         J     MFMT1700            TYPE 4 - FORMAT SYSTEM DATE AND TIME\n         J     MFMT1900            TYPE 5 - FORMAT DATE AND TIME\n         J     MFMT6500            TYPE 6 - INSERT BLANKS\n         J     MFMT7300            TYPE 7 - TAB\n         J     MFMT6600            TYPE 8 - TRANSLATE DCBRECFM\n         J     MFMT6900            TYPE 9 - TRANSLATE DCBDSORG\n         J     MFMT0810            TYPE 10 - ALTERNATE TYPE 2\n*        J     MFMT7500            TYPE 11 NOT SUPPORTED\n*        J     MFMT7500            TYPE 12 NOT SUPPORTED\n*        J     MFMT7500            TYPE 13 NOT SUPPORTED\n*        J     MFMT7500            TYPE 14 NOT SUPPORTED\n*        J     MFMT7500            TYPE 15 NOT SUPPORTED\nMFMT0300 LA    1,3(,3)             LOAD ADDRESS OF DATA ADDRESS\n         BRAS  15,MFMT5900         GET THE ADDRESS\n         MVC   MFMTWLEN,0(4)       SAVE THE LENGTH\n         J     MFMT0100            GO DO THE NEXT FORMAT\nMFMT0400 LA    1,3(,3)             LOAD ADDRESS OF DATA ADDRESS\n         SR    5,5                 SET REG 5 = 0\n         SR    6,6                 SET REG 6 = 0\n         ICM   5,B'0001',1(3)      LOAD THE INPUT LENGTH\n         JNZ   *+L'*+4             BR IF INPUT LENGTH IS DEFINED\n         IC    5,MFMTWLEN          LOAD SAVED LENGTH\n         IC    6,2(,3)             LOAD THE OUTPUT LENGTH\n         BRAS  15,MFMT5900         GET THE ADDRESS\n         LTR   15,6                TEST IF OUTPUT LENGTH IS SPECIFIED\n         JZ    MFMT0500            BR IF NOT\n         LR    0,4                 COPY START OF DATA TO REG 0\n         LR    1,5                 COPY INPUT LENGTH TO REG 1\n*        ICM   1,B'1000',=C' '     LOAD FILL CHARACTER\n         O     1,=AL1(C' ',0,0,0)  ADD FILL CHARACTER\n         MVCL  14,0                COPY DATA TO OUTPUT AREA\n         J     MFMT0100            GO DO THE NEXT FORMAT\nMFMT0500 LA    15,0(5,4)           PUT END OF INPUT AREA INTO REG 15\nMFMT0600 AHI   15,-1               BACKUP 1 BYTE\n         CR    15,4                TEST IF START OF DATA\n         JE    MFMT0700            BR IF SO\n         CLI   0(15),C' '          TEST IF TRAILING BLANK\n         JE    MFMT0600            BR IF SO\nMFMT0700 LA    1,1(,15)            SET REG 1 TO END OF INPUT\n         SR    1,4                 COMPUTE ACTUAL INPUT LENGTH\n         LR    0,4                 COPY START OF INPUT TO REG 0\n         LR    15,1                COPY LENGTH TO REG 15\n         MVCL  14,0                COPY TEXT TO OUTPUT LINE\n         J     MFMT0100            GO DO THE NEXT FORMAT\nMFMT0800 DC    0H'0'\nMFMT0810 MVC   MFMTSAVE,0(3)       SAVE THE ENTRY CODE\n         NI    MFMTSAVE,X'3F'      DISCARD THE 2 HIGH ORDER BITS\n         LA    1,3(,3)             LOAD ADDRESS OF DATA ADDRESS\n         SR    5,5                 SET REG 5 = 0\n         SR    6,6                 SET REG 6 = 0\n         IC    5,1(,3)             LOAD THE INPUT LENGTH\n         IC    6,2(,3)             LOAD THE OUTPUT LENGTH\n         BRAS  15,MFMT5900         GET THE ADDRESS\n         SLL   5,2                 MULTIPLY LENGTH BY 4\n         SR    15,15               SET REG 15 = 0\n         EX    0,MFMT6400(5)       LOAD THE BINARY VALUE\n         CVD   15,MFMTWWRK         CONVERT MFMT0800 VALUE TO PACKED   ->\n                                    DECIMAL\n         CLI   MFMTSAVE,1          TEST FORMAT CODE\n         JE    MFMT0820            BR IF FORMAT 1\n         MVC   MFMTWLNG,MFMT8310   COPY THE ALTERNATE EDIT MASK\n         LA    1,MFMTWLNG+L'MFMTWLNG-1  LOAD ADDR OF THE DEFAULT 0\n         EDMK  MFMTWLNG,MFMTWWRK   EDIT THE NUMBER\n         J     MFMT0830\nMFMT0820 MVC   MFMTWEWK,MFMT8300   COPY EDIT MASK TO WORK AREA\n         LA    1,MFMTWEWK+L'MFMTWEWK-1\n         EDMK  MFMTWEWK,MFMTWWRK   CONVERT PACKED DECIMAL VALUE TO    ->\n                                    DECIMAL DIGITS\nMFMT0830 LTR   15,15               TEST VALUE\n         JNM   MFMT0900            BR IF VALUE IS +\n         AHI   1,-1                BACKUP START OF NUMBER BY 1\n         MVI   0(1),C'-'           INSERT A MINUS SIGN\nMFMT0900 LR    0,1                 COPY START OF VALUE TO REG 0\n         LA    1,MFMTWEWK+L'MFMTWEWK  LOAD END OF VALUE\n         CLI   MFMTSAVE,1          ALTERNATE FORMAT?\n         JE    *+L'*+4             BR IF NOT\n         LA    1,MFMTWLNG+L'MFMTWLNG  LOAD ALTERNATE END\n         SR    1,0                 COMPUTE LENGTH OF NUMBER\n         LTR   6,6                 TEST OUTPUT LENGTH\n         JZ    MFMT1100            BR IF 0\n         CR    6,1                 COMPARE OUTPUT LENGTH WITH MAX\n         JNL   MFMT1000            BR IF NUMBER WILL FIT IN FIELD\n         LR    15,6                COPY LENGTH TO REG 15\n         L     1,=AL1(C'*',0,0,0)  LOAD FILL CHARACTER\n         MVCL  14,0                INSERT *S IN THE OUTPUT FIELD\n         J     MFMT0100            GO DO THE NEXT FORMAT\nMFMT1000 LR    5,14                SAVE ADDRESS OF OUTPUT\n         L     7,=AL1(C' ',0,0,0)  LOAD FILL CHARACTER\n         LR    15,6                COPY FIELD LENGTH TO REG 15\n         MVCL  14,6                CLEAR THE OUTPUT FIELD\n         LR    14,5                COPY START OF OUTPUT FIELD TO REG 14\n         LR    15,6                COPY OUTPUT FIELD LENGTH TO REG 15\n         SR    15,1                COMPUTE NUMBER OF LEADING BLANKS\n         AR    14,15               COMPUTE START OF NUMBER IN OUTPUT\nMFMT1100 LR    15,1                COPY LENGTH TO REG 15\n         MVCL  14,0                COPY CONVERTED VALUE TO OUTPUT\n         J     MFMT0100            GO DO THE NEXT FORMAT\n* TRANSLATE INPUT BINARY DATA TO HEXADECIMAL DIGITS\n* JUST THE INPUT LENGTH IS USED, AN OUTPUT LENGTH IS IGNORED\nMFMT1200 LA    1,3(,3)             LOAD ADDRESS OF ADDRESS\n         SR    5,5                 SET REG 5 = 0\n         ICM   5,B'0001',1(3)      LOAD THE INPUT LENGTH\n         JNZ   *+L'*+4             BR IF INPUT LENGTH IS DEFINED\n         IC    5,MFMTWLEN          LOAD SAVED INPUT LENGTH\n         BRAS  15,MFMT5900         GET THE ADDRESS\nMFMT1300 CHI   5,7                 TEST REMINING LENGTH\n         JNH   MFMT1400            BR IF 7 OR FEWER BYTES REMAIN\n         UNPK  0(15,14),0(8,4)     TRANSLATE 7 BYTES TO HEX DIGITS\n         TR    0(14,14),MFMT8200\n         AHI   14,14               BUMP THE OUTPUT POINTER\n         AHI   4,7                 BUMP THE INPUT POINTER\n         AHI   5,-7                REDUCE REMAINING LENGTH BY 7\n         J     MFMT1300            GO DO THE NEXT GROUP\nMFMT1400 LR    1,5                 COPY REMAINING LENGTH TO REG 1\n         SLL   1,5                 GET OUTPUT LENGTH\n         OR    1,5                 ADD IN INPUT LENGTH\n         EX    1,MFMT1500          TRANSLATE LAST GROUP OF BYTES\n         SRL   1,4                  TO HEXADECIMAL DIGITS\n         EX    1,MFMT1600\n         AR    14,1                UPDATE THE OUTPUT POINTER\n         J     MFMT0100            GO CHECK THE NEXT FORMAT\nMFMT1500 UNPK  0(*-*,14),0(*-*,4)  ** EXECUTE ONLY **\nMFMT1600 TR    0(*-*,14),MFMT8200  ** EXECUTE ONLY **\n* FORMAT SYSTEM DATE AND TIME\nMFMT1700 CLI   MFMTWFLG,0          TEST IF SYSTEM TIME OBTAINED\n         JNE   MFMT1800            BR IF SO\n         ST    14,MFMTWDT          SAVE REG 14\n         TIME  DEC                 GET THE SYSTEM DATE AND TIME\n         L     14,MFMTWDT          RESTORE REG 14\n         STM   0,1,MFMTWDT         STORE THE DATE AND TIME\n         MVI   MFMTWFLG,255        INDICATE DATE AND TIME IN WORK AREA\nMFMT1800 SR    5,5                 SET REG 5 = 0\n         SR    6,6                 SET REG 6 = 0\n         IC    5,1(,3)             LOAD THE DATE CODE\n         IC    6,2(,3)             LOAD THE TIME CODE\n         LA    3,3(,3)             LOAD ADDRESS OF THE NEXT FORMAT\n         LA    4,MFMTWDT           LOAD ADDRESS OF THE DATE AND TIME\n         J     MFMT2000            BR TO DATE/TIME COMMON CODE\n* FORMAT DATE AND TIME FROM STORAGE REPRESENTING REG 0 AND REG 1\n* AFTER EXECUTING A TIME DEC MACRO\nMFMT1900 SR    5,5                 SET REG 5 = 0\n         SR    6,6                 SET REG 6 = 0\n         IC    5,1(,3)             LOAD THE DATE CODE\n         IC    6,2(,3)             LOAD THE TIME CODE\n         LA    1,3(,3)             LOAD THE ADDRESS OF THE ADDRESS\n         BRAS  15,MFMT5900         GET THE DATA AREA ADDRESS\nMFMT2000 LTR   5,5                 TEST IF DATE WANTED\n         JZ    MFMT5010            BR IF NOT\n         ICM   9,B'1111',4(4)      LOAD THE DATE\n         JNZ   MFMT2010            BR IF DATE IS PRSENT\n         SR    1,1                 SET DAY OF MONTH = 0\n         SR    8,8                 SET MONTH = 0\n         MVC   MFMTWEWK+L'MFMTWEWK-3-4(4),=C'0000' SET YEAR IN MFMTWEWK\n         J     MFMT2210            AND CONTINUE\nMFMT2010 ZAP   MFMTWWRK,4(4,4)     COPY THE DATE TO THE WORK AREA\n         CVB   9,MFMTWWRK          CONVERT THE DATE TO BINARY\n         A     9,=F'1900000'       CONVERT THE YEAR FROM CYY TO A     ->\n                                    TRUE YEAR\n         CVD   9,MFMTWWRK          CONVERT YYYYDDD TO PACKED DECIMAL\n         UNPK  MFMTWEWK,MFMTWWRK   CONVERT YYYYDDD TO DECIMAL.  THE   ->\n                                    DDD IS NOT USABLE, BUT THE YYYY IS\n         SR    8,8                 SET REG 8 = 0\n         D     8,=F'1000'          ISOLATE THE YEAR\n         LR    1,8                 COPY THE DAY OF YEAR TO REG 1\n         SR    8,8                 SET REG 8 = 0\n         LR    0,9                 COPY YEAR TO REG 0\n         N     0,=A(B'11')         TEST IF YEAR DIVISIBLE BY 4\n         JNZ   MFMT2100            BR IF NOT, IT CAN'T BE A LEAP YEAR\n         D     8,=F'100'           DIVIDE YEAR BY 100\n         LTR   8,8                 TEST REMAINDER\n         JNZ   MFMT2200            YEAR IS NOT A CENTURY YEAR, SO IT  ->\n                                    MUST BE A LEAP YEAR\n         N     9,=A(B'11')         TEST IF YEAR CAN BE DIVIDED BY 400\n         JZ    MFMT2200            CENTURY YEAR IS A LEAP YEAR\nMFMT2100 CHI   1,31+28             COMPARE DAY OF YEAR WITH FEB 28\n         JNH   MFMT2200            BR IF DAY OF YEAR DOES NOT HAVE    ->\n                                    TO BE ADJUSTED\n         AHI   1,1                 PRETEND DAY OF YEAR IS IN A LEAP   ->\n                                    YEAR\nMFMT2200 SR    8,8                 SET REG 8 = 0\n         IC    8,MFMT8600(1)       LOAD THE MONTH FOR THE DAY OF YEAR\n         SLL   8,1                 MULTIPLY MONTH BY 2\n         SH    1,MFMT8500(8)       SUBTRACT DAY OF YEAR FOR THE 1ST   ->\n                                    DAY OF THE MONTH FROM DAY OF YEAR\n         SRL   8,1                 RESET MONTH TO \"NORMAL\" FORM\n* DAY OF MONTH IS IN REG 1, MONTH IS IN REG 8, AND YEAR IN\n* CHARACTER FORM IS IN MFMTWEWK\nMFMT2210 SLL   5,2                 MULTIPLY DATE CODE BY 4\n         B     *(5)                BR\n         J     MFMT2300             1 -- FORMAT DATE AS YYYY/MM/DD\n         J     MFMT2400             2 -- FORMAT DATE AS YY/MM/DD\n         J     MFMT2600             3 -- FORMAT DATE AS MM/DD/YYYY\n         J     MFMT2700             4 -- FORMAT DATE AS MM/DD/YY\n         J     MFMT2900             5 -- FORMAT DATE AS YYYY MONTH DD\n         J     MFMT3000             6 -- FORMAT DATE AS YY MONTH DD\n         J     MFMT3200             7 -- FORMAT DATE AS MONTH DD, YYYY\n         J     MFMT3300             8 -- FORMAT YEAR AS YYYY\n         J     MFMT3400             9 -- FORMAT YEAR AS YY\n         J     MFMT3500            10 -- FORMAT MONTH AS MM (NUMERIC)\n         J     MFMT3600            11 -- FORMAT MONTH AS MMM\n         J     MFMT3700            12 -- FORMAT MONTH AS MONTH\n         J     MFMT3710            13 -- FORMAT DAY OF MONTH AS DD\n         J     MFMT3720            14 -- FORMAT DAY OF YEAR\n         J     MFMT7500            15 -- INVALID\nMFMT2300 ICM   15,B'1111',4(4)     LOAD THE DATE\n         JNZ   MFMT2310            BR IF DATE PRESENT\n         MVC   0(10,14),=CL10'--'  INDICATE MISSING DATE\n         AHI   14,10               BUMP OUTPUT\n         J     MFMT5000            TEST IF TIME\nMFMT2310 BRAS  15,MFMT3800         COPY THE 4 DIGIT YEAR\n         J     MFMT2500            AND CONTINUE\nMFMT2400 ICM   15,B'1111',4(4)     LOAD THE DATE\n         JNZ   MFMT2410            BR IF DATE PRESENT\n         MVC   0(8,14),=CL10'--'   INDICATE MISSING DATE\n         AHI   14,8                BUMP OUTPUT\n         J     MFMT5000            TEST IF TIME\nMFMT2410 BRAS  15,MFMT3900         COPY THE 2 DIGIT YEAR\nMFMT2500 BRAS  15,MFMT4000         INSERT A /\n         BRAS  15,MFMT4300         INSERT MM\n         BRAS  15,MFMT4000         INSERT A /\n         BRAS  15,MFMT4800         INSERT DD\n         J     MFMT5000            TEST IF TIME\nMFMT2600 ICM   15,B'1111',4(4)     LOAD THE DATE\n         JNZ   MFMT2610            BR IF DATE PRESENT\n         MVC   0(10,4),=CL10'--'   INDICATE MISSING DATE\n         AHI   14,10               BUMP OUTPUT\n         J     MFMT5000            TEST IF TIME\nMFMT2610 BRAS  15,MFMT4300         INSERT MM\n         BRAS  15,MFMT4000         INSERT A /\n         BRAS  15,MFMT4800         INSERT DD\n         BRAS  15,MFMT4000         INSERT A /\n         BRAS  15,MFMT3800         INSERT YYYY\n         J     MFMT5000            TEST IF TIME\nMFMT2700 ICM   15,B'1111',4(4)     LOAD THE DATE\n         JNZ   MFMT2710            BR IF DATE PRESENT\n         MVC   0(8,14),=CL10'--'   INDICATE MISSING DATE\n         AHI   14,8                BUMP OUTPUT\n         J     MFMT5000            TEST IF TIME\nMFMT2710 BRAS  15,MFMT4300         INSERT MM\n         BRAS  15,MFMT4000         INSERT A /\n         BRAS  15,MFMT4800         INSERT DD\n         BRAS  15,MFMT4000         INSERT A /\n         BRAS  15,MFMT3900         INSERT YY\n         J     MFMT5000            TEST IF TIME\nMFMT2800 NOPR  0                   ** NOT USED! **\nMFMT2900 ICM   15,B'1111',4(4)     LOAD THE DATE\n         JNZ   MFMT2910            BR IF DATE PRESENT\n         MVC   0(10,4),=CL10'--'   INDICATE MISSING DATE\n         AHI   14,10               BUMP OUTPUT\n         J     MFMT5000            TEST IF TIME\nMFMT2910 BRAS  15,MFMT3800         INSERT YYYY\n         J     MFMT3100\nMFMT3000 BRAS  15,MFMT3900         INSERT YY\nMFMT3100 BRAS  15,MFMT4100         INSERT A SPACE\n         BRAS  15,MFMT4400         INSERT LONG MONTH\n         BRAS  15,MFMT4100         INSERT A SPACE\n         BRAS  15,MFMT4800         INSERT DD\n         J     MFMT5000            TEST IF TIME\n* FORMAT MONTH DD, YYYY\nMFMT3200 BRAS  15,MFMT4400         INSERT A LONG MONTH\n         BRAS  15,MFMT4100         INSERT A SPACE\n         BRAS  15,MFMT4800         INSERT DD\n         BRAS  15,MFMT4210         INSERT C', '\n         BRAS  15,MFMT3800         INSERT YYYY\n         J     MFMT5000            TEST IF TIME\n* FORMAT YYYY\nMFMT3300 BRAS  15,MFMT3800         INSERT YYYY\n         J     MFMT5000            TEST IF TIME\n* FORMAT YY\nMFMT3400 BRAS  15,MFMT3900         INSERT YY\n         J     MFMT5000            TEST IF TIME\n* FORMAT MM (NUMERIC MONTH)\nMFMT3500 BRAS  15,MFMT4300         INSERT MM\n         J     MFMT5000            TEST IF TIME\n* FORMAT MMM (ABBREVIATED MONTH)\nMFMT3600 BRAS  15,MFMT4700         INSERT MMM\n         J     MFMT5000            TEST IF TIME\n* INSERT FULL MONTH NAME\nMFMT3700 BRAS  15,MFMT4400\n         J     MFMT5000            TEST IF TIME\n* INSERT DD\nMFMT3710 BRAS  15,MFMT4800         INSERT DD\n         J     MFMT5000            TEST IF TIME\n* INSERT DDD (DAY OF YEAR)\nMFMT3720 UNPK  MFMTWWRK,4(4,4)     CONVERT 0CYYDDD TO DECIMAL\n         OI    MFMTWWRK+7,X'F0'    MAKE SURE THE LAST BYTE IS A DIGIT\n         MVC   0(3,14),MFMTWWRK+5  COPY DDD TO OUTPUT\n         AHI   14,3                UPDATE THE OUTPUT POINTER\n         J     MFMT5000            TEST IF TIME\n* GET THE 4 DIGIT YEAR\nMFMT3800 MVC   0(4,14),MFMTWEWK+L'MFMTWEWK-3-4  COPY THE YEAR\n         AHI   14,4                BUMP THE OUTPUT POINTER\n         BR    15                  AND RETURN\n* GET THE 2 DIGIT YEAR\nMFMT3900 MVC   0(2,14),MFMTWEWK+L'MFMTWEWK-3-2  COPY THE YEAR\n         AHI   14,2                BUMP THE OUTPUT POINTER\n         BR    15                  AND RETURN\n* INSERT A /\nMFMT4000 MVI   0(14),C'/'          INSERT A /\n         J     MFMT4200            UPDATE POSITION AND RETURM\n* INSERT A SPACE\nMFMT4100 MVI   0(14),C' '          INSERT A BLANK\nMFMT4200 AHI   14,1                BUMP THE OUTPUT POINTER\n         BR    15                  AND RETURN\n* INSERT C', '\nMFMT4210 MVC   0(2,14),=C', '      COPY C', ' TO OUTPUT\n         AHI   14,2                UPDATE OUTPUT POINTER\n         BR    15                  AND RETURN\n* INSERT 2 DIGIT MONTH\nMFMT4300 CVD   8,MFMTWWRK          CONVERT MONTH TO PACKED DECIMAL\n         J     MFMT4900            CONTINUE\n* INSERT FULL MONTH NAME\nMFMT4400 LR    9,8                 COPY REG 8 TO REG 9\n         MHI   9,9                 MULTIPLY MONTH BY LENGTH OF A MONTH\n         LA    10,MFMT8700+9(9)    LOAD END OF MONTH NAME\n         LA    9,MFMT8700(9)       LOAD START OF THE MONTH NAME\nMFMT4500 BCTR  10,0                BACKUP 1 BYTE\n         CLI   0(10),C' '          TEST FOR TRAILING BLANK\n         JE    MFMT4500            BR IF TRAILING BLANK\n         SR    10,9                COMPUTE LENGTH TO MOVE\n         EX    10,MFMT4600         MOVE MONTH NAME TO OUTPUT LINE\n         LA    14,1(10,14)         COMPUTE ADDRESS OF NEXT OUTPUT BYTE\n         BR    15                  AND RETURN\nMFMT4600 MVC   0(*-*,14),0(9)      ** EXECUTE ONLY **\n* INSERT ABBREVIATED MONTH\nMFMT4700 LR    9,8                 COPY REG 8 TO REG 9\n         MHI   9,9                 MULTIPLY MONTH BY 9\n         LA    9,MFMT8700(9)       COMPUTE ADDRESS OF MONTH NAME\n         MVC   0(3,14),0(9)        COPY ABBREVIATED MONTH TO OUTPUT\n         AHI   14,3                UPDATE OUTPUT POSITION\n         BR    15                  AND RETURN\n* INSERT DAY OF MONTH\nMFMT4800 CVD   1,MFMTWWRK          CONVERT DAY OF MONTH TO PACKED DEC\nMFMT4900 OI    MFMTWWRK+7,X'0F'    MAKE SURE THE LAST NIBBLE IS OK\n         UNPK  0(2,14),MFMTWWRK    CONVERT VALUE TO DECIMAL\n         AHI   14,2                BUMP THE OUTPUT POINTER\n         BR    15                  AND RETURN\n* TEST IF TIME WANTED\nMFMT5000 LTR   6,6                 TEST TIME CODE\n         JZ    MFMT0100            BR IF TIME NOT WANTED\n         MVI   0(14),C' '          INSERT A BLANK\n         AHI   14,1                BUMP THE OUTPUT POSITION\n         J     MFMT5020\nMFMT5010 LTR   6,6                 TEST TIME CODE\n         JZ    MFMT0100            BR IF TIME NOT WANTED\nMFMT5020 CHI   6,4                 TEST IF SUPPORTED\n         JH    MFMT7500            BR IF NOT SUPPORTED\n         SLL   6,2                 MULTIPLY TIME CODE BY 4\n         B     *(6)                BR BASED ON TIME CODE\n         J     MFMT5100             1 - HH:MM\n         J     MFMT5200             2 - HH:MM AM (OR PM)\n         J     MFMT5300             3 - HH:MM:SS\n         J     MFMT5400             4 - HH:MM:SS AM (OR PM)\nMFMT5100 MVC   MFMTWEWK(6),MFMT8400  COPY EDIT MASK TO OUTPUT\n         ED    MFMTWEWK(6),0(4)    TRANSLATE PACKED DECIMAL DIGITS    ->\n                                    TO DECIMAL\n         MVC   0(5,14),MFMTWEWK+1  COPY TRANSLATED TIME TO OUTPUT\n         AHI   14,5                BUMP THE OUTPUT POINTER\n         J     MFMT0100            AND CONTINUE\nMFMT5200 MVC   MFMTWEWK(6),MFMT8400  COPY EDIT MASK TO OUTPUT\n         ED    MFMTWEWK(6),0(4)    TRANSLATE PACKED DECIMAL DIGITS    ->\n                                    TO DECIMAL\n         MVC   0(5,14),MFMTWEWK+1  COPY TRANSLATED TIME TO OUTPUT\n         LA    15,5(,14)           SET REG 15\n         J     MFMT5600\nMFMT5300 MVC   MFMTWEWK,MFMT8400   COPY EDIT MASK TO WORK AREA\n         ED    MFMTWEWK,0(4)       TRANSLATE PACKED DECIMAL DIGITS    ->\n                                    TO DECIMAL\n         MVC   0(L'MFMT8400-1,14),MFMTWEWK+1  COPY TRANSLATED TIME    ->\n                                    TO OUTPUT\n         AHI   14,L'MFMT8400-1     BUMP THE OUTPUT POINTER\n         J     MFMT0100            GO DO THE NEXT FORMAT\nMFMT5400 MVC   MFMTWEWK,MFMT8400   COPY EDIT MASK TO WORK AREA\n         ED    MFMTWEWK,0(4)       TRANSLATE PACKED DECIMAL DIGITS    ->\n                                    TO DECIMAL\n         MVC   0(L'MFMT8400-1,14),MFMTWEWK+1  COPY TRANSLATED TIME    ->\n                                    TO OUTPUT\n         LA    15,L'MFMT8400-1(,14)  SET REG 15\nMFMT5600 CLI   0(4),X'12'          COMPARE ORIGINAL TIME\n         JNL   MFMT5700            BR IF PM\n         MVC   0(3,15),=C' AM'     ADD AM TO OUTPUT\n         CLI   0(4),X'00'          TEST IF 12 AM\n         JNE   MFMT5800            BE IF NOT, WE'RE DONE\n         MVC   0(2,14),=C'12'      CHANGE 00 TO 12\n         J     MFMT5800            AND CONTINUE\nMFMT5700 MVC   0(3,15),=C' PM'     INSERT PM\n         CLI   0(4),X'12'          TEST IF NOON TO 12:59\n         JE    MFMT5800            BR IF SO, TIME DOES NOT HAVE TO    ->\n                                    ADJUSTED\n         MVC   MFMTWWRK+4(4),0(4)  COPY ORIGINAL TIME TO WORK AREA\n         OI    MFMTWWRK+7,X'0F'    SET A VALID SIGN\n         SP    MFMTWWRK+4(4),=P'1200000'  ADJUST THE TIME\n         MVC   MFMTWWRK(4),=X'402120'  COPY EDIT MASK\n         ED    MFMTWWRK(4),MFMTWWRK+4  CONVERT ADJUSTED TIME TO DECIMAL\n         MVC   0(2,14),MFMTWWRK+1  REPLACE HH WITH ADJUSTED HH\nMFMT5800 LA    14,3(,15)           UPDATE OUTPUT POINTER\n         J     MFMT0100            GO DO THE NEXT FORMAT\n         CNOP  0,8\n* GET THE ADDRESS.  REG 1 POINTS TO THE ADDRESS CONSTANT, REG 3\n* POINTS TO THE FORMAT.  ON RETURN, REG 3 PONTS TO THE NEXT FORMAT,\n* AND REG 4 CONTAINS THE OPERAND ADDRESS\nMFMT5900 TM    0(3),X'40'          TEST IF S-TYPE ADDRESS\n         JZ    MFMT6300            BR IF IN-LINE ADDRESS CONSTANT\nMFMT6000 LH    2,0(,1)             LOAD OFFSET FROM THE BASE REGISTER\n         N     2,=A(X'FFF')        ISOLATE THE OFFSET\n         IC    4,0(,1)             LOAD REGISTER\n         N     4,=A(X'F0')         ISOLATE THE REGISTER\n         SRL   4,2                 TRANSLATE REGISTER VALUE TO WORD   ->\n                                    OFFSET\n         L     4,MFMT8100(4)       LOAD THE SAVE AREA OFFSET FOR THE  ->\n                                    REGISTER\n         CHI   4,99                TEST IF REG 13\n         JNE   MFMT6100            BR IF NOT\n         LR    4,13                COPY REG 13 TO REG 4\n         J     MFMT6200            GO ADD THE OFFSET\nMFMT6100 L     4,0(4,13)           LOAD THE BASE REGISTER FROM THE    ->\n                                    SAVE AREA\nMFMT6200 ALR   4,2                 ADD THE OFFSET TO THE BASE REGISTER\n         LA    3,2(,1)             COMPUTE THE ADDRESS                ->\n                                    OF THE NEXT FORMAT\n         BR    15                  GO TO THE CONVERSION ROUTINE\nMFMT6300 ICM   4,B'1111',0(1)      LOAD THE DATA ADDRESS\n         LA    3,4(,1)             LOAD ADDRESS OF THE NEXT FORMAT\n         BR    15                  GO TO THE CONVERSION ROUTINE\nMFMT6400 J     MFMT7500            LENGTH 0, FORMAT ERROR\n         IC    15,0(,4)            LENGTH 1, LOAD 1 BYTE\n         ICM   15,B'0011',0(4)     LENGTH 2, LOAD 2 BYTES\n         ICM   15,B'0111',0(4)     LENGTH 3, LOAD 3 BYTES\n         ICM   15,B'1111',0(4)     LENGTH 4, LOAD 4 BYTES\nMFMT6500 SR    15,15               SET REG 15 = 0\n         L     1,=AL1(C' ',0,0,0)  LOAD FILL CHARACTER\n         IC    15,1(,3)            LOAD NUMBER OF BLANKS TO INSERT\n         AHI   3,2                 COMPUTE ADDRESS OF THE NEXT FORMAT\n         MVCL  14,0                INSERT THE BLANKS\n         J     MFMT0100            GO PROCESS THE NEXT FORMAT\n* TRANSLATE DCBRECFM TO A CHARACTER STRING\nMFMT6600 SR    6,6                 SET REG 6 = 0\n         IC    6,2(,3)             LOAD THE OUTPUT LENGTH\n         LA    1,3(,3)             LOAD ADDRESS OF THE ADDRESS\n         BRAS  15,MFMT5900         GET THE ADDRESS\n         MVC   MFMTWEWK(5),=CL8' ' CLEAR THE TEMPORARY OUTPUT\n         TM    0(4),DCBRECL        TEST IF RECFM IS VALID\n         JNZ   MFMT6610            BR IF A RECORD TYPE IS DEFINED\n         MVI   MFMTWEWK,C'?'       INDICATE RECFM IS INVALID\n         LA    15,MFMTWEWK+1       SET REG 15 = END OF DATA\n         J     MFMT7200            AND EXIT\nMFMT6610 LA    15,MFMTWEWK         LOAD ADDRESS OF THE TEMPORARY OUTPUT\n         LA    0,MFMT7800          LOAD ENTRIES IN THE CONVERSION TABLE\n         LA    1,MFMT7700          LOAD ADDR OF THE CONVERSION TABLE\nMFMT6700 MVC   MFMTWEWK+5(1),0(4)  SAVE A COPY OF THE RECFM\n         NC    MFMTWEWK+5(1),0(1)  ISOLATE TEST BITS\n         CLC   MFMTWEWK+5(1),1(1)  TEST RECFM\n         JNE   MFMT6800            BR OPTION NOT PRESENT\n         MVC   0(1,15),2(1)        COPY THE OPTION CHARACTER\n         AHI   15,1                UPDATE THE OUTPUT ADDR\nMFMT6800 AHI   1,3                 COMPUTE ADDR OF NEXT RECFM         ->\n                                    CONVERSION TABLE ENTRY\n         BRCT  0,MFMT6700          GO DO IT\n         J     MFMT7200\n* TRANSLATE DCBDSORG TO A CHARACTER STRING\nMFMT6900 SR    6,6                 SET OUTPUT LENGTH = 0\n         IC    6,2(,3)             LOAD OUTPUT LENGTH\n         LA    1,3(,3)             LOAD ADDRESS OF THE ADDRESS\n         BRAS  15,MFMT5900         GET THE ACTUAL ADDRESS\n         LA    0,MFMT8000          LOAD ENTRIES IN DSORG TABLE\n         LA    1,MFMT7900          LOAD ADDR OF START OF THE DSORG TAB\nMFMT7000 CLC   0(2,4),0(1)         TEST IF MATCH\n         JE    MFMT7100            BE IF SO\n         AHI   1,5                 COMPUTE ADDR OF NEXT DSORG ENTRY\n         BRCT  0,MFMT7000          GO CHECK IT\nMFMT7100 MVC   MFMTWEWK(3),2(1)    COPY DSORG TEXT\n         LA    15,MFMTWEWK+3       LOAD END OF DSORG\n         CLI   MFMTWEWK+2,C' '     TEST IF 3 BYTE DSORG\n         BNE   MFMT7200            BR IF SO\n         BCTR  15,0                RESET END OF DSORG\nMFMT7200 LR    5,15                COPY END OF TEXT TO REG 5\n         LA    4,MFMTWEWK          LOAD ADDRESS OF CONVERTED TEXT\n         SR    5,4                 COMPUTE LENGTH OF CONVERTED TEXT\n         LTR   6,6                 TEST OUTPUT LENGTH\n         JNZ   *+L'*+2             BR IF OUTPUT LENGTH DEFINED\n         LR    6,5                 COPY INPUT LENGTH TO OUTPUT LENGTH\n         O     5,=AL1(C' ',0,0,0)  ADD FILL CHARACTER TO INPUT LENGTH\n         LR    15,6                COPY OUTPUT LENGTH TO REG 15\n         MVCL  14,4                COPY RECFM TEXT TO OUTPUT\n         J     MFMT0100            GO DO THE NEXT FORMAT\n* TAB -- REPOSITION OUTPUT POINTER, INSERT BLANKS IF TAB > CURRENT\n*        LINE POSITION\nMFMT7300 SR    15,15               SET REG 15 = 0\n         IC    15,1(,3)            LOAD TAB POSITION\n         AHI   3,2                 UPDATE FORMAT POSITION\n         LA    15,MFMTWLNE+4(15)   COMPUTE TAB POSITION IN OUTPUT     ->\n                                    BUFFER\n         CR    15,14               COMPARE TAB POSITION W/ CURRENT    ->\n                                    LINE POSITION\n         JH    MFMT7400            BR IF FORWARD TAB\n         JE    MFMT0100            NO MOVEMENT, IGNORE\n         LR    14,15               BACKWARDS, SET NEW OUTPUT POSITION\n         J     MFMT0100            GO DO THE NEXT FORMAT\nMFMT7400 SR    15,14               COMPUTE NUMBER OF BLANKS TO INSERT\n         L     1,=AL1(C' ',0,0,0)  LOAD FILL CHARACTER INTO REG 1\n         MVCL  14,0                INSERT BLANKS TO NEW TAB\n         J     MFMT0100            GO DO THE NEXT FORMAT\nMFMT7500 MVC   0(5,14),=C'*FMT*'   INDICATE A FORMAT PROBLEM\n         AHI   14,5                UPDATE THE OUTPUT POINTER\nMFMT7600 LA    1,MFMTWLNE          LOAD ADDR OF GENERATED LINE\n         SR    14,1                COMPUTE LENGTH OF GENERATED LINE\n         STH   14,0(,1)            STORE LENGTH IN THE RDW\n         XC    2(2,1),2(1)         CLEAR THE REMAINDER OF THE RDW\n         ST    1,24(,13)           REPLACE CALLER'S REG 1 WITH        ->\n                                    ADDRESS OF GENERATED OUTPUT LINE\n         RETURN (14,12),T          RESTORE REGS & RETURN TO CALLER\nMFMT7700 DC    AL1(DCBRECL,DCBRECF,C'F') TABLE TO\n         DC    AL1(DCBRECL,DCBRECV,C'V')  TRANSLATE\n         DC    AL1(DCBRECL,DCBRECU,C'U')   DCBRECFM\n*        DC    AL1(DCBRECL,0,C'?')          TO A\n         DC    AL1(DCBRECBR,DCBRECBR,C'B')   CHARACTER\n         DC    AL1(DCBRECSB,DCBRECSB,C'S')    STRING\n         DC    AL1(DCBRECTO,DCBRECTO,C'T')\n         DC    AL1(DCBRECCC,DCBRECCA,C'A')\n         DC    AL1(DCBRECCC,DCBRECCM,C'M')\nMFMT7800 EQU   (*-MFMT7700)/3      NUMBER OF ENTRIES IN MFMT7700 TABLE\nMFMT7900 DC    AL1(DCBDSGPS,0),CL3'PS'         TABLE TO\n         DC    AL1(DCBDSGPO,0),CL3'PO'          TRANSLATE\n         DC    AL1(DCBDSGIS,0),CL3'IS'           DCBDSORG\n         DC    AL1(DCBDSGDA,0),CL3'DA'            TO A\n         DC    AL1(0,DCBACBM),CL3'VS'              CHARACTER STRING\n         DC    AL1(DCBDSGPS+DCBDSGU,0),CL3'PSU'\n         DC    AL1(DCBDSGPO+DCBDSGU,0),CL3'POU'\n         DC    AL1(DCBDSGIS+DCBDSGU,0),CL3'ISU'\n         DC    AL1(DCBDSGDA+DCBDSGU,0),CL3'DAU'\nMFMT8000 EQU   (*-MFMT7900)/5      NUMBER OF ENTRIES IN MFMT7900 TABLE\n         DC    2AL1(0),CL3'??'\n* THE MFMT8100 TABLE TRANSLATES A REGISTER NUMBER TO THE OFFSET\n* OF THE REGISTER LOCATION IN THE SAVE AREA USED WHEN MINIFMT IS\n* CALLED.  SINCE REGISTERS 14, 15, 0 AND 1 ARE LINK REGISTERS WHEN\n* MICROFMT IS CALLED THEY ARE NOT VERY USEFUL FOR THE PURPOSE, BUT\n* REGISTERS 2 THROUGH 13 ARE USEFUL.\n*             REG 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\nMFMT8100 DC    A(20,24,28,32,36,40,44,48,52,56,60,64,68,99,12,16)\nMFMT8200 EQU   *-C'0'\n         DC    C'0123456789ABCDEF'\n*                  ----+----1----+\nMFMT8300 DC    0C' 999999999999999',C' ',13X'20',X'2120'\nMFMT8310 DC    0C' 999,999,999,999,999'\n         DC    C' ',3X'20',C',',3X'20',C',',3X'20',C',',3X'20',C',',X'2>\n               02120'\n*                 0----+---\nMFMT8400 DC    0C'0HH:MM:SS',C'0',X'2120',C':',X'2020',C':',X'2020'\n* DAY OF YEAR FOR 1ST DAY OF MONTH\n         DC    0H'0'\nMFMT8500 EQU   *-2\n         DC    AL2(0)                                JANUARY\n         DC    AL2(31)                               FEBRUARY\n         DC    AL2(31+29)                            MARCH\n         DC    AL2(31+29+31)                         APRIL\n         DC    AL2(31+29+31+30)                      MAY\n         DC    AL2(31+29+31+30+31)                   JUNE\n         DC    AL2(31+29+31+30+31+30)                JULY\n         DC    AL2(31+29+31+30+31+30+31)             AUGUST\n*                                                    ----+----\n         DC    AL2(31+29+31+30+31+30+31+31)          SEPTEMBER\n         DC    AL2(31+29+31+30+31+30+31+31+30)       OCTOBER\n         DC    AL2(31+29+31+30+31+30+31+31+30+31)    NOVEMBER\n         DC    AL2(31+29+31+30+31+30+31+31+30+31+30) DECEMBER\n* TRANSLATE DAY OF YEAR TO MONTH\n* JANUARY TO JUNE\nMFMT8600 DC    32AL1(1),29AL1(2),31AL1(3),30AL1(4),31AL1(5),30AL1(6)\n* JULY TO DECEMBER\n         DC    31AL1(7),31AL1(8),30AL1(9),31AL1(10),30AL1(11),31AL1(12)\n* MONTH NUMBER TO MONTH NAME, ABBREVIATED MONTH NAME IS THE FIRST 3\n* CHARACTERS OF THE FULL MONTH NAME\nMFMT8700 DC    CL9'--'\n         DC    CL9'JANUARY',CL9'FEBRUARY',CL9'MARCH'\n         DC    CL9'APRIL',CL9'MAY',CL9'JUNE'\n         DC    CL9'JULY',CL9'AUGUST',CL9'SEPTEMBER'\n         DC    CL9'OCTOBER',CL9'NOVEMBER',CL9'DECEMBER'\n         DC    0D'0'\n         LTORG ,\n         DC    0D'0'\n         DROP  ,\n         TITLE 'CNVTBIN -- Translate Time of Day As Returned by TIME BI>\n               N to Time of Day As Returned by TIME DEC'\n***********************************************************************\n*                                                                     *\n* Title -- CNVTBIN                                                    *\n*                                                                     *\n* Function / Operation -- CNVTBIN converts the time of day as         *\n*   returned by the TIME BIN macro to the time of day as returned     *\n*   by the TIME DEC macro.                                            *\n*                                                                     *\n* Calling Sequence --                                                 *\n*   ----+----1----+----2----+----3----+----4----+----5----+----6----+ *\n*            TIME  BIN                 (or equivalent)                *\n*            L     15,=V(CNVTBIN)      Load address of CNVTBIN        *\n*            BASR  14,15               Convert binary time of day     *\n*   *                                   to 8 packed decimal digits    *\n*   * Time of day is in reg 0                                         *\n*   * CNVTBIN can also be called using the BRAS or BRASL instructions *\n*                                                                     *\n* Status / Change Level --                                            *\n*   V2L0 -- May 2010                                                  *\n*    - Replace lost source                                            *\n*                                                                     *\n* Method of Operation -- Prepare a binary number that is the analog   *\n*   of the number returned by TIME DEC, convert the number to the     *\n*   5 byte equivalent of the packed decimal equivalent of the value   *\n*   returned by TIME DEC, store the decimal digits in reg 0 and       *\n*   return.                                                           *\n*                                                                     *\n***********************************************************************\n         SPACE 5\n         ENTRY CNVTBIN\n         AGO   .NEWBIN\nCNVTBIN  BASR  15,0                STORE CURRENT ADDRESS IN REG 15\n         USING *,15                ESTABLISH ADDRESSABILITY\n         SAVE  (14,3),,CNVTBIN     SAVE REGISTERS 14 THROUGH 3        ->\n                                    (THE SAVE AREA POSITIONS FOR      ->\n                                     REGISTERS 11 AND 12 WILL BE USED ->\n                                      AS A WORK AREA)\n         LR    3,0                 COPY THE TIME BIN VALUE TO REG 3\n         SR    2,2                 SET REG 2 = 0\n         D     2,=F'100'           DIVIDE BY NUMBER OF 1/100TH OF A   ->\n                                    SECONDS IN A SECOND\n         LR    0,2                 COPY 1/100THS OF A SECOND TO REG 0\n         SR    2,2                 SET REG 2 = 0\n         D     2,=F'60'            DIVIDE SECONDS BY SECONDS IN 1     ->\n                                    MINUTE\n         MHI   2,100               MULTIPLY SECONDS BY 100\n         AR    0,2                 ADD TO TOTAL\n         SR    2,2                 SET REG 2 = 0\n         D     2,=F'60'            DIVIDE MINUTES BY 60\n* WE HAVE MINUTES IN AN HOUR IN REG 2, AND THE HOUR OF THE DAY IN REG 3\n         MHI   2,10000             MULTIPLY MINUTES BY 10000\n         AR    0,2                 ADD TO TOTAL\n         SR    2,2                 SET REG 2 = 0\n         M     2,=F'1000000'       MULTIPLY HOUR OF THE DAY BY 1000000\n         AR    0,3                 ADD TO TOTAL\n         CVD   0,64(,13)           CONVERT TIME TO PACKED DECIMAL\n         LM    0,1,64(13)          LOAD TIME\n         SRDL  0,4                 REMOVE THE PACKED DECIMAL SIGN\n         ST    1,20(,13)           REPLACE CALLER'S REG 0 WITH RESULT\n         RETURN (14,3),T           RESTORE CALLER'S REGISTERS & RETURN\n         DC    0D'0'               FORCE DOUBLE WORD ALIGNMENT\n         LTORG ,                   DEFINE THE LITERAL POOL\n         DC    0D'0'               FORCE DOUBLE WORD ALIGNMENT\n         SPACE 1\n         DROP  ,                   KILL ADDRESSABILITY\n.NEWBIN  ANOP\nCNVTBIN  BASR  15,0                Store current address in reg 15\n         USING *,15                Establish addressability\n         SAVE  (14,1),,CNVTBIN     Save registers\n         LR    1,0                 Copy reg 0 to reg 1\n         SR    0,0                 Compute minutes (in reg 1)\n         D     0,=F'6000'           and seconds (in reg 0)\n         LR    14,0                Copy seconds to reg 14\n         SR    0,0                 Compute hours (in reg 1)\n         D     0,=F'60'             and minutes (in reg 0)\n         MHI   0,10000             Multiply minutes by 10000\n         AR    14,0                Combine minutes and seconds\n         MHI   1,1000              Multiply hours by 1000000\n         MHI   1,1000\n         AR    14,1                Combine hours with minutes & seconds\n         MHI   14,10               Multiply F'hhmmssss' by 10\n         CVD   14,64(,13)          Convert F'hhmmssss0' to decimal\n         MVC   20(4,13),67(13)     Replace caller's reg 0 with hhmmssss\n         RETURN (14,1)             Restore registers & return\n         DC    0D'0'\n         LTORG ,\n         DC    0D'0'\n         DROP   ,                  Kill addressability\n         TITLE 'LJUST            L E F T   J U S T I F Y   R I G H T   >\n               J U S T I F I E D   D A T A'\n* Left justify right justified justifed data\n*          LA    0,L'DATA\n*          LA    1,DATA\n*          L     15,=V(LJUST)\n*          CALL  (15)\n*          ...\n* DATA     DC    C'  DATA'\n*\n* Output is C'DATA  '\n*\n* An alternative, slightly faster though more expensive in storage,\n* inplementation is expressed in comments.\n         SPACE 1\n         ENTRY LJUST               Define external entry point\nLJUST    BASR  15,0                Store current address in reg 15\n         USING *,4                 Establish program addressability\n         SAVE  (14,4),,LJUST       Save registers\n         LR    4,15                Prepare base register\n         LR    14,1                Copy start of data to reg 14 and\n         LR    2,1                  reg 2\n         LTR   3,0                 Copy length to reg 3\n         JNP   LJ0300              Br if length is bad\n**       LA    1,0(3,2)            Compute address of end of data\n*        LR    15,0                Copy length to reg 15\n*        BCTR  15,0                Compute length to test\n*        EX    15,LJ0500           Find first non-blank\n*        JZ    LJ0300              All blanka, exit\nLJ0100   TM    0(1),255-C' '       Find first non-blank\n         JNZ   LJ0200              Br if found\n         AHI   1,1                 Update reg 1\n         BRCT  0,LJ0100            Keep on looking\n         J     LJ0300              All blanks, exit\nLJ0200   CR    14,1                Test if already left justified\n         JE    LJ0300              Br if so\n         LA    15,0(3,2)           Compute addr of end of data\n         SR    15,1                Compute length to copy\n         JNP   LJ0300              Oops\n         BCTR  15,0                Reduce length by 1 for hardware\n         EX    15,LJ0400           Left justify the data\n         LA    14,1(15,14)         Compute end of string we just copied\n         LA    15,0(3,2)           Compute end of data\n         SR    15,14               Compute bytes to blank\n         JNP   LJ0300              Br if none\n         L     1,LJ0600            Load the fill character\n         MVCL  14,0                Fill the vacated data with blanks\nLJ0300   RETURN (14,4)             Restore registers & return\nLJ0400   MVC   0(*-*,14),0(1)    **EX only **\n*LJ0500  TRT   0(*-*,14),LJ0700  **EX only **\nLJ0600   DC    0A(0),C' ',3AL1(0)\n         DC    0D'0'\n*LJ0700  DC    X'00',(C' '-(*-LJ0700))X'04',X'00',(256-(*-LJ0700))X'04'\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QSORTS": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01\\x17\\x10\\x7f\\x01\\x17\\x10\\x7f\\x14\\x19\\x01!\\x01!\\x00\\x00\\xd4\\xe5\\xe2\\xd7\\xd9\\xd6\\xc7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-04-17T00:00:00", "modifydate": "2017-04-17T14:19:22", "lines": 289, "newlines": 289, "modlines": 0, "user": "MVSPROG"}, "text": "V1L1     TITLE '                                            QUICKSORT S?\n               HELL'\n***********************************************************************\n*                                                                     *\n* TITLE -- QSORT                                                      *\n*                                                                     *\n* FUNCTION / OPERATION -- THIS MODULE OPERATES AS A SHELL BETWEEN A   *\n*   CALLING PROGRAM AND A COMPARE PROGRAM.  THE EFFECT OF THE SHELL   *\n*   IS TO SORT DATA IN ASCENDING ORDER, DEPENDING ON THE RESULTS      *\n*   RETURNED BY THE COMPARE PROGRAM                                   *\n*                                                                     *\n* STATUS / CHANGE LEVEL --                                            *\n*   V1L1 -- OCT 14, 1997                                              *\n*     UPDATE QSORT TO DO NO PROCESSING IF N <= 1                      *\n*   V1L0 -- FEB 28, 1993                                              *\n*                                                                     *\n* CALLING SEQUENCE --                                                 *\n*                                                                     *\n*          CALL QSORT,(BASE,N,WIDTH,COMPARE,WORK)                     *\n*                                                                     *\n*    BASE    -- THE FIRST ELEMENT IN AN ARRAY OF ELEMENTS TO SORT     *\n*    COMPARE -- THE ADDRESS OF A ROUTINE USED TO COMPARE TWO ELEMENTS *\n*               OF THE DATA AREA                                      *\n*    N       -- A FULL WORD CONTAINING THE NUMBER OF ELEMENTS TO SORT *\n*    WIDTH   -- A FULL WORD CONTAINING THE NUMBER OF BYTES IN EACH    *\n*               ELEMENT.  THE MAXIMUM VALUE IS 256.                   *\n*    WORK    -- A 100 BYTE DATA AREA USED AS A WORK AREA              *\n*                                                                     *\n*    COMPARE ROUTINE --                                               *\n*      THE COMPARE ROUTINE IS CALLED WITH THIS CALLING SEQUENCE --    *\n*                                                                     *\n*               CALL COMPARE,(ELEMENT1,ELEMENT2)                      *\n*                                                                     *\n*      THE RETURN CODE IN REGISTER 15 EXPECTED FROM COMPARE IS --     *\n*                                                                     *\n*        ELEMENT1 < ELEMENT2 -- LESS THAN 0                           *\n*        ELEMENT1 = ELEMENT2 -- 0                                     *\n*        ELEMENT1 > ELEMENT2 -- GREATER THAN 0                        *\n*                                                                     *\n* ATTRIBUTES -- QSORT IS REENTRANT, REFRESHABLE AND RESUABLE.  IT     *\n*   USES NO EXTERNAL SYSTEM RESOURCES.  IT OPERATES AMODE ANY,        *\n*   RMODE ANY.  IT DOES NOT SUPPORT OPERATION IN AR MODE              *\n*                                                                     *\n***********************************************************************\n         EJECT\n         MACRO\n         SETR\n         LCLA  &A\n.L       AIF   (&A GT 15).X\nR&A      EQU   &A\n&A       SETA  &A+1\n         AGO   .L\n.X       MEND\n*        CALL  QSORT( BASE, NUM, WIDTH, COMPARE, WORK )\n*\n* THIS ROUTINE IS BASED ON THE FOLLOWING C PROGRAM\n*\n* VOID SORT( CHAR *ARRAY, INT N )\n*  {\n*   INT GAP, I, J, TEMP;\n*\n*   FOR ( GAP = N / 2; GAP > 0; GAP /= 2 )\n*    FOR ( I = GAP; I < N; I++ )\n*     FOR ( J = I - GAP;\n*           J >= 0 && ARRAY(J) > ARRAY(J + GAP);\n*           J -= GAP )\n*      {\n*       TEMP = ARRAY(J);\n*       ARRAY(J) = ARRAY( J + GAP );\n*       ARRAY( J + GAP ) = TEMP;\n*      }\n*  }\n         SPACE 1\nQSORTS   CSECT                     DEFINE PROGRAM CSECT\n         SPACE 1\nQSORTS   AMODE ANY                 DEFINE AMODE\nQSORTS   RMODE ANY                 DEFINE RMODE\n         SPACE 1\n         ENTRY QSORT,QSORTL\n         SPACE 1\n         SR    R15,R15             SET R15 = 0\n         BR    R14                 RETURN IF QSORTS CALLED\n         SPACE 1\n         DC    C'QSORT AND QSORTL ROUTINES -- V1L1',0D'0'\n         SPACE 1\nN        EQU   R3                  N\nWIDTH    EQU   R4                  WIDTH\nGAP      EQU   R6                  GAP\nI        EQU   R7                  I\nJ        EQU   R8                  J\n         SPACE 1\n         USING *,R12               ESTABLISH ADDRESSABILITY\nQSORT    SAVE  (14,12),,*          SAVE CALLER'S REGISTERS\n         LR    R12,R15             COPY EP ADDRESS TO R12\n         LM    R2,R6,0(R1)         LOAD THE REGISTERS\n         ST    R6,8(,R13)          ADD THE NEW SAVE AREA TO THE\n         ST    R13,4(,R6)           CALLER'S SAVE AREA CHAIN\n         LR    R13,R6              ESTABLISH THE NEW SAVE AREA\n         L     R3,0(,R3)           LOAD VALUE OF NUM\n         C     R3,=F'1'            COMPARE VALUE W/ 1          10/14/97\n         BNH   QSO0600             BR IF 0 OR 1                10/14/97\n         L     R4,0(,R4)           LOAD VALUE OF WIDTH\n*   FOR ( GAP = N / 2; GAP > 0; GAP /= 2 )\n         LR    GAP,N               COPY N TO GAP\n         CNOP  0,8\nQSO0100  SRA   GAP,1               DIVIDE N BY 2\n         LTR   GAP,GAP             TEST IF DONE\n         BZ    QSO0600             BR IF SO\n*    FOR ( I = GAP; I < N; I++ )\n         LR    I,GAP               COPY GAP TO I\nQSO0200  CR    I,N                 COMPARE I AND N\n         BNL   QSO0100             BR IF NOT A MATCH\n*     FOR ( J = I - GAP;\n*           J >= 0 && ARRAY(J) > ARRAY(J + GAP);\n*           J -= GAP )\n         LR    J,I                 COPY I TO J\n         SR    J,GAP               SUBTRACT GAP FROM I\nQSO0300  LTR   J,J                 COMPARE J AND 0\n         BL    QSO0500             BR IF DONE\n         LR    R15,J               COPY J TO R15\n         MR    R14,WIDTH           COMPUTE TRUE OFFSET\n         LA    R9,0(R15,R2)        COMPUTE ADDRESS\n         LR    R15,J               COPY J TO R15\n         AR    R15,GAP             ADD GAP\n         MR    R14,WIDTH           COMPUTE TRUE OFFSET\n         LA    R10,0(R15,R2)       COMPUTE ADDRESS\n         LR    R15,R5              COPY COMPARE ROUTINE ADDRESS TO R15\n         CALL  (15),((R9),(R10)),MF=(E,72(,R13)) CALL THE COMPARE PGM\n         LTR   R15,R15             TEST RC FROM COMPARE\n         BNH   QSO0500             BR IF DONE\n         LR    R1,WIDTH            COPY WIDTH TO R1\n         BCTR  R1,0                REDUCE BY 1\n         EX    R1,SWITCH1          EXCHANGE THE TWO ELEMENTS\n         EX    R1,SWITCH2\n         EX    R1,SWITCH1\nQSO0400  SR    J,GAP               SUBTRACT GAP FROM J\n         B     QSO0300             TEST IF FOR IS DONE\n         SPACE 1\nQSO0500  LA    I,1(,I)             ADD 1 TO I\n         B     QSO0200             TEST IF FOR IS DONE\n         SPACE 1\nQSO0600  L     R13,4(,R13)         RESTORE ADDR OF CALLER'S SAVE AREA\n         RETURN (14,12),T          RETURN TO CALLER\n         SPACE 1\n         CNOP  0,8\nSWITCH1  XC    0(*-*,R9),0(R10)\nSWITCH2  XC    0(*-*,R10),0(R9)\n         SPACE 1\n         CNOP  0,8\n         LTORG ,\n         EJECT\n***********************************************************************\n*                                                                     *\n* TITLE -- QSORTL                                                     *\n*                                                                     *\n* FUNCTION / OPERATION -- QSORTL ACTS AS AN INTERFACE BETWEEN ANOTHER *\n*   PROGRAM AND THE QSORT PROGRAM.  QSORTL SORTS A LIST OF ELEMENTS   *\n*   THAT ARE ON A CHAIN.  IT DOES THIS BY RUNNING THE CHAIN TO        *\n*   PRODUCE A POINTER LIST, THEN USES QSORT TO SORT THE POINTER LIST. *\n*   AFTER QSORT TERMINATES THE CHAIN IS REBUILT IN SORTED ORDER BY    *\n*   UPDATING THE POINTER ELEMENTS.                                    *\n*                                                                     *\n*                                                                     *\n* STATUS / CHANGE LEVEL --                                            *\n*   V1L0 -- MAR 31, 1993                                              *\n*                                                                     *\n* CALLING SEQUENCE --                                                 *\n*   CALL QSORTL,(BASE,OFFSET,COMPARE)                                 *\n*                                                                     *\n*     BASE    -- ADDRESS OF A POINTER TO THE FIRST ELEMENT OF THE     *\n*                CHAIN                                                *\n*     OFFSET  -- OFFSET OF THE 4 BYTE POINTER TO THE NEXT ELEMENT     *\n*                IN THE CHAIN.  A POINTER VALUE OF 0 INDICATES THE    *\n*                LAST ELEMENT IN THE CHAIN.                           *\n*     COMPARE -- COMPARE ROUTINE, AS USED BY QSORT.  THE COMPARE      *\n*                ROUTINE SEES POINTERS TO THE DATA ELEMENT TO SORT.   *\n*                                                                     *\n* ATTRIBUTES -- QSORTL IS REENTRANT, REFRESHABLE AND REUSABLE.  IT    *\n*   USES THE GETMAIN AND FREEMAIN SERVICE ROUTINE TO ALLOCATE AND     *\n*   RELEASE STORAGE IN SUBPOOL 0.  IT OPERATES AMODE ANY, RMODE ANY.  *\n*   AR MODE OPERATION IS NOT SUPPORT.                                 *\n*                                                                     *\n***********************************************************************\n         CNOP  0,8\n         SPACE 1\n         USING *,R12               ESTABLISH PROGRAM ADDRESSABILITY\n         USING QLWORK,R13          ESTABLISH WORK AREA ADDRESSABILITY\n         SPACE 1\nQSORTL   SAVE  (14,12),,*          SAVE REGISTERS\n         LR    R12,R15             COPY EP ADDRESS TO R12\n         LM    R2,R4,0(R1)         LOAD PARM LIST\n         L     R3,0(,R3)           LOAD VALUE OF OFFSET\n         SPACE 1\n* COUNT THE NUMBER OF ELEMENTS ON THE CHAIN\n         SPACE 1\n         SR    R7,R7               SET COUNT = 0\n         L     R6,0(,R2)           LOAD ADDRESS OF THE FIRST ELEMENT\nQL0100   LTR   R6,R6               TEST IF END OF CHAIN\n         BZ    QL0200              BR IF END\n         L     R6,0(R3,R6)         LOAD ADDRESS OF THE NEXT ELEMENT\n         LA    R7,1(,R7)           ADD 1 TO COUNT\n         B     QL0100              AND CONTINUE\n         SPACE 1\n* MAKE SURE THE CHAIN IS WORTH SORTING\n         SPACE 1\nQL0200   C     R7,=F'1'            COMPARE COUNT WITH 1\n         BNH   QL0600              EXIT IF COUNT <= 1\n         SPACE 1\n* CALCULATE THE SIZE OF THE WORK AREA WE WILL ALLOCATE.  THE WORK\n* AREA CONTAINS A FIXED BASE AREA FOLLOWED BY POINTER LIST WE PASS TO\n* QSORT.\n         SPACE 1\n         LR    R6,R7               COPY COUNT TO R6\n         SLL   R6,2                MULTIPLY COUNT BY 4\n         LA    R6,QLWORKL+7(,R6)   COMPUTE TOTAL SIZE TO ALLOCATE\n         SPACE 1\n* ALLOCATE THE WORK AREA\n         SPACE 1\n         N     R6,=F'-8'           ROUND DOWN TO A DOUBLE WORD\n         GETMAIN RU,LV=(R6)        ALLOCATE THE WORK AREA\n         SPACE 1\n* ADD THE CHAIN AREA IN THE WORK AREA TO THE SAVE AREA CHAIN\n         SPACE 1\n         ST    R13,QLS-QLWORK+4(,R1) ADD THE SAVE AREA TO THE\n         ST    R1,8(,R13)             SAVE AREA CHAIN\n         LR    R13,R1              ESTABLISH A NEW SAVE AREA ADDRESS\n         SPACE 1\n* INITIALIZE ADDITIONAL DATA AREAS\n         SPACE 1\n         ST    R6,QLSSIZE          SAVE THE WORK AREA SIZE\n         ST    R7,QLCOUNT          SAVE COUNT\n         SPACE 1\n* BUILD THE POINTER LIST\n         SPACE 1\n         LA    R1,QLPTRS           LOAD ADDR OF THE FIRST POINTER\n         L     R6,0(,R2)           LOAD ADDRESS OF THE FIRST ELEMENT\nQL0300   LTR   R6,R6               TEST IF END OF CHAIN\n         BZ    QL0400              BR IF SO\n         ST    R6,0(,R1)           SAVE ADDRESS\n         LA    R1,4(,R1)           COMPUTE NEXT POINTER ADDRESS\n         L     R6,0(R3,R6)         LOAD ADDRESS OF THE NEXT AREA\n         B     QL0300\n         SPACE 1\n* USE QSORT TO SORT THE POINTER LIST\n         SPACE 1\nQL0400   L     R15,=A(QSORT)       LOAD START OF QSORT\n         CALL  (15),(QLPTRS,QLCOUNT,QLWIDTH,(R4),QLSWORK),MF=(E,QSPARM)\n         SPACE 1\n* REBUILD THE CHAIN IN SORTED ORDER USING THE POINTER LIST\n         SPACE 1\n         SR    R2,R3               MAKE POINTER TO 1ST ELEMENT A DUMMY ?\n                                    ELEMENT\n         LA    R1,QLPTRS           LOAD ADDRESS OF THE FIRST POINTER\nQL0500   LA    R6,0(R3,R2)         COMPUTE ADDRESS OF POINTER TO       ?\n                                    NEXT ELEMENT\n         MVC   0(4,R6),0(R1)       COPY POINTER\n         L     R2,0(,R1)           LOAD ADDRESS OF THE ELEMENT\n         LA    R1,4(,R1)           COMPUTE NEXT POINTER ADDRESS\n         BCT   R7,QL0500           GO DO THE NEXT ELEMENT\n         LA    R6,0(R3,R2)         COMPUTE ADDRESS OF POINTER TO       ?\n                                    NEXT ELEMENT\n         XC    0(4,R6),0(R6)       CLEAR POINTER IN LAST ELEMENT\n         SPACE 1\n* RELEASE THE ALLOCATED STORAGE\n         SPACE 1\n         L     R0,QLSSIZE          LOAD SIZE OF ALLOCATED STORAGE\n         LR    R1,R13              COPY ADDRESS TO R1\n         L     R13,4(,R13)         LOAD ADDR OF THE CALLER'S SAVE AREA\n         FREEMAIN RU,LV=(0),A=(1)  RELEASE STORAGE\n         SPACE 1\n* RETURN\n         SPACE 1\nQL0600   RETURN (14,12),T          RETURN TO CALLER\n         SPACE 1\nQLWIDTH  DC    F'4'                VALUE OF 4\n         SPACE 1\n         DC    0D'0'\n         LTORG ,\n         SPACE 1\nQLWORK   DSECT                     WORK AREA\nQLS      DS    9D                  SAVE AREA\nQLSWORK  DS    XL100               QSORT WORK AREA\nQLSSIZE  DS    F                   SIZE OF THIS WORK AREA\nQLCOUNT  DS    F                   NUMBER OF ELEMENTS\nQSPARM   CALL  ,(*-*,*-*,*-*,*-*,*-*),MF=L QSORT PARM LIST\nQLWORKL  EQU   *-QLWORK            LENGTH OF BASE PORTION\nQLPTRS   DS    0A                  FIRST POINTER\n         SETR  ,\n         END   ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT956/FILE956.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT956", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}