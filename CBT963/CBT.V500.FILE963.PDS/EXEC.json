{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "TSAZFA", "INMTNODE": "JES2", "INMTUID": "TSAZFA", "INMFTIME": "20171011150615000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 352716, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 32720, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "TSAZF.CBT.DYNAMIC.EXEC", "INMMEMBR": "TSAZF.CBT.DYNAMIC.EXEC", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"TSAZF.CBT.DYNAMIC.EXEC": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 32720, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 128, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 32760, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "170284", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\xc0\\x00\\x00\\x05'", "DS1LSTAR": "b'\\x00\\x06\\x02'", "DS1TRBAL": "b'k\\xfa'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f* \\x00\\x04\\x890`'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f* \\x00\\x04\\x890`'", "b'P\\x8b\\x93\\xb8\\x00\\x00\\x00\\x8d\\x00\\x00\\x00\\x8d\\x00\\x0e\\x00\\x0f'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$LIST": {"ttr": 1283, "alias": false, "halfwords": 40, "notes": 0, "parms": "b'\\x01\\x02 Q\\x01\\x17#o\\x01\\x17(O\\tE\\x00\\t\\x00\\n\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@\\x00\\x00\\x00\\t\\x00\\x00\\x00\\n\\x00\\x00\\x00\\x00'", "ispf": {"version": "01.02", "flags": 32, "createdate": "2017-08-24T00:00:00", "modifydate": "2017-10-11T09:45:51", "lines": 9, "newlines": 10, "modlines": 0, "user": "AL-FERG"}, "text": "FROM 'TSAZF.CBT.ALZ.DYNAMIC.EXEC'\n    @$AVRS   - SEA's $ysout Archive, Viewing, & Retrieval System\n    @HCD     - IBM Hardware Configuration w/ISPF SHRPROF Support\n    @IPCS    - IBM IPCS w/ISPF SHRPROF Support\n    @STARTUP - Main Dynamic ISPF EXEC call in ISPF Logon PROCs\n    CA1DS34  - ISPF DSLIST Tape DSN Information via CA's CA1 TMS\n    DYNMISPF - Dynamic ISPF EXEC used from TSO LOGON EXEC line\n    FM       - ISPF DSLIST VSAM Browse, Edit, & View via IBM FileMgr\n    STARTUP  - Allocate Personal ISPF Libraries at Startup\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@$AVRS": {"ttr": 259, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1f\\x00\\x00\\x01\\x112\\x1f\\x01\\x17(O\\tF\\x01y\\x01\\x87\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.31", "flags": 0, "createdate": "2011-11-17T00:00:00", "modifydate": "2017-10-11T09:46:00", "lines": 377, "newlines": 391, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n\n This REXX allocates the SAE $AVRS Libraries and then envokes $AVRS on\n      viewing interface.\n\n                           --- EXAMPLE ---\nTSO <%>@$AVRS <PROD_DEVL(PROD|DEVL)> <TEST(TraceOption)>,\n              <VERSION(blank|R##BM##>\nTSO <%>@$AVRS -H -- To display help for this REXX\n\n  Arguments: InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n               PROD_DEVL - System DSNs to use, PROD or DEVL\n                           default: DEVL\n                    TEST - Used to control traces\n                 VERSION - blank or R##BM##, e.g. R52BM04\n                           default: blank\n\n      Files: NONE\nOther EXECS: NONE\n\nEXEC History\n\n REXX EXEC Name: @$AVRS\n         Author: Al Ferguson (TSAZFA)\n         Writen: 17NOV11\n        History: 06FEB17 - v1.18 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.17 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.16 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 21JUN16 - v1.14 - Add support for VERSION NPPARM\n                           to allow testing of maintenance under ISPF\n                           before it rolls out, in particular the 4 JOBCARD\n                           Records for the JCLLIBs.\n                 17NOV11 - v1.0 - Initial Version\n\n***************************** Rexx ***********************************/\nMsgStat = MSG(\"OFF\")\nARG InParms                                  /* Place arguments here */\n\nIF WORDPOS(InParms,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nok='0'\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPMLIB DATASET ID('\"$AVR_ISPMLIB\"') STACK\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB DATASET ID('\"$AVR_ISPPLIB\"') STACK\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB DATASET ID('\"$AVR_ISPTLIB\"') STACK\"\n\nok='0 4'\n  ADDRESS \"ISPEXEC\" \"SELECT CMD(CALL '\"$AVR_LOADLIB\"(ISP$AVRS)' '$.\"DB\"')\",\n                    \"NEWAPPL(\"$AVR_APPLID\") PASSLIB\"\nok='0'\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPMLIB\"\n\nMsgStat = MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE = 1; FALSE = 0  /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"PROD_DEVL(DEVL) TEST(O) VERSION()\"\n  MatchLength = 4                 /* NP-Parms match on first # chars  */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  NbrSubmited = 0\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n  IF ABBREV(AnythingElse, \"DEVL\") THEN DO\n     PROD_DEVL = \"DEVL\"\n     AnythingElse = STRIP(RIGHT(AnythingElse,LENGTH(AnythingElse)-4))\n  END\n\n  IF ABBREV(PROD_DEVL, \"DEVL\") THEN DO\n      HLQ = \"DSYS.$AVR\"; $AVR_APPLID = \"$AVD\"; DB = \"DL\"\n    END\n  ELSE DO\n      HLQ = \"PSYS.$AVR\"; $AVR_APPLID = \"$AVP\"; DB = \"PR\"\n  END\n  IF VERSION \u00ac= \"\" THEN HLQ = \"SYS3.$AVR.\" || VERSION\n  $AVR_ISPMLIB = HLQ\".ISPMLIB\"\n  $AVR_ISPPLIB = HLQ\".ISPPLIB\"\n  $AVR_ISPTLIB = HLQ\".ISPTLIB\"\n  $AVR_LOADLIB = HLQ\".LOADLIB\"\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ok='*'                            /* Ignore all non-0 RCs           */\n    ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB\"\n    ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"\n    ADDRESS \"ISPEXEC\" \"LIBDEF ISPMLIB\"\n    ADDRESS \"ISPEXEC\" \"FTCLOSE\"\n    ZISPFRC = ExitError\n    ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"\nEXIT ExitError                      /* EXIT with error return code    */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@HCD": {"ttr": 513, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x018\\x00\\x00\\x01\\x07\\x13_\\x01\\x17(O\\tF\\x01\\x9c\\x01J\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.56", "flags": 0, "createdate": "2007-05-15T00:00:00", "modifydate": "2017-10-11T09:46:00", "lines": 412, "newlines": 330, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n\n This REXX allocates the HCD DSNs and then calls HCD's Startup command.\n\n                           --- EXAMPLE ---\nTSO <%>@HCD <HLQ(HCD_HLQ)> <TEST(TraceOption)> <TRACE(TRUE|FALSE)>\nTSO <%>@HCD -H -- To display help for this REXX\n\n  Arguments: InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                     HLQ - HLQ to add to HCD DSNs.    default: blank\n                    TEST - Used to control traces\n                   TRACE - Turn on HCD Tracing.       default: FALSE\n\n      Files: Used to maintain SYS%.IODF%% Files.\nOther EXECS: None\n\nEXEC History\n\n REXX EXEC Name: @HCD\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.41\n                 FERGUSON AL (HUL2353)\n         Writen: 04DEC07\n        History: 06FEB17 - v1.43 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.42 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.41 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 27SEP12 - v1.38 - STEPLIBs moved linklist,\n                           removing DynaSTEP usage.\n                 21MAY12 - v1.34 - Add back DynaSTEP to all HCD\n                           Help.\n                 31AUG11 - v1.29 - Minor tweaks and cleanup,\n                           plus fix ISPF APPL to CBD.\n                 29JUL10 - v1.26 - Change DynaSTEP to ISPLLIB\n                           LIBDEF. Change TSO ALLOCs to BPXWDYNs.\n                 04DEC07 - v1.0\n\n***************************** Rexx ***********************************/\nMsgStat = MSG(\"OFF\")\nARG InParms                                  /* Place arguments here */\n\nIF WORDPOS(InParms,'-h -H') > 0 THEN CALL DISPLAY_HELP\n   ELSE CALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nCALL BPXWDYN(\"ALLOC DD(HCDPROF) NEW REUSE UNIT(VIO)\",\n             \"TRACKS SPACE(1,5) DSORG(PS) RECFM(F,B) LRECL(80)\")\nok='0'\n  ADDRESS \"TSO\" \"NEWSTACK\"\n      IF TRACE THEN QUEUE \"TRACE ON\"\n         ELSE       QUEUE \"TRACE OFF\"\n      QUEUE \"IODF_DATA_SPACE = YES\"\n      IF UIMLIB \u00ac= \"\" THEN QUEUE \"UIM_LIBNAME = *\"\n      ADDRESS \"MVS\" \"EXECIO\" QUEUED() \"DISKW HCDPROF (FINIS\"\n  ADDRESS \"TSO\" \"DELSTACK\"\n\nCALL BPXWDYN(\"ALLOC DD(HCDMLOG)  SYSOUT(T) REUSE RECFM(F,B) LRECL(133)\")\nCALL BPXWDYN(\"ALLOC DD(HCDTRACE) SYSOUT(T) REUSE RECFM(F,B) LRECL(80) \")\nCALL BPXWDYN(\"ALLOC DD(HCDTERM)  SYSOUT(T) REUSE RECFM(F,B) LRECL(80) \")\n\n  ADDRESS \"TSO\" \"ALTLIB ACTIVATE APPLICATION(CLIST) DSN(\"SCBDCLST\")\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPMLIB DATASET ID(\"SCBDMENU\") STACK\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB DATASET ID(\"SCBDPENU\") STACK\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB DATASET ID(\"SCBDTENU\") STACK\"\n  ADDRESS \"ISPEXEC\" \"VGET ZPFSHOW PROFILE\"\n  SZPFSHOW = ZPFSHOW\n  ADDRESS \"ISPEXEC\" \"SELECT PGM(ISPOPF) PARM(PFK,ON)\"\n\nok='0 4 8 10';ADDRESS \"ISPEXEC\" \"SELECT PGM(CBDMGHCP) PARM(DIALOG,E)\",\n                                \"SUSPEND NEWAPPL(CBD) PASSLIB\"\nok='0'\n  ADDRESS \"ISPEXEC\" \"SELECT PGM(ISPOPF) PARM(PFK,\"SZPFSHOW\")\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPMLIB\"\n  ADDRESS \"TSO\" \"ALTLIB DEACTIVATE APPLICATION(CLIST)\"\n\nCALL BPXWDYN(\"FREE DD(HCDTERM)\")\nCALL BPXWDYN(\"FREE DD(HCDTRACE)\")\nCALL BPXWDYN(\"FREE DD(HCDPROF)\")\nCALL BPXWDYN(\"FREE DD(HCDMLOG)\")\n\nMsgStat = MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE = 1; FALSE = 0  /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"HLQ() TEST(O) TRACE(FALSE)\"\n  MatchLength = 3      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  NbrSubmited = 0\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n  IF HLQ = \"\" THEN DO\n     SCBDCLST = \"'SYS1.SCBDCLST'\"\n     SCBDMENU = \"'SYS1.SCBDMENU'\"\n     SCBDPENU = \"'SYS1.SCBDPENU'\"\n     SCBDTENU = \"'SYS1.SCBDTENU'\"\n     UIMLIB   = \"\"\n     SCBDHENU = \"'SYS1.SCBDHENU'\" UIMLIB\n     STEPLIB  = SCBDHENU\n    END\n  ELSE DO\n     SCBDCLST = \"'\"HLQ\".SYS1.SCBDCLST'\"\n     SCBDMENU = \"'\"HLQ\".SYS1.SCBDMENU'\"\n     SCBDPENU = \"'\"HLQ\".SYS1.SCBDPENU'\"\n     SCBDTENU = \"'\"HLQ\".SYS1.SCBDTENU'\"\n     UIMLIB   = \"'\"HLQ\".SYS1.NUCLEUS'\"\n     SCBDHENU = \"'\"HLQ\".SYS1.LINKLIB' '\"HLQ\".SYS1.SCBDHENU'\" UIMLIB\n     STEPLIB  = SCBDHENU\n  END\n  IF \u00ac(TRACE = FALSE) THEN TRACE = TRUE\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ok='*'                               /* Ignore all non-0 RCs        */\n    ADDRESS \"ISPEXEC\" \"SELECT PGM(ISPOPF) PARM(PFK,\"SZPFSHOW\")\"\n    CALL BPXWDYN(\"FREE DD(HCDTERM)\" )\n    CALL BPXWDYN(\"FREE DD(HCDTRACE)\")\n    CALL BPXWDYN(\"FREE DD(HCDPROF)\")\n    CALL BPXWDYN(\"FREE DD(HCDMLOG)\")\n    ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB\"\n    ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"\n    ADDRESS \"ISPEXEC\" \"LIBDEF ISPMLIB\"\n    ADDRESS \"TSO\" \"ALTLIB DEACTIVATE APPLICATION(CLIST)\"\n    ADDRESS \"ISPEXEC\" \"FTCLOSE\"        /* Close File Tailoring DSN    */\n    ZISPFRC = ExitError                /* Initialize ISPF RC Variable */\n    ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\" /* Set ISPF RC to error RC     */\nEXIT ExitError                         /* Set TSO/MVS RC to error RC  */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@IPCS": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x013\\x00\\x00\\x01\\x07\\x13_\\x01\\x17(O\\tF\\x01\\xc6\\x01J\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.51", "flags": 0, "createdate": "2007-05-15T00:00:00", "modifydate": "2017-10-11T09:46:00", "lines": 454, "newlines": 330, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n\n This REXX allocates the IPCS Libraries, sets up the IPCS Options, and\n      then starts IPCS. It will automatically\n\n                           --- EXAMPLE ---\nTSO <%>IPCS DSName <HLQ(HCD_HLQ)> <TEST(TraceOption)>\nTSO <%>IPCS -H -- To display help for this REXX\n\n  Arguments: DSName      - Dump Dataset to open on start.\n                           \".\" is treated as Blank\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                     HLQ - HLQ to add to HCD DSNs.    default: blank\n                    TEST - Used to control traces\n\n      Files: Used with SYSDUMP.** and SYS1.SADMP Datasets\nOther EXECS: Can be called from SYSDUMP Listing REXX\n\nEXEC History\n\n REXX EXEC Name: IPCS\n         Author: FERGUSON AL (TSAZFA) from version 1.35\n                 FERGUSON AL (HUL2353)\n         Writen: 15MAY07\n        History: 06FEB17 - v1.39 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.38 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.37 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 07OCT15 - v1.35 - Remove JES3 DSNs & Msg, add\n                           JES2 DSNs, & convert MVS Version to use REXX\n                           Function MVSVAR('SYSMVS').\n                 08MAR11 - v1.26 - Add JES3 Panels to IPCS\n                           Concatination\n                 29JUL10 - v1.22 - Change DynaSTEP to ISPLLIB\n                           LIBDEF and TSO ALLOCs to BPXWDYN ALLOCs.\n                 18AUG09 - v1.19 - Add support for IPCSPARM DD.\n                 06AUG08 - v1.17 - Changes to support using @IPCS\n                           from multiple Images at the same time.\n                 12NOV07 - v1.12 - Better support for passed parms.\n                 15MAY07 - v1.0\n\n***************************** Rexx ***********************************/\nMsgStat = MSG(\"OFF\")\nARG DsName InParms                           /* Place arguments here */\n\nIF WORDPOS(DsName,'-h -H') > 0 THEN CALL DISPLAY_HELP\nIF ABBREV(DsName,'.')          THEN DsName = \"\"\nIF ABBREV(DsName,'HLQ(')       THEN DO\n    InParms = DsName InParms; DsName = \"\"\nEND\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nok='0'\n  x = BPXWDYN(\"ALLOC DD(IPCSPRNT) SYSOUT(K) REUSE\")\n  IF IPCSPARM \u00ac= \"\" THEN x = BPXWDYN(\"ALLOC DD(HCDMLOG) DSN(\"IPCSPARM\")\",\n                                     \"SHR REUSE\")\n  ADDRESS \"TSO\" \"ALTLIB ACTIVATE APPLICATION(EXEC) DSN(\"SBLSCLI0\")\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPSLIB DATASET ID(\"SBLSKEL0\") STACK\"\n  IF SBLSLIB0 \u00ac= \"\" THEN ADDRESS \"ISPEXEC\",\n                    \"LIBDEF ISPLLIB DATASET ID(\"SBLSLIB0\") STACK\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPMLIB DATASET ID(\"SBLSMSG0\") STACK\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB DATASET ID(\"SBLSPNL0\") STACK\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB DATASET ID(\"SBLSTBL0\") STACK\"\n\n  CALL ALLOCATE_DUMP_DIRECTORY\n  CALL SET_IPCS_DEFAULTS\n  ADDRESS \"ISPEXEC\" \"SELECT PGM(BLSG) NEWAPPL(BLSG) PASSLIB\",\n                    \"PARM(PGM(BLSGSCMD) PARM(EXEC\" START_REXX\"))\"\n\n  x = BPXWDYN(\"FREE DD(IPCSDDIR)\")\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPSLIB\"\n  IF SBLSLIB0 \u00ac= \"\" THEN ADDRESS \"ISPEXEC\" \"LIBDEF ISPLLIB\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPMLIB\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB\"\n  ADDRESS \"TSO\" \"ALTLIB DEACTIVATE APPLICATION(EXEC)\"\n  IF IPCSPARM \u00ac= \"\" THEN x = BPXWDYN(\"FREE DD(HCDMLOG)\")\n  x = BPXWDYN(\"FREE DD(IPCSPRNT)\")\n\nMsgStat = MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE = 1; FALSE = 0  /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"HLQ() TEST(O)\"\n  MatchLength = 4      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  NbrSubmited = 0\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n  IF HLQ = \"\" THEN DO\n      SBLSCLI0 = \"'SYS1.SBLSCLI0'\"\n      SBLSKEL0 = \"'SYS1.SBLSKEL0'\"\n      SBLSLIB0 = \"\"\n      SBLSMSG0 = \"'SYS1.SBLSMSG0'\"\n      SBLSPNL0 = \"'SYS1.SBLSPNL0' 'SYS1.SHASPNL0'\"\n      SBLSTBL0 = \"'SYS1.SBLSTBL0'\"\n      IPCSPARM = \"'SYS1.SHASPARM'\"\n    END\n  ELSE DO\n      SBLSCLI0 = \"'\"HLQ\".SYS1.SBLSCLI0'\"\n      SBLSCLI0 = \"'\"HLQ\".SYS1.SBLSCLI0'\"\n      SBLSKEL0 = \"'\"HLQ\".SYS1.SBLSKEL0'\"\n      SBLSLIB0 = \"'\"HLQ\".SYS1.MIGLIB' '\"HLQ\".SYS1.LINKLIB'\"\n      SBLSMSG0 = \"'\"HLQ\".SYS1.SBLSMSG0'\"\n      SBLSPNL0 = \"'\"HLQ\".SYS1.SBLSPNL0' '\"HLQ\".SYS1.SHASPNL0'\"\n      SBLSTBL0 = \"'\"HLQ\".SYS1.SBLSTBL0'\"\n      IPCSPARM = \"'\"HLQ\".SYS1.PARMLIB'\"\n  END\n  START_REXX = STRIP(WORD(SBLSCLI0,1),\"T\",\"'\")\"(BLSCALTL)'\"\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/***********************************************************/\n/***************** allocate dump directory *****************/\n/***********************************************************/\nALLOCATE_DUMP_DIRECTORY:\n  IF HLQ = \"\" THEN\n       ZOSVER = TRANSLATE(MVSVAR(\"SYSMVS\"),\"#\",\".\")\n  ELSE ZOSVER = HLQ\n  IPCS_DSN = SYSUID\".IPCS.\"ZOSVER\".DDIR.\"MVSVAR(\"SYSNAME\")\n\n  STATUS = LISTDSI(\"'\"IPCS_DSN\"' RECALL\")\n\n  IF (SYSREASON = 5) THEN DO /* NOT CATALOGED */\n      ADDRESS \"TSO\" \"DEF\",\n              \"CLUSTER(NAME('\"IPCS_DSN\"') IX RUS SHR(1 3))\",\n              \"DATA(NAME('\"IPCS_DSN\".DATA') KEYS(128 0) RECSZ(384 3072)\",\n                          \"CISZ(4096) CYLINDERS(3 2))\",\n              \"INDEX(NAME('\"IPCS_DSN\".INDEX') CYLINDERS(1 1))\"\n      ADDRESS \"TSO\" \"IPCSDDIR '\"IPCS_DSN\"'\"\n  END\n  ADDRESS \"TSO\" \"ALLOCATE FI(IPCSDDIR) DA('\"IPCS_DSN\"') SHR REUSE\"\nRETURN\n/*********************************************************************/\n/************** INVOKE IPCS IN LINE MODE TO SET DEFAULTS *************/\n/*********************************************************************/\nSET_IPCS_DEFAULTS:\n  ADDRESS \"TSO\" \"NEWSTACK\"\n    QUEUE \"SETDEF NOCONFIRM\"\n    QUEUE \"SETDEF NOPRINT NOTERMINAL\"\n    QUEUE \"SETDEF DISPLAY(NOMACHINE)\"\n    QUEUE \"SETDEF DISPLAY(NOREMARK)\"\n    QUEUE \"SETDEF DISPLAY(NOREQUEST)\"\n    QUEUE \"SETDEF DISPLAY(NOSTORAGE)\"\n    QUEUE \"SETDEF DISPLAY(NOSYMBOL)\"\n    IF DsName \u00ac= \"\" THEN DO\n        QUEUE \"SETDEF DsName(\"DsName\") NOCONFIRM\"\n        QUEUE \"OPEN DsName\"\n    END\n    QUEUE \"END\"\n\n    ADDRESS \"TSO\" \"IPCS\"\n  ADDRESS \"TSO\" \"DELSTACK\"\nRETURN\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ok='*'                               /* Ignore all non-0 RCs        */\n    ADDRESS \"ISPEXEC\" \"LIBDEF ISPSLIB\"\n    IF SBLSLIB0 \u00ac= \"\" THEN ADDRESS \"ISPEXEC\" \"LIBDEF ISPLLIB\"\n    ADDRESS \"ISPEXEC\" \"LIBDEF ISPMLIB\"\n    ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"\n    ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB\"\n    ADDRESS \"TSO\" \"ALTLIB DEACTIVATE APPLICATION(CLIST)\"\n    ADDRESS \"TSO\" \"FREE DD(IPCSDDIR)\"\n    IF IPCSPARM \u00ac= \"\" THEN CALL BPXWDYN(\"FREE DD(IPCSPARM)\")\n    CALL BPXWDYN(\"FREE DD(IPCSPRNT)\")\n    ADDRESS \"ISPEXEC\" \"FTCLOSE\"        /* Close File Tailoring DSN    */\n    ZISPFRC = ExitError                /* Initialize ISPF RC Variable */\n    ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\" /* Set ISPF RC to error RC     */\nEXIT ExitError                         /* Set TSO/MVS RC to error RC  */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@STARTUP": {"ttr": 22, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01=\\x00\\x00\\x01\\x01&\\x8f\\x01\\x17(O\\tF\\x00\\xa8\\x00w\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.61", "flags": 0, "createdate": "2001-09-25T00:00:00", "modifydate": "2017-10-11T09:46:00", "lines": 168, "newlines": 119, "modlines": 0, "user": "AL-FERG"}, "text": "/*                                   REXX\n  This logon REXX is Executed by a TSO LOGON PROC win NO Dataset\n       Allocations, so if there are any allocation issues will\n       it will leave you at the TSO READY PROMPT.\n\n       1. Verify USER's ISPF.PROFILE & Z.CLIST DSNs exist. If not,\n          clean up catalog (possible DR issue), then allocate them.\n\n       2. Set Shop Standard ISPF/TSO Datasets for later Allocation\n       3. Add Image Specific ISPF/TSO Datasets for later Allocation\n       4. Add USERID Based ISPF/TSO Datasets for later Allocation\n\n       5. Do actual allocations based on DD Values built above\n\n       6. Move TSO Variable Storage Above the Line.\n       7. IF a personal ISPF.PROFILE(STARTUP) REXX, QUEUE for Execution,\n          ELSE determine how to start ISPF and QUEUE it.\n       8. Exit and allow QUEUED Commands to execute in Order\n  ------------------------ Change History ------------------------------\n  2017-01-11 - TSAZFA - v1.60 - Minor refactoring\n  2016-12-20 - TSAZFA - v1.57 - Update ID Prefix Logic for CO & DC\n  2016-12-20 - TSAZFA - v1.54 - Add SYS1.HELPENP to SYSHELP DD.\n  2016-02-11 - TSAZFA - v1.51 - Remove OPSHLQ, no longer needed\n  2016-01-21 - TSAZFA - v1.47 - Tweaks for INS1 & JOB Scan upgrade\n  2015-12-15 - TSAZFA - v1.44 - Move all allocations into REXX and out\n                        of TSO LOGON PROC. Handle different allocation\n                        based on 1st 2 charactors of USERID.\n  2015-10-30 - TSAZFA - v1.30 - Minor Re-Factoring\n  2015-10-30 - TSAZFA - v1.28 - Add IDIOFF as DUMMY\n  2015-10-30 - TSAZFA - v1.25 - Add ISPLOG SYSOUT(0), trash after LOGOFF\n  2015-10-13 - TSAZFA - v1.22 - Minor Cleanup and comments\n  2015-10-12 - TSAZFA - v1.17 - Tweaks to make more generic\n  2015-10-12 - TSAZFA - v1.15 - Fix issues remove dead code.\n  2015-10-12 - TSAZFA - v1.00 - First SCDC Version\n*/\nARG args\n\nCALL ALLOC_PERSONAL_DSNS\nCALL ADD_SHOP_ALLOCATIONS\nCALL ADD_IMAGE_ALLOCATIONS\nCALL ADD_USERID_ALLOCATIONS\nCALL DO_STANDARD_ALLOCATIONS\n              /* Move TSO Variable Storage Above the Line            */\nADDRESS \"TSO\" \"PROFILE VARSTORAGE(HIGH)\"\nSELECT\n  WHEN SYSDSN(\"ISPF.PROFILE(STARTUP)\") = \"OK\" THEN /* Custom Startup */\n       QUEUE \"EXEC '\"SYSVAR(\"SYSUID\")\".ISPF.PROFILE(STARTUP)'\"\n  WHEN args = \"\"                              THEN /* Basic Startup  */\n       QUEUE \"ISPSTART PANEL(ISR@PRIM) NEWAPPL(ISR) SHRPROF\"\nOTHERWISE; QUEUE args                        ;END  /* Passed Startup */\n\nEXIT 0\n/*--------------------------------------------------------------------\n     Add all standard Shop Datasets to initial concatinations\n  --------------------------------------------------------------------*/\nADD_SHOP_ALLOCATIONS:\n  ISPLLIB = \"'SYS3.ISPF.ISPLLIB' 'SSWCSYS.ISPF.STEPLIB'\"\n  ISPMLIB = \"'SYS3.ISPF.ISPMLIB' 'ISP.SISPMENU' 'SSWCSYS.ISPF.ISPMLIB'\"\n  ISPPLIB = \"'SYS3.ISPF.ISPPLIB' 'ISP.SISPPENU' 'SSWCSYS.ISPF.ISPPLIB'\"\n  ISPSLIB = \"'SYS3.ISPF.ISPSLIB' 'ISP.SISPSENU' 'ISP.SISPSLIB'\"\n  ISPTLIB = \"'SYS3.ISPF.ISPTLIB' 'ISP.SISPTENU' 'SSWCSYS.ISPF.ISPTLIB'\"\n\n  SYSEXEC = \"'SYS3.ISPF.EXEC' 'ISP.SISPEXEC'\"\n  SYSHELP = \"'SYS1.HELP' 'SYS1.HELPENP' 'ISP.SISPHELP' 'SYS3.ISPF.HELP'\"\n  SYSPROC = \"'SYS3.ISPF.CLIST' 'ISP.SISPCLIB' 'SSWCSYS.ISPF.SYSPROC' Z.CLIST\"\nRETURN\n/*--------------------------------------------------------------------\n     Add all Image Specific Datasets to concatinations\n  --------------------------------------------------------------------*/\nADD_IMAGE_ALLOCATIONS:\n  EnvHlq  = MVSVAR(\"SYM\",\"ENVCLONE\")||\"SYS\"\n  SYSNAME = MVSVAR(\"SYSNAME\")\n  SELECT\n    WHEN ABBREV(SYSNAME,\"DEV\") THEN DO /* Development Images ...      */\n      SYSEXEC = SYSEXEC \"'SSWCSYS.ISPF.SYSEXEC'\"\n      SYSPROC = \"'\"EnvHlq\".JOBSCAN.CLIST'\" SYSPROC\n     END\n    WHEN ABBREV(SYSNAME,\"PRD\") THEN DO /* Production Images ...       */\n      SYSEXEC = SYSEXEC \"'SSWCSYS.ISPF.SYSEXEC'\"\n      SYSPROC = \"'\"EnvHlq\".JOBSCAN.CLIST'\" SYSPROC\n     END\n    WHEN ABBREV(SYSNAME,\"INS\") THEN DO /* Installation Images ...     */\n      SYSEXEC = SYSEXEC \"'ISWCSYS.ISPF.SYSEXEC'\"\n      SYSPROC = \"'SSWCSYS.JS781.CLIST'\" SYSPROC\n     END\n  OTHERWISE; NOP; END\nRETURN\n/*--------------------------------------------------------------------\n     Add all USERID Based Datasets to concatinations\n  --------------------------------------------------------------------*/\nADD_USERID_ALLOCATIONS:\n  fst2 = LEFT(SYSVAR(\"SYSUID\"),2)\n  SELECT\n    WHEN WORDPOS(fst2,\"AR\")       > 0 THEN DO\n     /* ISPPLIB = \"'SSWCSYS.ISPF.ISPPLIB.AR'\" ISPPLIB   */\n      END\n    WHEN WORDPOS(fst2,\"CO DC TS\") > 0 THEN DO\n        ISPLLIB = \"'SYS3.TECH.ISPLLIB'\" ISPLLIB\n        ISPMLIB = \"'SYS3.TECH.ISPMLIB'\" ISPMLIB\n        ISPPLIB = \"'SYS3.TECH.ISPPLIB'\" ISPPLIB\n        ISPSLIB = \"'SYS3.TECH.ISPSLIB'\" ISPSLIB\n        ISPTLIB = \"'SYS3.TECH.ISPTLIB'\" ISPTLIB\n        SYSEXEC = \"'SYS3.TECH.EXEC'\"    SYSEXEC \"'SYS2.OPSMVS.CCLXEXEC'\"\n        SYSHELP = \"'SYS3.TECH.HELP'\"    SYSHELP \"'SYS2.OPSMVS.CCLXHENU'\"\n        SYSPROC = \"'SYS3.TECH.CLIST'\"   SYSPROC\n      END\n    WHEN WORDPOS(fst2,\"CT\")       > 0 THEN DO\n     /* ISPPLIB = \"'SSWCSYS.ISPF.ISPPLIB.CT'\" ISPPLIB   */\n      END\n    WHEN WORDPOS(fst2,\"LS\")       > 0 THEN DO\n        ISPPLIB = \"'SSWCSYS.ISPF.ISPPLIB.LS'\" ISPPLIB   /* Cleanup ISR@PRIM */\n      END\n    WHEN WORDPOS(fst2,\"MS\")       > 0 THEN DO\n     /* ISPPLIB = \"'SSWCSYS.ISPF.ISPPLIB.MS'\" ISPPLIB   */\n      END\n    WHEN WORDPOS(fst2,\"OM\")       > 0 THEN DO\n     /* ISPPLIB = \"'SSWCSYS.ISPF.ISPPLIB.OM'\" ISPPLIB   */\n      END\n    WHEN WORDPOS(fst2,\"SP\")       > 0 THEN DO\n     /* ISPPLIB = \"'SSWCSYS.ISPF.ISPPLIB.SP'\" ISPPLIB   */\n      END\n    WHEN WORDPOS(fst2,\"VP\")       > 0 THEN DO\n     /* ISPPLIB = \"'SSWCSYS.ISPF.ISPPLIB.VP'\" ISPPLIB   */\n      END\n  OTHERWISE; NOP; END\nRETURN\n/*--------------------------------------------------------------------\n     Allocate the necessary ISPF PROFILE and TABLE DDs\n  --------------------------------------------------------------------*/\nDO_STANDARD_ALLOCATIONS:\n                /* Allocate Standard Shared ISPF Datasets             */\n  ADDRESS \"TSO\" \"ALLOC DD(ISPLLIB) SHR REUSE DSN(\"ISPLLIB\")\"\n  ADDRESS \"TSO\" \"ALLOC DD(ISPMLIB) SHR REUSE DSN(\"ISPMLIB\")\"\n  ADDRESS \"TSO\" \"ALLOC DD(ISPPLIB) SHR REUSE DSN(\"ISPPLIB\")\"\n  ADDRESS \"TSO\" \"ALLOC DD(ISPSLIB) SHR REUSE DSN(\"ISPSLIB\")\"\n  ADDRESS \"TSO\" \"ALLOC DD(ISPTLIB) SHR REUSE DSN(\"ISPPROF ISPTLIB\")\"\n                /* Allocate Standard Personal ISPF Datasets           */\n  ADDRESS \"TSO\" \"ALLOC DD(ISPLOG)  SYSOUT(0) RECFM(V,B,A) LRECL(125) REUSE\"\n  ADDRESS \"TSO\" \"ALLOC DD(ISPPROF) SHR REUSE DSN(\"ISPPROF\")\"\n  ADDRESS \"TSO\" \"ALLOC DD(ISPTABL) SHR REUSE DSN(\"ISPPROF\")\"\n                /* Allocate Standard TSO Datasets                     */\n  ADDRESS \"TSO\" \"ALLOC DD(SYSEXEC) SHR REUSE DSN(\"SYSEXEC\")\"\n  ADDRESS \"TSO\" \"ALLOC DD(SYSHELP) SHR REUSE DSN(\"SYSHELP\")\"\n  ADDRESS \"TSO\" \"ALLOC DD(SYSPROC) SHR REUSE DSN(\"SYSPROC\")\"\n                /* Allocate any additional Datasets or DDs            */\n  ADDRESS \"TSO\" \"ALLOC DD(IDIOFF) DUMMY\"       /* No Fault Analalyzer */\nRETURN\n/*--------------------------------------------------------------------\n     Ensure Personal ISPF.PROFILE and Z.CNTL Datasets Exist\n  --------------------------------------------------------------------*/\nALLOC_PERSONAL_DSNS:\n  ISPPROF = \"ISPF.PROFILE\"\n  ALLOCOP = \"CATALOG TRACKS SPACE(15,30) DSNTYPE(LIBRARY,2)\" ,\n            \"DSORG(PO) RECFM(F,B) LRECL(80) BLKSIZE(0)\"\n  IF SYSDSN(ISPPROF) \u00ac= \"OK\" THEN DO\n     SAY \"=*=*=> Allocating your personal ISPF.PROFILE dataset!\"\n     ADDRESS \"TSO\" \"DELETE\" ISPPROF \"NVSAM NSCR\"  /* If bad CAT entry */\n     ADDRESS \"TSO\" \"ALLOC DD(ISPPROF) DSN(\"ISPPROF\") NEW REUSE\" ALLOCOP\n     ADDRESS \"TSO\" \"FREE DD(ISPPROF)\"\n  END\n  MYCLIST = \"Z.CLIST\"\n  IF SYSDSN(MYCLIST) \u00ac= \"OK\" THEN DO\n     SAY \"=*=*=> Allocating your personal Z.CLIST dataset!\"\n     ADDRESS \"TSO\" \"DELETE\" MYCLIST \"NVSAM NOSCR\" /* If bad CAT entry */\n     ADDRESS \"TSO\" \"ALLOC DD(MYCLIST) DSN(\"MYCLIST\") NEW REUSE\" ALLOCOP\n     ADDRESS \"TSO\" \"FREE DD(MYCLIST)\"\n  END\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CA1DS34": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x00\\x01\\x152\\x8f\\x01\\x17(O\\tF\\x01b\\x01R\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2015-11-24T00:00:00", "modifydate": "2017-10-11T09:46:00", "lines": 354, "newlines": 338, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n\n This REXX is used to invoke an equivelent to CA1's TI REXX, but works\n      when invoked from an ISPF DSLIST \"I\" Command\"\n\n                           --- EXAMPLE ---\nTSO <%>CA1DS34 option ZDLDSN ZDLVOL <TEST(TraceOption)>\nTSO <%>CA1DS34 -H -- To display help for this REXX\n\n  Arguments: option      - Option used in DSLIST that generated call\n                           to this REXX (Generally I or M)\n             ZDLDSN      - DSLIST DSN\n             ZDLVOL      - DSLIST 1st Tape VOLSER\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: The current DSN on the DSLIST display\nOther EXECS: Modeled off CA1's TI EXEC.\n\nEXEC History\n\n REXX EXEC Name: CA1DS34\n         Author: AL FERGUSON - TS ADM (TSAZFA)\n         Writen: 24NOV15\n        History: 06FEB17 - v1.06 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v1.05 - Mass update to pickup Error\n                           Handling Fixes.\n                 31JAN17 - v1.04 - Update all REXXes with latest\n                           common routines via %CCMASS\n                 24NOV15 - v1.0\n\n***************************** Rexx ***********************************/\nMsgStat = MSG(\"OFF\")\nPARSE ARG option ZDLDSN ZDLVOL InParms       /* Place arguments here */\n\nIF WORDPOS(InParms,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nok='0'\nIF ZDLVOL = \"\" THEN DO\n   ADDRESS \"ISPEXEC\" \"VGET (ZDLDSN ZDLVOL) SHARED\"\n   IF ZDLVOL = \"\" THEN DO\n      CALL SET_MSG \"\",\"'%\"rname\" needs the Dataset Name and Volser!\", \"YES\"\n      EXIT\n   END\n END\nELSE ADDRESS \"ISPEXEC\" \"VPUT (ZDLDSN ZDLVOL) SHARED\"\n\nok='0';\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPMLIB DATASET ID(\"CA1_ISPMLIB\")\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB DATASET ID(\"CA1_ISPPLIB\")\"\n\nok='0 4';ADDRESS \"TSO\" \"CALL *(CTSTI)\"     /* CA1 LOADLIB in LINKLIST */\n\nok='0';ADDRESS \"ISPEXEC\" \"LIBDEF ISPMLIB\"\nok='0';ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"\n\nMsgStat = MSG(MsgStat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE = 1; FALSE = 0  /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"TEST(O)\"\n  MatchLength = 4      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  NbrSubmited = 0\n  SYSUID = USERID()\n  UserPrefix = LEFT(SYSUID,4)\n  ExitError = 0; SqlError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname = MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\n  CA1_ISPMLIB = \"'SSWCSYS.CA1.R126.CTAPMENU'\"\n  CA1_ISPPLIB = \"'SSWCSYS.CA1.R126.CTAPPENU'\"\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DYNMISPF": {"ttr": 257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x03\\x00\\x00\\x01\\x17\"/\\x01\\x17(O\\tF\\x00\\xd3\\x00\\xce\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "02.03", "flags": 0, "createdate": "2017-08-10T00:00:00", "modifydate": "2017-10-11T09:46:00", "lines": 211, "newlines": 206, "modlines": 0, "user": "AL-FERG"}, "text": "/*                                   REXX\n  This logon REXX is Executed by a TSO LOGON PROC win NO Dataset\n       Allocations, so if there are any allocation issues will\n       it will leave you at the TSO READY PROMPT.\n\n       1. Verify USER's ISPF.PROFILE & Z.CLIST DSNs exist. If not,\n          clean up catalog (possible DR issue), then allocate them.\n\n       2. Set Shop Standard ISPF/TSO Datasets for later Allocation\n       3. Add Image Specific ISPF/TSO Datasets for later Allocation\n       4. Add USERID Based ISPF/TSO Datasets for later Allocation\n\n       5. Do actual allocations based on DD Values built above\n\n       6. Move TSO Variable Storage Above the Line.\n       7. IF a personal ISPF.PROFILE(STARTUP) REXX, QUEUE for Execution,\n          ELSE determine how to start ISPF and QUEUE it.\n       8. Exit and allow QUEUED Commands to execute in Order\n  ------------------------ Change History ------------------------------\n  2017-07-10 - TSAZFA - v2.01 - Add Personel USER DSNs to @STARTUP\n  2017-01-11 - TSAZFA - v1.60 - Minor refactoring\n  2016-12-20 - TSAZFA - v1.57 - Update ID Prefix Logic for CO & DC\n  2016-12-20 - TSAZFA - v1.54 - Add SYS1.HELPENP to SYSHELP DD.\n  2016-02-11 - TSAZFA - v1.51 - Remove OPSHLQ, no longer needed\n  2016-01-21 - TSAZFA - v1.47 - Tweaks for INS1 & JOB Scan upgrade\n  2015-12-15 - TSAZFA - v1.44 - Move all allocations into REXX and out\n                        of TSO LOGON PROC. Handle different allocation\n                        based on 1st 2 charactors of USERID.\n  2015-10-30 - TSAZFA - v1.30 - Minor Re-Factoring\n  2015-10-30 - TSAZFA - v1.28 - Add IDIOFF as DUMMY\n  2015-10-30 - TSAZFA - v1.25 - Add ISPLOG SYSOUT(0), trash after LOGOFF\n  2015-10-13 - TSAZFA - v1.22 - Minor Cleanup and comments\n  2015-10-12 - TSAZFA - v1.17 - Tweaks to make more generic\n  2015-10-12 - TSAZFA - v1.15 - Fix issues remove dead code.\n  2015-10-12 - TSAZFA - v1.00 - First SCDC Version\n*/\nARG args\nCALL ADD_SHOP_ALLOCATIONS\nCALL ADD_IMAGE_ALLOCATIONS\nCALL ADD_USER_GROUP_ALLOCATIONS\n\nCALL ALLOC_PERSONAL_DSNS\nCALL ADD_USER_ALLOCATIONS\n\nCALL DO_STANDARD_ALLOCATIONS\n              /* Move TSO Variable Storage Above the Line            */\nADDRESS \"TSO\" \"PROFILE VARSTORAGE(HIGH)\"\nSELECT\n  WHEN SYSDSN(\"ISPF.PROFILE(STARTUP)\") = \"OK\" THEN /* Custom Startup */\n       QUEUE \"EXEC '\"SYSVAR(\"SYSUID\")\".ISPF.PROFILE(STARTUP)'\"\n  WHEN args = \"\"                              THEN /* Basic Startup  */\n       QUEUE \"ISPSTART PANEL(ISR@PRIM) NEWAPPL(ISR) SHRPROF\"\nOTHERWISE; QUEUE args                        ;END  /* Passed Startup */\n\nEXIT 0\n/*--------------------------------------------------------------------\n     Add all standard Shop Datasets to initial concatinations\n  --------------------------------------------------------------------*/\nADD_SHOP_ALLOCATIONS:\n  ISPLLIB = \"'SYS3.ISPF.ISPLLIB' 'SSWCSYS.ISPF.STEPLIB'\"\n  ISPMLIB = \"'SYS3.ISPF.ISPMLIB' 'ISP.SISPMENU' 'SSWCSYS.ISPF.ISPMLIB'\"\n  ISPPLIB = \"'SYS3.ISPF.ISPPLIB' 'ISP.SISPPENU' 'SSWCSYS.ISPF.ISPPLIB'\"\n  ISPSLIB = \"'SYS3.ISPF.ISPSLIB' 'ISP.SISPSENU' 'ISP.SISPSLIB'\"\n  ISPTLIB = \"'SYS3.ISPF.ISPTLIB' 'ISP.SISPTENU' 'SSWCSYS.ISPF.ISPTLIB'\"\n\n  SYSEXEC = \"'SYS3.ISPF.EXEC' 'ISP.SISPEXEC'\"\n  SYSHELP = \"'SYS1.HELP' 'SYS1.HELPENP' 'ISP.SISPHELP' 'SYS3.ISPF.HELP'\"\n  SYSPROC = \"'SYS3.ISPF.CLIST' 'ISP.SISPCLIB' 'SSWCSYS.ISPF.SYSPROC' Z.CLIST\"\nRETURN\n/*--------------------------------------------------------------------\n     Add all Image Specific Datasets to concatinations\n  --------------------------------------------------------------------*/\nADD_IMAGE_ALLOCATIONS:\n  EnvClone = MVSVAR(\"SYM\",\"ENVCLONE\")\n  SYSNAME  = MVSVAR(\"SYSNAME\")\n  SELECT\n    WHEN ABBREV(SYSNAME,\"DEV\")  THEN DO /* Development Images ...     */\n      SYSEXEC = SYSEXEC \"'SSWCSYS.ISPF.SYSEXEC'\"\n      SYSPROC = \"'\"EnvClone\"SYS.JOBSCAN.CLIST'\" SYSPROC\n     END\n    WHEN ABBREV(SYSNAME,\"PRDA\") THEN DO /* AWS Prod Test Image ...    */\n      SYSEXEC = SYSEXEC \"'SSWCSYS.ISPF.SYSEXEC'\"\n      SYSPROC = \"'\"EnvClone\"SYS.JOBSCAN.CLIST'\" SYSPROC\n     END\n    WHEN ABBREV(SYSNAME,\"PRD\")  THEN DO /* Production Images ...      */\n      SYSEXEC = SYSEXEC \"'SSWCSYS.ISPF.SYSEXEC'\"\n      SYSPROC = \"'\"EnvClone\"SYS.JOBSCAN.CLIST'\" SYSPROC\n     END\n    WHEN ABBREV(SYSNAME,\"INS\")  THEN DO /* Installation Images ...    */\n      SYSEXEC = SYSEXEC \"'\"EnvClone\"SWCSYS.ISPF.SYSEXEC'\"\n      SYSPROC = \"'SSWCSYS.JS781.CLIST'\" SYSPROC\n     END\n  OTHERWISE; NOP; END\nRETURN\n/*--------------------------------------------------------------------\n     Add all USER GROUP Based Datasets to concatinations\n  --------------------------------------------------------------------*/\nADD_USER_GROUP_ALLOCATIONS:\n  fst2 = LEFT(SYSVAR(\"SYSUID\"),2)\n  SELECT\n    WHEN WORDPOS(fst2,\"AR\")       > 0 THEN DO\n     /* ISPPLIB = \"'SSWCSYS.ISPF.ISPPLIB.AR'\" ISPPLIB   */\n      END\n    WHEN WORDPOS(fst2,\"CO DC TS\") > 0 THEN DO\n        ISPLLIB = \"'SYS3.TECH.ISPLLIB'\" ISPLLIB\n        ISPMLIB = \"'SYS3.TECH.ISPMLIB'\" ISPMLIB\n        ISPPLIB = \"'SYS3.TECH.ISPPLIB'\" ISPPLIB\n        ISPSLIB = \"'SYS3.TECH.ISPSLIB'\" ISPSLIB\n        ISPTLIB = \"'SYS3.TECH.ISPTLIB'\" ISPTLIB\n        SYSEXEC = \"'SYS3.TECH.EXEC'\"    SYSEXEC \"'SYS2.OPSMVS.CCLXEXEC'\"\n        SYSHELP = \"'SYS3.TECH.HELP'\"    SYSHELP \"'SYS2.OPSMVS.CCLXHENU'\"\n        SYSPROC = \"'SYS3.TECH.CLIST'\"   SYSPROC\n      END\n    WHEN WORDPOS(fst2,\"CT\")       > 0 THEN DO\n     /* ISPPLIB = \"'SSWCSYS.ISPF.ISPPLIB.CT'\" ISPPLIB   */\n      END\n    WHEN WORDPOS(fst2,\"LS\")       > 0 THEN DO\n        ISPPLIB = \"'SSWCSYS.ISPF.ISPPLIB.LS'\" ISPPLIB   /* Cleanup ISR@PRIM */\n      END\n    WHEN WORDPOS(fst2,\"MS\")       > 0 THEN DO\n     /* ISPPLIB = \"'SSWCSYS.ISPF.ISPPLIB.MS'\" ISPPLIB   */\n      END\n    WHEN WORDPOS(fst2,\"OM\")       > 0 THEN DO\n     /* ISPPLIB = \"'SSWCSYS.ISPF.ISPPLIB.OM'\" ISPPLIB   */\n      END\n    WHEN WORDPOS(fst2,\"SP\")       > 0 THEN DO\n     /* ISPPLIB = \"'SSWCSYS.ISPF.ISPPLIB.SP'\" ISPPLIB   */\n      END\n    WHEN WORDPOS(fst2,\"VP\")       > 0 THEN DO\n     /* ISPPLIB = \"'SSWCSYS.ISPF.ISPPLIB.VP'\" ISPPLIB   */\n      END\n  OTHERWISE; NOP; END\nRETURN\n/*--------------------------------------------------------------------\n     Ensure Personal ISPF.PROFILE and Z.CNTL Datasets Exist\n  --------------------------------------------------------------------*/\nALLOC_PERSONAL_DSNS:\n  ISPPROF = \"ISPF.PROFILE\"\n  ALLOCOP = \"CATALOG TRACKS SPACE(15,30) DSNTYPE(LIBRARY,2)\" ,\n            \"DSORG(PO) RECFM(F,B) LRECL(80) BLKSIZE(0)\"\n  IF SYSDSN(ISPPROF) \u00ac= \"OK\" THEN DO\n     SAY \"=*=*=> Allocating your personal ISPF.PROFILE dataset!\"\n     ADDRESS \"TSO\" \"DELETE\" ISPPROF \"NVSAM NSCR\"  /* If bad CAT entry */\n     ADDRESS \"TSO\" \"ALLOC DD(ISPPROF) DSN(\"ISPPROF\") NEW REUSE\" ALLOCOP\n     ADDRESS \"TSO\" \"FREE DD(ISPPROF)\"\n  END\n  MYCLIST = \"Z.CLIST\"\n  IF SYSDSN(MYCLIST) \u00ac= \"OK\" THEN DO\n     SAY \"=*=*=> Allocating your personal Z.CLIST dataset!\"\n     ADDRESS \"TSO\" \"DELETE\" MYCLIST \"NVSAM NOSCR\" /* If bad CAT entry */\n     ADDRESS \"TSO\" \"ALLOC DD(MYCLIST) DSN(\"MYCLIST\") NEW REUSE\" ALLOCOP\n     ADDRESS \"TSO\" \"FREE DD(MYCLIST)\"\n  END\nRETURN\n/*---------------------------------------------------------------------*\n          Update concatinations for User's Personal ISPF DSNs\n *---------------------------------------------------------------------*/\nADD_USER_ALLOCATIONS:         /* Setup existing personal ISPF DSNs     */\n  IF SYSDSN(\"ISPF.ISPLLIB\") = \"OK\" THEN IF,\n     ISPLLIB = \"\" THEN ISPLLIB = \"ISPF.ISPLLIB\"\n                  ELSE ISPLLIB = \"ISPF.ISPLLIB\" ISPLLIB\n  IF SYSDSN(\"ISPF.ISPMLIB\") = \"OK\" THEN IF,\n     ISPMLIB = \"\" THEN ISPMLIB = \"ISPF.ISPMLIB\"\n                  ELSE ISPMLIB = \"ISPF.ISPMLIB\" ISPMLIB\n  IF SYSDSN(\"ISPF.ISPPLIB\") = \"OK\" THEN IF,\n     ISPPLIB = \"\" THEN ISPPLIB = \"ISPF.ISPPLIB\"\n                  ELSE ISPPLIB = \"ISPF.ISPPLIB\" ISPPLIB\n  IF SYSDSN(\"ISPF.ISPSLIB\") = \"OK\" THEN IF,\n     ISPSLIB = \"\" THEN ISPSLIB = \"ISPF.ISPSLIB\"\n                  ELSE ISPSLIB = \"ISPF.ISPSLIB\" ISPSLIB\n  IF SYSDSN(\"ISPF.ISPTLIB\") = \"OK\" THEN IF,\n     ISPTLIB = \"\" THEN ISPTLIB = \"ISPF.ISPTLIB\"\n                  ELSE ISPTLIB = \"ISPF.ISPTLIB\" ISPTLIB\n                              /* Setup existing personal TSO DSNs      */\n  IF SYSDSN(\"Z.EXEC\") = \"OK\"       THEN IF,\n     SYSEXEC = \"\" THEN SYSEXEC = \"Z.EXEC\"\n                  ELSE SYSEXEC = \"Z.EXEC\" SYSEXEC\n  IF SYSDSN(\"Z.HELP\") = \"OK\"       THEN IF,\n     SYSHELP = \"\" THEN SYSHELP = \"Z.HELP\"\n                  ELSE SYSHELP = \"Z.HELP\" SYSHELP\n  IF SYSDSN(\"Z.CLIST\") = \"OK\"      THEN IF, /* Move personal CList 1st */\n     SYSPROC = \"\" THEN SYSPROC = \"Z.CLIST\"\n                  ELSE SYSPROC = \"Z.CLIST\" SYSPROC\n  IF SYSDSN(\"Z.LOADLIB\") = \"OK\"    THEN IF,\n     TSOLIB = \"\"  THEN TSOLIB = \"Z.LOADLIB\"\n                  ELSE TSOLIB = \"Z.LOADLIB\" TSOLIB\n  IF SYSDSN(\"Z.TSOLIB\") = \"OK\"     THEN IF,\n     TSOLIB = \"\"  THEN TSOLIB = \"Z.TSOLIB\"\n                  ELSE TSOLIB = \"Z.TSOLIB\" TSOLIB\nRETURN\n/*--------------------------------------------------------------------\n     Allocate the necessary ISPF PROFILE and TABLE DDs\n  --------------------------------------------------------------------*/\nDO_STANDARD_ALLOCATIONS:\n                /* Allocate Standard Shared ISPF Datasets             */\n  ADDRESS \"TSO\" \"ALLOC DD(ISPLLIB) SHR REUSE DSN(\"ISPLLIB\")\"\n  ADDRESS \"TSO\" \"ALLOC DD(ISPMLIB) SHR REUSE DSN(\"ISPMLIB\")\"\n  ADDRESS \"TSO\" \"ALLOC DD(ISPPLIB) SHR REUSE DSN(\"ISPPLIB\")\"\n  ADDRESS \"TSO\" \"ALLOC DD(ISPSLIB) SHR REUSE DSN(\"ISPSLIB\")\"\n  ADDRESS \"TSO\" \"ALLOC DD(ISPTLIB) SHR REUSE DSN(\"ISPPROF ISPTLIB\")\"\n                /* Allocate Standard Personal ISPF Datasets           */\n  ADDRESS \"TSO\" \"ALLOC DD(ISPPROF) SHR REUSE DSN(\"ISPPROF\")\"\n  ADDRESS \"TSO\" \"ALLOC DD(ISPTABL) SHR REUSE DSN(\"ISPPROF\")\"\n                /* Allocate Standard TSO Datasets                     */\n  ADDRESS \"TSO\" \"ALLOC DD(SYSEXEC) SHR REUSE DSN(\"SYSEXEC\")\"\n  ADDRESS \"TSO\" \"ALLOC DD(SYSHELP) SHR REUSE DSN(\"SYSHELP\")\"\n  ADDRESS \"TSO\" \"ALLOC DD(SYSPROC) SHR REUSE DSN(\"SYSPROC\")\"\n                /* Allocate any additional Datasets or DDs            */\n  ADDRESS \"TSO\" \"ALLOC DD(IDIOFF) DUMMY\"       /* No Fault Analalyzer */\n  ADDRESS \"TSO\" \"ALLOC DD(ISPLOG) SYSOUT(0) RECFM(V,B,A) LRECL(125) REUSE\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FM": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01&\\x00\\x00\\x01\\x050\\x1f\\x01\\x17(O\\tF\\x01\\x8f\\x01n\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.38", "flags": 0, "createdate": "2005-10-28T00:00:00", "modifydate": "2017-10-11T09:46:00", "lines": 399, "newlines": 366, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n\n This REXX allocates the appropriate File Manager libraries and then\n      Displays the File Manager Startup Screen\n\n                           --- EXAMPLE ---\nTSO <%>FM option dataset inparms <PROD_TEST(PROD|TEST)> <TEST(trace option)>\nTSO <%>FM -H -- To display help for this REXX\n\n  Arguments: option      - Browse, Edit, or View\n             dataset     - Dataset Name to perform action against\n             inparms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n               PROD_TEST - System DSNs to use, PROD or TEST\n                           default: PROD\n                    TEST - Used to control traces\n\n      Files: NONE\nOther EXECS: NONE\n\nEXEC History\n\n REXX EXEC Name: FM\n         Author: Al Ferguson (HUL2353)\n         Writen: 28OCT05\n        History: 27SEP12 - Version 1.34 - STEPLIBs moved linklist,\n                           removing DynaSTEP usage.\n                 10MAY11 - Version 1.24 - Update COBOL Compiler library\n                           to SYS2.COBOL vs IGY .\n                 05AUG08 - Version 1.14 - Multiple fixes, support for\n                           TEST/PROD, new DSN Names.\n                 03NOV05 - Version 1.03 - Added COBOL and PL/I Compilers\n                           to STEPLIB\n                 28OCT05 - Version 1.0\n\n***************************** Rexx ***********************************/\nmsgstat = MSG(\"OFF\")\nARG option dataset inparms                   /* Place arguments here */\n\nIF WORDPOS(option,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n    ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"  /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nok='0'\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPMLIB DATASET ID(\"fm_ISPMLIB\") STACK\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB DATASET ID(\"fm_ISPPLIB\") STACK\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPSLIB DATASET ID(\"fm_ISPSLIB\") STACK\"\n  ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB DATASET ID(\"fm_ISPTLIB\") STACK\"\n  ADDRESS \"TSO\" \"ALTLIB ACT APPLICATION (EXEC) DSNAME(\"fm_SYSEXEC\")\"\nok='*'\n   SELECT\n     WHEN ABBREV(option, \"B\") THEN ADDRESS \"ISPEXEC\" \"SELECT PGM(FILEMGR)\",\n          \"PARM(DSB\" dataset anything_else\") NEWAPPL(FMN) PASSLIB\"\n     WHEN ABBREV(option, \"E\") THEN ADDRESS \"ISPEXEC\" \"SELECT PGM(FILEMGR)\",\n          \"PARM(DSE\" dataset anything_else\") NEWAPPL(FMN) PASSLIB\"\n     WHEN ABBREV(option, \"I\") THEN ADDRESS \"ISPEXEC\" \"SELECT PGM(FILEMGR)\",\n          \"PARM(DSI\" dataset anything_else\") NEWAPPL(FMN) PASSLIB\"\n     WHEN ABBREV(option, \"V\") THEN ADDRESS \"ISPEXEC\" \"SELECT PGM(FILEMGR)\",\n          \"PARM(DSV\" dataset anything_else\") NEWAPPL(FMN) PASSLIB\"\n   OTHERWISE\n       ADDRESS \"ISPEXEC\" \"SELECT PANEL(FMNSTASK) NEWAPPL(FMN) PASSLIB\"\n   END\n\nIF RC \u00ac= 0 THEN CALL SET_MSG \"File Manager RC=\"RC,, \"YES\"\nok='0'\n   ADDRESS \"TSO\" \"ALTLIB DEACT APPLICATION (EXEC)\"\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB\"\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPSLIB\"\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"\n   ADDRESS \"ISPEXEC\" \"LIBDEF ISPMLIB\"\n\nmsgstat = MSG(msgstat)\nEXIT exit_error\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE = 1; FALSE = 0  /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  valid_parms = \"PROD_TEST() TEST(O)\"\n  match_length = 4                /* NP-Parms match on first # chars  */\n  IF valid_parms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  no_submited = 0\n  SYSUID = SYSVAR(\"SYSUID\")\n  user_prefix = LEFT(SYSUID,4)\n  exit_error = 0; sql_error = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n  IF ABBREV(anything_else, \"TEST\") THEN DO\n      PROD_TEST = \"TEST\"\n      anything_else = STRIP(RIGHT(anything_else,LENGTH(anything_else)-4))\n  END\n  IF ABBREV(PROD_TEST, \"TEST\") THEN\n       HLQ = \"SYST.FILEMGR\"\n  ELSE HLQ= \"FMN\"\n\n  fm_ISPMLIB =\"'\"HLQ\".SFMNMENU'\"\n  fm_ISPPLIB =\"'\"HLQ\".SFMNPENU'\"\n  fm_ISPSLIB =\"'\"HLQ\".SFMNSLIB'\"\n  fm_ISPTLIB =\"'\"HLQ\".SFMNTENU'\"\n  fm_SYSEXEC =\"'\"HLQ\".SFMNEXEC'\"\n  fm_STEPLIB =\"'\"HLQ\".SFMNMOD1' 'IBMZ.SIBMZCMP' 'IGY.SIGYCOMP'\"\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG exit_or_return .                                                    /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n      source.i = SOURCELINE(i + 1)  /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO   /* No ISPF, use SAY to display help            *//*COPY*/\n      DO i = 1 TO i                                                     /*COPY*/\n          SAY source.i                                                  /*COPY*/\n      END                                                               /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n      PARSE SOURCE . . rname .      /* Get REXX EXEC name             *//*COPY*/\n                                                                        /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\" /*COPY*/\n      DO i = 1 TO i    /* Build HELP table to display                 *//*COPY*/\n          source = source.i                                             /*COPY*/\n          ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"                             /*COPY*/\n      END                                                               /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                          /*COPY*/\n      ZTDMARK = CENTER(\"----> END of Help <----\",80)                    /*COPY*/\n      ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"     /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                        /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',exit_or_return,3) THEN RETURN                        /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Possitional Parms in a           /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  vp_list = valid_parms ' '; in_list = inparms ' '                      /*COPY*/\n  parm_list = ''; parm_error_list = ''                                  /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(valid_parms) UNTIL vp_list = ''                  /*COPY*/\n      PARSE VALUE vp_list WITH parm.linx '(' parm_val.linx ') ' vp_list /*COPY*/\n      parm_list = parm_list STRIP(LEFT(parm.linx,match_length))         /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(in_list, '(') > 0                                      /*COPY*/\n      PARSE VALUE in_list WITH parm '(' value ') ' in_list              /*COPY*/\n      UPPER parm           /* Don't want to translate value to UPPER */ /*COPY*/\n      parm = STRIP(parm)                                                /*COPY*/\n      parm_number = WORDPOS(STRIP(LEFT(parm,match_length)), parm_list)  /*COPY*/\n      IF parm_number > 0 THEN parm_val.parm_number = value              /*COPY*/\n      ELSE IF INDEX(value,\")\") > 0 THEN                                 /*COPY*/\n           parm_error_list = parm_error_list parm\"(\"value               /*COPY*/\n      ELSE parm_error_list = parm_error_list parm\"(\"value\")\"            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN parm_error_list \u00ac= '' & accept_all = TRUE THEN                 /*COPY*/\n        anything_else = STRIP(in_list) parm_error_list                  /*COPY*/\n    WHEN parm_error_list \u00ac= ''                     THEN DO              /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"parm_error_list\"' not valid Parm(s) for\" rname\"!\", \"YES\" /*COPY*/\n        EXIT 8                                                          /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      anything_else = STRIP(in_list)                                    /*COPY*/\n  END                                                                   /*COPY*/\n  DO parm_inx = 1 TO linx                                               /*COPY*/\n      SELECT                                                            /*COPY*/\n        WHEN ABBREV(parm_val.parm_inx, \"&\")               |,            /*COPY*/\n             ABBREV(parm_val.parm_inx, \"*\")               THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"= '\"parm_val.parm_inx\"'\"           /*COPY*/\n        WHEN DATATYPE(parm_val.parm_inx, \"NUM\")           THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"=\" parm_val.parm_inx               /*COPY*/\n        WHEN WORDPOS(parm_val.parm_inx, \"FALSE TRUE\") > 0 THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"=\" parm_val.parm_inx               /*COPY*/\n        WHEN (LEFT(parm_val.parm_inx,1) = \"'\"             & ,           /*COPY*/\n              RIGHT(parm_val.parm_inx,1) = \"'\")           | ,           /*COPY*/\n             INDEX(parm_val.parm_inx,':') > 0             | ,           /*COPY*/\n             INDEX(parm_val.parm_inx,'*') > 0             | ,           /*COPY*/\n             INDEX(parm_val.parm_inx,'%') > 0             | ,           /*COPY*/\n             INDEX(parm_val.parm_inx,'=') > 0             THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"= parm_val.\"parm_inx               /*COPY*/\n        WHEN INDEX(STRIP(parm_val.parm_inx), \" \") > 0     THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"=\" parm_val.parm_inx               /*COPY*/\n      OTHERWISE                                                         /*COPY*/\n          ADDRESS \"MVS\" \"SUBCOM TSO\"                                    /*COPY*/\n          IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE       /*COPY*/\n          PARSE VALUE parm_val.parm_inx WITH PDS_name '(' rest          /*COPY*/\n          SELECT                                                        /*COPY*/\n            WHEN \u00ac(TSO_avail)                            THEN           /*COPY*/\n                INTERPRET parm.parm_inx \"=\" parm_val.parm_inx           /*COPY*/\n            WHEN SYSVAR(\"SYSNEST\") = 'YES'               THEN           /*COPY*/\n                INTERPRET parm.parm_inx \"=\" parm_val.parm_inx           /*COPY*/\n            WHEN (INDEX(rest, \")\") > 0                   &,             /*COPY*/\n                 (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")   |,             /*COPY*/\n                  ABBREV(rest, \"0)\")))                   THEN           /*COPY*/\n                INTERPRET parm.parm_inx \"= '\"parm_val.parm_inx\"'\"       /*COPY*/\n            WHEN (LISTDSI(parm_val.parm_inx)       <= 4  | ,            /*COPY*/\n                  LISTDSI(\"'\"parm_val.parm_inx\"'\") <= 4  | ,            /*COPY*/\n                  LISTDSI(\"'\"PDS_name\"'\")          <= 4  | ,            /*COPY*/\n                  LISTDSI(PDS_name)                <= 4) THEN           /*COPY*/\n                INTERPRET parm.parm_inx \"= parm_val.\"parm_inx           /*COPY*/\n          OTHERWISE                                                     /*COPY*/\n                INTERPRET parm.parm_inx \"=\" parm_val.parm_inx           /*COPY*/\n          END                                                           /*COPY*/\n          INTERPRET parm.parm_inx \"=\" parm_val.parm_inx                 /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM                              /*COPY*/\n  IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'                   /*COPY*/\n     ELSE ZERRALRM = 'NO'                                               /*COPY*/\n  IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                       /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ002)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ok='*'                            /* Ignore all non-0 RCs           */\n    ADDRESS \"TSO\" \"ALTLIB DEACT APPLICATION (EXEC)\"\n    ADDRESS \"ISPEXEC\" \"LIBDEF ISPTLIB\"\n    ADDRESS \"ISPEXEC\" \"LIBDEF ISPSLIB\"\n    ADDRESS \"ISPEXEC\" \"LIBDEF ISPPLIB\"\n    ADDRESS \"ISPEXEC\" \"LIBDEF ISPMLIB\"\n    ADDRESS \"ISPEXEC\" \"FTCLOSE\"\n    ZISPFRC = exit_error\n    ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"\nEXIT exit_error                     /* EXIT with error return code    */\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok = '*' THEN RETURN  /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n            PARSE PULL eresult                                          /*COPY*/\n            eresults = STRIP(eresults \"NL ===>\" eresult)                /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n      nextl = SOURCELINE(elineno + e_i)                                 /*COPY*/\n      IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)       /*COPY*/\n      sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                     /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n      ecause  = ERRORTEXT(RC)       /* Brief description of error     *//*COPY*/\n      expandl = \"Can't INTERPRET source with SYNTAX errors!\"            /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n      ecause  = CONDITION('D')      /* Brief description of error     *//*COPY*/\n      full_line = sourcel           /* Begin getting EXECuted source  *//*COPY*/\n      PARSE VALUE full_line WITH srcl ';' full_line                     /*COPY*/\n      IF \u00ac(ABBREV(STRIP(srcl),\"CALL\")) &,                               /*COPY*/\n         \u00ac(ABBREV(STRIP(srcl),\"SAY\"))  THEN INTERPRET \"evals =\" srcl    /*COPY*/\n          ELSE evals = \"\"                                               /*COPY*/\n      IF DATATYPE(evals, \"NUM\") | evals = \"\" THEN evals = srcl          /*COPY*/\n      expandl = evals                                                   /*COPY*/\n      DO WHILE full_line \u00ac= ''      /* loop to handle ';' in source   *//*COPY*/\n          PARSE VALUE full_line WITH srcl ';' full_line                 /*COPY*/\n          IF \u00ac(ABBREV(STRIP(srcl),\"CALL\")) THEN INTERPRET \"evals =\" srcl/*COPY*/\n              ELSE evals = \"\"                                           /*COPY*/\n          IF DATATYPE(evals, \"NUM\") | evals = \"\" THEN evals = srcl      /*COPY*/\n          expandl = expandl ';' evals                                   /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR'      THEN           /*COPY*/\n         emsg = ZERRLM                                                  /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') = 'VAR' & SYSMSGLVL1 \u00ac= \"\" THEN           /*COPY*/\n         IF SYMBOL('SYSMSGLVL2') = 'VAR'                 THEN           /*COPY*/\n              emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                         /*COPY*/\n         ELSE emsg = SYSMSGLVL1                                         /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      emsg = 'No available ERROR description.'                          /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0 THEN                      /*COPY*/\n     QUEUE \"SYSREASON: '\"SYSREASON\"'\"                                   /*COPY*/\n  IF etype = 'NOVALUE' THEN exit_error = 4   /* Set EXIT error level  *//*COPY*/\n     ELSE exit_error = RC                                               /*COPY*/\n  erc = exit_error      /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  TRACE(\"O\")                                                            /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresults = 1 TO eresult.0                                          /*COPY*/\n      PARSE PULL eresult.eresults                                       /*COPY*/\n  END                                                                   /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls) /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY CENTER(LEFT('          Error Type:' etype,80),ls)                 /*COPY*/\n  SAY CENTER(LEFT('         Error Cause:' ecause,80),ls)                /*COPY*/\n  SAY CENTER(LEFT('                  RC:' erc,80),ls)                   /*COPY*/\n  SAY CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)             /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n      SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)  /*COPY*/\n  END                                                                   /*COPY*/\n  SAY CENTER(LEFT('         Source Line:' elineno,80),ls)               /*COPY*/\n  SAY LEFT('   Error Description:' emsg,ls)                             /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY LEFT('Source line reads as:' sourcel,ls)                          /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY LEFT('  Source EXECutes as:' expandl,ls)                          /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\n  SAY ''                                                                /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = exit_error              /* SET ISPF RC to exit_error      *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT exit_error                     /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFGRPS": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x00\\x01\\x00\\x13\\x0f\\x01\\x17(O\\tF\\x01k\\x01M\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2000-05-09T00:00:00", "modifydate": "2017-10-11T09:46:00", "lines": 363, "newlines": 333, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n\n This REXX Indicates whether the user is a member of a GROUP or RETURNs\n      all groups to which a user is CONNECTed.  If a GROUP is specified,\n      it RETURNs TRUE when the USER is CONNECTed to group and RETURNs\n      FALSE if user is not.  If no GROUP is not specified, it RETURNs a\n      list of all GROUPs the USER is CONNECTed to separated by spaces.\n\n                           --- EXAMPLE ---\nTSO <%>RACFGRPS checkgroup <TEST(trace_option)>\nTSO <%>RACFGRPS -H -- To display help for this REXX\n\n  Arguments: checkgroup  - RACF Group to check\n             inparms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: NONE\nOther EXECS: NONE\n\nEXEC History\n\n REXX EXEC Name: RACFGRPS\n         Author: AL Hulsebosch (HUL2353)\n         Writen: 09MAY00\n        History: 09MAY00 - Version 1.0 - This is a reformat of a sample\n                           REXX (RACFGRPS) obtained from the CBT Tapes.\n\n***************************** Rexx ***********************************/\nmsgstat = MSG(\"OFF\")\nPARSE ARG checkgroup inparms /* Place arguments here */\n\nIF WORDPOS(checkgroup,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n    ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"  /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nCALL GET_GROUPS\n\nPARSE SOURCE . calltype .\nSELECT\n  WHEN calltype = 'COMMAND'               THEN\n    CALL SET_MSG , \"You are CONNECTed to the following GROUPs: \" allgroups, \"NO\"\n  WHEN checkgroup = \"\"                    THEN RETURN allgroups\n  WHEN WORDPOS(checkgroup, allgroups) > 0 THEN RETURN TRUE\nOTHERWISE;                                     RETURN FALSE; END\n\nmsgstat = MSG(msgstat)\nEXIT exit_error\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE = 1; FALSE = 0  /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  valid_parms = \"TEST(O)\"\n  match_length = 4                /* NP-Parms match on first # chars  */\n  IF valid_parms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  no_submited = 0\n  SYSUID = SYSVAR(\"SYSUID\")\n  user_prefix = LEFT(SYSUID,4)\n  exit_error = 0; sql_error = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG exit_or_return .                                                    /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n      source.i = SOURCELINE(i + 1)  /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO   /* No ISPF, use SAY to display help            *//*COPY*/\n      DO i = 1 TO i                                                     /*COPY*/\n          SAY source.i                                                  /*COPY*/\n      END                                                               /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n      PARSE SOURCE . . rname .      /* Get REXX EXEC name             *//*COPY*/\n                                                                        /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\" /*COPY*/\n      DO i = 1 TO i    /* Build HELP table to display                 *//*COPY*/\n          source = source.i                                             /*COPY*/\n          ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"                             /*COPY*/\n      END                                                               /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                          /*COPY*/\n      ZTDMARK = CENTER(\"----> END of Help <----\",80)                    /*COPY*/\n      ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"     /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                        /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',exit_or_return,3) THEN RETURN                        /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Possitional Parms in a           /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  vp_list = valid_parms ' '; in_list = inparms ' '                      /*COPY*/\n  parm_list = ''; parm_error_list = ''                                  /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(valid_parms) UNTIL vp_list = ''                  /*COPY*/\n      PARSE VALUE vp_list WITH parm.linx '(' parm_val.linx ') ' vp_list /*COPY*/\n      parm_list = parm_list STRIP(LEFT(parm.linx,match_length))         /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(in_list, '(') > 0                                      /*COPY*/\n      PARSE VALUE in_list WITH parm '(' value ') ' in_list              /*COPY*/\n      UPPER parm           /* Don't want to translate value to UPPER */ /*COPY*/\n      parm = STRIP(parm)                                                /*COPY*/\n      parm_number = WORDPOS(STRIP(LEFT(parm,match_length)), parm_list)  /*COPY*/\n      IF parm_number > 0 THEN parm_val.parm_number = value              /*COPY*/\n      ELSE IF INDEX(value,\")\") > 0 THEN                                 /*COPY*/\n           parm_error_list = parm_error_list parm\"(\"value               /*COPY*/\n      ELSE parm_error_list = parm_error_list parm\"(\"value\")\"            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN parm_error_list \u00ac= '' & accept_all = TRUE THEN                 /*COPY*/\n        anything_else = STRIP(in_list) parm_error_list                  /*COPY*/\n    WHEN parm_error_list \u00ac= ''                     THEN DO              /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"parm_error_list\"' not valid Parm(s) for\" rname\"!\", \"YES\" /*COPY*/\n        EXIT 8                                                          /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      anything_else = STRIP(in_list)                                    /*COPY*/\n  END                                                                   /*COPY*/\n  DO parm_inx = 1 TO linx                                               /*COPY*/\n      SELECT                                                            /*COPY*/\n        WHEN ABBREV(parm_val.parm_inx, \"&\")               |,            /*COPY*/\n             ABBREV(parm_val.parm_inx, \"*\")               THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"= '\"parm_val.parm_inx\"'\"           /*COPY*/\n        WHEN DATATYPE(parm_val.parm_inx, \"NUM\")           THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"=\" parm_val.parm_inx               /*COPY*/\n        WHEN WORDPOS(parm_val.parm_inx, \"FALSE TRUE\") > 0 THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"=\" parm_val.parm_inx               /*COPY*/\n        WHEN (LEFT(parm_val.parm_inx,1) = \"'\"             & ,           /*COPY*/\n              RIGHT(parm_val.parm_inx,1) = \"'\")           | ,           /*COPY*/\n             INDEX(parm_val.parm_inx,':') > 0             | ,           /*COPY*/\n             INDEX(parm_val.parm_inx,'*') > 0             | ,           /*COPY*/\n             INDEX(parm_val.parm_inx,'%') > 0             | ,           /*COPY*/\n             INDEX(parm_val.parm_inx,'=') > 0             THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"= parm_val.\"parm_inx               /*COPY*/\n        WHEN INDEX(STRIP(parm_val.parm_inx), \" \") > 0     THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"=\" parm_val.parm_inx               /*COPY*/\n      OTHERWISE                                                         /*COPY*/\n          ADDRESS \"MVS\" \"SUBCOM TSO\"                                    /*COPY*/\n          IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE       /*COPY*/\n          PARSE VALUE parm_val.parm_inx WITH PDS_name '(' rest          /*COPY*/\n          SELECT                                                        /*COPY*/\n            WHEN \u00ac(TSO_avail)                            THEN           /*COPY*/\n                INTERPRET parm.parm_inx \"=\" parm_val.parm_inx           /*COPY*/\n            WHEN SYSVAR(\"SYSNEST\") = 'YES'               THEN           /*COPY*/\n                INTERPRET parm.parm_inx \"=\" parm_val.parm_inx           /*COPY*/\n            WHEN (INDEX(rest, \")\") > 0                   &,             /*COPY*/\n                 (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")   |,             /*COPY*/\n                  ABBREV(rest, \"0)\")))                   THEN           /*COPY*/\n                INTERPRET parm.parm_inx \"= '\"parm_val.parm_inx\"'\"       /*COPY*/\n            WHEN (LISTDSI(parm_val.parm_inx)       <= 4  | ,            /*COPY*/\n                  LISTDSI(\"'\"parm_val.parm_inx\"'\") <= 4  | ,            /*COPY*/\n                  LISTDSI(\"'\"PDS_name\"'\")          <= 4  | ,            /*COPY*/\n                  LISTDSI(PDS_name)                <= 4) THEN           /*COPY*/\n                INTERPRET parm.parm_inx \"= parm_val.\"parm_inx           /*COPY*/\n          OTHERWISE                                                     /*COPY*/\n                INTERPRET parm.parm_inx \"=\" parm_val.parm_inx           /*COPY*/\n          END                                                           /*COPY*/\n          INTERPRET parm.parm_inx \"=\" parm_val.parm_inx                 /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM                              /*COPY*/\n  IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'                   /*COPY*/\n     ELSE ZERRALRM = 'NO'                                               /*COPY*/\n  IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                       /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ002)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n      Go to the ADDRESS Spaces ACEE and Get the list of GROUPs\n***********************************************************************/\nGET_GROUPS:\n  ASXB_ptr      = STORAGE(224,4)\n  ASXB          = STORAGE(D2X(C2D(ASXB_ptr) + 108),4)\n  ACEE          = STORAGE(D2X(C2D(ASXB) + 200),4)\n  ACEE_cgrp     = STORAGE(D2X(C2D(ACEE) + 116),4)\n  ACEE_grpl_len = C2D(STORAGE(D2X(C2D(ACEE_cgrp) + 5),3))\n  ACEE_grpl     = STORAGE(D2X(C2D(ACEE_cgrp) + 32),ACEE_grpl_len)\n\n  allgroups = \"\"\n  DO i = 1 TO C2D(STORAGE(D2X(C2D(ACEE_cgrp) + 8),2))\n    PARSE VALUE ACEE_grpl WITH 1 group 9 . 25 ACEE_grpl\n    allgroups = group allgroups\n  END\nRETURN\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok = '*' THEN RETURN  /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n            PARSE PULL eresult                                          /*COPY*/\n            eresults = STRIP(eresults \"NL ===>\" eresult)                /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n      nextl = SOURCELINE(elineno + e_i)                                 /*COPY*/\n      IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)       /*COPY*/\n      sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                     /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n      ecause  = ERRORTEXT(RC)       /* Brief description of error     *//*COPY*/\n      expandl = \"Can't INTERPRET source with SYNTAX errors!\"            /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n      ecause  = CONDITION('D')      /* Brief description of error     *//*COPY*/\n      full_line = sourcel           /* Begin getting EXECuted source  *//*COPY*/\n      PARSE VALUE full_line WITH srcl ';' full_line                     /*COPY*/\n      IF \u00ac(ABBREV(STRIP(srcl),\"CALL\")) &,                               /*COPY*/\n         \u00ac(ABBREV(STRIP(srcl),\"SAY\"))  THEN INTERPRET \"evals =\" srcl    /*COPY*/\n          ELSE evals = \"\"                                               /*COPY*/\n      IF DATATYPE(evals, \"NUM\") | evals = \"\" THEN evals = srcl          /*COPY*/\n      expandl = evals                                                   /*COPY*/\n      DO WHILE full_line \u00ac= ''      /* loop to handle ';' in source   *//*COPY*/\n          PARSE VALUE full_line WITH srcl ';' full_line                 /*COPY*/\n          IF \u00ac(ABBREV(STRIP(srcl),\"CALL\")) THEN INTERPRET \"evals =\" srcl/*COPY*/\n              ELSE evals = \"\"                                           /*COPY*/\n          IF DATATYPE(evals, \"NUM\") | evals = \"\" THEN evals = srcl      /*COPY*/\n          expandl = expandl ';' evals                                   /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR'      THEN           /*COPY*/\n         emsg = ZERRLM                                                  /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') = 'VAR' & SYSMSGLVL1 \u00ac= \"\" THEN           /*COPY*/\n         IF SYMBOL('SYSMSGLVL2') = 'VAR'                 THEN           /*COPY*/\n              emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                         /*COPY*/\n         ELSE emsg = SYSMSGLVL1                                         /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      emsg = 'No available ERROR description.'                          /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0 THEN                      /*COPY*/\n     QUEUE \"SYSREASON: '\"SYSREASON\"'\"                                   /*COPY*/\n  IF etype = 'NOVALUE' THEN exit_error = 4   /* Set EXIT error level  *//*COPY*/\n     ELSE exit_error = RC                                               /*COPY*/\n  erc = exit_error      /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  TRACE(\"O\")                                                            /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresults = 1 TO eresult.0                                          /*COPY*/\n      PARSE PULL eresult.eresults                                       /*COPY*/\n  END                                                                   /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls) /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY CENTER(LEFT('          Error Type:' etype,80),ls)                 /*COPY*/\n  SAY CENTER(LEFT('         Error Cause:' ecause,80),ls)                /*COPY*/\n  SAY CENTER(LEFT('                  RC:' erc,80),ls)                   /*COPY*/\n  SAY CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)             /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n      SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)  /*COPY*/\n  END                                                                   /*COPY*/\n  SAY CENTER(LEFT('         Source Line:' elineno,80),ls)               /*COPY*/\n  SAY LEFT('   Error Description:' emsg,ls)                             /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY LEFT('Source line reads as:' sourcel,ls)                          /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY LEFT('  Source EXECutes as:' expandl,ls)                          /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\n  SAY ''                                                                /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = exit_error              /* SET ISPF RC to exit_error      *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT exit_error                     /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STARTUP": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03M\\x00\\x00\\x01\\x023\\x8f\\x01\\x17(O\\tF\\x00\\xb6\\x00Z\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "03.77", "flags": 0, "createdate": "2002-12-04T00:00:00", "modifydate": "2017-10-11T09:46:00", "lines": 182, "newlines": 90, "modlines": 0, "user": "AL-FERG"}, "text": "/*                                   REXX\n    Copy this member to your ISPF.PROFILE and update INITIALIZE_REXX\n         Function at end, as needed.\n\n    This member will be run immediately after the @SCSTART Startup\n         REXX is run. This member would be run instead of the\n         automated startup of ISPF, so include that if it is needed.\n\n    Works well in DR situation with Ed Jaffe's TSO SUB=MSTR UserMods\n         ftp://phoenixsoftware.com/pub/demo/tsomods.xmi\n\n-- HISTORY --\n   2015-10-30 - TSAZFA - v3.75 - Minor Optimization/Re-Factoring\n   2015-10-30 - TSAZFA - v3.54 - Minor Cleanup & Re-Factoring\n   2015-10-30 - TSAZFA - v3.53 - Tweaks to move things to @SCSTART\n   2015-10-12 - TSAZFA - v3.39 - Initial SCDC \"Generic\" Version\n                                     REXX                            */\n\nCALL INITIALIZE_REXX\nSELECT\n  WHEN ABBREV(MVSVAR(\"SYSNAME\"), \"DEV\") THEN CALL SETUP_FOR_DEVL\n  WHEN ABBREV(MVSVAR(\"SYSNAME\"), \"INS\") THEN CALL SETUP_FOR_TECH\nOTHERWISE;                                   CALL SETUP_FOR_PROD; END\n\nCALL SETUP_FOR_USER\nCALL GET_CURRENT_ALLOCATIONS\n        /* Setup ISPF DDs                                            */\nIF ISPLLIB \u00ac= \"\" THEN CALL UPDATE_DD(\"ISPLLIB\" ISPLLIB)\nIF ISPMLIB \u00ac= \"\" THEN CALL UPDATE_DD(\"ISPMLIB\" ISPMLIB)\nIF ISPPLIB \u00ac= \"\" THEN CALL UPDATE_DD(\"ISPPLIB\" ISPPLIB)\nIF ISPSLIB \u00ac= \"\" THEN CALL UPDATE_DD(\"ISPSLIB\" ISPSLIB)\nIF ISPTLIB \u00ac= \"\" THEN CALL UPDATE_DD(\"ISPTLIB\" ISPTLIB)\nIF ISPPROF \u00ac= \"\" THEN x = BPXWDYN(\"ALLOC DD(ISPPROF) DSN(\"ISPPROF\") SHR REUSE\")\nIF ISPTABL \u00ac= \"\" THEN x = BPXWDYN(\"ALLOC DD(ISPTABL) DSN(\"ISPTABL\") SHR REUSE\")\n        /* Setup TSO DDs                                             */\nIF SYSHELP \u00ac= \"\" THEN CALL UPDATE_DD(\"SYSHELP\" SYSHELP)\nIF SYSPROC \u00ac= \"\" THEN CALL UPDATE_DD(\"SYSPROC\" SYSPROC)\nIF SYSEXEC \u00ac= \"\" THEN CALL UPDATE_DD(\"SYSEXEC\" SYSEXEC)\n        /* PULL any STACKed commands to be pushed later              */\n_queue. = \"\"; _queue.0 = QUEUED()\nIF _queue.0 > 0 THEN DO k = 1 TO _queue.0; PULL _queue.k; END\n        /* Invoke ISPF, after Exiting from REXX.                     */\nPUSH \"ISPSTART PANEL(ISR@PRIM) NEWAPPL(ISR) SHRPROF\"\n        /* Push TSOLIB setup onto Queue                              */\nIF (TSOLIB STEPLIB) \u00ac= \"\" THEN DO         /* Use TSOLIB for APF LIBs */\n   PARSE VALUE (TSOLIB STEPLIB) WITH front \"***\" middle \"***\" back\n   PUSH \"TSOLIB ACT DSN(\"STRIP(front middle back)\")\"\nEND\nIF _queue.0 > 0 THEN DO k = 1 TO _queue.0 /* Don't Start ISPF Twice! */\n   IF \u00ac(ABBREV(_queue.k, \"ISPSTART \")) THEN PUSH _queue.k\nEND\n\nEXIT\n/*---------------------------------------------------------------------*\n          Build list of currently Allocated DD Concatinations\n *---------------------------------------------------------------------*/\nGET_CURRENT_ALLOCATIONS:\n  my_DD = 0; concat. = \"\"; dd_lst = \"\"\n  my_DDs = \"ISPLLIB ISPMLIB ISPPLIB ISPSLIB ISPTLIB\",\n           \"SYSHELP SYSPROC SYSEXEC STEPLIB\"\n  DO j = 1 UNTIL list \u00ac= 0\n     x = BPXWDYN(\"INFO INRELNO(\"j\") INRTDDN(ddn) INRTDSN(dsn) INRTLST(list)\")\n       IF x \u00ac= 0 THEN EXIT BPXWDYN_ERR(x \"INFO\" \"DSN: '\"dsn\"' LIST:\" list)\n     IF ddn \u00ac= \"\" & WORDPOS(ddn, dd_lst) = 0 THEN dd_lst = dd_lst ddn\n     SELECT\n       WHEN ddn = \"\" & \u00ac(my_DD)                 THEN ITERATE j\n       WHEN WORDPOS(ddn, my_DDs) > 0 | ddn = \"\" THEN DO\n          IF ddn \u00ac= \"\" THEN this_dd = ddn\n          my_DD = 1; concat.this_dd = concat.this_dd dsn\n         END\n     OTHERWISE; my_DD = 0; END\n  END\nRETURN\n/*---------------------------------------------------------------------*\n          Update concatinations for SCDC Development Systems\n *---------------------------------------------------------------------*/\nSETUP_FOR_DEVL:\n  NOP    /* Nothing currently changed for DEVL System                  */\nRETURN\n/*---------------------------------------------------------------------*\n          Update concatinations for SCDC Techie Install Systems\n *---------------------------------------------------------------------*/\nSETUP_FOR_TECH:\n  NOP    /* Nothing currently changed for INSTALL Systems              */\nRETURN\n/*---------------------------------------------------------------------*\n          Update concatinations for SCDC Production Systems\n *---------------------------------------------------------------------*/\nSETUP_FOR_PROD:\n  NOP    /* Nothing currently changed for PROD System                  */\nRETURN\n/*---------------------------------------------------------------------*\n          Update concatinations for User's Personal ISPF DSNs\n *---------------------------------------------------------------------*/\nSETUP_FOR_USER:               /* Setup existing personal ISPF DSNs     */\n  IF SYSDSN(\"ISPF.ISPLLIB\") = \"OK\" THEN IF,\n     ISPLLIB = \"\" THEN ISPLLIB = USERID()\".ISPF.ISPLLIB ***\"\n                  ELSE ISPLLIB = USERID()\".ISPF.ISPLLIB\" ISPLLIB\n  IF SYSDSN(\"ISPF.ISPMLIB\") = \"OK\" THEN IF,\n     ISPMLIB = \"\" THEN ISPMLIB = USERID()\".ISPF.ISPMLIB ***\"\n                  ELSE ISPMLIB = USERID()\".ISPF.ISPMLIB\" ISPMLIB\n  IF SYSDSN(\"ISPF.ISPPLIB\") = \"OK\" THEN IF,\n     ISPPLIB = \"\" THEN ISPPLIB = USERID()\".ISPF.ISPPLIB ***\"\n                  ELSE ISPPLIB = USERID()\".ISPF.ISPPLIB\" ISPPLIB\n  IF SYSDSN(\"ISPF.ISPSLIB\") = \"OK\" THEN IF,\n     ISPSLIB = \"\" THEN ISPSLIB = USERID()\".ISPF.ISPSLIB ***\"\n                  ELSE ISPSLIB = USERID()\".ISPF.ISPSLIB\" ISPSLIB\n  IF SYSDSN(\"ISPF.ISPTLIB\") = \"OK\" THEN IF,\n     ISPTLIB = \"\" THEN ISPTLIB = USERID()\".ISPF.PROFILE\",\n                                 USERID()\".ISPF.ISPTLIB ***\"\n                  ELSE ISPTLIB = USERID()\".ISPF.PROFILE\",\n                                 USERID()\".ISPF.ISPTLIB\" ISPTLIB\n                              /* Setup existing personal TSO DSNs      */\n  IF SYSDSN(\"Z.EXEC\") = \"OK\"       THEN IF,\n     SYSEXEC = \"\" THEN SYSEXEC = USERID()\".Z.EXEC ***\"\n                  ELSE SYSEXEC = USERID()\".Z.EXEC\" SYSEXEC\n  IF SYSDSN(\"Z.HELP\") = \"OK\"       THEN IF,\n     SYSHELP = \"\" THEN SYSHELP = USERID()\".Z.HELP ***\"\n                  ELSE SYSHELP = USERID()\".Z.HELP\" SYSHELP\n  IF SYSDSN(\"Z.CLIST\") = \"OK\"      THEN IF, /* Move personal CList 1st */\n     SYSPROC = \"\" THEN SYSPROC = USERID()\".Z.CLIST ***\"\n                  ELSE SYSPROC = USERID()\".Z.CLIST\" SYSPROC\n  IF SYSDSN(\"Z.LOADLIB\") = \"OK\"    THEN IF,\n     TSOLIB = \"\"  THEN TSOLIB = \"Z.LOADLIB ***\"\n                  ELSE TSOLIB = \"Z.LOADLIB\" TSOLIB\n  IF SYSDSN(\"Z.TSOLIB\") = \"OK\"     THEN IF,\n     TSOLIB = \"\"  THEN TSOLIB = \"Z.TSOLIB ***\"\n                  ELSE TSOLIB = \"Z.TSOLIB\" TSOLIB\nRETURN\n/*---------------------------------------------------------------------*\n                Use BPXWDYN to update DD concatinations\n *---------------------------------------------------------------------*/\nUPDATE_DD:\nARG dd_name front \"***\" back\n  DDLIST = dd_name; this_DD = dd_name; DSLIST = front concat.dd_name back\n  x = BPXWDYN(\"ALLOC DD(\"dd_name\") DSN(\"WORD(DSLIST,1)\") SHR REUSE\")\n    IF x \u00ac= 0 THEN EXIT BPXWDYN_ERR(x \"ALLOC\" dd_name WORD(DSLIST,1))\n  DO i = 2 TO WORDS(DSLIST)\n     x = BPXWDYN(\"ALLOC DD(TMP\"i\") DSN(\"WORD(DSLIST,i)\") SHR REUSE\")\n       IF x \u00ac= 0 THEN EXIT BPXWDYN_ERR(x \"ALLOC TMP\"i WORD(DSLIST,i))\n     DDLIST = DDLIST\",TMP\"i\n  END\n  IF WORDS(DSLIST) > 1 THEN DO\n     x = BPXWDYN(\"CONCAT DDLIST(\"DDLIST\")\")\n       IF x \u00ac= 0 THEN EXIT BPXWDYN_ERR(x \"CONCAT\" dd_name DDLIST)\n  END\nRETURN\n/*---------------------------------------------------------------------*\n      Display BPXWDYN error information for non-zero Return Codes\n *---------------------------------------------------------------------*/\nBPXWDYN_ERR:\nPARSE ARG BPXWDYN_rc arg2 arg3\n  SAY RIGHT(arg2,7) \"of:\" arg3\n  IF BPXWDYN_rc > 0 THEN DO\n     PARSE VALUE RIGHT(D2X(BPXWDYN_rc),8,\"0\") WITH dyn_EC 5 dyn_RC .\n     SAY RIGHT(arg2,7) \"RC:\" BPXWDYN_rc \"(\"dyn_EC dyn_RC\")\"\n    END\n  ELSE DO; dyn_EC=ABS(BPXWDYN_rc); SAY RIGHT(arg2,7) \"RC:\" BPXWDYN_rc; END\n  IF SYMBOL(\"S99MSG.0\")=\"VAR\" THEN DO i=1 TO S99MSG.0;SAY \"  \"S99MSG.i;END\nRETURN dyn_EC\n/*---------------------------------------------------------------------*\n    Personal setup of initial TSO/ISPF/STEPLIB/TSOLIB Concatinations\n             -- This can include Group or CBT libraries --\n    NOTE: STEPLIB & TSOLIB need to be enclosed in Single Quotes.\n *---------------------------------------------------------------------*/\nINITIALIZE_REXX:\n          /* Standard TSO DDs                                          */\n  STEPLIB = \"\"                             /* Use STEPLIB for APF LIBs */\n  SYSEXEC = \"\"\n  SYSHELP = \"\"\n  SYSPROC = \"\"\n  TSOLIB  = \"\"                             /* Use TSOLIB for APF LIBs  */\n          /* ISPF Personal Table allocations                           */\n  ISPPROF = \"\"\n  ISPTABL = ISPPROF\n          /* Standard ISPF DDs                                         */\n  ISPLLIB = \"\"                              /* Use as a nonAPF TASKLIB */\n  ISPMLIB = \"\"\n  ISPPLIB = \"\"\n  ISPSLIB = \"\"\n  ISPTLIB = \"\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT963/CBT.V500.FILE963.PDS/EXEC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT963/CBT.V500.FILE963.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}